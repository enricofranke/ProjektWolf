; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\buffer.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_g_pMemoryBlocks:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__E6E7469F_winioctl@h DB 01H
__08182E14_stralign@h DB 01H
__596A73F5_buffer@c DB 01H
msvcjmc	ENDS
PUBLIC	_InitializeBuffer
PUBLIC	_UninitializeBuffer
PUBLIC	_AllocateBuffer
PUBLIC	_FreeBuffer
PUBLIC	_IsExecutableAddress
PUBLIC	__JustMyCode_Default
EXTRN	_memset:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__VirtualQuery@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\buffer.c
;	COMDAT _GetMemoryBlock
_TEXT	SEGMENT
_pSlot$1 = -20						; size = 4
_pBlock$ = -8						; size = 4
_pOrigin$ = 8						; size = 4
_GetMemoryBlock PROC					; COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __596A73F5_buffer@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 153  :     PMEMORY_BLOCK pBlock;
; 154  : #if defined(_M_X64) || defined(__x86_64__)
; 155  :     ULONG_PTR minAddr;
; 156  :     ULONG_PTR maxAddr;
; 157  : 
; 158  :     SYSTEM_INFO si;
; 159  :     GetSystemInfo(&si);
; 160  :     minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;
; 161  :     maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;
; 162  : 
; 163  :     // pOrigin Â± 512MB
; 164  :     if ((ULONG_PTR)pOrigin > MAX_MEMORY_RANGE && minAddr < (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE)
; 165  :         minAddr = (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE;
; 166  : 
; 167  :     if (maxAddr > (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE)
; 168  :         maxAddr = (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE;
; 169  : 
; 170  :     // Make room for MEMORY_BLOCK_SIZE bytes.
; 171  :     maxAddr -= MEMORY_BLOCK_SIZE - 1;
; 172  : #endif
; 173  : 
; 174  :     // Look the registered blocks for a reachable one.
; 175  :     for (pBlock = g_pMemoryBlocks; pBlock != NULL; pBlock = pBlock->pNext)

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_pMemoryBlocks
  0002d	89 45 f8	 mov	 DWORD PTR _pBlock$[ebp], eax
  00030	eb 08		 jmp	 SHORT $LN4@GetMemoryB
$LN2@GetMemoryB:
  00032	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 4d f8	 mov	 DWORD PTR _pBlock$[ebp], ecx
$LN4@GetMemoryB:
  0003a	83 7d f8 00	 cmp	 DWORD PTR _pBlock$[ebp], 0
  0003e	74 13		 je	 SHORT $LN3@GetMemoryB

; 176  :     {
; 177  : #if defined(_M_X64) || defined(__x86_64__)
; 178  :         // Ignore the blocks too far.
; 179  :         if ((ULONG_PTR)pBlock < minAddr || (ULONG_PTR)pBlock >= maxAddr)
; 180  :             continue;
; 181  : #endif
; 182  :         // The block has at least one unused slot.
; 183  :         if (pBlock->pFree != NULL)

  00040	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00043	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00047	74 08		 je	 SHORT $LN8@GetMemoryB

; 184  :             return pBlock;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  0004c	e9 85 00 00 00	 jmp	 $LN1@GetMemoryB
$LN8@GetMemoryB:

; 185  :     }

  00051	eb df		 jmp	 SHORT $LN2@GetMemoryB
$LN3@GetMemoryB:

; 186  : 
; 187  : #if defined(_M_X64) || defined(__x86_64__)
; 188  :     // Alloc a new block above if not found.
; 189  :     {
; 190  :         LPVOID pAlloc = pOrigin;
; 191  :         while ((ULONG_PTR)pAlloc >= minAddr)
; 192  :         {
; 193  :             pAlloc = FindPrevFreeRegion(pAlloc, (LPVOID)minAddr, si.dwAllocationGranularity);
; 194  :             if (pAlloc == NULL)
; 195  :                 break;
; 196  : 
; 197  :             pBlock = (PMEMORY_BLOCK)VirtualAlloc(
; 198  :                 pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
; 199  :             if (pBlock != NULL)
; 200  :                 break;
; 201  :         }
; 202  :     }
; 203  : 
; 204  :     // Alloc a new block below if not found.
; 205  :     if (pBlock == NULL)
; 206  :     {
; 207  :         LPVOID pAlloc = pOrigin;
; 208  :         while ((ULONG_PTR)pAlloc <= maxAddr)
; 209  :         {
; 210  :             pAlloc = FindNextFreeRegion(pAlloc, (LPVOID)maxAddr, si.dwAllocationGranularity);
; 211  :             if (pAlloc == NULL)
; 212  :                 break;
; 213  : 
; 214  :             pBlock = (PMEMORY_BLOCK)VirtualAlloc(
; 215  :                 pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
; 216  :             if (pBlock != NULL)
; 217  :                 break;
; 218  :         }
; 219  :     }
; 220  : #else
; 221  :     // In x86 mode, a memory block can be placed anywhere.
; 222  :     pBlock = (PMEMORY_BLOCK)VirtualAlloc(

  00053	8b f4		 mov	 esi, esp
  00055	6a 40		 push	 64			; 00000040H
  00057	68 00 30 00 00	 push	 12288			; 00003000H
  0005c	68 00 10 00 00	 push	 4096			; 00001000H
  00061	6a 00		 push	 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAlloc@16
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	89 45 f8	 mov	 DWORD PTR _pBlock$[ebp], eax

; 223  :         NULL, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
; 224  : #endif
; 225  : 
; 226  :     if (pBlock != NULL)

  00073	83 7d f8 00	 cmp	 DWORD PTR _pBlock$[ebp], 0
  00077	74 5a		 je	 SHORT $LN9@GetMemoryB

; 227  :     {
; 228  :         // Build a linked list of all the slots.
; 229  :         PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBlock + 1;

  00079	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  0007c	83 c0 20	 add	 eax, 32			; 00000020H
  0007f	89 45 ec	 mov	 DWORD PTR _pSlot$1[ebp], eax

; 230  :         pBlock->pFree = NULL;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00085	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 231  :         pBlock->usedCount = 0;

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  0008f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN7@GetMemoryB:

; 232  :         do
; 233  :         {
; 234  :             pSlot->pNext = pBlock->pFree;

  00096	8b 45 ec	 mov	 eax, DWORD PTR _pSlot$1[ebp]
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _pBlock$[ebp]
  0009c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009f	89 10		 mov	 DWORD PTR [eax], edx

; 235  :             pBlock->pFree = pSlot;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000a4	8b 4d ec	 mov	 ecx, DWORD PTR _pSlot$1[ebp]
  000a7	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 236  :             pSlot++;

  000aa	8b 45 ec	 mov	 eax, DWORD PTR _pSlot$1[ebp]
  000ad	83 c0 20	 add	 eax, 32			; 00000020H
  000b0	89 45 ec	 mov	 DWORD PTR _pSlot$1[ebp], eax

; 237  :         } while ((ULONG_PTR)pSlot - (ULONG_PTR)pBlock <= MEMORY_BLOCK_SIZE - MEMORY_SLOT_SIZE);

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _pSlot$1[ebp]
  000b6	2b 45 f8	 sub	 eax, DWORD PTR _pBlock$[ebp]
  000b9	3d e0 0f 00 00	 cmp	 eax, 4064		; 00000fe0H
  000be	76 d6		 jbe	 SHORT $LN7@GetMemoryB

; 238  : 
; 239  :         pBlock->pNext = g_pMemoryBlocks;

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_pMemoryBlocks
  000c9	89 08		 mov	 DWORD PTR [eax], ecx

; 240  :         g_pMemoryBlocks = pBlock;

  000cb	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000ce	a3 00 00 00 00	 mov	 DWORD PTR _g_pMemoryBlocks, eax
$LN9@GetMemoryB:

; 241  :     }
; 242  : 
; 243  :     return pBlock;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
$LN1@GetMemoryB:

; 244  : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000df	3b ec		 cmp	 ebp, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_GetMemoryBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\buffer.c
;	COMDAT _IsExecutableAddress
_TEXT	SEGMENT
tv70 = -236						; size = 4
_mi$ = -36						; size = 28
__$ArrayPad$ = -4					; size = 4
_pAddress$ = 8						; size = 4
_IsExecutableAddress PROC				; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __596A73F5_buffer@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 308  :     MEMORY_BASIC_INFORMATION mi;
; 309  :     VirtualQuery(pAddress, &mi, sizeof(mi));

  00032	8b f4		 mov	 esi, esp
  00034	6a 1c		 push	 28			; 0000001cH
  00036	8d 45 dc	 lea	 eax, DWORD PTR _mi$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pAddress$[ebp]
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualQuery@12
  00044	3b f4		 cmp	 esi, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 310  : 
; 311  :     return (mi.State == MEM_COMMIT && (mi.Protect & PAGE_EXECUTE_FLAGS));

  0004b	81 7d ec 00 10
	00 00		 cmp	 DWORD PTR _mi$[ebp+16], 4096 ; 00001000H
  00052	75 16		 jne	 SHORT $LN3@IsExecutab
  00054	8b 45 f0	 mov	 eax, DWORD PTR _mi$[ebp+20]
  00057	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0005c	74 0c		 je	 SHORT $LN3@IsExecutab
  0005e	c7 85 14 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv70[ebp], 1
  00068	eb 0a		 jmp	 SHORT $LN4@IsExecutab
$LN3@IsExecutab:
  0006a	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN4@IsExecutab:
  00074	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]

; 312  : }

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@IsExecutab
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00091	33 cd		 xor	 ecx, ebp
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  0009e	3b ec		 cmp	 ebp, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
  000a9	0f 1f 00	 npad	 3
$LN7@IsExecutab:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN6@IsExecutab
$LN6@IsExecutab:
  000b4	dc ff ff ff	 DD	 -36			; ffffffdcH
  000b8	1c 00 00 00	 DD	 28			; 0000001cH
  000bc	00 00 00 00	 DD	 $LN5@IsExecutab
$LN5@IsExecutab:
  000c0	6d		 DB	 109			; 0000006dH
  000c1	69		 DB	 105			; 00000069H
  000c2	00		 DB	 0
_IsExecutableAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\buffer.c
;	COMDAT _FreeBuffer
_TEXT	SEGMENT
_pSlot$1 = -44						; size = 4
_pTargetBlock$ = -32					; size = 4
_pPrev$ = -20						; size = 4
_pBlock$ = -8						; size = 4
_pBuffer$ = 8						; size = 4
_FreeBuffer PROC					; COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __596A73F5_buffer@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 268  :     PMEMORY_BLOCK pBlock = g_pMemoryBlocks;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_pMemoryBlocks
  0002d	89 45 f8	 mov	 DWORD PTR _pBlock$[ebp], eax

; 269  :     PMEMORY_BLOCK pPrev = NULL;

  00030	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pPrev$[ebp], 0

; 270  :     ULONG_PTR pTargetBlock = ((ULONG_PTR)pBuffer / MEMORY_BLOCK_SIZE) * MEMORY_BLOCK_SIZE;

  00037	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0003a	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  0003d	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00040	89 45 e0	 mov	 DWORD PTR _pTargetBlock$[ebp], eax
$LN2@FreeBuffer:

; 271  : 
; 272  :     while (pBlock != NULL)

  00043	83 7d f8 00	 cmp	 DWORD PTR _pBlock$[ebp], 0
  00047	0f 84 96 00 00
	00		 je	 $LN1@FreeBuffer

; 273  :     {
; 274  :         if ((ULONG_PTR)pBlock == pTargetBlock)

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00050	3b 45 e0	 cmp	 eax, DWORD PTR _pTargetBlock$[ebp]
  00053	75 7b		 jne	 SHORT $LN4@FreeBuffer

; 275  :         {
; 276  :             PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBuffer;

  00055	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  00058	89 45 d4	 mov	 DWORD PTR _pSlot$1[ebp], eax

; 277  : #ifdef _DEBUG
; 278  :             // Clear the released slot for debugging.
; 279  :             memset(pSlot, 0x00, sizeof(*pSlot));

  0005b	6a 20		 push	 32			; 00000020H
  0005d	6a 00		 push	 0
  0005f	8b 45 d4	 mov	 eax, DWORD PTR _pSlot$1[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _memset
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : #endif
; 281  :             // Restore the released slot to the list.
; 282  :             pSlot->pNext = pBlock->pFree;

  0006b	8b 45 d4	 mov	 eax, DWORD PTR _pSlot$1[ebp]
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _pBlock$[ebp]
  00071	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00074	89 10		 mov	 DWORD PTR [eax], edx

; 283  :             pBlock->pFree = pSlot;

  00076	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00079	8b 4d d4	 mov	 ecx, DWORD PTR _pSlot$1[ebp]
  0007c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 284  :             pBlock->usedCount--;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00082	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00085	83 e9 01	 sub	 ecx, 1
  00088	8b 55 f8	 mov	 edx, DWORD PTR _pBlock$[ebp]
  0008b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 285  : 
; 286  :             // Free if unused.
; 287  :             if (pBlock->usedCount == 0)

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00091	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00095	75 37		 jne	 SHORT $LN5@FreeBuffer

; 288  :             {
; 289  :                 if (pPrev)

  00097	83 7d ec 00	 cmp	 DWORD PTR _pPrev$[ebp], 0
  0009b	74 0c		 je	 SHORT $LN6@FreeBuffer

; 290  :                     pPrev->pNext = pBlock->pNext;

  0009d	8b 45 ec	 mov	 eax, DWORD PTR _pPrev$[ebp]
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _pBlock$[ebp]
  000a3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a5	89 10		 mov	 DWORD PTR [eax], edx
  000a7	eb 0b		 jmp	 SHORT $LN7@FreeBuffer
$LN6@FreeBuffer:

; 291  :                 else
; 292  :                     g_pMemoryBlocks = pBlock->pNext;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	89 0d 00 00 00
	00		 mov	 DWORD PTR _g_pMemoryBlocks, ecx
$LN7@FreeBuffer:

; 293  : 
; 294  :                 VirtualFree(pBlock, 0, MEM_RELEASE);

  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 80 00 00	 push	 32768			; 00008000H
  000bb	6a 00		 push	 0
  000bd	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@FreeBuffer:

; 295  :             }
; 296  : 
; 297  :             break;

  000ce	eb 13		 jmp	 SHORT $LN1@FreeBuffer
$LN4@FreeBuffer:

; 298  :         }
; 299  : 
; 300  :         pPrev = pBlock;

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000d3	89 45 ec	 mov	 DWORD PTR _pPrev$[ebp], eax

; 301  :         pBlock = pBlock->pNext;

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000db	89 4d f8	 mov	 DWORD PTR _pBlock$[ebp], ecx

; 302  :     }

  000de	e9 60 ff ff ff	 jmp	 $LN2@FreeBuffer
$LN1@FreeBuffer:

; 303  : }

  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx
  000e6	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000ec	3b ec		 cmp	 ebp, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_FreeBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\buffer.c
;	COMDAT _AllocateBuffer
_TEXT	SEGMENT
_pBlock$ = -20						; size = 4
_pSlot$ = -8						; size = 4
_pOrigin$ = 8						; size = 4
_AllocateBuffer PROC					; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __596A73F5_buffer@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 249  :     PMEMORY_SLOT  pSlot;
; 250  :     PMEMORY_BLOCK pBlock = GetMemoryBlock(pOrigin);

  00028	8b 45 08	 mov	 eax, DWORD PTR _pOrigin$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _GetMemoryBlock
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 ec	 mov	 DWORD PTR _pBlock$[ebp], eax

; 251  :     if (pBlock == NULL)

  00037	83 7d ec 00	 cmp	 DWORD PTR _pBlock$[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@AllocateBu

; 252  :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 39		 jmp	 SHORT $LN1@AllocateBu
$LN2@AllocateBu:

; 253  : 
; 254  :     // Remove an unused slot from the list.
; 255  :     pSlot = pBlock->pFree;

  00041	8b 45 ec	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	89 4d f8	 mov	 DWORD PTR _pSlot$[ebp], ecx

; 256  :     pBlock->pFree = pSlot->pNext;

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _pBlock$[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 257  :     pBlock->usedCount++;

  00055	8b 45 ec	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	83 c1 01	 add	 ecx, 1
  0005e	8b 55 ec	 mov	 edx, DWORD PTR _pBlock$[ebp]
  00061	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 258  : #ifdef _DEBUG
; 259  :     // Fill the slot with INT3 for debugging.
; 260  :     memset(pSlot, 0xCC, sizeof(MEMORY_SLOT));

  00064	6a 20		 push	 32			; 00000020H
  00066	68 cc 00 00 00	 push	 204			; 000000ccH
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _memset
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 261  : #endif
; 262  :     return pSlot;

  00077	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
$LN1@AllocateBu:

; 263  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_AllocateBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\buffer.c
;	COMDAT _UninitializeBuffer
_TEXT	SEGMENT
_pNext$1 = -20						; size = 4
_pBlock$ = -8						; size = 4
_UninitializeBuffer PROC				; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __596A73F5_buffer@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 76   :     PMEMORY_BLOCK pBlock = g_pMemoryBlocks;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_pMemoryBlocks
  0002d	89 45 f8	 mov	 DWORD PTR _pBlock$[ebp], eax

; 77   :     g_pMemoryBlocks = NULL;

  00030	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_pMemoryBlocks, 0
$LN2@Uninitiali:

; 78   : 
; 79   :     while (pBlock)

  0003a	83 7d f8 00	 cmp	 DWORD PTR _pBlock$[ebp], 0
  0003e	74 2a		 je	 SHORT $LN1@Uninitiali

; 80   :     {
; 81   :         PMEMORY_BLOCK pNext = pBlock->pNext;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	89 4d ec	 mov	 DWORD PTR _pNext$1[ebp], ecx

; 82   :         VirtualFree(pBlock, 0, MEM_RELEASE);

  00048	8b f4		 mov	 esi, esp
  0004a	68 00 80 00 00	 push	 32768			; 00008000H
  0004f	6a 00		 push	 0
  00051	8b 45 f8	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFree@12
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 83   :         pBlock = pNext;

  00062	8b 45 ec	 mov	 eax, DWORD PTR _pNext$1[ebp]
  00065	89 45 f8	 mov	 DWORD PTR _pBlock$[ebp], eax

; 84   :     }

  00068	eb d0		 jmp	 SHORT $LN2@Uninitiali
$LN1@Uninitiali:

; 85   : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_UninitializeBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\buffer.c
;	COMDAT _InitializeBuffer
_TEXT	SEGMENT
_InitializeBuffer PROC					; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __596A73F5_buffer@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 70   :     // Nothing to do for now.
; 71   : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_InitializeBuffer ENDP
_TEXT	ENDS
END
