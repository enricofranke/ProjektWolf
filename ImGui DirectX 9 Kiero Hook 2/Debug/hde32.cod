; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hde\hde32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_hde32_table
msvcjmc	SEGMENT
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__E6E7469F_winioctl@h DB 01H
__08182E14_stralign@h DB 01H
__B51C3CBF_hde32@c DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
_hde32_table DB	0a3H
	DB	0a8H
	DB	0a3H
	DB	0a8H
	DB	0a3H
	DB	0a8H
	DB	0a3H
	DB	0a8H
	DB	0a3H
	DB	0a8H
	DB	0a3H
	DB	0a8H
	DB	0a3H
	DB	0a8H
	DB	0a3H
	DB	0a8H
	DB	0aaH
	DB	0aaH
	DB	0aaH
	DB	0aaH
	DB	0aaH
	DB	0aaH
	DB	0aaH
	DB	0aaH
	DB	0acH
	DB	0aaH
	DB	0b2H
	DB	0aaH
	DB	09fH
	DB	09fH
	DB	09fH
	DB	09fH
	DB	0b5H
	DB	0a3H
	DB	0a3H
	DB	0a4H
	DB	0aaH
	DB	0aaH
	DB	0baH
	DB	0aaH
	DB	096H
	DB	0aaH
	DB	0a8H
	DB	0aaH
	DB	0c3H
	DB	0c3H
	DB	096H
	DB	096H
	DB	0b7H
	DB	0aeH
	DB	0d6H
	DB	0bdH
	DB	0a3H
	DB	0c5H
	DB	0a3H
	DB	0a3H
	DB	09fH
	DB	0c3H
	DB	09cH
	DB	0aaH
	DB	0aaH
	DB	0acH
	DB	0aaH
	DB	0bfH
	DB	03H
	DB	07fH
	DB	011H
	DB	07fH
	DB	01H
	DB	07fH
	DB	01H
	DB	03fH
	DB	01H
	DB	01H
	DB	090H
	DB	082H
	DB	07dH
	DB	097H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	07fH
	DB	059H
	DB	059H
	DB	060H
	DB	07dH
	DB	07fH
	DB	07fH
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	09aH
	DB	088H
	DB	07dH
	DB	059H
	DB	050H
	DB	050H
	DB	050H
	DB	050H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	061H
	DB	094H
	DB	061H
	DB	09eH
	DB	059H
	DB	059H
	DB	085H
	DB	059H
	DB	092H
	DB	0a3H
	DB	060H
	DB	060H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	059H
	DB	09fH
	DB	01H
	DB	03H
	DB	01H
	DB	04H
	DB	03H
	DB	0d5H
	DB	03H
	DB	0ccH
	DB	01H
	DB	0bcH
	DB	03H
	DB	0f0H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	050H
	DB	050H
	DB	050H
	DB	050H
	DB	014H
	DB	020H
	DB	020H
	DB	020H
	DB	020H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	0c4H
	DB	02H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	0c0H
	DB	0c2H
	DB	010H
	DB	011H
	DB	02H
	DB	03H
	DB	011H
	DB	03H
	DB	03H
	DB	04H
	DB	00H
	DB	00H
	DB	014H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	0c6H
	DB	0c8H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0caH
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	06H
	DB	00H
	DB	04H
	DB	00H
	DB	0c0H
	DB	0c2H
	DB	01H
	DB	01H
	DB	03H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	01H
	DB	00H
	DB	03H
	DB	0c4H
	DB	0c4H
	DB	0c6H
	DB	03H
	DB	01H
	DB	01H
	DB	01H
	DB	0ffH
	DB	03H
	DB	03H
	DB	03H
	DB	0c8H
	DB	040H
	DB	00H
	DB	0aH
	DB	00H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	033H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0bfH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0bfH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	0ffH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04bH
	DB	052H
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04fH
	DB	04cH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	055H
	DB	045H
	DB	040H
	DB	04aH
	DB	04aH
	DB	04aH
	DB	045H
	DB	059H
	DB	04dH
	DB	046H
	DB	04aH
	DB	05dH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	04aH
	DB	061H
	DB	063H
	DB	067H
	DB	04eH
	DB	04aH
	DB	04aH
	DB	06bH
	DB	06dH
	DB	04aH
	DB	04aH
	DB	045H
	DB	06dH
	DB	04aH
	DB	04aH
	DB	044H
	DB	045H
	DB	04aH
	DB	04aH
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	0dH
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	0eH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	06H
	DB	06H
	DB	00H
	DB	06H
	DB	06H
	DB	02H
	DB	06H
	DB	00H
	DB	0aH
	DB	0aH
	DB	07H
	DB	07H
	DB	06H
	DB	02H
	DB	05H
	DB	05H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	0eH
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	01H
	DB	06H
	DB	00H
	DB	00H
	DB	08H
	DB	00H
	DB	010H
	DB	00H
	DB	018H
	DB	00H
	DB	020H
	DB	00H
	DB	028H
	DB	00H
	DB	030H
	DB	00H
	DB	080H
	DB	01H
	DB	082H
	DB	01H
	DB	086H
	DB	00H
	DB	0f6H
	DB	0cfH
	DB	0feH
	DB	03fH
	DB	0abH
	DB	00H
	DB	0b0H
	DB	00H
	DB	0b1H
	DB	00H
	DB	0b3H
	DB	00H
	DB	0baH
	DB	0f8H
	DB	0bbH
	DB	00H
	DB	0c0H
	DB	00H
	DB	0c1H
	DB	00H
	DB	0c7H
	DB	0bfH
	DB	062H
	DB	0ffH
	DB	00H
	DB	08dH
	DB	0ffH
	DB	00H
	DB	0c4H
	DB	0ffH
	DB	00H
	DB	0c5H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ebH
	DB	01H
	DB	0ffH
	DB	0eH
	DB	012H
	DB	08H
	DB	00H
	DB	013H
	DB	09H
	DB	00H
	DB	016H
	DB	08H
	DB	00H
	DB	017H
	DB	09H
	DB	00H
	DB	02bH
	DB	09H
	DB	00H
	DB	0aeH
	DB	0ffH
	DB	07H
	DB	0b2H
	DB	0ffH
	DB	00H
	DB	0b4H
	DB	0ffH
	DB	00H
	DB	0b5H
	DB	0ffH
	DB	00H
	DB	0c3H
	DB	01H
	DB	00H
	DB	0c7H
	DB	0ffH
	DB	0bfH
	DB	0e7H
	DB	08H
	DB	00H
	DB	0f0H
	DB	02H
	DB	00H
_DATA	ENDS
PUBLIC	_hde32_disasm
PUBLIC	__JustMyCode_Default
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hde\hde32.c
;	COMDAT _hde32_disasm
_TEXT	SEGMENT
tv360 = -408						; size = 4
tv304 = -408						; size = 4
tv359 = -404						; size = 4
tv303 = -404						; size = 4
tv73 = -404						; size = 4
tv552 = -400						; size = 4
tv452 = -400						; size = 4
tv443 = -400						; size = 4
tv403 = -400						; size = 4
tv377 = -400						; size = 4
tv366 = -400						; size = 4
tv358 = -400						; size = 4
tv330 = -400						; size = 4
tv318 = -400						; size = 4
tv302 = -400						; size = 4
tv72 = -400						; size = 4
$T1 = -389						; size = 1
_table_end$2 = -188					; size = 4
_op$3 = -173						; size = 1
_table_end$4 = -164					; size = 4
_t$5 = -149						; size = 1
_t$6 = -140						; size = 2
_disp_size$ = -125					; size = 1
_m_rm$ = -113						; size = 1
_m_reg$ = -101						; size = 1
_m_mod$ = -89						; size = 1
_ht$ = -80						; size = 4
_pref$ = -65						; size = 1
_opcode$ = -53						; size = 1
_cflags$ = -41						; size = 1
_p$ = -32						; size = 4
_c$ = -17						; size = 1
_x$ = -5						; size = 1
_code$ = 8						; size = 4
_hs$ = 12						; size = 4
_hde32_disasm PROC					; COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 68 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-408]
  00012	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 7b fe ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __B51C3CBF_hde32@c
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 15   :     uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _code$[ebp]
  00032	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
  00035	c6 45 bf 00	 mov	 BYTE PTR _pref$[ebp], 0

; 16   :     uint8_t *ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

  00039	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _ht$[ebp], OFFSET _hde32_table
  00040	c6 45 83 00	 mov	 BYTE PTR _disp_size$[ebp], 0

; 17   : 
; 18   :     // Avoid using memset to reduce the footprint.
; 19   : #ifndef _MSC_VER
; 20   :     memset((LPBYTE)hs, 0, sizeof(hde32s));
; 21   : #else
; 22   :     __stosb((LPBYTE)hs, 0, sizeof(hde32s));

  00044	8b 7d 0c	 mov	 edi, DWORD PTR _hs$[ebp]
  00047	32 c0		 xor	 al, al
  00049	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0004e	f3 aa		 rep stosb

; 23   : #endif
; 24   : 
; 25   :     for (x = 16; x; x--)

  00050	c6 45 fb 10	 mov	 BYTE PTR _x$[ebp], 16	; 00000010H
  00054	eb 08		 jmp	 SHORT $LN4@hde32_disa
$LN2@hde32_disa:
  00056	8a 45 fb	 mov	 al, BYTE PTR _x$[ebp]
  00059	2c 01		 sub	 al, 1
  0005b	88 45 fb	 mov	 BYTE PTR _x$[ebp], al
$LN4@hde32_disa:
  0005e	0f b6 45 fb	 movzx	 eax, BYTE PTR _x$[ebp]
  00062	85 c0		 test	 eax, eax
  00064	0f 84 89 01 00
	00		 je	 $pref_done$155

; 26   :         switch (c = *p++) {

  0006a	c6 85 7b fe ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  00071	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00074	8a 08		 mov	 cl, BYTE PTR [eax]
  00076	88 4d ef	 mov	 BYTE PTR _c$[ebp], cl
  00079	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00080	75 0d		 jne	 SHORT $LN125@hde32_disa
  00082	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00087	e8 00 00 00 00	 call	 __RTC_UninitUse
  0008c	83 c4 04	 add	 esp, 4
$LN125@hde32_disa:
  0008f	0f b6 55 ef	 movzx	 edx, BYTE PTR _c$[ebp]
  00093	89 95 70 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
  00099	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
  000a2	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  000a8	89 8d 6c fe ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  000ae	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  000b4	83 ea 26	 sub	 edx, 38			; 00000026H
  000b7	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv73[ebp], edx
  000bd	81 bd 6c fe ff
	ff cd 00 00 00	 cmp	 DWORD PTR tv73[ebp], 205 ; 000000cdH
  000c7	0f 87 1f 01 00
	00		 ja	 $LN29@hde32_disa
  000cd	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  000d3	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN147@hde32_disa[eax]
  000da	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN148@hde32_disa[ecx*4]
$LN23@hde32_disa:

; 27   :             case 0xf3:
; 28   :                 hs->p_rep = c;

  000e1	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  000e8	75 0d		 jne	 SHORT $LN127@hde32_disa
  000ea	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  000ef	e8 00 00 00 00	 call	 __RTC_UninitUse
  000f4	83 c4 04	 add	 esp, 4
$LN127@hde32_disa:
  000f7	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  000fa	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  000fd	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 29   :                 pref |= PRE_F3;

  00100	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00104	83 c8 04	 or	 eax, 4
  00107	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al

; 30   :                 break;

  0010a	e9 df 00 00 00	 jmp	 $LN5@hde32_disa
$LN24@hde32_disa:

; 31   :             case 0xf2:
; 32   :                 hs->p_rep = c;

  0010f	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00116	75 0d		 jne	 SHORT $LN128@hde32_disa
  00118	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  0011d	e8 00 00 00 00	 call	 __RTC_UninitUse
  00122	83 c4 04	 add	 esp, 4
$LN128@hde32_disa:
  00125	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00128	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  0012b	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 33   :                 pref |= PRE_F2;

  0012e	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00132	83 c8 02	 or	 eax, 2
  00135	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al

; 34   :                 break;

  00138	e9 b1 00 00 00	 jmp	 $LN5@hde32_disa
$LN25@hde32_disa:

; 35   :             case 0xf0:
; 36   :                 hs->p_lock = c;

  0013d	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00144	75 0d		 jne	 SHORT $LN129@hde32_disa
  00146	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  0014b	e8 00 00 00 00	 call	 __RTC_UninitUse
  00150	83 c4 04	 add	 esp, 4
$LN129@hde32_disa:
  00153	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00156	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  00159	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 37   :                 pref |= PRE_LOCK;

  0015c	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00160	83 c8 20	 or	 eax, 32			; 00000020H
  00163	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al

; 38   :                 break;

  00166	e9 83 00 00 00	 jmp	 $LN5@hde32_disa
$LN26@hde32_disa:

; 39   :             case 0x26: case 0x2e: case 0x36:
; 40   :             case 0x3e: case 0x64: case 0x65:
; 41   :                 hs->p_seg = c;

  0016b	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00172	75 0d		 jne	 SHORT $LN130@hde32_disa
  00174	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00179	e8 00 00 00 00	 call	 __RTC_UninitUse
  0017e	83 c4 04	 add	 esp, 4
$LN130@hde32_disa:
  00181	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00184	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  00187	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 42   :                 pref |= PRE_SEG;

  0018a	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  0018e	83 c8 40	 or	 eax, 64			; 00000040H
  00191	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al

; 43   :                 break;

  00194	eb 58		 jmp	 SHORT $LN5@hde32_disa
$LN27@hde32_disa:

; 44   :             case 0x66:
; 45   :                 hs->p_66 = c;

  00196	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  0019d	75 0d		 jne	 SHORT $LN131@hde32_disa
  0019f	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  001a4	e8 00 00 00 00	 call	 __RTC_UninitUse
  001a9	83 c4 04	 add	 esp, 4
$LN131@hde32_disa:
  001ac	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  001af	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  001b2	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 46   :                 pref |= PRE_66;

  001b5	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  001b9	83 c8 08	 or	 eax, 8
  001bc	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al

; 47   :                 break;

  001bf	eb 2d		 jmp	 SHORT $LN5@hde32_disa
$LN28@hde32_disa:

; 48   :             case 0x67:
; 49   :                 hs->p_67 = c;

  001c1	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  001c8	75 0d		 jne	 SHORT $LN132@hde32_disa
  001ca	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  001cf	e8 00 00 00 00	 call	 __RTC_UninitUse
  001d4	83 c4 04	 add	 esp, 4
$LN132@hde32_disa:
  001d7	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  001da	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  001dd	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 50   :                 pref |= PRE_67;

  001e0	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  001e4	83 c8 10	 or	 eax, 16			; 00000010H
  001e7	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al

; 51   :                 break;

  001ea	eb 02		 jmp	 SHORT $LN5@hde32_disa
$LN29@hde32_disa:

; 52   :             default:
; 53   :                 goto pref_done;

  001ec	eb 05		 jmp	 SHORT $pref_done$155
$LN5@hde32_disa:

; 54   :         }

  001ee	e9 63 fe ff ff	 jmp	 $LN2@hde32_disa
$pref_done$155:

; 55   :   pref_done:
; 56   : 
; 57   :     hs->flags = (uint32_t)pref << 23;

  001f3	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  001f7	c1 e0 17	 shl	 eax, 23			; 00000017H
  001fa	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  001fd	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 58   : 
; 59   :     if (!pref)

  00200	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00204	85 c0		 test	 eax, eax
  00206	75 0a		 jne	 SHORT $LN30@hde32_disa

; 60   :         pref |= PRE_NONE;

  00208	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  0020c	83 c8 01	 or	 eax, 1
  0020f	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al
$LN30@hde32_disa:

; 61   : 
; 62   :     if ((hs->opcode = c) == 0x0f) {

  00212	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00219	75 0d		 jne	 SHORT $LN133@hde32_disa
  0021b	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00220	e8 00 00 00 00	 call	 __RTC_UninitUse
  00225	83 c4 04	 add	 esp, 4
$LN133@hde32_disa:
  00228	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  0022b	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  0022e	88 48 06	 mov	 BYTE PTR [eax+6], cl
  00231	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00238	75 0d		 jne	 SHORT $LN134@hde32_disa
  0023a	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  0023f	e8 00 00 00 00	 call	 __RTC_UninitUse
  00244	83 c4 04	 add	 esp, 4
$LN134@hde32_disa:
  00247	0f b6 55 ef	 movzx	 edx, BYTE PTR _c$[ebp]
  0024b	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  0024e	75 42		 jne	 SHORT $LN31@hde32_disa

; 63   :         hs->opcode2 = c = *p++;

  00250	c6 85 7b fe ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  00257	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  0025a	8a 08		 mov	 cl, BYTE PTR [eax]
  0025c	88 4d ef	 mov	 BYTE PTR _c$[ebp], cl
  0025f	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00266	75 0d		 jne	 SHORT $LN135@hde32_disa
  00268	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  0026d	e8 00 00 00 00	 call	 __RTC_UninitUse
  00272	83 c4 04	 add	 esp, 4
$LN135@hde32_disa:
  00275	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00278	8a 45 ef	 mov	 al, BYTE PTR _c$[ebp]
  0027b	88 42 07	 mov	 BYTE PTR [edx+7], al
  0027e	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00281	83 c1 01	 add	 ecx, 1
  00284	89 4d e0	 mov	 DWORD PTR _p$[ebp], ecx

; 64   :         ht += DELTA_OPCODES;

  00287	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  0028a	83 c0 4a	 add	 eax, 74			; 0000004aH
  0028d	89 45 b0	 mov	 DWORD PTR _ht$[ebp], eax
  00290	eb 61		 jmp	 SHORT $LN32@hde32_disa
$LN31@hde32_disa:

; 65   :     } else if (c >= 0xa0 && c <= 0xa3) {

  00292	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00299	75 0d		 jne	 SHORT $LN136@hde32_disa
  0029b	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  002a0	e8 00 00 00 00	 call	 __RTC_UninitUse
  002a5	83 c4 04	 add	 esp, 4
$LN136@hde32_disa:
  002a8	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  002ac	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  002b1	7c 40		 jl	 SHORT $LN32@hde32_disa
  002b3	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  002ba	75 0d		 jne	 SHORT $LN137@hde32_disa
  002bc	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  002c1	e8 00 00 00 00	 call	 __RTC_UninitUse
  002c6	83 c4 04	 add	 esp, 4
$LN137@hde32_disa:
  002c9	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  002cd	3d a3 00 00 00	 cmp	 eax, 163		; 000000a3H
  002d2	7f 1f		 jg	 SHORT $LN32@hde32_disa

; 66   :         if (pref & PRE_67)

  002d4	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  002d8	83 e0 10	 and	 eax, 16			; 00000010H
  002db	74 0c		 je	 SHORT $LN34@hde32_disa

; 67   :             pref |= PRE_66;

  002dd	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  002e1	83 c8 08	 or	 eax, 8
  002e4	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al
  002e7	eb 0a		 jmp	 SHORT $LN32@hde32_disa
$LN34@hde32_disa:

; 68   :         else
; 69   :             pref &= ~PRE_66;

  002e9	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  002ed	83 e0 f7	 and	 eax, -9			; fffffff7H
  002f0	88 45 bf	 mov	 BYTE PTR _pref$[ebp], al
$LN32@hde32_disa:

; 70   :     }
; 71   : 
; 72   :     opcode = c;

  002f3	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  002fa	75 0d		 jne	 SHORT $LN138@hde32_disa
  002fc	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00301	e8 00 00 00 00	 call	 __RTC_UninitUse
  00306	83 c4 04	 add	 esp, 4
$LN138@hde32_disa:
  00309	8a 45 ef	 mov	 al, BYTE PTR _c$[ebp]
  0030c	88 45 cb	 mov	 BYTE PTR _opcode$[ebp], al

; 73   :     cflags = ht[ht[opcode / 4] + (opcode % 4)];

  0030f	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  00313	99		 cdq
  00314	83 e2 03	 and	 edx, 3
  00317	03 c2		 add	 eax, edx
  00319	c1 f8 02	 sar	 eax, 2
  0031c	8b 4d b0	 mov	 ecx, DWORD PTR _ht$[ebp]
  0031f	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00323	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  00327	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0032c	79 05		 jns	 SHORT $LN153@hde32_disa
  0032e	48		 dec	 eax
  0032f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00332	40		 inc	 eax
$LN153@hde32_disa:
  00333	03 45 b0	 add	 eax, DWORD PTR _ht$[ebp]
  00336	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  00339	88 4d d7	 mov	 BYTE PTR _cflags$[ebp], cl

; 74   : 
; 75   :     if (cflags == C_ERROR) {

  0033c	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00340	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00345	75 2a		 jne	 SHORT $LN36@hde32_disa

; 76   :         hs->flags |= F_ERROR | F_ERROR_OPCODE;

  00347	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  0034a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0034d	81 c9 00 30 00
	00		 or	 ecx, 12288		; 00003000H
  00353	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00356	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 77   :         cflags = 0;

  00359	c6 45 d7 00	 mov	 BYTE PTR _cflags$[ebp], 0

; 78   :         if ((opcode & -3) == 0x24)

  0035d	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  00361	83 e0 fd	 and	 eax, -3			; fffffffdH
  00364	83 f8 24	 cmp	 eax, 36			; 00000024H
  00367	75 08		 jne	 SHORT $LN36@hde32_disa

; 79   :             cflags++;

  00369	8a 45 d7	 mov	 al, BYTE PTR _cflags$[ebp]
  0036c	04 01		 add	 al, 1
  0036e	88 45 d7	 mov	 BYTE PTR _cflags$[ebp], al
$LN36@hde32_disa:

; 80   :     }
; 81   : 
; 82   :     x = 0;

  00371	c6 45 fb 00	 mov	 BYTE PTR _x$[ebp], 0

; 83   :     if (cflags & C_GROUP) {

  00375	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00379	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0037e	74 2b		 je	 SHORT $LN38@hde32_disa

; 84   :         uint16_t t;
; 85   :         t = *(uint16_t *)(ht + (cflags & 0x7f));

  00380	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00384	83 e0 7f	 and	 eax, 127		; 0000007fH
  00387	8b 4d b0	 mov	 ecx, DWORD PTR _ht$[ebp]
  0038a	66 8b 14 01	 mov	 dx, WORD PTR [ecx+eax]
  0038e	66 89 95 74 ff
	ff ff		 mov	 WORD PTR _t$6[ebp], dx

; 86   :         cflags = (uint8_t)t;

  00395	8a 85 74 ff ff
	ff		 mov	 al, BYTE PTR _t$6[ebp]
  0039b	88 45 d7	 mov	 BYTE PTR _cflags$[ebp], al

; 87   :         x = (uint8_t)(t >> 8);

  0039e	0f b7 85 74 ff
	ff ff		 movzx	 eax, WORD PTR _t$6[ebp]
  003a5	c1 f8 08	 sar	 eax, 8
  003a8	88 45 fb	 mov	 BYTE PTR _x$[ebp], al
$LN38@hde32_disa:

; 88   :     }
; 89   : 
; 90   :     if (hs->opcode2) {

  003ab	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  003ae	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  003b2	85 c9		 test	 ecx, ecx
  003b4	74 4c		 je	 SHORT $LN39@hde32_disa

; 91   :         ht = hde32_table + DELTA_PREFIXES;

  003b6	c7 45 b0 30 01
	00 00		 mov	 DWORD PTR _ht$[ebp], OFFSET _hde32_table+304

; 92   :         if (ht[ht[opcode / 4] + (opcode % 4)] & pref)

  003bd	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  003c1	99		 cdq
  003c2	83 e2 03	 and	 edx, 3
  003c5	03 c2		 add	 eax, edx
  003c7	c1 f8 02	 sar	 eax, 2
  003ca	8b 4d b0	 mov	 ecx, DWORD PTR _ht$[ebp]
  003cd	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003d1	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  003d5	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  003da	79 05		 jns	 SHORT $LN154@hde32_disa
  003dc	48		 dec	 eax
  003dd	83 c8 fc	 or	 eax, -4			; fffffffcH
  003e0	40		 inc	 eax
$LN154@hde32_disa:
  003e1	03 45 b0	 add	 eax, DWORD PTR _ht$[ebp]
  003e4	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  003e8	0f b6 55 bf	 movzx	 edx, BYTE PTR _pref$[ebp]
  003ec	23 ca		 and	 ecx, edx
  003ee	74 12		 je	 SHORT $LN39@hde32_disa

; 93   :             hs->flags |= F_ERROR | F_ERROR_OPCODE;

  003f0	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  003f3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  003f6	81 c9 00 30 00
	00		 or	 ecx, 12288		; 00003000H
  003fc	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  003ff	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN39@hde32_disa:

; 94   :     }
; 95   : 
; 96   :     if (cflags & C_MODRM) {

  00402	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00406	83 e0 01	 and	 eax, 1
  00409	0f 84 16 07 00
	00		 je	 $LN41@hde32_disa

; 97   :         hs->flags |= F_MODRM;

  0040f	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00412	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00415	83 c9 01	 or	 ecx, 1
  00418	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  0041b	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 98   :         hs->modrm = c = *p++;

  0041e	c6 85 7b fe ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  00425	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00428	8a 08		 mov	 cl, BYTE PTR [eax]
  0042a	88 4d ef	 mov	 BYTE PTR _c$[ebp], cl
  0042d	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00434	75 0d		 jne	 SHORT $LN139@hde32_disa
  00436	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  0043b	e8 00 00 00 00	 call	 __RTC_UninitUse
  00440	83 c4 04	 add	 esp, 4
$LN139@hde32_disa:
  00443	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00446	8a 45 ef	 mov	 al, BYTE PTR _c$[ebp]
  00449	88 42 08	 mov	 BYTE PTR [edx+8], al
  0044c	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  0044f	83 c1 01	 add	 ecx, 1
  00452	89 4d e0	 mov	 DWORD PTR _p$[ebp], ecx

; 99   :         hs->modrm_mod = m_mod = c >> 6;

  00455	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  0045c	75 0d		 jne	 SHORT $LN140@hde32_disa
  0045e	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00463	e8 00 00 00 00	 call	 __RTC_UninitUse
  00468	83 c4 04	 add	 esp, 4
$LN140@hde32_disa:
  0046b	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  0046f	c1 f8 06	 sar	 eax, 6
  00472	88 45 a7	 mov	 BYTE PTR _m_mod$[ebp], al
  00475	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  00478	8a 55 a7	 mov	 dl, BYTE PTR _m_mod$[ebp]
  0047b	88 51 09	 mov	 BYTE PTR [ecx+9], dl

; 100  :         hs->modrm_rm = m_rm = c & 7;

  0047e	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00485	75 0d		 jne	 SHORT $LN141@hde32_disa
  00487	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  0048c	e8 00 00 00 00	 call	 __RTC_UninitUse
  00491	83 c4 04	 add	 esp, 4
$LN141@hde32_disa:
  00494	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  00498	83 e0 07	 and	 eax, 7
  0049b	88 45 8f	 mov	 BYTE PTR _m_rm$[ebp], al
  0049e	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  004a1	8a 55 8f	 mov	 dl, BYTE PTR _m_rm$[ebp]
  004a4	88 51 0b	 mov	 BYTE PTR [ecx+11], dl

; 101  :         hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

  004a7	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  004ae	75 0d		 jne	 SHORT $LN142@hde32_disa
  004b0	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  004b5	e8 00 00 00 00	 call	 __RTC_UninitUse
  004ba	83 c4 04	 add	 esp, 4
$LN142@hde32_disa:
  004bd	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  004c1	83 e0 3f	 and	 eax, 63			; 0000003fH
  004c4	c1 f8 03	 sar	 eax, 3
  004c7	88 45 9b	 mov	 BYTE PTR _m_reg$[ebp], al
  004ca	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  004cd	8a 55 9b	 mov	 dl, BYTE PTR _m_reg$[ebp]
  004d0	88 51 0a	 mov	 BYTE PTR [ecx+10], dl

; 102  : 
; 103  :         if (x && ((x << m_reg) & 0x80))

  004d3	0f b6 45 fb	 movzx	 eax, BYTE PTR _x$[ebp]
  004d7	85 c0		 test	 eax, eax
  004d9	74 23		 je	 SHORT $LN43@hde32_disa
  004db	0f b6 45 fb	 movzx	 eax, BYTE PTR _x$[ebp]
  004df	0f b6 4d 9b	 movzx	 ecx, BYTE PTR _m_reg$[ebp]
  004e3	d3 e0		 shl	 eax, cl
  004e5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004ea	74 12		 je	 SHORT $LN43@hde32_disa

; 104  :             hs->flags |= F_ERROR | F_ERROR_OPCODE;

  004ec	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  004ef	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004f2	81 c9 00 30 00
	00		 or	 ecx, 12288		; 00003000H
  004f8	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  004fb	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN43@hde32_disa:

; 105  : 
; 106  :         if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {

  004fe	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00501	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00505	85 c9		 test	 ecx, ecx
  00507	0f 85 a1 00 00
	00		 jne	 $LN44@hde32_disa
  0050d	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  00511	3d d9 00 00 00	 cmp	 eax, 217		; 000000d9H
  00516	0f 8c 92 00 00
	00		 jl	 $LN44@hde32_disa
  0051c	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  00520	3d df 00 00 00	 cmp	 eax, 223		; 000000dfH
  00525	0f 8f 83 00 00
	00		 jg	 $LN44@hde32_disa

; 107  :             uint8_t t = opcode - 0xd9;

  0052b	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  0052f	2d d9 00 00 00	 sub	 eax, 217		; 000000d9H
  00534	88 85 6b ff ff
	ff		 mov	 BYTE PTR _t$5[ebp], al

; 108  :             if (m_mod == 3) {

  0053a	0f b6 45 a7	 movzx	 eax, BYTE PTR _m_mod$[ebp]
  0053e	83 f8 03	 cmp	 eax, 3
  00541	75 2a		 jne	 SHORT $LN45@hde32_disa

; 109  :                 ht = hde32_table + DELTA_FPU_MODRM + t*8;

  00543	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _t$5[ebp]
  0054a	8d 0c c5 f8 00
	00 00		 lea	 ecx, DWORD PTR _hde32_table[eax*8+248]
  00551	89 4d b0	 mov	 DWORD PTR _ht$[ebp], ecx

; 110  :                 t = ht[m_reg] << m_rm;

  00554	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  00558	8b 4d b0	 mov	 ecx, DWORD PTR _ht$[ebp]
  0055b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0055f	0f b6 4d 8f	 movzx	 ecx, BYTE PTR _m_rm$[ebp]
  00563	d3 e2		 shl	 edx, cl
  00565	88 95 6b ff ff
	ff		 mov	 BYTE PTR _t$5[ebp], dl

; 111  :             } else {

  0056b	eb 21		 jmp	 SHORT $LN46@hde32_disa
$LN45@hde32_disa:

; 112  :                 ht = hde32_table + DELTA_FPU_REG;

  0056d	c7 45 b0 f1 00
	00 00		 mov	 DWORD PTR _ht$[ebp], OFFSET _hde32_table+241

; 113  :                 t = ht[t] << m_reg;

  00574	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _t$5[ebp]
  0057b	8b 4d b0	 mov	 ecx, DWORD PTR _ht$[ebp]
  0057e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00582	0f b6 4d 9b	 movzx	 ecx, BYTE PTR _m_reg$[ebp]
  00586	d3 e2		 shl	 edx, cl
  00588	88 95 6b ff ff
	ff		 mov	 BYTE PTR _t$5[ebp], dl
$LN46@hde32_disa:

; 114  :             }
; 115  :             if (t & 0x80)

  0058e	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _t$5[ebp]
  00595	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0059a	74 12		 je	 SHORT $LN44@hde32_disa

; 116  :                 hs->flags |= F_ERROR | F_ERROR_OPCODE;

  0059c	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  0059f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  005a2	81 c9 00 30 00
	00		 or	 ecx, 12288		; 00003000H
  005a8	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  005ab	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN44@hde32_disa:

; 117  :         }
; 118  : 
; 119  :         if (pref & PRE_LOCK) {

  005ae	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  005b2	83 e0 20	 and	 eax, 32			; 00000020H
  005b5	0f 84 ff 00 00
	00		 je	 $no_lock_error$156

; 120  :             if (m_mod == 3) {

  005bb	0f b6 45 a7	 movzx	 eax, BYTE PTR _m_mod$[ebp]
  005bf	83 f8 03	 cmp	 eax, 3
  005c2	75 17		 jne	 SHORT $LN49@hde32_disa

; 121  :                 hs->flags |= F_ERROR | F_ERROR_LOCK;

  005c4	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  005c7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  005ca	81 c9 00 90 00
	00		 or	 ecx, 36864		; 00009000H
  005d0	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  005d3	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 122  :             } else {

  005d6	e9 df 00 00 00	 jmp	 $no_lock_error$156
$LN49@hde32_disa:

; 123  :                 uint8_t *table_end, op = opcode;

  005db	8a 45 cb	 mov	 al, BYTE PTR _opcode$[ebp]
  005de	88 85 53 ff ff
	ff		 mov	 BYTE PTR _op$3[ebp], al

; 124  :                 if (hs->opcode2) {

  005e4	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  005e7	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  005eb	85 c9		 test	 ecx, ecx
  005ed	74 15		 je	 SHORT $LN51@hde32_disa

; 125  :                     ht = hde32_table + DELTA_OP2_LOCK_OK;

  005ef	c7 45 b0 b9 01
	00 00		 mov	 DWORD PTR _ht$[ebp], OFFSET _hde32_table+441

; 126  :                     table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;

  005f6	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  005f9	83 c0 12	 add	 eax, 18			; 00000012H
  005fc	89 85 5c ff ff
	ff		 mov	 DWORD PTR _table_end$4[ebp], eax

; 127  :                 } else {

  00602	eb 23		 jmp	 SHORT $LN52@hde32_disa
$LN51@hde32_disa:

; 128  :                     ht = hde32_table + DELTA_OP_LOCK_OK;

  00604	c7 45 b0 a1 01
	00 00		 mov	 DWORD PTR _ht$[ebp], OFFSET _hde32_table+417

; 129  :                     table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;

  0060b	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  0060e	83 c0 18	 add	 eax, 24			; 00000018H
  00611	89 85 5c ff ff
	ff		 mov	 DWORD PTR _table_end$4[ebp], eax

; 130  :                     op &= -2;

  00617	0f b6 85 53 ff
	ff ff		 movzx	 eax, BYTE PTR _op$3[ebp]
  0061e	83 e0 fe	 and	 eax, -2			; fffffffeH
  00621	88 85 53 ff ff
	ff		 mov	 BYTE PTR _op$3[ebp], al
$LN52@hde32_disa:

; 131  :                 }
; 132  :                 for (; ht != table_end; ht++)

  00627	eb 09		 jmp	 SHORT $LN9@hde32_disa
$LN7@hde32_disa:
  00629	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  0062c	83 c0 01	 add	 eax, 1
  0062f	89 45 b0	 mov	 DWORD PTR _ht$[ebp], eax
$LN9@hde32_disa:
  00632	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  00635	3b 85 5c ff ff
	ff		 cmp	 eax, DWORD PTR _table_end$4[ebp]
  0063b	74 6b		 je	 SHORT $LN8@hde32_disa

; 133  :                     if (*ht++ == op) {

  0063d	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  00640	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00643	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv302[ebp], ecx
  00649	0f b6 95 53 ff
	ff ff		 movzx	 edx, BYTE PTR _op$3[ebp]
  00650	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv303[ebp], edx
  00656	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  00659	83 c0 01	 add	 eax, 1
  0065c	89 45 b0	 mov	 DWORD PTR _ht$[ebp], eax
  0065f	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv302[ebp]
  00665	3b 8d 6c fe ff
	ff		 cmp	 ecx, DWORD PTR tv303[ebp]
  0066b	75 0c		 jne	 SHORT $LN121@hde32_disa
  0066d	c7 85 68 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv304[ebp], 1
  00677	eb 0a		 jmp	 SHORT $LN122@hde32_disa
$LN121@hde32_disa:
  00679	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv304[ebp], 0
$LN122@hde32_disa:
  00683	83 bd 68 fe ff
	ff 00		 cmp	 DWORD PTR tv304[ebp], 0
  0068a	74 1a		 je	 SHORT $LN53@hde32_disa

; 134  :                         if (!((*ht << m_reg) & 0x80))

  0068c	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  0068f	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00692	0f b6 4d 9b	 movzx	 ecx, BYTE PTR _m_reg$[ebp]
  00696	d3 e2		 shl	 edx, cl
  00698	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0069e	75 04		 jne	 SHORT $LN54@hde32_disa

; 135  :                             goto no_lock_error;

  006a0	eb 18		 jmp	 SHORT $no_lock_error$156
  006a2	eb 02		 jmp	 SHORT $LN53@hde32_disa
$LN54@hde32_disa:

; 136  :                         else
; 137  :                             break;

  006a4	eb 02		 jmp	 SHORT $LN8@hde32_disa
$LN53@hde32_disa:

; 138  :                     }

  006a6	eb 81		 jmp	 SHORT $LN7@hde32_disa
$LN8@hde32_disa:

; 139  :                 hs->flags |= F_ERROR | F_ERROR_LOCK;

  006a8	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  006ab	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  006ae	81 c9 00 90 00
	00		 or	 ecx, 36864		; 00009000H
  006b4	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  006b7	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$no_lock_error$156:

; 140  :               no_lock_error:
; 141  :                 ;
; 142  :             }
; 143  :         }
; 144  : 
; 145  :         if (hs->opcode2) {

  006ba	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  006bd	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  006c1	85 c9		 test	 ecx, ecx
  006c3	74 75		 je	 SHORT $LN56@hde32_disa

; 146  :             switch (opcode) {

  006c5	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  006c9	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv318[ebp], eax
  006cf	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv318[ebp]
  006d5	83 e9 20	 sub	 ecx, 32			; 00000020H
  006d8	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv318[ebp], ecx
  006de	83 bd 70 fe ff
	ff 03		 cmp	 DWORD PTR tv318[ebp], 3
  006e5	77 51		 ja	 SHORT $LN10@hde32_disa
  006e7	8b 95 70 fe ff
	ff		 mov	 edx, DWORD PTR tv318[ebp]
  006ed	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN149@hde32_disa[edx*4]
$LN58@hde32_disa:

; 147  :                 case 0x20: case 0x22:
; 148  :                     m_mod = 3;

  006f4	c6 45 a7 03	 mov	 BYTE PTR _m_mod$[ebp], 3

; 149  :                     if (m_reg > 4 || m_reg == 1)

  006f8	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  006fc	83 f8 04	 cmp	 eax, 4
  006ff	7f 09		 jg	 SHORT $LN61@hde32_disa
  00701	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  00705	83 f8 01	 cmp	 eax, 1
  00708	75 07		 jne	 SHORT $LN59@hde32_disa
$LN61@hde32_disa:

; 150  :                         goto error_operand;

  0070a	e9 ce 01 00 00	 jmp	 $error_operand$157
  0070f	eb 05		 jmp	 SHORT $LN62@hde32_disa
$LN59@hde32_disa:

; 151  :                     else
; 152  :                         goto no_error_operand;

  00711	e9 d9 01 00 00	 jmp	 $no_error_operand$158
$LN62@hde32_disa:

; 153  :                 case 0x21: case 0x23:
; 154  :                     m_mod = 3;

  00716	c6 45 a7 03	 mov	 BYTE PTR _m_mod$[ebp], 3

; 155  :                     if (m_reg == 4 || m_reg == 5)

  0071a	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  0071e	83 f8 04	 cmp	 eax, 4
  00721	74 09		 je	 SHORT $LN65@hde32_disa
  00723	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  00727	83 f8 05	 cmp	 eax, 5
  0072a	75 07		 jne	 SHORT $LN63@hde32_disa
$LN65@hde32_disa:

; 156  :                         goto error_operand;

  0072c	e9 ac 01 00 00	 jmp	 $error_operand$157
  00731	eb 05		 jmp	 SHORT $LN10@hde32_disa
$LN63@hde32_disa:

; 157  :                     else
; 158  :                         goto no_error_operand;

  00733	e9 b7 01 00 00	 jmp	 $no_error_operand$158
$LN10@hde32_disa:

; 159  :             }
; 160  :         } else {

  00738	eb 50		 jmp	 SHORT $LN57@hde32_disa
$LN56@hde32_disa:

; 161  :             switch (opcode) {

  0073a	8a 45 cb	 mov	 al, BYTE PTR _opcode$[ebp]
  0073d	88 85 70 fe ff
	ff		 mov	 BYTE PTR tv330[ebp], al
  00743	80 bd 70 fe ff
	ff 8c		 cmp	 BYTE PTR tv330[ebp], 140 ; 0000008cH
  0074a	74 0b		 je	 SHORT $LN66@hde32_disa
  0074c	80 bd 70 fe ff
	ff 8e		 cmp	 BYTE PTR tv330[ebp], 142 ; 0000008eH
  00753	74 17		 je	 SHORT $LN69@hde32_disa
  00755	eb 33		 jmp	 SHORT $LN57@hde32_disa
$LN66@hde32_disa:

; 162  :                 case 0x8c:
; 163  :                     if (m_reg > 5)

  00757	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  0075b	83 f8 05	 cmp	 eax, 5
  0075e	7e 07		 jle	 SHORT $LN67@hde32_disa

; 164  :                         goto error_operand;

  00760	e9 78 01 00 00	 jmp	 $error_operand$157
  00765	eb 05		 jmp	 SHORT $LN69@hde32_disa
$LN67@hde32_disa:

; 165  :                     else
; 166  :                         goto no_error_operand;

  00767	e9 83 01 00 00	 jmp	 $no_error_operand$158
$LN69@hde32_disa:

; 167  :                 case 0x8e:
; 168  :                     if (m_reg == 1 || m_reg > 5)

  0076c	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  00770	83 f8 01	 cmp	 eax, 1
  00773	74 09		 je	 SHORT $LN72@hde32_disa
  00775	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  00779	83 f8 05	 cmp	 eax, 5
  0077c	7e 07		 jle	 SHORT $LN70@hde32_disa
$LN72@hde32_disa:

; 169  :                         goto error_operand;

  0077e	e9 5a 01 00 00	 jmp	 $error_operand$157
  00783	eb 05		 jmp	 SHORT $LN57@hde32_disa
$LN70@hde32_disa:

; 170  :                     else
; 171  :                         goto no_error_operand;

  00785	e9 65 01 00 00	 jmp	 $no_error_operand$158
$LN57@hde32_disa:

; 172  :             }
; 173  :         }
; 174  : 
; 175  :         if (m_mod == 3) {

  0078a	0f b6 45 a7	 movzx	 eax, BYTE PTR _m_mod$[ebp]
  0078e	83 f8 03	 cmp	 eax, 3
  00791	0f 85 e0 00 00
	00		 jne	 $LN73@hde32_disa

; 176  :             uint8_t *table_end;
; 177  :             if (hs->opcode2) {

  00797	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  0079a	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0079e	85 c9		 test	 ecx, ecx
  007a0	74 15		 je	 SHORT $LN75@hde32_disa

; 178  :                 ht = hde32_table + DELTA_OP2_ONLY_MEM;

  007a2	c7 45 b0 da 01
	00 00		 mov	 DWORD PTR _ht$[ebp], OFFSET _hde32_table+474

; 179  :                 table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;

  007a9	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  007ac	83 c0 2a	 add	 eax, 42			; 0000002aH
  007af	89 85 44 ff ff
	ff		 mov	 DWORD PTR _table_end$2[ebp], eax

; 180  :             } else {

  007b5	eb 13		 jmp	 SHORT $LN76@hde32_disa
$LN75@hde32_disa:

; 181  :                 ht = hde32_table + DELTA_OP_ONLY_MEM;

  007b7	c7 45 b0 cb 01
	00 00		 mov	 DWORD PTR _ht$[ebp], OFFSET _hde32_table+459

; 182  :                 table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;

  007be	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  007c1	83 c0 0f	 add	 eax, 15			; 0000000fH
  007c4	89 85 44 ff ff
	ff		 mov	 DWORD PTR _table_end$2[ebp], eax
$LN76@hde32_disa:

; 183  :             }
; 184  :             for (; ht != table_end; ht += 2)

  007ca	eb 09		 jmp	 SHORT $LN16@hde32_disa
$LN14@hde32_disa:
  007cc	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  007cf	83 c0 02	 add	 eax, 2
  007d2	89 45 b0	 mov	 DWORD PTR _ht$[ebp], eax
$LN16@hde32_disa:
  007d5	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  007d8	3b 85 44 ff ff
	ff		 cmp	 eax, DWORD PTR _table_end$2[ebp]
  007de	0f 84 8f 00 00
	00		 je	 $LN15@hde32_disa

; 185  :                 if (*ht++ == opcode) {

  007e4	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  007e7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  007ea	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv358[ebp], ecx
  007f0	0f b6 55 cb	 movzx	 edx, BYTE PTR _opcode$[ebp]
  007f4	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv359[ebp], edx
  007fa	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  007fd	83 c0 01	 add	 eax, 1
  00800	89 45 b0	 mov	 DWORD PTR _ht$[ebp], eax
  00803	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv358[ebp]
  00809	3b 8d 6c fe ff
	ff		 cmp	 ecx, DWORD PTR tv359[ebp]
  0080f	75 0c		 jne	 SHORT $LN123@hde32_disa
  00811	c7 85 68 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv360[ebp], 1
  0081b	eb 0a		 jmp	 SHORT $LN124@hde32_disa
$LN123@hde32_disa:
  0081d	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv360[ebp], 0
$LN124@hde32_disa:
  00827	83 bd 68 fe ff
	ff 00		 cmp	 DWORD PTR tv360[ebp], 0
  0082e	74 3e		 je	 SHORT $LN77@hde32_disa

; 186  :                     if (*ht++ & pref && !((*ht << m_reg) & 0x80))

  00830	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  00833	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00836	0f b6 55 bf	 movzx	 edx, BYTE PTR _pref$[ebp]
  0083a	23 ca		 and	 ecx, edx
  0083c	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv366[ebp], ecx
  00842	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  00845	83 c0 01	 add	 eax, 1
  00848	89 45 b0	 mov	 DWORD PTR _ht$[ebp], eax
  0084b	83 bd 70 fe ff
	ff 00		 cmp	 DWORD PTR tv366[ebp], 0
  00852	74 18		 je	 SHORT $LN78@hde32_disa
  00854	8b 45 b0	 mov	 eax, DWORD PTR _ht$[ebp]
  00857	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0085a	0f b6 4d 9b	 movzx	 ecx, BYTE PTR _m_reg$[ebp]
  0085e	d3 e2		 shl	 edx, cl
  00860	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00866	75 04		 jne	 SHORT $LN78@hde32_disa

; 187  :                         goto error_operand;

  00868	eb 73		 jmp	 SHORT $error_operand$157
  0086a	eb 02		 jmp	 SHORT $LN77@hde32_disa
$LN78@hde32_disa:

; 188  :                     else
; 189  :                         break;

  0086c	eb 05		 jmp	 SHORT $LN15@hde32_disa
$LN77@hde32_disa:

; 190  :                 }

  0086e	e9 59 ff ff ff	 jmp	 $LN14@hde32_disa
$LN15@hde32_disa:

; 191  :             goto no_error_operand;

  00873	eb 7a		 jmp	 SHORT $no_error_operand$158
  00875	eb 66		 jmp	 SHORT $error_operand$157
$LN73@hde32_disa:

; 192  :         } else if (hs->opcode2) {

  00877	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  0087a	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0087e	85 c9		 test	 ecx, ecx
  00880	74 59		 je	 SHORT $LN80@hde32_disa

; 193  :             switch (opcode) {

  00882	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  00886	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv377[ebp], eax
  0088c	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv377[ebp]
  00892	83 e9 50	 sub	 ecx, 80			; 00000050H
  00895	89 8d 70 fe ff
	ff		 mov	 DWORD PTR tv377[ebp], ecx
  0089b	81 bd 70 fe ff
	ff a7 00 00 00	 cmp	 DWORD PTR tv377[ebp], 167 ; 000000a7H
  008a5	77 30		 ja	 SHORT $LN17@hde32_disa
  008a7	8b 95 70 fe ff
	ff		 mov	 edx, DWORD PTR tv377[ebp]
  008ad	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN150@hde32_disa[edx]
  008b4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN151@hde32_disa[eax*4]
$LN82@hde32_disa:

; 194  :                 case 0x50: case 0xd7: case 0xf7:
; 195  :                     if (pref & (PRE_NONE | PRE_66))

  008bb	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  008bf	83 e0 09	 and	 eax, 9
  008c2	74 02		 je	 SHORT $LN83@hde32_disa

; 196  :                         goto error_operand;

  008c4	eb 17		 jmp	 SHORT $error_operand$157
$LN83@hde32_disa:

; 197  :                     break;

  008c6	eb 0f		 jmp	 SHORT $LN17@hde32_disa
$LN84@hde32_disa:

; 198  :                 case 0xd6:
; 199  :                     if (pref & (PRE_F2 | PRE_F3))

  008c8	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  008cc	83 e0 06	 and	 eax, 6
  008cf	74 02		 je	 SHORT $LN85@hde32_disa

; 200  :                         goto error_operand;

  008d1	eb 0a		 jmp	 SHORT $error_operand$157
$LN85@hde32_disa:

; 201  :                     break;

  008d3	eb 02		 jmp	 SHORT $LN17@hde32_disa
$LN86@hde32_disa:

; 202  :                 case 0xc5:
; 203  :                     goto error_operand;

  008d5	eb 06		 jmp	 SHORT $error_operand$157
$LN17@hde32_disa:

; 204  :             }
; 205  :             goto no_error_operand;

  008d7	eb 16		 jmp	 SHORT $no_error_operand$158

; 206  :         } else

  008d9	eb 02		 jmp	 SHORT $error_operand$157
$LN80@hde32_disa:

; 207  :             goto no_error_operand;

  008db	eb 12		 jmp	 SHORT $no_error_operand$158
$error_operand$157:

; 208  : 
; 209  :       error_operand:
; 210  :         hs->flags |= F_ERROR | F_ERROR_OPERAND;

  008dd	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  008e0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  008e3	81 c9 00 10 01
	00		 or	 ecx, 69632		; 00011000H
  008e9	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  008ec	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$no_error_operand$158:

; 211  :       no_error_operand:
; 212  : 
; 213  :         c = *p++;

  008ef	c6 85 7b fe ff
	ff 01		 mov	 BYTE PTR $T1[ebp], 1
  008f6	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  008f9	8a 08		 mov	 cl, BYTE PTR [eax]
  008fb	88 4d ef	 mov	 BYTE PTR _c$[ebp], cl
  008fe	8b 55 e0	 mov	 edx, DWORD PTR _p$[ebp]
  00901	83 c2 01	 add	 edx, 1
  00904	89 55 e0	 mov	 DWORD PTR _p$[ebp], edx

; 214  :         if (m_reg <= 1) {

  00907	0f b6 45 9b	 movzx	 eax, BYTE PTR _m_reg$[ebp]
  0090b	83 f8 01	 cmp	 eax, 1
  0090e	7f 2c		 jg	 SHORT $LN87@hde32_disa

; 215  :             if (opcode == 0xf6)

  00910	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  00914	3d f6 00 00 00	 cmp	 eax, 246		; 000000f6H
  00919	75 0c		 jne	 SHORT $LN88@hde32_disa

; 216  :                 cflags |= C_IMM8;

  0091b	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  0091f	83 c8 02	 or	 eax, 2
  00922	88 45 d7	 mov	 BYTE PTR _cflags$[ebp], al
  00925	eb 15		 jmp	 SHORT $LN87@hde32_disa
$LN88@hde32_disa:

; 217  :             else if (opcode == 0xf7)

  00927	0f b6 45 cb	 movzx	 eax, BYTE PTR _opcode$[ebp]
  0092b	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00930	75 0a		 jne	 SHORT $LN87@hde32_disa

; 218  :                 cflags |= C_IMM_P66;

  00932	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00936	83 c8 10	 or	 eax, 16			; 00000010H
  00939	88 45 d7	 mov	 BYTE PTR _cflags$[ebp], al
$LN87@hde32_disa:

; 219  :         }
; 220  : 
; 221  :         switch (m_mod) {

  0093c	8a 45 a7	 mov	 al, BYTE PTR _m_mod$[ebp]
  0093f	88 85 70 fe ff
	ff		 mov	 BYTE PTR tv403[ebp], al
  00945	80 bd 70 fe ff
	ff 00		 cmp	 BYTE PTR tv403[ebp], 0
  0094c	74 14		 je	 SHORT $LN91@hde32_disa
  0094e	80 bd 70 fe ff
	ff 01		 cmp	 BYTE PTR tv403[ebp], 1
  00955	74 32		 je	 SHORT $LN96@hde32_disa
  00957	80 bd 70 fe ff
	ff 02		 cmp	 BYTE PTR tv403[ebp], 2
  0095e	74 2f		 je	 SHORT $LN97@hde32_disa
  00960	eb 42		 jmp	 SHORT $LN19@hde32_disa
$LN91@hde32_disa:

; 222  :             case 0:
; 223  :                 if (pref & PRE_67) {

  00962	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00966	83 e0 10	 and	 eax, 16			; 00000010H
  00969	74 0f		 je	 SHORT $LN92@hde32_disa

; 224  :                     if (m_rm == 6)

  0096b	0f b6 45 8f	 movzx	 eax, BYTE PTR _m_rm$[ebp]
  0096f	83 f8 06	 cmp	 eax, 6
  00972	75 04		 jne	 SHORT $LN94@hde32_disa

; 225  :                         disp_size = 2;

  00974	c6 45 83 02	 mov	 BYTE PTR _disp_size$[ebp], 2
$LN94@hde32_disa:

; 226  :                 } else

  00978	eb 0d		 jmp	 SHORT $LN93@hde32_disa
$LN92@hde32_disa:

; 227  :                     if (m_rm == 5)

  0097a	0f b6 45 8f	 movzx	 eax, BYTE PTR _m_rm$[ebp]
  0097e	83 f8 05	 cmp	 eax, 5
  00981	75 04		 jne	 SHORT $LN93@hde32_disa

; 228  :                         disp_size = 4;

  00983	c6 45 83 04	 mov	 BYTE PTR _disp_size$[ebp], 4
$LN93@hde32_disa:

; 229  :                 break;

  00987	eb 1b		 jmp	 SHORT $LN19@hde32_disa
$LN96@hde32_disa:

; 230  :             case 1:
; 231  :                 disp_size = 1;

  00989	c6 45 83 01	 mov	 BYTE PTR _disp_size$[ebp], 1

; 232  :                 break;

  0098d	eb 15		 jmp	 SHORT $LN19@hde32_disa
$LN97@hde32_disa:

; 233  :             case 2:
; 234  :                 disp_size = 2;

  0098f	c6 45 83 02	 mov	 BYTE PTR _disp_size$[ebp], 2

; 235  :                 if (!(pref & PRE_67))

  00993	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00997	83 e0 10	 and	 eax, 16			; 00000010H
  0099a	75 08		 jne	 SHORT $LN19@hde32_disa

; 236  :                     disp_size <<= 1;

  0099c	8a 45 83	 mov	 al, BYTE PTR _disp_size$[ebp]
  0099f	d0 e0		 shl	 al, 1
  009a1	88 45 83	 mov	 BYTE PTR _disp_size$[ebp], al
$LN19@hde32_disa:

; 237  :         }
; 238  : 
; 239  :         if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {

  009a4	0f b6 45 a7	 movzx	 eax, BYTE PTR _m_mod$[ebp]
  009a8	83 f8 03	 cmp	 eax, 3
  009ab	0f 84 e2 00 00
	00		 je	 $LN99@hde32_disa
  009b1	0f b6 45 8f	 movzx	 eax, BYTE PTR _m_rm$[ebp]
  009b5	83 f8 04	 cmp	 eax, 4
  009b8	0f 85 d5 00 00
	00		 jne	 $LN99@hde32_disa
  009be	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  009c2	83 e0 10	 and	 eax, 16			; 00000010H
  009c5	0f 85 c8 00 00
	00		 jne	 $LN99@hde32_disa

; 240  :             hs->flags |= F_SIB;

  009cb	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  009ce	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  009d1	83 c9 02	 or	 ecx, 2
  009d4	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  009d7	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 241  :             p++;

  009da	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  009dd	83 c0 01	 add	 eax, 1
  009e0	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax

; 242  :             hs->sib = c;

  009e3	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  009ea	75 0d		 jne	 SHORT $LN143@hde32_disa
  009ec	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  009f1	e8 00 00 00 00	 call	 __RTC_UninitUse
  009f6	83 c4 04	 add	 esp, 4
$LN143@hde32_disa:
  009f9	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  009fc	8a 4d ef	 mov	 cl, BYTE PTR _c$[ebp]
  009ff	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 243  :             hs->sib_scale = c >> 6;

  00a02	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00a09	75 0d		 jne	 SHORT $LN144@hde32_disa
  00a0b	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00a10	e8 00 00 00 00	 call	 __RTC_UninitUse
  00a15	83 c4 04	 add	 esp, 4
$LN144@hde32_disa:
  00a18	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  00a1c	c1 f8 06	 sar	 eax, 6
  00a1f	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  00a22	88 41 0d	 mov	 BYTE PTR [ecx+13], al

; 244  :             hs->sib_index = (c & 0x3f) >> 3;

  00a25	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00a2c	75 0d		 jne	 SHORT $LN145@hde32_disa
  00a2e	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00a33	e8 00 00 00 00	 call	 __RTC_UninitUse
  00a38	83 c4 04	 add	 esp, 4
$LN145@hde32_disa:
  00a3b	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  00a3f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00a42	c1 f8 03	 sar	 eax, 3
  00a45	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  00a48	88 41 0e	 mov	 BYTE PTR [ecx+14], al

; 245  :             if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))

  00a4b	80 bd 7b fe ff
	ff 00		 cmp	 BYTE PTR $T1[ebp], 0
  00a52	75 0d		 jne	 SHORT $LN146@hde32_disa
  00a54	68 00 00 00 00	 push	 OFFSET $LN126@hde32_disa
  00a59	e8 00 00 00 00	 call	 __RTC_UninitUse
  00a5e	83 c4 04	 add	 esp, 4
$LN146@hde32_disa:
  00a61	0f b6 45 ef	 movzx	 eax, BYTE PTR _c$[ebp]
  00a65	83 e0 07	 and	 eax, 7
  00a68	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv443[ebp], eax
  00a6e	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  00a71	8a 95 70 fe ff
	ff		 mov	 dl, BYTE PTR tv443[ebp]
  00a77	88 51 0f	 mov	 BYTE PTR [ecx+15], dl
  00a7a	0f b6 85 70 fe
	ff ff		 movzx	 eax, BYTE PTR tv443[ebp]
  00a81	83 f8 05	 cmp	 eax, 5
  00a84	75 0d		 jne	 SHORT $LN99@hde32_disa
  00a86	0f b6 45 a7	 movzx	 eax, BYTE PTR _m_mod$[ebp]
  00a8a	83 e0 01	 and	 eax, 1
  00a8d	75 04		 jne	 SHORT $LN99@hde32_disa

; 246  :                 disp_size = 4;

  00a8f	c6 45 83 04	 mov	 BYTE PTR _disp_size$[ebp], 4
$LN99@hde32_disa:

; 247  :         }
; 248  : 
; 249  :         p--;

  00a93	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00a96	83 e8 01	 sub	 eax, 1
  00a99	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax

; 250  :         switch (disp_size) {

  00a9c	8a 45 83	 mov	 al, BYTE PTR _disp_size$[ebp]
  00a9f	88 85 70 fe ff
	ff		 mov	 BYTE PTR tv452[ebp], al
  00aa5	80 bd 70 fe ff
	ff 01		 cmp	 BYTE PTR tv452[ebp], 1
  00aac	74 14		 je	 SHORT $LN101@hde32_disa
  00aae	80 bd 70 fe ff
	ff 02		 cmp	 BYTE PTR tv452[ebp], 2
  00ab5	74 27		 je	 SHORT $LN102@hde32_disa
  00ab7	80 bd 70 fe ff
	ff 04		 cmp	 BYTE PTR tv452[ebp], 4
  00abe	74 3c		 je	 SHORT $LN103@hde32_disa
  00ac0	eb 57		 jmp	 SHORT $LN21@hde32_disa
$LN101@hde32_disa:

; 251  :             case 1:
; 252  :                 hs->flags |= F_DISP8;

  00ac2	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00ac5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00ac8	83 c9 20	 or	 ecx, 32			; 00000020H
  00acb	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00ace	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 253  :                 hs->disp.disp8 = *p;

  00ad1	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00ad4	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00ad7	8a 11		 mov	 dl, BYTE PTR [ecx]
  00ad9	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 254  :                 break;

  00adc	eb 3b		 jmp	 SHORT $LN21@hde32_disa
$LN102@hde32_disa:

; 255  :             case 2:
; 256  :                 hs->flags |= F_DISP16;

  00ade	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00ae1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00ae4	83 c9 40	 or	 ecx, 64			; 00000040H
  00ae7	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00aea	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 257  :                 hs->disp.disp16 = *(uint16_t *)p;

  00aed	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00af0	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00af3	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00af6	66 89 50 14	 mov	 WORD PTR [eax+20], dx

; 258  :                 break;

  00afa	eb 1d		 jmp	 SHORT $LN21@hde32_disa
$LN103@hde32_disa:

; 259  :             case 4:
; 260  :                 hs->flags |= F_DISP32;

  00afc	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00aff	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00b02	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  00b08	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00b0b	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 261  :                 hs->disp.disp32 = *(uint32_t *)p;

  00b0e	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00b11	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00b14	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b16	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN21@hde32_disa:

; 262  :         }
; 263  :         p += disp_size;

  00b19	0f b6 45 83	 movzx	 eax, BYTE PTR _disp_size$[ebp]
  00b1d	03 45 e0	 add	 eax, DWORD PTR _p$[ebp]
  00b20	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
  00b23	eb 1b		 jmp	 SHORT $LN42@hde32_disa
$LN41@hde32_disa:

; 264  :     } else if (pref & PRE_LOCK)

  00b25	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00b29	83 e0 20	 and	 eax, 32			; 00000020H
  00b2c	74 12		 je	 SHORT $LN42@hde32_disa

; 265  :         hs->flags |= F_ERROR | F_ERROR_LOCK;

  00b2e	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00b31	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00b34	81 c9 00 90 00
	00		 or	 ecx, 36864		; 00009000H
  00b3a	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00b3d	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN42@hde32_disa:

; 266  : 
; 267  :     if (cflags & C_IMM_P66) {

  00b40	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00b44	83 e0 10	 and	 eax, 16			; 00000010H
  00b47	0f 84 97 00 00
	00		 je	 $LN105@hde32_disa

; 268  :         if (cflags & C_REL32) {

  00b4d	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00b51	83 e0 40	 and	 eax, 64			; 00000040H
  00b54	74 3b		 je	 SHORT $LN106@hde32_disa

; 269  :             if (pref & PRE_66) {

  00b56	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00b5a	83 e0 08	 and	 eax, 8
  00b5d	74 2d		 je	 SHORT $LN107@hde32_disa

; 270  :                 hs->flags |= F_IMM16 | F_RELATIVE;

  00b5f	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00b62	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00b65	81 c9 08 01 00
	00		 or	 ecx, 264		; 00000108H
  00b6b	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00b6e	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 271  :                 hs->imm.imm16 = *(uint16_t *)p;

  00b71	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00b74	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00b77	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00b7a	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 272  :                 p += 2;

  00b7e	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00b81	83 c0 02	 add	 eax, 2
  00b84	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax

; 273  :                 goto disasm_done;

  00b87	e9 67 01 00 00	 jmp	 $disasm_done$159
$LN107@hde32_disa:

; 274  :             }
; 275  :             goto rel32_ok;

  00b8c	e9 0b 01 00 00	 jmp	 $rel32_ok$160
$LN106@hde32_disa:

; 276  :         }
; 277  :         if (pref & PRE_66) {

  00b91	0f b6 45 bf	 movzx	 eax, BYTE PTR _pref$[ebp]
  00b95	83 e0 08	 and	 eax, 8
  00b98	74 27		 je	 SHORT $LN108@hde32_disa

; 278  :             hs->flags |= F_IMM16;

  00b9a	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00b9d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00ba0	83 c9 08	 or	 ecx, 8
  00ba3	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00ba6	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 279  :             hs->imm.imm16 = *(uint16_t *)p;

  00ba9	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00bac	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00baf	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00bb2	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 280  :             p += 2;

  00bb6	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00bb9	83 c0 02	 add	 eax, 2
  00bbc	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax

; 281  :         } else {

  00bbf	eb 23		 jmp	 SHORT $LN105@hde32_disa
$LN108@hde32_disa:

; 282  :             hs->flags |= F_IMM32;

  00bc1	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00bc4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00bc7	83 c9 10	 or	 ecx, 16			; 00000010H
  00bca	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00bcd	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 283  :             hs->imm.imm32 = *(uint32_t *)p;

  00bd0	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00bd3	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00bd6	8b 11		 mov	 edx, DWORD PTR [ecx]
  00bd8	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 284  :             p += 4;

  00bdb	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00bde	83 c0 04	 add	 eax, 4
  00be1	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
$LN105@hde32_disa:

; 285  :         }
; 286  :     }
; 287  : 
; 288  :     if (cflags & C_IMM16) {

  00be4	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00be8	83 e0 04	 and	 eax, 4
  00beb	74 7a		 je	 SHORT $LN110@hde32_disa

; 289  :         if (hs->flags & F_IMM32) {

  00bed	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00bf0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00bf3	83 e1 10	 and	 ecx, 16			; 00000010H
  00bf6	74 1e		 je	 SHORT $LN111@hde32_disa

; 290  :             hs->flags |= F_IMM16;

  00bf8	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00bfb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00bfe	83 c9 08	 or	 ecx, 8
  00c01	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00c04	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 291  :             hs->disp.disp16 = *(uint16_t *)p;

  00c07	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c0a	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00c0d	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00c10	66 89 50 14	 mov	 WORD PTR [eax+20], dx
  00c14	eb 48		 jmp	 SHORT $LN112@hde32_disa
$LN111@hde32_disa:

; 292  :         } else if (hs->flags & F_IMM16) {

  00c16	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c19	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00c1c	83 e1 08	 and	 ecx, 8
  00c1f	74 21		 je	 SHORT $LN113@hde32_disa

; 293  :             hs->flags |= F_2IMM16;

  00c21	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c24	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00c27	81 c9 00 08 00
	00		 or	 ecx, 2048		; 00000800H
  00c2d	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00c30	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 294  :             hs->disp.disp16 = *(uint16_t *)p;

  00c33	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c36	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00c39	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00c3c	66 89 50 14	 mov	 WORD PTR [eax+20], dx

; 295  :         } else {

  00c40	eb 1c		 jmp	 SHORT $LN112@hde32_disa
$LN113@hde32_disa:

; 296  :             hs->flags |= F_IMM16;

  00c42	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c45	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00c48	83 c9 08	 or	 ecx, 8
  00c4b	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00c4e	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 297  :             hs->imm.imm16 = *(uint16_t *)p;

  00c51	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c54	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00c57	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00c5a	66 89 50 10	 mov	 WORD PTR [eax+16], dx
$LN112@hde32_disa:

; 298  :         }
; 299  :         p += 2;

  00c5e	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00c61	83 c0 02	 add	 eax, 2
  00c64	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
$LN110@hde32_disa:

; 300  :     }
; 301  :     if (cflags & C_IMM8) {

  00c67	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00c6b	83 e0 02	 and	 eax, 2
  00c6e	74 23		 je	 SHORT $LN115@hde32_disa

; 302  :         hs->flags |= F_IMM8;

  00c70	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c73	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00c76	83 c9 04	 or	 ecx, 4
  00c79	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00c7c	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 303  :         hs->imm.imm8 = *p++;

  00c7f	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c82	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00c85	8a 11		 mov	 dl, BYTE PTR [ecx]
  00c87	88 50 10	 mov	 BYTE PTR [eax+16], dl
  00c8a	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00c8d	83 c0 01	 add	 eax, 1
  00c90	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
$LN115@hde32_disa:

; 304  :     }
; 305  : 
; 306  :     if (cflags & C_REL32) {

  00c93	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00c97	83 e0 40	 and	 eax, 64			; 00000040H
  00c9a	74 28		 je	 SHORT $LN116@hde32_disa
$rel32_ok$160:

; 307  :       rel32_ok:
; 308  :         hs->flags |= F_IMM32 | F_RELATIVE;

  00c9c	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00c9f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00ca2	81 c9 10 01 00
	00		 or	 ecx, 272		; 00000110H
  00ca8	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00cab	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 309  :         hs->imm.imm32 = *(uint32_t *)p;

  00cae	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00cb1	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00cb4	8b 11		 mov	 edx, DWORD PTR [ecx]
  00cb6	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 310  :         p += 4;

  00cb9	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00cbc	83 c0 04	 add	 eax, 4
  00cbf	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
  00cc2	eb 2f		 jmp	 SHORT $disasm_done$159
$LN116@hde32_disa:

; 311  :     } else if (cflags & C_REL8) {

  00cc4	0f b6 45 d7	 movzx	 eax, BYTE PTR _cflags$[ebp]
  00cc8	83 e0 20	 and	 eax, 32			; 00000020H
  00ccb	74 26		 je	 SHORT $disasm_done$159

; 312  :         hs->flags |= F_IMM8 | F_RELATIVE;

  00ccd	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00cd0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00cd3	81 c9 04 01 00
	00		 or	 ecx, 260		; 00000104H
  00cd9	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00cdc	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 313  :         hs->imm.imm8 = *p++;

  00cdf	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00ce2	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  00ce5	8a 11		 mov	 dl, BYTE PTR [ecx]
  00ce7	88 50 10	 mov	 BYTE PTR [eax+16], dl
  00cea	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00ced	83 c0 01	 add	 eax, 1
  00cf0	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
$disasm_done$159:

; 314  :     }
; 315  : 
; 316  :   disasm_done:
; 317  : 
; 318  :     if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {

  00cf3	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00cf6	2b 45 08	 sub	 eax, DWORD PTR _code$[ebp]
  00cf9	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv552[ebp], eax
  00cff	8b 4d 0c	 mov	 ecx, DWORD PTR _hs$[ebp]
  00d02	8a 95 70 fe ff
	ff		 mov	 dl, BYTE PTR tv552[ebp]
  00d08	88 11		 mov	 BYTE PTR [ecx], dl
  00d0a	0f b6 85 70 fe
	ff ff		 movzx	 eax, BYTE PTR tv552[ebp]
  00d11	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00d14	7e 18		 jle	 SHORT $LN119@hde32_disa

; 319  :         hs->flags |= F_ERROR | F_ERROR_LENGTH;

  00d16	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00d19	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00d1c	81 c9 00 50 00
	00		 or	 ecx, 20480		; 00005000H
  00d22	8b 55 0c	 mov	 edx, DWORD PTR _hs$[ebp]
  00d25	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 320  :         hs->len = 15;

  00d28	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00d2b	c6 00 0f	 mov	 BYTE PTR [eax], 15	; 0000000fH
$LN119@hde32_disa:

; 321  :     }
; 322  : 
; 323  :     return (unsigned int)hs->len;

  00d2e	8b 45 0c	 mov	 eax, DWORD PTR _hs$[ebp]
  00d31	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 324  : }

  00d34	5f		 pop	 edi
  00d35	5e		 pop	 esi
  00d36	5b		 pop	 ebx
  00d37	81 c4 98 01 00
	00		 add	 esp, 408		; 00000198H
  00d3d	3b ec		 cmp	 ebp, esp
  00d3f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d44	8b e5		 mov	 esp, ebp
  00d46	5d		 pop	 ebp
  00d47	c3		 ret	 0
$LN152@hde32_disa:
$LN126@hde32_disa:
  00d48	63		 DB	 99			; 00000063H
  00d49	00		 DB	 0
  00d4a	66 90		 npad	 2
$LN148@hde32_disa:
  00d4c	00 00 00 00	 DD	 $LN26@hde32_disa
  00d50	00 00 00 00	 DD	 $LN27@hde32_disa
  00d54	00 00 00 00	 DD	 $LN28@hde32_disa
  00d58	00 00 00 00	 DD	 $LN25@hde32_disa
  00d5c	00 00 00 00	 DD	 $LN24@hde32_disa
  00d60	00 00 00 00	 DD	 $LN23@hde32_disa
  00d64	00 00 00 00	 DD	 $LN29@hde32_disa
$LN147@hde32_disa:
  00d68	00		 DB	 0
  00d69	06		 DB	 6
  00d6a	06		 DB	 6
  00d6b	06		 DB	 6
  00d6c	06		 DB	 6
  00d6d	06		 DB	 6
  00d6e	06		 DB	 6
  00d6f	06		 DB	 6
  00d70	00		 DB	 0
  00d71	06		 DB	 6
  00d72	06		 DB	 6
  00d73	06		 DB	 6
  00d74	06		 DB	 6
  00d75	06		 DB	 6
  00d76	06		 DB	 6
  00d77	06		 DB	 6
  00d78	00		 DB	 0
  00d79	06		 DB	 6
  00d7a	06		 DB	 6
  00d7b	06		 DB	 6
  00d7c	06		 DB	 6
  00d7d	06		 DB	 6
  00d7e	06		 DB	 6
  00d7f	06		 DB	 6
  00d80	00		 DB	 0
  00d81	06		 DB	 6
  00d82	06		 DB	 6
  00d83	06		 DB	 6
  00d84	06		 DB	 6
  00d85	06		 DB	 6
  00d86	06		 DB	 6
  00d87	06		 DB	 6
  00d88	06		 DB	 6
  00d89	06		 DB	 6
  00d8a	06		 DB	 6
  00d8b	06		 DB	 6
  00d8c	06		 DB	 6
  00d8d	06		 DB	 6
  00d8e	06		 DB	 6
  00d8f	06		 DB	 6
  00d90	06		 DB	 6
  00d91	06		 DB	 6
  00d92	06		 DB	 6
  00d93	06		 DB	 6
  00d94	06		 DB	 6
  00d95	06		 DB	 6
  00d96	06		 DB	 6
  00d97	06		 DB	 6
  00d98	06		 DB	 6
  00d99	06		 DB	 6
  00d9a	06		 DB	 6
  00d9b	06		 DB	 6
  00d9c	06		 DB	 6
  00d9d	06		 DB	 6
  00d9e	06		 DB	 6
  00d9f	06		 DB	 6
  00da0	06		 DB	 6
  00da1	06		 DB	 6
  00da2	06		 DB	 6
  00da3	06		 DB	 6
  00da4	06		 DB	 6
  00da5	06		 DB	 6
  00da6	00		 DB	 0
  00da7	00		 DB	 0
  00da8	01		 DB	 1
  00da9	02		 DB	 2
  00daa	06		 DB	 6
  00dab	06		 DB	 6
  00dac	06		 DB	 6
  00dad	06		 DB	 6
  00dae	06		 DB	 6
  00daf	06		 DB	 6
  00db0	06		 DB	 6
  00db1	06		 DB	 6
  00db2	06		 DB	 6
  00db3	06		 DB	 6
  00db4	06		 DB	 6
  00db5	06		 DB	 6
  00db6	06		 DB	 6
  00db7	06		 DB	 6
  00db8	06		 DB	 6
  00db9	06		 DB	 6
  00dba	06		 DB	 6
  00dbb	06		 DB	 6
  00dbc	06		 DB	 6
  00dbd	06		 DB	 6
  00dbe	06		 DB	 6
  00dbf	06		 DB	 6
  00dc0	06		 DB	 6
  00dc1	06		 DB	 6
  00dc2	06		 DB	 6
  00dc3	06		 DB	 6
  00dc4	06		 DB	 6
  00dc5	06		 DB	 6
  00dc6	06		 DB	 6
  00dc7	06		 DB	 6
  00dc8	06		 DB	 6
  00dc9	06		 DB	 6
  00dca	06		 DB	 6
  00dcb	06		 DB	 6
  00dcc	06		 DB	 6
  00dcd	06		 DB	 6
  00dce	06		 DB	 6
  00dcf	06		 DB	 6
  00dd0	06		 DB	 6
  00dd1	06		 DB	 6
  00dd2	06		 DB	 6
  00dd3	06		 DB	 6
  00dd4	06		 DB	 6
  00dd5	06		 DB	 6
  00dd6	06		 DB	 6
  00dd7	06		 DB	 6
  00dd8	06		 DB	 6
  00dd9	06		 DB	 6
  00dda	06		 DB	 6
  00ddb	06		 DB	 6
  00ddc	06		 DB	 6
  00ddd	06		 DB	 6
  00dde	06		 DB	 6
  00ddf	06		 DB	 6
  00de0	06		 DB	 6
  00de1	06		 DB	 6
  00de2	06		 DB	 6
  00de3	06		 DB	 6
  00de4	06		 DB	 6
  00de5	06		 DB	 6
  00de6	06		 DB	 6
  00de7	06		 DB	 6
  00de8	06		 DB	 6
  00de9	06		 DB	 6
  00dea	06		 DB	 6
  00deb	06		 DB	 6
  00dec	06		 DB	 6
  00ded	06		 DB	 6
  00dee	06		 DB	 6
  00def	06		 DB	 6
  00df0	06		 DB	 6
  00df1	06		 DB	 6
  00df2	06		 DB	 6
  00df3	06		 DB	 6
  00df4	06		 DB	 6
  00df5	06		 DB	 6
  00df6	06		 DB	 6
  00df7	06		 DB	 6
  00df8	06		 DB	 6
  00df9	06		 DB	 6
  00dfa	06		 DB	 6
  00dfb	06		 DB	 6
  00dfc	06		 DB	 6
  00dfd	06		 DB	 6
  00dfe	06		 DB	 6
  00dff	06		 DB	 6
  00e00	06		 DB	 6
  00e01	06		 DB	 6
  00e02	06		 DB	 6
  00e03	06		 DB	 6
  00e04	06		 DB	 6
  00e05	06		 DB	 6
  00e06	06		 DB	 6
  00e07	06		 DB	 6
  00e08	06		 DB	 6
  00e09	06		 DB	 6
  00e0a	06		 DB	 6
  00e0b	06		 DB	 6
  00e0c	06		 DB	 6
  00e0d	06		 DB	 6
  00e0e	06		 DB	 6
  00e0f	06		 DB	 6
  00e10	06		 DB	 6
  00e11	06		 DB	 6
  00e12	06		 DB	 6
  00e13	06		 DB	 6
  00e14	06		 DB	 6
  00e15	06		 DB	 6
  00e16	06		 DB	 6
  00e17	06		 DB	 6
  00e18	06		 DB	 6
  00e19	06		 DB	 6
  00e1a	06		 DB	 6
  00e1b	06		 DB	 6
  00e1c	06		 DB	 6
  00e1d	06		 DB	 6
  00e1e	06		 DB	 6
  00e1f	06		 DB	 6
  00e20	06		 DB	 6
  00e21	06		 DB	 6
  00e22	06		 DB	 6
  00e23	06		 DB	 6
  00e24	06		 DB	 6
  00e25	06		 DB	 6
  00e26	06		 DB	 6
  00e27	06		 DB	 6
  00e28	06		 DB	 6
  00e29	06		 DB	 6
  00e2a	06		 DB	 6
  00e2b	06		 DB	 6
  00e2c	06		 DB	 6
  00e2d	06		 DB	 6
  00e2e	06		 DB	 6
  00e2f	06		 DB	 6
  00e30	06		 DB	 6
  00e31	06		 DB	 6
  00e32	03		 DB	 3
  00e33	06		 DB	 6
  00e34	04		 DB	 4
  00e35	05		 DB	 5
  00e36	66 90		 npad	 2
$LN149@hde32_disa:
  00e38	00 00 00 00	 DD	 $LN58@hde32_disa
  00e3c	00 00 00 00	 DD	 $LN62@hde32_disa
  00e40	00 00 00 00	 DD	 $LN58@hde32_disa
  00e44	00 00 00 00	 DD	 $LN62@hde32_disa
$LN151@hde32_disa:
  00e48	00 00 00 00	 DD	 $LN82@hde32_disa
  00e4c	00 00 00 00	 DD	 $LN86@hde32_disa
  00e50	00 00 00 00	 DD	 $LN84@hde32_disa
  00e54	00 00 00 00	 DD	 $LN17@hde32_disa
$LN150@hde32_disa:
  00e58	00		 DB	 0
  00e59	03		 DB	 3
  00e5a	03		 DB	 3
  00e5b	03		 DB	 3
  00e5c	03		 DB	 3
  00e5d	03		 DB	 3
  00e5e	03		 DB	 3
  00e5f	03		 DB	 3
  00e60	03		 DB	 3
  00e61	03		 DB	 3
  00e62	03		 DB	 3
  00e63	03		 DB	 3
  00e64	03		 DB	 3
  00e65	03		 DB	 3
  00e66	03		 DB	 3
  00e67	03		 DB	 3
  00e68	03		 DB	 3
  00e69	03		 DB	 3
  00e6a	03		 DB	 3
  00e6b	03		 DB	 3
  00e6c	03		 DB	 3
  00e6d	03		 DB	 3
  00e6e	03		 DB	 3
  00e6f	03		 DB	 3
  00e70	03		 DB	 3
  00e71	03		 DB	 3
  00e72	03		 DB	 3
  00e73	03		 DB	 3
  00e74	03		 DB	 3
  00e75	03		 DB	 3
  00e76	03		 DB	 3
  00e77	03		 DB	 3
  00e78	03		 DB	 3
  00e79	03		 DB	 3
  00e7a	03		 DB	 3
  00e7b	03		 DB	 3
  00e7c	03		 DB	 3
  00e7d	03		 DB	 3
  00e7e	03		 DB	 3
  00e7f	03		 DB	 3
  00e80	03		 DB	 3
  00e81	03		 DB	 3
  00e82	03		 DB	 3
  00e83	03		 DB	 3
  00e84	03		 DB	 3
  00e85	03		 DB	 3
  00e86	03		 DB	 3
  00e87	03		 DB	 3
  00e88	03		 DB	 3
  00e89	03		 DB	 3
  00e8a	03		 DB	 3
  00e8b	03		 DB	 3
  00e8c	03		 DB	 3
  00e8d	03		 DB	 3
  00e8e	03		 DB	 3
  00e8f	03		 DB	 3
  00e90	03		 DB	 3
  00e91	03		 DB	 3
  00e92	03		 DB	 3
  00e93	03		 DB	 3
  00e94	03		 DB	 3
  00e95	03		 DB	 3
  00e96	03		 DB	 3
  00e97	03		 DB	 3
  00e98	03		 DB	 3
  00e99	03		 DB	 3
  00e9a	03		 DB	 3
  00e9b	03		 DB	 3
  00e9c	03		 DB	 3
  00e9d	03		 DB	 3
  00e9e	03		 DB	 3
  00e9f	03		 DB	 3
  00ea0	03		 DB	 3
  00ea1	03		 DB	 3
  00ea2	03		 DB	 3
  00ea3	03		 DB	 3
  00ea4	03		 DB	 3
  00ea5	03		 DB	 3
  00ea6	03		 DB	 3
  00ea7	03		 DB	 3
  00ea8	03		 DB	 3
  00ea9	03		 DB	 3
  00eaa	03		 DB	 3
  00eab	03		 DB	 3
  00eac	03		 DB	 3
  00ead	03		 DB	 3
  00eae	03		 DB	 3
  00eaf	03		 DB	 3
  00eb0	03		 DB	 3
  00eb1	03		 DB	 3
  00eb2	03		 DB	 3
  00eb3	03		 DB	 3
  00eb4	03		 DB	 3
  00eb5	03		 DB	 3
  00eb6	03		 DB	 3
  00eb7	03		 DB	 3
  00eb8	03		 DB	 3
  00eb9	03		 DB	 3
  00eba	03		 DB	 3
  00ebb	03		 DB	 3
  00ebc	03		 DB	 3
  00ebd	03		 DB	 3
  00ebe	03		 DB	 3
  00ebf	03		 DB	 3
  00ec0	03		 DB	 3
  00ec1	03		 DB	 3
  00ec2	03		 DB	 3
  00ec3	03		 DB	 3
  00ec4	03		 DB	 3
  00ec5	03		 DB	 3
  00ec6	03		 DB	 3
  00ec7	03		 DB	 3
  00ec8	03		 DB	 3
  00ec9	03		 DB	 3
  00eca	03		 DB	 3
  00ecb	03		 DB	 3
  00ecc	03		 DB	 3
  00ecd	01		 DB	 1
  00ece	03		 DB	 3
  00ecf	03		 DB	 3
  00ed0	03		 DB	 3
  00ed1	03		 DB	 3
  00ed2	03		 DB	 3
  00ed3	03		 DB	 3
  00ed4	03		 DB	 3
  00ed5	03		 DB	 3
  00ed6	03		 DB	 3
  00ed7	03		 DB	 3
  00ed8	03		 DB	 3
  00ed9	03		 DB	 3
  00eda	03		 DB	 3
  00edb	03		 DB	 3
  00edc	03		 DB	 3
  00edd	03		 DB	 3
  00ede	02		 DB	 2
  00edf	00		 DB	 0
  00ee0	03		 DB	 3
  00ee1	03		 DB	 3
  00ee2	03		 DB	 3
  00ee3	03		 DB	 3
  00ee4	03		 DB	 3
  00ee5	03		 DB	 3
  00ee6	03		 DB	 3
  00ee7	03		 DB	 3
  00ee8	03		 DB	 3
  00ee9	03		 DB	 3
  00eea	03		 DB	 3
  00eeb	03		 DB	 3
  00eec	03		 DB	 3
  00eed	03		 DB	 3
  00eee	03		 DB	 3
  00eef	03		 DB	 3
  00ef0	03		 DB	 3
  00ef1	03		 DB	 3
  00ef2	03		 DB	 3
  00ef3	03		 DB	 3
  00ef4	03		 DB	 3
  00ef5	03		 DB	 3
  00ef6	03		 DB	 3
  00ef7	03		 DB	 3
  00ef8	03		 DB	 3
  00ef9	03		 DB	 3
  00efa	03		 DB	 3
  00efb	03		 DB	 3
  00efc	03		 DB	 3
  00efd	03		 DB	 3
  00efe	03		 DB	 3
  00eff	00		 DB	 0
_hde32_disasm ENDP
_TEXT	ENDS
END
