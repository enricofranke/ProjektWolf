; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\trampoline.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__E6E7469F_winioctl@h DB 01H
__08182E14_stralign@h DB 01H
__546B2D2F_trampoline@c DB 01H
msvcjmc	ENDS
PUBLIC	_CreateTrampolineFunction
PUBLIC	__JustMyCode_Default
EXTRN	_hde32_disasm:PROC
EXTRN	_IsExecutableAddress:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\trampoline.c
;	COMDAT _IsCodePadding
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pInst$ = 8						; size = 4
_size$ = 12						; size = 4
_IsCodePadding PROC					; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __546B2D2F_trampoline@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 58   :     UINT i;
; 59   : 
; 60   :     if (pInst[0] != 0x00 && pInst[0] != 0x90 && pInst[0] != 0xCC)

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _pInst$[ebp]
  00033	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00037	85 c0		 test	 eax, eax
  00039	74 30		 je	 SHORT $LN5@IsCodePadd
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	6b c8 00	 imul	 ecx, eax, 0
  00043	8b 55 08	 mov	 edx, DWORD PTR _pInst$[ebp]
  00046	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0004a	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  0004f	74 1a		 je	 SHORT $LN5@IsCodePadd
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	6b c8 00	 imul	 ecx, eax, 0
  00059	8b 55 08	 mov	 edx, DWORD PTR _pInst$[ebp]
  0005c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00060	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  00065	74 04		 je	 SHORT $LN5@IsCodePadd

; 61   :         return FALSE;

  00067	33 c0		 xor	 eax, eax
  00069	eb 41		 jmp	 SHORT $LN1@IsCodePadd
$LN5@IsCodePadd:

; 62   : 
; 63   :     for (i = 1; i < size; ++i)

  0006b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00072	eb 09		 jmp	 SHORT $LN4@IsCodePadd
$LN2@IsCodePadd:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00077	83 c0 01	 add	 eax, 1
  0007a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@IsCodePadd:
  0007d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00080	3b 45 0c	 cmp	 eax, DWORD PTR _size$[ebp]
  00083	73 22		 jae	 SHORT $LN3@IsCodePadd

; 64   :     {
; 65   :         if (pInst[i] != pInst[0])

  00085	8b 45 08	 mov	 eax, DWORD PTR _pInst$[ebp]
  00088	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0008b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0008e	ba 01 00 00 00	 mov	 edx, 1
  00093	6b c2 00	 imul	 eax, edx, 0
  00096	8b 55 08	 mov	 edx, DWORD PTR _pInst$[ebp]
  00099	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  0009d	3b c8		 cmp	 ecx, eax
  0009f	74 04		 je	 SHORT $LN6@IsCodePadd

; 66   :             return FALSE;

  000a1	33 c0		 xor	 eax, eax
  000a3	eb 07		 jmp	 SHORT $LN1@IsCodePadd
$LN6@IsCodePadd:

; 67   :     }

  000a5	eb cd		 jmp	 SHORT $LN2@IsCodePadd
$LN3@IsCodePadd:

; 68   :     return TRUE;

  000a7	b8 01 00 00 00	 mov	 eax, 1
$LN1@IsCodePadd:

; 69   : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b5	3b ec		 cmp	 ebp, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_IsCodePadding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\trampoline.c
;	COMDAT _CreateTrampolineFunction
_TEXT	SEGMENT
tv217 = -428						; size = 4
tv205 = -428						; size = 4
tv171 = -428						; size = 4
_cond$1 = -225						; size = 1
_dest$2 = -216						; size = 4
_dest$3 = -204						; size = 4
_dest$4 = -192						; size = 4
_pNewInst$5 = -180					; size = 4
_pOldInst$6 = -168					; size = 4
_pCopySrc$7 = -156					; size = 4
_copySize$8 = -144					; size = 4
_hs$9 = -132						; size = 28
_finished$ = -96					; size = 4
_jmpDest$ = -84						; size = 4
_newPos$ = -69						; size = 1
_oldPos$ = -57						; size = 1
_jcc$ = -48						; size = 6
_jmp$ = -32						; size = 5
_call$ = -16						; size = 5
__$ArrayPad$ = -4					; size = 4
_ct$ = 8						; size = 4
_CreateTrampolineFunction PROC				; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 54 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-428]
  00012	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __546B2D2F_trampoline@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 74   : #if defined(_M_X64) || defined(__x86_64__)
; 75   :     CALL_ABS call = {
; 76   :         0xFF, 0x15, 0x00000002, // FF15 00000002: CALL [RIP+8]
; 77   :         0xEB, 0x08,             // EB 08:         JMP +10
; 78   :         0x0000000000000000ULL   // Absolute destination address
; 79   :     };
; 80   :     JMP_ABS jmp = {
; 81   :         0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
; 82   :         0x0000000000000000ULL   // Absolute destination address
; 83   :     };
; 84   :     JCC_ABS jcc = {
; 85   :         0x70, 0x0E,             // 7* 0E:         J** +16
; 86   :         0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
; 87   :         0x0000000000000000ULL   // Absolute destination address
; 88   :     };
; 89   : #else
; 90   :     CALL_REL call = {

  00032	c6 45 f0 e8	 mov	 BYTE PTR _call$[ebp], 232 ; 000000e8H
  00036	c7 45 f1 00 00
	00 00		 mov	 DWORD PTR _call$[ebp+1], 0

; 91   :         0xE8,                   // E8 xxxxxxxx: CALL +5+xxxxxxxx
; 92   :         0x00000000              // Relative destination address
; 93   :     };
; 94   :     JMP_REL jmp = {

  0003d	c6 45 e0 e9	 mov	 BYTE PTR _jmp$[ebp], 233 ; 000000e9H
  00041	c7 45 e1 00 00
	00 00		 mov	 DWORD PTR _jmp$[ebp+1], 0

; 95   :         0xE9,                   // E9 xxxxxxxx: JMP +5+xxxxxxxx
; 96   :         0x00000000              // Relative destination address
; 97   :     };
; 98   :     JCC_REL jcc = {

  00048	c6 45 d0 0f	 mov	 BYTE PTR _jcc$[ebp], 15	; 0000000fH
  0004c	c6 45 d1 80	 mov	 BYTE PTR _jcc$[ebp+1], 128 ; 00000080H
  00050	c7 45 d2 00 00
	00 00		 mov	 DWORD PTR _jcc$[ebp+2], 0

; 99   :         0x0F, 0x80,             // 0F8* xxxxxxxx: J** +6+xxxxxxxx
; 100  :         0x00000000              // Relative destination address
; 101  :     };
; 102  : #endif
; 103  : 
; 104  :     UINT8     oldPos   = 0;

  00057	c6 45 c7 00	 mov	 BYTE PTR _oldPos$[ebp], 0

; 105  :     UINT8     newPos   = 0;

  0005b	c6 45 bb 00	 mov	 BYTE PTR _newPos$[ebp], 0

; 106  :     ULONG_PTR jmpDest  = 0;     // Destination address of an internal jump.

  0005f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _jmpDest$[ebp], 0

; 107  :     BOOL      finished = FALSE; // Is the function completed?

  00066	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 0

; 108  : #if defined(_M_X64) || defined(__x86_64__)
; 109  :     UINT8     instBuf[16];
; 110  : #endif
; 111  : 
; 112  :     ct->patchAbove = FALSE;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  00070	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 113  :     ct->nIP        = 0;

  00077	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  0007a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN4@CreateTram:

; 114  : 
; 115  :     do
; 116  :     {
; 117  :         HDE       hs;
; 118  :         UINT      copySize;
; 119  :         LPVOID    pCopySrc;
; 120  :         ULONG_PTR pOldInst = (ULONG_PTR)ct->pTarget     + oldPos;

  00081	0f b6 45 c7	 movzx	 eax, BYTE PTR _oldPos$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _ct$[ebp]
  00088	03 01		 add	 eax, DWORD PTR [ecx]
  0008a	89 85 58 ff ff
	ff		 mov	 DWORD PTR _pOldInst$6[ebp], eax

; 121  :         ULONG_PTR pNewInst = (ULONG_PTR)ct->pTrampoline + newPos;

  00090	0f b6 45 bb	 movzx	 eax, BYTE PTR _newPos$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _ct$[ebp]
  00097	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0009a	89 85 4c ff ff
	ff		 mov	 DWORD PTR _pNewInst$5[ebp], eax

; 122  : 
; 123  :         copySize = HDE_DISASM((LPVOID)pOldInst, &hs);

  000a0	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _hs$9[ebp]
  000a6	50		 push	 eax
  000a7	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _pOldInst$6[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 _hde32_disasm
  000b3	83 c4 08	 add	 esp, 8
  000b6	89 85 70 ff ff
	ff		 mov	 DWORD PTR _copySize$8[ebp], eax

; 124  :         if (hs.flags & F_ERROR)

  000bc	8b 45 94	 mov	 eax, DWORD PTR _hs$9[ebp+24]
  000bf	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  000c4	74 07		 je	 SHORT $LN5@CreateTram

; 125  :             return FALSE;

  000c6	33 c0		 xor	 eax, eax
  000c8	e9 37 04 00 00	 jmp	 $LN1@CreateTram
$LN5@CreateTram:

; 126  : 
; 127  :         pCopySrc = (LPVOID)pOldInst;

  000cd	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pOldInst$6[ebp]
  000d3	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pCopySrc$7[ebp], eax

; 128  :         if (oldPos >= sizeof(JMP_REL))

  000d9	0f b6 45 c7	 movzx	 eax, BYTE PTR _oldPos$[ebp]
  000dd	83 f8 05	 cmp	 eax, 5
  000e0	72 33		 jb	 SHORT $LN6@CreateTram

; 129  :         {
; 130  :             // The trampoline function is long enough.
; 131  :             // Complete the function with the jump to the target function.
; 132  : #if defined(_M_X64) || defined(__x86_64__)
; 133  :             jmp.address = pOldInst;
; 134  : #else
; 135  :             jmp.operand = (UINT32)(pOldInst - (pNewInst + sizeof(jmp)));

  000e2	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _pNewInst$5[ebp]
  000e8	83 c0 05	 add	 eax, 5
  000eb	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _pOldInst$6[ebp]
  000f1	2b c8		 sub	 ecx, eax
  000f3	89 4d e1	 mov	 DWORD PTR _jmp$[ebp+1], ecx

; 136  : #endif
; 137  :             pCopySrc = &jmp;

  000f6	8d 45 e0	 lea	 eax, DWORD PTR _jmp$[ebp]
  000f9	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pCopySrc$7[ebp], eax

; 138  :             copySize = sizeof(jmp);

  000ff	c7 85 70 ff ff
	ff 05 00 00 00	 mov	 DWORD PTR _copySize$8[ebp], 5

; 139  : 
; 140  :             finished = TRUE;

  00109	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR _finished$[ebp], 1

; 141  :         }

  00110	e9 99 02 00 00	 jmp	 $LN7@CreateTram
$LN6@CreateTram:

; 142  : #if defined(_M_X64) || defined(__x86_64__)
; 143  :         else if ((hs.modrm & 0xC7) == 0x05)
; 144  :         {
; 145  :             // Instructions using RIP relative addressing. (ModR/M = 00???101B)
; 146  : 
; 147  :             // Modify the RIP relative address.
; 148  :             PUINT32 pRelAddr;
; 149  : 
; 150  :             // Avoid using memcpy to reduce the footprint.
; 151  : #ifndef _MSC_VER
; 152  :             memcpy(instBuf, (LPBYTE)pOldInst, copySize);
; 153  : #else
; 154  :             __movsb(instBuf, (LPBYTE)pOldInst, copySize);
; 155  : #endif
; 156  :             pCopySrc = instBuf;
; 157  : 
; 158  :             // Relative address is stored at (instruction length - immediate value length - 4).
; 159  :             pRelAddr = (PUINT32)(instBuf + hs.len - ((hs.flags & 0x3C) >> 2) - 4);
; 160  :             *pRelAddr
; 161  :                 = (UINT32)((pOldInst + hs.len + (INT32)hs.disp.disp32) - (pNewInst + hs.len));
; 162  : 
; 163  :             // Complete the function if JMP (FF /4).
; 164  :             if (hs.opcode == 0xFF && hs.modrm_reg == 4)
; 165  :                 finished = TRUE;
; 166  :         }
; 167  : #endif
; 168  :         else if (hs.opcode == 0xE8)

  00115	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00119	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  0011e	75 42		 jne	 SHORT $LN8@CreateTram

; 169  :         {
; 170  :             // Direct relative CALL
; 171  :             ULONG_PTR dest = pOldInst + hs.len + (INT32)hs.imm.imm32;

  00120	0f b6 85 7c ff
	ff ff		 movzx	 eax, BYTE PTR _hs$9[ebp]
  00127	03 85 58 ff ff
	ff		 add	 eax, DWORD PTR _pOldInst$6[ebp]
  0012d	03 45 8c	 add	 eax, DWORD PTR _hs$9[ebp+16]
  00130	89 85 40 ff ff
	ff		 mov	 DWORD PTR _dest$4[ebp], eax

; 172  : #if defined(_M_X64) || defined(__x86_64__)
; 173  :             call.address = dest;
; 174  : #else
; 175  :             call.operand = (UINT32)(dest - (pNewInst + sizeof(call)));

  00136	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _pNewInst$5[ebp]
  0013c	83 c0 05	 add	 eax, 5
  0013f	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _dest$4[ebp]
  00145	2b c8		 sub	 ecx, eax
  00147	89 4d f1	 mov	 DWORD PTR _call$[ebp+1], ecx

; 176  : #endif
; 177  :             pCopySrc = &call;

  0014a	8d 45 f0	 lea	 eax, DWORD PTR _call$[ebp]
  0014d	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pCopySrc$7[ebp], eax

; 178  :             copySize = sizeof(call);

  00153	c7 85 70 ff ff
	ff 05 00 00 00	 mov	 DWORD PTR _copySize$8[ebp], 5

; 179  :         }

  0015d	e9 4c 02 00 00	 jmp	 $LN7@CreateTram
$LN8@CreateTram:

; 180  :         else if ((hs.opcode & 0xFD) == 0xE9)

  00162	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00166	25 fd 00 00 00	 and	 eax, 253		; 000000fdH
  0016b	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  00170	0f 85 c8 00 00
	00		 jne	 $LN10@CreateTram

; 181  :         {
; 182  :             // Direct relative JMP (EB or E9)
; 183  :             ULONG_PTR dest = pOldInst + hs.len;

  00176	0f b6 85 7c ff
	ff ff		 movzx	 eax, BYTE PTR _hs$9[ebp]
  0017d	03 85 58 ff ff
	ff		 add	 eax, DWORD PTR _pOldInst$6[ebp]
  00183	89 85 34 ff ff
	ff		 mov	 DWORD PTR _dest$3[ebp], eax

; 184  : 
; 185  :             if (hs.opcode == 0xEB) // isShort jmp

  00189	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  0018d	3d eb 00 00 00	 cmp	 eax, 235		; 000000ebH
  00192	75 12		 jne	 SHORT $LN12@CreateTram

; 186  :                 dest += (INT8)hs.imm.imm8;

  00194	0f be 45 8c	 movsx	 eax, BYTE PTR _hs$9[ebp+16]
  00198	03 85 34 ff ff
	ff		 add	 eax, DWORD PTR _dest$3[ebp]
  0019e	89 85 34 ff ff
	ff		 mov	 DWORD PTR _dest$3[ebp], eax
  001a4	eb 0f		 jmp	 SHORT $LN13@CreateTram
$LN12@CreateTram:

; 187  :             else
; 188  :                 dest += (INT32)hs.imm.imm32;

  001a6	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _dest$3[ebp]
  001ac	03 45 8c	 add	 eax, DWORD PTR _hs$9[ebp+16]
  001af	89 85 34 ff ff
	ff		 mov	 DWORD PTR _dest$3[ebp], eax
$LN13@CreateTram:

; 189  : 
; 190  :             // Simply copy an internal jump.
; 191  :             if ((ULONG_PTR)ct->pTarget <= dest
; 192  :                 && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))

  001b5	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	3b 8d 34 ff ff
	ff		 cmp	 ecx, DWORD PTR _dest$3[ebp]
  001c0	77 26		 ja	 SHORT $LN14@CreateTram
  001c2	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  001c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c7	83 c1 05	 add	 ecx, 5
  001ca	39 8d 34 ff ff
	ff		 cmp	 DWORD PTR _dest$3[ebp], ecx
  001d0	73 16		 jae	 SHORT $LN14@CreateTram

; 193  :             {
; 194  :                 if (jmpDest < dest)

  001d2	8b 45 ac	 mov	 eax, DWORD PTR _jmpDest$[ebp]
  001d5	3b 85 34 ff ff
	ff		 cmp	 eax, DWORD PTR _dest$3[ebp]
  001db	73 09		 jae	 SHORT $LN16@CreateTram

; 195  :                     jmpDest = dest;

  001dd	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _dest$3[ebp]
  001e3	89 45 ac	 mov	 DWORD PTR _jmpDest$[ebp], eax
$LN16@CreateTram:

; 196  :             }

  001e6	eb 51		 jmp	 SHORT $LN15@CreateTram
$LN14@CreateTram:

; 197  :             else
; 198  :             {
; 199  : #if defined(_M_X64) || defined(__x86_64__)
; 200  :                 jmp.address = dest;
; 201  : #else
; 202  :                 jmp.operand = (UINT32)(dest - (pNewInst + sizeof(jmp)));

  001e8	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _pNewInst$5[ebp]
  001ee	83 c0 05	 add	 eax, 5
  001f1	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _dest$3[ebp]
  001f7	2b c8		 sub	 ecx, eax
  001f9	89 4d e1	 mov	 DWORD PTR _jmp$[ebp+1], ecx

; 203  : #endif
; 204  :                 pCopySrc = &jmp;

  001fc	8d 45 e0	 lea	 eax, DWORD PTR _jmp$[ebp]
  001ff	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pCopySrc$7[ebp], eax

; 205  :                 copySize = sizeof(jmp);

  00205	c7 85 70 ff ff
	ff 05 00 00 00	 mov	 DWORD PTR _copySize$8[ebp], 5

; 206  : 
; 207  :                 // Exit the function If it is not in the branch
; 208  :                 finished = (pOldInst >= jmpDest);

  0020f	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pOldInst$6[ebp]
  00215	3b 45 ac	 cmp	 eax, DWORD PTR _jmpDest$[ebp]
  00218	72 0c		 jb	 SHORT $LN37@CreateTram
  0021a	c7 85 54 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv171[ebp], 1
  00224	eb 0a		 jmp	 SHORT $LN38@CreateTram
$LN37@CreateTram:
  00226	c7 85 54 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv171[ebp], 0
$LN38@CreateTram:
  00230	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv171[ebp]
  00236	89 4d a0	 mov	 DWORD PTR _finished$[ebp], ecx
$LN15@CreateTram:

; 209  :             }
; 210  :         }

  00239	e9 70 01 00 00	 jmp	 $LN7@CreateTram
$LN10@CreateTram:

; 211  :         else if ((hs.opcode & 0xF0) == 0x70
; 212  :             || (hs.opcode & 0xFC) == 0xE0
; 213  :             || (hs.opcode2 & 0xF0) == 0x80)

  0023e	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00242	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00247	83 f8 70	 cmp	 eax, 112		; 00000070H
  0024a	74 24		 je	 SHORT $LN19@CreateTram
  0024c	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00250	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00255	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  0025a	74 14		 je	 SHORT $LN19@CreateTram
  0025c	0f b6 45 83	 movzx	 eax, BYTE PTR _hs$9[ebp+7]
  00260	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00265	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0026a	0f 85 04 01 00
	00		 jne	 $LN17@CreateTram
$LN19@CreateTram:

; 214  :         {
; 215  :             // Direct relative Jcc
; 216  :             ULONG_PTR dest = pOldInst + hs.len;

  00270	0f b6 85 7c ff
	ff ff		 movzx	 eax, BYTE PTR _hs$9[ebp]
  00277	03 85 58 ff ff
	ff		 add	 eax, DWORD PTR _pOldInst$6[ebp]
  0027d	89 85 28 ff ff
	ff		 mov	 DWORD PTR _dest$2[ebp], eax

; 217  : 
; 218  :             if ((hs.opcode & 0xF0) == 0x70      // Jcc
; 219  :                 || (hs.opcode & 0xFC) == 0xE0)  // LOOPNZ/LOOPZ/LOOP/JECXZ

  00283	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00287	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0028c	83 f8 70	 cmp	 eax, 112		; 00000070H
  0028f	74 10		 je	 SHORT $LN22@CreateTram
  00291	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00295	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  0029a	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  0029f	75 12		 jne	 SHORT $LN20@CreateTram
$LN22@CreateTram:

; 220  :                 dest += (INT8)hs.imm.imm8;

  002a1	0f be 45 8c	 movsx	 eax, BYTE PTR _hs$9[ebp+16]
  002a5	03 85 28 ff ff
	ff		 add	 eax, DWORD PTR _dest$2[ebp]
  002ab	89 85 28 ff ff
	ff		 mov	 DWORD PTR _dest$2[ebp], eax
  002b1	eb 0f		 jmp	 SHORT $LN21@CreateTram
$LN20@CreateTram:

; 221  :             else
; 222  :                 dest += (INT32)hs.imm.imm32;

  002b3	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _dest$2[ebp]
  002b9	03 45 8c	 add	 eax, DWORD PTR _hs$9[ebp+16]
  002bc	89 85 28 ff ff
	ff		 mov	 DWORD PTR _dest$2[ebp], eax
$LN21@CreateTram:

; 223  : 
; 224  :             // Simply copy an internal jump.
; 225  :             if ((ULONG_PTR)ct->pTarget <= dest
; 226  :                 && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))

  002c2	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  002c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c7	3b 8d 28 ff ff
	ff		 cmp	 ecx, DWORD PTR _dest$2[ebp]
  002cd	77 26		 ja	 SHORT $LN23@CreateTram
  002cf	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  002d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d4	83 c1 05	 add	 ecx, 5
  002d7	39 8d 28 ff ff
	ff		 cmp	 DWORD PTR _dest$2[ebp], ecx
  002dd	73 16		 jae	 SHORT $LN23@CreateTram

; 227  :             {
; 228  :                 if (jmpDest < dest)

  002df	8b 45 ac	 mov	 eax, DWORD PTR _jmpDest$[ebp]
  002e2	3b 85 28 ff ff
	ff		 cmp	 eax, DWORD PTR _dest$2[ebp]
  002e8	73 09		 jae	 SHORT $LN25@CreateTram

; 229  :                     jmpDest = dest;

  002ea	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _dest$2[ebp]
  002f0	89 45 ac	 mov	 DWORD PTR _jmpDest$[ebp], eax
$LN25@CreateTram:

; 230  :             }

  002f3	eb 7d		 jmp	 SHORT $LN24@CreateTram
$LN23@CreateTram:

; 231  :             else if ((hs.opcode & 0xFC) == 0xE0)

  002f5	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  002f9	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  002fe	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  00303	75 09		 jne	 SHORT $LN26@CreateTram

; 232  :             {
; 233  :                 // LOOPNZ/LOOPZ/LOOP/JCXZ/JECXZ to the outside are not supported.
; 234  :                 return FALSE;

  00305	33 c0		 xor	 eax, eax
  00307	e9 f8 01 00 00	 jmp	 $LN1@CreateTram

; 235  :             }

  0030c	eb 64		 jmp	 SHORT $LN24@CreateTram
$LN26@CreateTram:

; 236  :             else
; 237  :             {
; 238  :                 UINT8 cond = ((hs.opcode != 0x0F ? hs.opcode : hs.opcode2) & 0x0F);

  0030e	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00312	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00315	74 0c		 je	 SHORT $LN39@CreateTram
  00317	0f b6 4d 82	 movzx	 ecx, BYTE PTR _hs$9[ebp+6]
  0031b	89 8d 54 fe ff
	ff		 mov	 DWORD PTR tv205[ebp], ecx
  00321	eb 0a		 jmp	 SHORT $LN40@CreateTram
$LN39@CreateTram:
  00323	0f b6 55 83	 movzx	 edx, BYTE PTR _hs$9[ebp+7]
  00327	89 95 54 fe ff
	ff		 mov	 DWORD PTR tv205[ebp], edx
$LN40@CreateTram:
  0032d	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv205[ebp]
  00333	83 e0 0f	 and	 eax, 15			; 0000000fH
  00336	88 85 1f ff ff
	ff		 mov	 BYTE PTR _cond$1[ebp], al

; 239  : #if defined(_M_X64) || defined(__x86_64__)
; 240  :                 // Invert the condition in x64 mode to simplify the conditional jump logic.
; 241  :                 jcc.opcode  = 0x71 ^ cond;
; 242  :                 jcc.address = dest;
; 243  : #else
; 244  :                 jcc.opcode1 = 0x80 | cond;

  0033c	0f b6 85 1f ff
	ff ff		 movzx	 eax, BYTE PTR _cond$1[ebp]
  00343	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00348	88 45 d1	 mov	 BYTE PTR _jcc$[ebp+1], al

; 245  :                 jcc.operand = (UINT32)(dest - (pNewInst + sizeof(jcc)));

  0034b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _pNewInst$5[ebp]
  00351	83 c0 06	 add	 eax, 6
  00354	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _dest$2[ebp]
  0035a	2b c8		 sub	 ecx, eax
  0035c	89 4d d2	 mov	 DWORD PTR _jcc$[ebp+2], ecx

; 246  : #endif
; 247  :                 pCopySrc = &jcc;

  0035f	8d 45 d0	 lea	 eax, DWORD PTR _jcc$[ebp]
  00362	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pCopySrc$7[ebp], eax

; 248  :                 copySize = sizeof(jcc);

  00368	c7 85 70 ff ff
	ff 06 00 00 00	 mov	 DWORD PTR _copySize$8[ebp], 6
$LN24@CreateTram:

; 249  :             }
; 250  :         }

  00372	eb 3a		 jmp	 SHORT $LN7@CreateTram
$LN17@CreateTram:

; 251  :         else if ((hs.opcode & 0xFE) == 0xC2)

  00374	0f b6 45 82	 movzx	 eax, BYTE PTR _hs$9[ebp+6]
  00378	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  0037d	3d c2 00 00 00	 cmp	 eax, 194		; 000000c2H
  00382	75 2a		 jne	 SHORT $LN7@CreateTram

; 252  :         {
; 253  :             // RET (C2 or C3)
; 254  : 
; 255  :             // Complete the function if not in a branch.
; 256  :             finished = (pOldInst >= jmpDest);

  00384	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pOldInst$6[ebp]
  0038a	3b 45 ac	 cmp	 eax, DWORD PTR _jmpDest$[ebp]
  0038d	72 0c		 jb	 SHORT $LN41@CreateTram
  0038f	c7 85 54 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv217[ebp], 1
  00399	eb 0a		 jmp	 SHORT $LN42@CreateTram
$LN41@CreateTram:
  0039b	c7 85 54 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv217[ebp], 0
$LN42@CreateTram:
  003a5	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv217[ebp]
  003ab	89 4d a0	 mov	 DWORD PTR _finished$[ebp], ecx
$LN7@CreateTram:

; 257  :         }
; 258  : 
; 259  :         // Can't alter the instruction length in a branch.
; 260  :         if (pOldInst < jmpDest && copySize != hs.len)

  003ae	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pOldInst$6[ebp]
  003b4	3b 45 ac	 cmp	 eax, DWORD PTR _jmpDest$[ebp]
  003b7	73 16		 jae	 SHORT $LN29@CreateTram
  003b9	0f b6 85 7c ff
	ff ff		 movzx	 eax, BYTE PTR _hs$9[ebp]
  003c0	39 85 70 ff ff
	ff		 cmp	 DWORD PTR _copySize$8[ebp], eax
  003c6	74 07		 je	 SHORT $LN29@CreateTram

; 261  :             return FALSE;

  003c8	33 c0		 xor	 eax, eax
  003ca	e9 35 01 00 00	 jmp	 $LN1@CreateTram
$LN29@CreateTram:

; 262  : 
; 263  :         // Trampoline function is too large.
; 264  :         if ((newPos + copySize) > TRAMPOLINE_MAX_SIZE)

  003cf	0f b6 45 bb	 movzx	 eax, BYTE PTR _newPos$[ebp]
  003d3	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _copySize$8[ebp]
  003d9	83 f8 20	 cmp	 eax, 32			; 00000020H
  003dc	76 07		 jbe	 SHORT $LN30@CreateTram

; 265  :             return FALSE;

  003de	33 c0		 xor	 eax, eax
  003e0	e9 1f 01 00 00	 jmp	 $LN1@CreateTram
$LN30@CreateTram:

; 266  : 
; 267  :         // Trampoline function has too many instructions.
; 268  :         if (ct->nIP >= ARRAYSIZE(ct->oldIPs))

  003e5	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  003e8	83 78 10 08	 cmp	 DWORD PTR [eax+16], 8
  003ec	72 07		 jb	 SHORT $LN31@CreateTram

; 269  :             return FALSE;

  003ee	33 c0		 xor	 eax, eax
  003f0	e9 0f 01 00 00	 jmp	 $LN1@CreateTram
$LN31@CreateTram:

; 270  : 
; 271  :         ct->oldIPs[ct->nIP] = oldPos;

  003f5	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  003f8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003fb	8b 55 08	 mov	 edx, DWORD PTR _ct$[ebp]
  003fe	8a 45 c7	 mov	 al, BYTE PTR _oldPos$[ebp]
  00401	88 44 0a 14	 mov	 BYTE PTR [edx+ecx+20], al

; 272  :         ct->newIPs[ct->nIP] = newPos;

  00405	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  00408	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0040b	8b 55 08	 mov	 edx, DWORD PTR _ct$[ebp]
  0040e	8a 45 bb	 mov	 al, BYTE PTR _newPos$[ebp]
  00411	88 44 0a 1c	 mov	 BYTE PTR [edx+ecx+28], al

; 273  :         ct->nIP++;

  00415	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  00418	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0041b	83 c1 01	 add	 ecx, 1
  0041e	8b 55 08	 mov	 edx, DWORD PTR _ct$[ebp]
  00421	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 274  : 
; 275  :         // Avoid using memcpy to reduce the footprint.
; 276  : #ifndef _MSC_VER
; 277  :         memcpy((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
; 278  : #else
; 279  :         __movsb((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);

  00424	0f b6 7d bb	 movzx	 edi, BYTE PTR _newPos$[ebp]
  00428	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  0042b	03 78 08	 add	 edi, DWORD PTR [eax+8]
  0042e	8b b5 64 ff ff
	ff		 mov	 esi, DWORD PTR _pCopySrc$7[ebp]
  00434	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _copySize$8[ebp]
  0043a	f3 a4		 rep movsb

; 280  : #endif
; 281  :         newPos += copySize;

  0043c	0f b6 45 bb	 movzx	 eax, BYTE PTR _newPos$[ebp]
  00440	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _copySize$8[ebp]
  00446	88 45 bb	 mov	 BYTE PTR _newPos$[ebp], al

; 282  :         oldPos += hs.len;

  00449	0f b6 85 7c ff
	ff ff		 movzx	 eax, BYTE PTR _hs$9[ebp]
  00450	0f b6 4d c7	 movzx	 ecx, BYTE PTR _oldPos$[ebp]
  00454	03 c8		 add	 ecx, eax
  00456	88 4d c7	 mov	 BYTE PTR _oldPos$[ebp], cl

; 283  :     }
; 284  :     while (!finished);

  00459	83 7d a0 00	 cmp	 DWORD PTR _finished$[ebp], 0
  0045d	0f 84 1e fc ff
	ff		 je	 $LN4@CreateTram

; 285  : 
; 286  :     // Is there enough place for a long jump?
; 287  :     if (oldPos < sizeof(JMP_REL)
; 288  :         && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL) - oldPos))

  00463	0f b6 45 c7	 movzx	 eax, BYTE PTR _oldPos$[ebp]
  00467	83 f8 05	 cmp	 eax, 5
  0046a	0f 83 8f 00 00
	00		 jae	 $LN32@CreateTram
  00470	0f b6 45 c7	 movzx	 eax, BYTE PTR _oldPos$[ebp]
  00474	b9 05 00 00 00	 mov	 ecx, 5
  00479	2b c8		 sub	 ecx, eax
  0047b	51		 push	 ecx
  0047c	0f b6 55 c7	 movzx	 edx, BYTE PTR _oldPos$[ebp]
  00480	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  00483	03 10		 add	 edx, DWORD PTR [eax]
  00485	52		 push	 edx
  00486	e8 00 00 00 00	 call	 _IsCodePadding
  0048b	83 c4 08	 add	 esp, 8
  0048e	85 c0		 test	 eax, eax
  00490	75 6d		 jne	 SHORT $LN32@CreateTram

; 289  :     {
; 290  :         // Is there enough place for a short jump?
; 291  :         if (oldPos < sizeof(JMP_REL_SHORT)
; 292  :             && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL_SHORT) - oldPos))

  00492	0f b6 45 c7	 movzx	 eax, BYTE PTR _oldPos$[ebp]
  00496	83 f8 02	 cmp	 eax, 2
  00499	73 26		 jae	 SHORT $LN33@CreateTram
  0049b	0f b6 45 c7	 movzx	 eax, BYTE PTR _oldPos$[ebp]
  0049f	b9 02 00 00 00	 mov	 ecx, 2
  004a4	2b c8		 sub	 ecx, eax
  004a6	51		 push	 ecx
  004a7	0f b6 55 c7	 movzx	 edx, BYTE PTR _oldPos$[ebp]
  004ab	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  004ae	03 10		 add	 edx, DWORD PTR [eax]
  004b0	52		 push	 edx
  004b1	e8 00 00 00 00	 call	 _IsCodePadding
  004b6	83 c4 08	 add	 esp, 8
  004b9	85 c0		 test	 eax, eax
  004bb	75 04		 jne	 SHORT $LN33@CreateTram

; 293  :         {
; 294  :             return FALSE;

  004bd	33 c0		 xor	 eax, eax
  004bf	eb 43		 jmp	 SHORT $LN1@CreateTram
$LN33@CreateTram:

; 295  :         }
; 296  : 
; 297  :         // Can we place the long jump above the function?
; 298  :         if (!IsExecutableAddress((LPBYTE)ct->pTarget - sizeof(JMP_REL)))

  004c1	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  004c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  004c6	83 e9 05	 sub	 ecx, 5
  004c9	51		 push	 ecx
  004ca	e8 00 00 00 00	 call	 _IsExecutableAddress
  004cf	83 c4 04	 add	 esp, 4
  004d2	85 c0		 test	 eax, eax
  004d4	75 04		 jne	 SHORT $LN34@CreateTram

; 299  :             return FALSE;

  004d6	33 c0		 xor	 eax, eax
  004d8	eb 2a		 jmp	 SHORT $LN1@CreateTram
$LN34@CreateTram:

; 300  : 
; 301  :         if (!IsCodePadding((LPBYTE)ct->pTarget - sizeof(JMP_REL), sizeof(JMP_REL)))

  004da	6a 05		 push	 5
  004dc	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  004df	8b 08		 mov	 ecx, DWORD PTR [eax]
  004e1	83 e9 05	 sub	 ecx, 5
  004e4	51		 push	 ecx
  004e5	e8 00 00 00 00	 call	 _IsCodePadding
  004ea	83 c4 08	 add	 esp, 8
  004ed	85 c0		 test	 eax, eax
  004ef	75 04		 jne	 SHORT $LN35@CreateTram

; 302  :             return FALSE;

  004f1	33 c0		 xor	 eax, eax
  004f3	eb 0f		 jmp	 SHORT $LN1@CreateTram
$LN35@CreateTram:

; 303  : 
; 304  :         ct->patchAbove = TRUE;

  004f5	8b 45 08	 mov	 eax, DWORD PTR _ct$[ebp]
  004f8	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1
$LN32@CreateTram:

; 305  :     }
; 306  : 
; 307  : #if defined(_M_X64) || defined(__x86_64__)
; 308  :     // Create a relay function.
; 309  :     jmp.address = (ULONG_PTR)ct->pDetour;
; 310  : 
; 311  :     ct->pRelay = (LPBYTE)ct->pTrampoline + newPos;
; 312  :     memcpy(ct->pRelay, &jmp, sizeof(jmp));
; 313  : #endif
; 314  : 
; 315  :     return TRUE;

  004ff	b8 01 00 00 00	 mov	 eax, 1
$LN1@CreateTram:

; 316  : }

  00504	52		 push	 edx
  00505	8b cd		 mov	 ecx, ebp
  00507	50		 push	 eax
  00508	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN48@CreateTram
  0050e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00513	58		 pop	 eax
  00514	5a		 pop	 edx
  00515	5f		 pop	 edi
  00516	5e		 pop	 esi
  00517	5b		 pop	 ebx
  00518	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0051b	33 cd		 xor	 ecx, ebp
  0051d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00522	81 c4 ac 01 00
	00		 add	 esp, 428		; 000001acH
  00528	3b ec		 cmp	 ebp, esp
  0052a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0052f	8b e5		 mov	 esp, ebp
  00531	5d		 pop	 ebp
  00532	c3		 ret	 0
  00533	90		 npad	 1
$LN48@CreateTram:
  00534	04 00 00 00	 DD	 4
  00538	00 00 00 00	 DD	 $LN47@CreateTram
$LN47@CreateTram:
  0053c	f0 ff ff ff	 DD	 -16			; fffffff0H
  00540	05 00 00 00	 DD	 5
  00544	00 00 00 00	 DD	 $LN43@CreateTram
  00548	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0054c	05 00 00 00	 DD	 5
  00550	00 00 00 00	 DD	 $LN44@CreateTram
  00554	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00558	06 00 00 00	 DD	 6
  0055c	00 00 00 00	 DD	 $LN45@CreateTram
  00560	7c ff ff ff	 DD	 -132			; ffffff7cH
  00564	1c 00 00 00	 DD	 28			; 0000001cH
  00568	00 00 00 00	 DD	 $LN46@CreateTram
$LN46@CreateTram:
  0056c	68		 DB	 104			; 00000068H
  0056d	73		 DB	 115			; 00000073H
  0056e	00		 DB	 0
$LN45@CreateTram:
  0056f	6a		 DB	 106			; 0000006aH
  00570	63		 DB	 99			; 00000063H
  00571	63		 DB	 99			; 00000063H
  00572	00		 DB	 0
$LN44@CreateTram:
  00573	6a		 DB	 106			; 0000006aH
  00574	6d		 DB	 109			; 0000006dH
  00575	70		 DB	 112			; 00000070H
  00576	00		 DB	 0
$LN43@CreateTram:
  00577	63		 DB	 99			; 00000063H
  00578	61		 DB	 97			; 00000061H
  00579	6c		 DB	 108			; 0000006cH
  0057a	6c		 DB	 108			; 0000006cH
  0057b	00		 DB	 0
_CreateTrampolineFunction ENDP
_TEXT	ENDS
END
