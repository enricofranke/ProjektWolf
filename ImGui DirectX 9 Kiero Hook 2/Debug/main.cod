; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?oEndScene@@3P6GJPAUIDirect3DDevice9@@@ZA	; oEndScene
PUBLIC	?oWndProc@@3P6GJPAUHWND__@@IIJ@ZA		; oWndProc
PUBLIC	?gameModule@@3IA				; gameModule
PUBLIC	?engineModule@@3IA				; engineModule
PUBLIC	?init@@3_NA					; init
PUBLIC	?show@@3_NA					; show
_BSS	SEGMENT
?oEndScene@@3P6GJPAUIDirect3DDevice9@@@ZA DD 01H DUP (?) ; oEndScene
?oWndProc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?)	; oWndProc
?gameModule@@3IA DD 01H DUP (?)				; gameModule
?engineModule@@3IA DD 01H DUP (?)			; engineModule
?init@@3_NA DB	01H DUP (?)				; init
	ALIGN	4

?show@@3_NA DB	01H DUP (?)				; show
_BSS	ENDS
msvcjmc	SEGMENT
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__241EEA0C_corecrt_memory@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__692346AF_guiddef@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__2908CC08_winuser@h DB 01H
__E6E7469F_winioctl@h DB 01H
__F5601360_stdlib@h DB 01H
__1E567087_propidl@h DB 01H
__9FABC30B_oleauto@h DB 01H
__08182E14_stralign@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__9DC49520_d3dx9math@inl DB 01H
__F9479C27_d3dx9math@h DB 01H
__51CE8FB9_d3dx9core@h DB 01H
__1131B8F5_vcruntime_new@h DB 01H
__42049807_imgui@h DB 01H
__17470045_entity@h DB 01H
__E27C6F99_cstdlib DB 01H
__4F04423B_type_traits DB 01H
__BDD787A0_main@cpp DB 01H
msvcjmc	ENDS
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	?GetDormant@Entity@@QAE_NXZ			; Entity::GetDormant
PUBLIC	?InitImGui@@YAXPAUIDirect3DDevice9@@@Z		; InitImGui
PUBLIC	?hkEndScene@@YGJPAUIDirect3DDevice9@@@Z		; hkEndScene
PUBLIC	??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z		; RPM<unsigned int,std::enable_if<1,void> >
PUBLIC	??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z	; WPM<int,std::enable_if<1,void> >
PUBLIC	?WndProc@@YGJQAUHWND__@@IIJ@Z			; WndProc
PUBLIC	?EnumWindowsCallback@@YGHPAUHWND__@@J@Z		; EnumWindowsCallback
PUBLIC	?GetProcessWindow@@YAPAUHWND__@@XZ		; GetProcessWindow
PUBLIC	?MainThread@@YGKPAX@Z				; MainThread
PUBLIC	_DllMain@12
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0L@PHFEFMEF@client?4dll@			; `string'
PUBLIC	??_C@_0L@EMPDFJNI@engine?4dll@			; `string'
PUBLIC	??_C@_0N@CLHLOEMD@Projekt?5Wolf@		; `string'
PUBLIC	??_C@_06FHEBLMEF@Aimbot@			; `string'
PUBLIC	??_C@_07GNHLELCG@Visuals@			; `string'
PUBLIC	??_C@_04OFFCAMCD@Test@				; `string'
PUBLIC	??_C@_05GENPCEMM@Test1@				; `string'
PUBLIC	??_C@_08HCFMKIA@WallHack@			; `string'
PUBLIC	??_C@_0BG@OOKKINEM@TODO?5ADD?5KEYBIND?5TOOL@	; `string'
PUBLIC	??_C@_0BH@PMENLFFB@TODO?5ADD?5COLOR?5CHANGER@	; `string'
PUBLIC	??_C@_05FGOJEGEO@Test3@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0N@CNFDMBCC@FOV?5Settings@		; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@3fd9999a
PUBLIC	__real@40000000
PUBLIC	__real@42c80000
PUBLIC	__real@43480000
PUBLIC	__real@44228000
PUBLIC	__real@bf800000
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__DisableThreadLibraryCalls@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__CallWindowProcA@20:PROC
EXTRN	__imp__GetAsyncKeyState@4:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__EnumWindows@8:PROC
EXTRN	__imp__GetWindowThreadProcessId@8:PROC
EXTRN	?init@kiero@@YA?AW4Enum@Status@1@W42RenderType@1@@Z:PROC ; kiero::init
EXTRN	?shutdown@kiero@@YAXXZ:PROC			; kiero::shutdown
EXTRN	?bind@kiero@@YA?AW4Enum@Status@1@GPAPAXPAX@Z:PROC ; kiero::bind
EXTRN	?CreateContext@ImGui@@YAPAUImGuiContext@@PAUImFontAtlas@@@Z:PROC ; ImGui::CreateContext
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?NewFrame@ImGui@@YAXXZ:PROC			; ImGui::NewFrame
EXTRN	?EndFrame@ImGui@@YAXXZ:PROC			; ImGui::EndFrame
EXTRN	?Render@ImGui@@YAXXZ:PROC			; ImGui::Render
EXTRN	?GetDrawData@ImGui@@YAPAUImDrawData@@XZ:PROC	; ImGui::GetDrawData
EXTRN	?Begin@ImGui@@YA_NPBDPA_NH@Z:PROC		; ImGui::Begin
EXTRN	?End@ImGui@@YAXXZ:PROC				; ImGui::End
EXTRN	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H0@Z:PROC ; ImGui::SetNextWindowPos
EXTRN	?SameLine@ImGui@@YAXMM@Z:PROC			; ImGui::SameLine
EXTRN	?BeginGroup@ImGui@@YAXXZ:PROC			; ImGui::BeginGroup
EXTRN	?EndGroup@ImGui@@YAXXZ:PROC			; ImGui::EndGroup
EXTRN	?Text@ImGui@@YAXPBDZZ:PROC			; ImGui::Text
EXTRN	?Button@ImGui@@YA_NPBDABUImVec2@@@Z:PROC	; ImGui::Button
EXTRN	?Checkbox@ImGui@@YA_NPBDPA_N@Z:PROC		; ImGui::Checkbox
EXTRN	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z:PROC		; ImGui::SliderInt
EXTRN	?ImGui_ImplWin32_Init@@YA_NPAX@Z:PROC		; ImGui_ImplWin32_Init
EXTRN	?ImGui_ImplWin32_NewFrame@@YAXXZ:PROC		; ImGui_ImplWin32_NewFrame
EXTRN	?ImGui_ImplDX9_Init@@YA_NPAUIDirect3DDevice9@@@Z:PROC ; ImGui_ImplDX9_Init
EXTRN	?ImGui_ImplDX9_NewFrame@@YAXXZ:PROC		; ImGui_ImplDX9_NewFrame
EXTRN	?ImGui_ImplDX9_RenderDrawData@@YAXPAUImDrawData@@@Z:PROC ; ImGui_ImplDX9_RenderDrawData
EXTRN	?loadStyle@@YAXXZ:PROC				; loadStyle
EXTRN	?ImGui_ImplWin32_WndProcHandler@@YAJPAUHWND__@@IIJ@Z:PROC ; ImGui_ImplWin32_WndProcHandler
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
	ALIGN	4

?window@@3PAUHWND__@@A DD 01H DUP (?)			; window
?WallsOn@@3_NA DB 01H DUP (?)				; WallsOn
_BSS	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@44228000
CONST	SEGMENT
__real@44228000 DD 044228000r			; 650
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fd9999a
CONST	SEGMENT
__real@3fd9999a DD 03fd9999ar			; 1.7
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0N@CNFDMBCC@FOV?5Settings@
CONST	SEGMENT
??_C@_0N@CNFDMBCC@FOV?5Settings@ DB 'FOV Settings', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FGOJEGEO@Test3@
CONST	SEGMENT
??_C@_05FGOJEGEO@Test3@ DB 'Test3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PMENLFFB@TODO?5ADD?5COLOR?5CHANGER@
CONST	SEGMENT
??_C@_0BH@PMENLFFB@TODO?5ADD?5COLOR?5CHANGER@ DB 'TODO ADD COLOR CHANGER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OOKKINEM@TODO?5ADD?5KEYBIND?5TOOL@
CONST	SEGMENT
??_C@_0BG@OOKKINEM@TODO?5ADD?5KEYBIND?5TOOL@ DB 'TODO ADD KEYBIND TOOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HCFMKIA@WallHack@
CONST	SEGMENT
??_C@_08HCFMKIA@WallHack@ DB 'WallHack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GENPCEMM@Test1@
CONST	SEGMENT
??_C@_05GENPCEMM@Test1@ DB 'Test1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFFCAMCD@Test@
CONST	SEGMENT
??_C@_04OFFCAMCD@Test@ DB 'Test', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GNHLELCG@Visuals@
CONST	SEGMENT
??_C@_07GNHLELCG@Visuals@ DB 'Visuals', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHEBLMEF@Aimbot@
CONST	SEGMENT
??_C@_06FHEBLMEF@Aimbot@ DB 'Aimbot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLHLOEMD@Projekt?5Wolf@
CONST	SEGMENT
??_C@_0N@CLHLOEMD@Projekt?5Wolf@ DB 'Projekt Wolf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMPDFJNI@engine?4dll@
CONST	SEGMENT
??_C@_0L@EMPDFJNI@engine?4dll@ DB 'engine.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHFEFMEF@client?4dll@
CONST	SEGMENT
??_C@_0L@PHFEFMEF@client?4dll@ DB 'client.dll', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?switchTabs@@3HA DD 03H					; switchTabs
?fov@@3HA DD	05aH					; fov
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
tv64 = -196						; size = 4
_hMod$ = 8						; size = 4
_dwReason$ = 12						; size = 4
_lpReserved$ = 16					; size = 4
_DllMain@12 PROC					; COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 234  : 	switch (dwReason)

  00028	8b 45 0c	 mov	 eax, DWORD PTR _dwReason$[ebp]
  0002b	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00031	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv64[ebp], 0
  00038	74 40		 je	 SHORT $LN5@DllMain
  0003a	83 bd 3c ff ff
	ff 01		 cmp	 DWORD PTR tv64[ebp], 1
  00041	74 02		 je	 SHORT $LN4@DllMain
  00043	eb 3a		 jmp	 SHORT $LN2@DllMain
$LN4@DllMain:

; 235  : 	{
; 236  : 	case DLL_PROCESS_ATTACH:
; 237  : 		DisableThreadLibraryCalls(hMod);

  00045	8b f4		 mov	 esi, esp
  00047	8b 45 08	 mov	 eax, DWORD PTR _hMod$[ebp]
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DisableThreadLibraryCalls@4
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 238  : 		CreateThread(nullptr, 0, MainThread, hMod, 0, nullptr);

  00058	8b f4		 mov	 esi, esp
  0005a	6a 00		 push	 0
  0005c	6a 00		 push	 0
  0005e	8b 45 08	 mov	 eax, DWORD PTR _hMod$[ebp]
  00061	50		 push	 eax
  00062	68 00 00 00 00	 push	 OFFSET ?MainThread@@YGKPAX@Z ; MainThread
  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 239  : 		break;

  00078	eb 05		 jmp	 SHORT $LN2@DllMain
$LN5@DllMain:

; 240  : 	case DLL_PROCESS_DETACH:
; 241  : 		kiero::shutdown();

  0007a	e8 00 00 00 00	 call	 ?shutdown@kiero@@YAXXZ	; kiero::shutdown
$LN2@DllMain:

; 242  : 		break;
; 243  : 	}
; 244  : 	return TRUE;

  0007f	b8 01 00 00 00	 mov	 eax, 1

; 245  : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ?MainThread@@YGKPAX@Z
_TEXT	SEGMENT
_attached$ = -5						; size = 1
_lpReserved$ = 8					; size = 4
?MainThread@@YGKPAX@Z PROC				; MainThread, COMDAT

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 216  : 	bool attached = false;

  00028	c6 45 fb 00	 mov	 BYTE PTR _attached$[ebp], 0
$LN4@MainThread:

; 217  : 	do
; 218  : 	{
; 219  : 		if (kiero::init(kiero::RenderType::D3D9) == kiero::Status::Success)

  0002c	6a 01		 push	 1
  0002e	e8 00 00 00 00	 call	 ?init@kiero@@YA?AW4Enum@Status@1@W42RenderType@1@@Z ; kiero::init
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	75 4c		 jne	 SHORT $LN2@MainThread

; 220  : 		{
; 221  : 			kiero::bind(42, reinterpret_cast<void**>(&oEndScene), hkEndScene);

  0003a	68 00 00 00 00	 push	 OFFSET ?hkEndScene@@YGJPAUIDirect3DDevice9@@@Z ; hkEndScene
  0003f	68 00 00 00 00	 push	 OFFSET ?oEndScene@@3P6GJPAUIDirect3DDevice9@@@ZA ; oEndScene
  00044	6a 2a		 push	 42			; 0000002aH
  00046	e8 00 00 00 00	 call	 ?bind@kiero@@YA?AW4Enum@Status@1@GPAPAXPAX@Z ; kiero::bind
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@MainThread:

; 222  : 			do
; 223  : 				window = GetProcessWindow();

  0004e	e8 00 00 00 00	 call	 ?GetProcessWindow@@YAPAUHWND__@@XZ ; GetProcessWindow
  00053	a3 00 00 00 00	 mov	 DWORD PTR ?window@@3PAUHWND__@@A, eax

; 224  : 			while (window == NULL);

  00058	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?window@@3PAUHWND__@@A, 0
  0005f	74 ed		 je	 SHORT $LN7@MainThread

; 225  : 			oWndProc = (WNDPROC)SetWindowLongPtr(window, GWL_WNDPROC, (LONG_PTR)WndProc);

  00061	8b f4		 mov	 esi, esp
  00063	68 00 00 00 00	 push	 OFFSET ?WndProc@@YGJQAUHWND__@@IIJ@Z ; WndProc
  00068	6a fc		 push	 -4			; fffffffcH
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?window@@3PAUHWND__@@A
  0006f	50		 push	 eax
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	a3 00 00 00 00	 mov	 DWORD PTR ?oWndProc@@3P6GJPAUHWND__@@IIJ@ZA, eax ; oWndProc

; 226  : 			attached = true;

  00082	c6 45 fb 01	 mov	 BYTE PTR _attached$[ebp], 1
$LN2@MainThread:

; 227  : 		}
; 228  : 	} while (!attached);

  00086	0f b6 45 fb	 movzx	 eax, BYTE PTR _attached$[ebp]
  0008a	85 c0		 test	 eax, eax
  0008c	74 9e		 je	 SHORT $LN4@MainThread

; 229  : 	return TRUE;

  0008e	b8 01 00 00 00	 mov	 eax, 1

; 230  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
?MainThread@@YGKPAX@Z ENDP				; MainThread
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ?GetProcessWindow@@YAPAUHWND__@@XZ
_TEXT	SEGMENT
?GetProcessWindow@@YAPAUHWND__@@XZ PROC			; GetProcessWindow, COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 209  : 	window = NULL;

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?window@@3PAUHWND__@@A, 0

; 210  : 	EnumWindows(EnumWindowsCallback, NULL);

  00032	8b f4		 mov	 esi, esp
  00034	6a 00		 push	 0
  00036	68 00 00 00 00	 push	 OFFSET ?EnumWindowsCallback@@YGHPAUHWND__@@J@Z ; EnumWindowsCallback
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnumWindows@8
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 211  : 	return window;

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?window@@3PAUHWND__@@A

; 212  : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GetProcessWindow@@YAPAUHWND__@@XZ ENDP			; GetProcessWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ?EnumWindowsCallback@@YGHPAUHWND__@@J@Z
_TEXT	SEGMENT
_wndProcId$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_handle$ = 8						; size = 4
_lParam$ = 12						; size = 4
?EnumWindowsCallback@@YGHPAUHWND__@@J@Z PROC		; EnumWindowsCallback, COMDAT

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 197  : 	DWORD wndProcId;
; 198  : 	GetWindowThreadProcessId(handle, &wndProcId);

  00032	8b f4		 mov	 esi, esp
  00034	8d 45 f4	 lea	 eax, DWORD PTR _wndProcId$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _handle$[ebp]
  0003b	51		 push	 ecx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowThreadProcessId@8
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 199  : 
; 200  : 	if (GetCurrentProcessId() != wndProcId)

  00049	8b f4		 mov	 esi, esp
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	3b 45 f4	 cmp	 eax, DWORD PTR _wndProcId$[ebp]
  0005b	74 07		 je	 SHORT $LN2@EnumWindow

; 201  : 		return TRUE; // skip to next window

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	eb 0a		 jmp	 SHORT $LN1@EnumWindow
$LN2@EnumWindow:

; 202  : 
; 203  : 	window = handle;

  00064	8b 45 08	 mov	 eax, DWORD PTR _handle$[ebp]
  00067	a3 00 00 00 00	 mov	 DWORD PTR ?window@@3PAUHWND__@@A, eax

; 204  : 	return FALSE; // window found abort search

  0006c	33 c0		 xor	 eax, eax
$LN1@EnumWindow:

; 205  : }

  0006e	52		 push	 edx
  0006f	8b cd		 mov	 ecx, ebp
  00071	50		 push	 eax
  00072	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@EnumWindow
  00078	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007d	58		 pop	 eax
  0007e	5a		 pop	 edx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 08 00	 ret	 8
  0009f	90		 npad	 1
$LN6@EnumWindow:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN5@EnumWindow
$LN5@EnumWindow:
  000a8	f4 ff ff ff	 DD	 -12			; fffffff4H
  000ac	04 00 00 00	 DD	 4
  000b0	00 00 00 00	 DD	 $LN4@EnumWindow
$LN4@EnumWindow:
  000b4	77		 DB	 119			; 00000077H
  000b5	6e		 DB	 110			; 0000006eH
  000b6	64		 DB	 100			; 00000064H
  000b7	50		 DB	 80			; 00000050H
  000b8	72		 DB	 114			; 00000072H
  000b9	6f		 DB	 111			; 0000006fH
  000ba	63		 DB	 99			; 00000063H
  000bb	49		 DB	 73			; 00000049H
  000bc	64		 DB	 100			; 00000064H
  000bd	00		 DB	 0
?EnumWindowsCallback@@YGHPAUHWND__@@J@Z ENDP		; EnumWindowsCallback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ?WndProc@@YGJQAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProc@@YGJQAUHWND__@@IIJ@Z PROC			; WndProc, COMDAT

; 189  : LRESULT __stdcall WndProc(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 190  : 	if (ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam))

  00028	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _uMsg$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?ImGui_ImplWin32_WndProcHandler@@YAJPAUHWND__@@IIJ@Z ; ImGui_ImplWin32_WndProcHandler
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
  00040	85 c0		 test	 eax, eax
  00042	74 07		 je	 SHORT $LN2@WndProc

; 191  : 		return true;

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	eb 26		 jmp	 SHORT $LN1@WndProc
$LN2@WndProc:

; 192  : 	return CallWindowProc(oWndProc, hWnd, uMsg, wParam, lParam);

  0004b	8b f4		 mov	 esi, esp
  0004d	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 0c	 mov	 edx, DWORD PTR _uMsg$[ebp]
  00058	52		 push	 edx
  00059	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0005c	50		 push	 eax
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?oWndProc@@3P6GJPAUHWND__@@IIJ@ZA ; oWndProc
  00063	51		 push	 ecx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@WndProc:

; 193  : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 10 00	 ret	 16			; 00000010H
?WndProc@@YGJQAUHWND__@@IIJ@Z ENDP			; WndProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_adress$ = 8						; size = 4
_value$ = 12						; size = 4
??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z PROC		; WPM<int,std::enable_if<1,void> >, COMDAT

; 15   : void WPM(const uintptr_t adress, const T value) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00020	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 16   : 	*reinterpret_cast<T*>(adress) = value;

  00047	8b 45 08	 mov	 eax, DWORD PTR _adress$[ebp]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0004d	89 08		 mov	 DWORD PTR [eax], ecx

; 17   : }

  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
  0006e	cc		 int	 3
  0006f	cc		 int	 3
  00070	cc		 int	 3
  00071	cc		 int	 3
  00072	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z ENDP		; WPM<int,std::enable_if<1,void> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ??0<lambda_af406ef13d2254f32c3176914df7d750>@@QAE@ABIABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<GlowObjectManager>$ = 8				; size = 4
_<glowIndex>$ = 12					; size = 4
??0<lambda_af406ef13d2254f32c3176914df7d750>@@QAE@ABIABH@Z PROC ; <lambda_af406ef13d2254f32c3176914df7d750>::<lambda_af406ef13d2254f32c3176914df7d750>, COMDAT
; _this$ = ecx

; 111  : 				};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _<GlowObjectManager>$[ebp]
  00033	89 08		 mov	 DWORD PTR [eax], ecx
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _<glowIndex>$[ebp]
  0003b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
??0<lambda_af406ef13d2254f32c3176914df7d750>@@QAE@ABIABH@Z ENDP ; <lambda_af406ef13d2254f32c3176914df7d750>::<lambda_af406ef13d2254f32c3176914df7d750>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z PROC ; <lambda_af406ef13d2254f32c3176914df7d750>::operator(), COMDAT
; _this$ = ecx

; 106  : 				auto applyColor = [&](const float r, const float g, const float b) noexcept -> void {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 107  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0x4)) = r;

  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00054	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00057	6b 10 38	 imul	 edx, DWORD PTR [eax], 56
  0005a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _r$[ebp]
  00061	f3 0f 11 44 02
	04		 movss	 DWORD PTR [edx+eax+4], xmm0

; 108  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0x8)) = g;

  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00072	6b 10 38	 imul	 edx, DWORD PTR [eax], 56
  00075	8b 01		 mov	 eax, DWORD PTR [ecx]
  00077	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _g$[ebp]
  0007c	f3 0f 11 44 02
	08		 movss	 DWORD PTR [edx+eax+8], xmm0

; 109  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0xC)) = b;

  00082	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008d	6b 10 38	 imul	 edx, DWORD PTR [eax], 56
  00090	8b 01		 mov	 eax, DWORD PTR [ecx]
  00092	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _b$[ebp]
  00097	f3 0f 11 44 02
	0c		 movss	 DWORD PTR [edx+eax+12], xmm0

; 110  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0x10)) = 1.7f;

  0009d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a8	6b 10 38	 imul	 edx, DWORD PTR [eax], 56
  000ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fd9999a
  000b5	f3 0f 11 44 02
	10		 movss	 DWORD PTR [edx+eax+16], xmm0

; 111  : 				};

  000bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c5	59		 pop	 ecx
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000cf	3b ec		 cmp	 ebp, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH
  000dc	cc		 int	 3
  000dd	cc		 int	 3
  000de	cc		 int	 3
  000df	cc		 int	 3
  000e0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z ENDP ; <lambda_af406ef13d2254f32c3176914df7d750>::operator()
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_adress$ = 8						; size = 4
??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z PROC		; RPM<unsigned int,std::enable_if<1,void> >, COMDAT

; 9    : auto RPM(const uintptr_t adress) noexcept -> T {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00020	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 10   : 	return *reinterpret_cast<T*>(adress);

  00047	8b 45 08	 mov	 eax, DWORD PTR _adress$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]

; 11   : }

  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
  0006e	cc		 int	 3
  0006f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z ENDP		; RPM<unsigned int,std::enable_if<1,void> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ?hkEndScene@@YGJPAUIDirect3DDevice9@@@Z
_TEXT	SEGMENT
tv214 = -392						; size = 4
tv93 = -392						; size = 4
$T1 = -384						; size = 8
$T2 = -368						; size = 8
$T3 = -352						; size = 8
$T4 = -336						; size = 8
$T5 = -320						; size = 8
_applyColor$6 = -112					; size = 8
_entTeamNum$7 = -96					; size = 4
_glowIndex$8 = -84					; size = 4
_entity$9 = -72						; size = 4
_i$10 = -60						; size = 4
_myTeamNum$11 = -48					; size = 4
_EntityList$ = -36					; size = 4
_GlowObjectManager$ = -24				; size = 4
_LocalPlayer$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_pDevice$ = 8						; size = 4
?hkEndScene@@YGJPAUIDirect3DDevice9@@@Z PROC		; hkEndScene, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 01 00
	00		 sub	 esp, 392		; 00000188H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 78 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-392]
  00012	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   : 	if (!init) {

  00032	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?init@@3_NA ; init
  00039	85 c0		 test	 eax, eax
  0003b	0f 85 9a 00 00
	00		 jne	 $LN7@hkEndScene

; 61   : 		gameModule = (DWORD)(GetModuleHandle("client.dll"));

  00041	8b f4		 mov	 esi, esp
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PHFEFMEF@client?4dll@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	a3 00 00 00 00	 mov	 DWORD PTR ?gameModule@@3IA, eax ; gameModule

; 62   : 		engineModule = (DWORD)(GetModuleHandle("engine.dll"));

  0005a	8b f4		 mov	 esi, esp
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EMPDFJNI@engine?4dll@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	a3 00 00 00 00	 mov	 DWORD PTR ?engineModule@@3IA, eax ; engineModule

; 63   : 		InitImGui(pDevice);

  00073	8b 45 08	 mov	 eax, DWORD PTR _pDevice$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?InitImGui@@YAXPAUIDirect3DDevice9@@@Z ; InitImGui
  0007c	83 c4 04	 add	 esp, 4

; 64   : 		ImGui::SetNextWindowPos(ImVec2(650, 200));

  0007f	51		 push	 ecx
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00088	51		 push	 ecx
  00089	0f 57 c0	 xorps	 xmm0, xmm0
  0008c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00091	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00097	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0009c	50		 push	 eax
  0009d	6a 00		 push	 0
  0009f	51		 push	 ecx
  000a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43480000
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	51		 push	 ecx
  000ae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44228000
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000c1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?SetNextWindowPos@ImGui@@YAXABUImVec2@@H0@Z ; ImGui::SetNextWindowPos
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 65   : 
; 66   : 		init = true;

  000cf	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?init@@3_NA, 1	; init

; 67   : 		loadStyle();

  000d6	e8 00 00 00 00	 call	 ?loadStyle@@YAXXZ	; loadStyle
$LN7@hkEndScene:

; 68   : 	}
; 69   : 	
; 70   : 	//Closes Cheat with "END" KEY
; 71   : 	if (GetAsyncKeyState(VK_END)) {

  000db	8b f4		 mov	 esi, esp
  000dd	6a 23		 push	 35			; 00000023H
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAsyncKeyState@4
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	98		 cwde
  000ed	85 c0		 test	 eax, eax
  000ef	74 0c		 je	 SHORT $LN8@hkEndScene

; 72   : 		kiero::shutdown();

  000f1	e8 00 00 00 00	 call	 ?shutdown@kiero@@YAXXZ	; kiero::shutdown

; 73   : 		return 0;

  000f6	33 c0		 xor	 eax, eax
  000f8	e9 ee 03 00 00	 jmp	 $LN1@hkEndScene
$LN8@hkEndScene:

; 74   : 	}
; 75   : 	
; 76   : 	//Switches Overlay Menu State
; 77   : 	if (GetAsyncKeyState(VK_F1) & 1) {

  000fd	8b f4		 mov	 esi, esp
  000ff	6a 70		 push	 112			; 00000070H
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAsyncKeyState@4
  00107	3b f4		 cmp	 esi, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010e	98		 cwde
  0010f	83 e0 01	 and	 eax, 1
  00112	74 2d		 je	 SHORT $LN9@hkEndScene

; 78   : 		show = !show;

  00114	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?show@@3_NA ; show
  0011b	85 c0		 test	 eax, eax
  0011d	75 0c		 jne	 SHORT $LN26@hkEndScene
  0011f	c7 85 78 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv93[ebp], 1
  00129	eb 0a		 jmp	 SHORT $LN27@hkEndScene
$LN26@hkEndScene:
  0012b	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv93[ebp], 0
$LN27@hkEndScene:
  00135	8a 8d 78 fe ff
	ff		 mov	 cl, BYTE PTR tv93[ebp]
  0013b	88 0d 00 00 00
	00		 mov	 BYTE PTR ?show@@3_NA, cl ; show
$LN9@hkEndScene:

; 79   : 	}
; 80   : 	//get Propertys 
; 81   : 	const uintptr_t LocalPlayer = RPM<uintptr_t>(gameModule + signatures::dwLocalPlayer);

  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gameModule@@3IA ; gameModule
  00146	05 14 dd d3 00	 add	 eax, 13884692		; 00d3dd14H
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z ; RPM<unsigned int,std::enable_if<1,void> >
  00151	83 c4 04	 add	 esp, 4
  00154	89 45 f4	 mov	 DWORD PTR _LocalPlayer$[ebp], eax

; 82   : 	const uintptr_t GlowObjectManager = RPM<uintptr_t>(gameModule + signatures::dwGlowObjectManager);

  00157	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gameModule@@3IA ; gameModule
  0015c	05 e0 a1 29 05	 add	 eax, 86614496		; 0529a1e0H
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 ??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z ; RPM<unsigned int,std::enable_if<1,void> >
  00167	83 c4 04	 add	 esp, 4
  0016a	89 45 e8	 mov	 DWORD PTR _GlowObjectManager$[ebp], eax

; 83   : 	const uintptr_t EntityList = RPM<uintptr_t>(gameModule + signatures::dwEntityList);

  0016d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gameModule@@3IA ; gameModule
  00172	05 ac 23 d5 04	 add	 eax, 81077164		; 04d523acH
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ??$RPM@IU?$enable_if@$00X@std@@@@YAII@Z ; RPM<unsigned int,std::enable_if<1,void> >
  0017d	83 c4 04	 add	 esp, 4
  00180	89 45 dc	 mov	 DWORD PTR _EntityList$[ebp], eax

; 84   : 
; 85   : 	if (aimBot) {
; 86   : 
; 87   : 	//TODO Aimbot	
; 88   : 
; 89   : 
; 90   : 	}
; 91   : 
; 92   : 	if (WallsOn) {

  00183	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?WallsOn@@3_NA
  0018a	85 c0		 test	 eax, eax
  0018c	0f 84 12 01 00
	00		 je	 $LN3@hkEndScene

; 93   : 	
; 94   : 		if (LocalPlayer != NULL && GlowObjectManager != NULL && EntityList != NULL) {

  00192	83 7d f4 00	 cmp	 DWORD PTR _LocalPlayer$[ebp], 0
  00196	0f 84 08 01 00
	00		 je	 $LN3@hkEndScene
  0019c	83 7d e8 00	 cmp	 DWORD PTR _GlowObjectManager$[ebp], 0
  001a0	0f 84 fe 00 00
	00		 je	 $LN3@hkEndScene
  001a6	83 7d dc 00	 cmp	 DWORD PTR _EntityList$[ebp], 0
  001aa	0f 84 f4 00 00
	00		 je	 $LN3@hkEndScene

; 95   : 
; 96   : 			int myTeamNum = *reinterpret_cast<int*>(LocalPlayer + netvars::m_iTeamNum);

  001b0	8b 45 f4	 mov	 eax, DWORD PTR _LocalPlayer$[ebp]
  001b3	8b 88 f4 00 00
	00		 mov	 ecx, DWORD PTR [eax+244]
  001b9	89 4d d0	 mov	 DWORD PTR _myTeamNum$11[ebp], ecx

; 97   : 			//The number of Players that are going to be checked with Team
; 98   : 			for (auto i = 0; i < 64; ++i) {

  001bc	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$10[ebp], 0
  001c3	eb 09		 jmp	 SHORT $LN4@hkEndScene
$LN2@hkEndScene:
  001c5	8b 45 c4	 mov	 eax, DWORD PTR _i$10[ebp]
  001c8	83 c0 01	 add	 eax, 1
  001cb	89 45 c4	 mov	 DWORD PTR _i$10[ebp], eax
$LN4@hkEndScene:
  001ce	83 7d c4 40	 cmp	 DWORD PTR _i$10[ebp], 64 ; 00000040H
  001d2	0f 8d cc 00 00
	00		 jge	 $LN3@hkEndScene

; 99   : 
; 100  : 				auto* const entity = *reinterpret_cast<Entity**>(gameModule + signatures::dwEntityList + i * 0x10);

  001d8	8b 45 c4	 mov	 eax, DWORD PTR _i$10[ebp]
  001db	c1 e0 04	 shl	 eax, 4
  001de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gameModule@@3IA ; gameModule
  001e4	8b 94 01 ac 23
	d5 04		 mov	 edx, DWORD PTR [ecx+eax+81077164]
  001eb	89 55 b8	 mov	 DWORD PTR _entity$9[ebp], edx

; 101  : 				if (entity == nullptr || entity->GetDormant()) continue;

  001ee	83 7d b8 00	 cmp	 DWORD PTR _entity$9[ebp], 0
  001f2	74 0f		 je	 SHORT $LN14@hkEndScene
  001f4	8b 4d b8	 mov	 ecx, DWORD PTR _entity$9[ebp]
  001f7	e8 00 00 00 00	 call	 ?GetDormant@Entity@@QAE_NXZ ; Entity::GetDormant
  001fc	0f b6 c0	 movzx	 eax, al
  001ff	85 c0		 test	 eax, eax
  00201	74 02		 je	 SHORT $LN13@hkEndScene
$LN14@hkEndScene:
  00203	eb c0		 jmp	 SHORT $LN2@hkEndScene
$LN13@hkEndScene:

; 102  : 
; 103  : 				const int glowIndex = *reinterpret_cast<int*>(entity + netvars::m_iGlowIndex);

  00205	8b 45 b8	 mov	 eax, DWORD PTR _entity$9[ebp]
  00208	8b 88 38 a4 00
	00		 mov	 ecx, DWORD PTR [eax+42040]
  0020e	89 4d ac	 mov	 DWORD PTR _glowIndex$8[ebp], ecx

; 104  : 				const int entTeamNum = *reinterpret_cast<int*>(entity + netvars::m_iTeamNum);

  00211	8b 45 b8	 mov	 eax, DWORD PTR _entity$9[ebp]
  00214	8b 88 f4 00 00
	00		 mov	 ecx, DWORD PTR [eax+244]
  0021a	89 4d a0	 mov	 DWORD PTR _entTeamNum$7[ebp], ecx

; 105  : 
; 106  : 				auto applyColor = [&](const float r, const float g, const float b) noexcept -> void {
; 107  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0x4)) = r;
; 108  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0x8)) = g;
; 109  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0xC)) = b;
; 110  : 					*reinterpret_cast<float*>((GlowObjectManager)+((glowIndex * 0x38) + 0x10)) = 1.7f;
; 111  : 				};

  0021d	8d 45 ac	 lea	 eax, DWORD PTR _glowIndex$8[ebp]
  00220	50		 push	 eax
  00221	8d 4d e8	 lea	 ecx, DWORD PTR _GlowObjectManager$[ebp]
  00224	51		 push	 ecx
  00225	8d 4d 90	 lea	 ecx, DWORD PTR _applyColor$6[ebp]
  00228	e8 00 00 00 00	 call	 ??0<lambda_af406ef13d2254f32c3176914df7d750>@@QAE@ABIABH@Z ; <lambda_af406ef13d2254f32c3176914df7d750>::<lambda_af406ef13d2254f32c3176914df7d750>

; 112  : 
; 113  : 				if (entTeamNum == myTeamNum) {

  0022d	8b 45 a0	 mov	 eax, DWORD PTR _entTeamNum$7[ebp]
  00230	3b 45 d0	 cmp	 eax, DWORD PTR _myTeamNum$11[ebp]
  00233	75 2a		 jne	 SHORT $LN15@hkEndScene

; 114  : 					// Teammate:
; 115  : 					applyColor(.0f, 1.f, 0.f);

  00235	51		 push	 ecx
  00236	0f 57 c0	 xorps	 xmm0, xmm0
  00239	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023e	51		 push	 ecx
  0023f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00247	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0024c	51		 push	 ecx
  0024d	0f 57 c0	 xorps	 xmm0, xmm0
  00250	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00255	8d 4d 90	 lea	 ecx, DWORD PTR _applyColor$6[ebp]
  00258	e8 00 00 00 00	 call	 ??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z ; <lambda_af406ef13d2254f32c3176914df7d750>::operator()

; 116  : 				}

  0025d	eb 28		 jmp	 SHORT $LN16@hkEndScene
$LN15@hkEndScene:

; 117  : 				else {
; 118  : 					// Enemy:
; 119  : 					applyColor(.0f, .0f, 1.f);

  0025f	51		 push	 ecx
  00260	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00268	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026d	51		 push	 ecx
  0026e	0f 57 c0	 xorps	 xmm0, xmm0
  00271	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00276	51		 push	 ecx
  00277	0f 57 c0	 xorps	 xmm0, xmm0
  0027a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027f	8d 4d 90	 lea	 ecx, DWORD PTR _applyColor$6[ebp]
  00282	e8 00 00 00 00	 call	 ??R<lambda_af406ef13d2254f32c3176914df7d750>@@QBEXMMM@Z ; <lambda_af406ef13d2254f32c3176914df7d750>::operator()
$LN16@hkEndScene:

; 120  : 				}
; 121  : 				*reinterpret_cast<bool*>((GlowObjectManager)+((glowIndex * 0x38) + 0x24)) = true;

  00287	6b 45 ac 38	 imul	 eax, DWORD PTR _glowIndex$8[ebp], 56
  0028b	8b 4d e8	 mov	 ecx, DWORD PTR _GlowObjectManager$[ebp]
  0028e	c6 44 01 24 01	 mov	 BYTE PTR [ecx+eax+36], 1

; 122  : 				*reinterpret_cast<bool*>((GlowObjectManager)+((glowIndex * 0x38) + 0x25)) = false;

  00293	6b 45 ac 38	 imul	 eax, DWORD PTR _glowIndex$8[ebp], 56
  00297	8b 4d e8	 mov	 ecx, DWORD PTR _GlowObjectManager$[ebp]
  0029a	c6 44 01 25 00	 mov	 BYTE PTR [ecx+eax+37], 0

; 123  : 
; 124  : 			}

  0029f	e9 21 ff ff ff	 jmp	 $LN2@hkEndScene
$LN3@hkEndScene:

; 125  : 
; 126  : 		}
; 127  : 	}
; 128  : 
; 129  : 	if (fov != 90) {

  002a4	83 3d 00 00 00
	00 5a		 cmp	 DWORD PTR ?fov@@3HA, 90	; 0000005aH
  002ab	74 18		 je	 SHORT $LN17@hkEndScene

; 130  : 		WPM<int>(LocalPlayer + netvars::m_iFOV, fov);

  002ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?fov@@3HA
  002b2	50		 push	 eax
  002b3	8b 4d f4	 mov	 ecx, DWORD PTR _LocalPlayer$[ebp]
  002b6	81 c1 e4 31 00
	00		 add	 ecx, 12772		; 000031e4H
  002bc	51		 push	 ecx
  002bd	e8 00 00 00 00	 call	 ??$WPM@HU?$enable_if@$00X@std@@@@YAXIH@Z ; WPM<int,std::enable_if<1,void> >
  002c2	83 c4 08	 add	 esp, 8
$LN17@hkEndScene:

; 131  : 	}
; 132  : 
; 133  : 	//showes the Overlay or Hide
; 134  : 	if (show) {

  002c5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?show@@3_NA ; show
  002cc	85 c0		 test	 eax, eax
  002ce	0f 84 04 02 00
	00		 je	 $LN18@hkEndScene

; 135  : 
; 136  : 		ImGui_ImplDX9_NewFrame();	

  002d4	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_NewFrame@@YAXXZ ; ImGui_ImplDX9_NewFrame

; 137  : 		ImGui_ImplWin32_NewFrame();

  002d9	e8 00 00 00 00	 call	 ?ImGui_ImplWin32_NewFrame@@YAXXZ ; ImGui_ImplWin32_NewFrame

; 138  : 		ImGui::NewFrame();

  002de	e8 00 00 00 00	 call	 ?NewFrame@ImGui@@YAXXZ	; ImGui::NewFrame

; 139  : 
; 140  : 		//begin new Overlay Window
; 141  : 		// TODO check boolean
; 142  : 		ImGui::Begin("Projekt Wolf");

  002e3	6a 00		 push	 0
  002e5	6a 00		 push	 0
  002e7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CLHLOEMD@Projekt?5Wolf@
  002ec	e8 00 00 00 00	 call	 ?Begin@ImGui@@YA_NPBDPA_NH@Z ; ImGui::Begin
  002f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  : 
; 144  : 		if (ImGui::Button("Aimbot", ImVec2(100.0f, 0.0f)))

  002f4	51		 push	 ecx
  002f5	0f 57 c0	 xorps	 xmm0, xmm0
  002f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fd	51		 push	 ecx
  002fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00306	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030b	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00311	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00316	50		 push	 eax
  00317	68 00 00 00 00	 push	 OFFSET ??_C@_06FHEBLMEF@Aimbot@
  0031c	e8 00 00 00 00	 call	 ?Button@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::Button
  00321	83 c4 08	 add	 esp, 8
  00324	0f b6 c0	 movzx	 eax, al
  00327	85 c0		 test	 eax, eax
  00329	74 0a		 je	 SHORT $LN19@hkEndScene

; 145  : 			switchTabs = 0;

  0032b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?switchTabs@@3HA, 0
$LN19@hkEndScene:

; 146  : 		ImGui::SameLine(0.0, 2.0f);

  00335	51		 push	 ecx
  00336	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0033e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00343	51		 push	 ecx
  00344	0f 57 c0	 xorps	 xmm0, xmm0
  00347	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034c	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00351	83 c4 08	 add	 esp, 8

; 147  : 		if (ImGui::Button("Visuals", ImVec2(100.0f, 0.0f)))

  00354	51		 push	 ecx
  00355	0f 57 c0	 xorps	 xmm0, xmm0
  00358	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035d	51		 push	 ecx
  0035e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00366	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036b	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00371	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00376	50		 push	 eax
  00377	68 00 00 00 00	 push	 OFFSET ??_C@_07GNHLELCG@Visuals@
  0037c	e8 00 00 00 00	 call	 ?Button@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::Button
  00381	83 c4 08	 add	 esp, 8
  00384	0f b6 c0	 movzx	 eax, al
  00387	85 c0		 test	 eax, eax
  00389	74 0a		 je	 SHORT $LN20@hkEndScene

; 148  : 			switchTabs = 1;

  0038b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?switchTabs@@3HA, 1
$LN20@hkEndScene:

; 149  : 		ImGui::SameLine(0.0, 2.0f);

  00395	51		 push	 ecx
  00396	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0039e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a3	51		 push	 ecx
  003a4	0f 57 c0	 xorps	 xmm0, xmm0
  003a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ac	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  003b1	83 c4 08	 add	 esp, 8

; 150  : 		if (ImGui::Button("Test", ImVec2(100.0f, 0.0f)))

  003b4	51		 push	 ecx
  003b5	0f 57 c0	 xorps	 xmm0, xmm0
  003b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003bd	51		 push	 ecx
  003be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  003c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cb	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  003d1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003d6	50		 push	 eax
  003d7	68 00 00 00 00	 push	 OFFSET ??_C@_04OFFCAMCD@Test@
  003dc	e8 00 00 00 00	 call	 ?Button@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::Button
  003e1	83 c4 08	 add	 esp, 8
  003e4	0f b6 c0	 movzx	 eax, al
  003e7	85 c0		 test	 eax, eax
  003e9	74 0a		 je	 SHORT $LN21@hkEndScene

; 151  : 			switchTabs = 2;

  003eb	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?switchTabs@@3HA, 2
$LN21@hkEndScene:

; 152  : 
; 153  : 		switch (switchTabs) {

  003f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?switchTabs@@3HA
  003fa	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv214[ebp], eax
  00400	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv214[ebp], 0
  00407	74 14		 je	 SHORT $LN22@hkEndScene
  00409	83 bd 78 fe ff
	ff 01		 cmp	 DWORD PTR tv214[ebp], 1
  00410	74 1a		 je	 SHORT $LN23@hkEndScene
  00412	83 bd 78 fe ff
	ff 02		 cmp	 DWORD PTR tv214[ebp], 2
  00419	74 5e		 je	 SHORT $LN24@hkEndScene
  0041b	eb 69		 jmp	 SHORT $LN5@hkEndScene
$LN22@hkEndScene:

; 154  : 		case 0:
; 155  : 			ImGui::Text("Test1");

  0041d	68 00 00 00 00	 push	 OFFSET ??_C@_05GENPCEMM@Test1@
  00422	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00427	83 c4 04	 add	 esp, 4

; 156  : 			break;

  0042a	eb 5a		 jmp	 SHORT $LN5@hkEndScene
$LN23@hkEndScene:

; 157  : 
; 158  : 		case 1:
; 159  : 
; 160  : 			ImGui::Checkbox("WallHack", &WallsOn);

  0042c	68 00 00 00 00	 push	 OFFSET ?WallsOn@@3_NA
  00431	68 00 00 00 00	 push	 OFFSET ??_C@_08HCFMKIA@WallHack@
  00436	e8 00 00 00 00	 call	 ?Checkbox@ImGui@@YA_NPBDPA_N@Z ; ImGui::Checkbox
  0043b	83 c4 08	 add	 esp, 8

; 161  : 			ImGui::SameLine();

  0043e	51		 push	 ecx
  0043f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00447	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0044c	51		 push	 ecx
  0044d	0f 57 c0	 xorps	 xmm0, xmm0
  00450	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00455	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  0045a	83 c4 08	 add	 esp, 8

; 162  : 			ImGui::Text("TODO ADD KEYBIND TOOL");

  0045d	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OOKKINEM@TODO?5ADD?5KEYBIND?5TOOL@
  00462	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00467	83 c4 04	 add	 esp, 4

; 163  : 			ImGui::Text("TODO ADD COLOR CHANGER");

  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PMENLFFB@TODO?5ADD?5COLOR?5CHANGER@
  0046f	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00474	83 c4 04	 add	 esp, 4

; 164  : 			break;

  00477	eb 0d		 jmp	 SHORT $LN5@hkEndScene
$LN24@hkEndScene:

; 165  : 
; 166  : 		case 2:
; 167  : 			ImGui::Text("Test3");

  00479	68 00 00 00 00	 push	 OFFSET ??_C@_05FGOJEGEO@Test3@
  0047e	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00483	83 c4 04	 add	 esp, 4
$LN5@hkEndScene:

; 168  : 			break;
; 169  : 		}
; 170  : 
; 171  : 		ImGui::BeginGroup();

  00486	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 172  : 
; 173  : 		ImGui::SliderInt("FOV Settings", &fov, 10, 150);

  0048b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00490	68 96 00 00 00	 push	 150			; 00000096H
  00495	6a 0a		 push	 10			; 0000000aH
  00497	68 00 00 00 00	 push	 OFFSET ?fov@@3HA
  0049c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CNFDMBCC@FOV?5Settings@
  004a1	e8 00 00 00 00	 call	 ?SliderInt@ImGui@@YA_NPBDPAHHH0@Z ; ImGui::SliderInt
  004a6	83 c4 14	 add	 esp, 20			; 00000014H

; 174  : 
; 175  : 		ImGui::EndGroup();

  004a9	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 176  : 
; 177  : 		ImGui::Text("Test");

  004ae	68 00 00 00 00	 push	 OFFSET ??_C@_04OFFCAMCD@Test@
  004b3	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  004b8	83 c4 04	 add	 esp, 4

; 178  : 
; 179  : 		ImGui::End();

  004bb	e8 00 00 00 00	 call	 ?End@ImGui@@YAXXZ	; ImGui::End

; 180  : 
; 181  : 		ImGui::EndFrame();

  004c0	e8 00 00 00 00	 call	 ?EndFrame@ImGui@@YAXXZ	; ImGui::EndFrame

; 182  : 		ImGui::Render();

  004c5	e8 00 00 00 00	 call	 ?Render@ImGui@@YAXXZ	; ImGui::Render

; 183  : 		ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());

  004ca	e8 00 00 00 00	 call	 ?GetDrawData@ImGui@@YAPAUImDrawData@@XZ ; ImGui::GetDrawData
  004cf	50		 push	 eax
  004d0	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_RenderDrawData@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX9_RenderDrawData
  004d5	83 c4 04	 add	 esp, 4
$LN18@hkEndScene:

; 184  : 	}
; 185  : 
; 186  : 	return oEndScene(pDevice);

  004d8	8b f4		 mov	 esi, esp
  004da	8b 45 08	 mov	 eax, DWORD PTR _pDevice$[ebp]
  004dd	50		 push	 eax
  004de	ff 15 00 00 00
	00		 call	 DWORD PTR ?oEndScene@@3P6GJPAUIDirect3DDevice9@@@ZA ; oEndScene
  004e4	3b f4		 cmp	 esi, esp
  004e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@hkEndScene:

; 187  : }

  004eb	52		 push	 edx
  004ec	8b cd		 mov	 ecx, ebp
  004ee	50		 push	 eax
  004ef	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@hkEndScene
  004f5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004fa	58		 pop	 eax
  004fb	5a		 pop	 edx
  004fc	5f		 pop	 edi
  004fd	5e		 pop	 esi
  004fe	5b		 pop	 ebx
  004ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00502	33 cd		 xor	 ecx, ebp
  00504	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00509	81 c4 88 01 00
	00		 add	 esp, 392		; 00000188H
  0050f	3b ec		 cmp	 ebp, esp
  00511	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00516	8b e5		 mov	 esp, ebp
  00518	5d		 pop	 ebp
  00519	c2 04 00	 ret	 4
$LN32@hkEndScene:
  0051c	03 00 00 00	 DD	 3
  00520	00 00 00 00	 DD	 $LN31@hkEndScene
$LN31@hkEndScene:
  00524	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00528	04 00 00 00	 DD	 4
  0052c	00 00 00 00	 DD	 $LN28@hkEndScene
  00530	ac ff ff ff	 DD	 -84			; ffffffacH
  00534	04 00 00 00	 DD	 4
  00538	00 00 00 00	 DD	 $LN29@hkEndScene
  0053c	90 ff ff ff	 DD	 -112			; ffffff90H
  00540	08 00 00 00	 DD	 8
  00544	00 00 00 00	 DD	 $LN30@hkEndScene
$LN30@hkEndScene:
  00548	61		 DB	 97			; 00000061H
  00549	70		 DB	 112			; 00000070H
  0054a	70		 DB	 112			; 00000070H
  0054b	6c		 DB	 108			; 0000006cH
  0054c	79		 DB	 121			; 00000079H
  0054d	43		 DB	 67			; 00000043H
  0054e	6f		 DB	 111			; 0000006fH
  0054f	6c		 DB	 108			; 0000006cH
  00550	6f		 DB	 111			; 0000006fH
  00551	72		 DB	 114			; 00000072H
  00552	00		 DB	 0
$LN29@hkEndScene:
  00553	67		 DB	 103			; 00000067H
  00554	6c		 DB	 108			; 0000006cH
  00555	6f		 DB	 111			; 0000006fH
  00556	77		 DB	 119			; 00000077H
  00557	49		 DB	 73			; 00000049H
  00558	6e		 DB	 110			; 0000006eH
  00559	64		 DB	 100			; 00000064H
  0055a	65		 DB	 101			; 00000065H
  0055b	78		 DB	 120			; 00000078H
  0055c	00		 DB	 0
$LN28@hkEndScene:
  0055d	47		 DB	 71			; 00000047H
  0055e	6c		 DB	 108			; 0000006cH
  0055f	6f		 DB	 111			; 0000006fH
  00560	77		 DB	 119			; 00000077H
  00561	4f		 DB	 79			; 0000004fH
  00562	62		 DB	 98			; 00000062H
  00563	6a		 DB	 106			; 0000006aH
  00564	65		 DB	 101			; 00000065H
  00565	63		 DB	 99			; 00000063H
  00566	74		 DB	 116			; 00000074H
  00567	4d		 DB	 77			; 0000004dH
  00568	61		 DB	 97			; 00000061H
  00569	6e		 DB	 110			; 0000006eH
  0056a	61		 DB	 97			; 00000061H
  0056b	67		 DB	 103			; 00000067H
  0056c	65		 DB	 101			; 00000065H
  0056d	72		 DB	 114			; 00000072H
  0056e	00		 DB	 0
?hkEndScene@@YGJPAUIDirect3DDevice9@@@Z ENDP		; hkEndScene
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\main.cpp
;	COMDAT ?InitImGui@@YAXPAUIDirect3DDevice9@@@Z
_TEXT	SEGMENT
_io$ = -8						; size = 4
_pDevice$ = 8						; size = 4
?InitImGui@@YAXPAUIDirect3DDevice9@@@Z PROC		; InitImGui, COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __BDD787A0_main@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 27   : 	ImGui::CreateContext();

  00028	6a 00		 push	 0
  0002a	e8 00 00 00 00	 call	 ?CreateContext@ImGui@@YAPAUImGuiContext@@PAUImFontAtlas@@@Z ; ImGui::CreateContext
  0002f	83 c4 04	 add	 esp, 4

; 28   : 	auto& io = ImGui::GetIO();

  00032	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  00037	89 45 f8	 mov	 DWORD PTR _io$[ebp], eax

; 29   : 	io.ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  0003d	c7 00 20 00 00
	00		 mov	 DWORD PTR [eax], 32	; 00000020H

; 30   : 	ImGui_ImplWin32_Init(window);

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR ?window@@3PAUHWND__@@A
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?ImGui_ImplWin32_Init@@YA_NPAX@Z ; ImGui_ImplWin32_Init
  0004e	83 c4 04	 add	 esp, 4

; 31   : 	ImGui_ImplDX9_Init(pDevice);

  00051	8b 45 08	 mov	 eax, DWORD PTR _pDevice$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_Init@@YA_NPAUIDirect3DDevice9@@@Z ; ImGui_ImplDX9_Init
  0005a	83 c4 04	 add	 esp, 4

; 32   : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?InitImGui@@YAXPAUIDirect3DDevice9@@@Z ENDP		; InitImGui
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\entity.h
;	COMDAT ?GetDormant@Entity@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetDormant@Entity@@QAE_NXZ PROC			; Entity::GetDormant, COMDAT
; _this$ = ecx

; 7    : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __17470045_entity@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 8    : 		return *reinterpret_cast<bool*>(this + signatures::m_bDormant);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8a 80 ed 00 00
	00		 mov	 al, BYTE PTR [eax+237]

; 9    : 	}

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?GetDormant@Entity@@QAE_NXZ ENDP			; Entity::GetDormant
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 187  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __x$[ebp]
  00035	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __y$[ebp]
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
END
