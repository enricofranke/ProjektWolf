; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\kiero.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__241EEA0C_corecrt_memory@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__692346AF_guiddef@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__2908CC08_winuser@h DB 01H
__E6E7469F_winioctl@h DB 01H
__F5601360_stdlib@h DB 01H
__1E567087_propidl@h DB 01H
__9FABC30B_oleauto@h DB 01H
__08182E14_stralign@h DB 01H
__20C772DE_kiero@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?init@kiero@@YA?AW4Enum@Status@1@W42RenderType@1@@Z ; kiero::init
PUBLIC	?shutdown@kiero@@YAXXZ				; kiero::shutdown
PUBLIC	?bind@kiero@@YA?AW4Enum@Status@1@GPAPAXPAX@Z	; kiero::bind
PUBLIC	?unbind@kiero@@YAXG@Z				; kiero::unbind
PUBLIC	?getRenderType@kiero@@YA?AW4Enum@RenderType@1@XZ ; kiero::getRenderType
PUBLIC	?getMethodsTable@kiero@@YAPAIXZ			; kiero::getMethodsTable
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_05GGIHNKI@Kiero@				; `string'
PUBLIC	??_C@_0BF@IOKLLNKO@Kiero?5DirectX?5Window@	; `string'
PUBLIC	??_C@_08NIHLGCK@d3d9?4dll@			; `string'
PUBLIC	??_C@_0BA@FAFMMBOF@Direct3DCreate9@		; `string'
PUBLIC	??_C@_09MPDKCPEA@d3d10?4dll@			; `string'
PUBLIC	??_C@_09EGGPMOF@d3d11?4dll@			; `string'
PUBLIC	??_C@_09ICPCIOEL@d3d12?4dll@			; `string'
PUBLIC	??_C@_0N@DOKAJOHF@opengl32?4dll@		; `string'
PUBLIC	??_C@_0N@JLGIBLKI@vulcan?91?4dll@		; `string'
PUBLIC	?__LINE__Var@?0??bind@kiero@@YA?AW4Enum@Status@2@GPAPAXPAX@Z@4JA ; `kiero::bind'::`1'::__LINE__Var
PUBLIC	??_C@_1KG@GPMKEGPE@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1GM@JBDKMNLM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??unbind@kiero@@YAXG@Z@4JA	; `kiero::unbind'::`1'::__LINE__Var
PUBLIC	??_C@_1BI@MNNDMDNM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp___wassert:PROC
EXTRN	_MH_Initialize@0:PROC
EXTRN	_MH_CreateHook@12:PROC
EXTRN	_MH_EnableHook@4:PROC
EXTRN	_MH_DisableHook@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?g_renderType@@3W4Enum@RenderType@kiero@@A DD 01H DUP (?) ; g_renderType
?g_methodsTable@@3PAIA DD 01H DUP (?)			; g_methodsTable
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1BI@MNNDMDNM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BI@MNNDMDNM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ DB '_'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??unbind@kiero@@YAXG@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??unbind@kiero@@YAXG@Z@4JA DD 02bdH	; `kiero::unbind'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GM@JBDKMNLM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1GM@JBDKMNLM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB '_'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '_', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'g', 00H
	DB	'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H, '!', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'f', 00H, 'u', 00H, 'n'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KG@GPMKEGPE@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1KG@GPMKEGPE@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'k', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	'\', 00H, 'k', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??bind@kiero@@YA?AW4Enum@Status@2@GPAPAXPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??bind@kiero@@YA?AW4Enum@Status@2@GPAPAXPAX@Z@4JA DD 02a7H ; `kiero::bind'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@JLGIBLKI@vulcan?91?4dll@
CONST	SEGMENT
??_C@_0N@JLGIBLKI@vulcan?91?4dll@ DB 'vulcan-1.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOKAJOHF@opengl32?4dll@
CONST	SEGMENT
??_C@_0N@DOKAJOHF@opengl32?4dll@ DB 'opengl32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICPCIOEL@d3d12?4dll@
CONST	SEGMENT
??_C@_09ICPCIOEL@d3d12?4dll@ DB 'd3d12.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EGGPMOF@d3d11?4dll@
CONST	SEGMENT
??_C@_09EGGPMOF@d3d11?4dll@ DB 'd3d11.dll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MPDKCPEA@d3d10?4dll@
CONST	SEGMENT
??_C@_09MPDKCPEA@d3d10?4dll@ DB 'd3d10.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FAFMMBOF@Direct3DCreate9@
CONST	SEGMENT
??_C@_0BA@FAFMMBOF@Direct3DCreate9@ DB 'Direct3DCreate9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NIHLGCK@d3d9?4dll@
CONST	SEGMENT
??_C@_08NIHLGCK@d3d9?4dll@ DB 'd3d9.dll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IOKLLNKO@Kiero?5DirectX?5Window@
CONST	SEGMENT
??_C@_0BF@IOKLLNKO@Kiero?5DirectX?5Window@ DB 'Kiero DirectX Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGIHNKI@Kiero@
CONST	SEGMENT
??_C@_05GGIHNKI@Kiero@ DB 'Kiero', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\kiero.cpp
;	COMDAT ?getMethodsTable@kiero@@YAPAIXZ
_TEXT	SEGMENT
?getMethodsTable@kiero@@YAPAIXZ PROC			; kiero::getMethodsTable, COMDAT

; 718  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20C772DE_kiero@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 719  : 	return g_methodsTable;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_methodsTable@@3PAIA

; 720  : } 

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?getMethodsTable@kiero@@YAPAIXZ ENDP			; kiero::getMethodsTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\kiero.cpp
;	COMDAT ?getRenderType@kiero@@YA?AW4Enum@RenderType@1@XZ
_TEXT	SEGMENT
?getRenderType@kiero@@YA?AW4Enum@RenderType@1@XZ PROC	; kiero::getRenderType, COMDAT

; 713  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20C772DE_kiero@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 714  : 	return g_renderType;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_renderType@@3W4Enum@RenderType@kiero@@A

; 715  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?getRenderType@kiero@@YA?AW4Enum@RenderType@1@XZ ENDP	; kiero::getRenderType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\kiero.cpp
;	COMDAT ?unbind@kiero@@YAXG@Z
_TEXT	SEGMENT
__index$ = 8						; size = 2
?unbind@kiero@@YAXG@Z PROC				; kiero::unbind, COMDAT

; 701  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20C772DE_kiero@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 702  : 	assert(_index >= 0);

  00028	0f b7 45 08	 movzx	 eax, WORD PTR __index$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7d 26		 jge	 SHORT $LN4@unbind
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??unbind@kiero@@YAXG@Z@4JA
  00036	83 c1 01	 add	 ecx, 1
  00039	8b f4		 mov	 esi, esp
  0003b	51		 push	 ecx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KG@GPMKEGPE@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@MNNDMDNM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@unbind:

; 703  : 
; 704  : 	if (g_renderType != RenderType::None)

  00056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_renderType@@3W4Enum@RenderType@kiero@@A, 0
  0005d	74 13		 je	 SHORT $LN1@unbind

; 705  : 	{
; 706  : #if KIERO_USE_MINHOOK
; 707  : 		MH_DisableHook((void*)g_methodsTable[_index]);

  0005f	0f b7 45 08	 movzx	 eax, WORD PTR __index$[ebp]
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_methodsTable@@3PAIA
  00069	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _MH_DisableHook@4
$LN1@unbind:

; 708  : #endif
; 709  : 	}
; 710  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?unbind@kiero@@YAXG@Z ENDP				; kiero::unbind
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\kiero.cpp
;	COMDAT ?bind@kiero@@YA?AW4Enum@Status@1@GPAPAXPAX@Z
_TEXT	SEGMENT
_target$1 = -8						; size = 4
__index$ = 8						; size = 2
__original$ = 12					; size = 4
__function$ = 16					; size = 4
?bind@kiero@@YA?AW4Enum@Status@1@GPAPAXPAX@Z PROC	; kiero::bind, COMDAT

; 679  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20C772DE_kiero@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 680  : 	// TODO: Need own detour function
; 681  : 
; 682  : 	assert(_index >= 0 && _original != NULL && _function != NULL);

  00028	0f b7 45 08	 movzx	 eax, WORD PTR __index$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7c 0c		 jl	 SHORT $LN6@bind
  00030	83 7d 0c 00	 cmp	 DWORD PTR __original$[ebp], 0
  00034	74 06		 je	 SHORT $LN6@bind
  00036	83 7d 10 00	 cmp	 DWORD PTR __function$[ebp], 0
  0003a	75 26		 jne	 SHORT $LN7@bind
$LN6@bind:
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??bind@kiero@@YA?AW4Enum@Status@2@GPAPAXPAX@Z@4JA
  00042	83 c1 03	 add	 ecx, 3
  00045	8b f4		 mov	 esi, esp
  00047	51		 push	 ecx
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_1KG@GPMKEGPE@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_1GM@JBDKMNLM@?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@bind:

; 683  : 
; 684  : 	if (g_renderType != RenderType::None)

  00062	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_renderType@@3W4Enum@RenderType@kiero@@A, 0
  00069	74 3b		 je	 SHORT $LN2@bind

; 685  : 	{
; 686  : #if KIERO_USE_MINHOOK
; 687  : 		void* target = (void*)g_methodsTable[_index];

  0006b	0f b7 45 08	 movzx	 eax, WORD PTR __index$[ebp]
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_methodsTable@@3PAIA
  00075	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00078	89 55 f8	 mov	 DWORD PTR _target$1[ebp], edx

; 688  : 		if (MH_CreateHook(target, _function, _original) != MH_OK || MH_EnableHook(target) != MH_OK)

  0007b	8b 45 0c	 mov	 eax, DWORD PTR __original$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 10	 mov	 ecx, DWORD PTR __function$[ebp]
  00082	51		 push	 ecx
  00083	8b 55 f8	 mov	 edx, DWORD PTR _target$1[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _MH_CreateHook@12
  0008c	85 c0		 test	 eax, eax
  0008e	75 0d		 jne	 SHORT $LN4@bind
  00090	8b 45 f8	 mov	 eax, DWORD PTR _target$1[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _MH_EnableHook@4
  00099	85 c0		 test	 eax, eax
  0009b	74 05		 je	 SHORT $LN3@bind
$LN4@bind:

; 689  : 		{
; 690  : 			return Status::UnknownError;

  0009d	83 c8 ff	 or	 eax, -1
  000a0	eb 09		 jmp	 SHORT $LN1@bind
$LN3@bind:

; 691  : 		}
; 692  : #endif
; 693  : 
; 694  : 		return Status::Success;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 05		 jmp	 SHORT $LN1@bind
$LN2@bind:

; 695  : 	}
; 696  : 
; 697  : 	return Status::NotInitializedError;

  000a6	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
$LN1@bind:

; 698  : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?bind@kiero@@YA?AW4Enum@Status@1@GPAPAXPAX@Z ENDP	; kiero::bind
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\kiero.cpp
;	COMDAT ?shutdown@kiero@@YAXXZ
_TEXT	SEGMENT
?shutdown@kiero@@YAXXZ PROC				; kiero::shutdown, COMDAT

; 665  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __20C772DE_kiero@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 666  : 	if (g_renderType != RenderType::None)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_renderType@@3W4Enum@RenderType@kiero@@A, 0
  0002f	74 33		 je	 SHORT $LN1@shutdown

; 667  : 	{
; 668  : #if KIERO_USE_MINHOOK
; 669  : 		MH_DisableHook(MH_ALL_HOOKS);

  00031	6a 00		 push	 0
  00033	e8 00 00 00 00	 call	 _MH_DisableHook@4

; 670  : #endif
; 671  : 
; 672  : 		::free(g_methodsTable);

  00038	8b f4		 mov	 esi, esp
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_methodsTable@@3PAIA
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00046	83 c4 04	 add	 esp, 4
  00049	3b f4		 cmp	 esi, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 673  : 		g_methodsTable = NULL;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_methodsTable@@3PAIA, 0

; 674  : 		g_renderType = RenderType::None;

  0005a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_renderType@@3W4Enum@RenderType@kiero@@A, 0
$LN1@shutdown:

; 675  : 	}
; 676  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?shutdown@kiero@@YAXXZ ENDP				; kiero::shutdown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\kiero.cpp
;	COMDAT ?init@kiero@@YA?AW4Enum@Status@1@W42RenderType@1@@Z
_TEXT	SEGMENT
_type$1 = -216						; size = 4
_device$2 = -204					; size = 4
_params$3 = -192					; size = 56
_displayMode$4 = -128					; size = 16
_direct3D9$5 = -104					; size = 4
_Direct3DCreate9$6 = -92				; size = 4
_libD3D9$7 = -80					; size = 4
_window$8 = -68						; size = 4
_windowClass$9 = -56					; size = 48
__$ArrayPad$ = -4					; size = 4
__renderType$ = 8					; size = 4
?init@kiero@@YA?AW4Enum@Status@1@W42RenderType@1@@Z PROC ; kiero::init, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 01 00
	00		 sub	 esp, 412		; 0000019cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 64 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-412]
  00012	b9 67 00 00 00	 mov	 ecx, 103		; 00000067H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __20C772DE_kiero@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 50   : 	if (g_renderType != RenderType::None)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_renderType@@3W4Enum@RenderType@kiero@@A, 0
  00039	74 0a		 je	 SHORT $LN2@init

; 51   : 	{
; 52   : 		return Status::AlreadyInitializedError;

  0003b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00040	e9 29 05 00 00	 jmp	 $LN1@init
$LN2@init:

; 53   : 	}
; 54   : 
; 55   : 	if (_renderType != RenderType::None)

  00045	83 7d 08 00	 cmp	 DWORD PTR __renderType$[ebp], 0
  00049	0f 84 1d 05 00
	00		 je	 $LN3@init

; 56   : 	{
; 57   : 		if (_renderType >= RenderType::D3D9 && _renderType <= RenderType::D3D12)

  0004f	83 7d 08 01	 cmp	 DWORD PTR __renderType$[ebp], 1
  00053	0f 8c fc 03 00
	00		 jl	 $LN4@init
  00059	83 7d 08 04	 cmp	 DWORD PTR __renderType$[ebp], 4
  0005d	0f 8f f2 03 00
	00		 jg	 $LN4@init

; 58   : 		{
; 59   : 			WNDCLASSEX windowClass;
; 60   : 			windowClass.cbSize = sizeof(WNDCLASSEX);

  00063	c7 45 c8 30 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp], 48 ; 00000030H

; 61   : 			windowClass.style = CS_HREDRAW | CS_VREDRAW;

  0006a	c7 45 cc 03 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+4], 3

; 62   : 			windowClass.lpfnWndProc = DefWindowProc;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__DefWindowProcA@16
  00076	89 45 d0	 mov	 DWORD PTR _windowClass$9[ebp+8], eax

; 63   : 			windowClass.cbClsExtra = 0;

  00079	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+12], 0

; 64   : 			windowClass.cbWndExtra = 0;

  00080	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+16], 0

; 65   : 			windowClass.hInstance = GetModuleHandle(NULL);

  00087	8b f4		 mov	 esi, esp
  00089	6a 00		 push	 0
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	89 45 dc	 mov	 DWORD PTR _windowClass$9[ebp+20], eax

; 66   : 			windowClass.hIcon = NULL;

  0009b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+24], 0

; 67   : 			windowClass.hCursor = NULL;

  000a2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+28], 0

; 68   : 			windowClass.hbrBackground = NULL;

  000a9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+32], 0

; 69   : 			windowClass.lpszMenuName = NULL;

  000b0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+36], 0

; 70   : 			windowClass.lpszClassName = KIERO_TEXT("Kiero");

  000b7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+40], OFFSET ??_C@_05GGIHNKI@Kiero@

; 71   : 			windowClass.hIconSm = NULL;

  000be	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _windowClass$9[ebp+44], 0

; 72   : 
; 73   : 			::RegisterClassEx(&windowClass);

  000c5	8b f4		 mov	 esi, esp
  000c7	8d 45 c8	 lea	 eax, DWORD PTR _windowClass$9[ebp]
  000ca	50		 push	 eax
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassExA@4
  000d1	3b f4		 cmp	 esi, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 74   : 
; 75   : 			HWND window = ::CreateWindow(windowClass.lpszClassName, KIERO_TEXT("Kiero DirectX Window"), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, NULL, NULL, windowClass.hInstance, NULL);

  000d8	8b f4		 mov	 esi, esp
  000da	6a 00		 push	 0
  000dc	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  000df	50		 push	 eax
  000e0	6a 00		 push	 0
  000e2	6a 00		 push	 0
  000e4	6a 64		 push	 100			; 00000064H
  000e6	6a 64		 push	 100			; 00000064H
  000e8	6a 00		 push	 0
  000ea	6a 00		 push	 0
  000ec	68 00 00 cf 00	 push	 13565952		; 00cf0000H
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IOKLLNKO@Kiero?5DirectX?5Window@
  000f6	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  000f9	51		 push	 ecx
  000fa	6a 00		 push	 0
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  00102	3b f4		 cmp	 esi, esp
  00104	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00109	89 45 bc	 mov	 DWORD PTR _window$8[ebp], eax

; 76   : 
; 77   : 			if (_renderType == RenderType::D3D9)

  0010c	83 7d 08 01	 cmp	 DWORD PTR __renderType$[ebp], 1
  00110	0f 85 06 03 00
	00		 jne	 $LN7@init

; 78   : 			{
; 79   : #if KIERO_INCLUDE_D3D9
; 80   : 				HMODULE libD3D9;
; 81   : 				if ((libD3D9 = ::GetModuleHandle(KIERO_TEXT("d3d9.dll"))) == NULL)

  00116	8b f4		 mov	 esi, esp
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_08NIHLGCK@d3d9?4dll@
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00123	3b f4		 cmp	 esi, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012a	89 45 b0	 mov	 DWORD PTR _libD3D9$7[ebp], eax
  0012d	83 7d b0 00	 cmp	 DWORD PTR _libD3D9$7[ebp], 0
  00131	75 34		 jne	 SHORT $LN8@init

; 82   : 				{
; 83   : 					::DestroyWindow(window);

  00133	8b f4		 mov	 esi, esp
  00135	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  00138	50		 push	 eax
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0013f	3b f4		 cmp	 esi, esp
  00141	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 84   : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

  00146	8b f4		 mov	 esi, esp
  00148	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  0014b	50		 push	 eax
  0014c	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  0014f	51		 push	 ecx
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  00156	3b f4		 cmp	 esi, esp
  00158	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 85   : 					return Status::ModuleNotFoundError;

  0015d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00162	e9 07 04 00 00	 jmp	 $LN1@init
$LN8@init:

; 86   : 				}
; 87   : 
; 88   : 				void* Direct3DCreate9;
; 89   : 				if ((Direct3DCreate9 = ::GetProcAddress(libD3D9, "Direct3DCreate9")) == NULL)

  00167	8b f4		 mov	 esi, esp
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FAFMMBOF@Direct3DCreate9@
  0016e	8b 45 b0	 mov	 eax, DWORD PTR _libD3D9$7[ebp]
  00171	50		 push	 eax
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00178	3b f4		 cmp	 esi, esp
  0017a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017f	89 45 a4	 mov	 DWORD PTR _Direct3DCreate9$6[ebp], eax
  00182	83 7d a4 00	 cmp	 DWORD PTR _Direct3DCreate9$6[ebp], 0
  00186	75 32		 jne	 SHORT $LN9@init

; 90   : 				{
; 91   : 					::DestroyWindow(window);

  00188	8b f4		 mov	 esi, esp
  0018a	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  0018d	50		 push	 eax
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00194	3b f4		 cmp	 esi, esp
  00196	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 92   : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

  0019b	8b f4		 mov	 esi, esp
  0019d	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  001a0	50		 push	 eax
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  001a4	51		 push	 ecx
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  001ab	3b f4		 cmp	 esi, esp
  001ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 93   : 					return Status::UnknownError;

  001b2	83 c8 ff	 or	 eax, -1
  001b5	e9 b4 03 00 00	 jmp	 $LN1@init
$LN9@init:

; 94   : 				}
; 95   : 
; 96   : 				LPDIRECT3D9 direct3D9;
; 97   : 				if ((direct3D9 = ((LPDIRECT3D9(__stdcall*)(uint32_t))(Direct3DCreate9))(D3D_SDK_VERSION)) == NULL)

  001ba	8b f4		 mov	 esi, esp
  001bc	6a 20		 push	 32			; 00000020H
  001be	ff 55 a4	 call	 DWORD PTR _Direct3DCreate9$6[ebp]
  001c1	3b f4		 cmp	 esi, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c8	89 45 98	 mov	 DWORD PTR _direct3D9$5[ebp], eax
  001cb	83 7d 98 00	 cmp	 DWORD PTR _direct3D9$5[ebp], 0
  001cf	75 32		 jne	 SHORT $LN10@init

; 98   : 				{
; 99   : 					::DestroyWindow(window);

  001d1	8b f4		 mov	 esi, esp
  001d3	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  001d6	50		 push	 eax
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  001dd	3b f4		 cmp	 esi, esp
  001df	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 100  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

  001e4	8b f4		 mov	 esi, esp
  001e6	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  001e9	50		 push	 eax
  001ea	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  001ed	51		 push	 ecx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  001f4	3b f4		 cmp	 esi, esp
  001f6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 101  : 					return Status::UnknownError;

  001fb	83 c8 ff	 or	 eax, -1
  001fe	e9 6b 03 00 00	 jmp	 $LN1@init
$LN10@init:

; 102  : 				}
; 103  : 
; 104  : 				D3DDISPLAYMODE displayMode;
; 105  : 				if (direct3D9->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &displayMode) < 0)

  00203	8b f4		 mov	 esi, esp
  00205	8d 45 80	 lea	 eax, DWORD PTR _displayMode$4[ebp]
  00208	50		 push	 eax
  00209	6a 00		 push	 0
  0020b	8b 4d 98	 mov	 ecx, DWORD PTR _direct3D9$5[ebp]
  0020e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00210	8b 45 98	 mov	 eax, DWORD PTR _direct3D9$5[ebp]
  00213	50		 push	 eax
  00214	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00217	ff d1		 call	 ecx
  00219	3b f4		 cmp	 esi, esp
  0021b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00220	85 c0		 test	 eax, eax
  00222	7d 32		 jge	 SHORT $LN11@init

; 106  : 				{
; 107  : 					::DestroyWindow(window);

  00224	8b f4		 mov	 esi, esp
  00226	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  00229	50		 push	 eax
  0022a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00230	3b f4		 cmp	 esi, esp
  00232	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

  00237	8b f4		 mov	 esi, esp
  00239	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  0023c	50		 push	 eax
  0023d	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  00240	51		 push	 ecx
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  00247	3b f4		 cmp	 esi, esp
  00249	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 109  : 					return Status::UnknownError;

  0024e	83 c8 ff	 or	 eax, -1
  00251	e9 18 03 00 00	 jmp	 $LN1@init
$LN11@init:

; 110  : 				}
; 111  : 
; 112  : 				D3DPRESENT_PARAMETERS params;
; 113  : 				params.BackBufferWidth = 0;

  00256	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp], 0

; 114  : 				params.BackBufferHeight = 0;

  00260	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+4], 0

; 115  : 				params.BackBufferFormat = displayMode.Format;

  0026a	8b 45 8c	 mov	 eax, DWORD PTR _displayMode$4[ebp+12]
  0026d	89 85 48 ff ff
	ff		 mov	 DWORD PTR _params$3[ebp+8], eax

; 116  : 				params.BackBufferCount = 0;

  00273	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+12], 0

; 117  : 				params.MultiSampleType = D3DMULTISAMPLE_NONE;

  0027d	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+16], 0

; 118  : 				params.MultiSampleQuality = NULL;

  00287	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+20], 0

; 119  : 				params.SwapEffect = D3DSWAPEFFECT_DISCARD;

  00291	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _params$3[ebp+24], 1

; 120  : 				params.hDeviceWindow = window;

  0029b	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  0029e	89 85 5c ff ff
	ff		 mov	 DWORD PTR _params$3[ebp+28], eax

; 121  : 				params.Windowed = 1;

  002a4	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _params$3[ebp+32], 1

; 122  : 				params.EnableAutoDepthStencil = 0;

  002ae	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+36], 0

; 123  : 				params.AutoDepthStencilFormat = D3DFMT_UNKNOWN;

  002b8	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+40], 0

; 124  : 				params.Flags = NULL;

  002c2	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+44], 0

; 125  : 				params.FullScreen_RefreshRateInHz = 0;

  002cc	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+48], 0

; 126  : 				params.PresentationInterval = 0;

  002d6	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _params$3[ebp+52], 0

; 127  : 
; 128  : 				LPDIRECT3DDEVICE9 device;
; 129  : 				if (direct3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, window, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &params, &device) < 0)

  002e0	8b f4		 mov	 esi, esp
  002e2	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _device$2[ebp]
  002e8	50		 push	 eax
  002e9	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _params$3[ebp]
  002ef	51		 push	 ecx
  002f0	68 20 01 00 00	 push	 288			; 00000120H
  002f5	8b 55 bc	 mov	 edx, DWORD PTR _window$8[ebp]
  002f8	52		 push	 edx
  002f9	6a 01		 push	 1
  002fb	6a 00		 push	 0
  002fd	8b 45 98	 mov	 eax, DWORD PTR _direct3D9$5[ebp]
  00300	8b 08		 mov	 ecx, DWORD PTR [eax]
  00302	8b 55 98	 mov	 edx, DWORD PTR _direct3D9$5[ebp]
  00305	52		 push	 edx
  00306	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  00309	ff d0		 call	 eax
  0030b	3b f4		 cmp	 esi, esp
  0030d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00312	85 c0		 test	 eax, eax
  00314	7d 49		 jge	 SHORT $LN12@init

; 130  : 				{
; 131  : 					direct3D9->Release();

  00316	8b 45 98	 mov	 eax, DWORD PTR _direct3D9$5[ebp]
  00319	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031b	8b f4		 mov	 esi, esp
  0031d	8b 55 98	 mov	 edx, DWORD PTR _direct3D9$5[ebp]
  00320	52		 push	 edx
  00321	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00324	ff d0		 call	 eax
  00326	3b f4		 cmp	 esi, esp
  00328	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 132  : 					::DestroyWindow(window);

  0032d	8b f4		 mov	 esi, esp
  0032f	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  00332	50		 push	 eax
  00333	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00339	3b f4		 cmp	 esi, esp
  0033b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 133  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

  00340	8b f4		 mov	 esi, esp
  00342	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  00345	50		 push	 eax
  00346	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  00349	51		 push	 ecx
  0034a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  00350	3b f4		 cmp	 esi, esp
  00352	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 134  : 					return Status::UnknownError;

  00357	83 c8 ff	 or	 eax, -1
  0035a	e9 0f 02 00 00	 jmp	 $LN1@init
$LN12@init:

; 135  : 				}
; 136  : 
; 137  : 				g_methodsTable = (uint150_t*)::calloc(119, sizeof(uint150_t));

  0035f	8b f4		 mov	 esi, esp
  00361	6a 04		 push	 4
  00363	6a 77		 push	 119			; 00000077H
  00365	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0036b	83 c4 08	 add	 esp, 8
  0036e	3b f4		 cmp	 esi, esp
  00370	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00375	a3 00 00 00 00	 mov	 DWORD PTR ?g_methodsTable@@3PAIA, eax

; 138  : 				::memcpy(g_methodsTable, *(uint150_t**)device, 119 * sizeof(uint150_t));

  0037a	68 dc 01 00 00	 push	 476			; 000001dcH
  0037f	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _device$2[ebp]
  00385	8b 08		 mov	 ecx, DWORD PTR [eax]
  00387	51		 push	 ecx
  00388	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_methodsTable@@3PAIA
  0038e	52		 push	 edx
  0038f	e8 00 00 00 00	 call	 _memcpy
  00394	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  : 
; 140  : #if KIERO_USE_MINHOOK
; 141  : 				MH_Initialize();

  00397	e8 00 00 00 00	 call	 _MH_Initialize@0

; 142  : #endif
; 143  : 
; 144  : 				direct3D9->Release();

  0039c	8b 45 98	 mov	 eax, DWORD PTR _direct3D9$5[ebp]
  0039f	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a1	8b f4		 mov	 esi, esp
  003a3	8b 55 98	 mov	 edx, DWORD PTR _direct3D9$5[ebp]
  003a6	52		 push	 edx
  003a7	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  003aa	ff d0		 call	 eax
  003ac	3b f4		 cmp	 esi, esp
  003ae	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 145  : 				direct3D9 = NULL;

  003b3	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _direct3D9$5[ebp], 0

; 146  : 
; 147  : 				device->Release();

  003ba	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _device$2[ebp]
  003c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c2	8b f4		 mov	 esi, esp
  003c4	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _device$2[ebp]
  003ca	52		 push	 edx
  003cb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  003ce	ff d0		 call	 eax
  003d0	3b f4		 cmp	 esi, esp
  003d2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 148  : 				device = NULL;

  003d7	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _device$2[ebp], 0

; 149  : 
; 150  : 				g_renderType = RenderType::D3D9;

  003e1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_renderType@@3W4Enum@RenderType@kiero@@A, 1

; 151  : 
; 152  : 				::DestroyWindow(window);

  003eb	8b f4		 mov	 esi, esp
  003ed	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  003f0	50		 push	 eax
  003f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  003f7	3b f4		 cmp	 esi, esp
  003f9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 153  : 				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

  003fe	8b f4		 mov	 esi, esp
  00400	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  00403	50		 push	 eax
  00404	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  00407	51		 push	 ecx
  00408	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  0040e	3b f4		 cmp	 esi, esp
  00410	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 154  : 
; 155  : 				return Status::Success;

  00415	33 c0		 xor	 eax, eax
  00417	e9 52 01 00 00	 jmp	 $LN1@init
$LN7@init:

; 156  : #endif
; 157  : 			}
; 158  : 			else if (_renderType == RenderType::D3D10)
; 159  : 			{
; 160  : #if KIERO_INCLUDE_D3D10
; 161  : 				HMODULE libDXGI;
; 162  : 				HMODULE libD3D10;
; 163  : 				if ((libDXGI = ::GetModuleHandle(KIERO_TEXT("dxgi.dll"))) == NULL || (libD3D10 = ::GetModuleHandle(KIERO_TEXT("d3d10.dll"))) == NULL)
; 164  : 				{
; 165  : 					::DestroyWindow(window);
; 166  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 167  : 					return Status::ModuleNotFoundError;
; 168  : 				}
; 169  : 
; 170  : 				void* CreateDXGIFactory;
; 171  : 				if ((CreateDXGIFactory = ::GetProcAddress(libDXGI, "CreateDXGIFactory")) == NULL)
; 172  : 				{
; 173  : 					::DestroyWindow(window);
; 174  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 175  : 					return Status::UnknownError;
; 176  : 				}
; 177  : 
; 178  : 				IDXGIFactory* factory;
; 179  : 				if (((long(__stdcall*)(const IID&, void**))(CreateDXGIFactory))(__uuidof(IDXGIFactory), (void**)&factory) < 0)
; 180  : 				{
; 181  : 					::DestroyWindow(window);
; 182  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 183  : 					return Status::UnknownError;
; 184  : 				}
; 185  : 
; 186  : 				IDXGIAdapter* adapter;
; 187  : 				if (factory->EnumAdapters(0, &adapter) == DXGI_ERROR_NOT_FOUND)
; 188  : 				{
; 189  : 					::DestroyWindow(window);
; 190  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 191  : 					return Status::UnknownError;
; 192  : 				}
; 193  : 
; 194  : 				void* D3D10CreateDeviceAndSwapChain;
; 195  : 				if ((D3D10CreateDeviceAndSwapChain = ::GetProcAddress(libD3D10, "D3D10CreateDeviceAndSwapChain")) == NULL)
; 196  : 				{
; 197  : 					::DestroyWindow(window);
; 198  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 199  : 					return Status::UnknownError;
; 200  : 				}
; 201  : 
; 202  : 				DXGI_RATIONAL refreshRate;
; 203  : 				refreshRate.Numerator = 60;
; 204  : 				refreshRate.Denominator = 1;
; 205  : 
; 206  : 				DXGI_MODE_DESC bufferDesc;
; 207  : 				bufferDesc.Width = 100;
; 208  : 				bufferDesc.Height = 100;
; 209  : 				bufferDesc.RefreshRate = refreshRate;
; 210  : 				bufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 211  : 				bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
; 212  : 				bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
; 213  : 
; 214  : 				DXGI_SAMPLE_DESC sampleDesc;
; 215  : 				sampleDesc.Count = 1;
; 216  : 				sampleDesc.Quality = 0;
; 217  : 
; 218  : 				DXGI_SWAP_CHAIN_DESC swapChainDesc;
; 219  : 				swapChainDesc.BufferDesc = bufferDesc;
; 220  : 				swapChainDesc.SampleDesc = sampleDesc;
; 221  : 				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
; 222  : 				swapChainDesc.BufferCount = 1;
; 223  : 				swapChainDesc.OutputWindow = window;
; 224  : 				swapChainDesc.Windowed = 1;
; 225  : 				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
; 226  : 				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 227  : 
; 228  : 				IDXGISwapChain* swapChain;
; 229  : 				ID3D10Device* device;
; 230  : 
; 231  : 				if (((long(__stdcall*)(
; 232  : 					IDXGIAdapter*,
; 233  : 					D3D10_DRIVER_TYPE,
; 234  : 					HMODULE,
; 235  : 					UINT,
; 236  : 					UINT,
; 237  : 					DXGI_SWAP_CHAIN_DESC*,
; 238  : 					IDXGISwapChain**,
; 239  : 					ID3D10Device**))(D3D10CreateDeviceAndSwapChain))(adapter, D3D10_DRIVER_TYPE_HARDWARE, NULL, 0, D3D10_SDK_VERSION, &swapChainDesc, &swapChain, &device) < 0)
; 240  : 				{
; 241  : 					::DestroyWindow(window);
; 242  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 243  : 					return Status::UnknownError;
; 244  : 				}
; 245  : 
; 246  : 				g_methodsTable = (uint150_t*)::calloc(116, sizeof(uint150_t));
; 247  : 				::memcpy(g_methodsTable, *(uint150_t**)swapChain, 18 * sizeof(uint150_t));
; 248  : 				::memcpy(g_methodsTable + 18, *(uint150_t**)device, 98 * sizeof(uint150_t));
; 249  : 
; 250  : #if KIERO_USE_MINHOOK
; 251  : 				MH_Initialize();
; 252  : #endif
; 253  : 
; 254  : 				swapChain->Release();
; 255  : 				swapChain = NULL;
; 256  : 
; 257  : 				device->Release();
; 258  : 				device = NULL;
; 259  : 
; 260  : 				::DestroyWindow(window);
; 261  : 				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 262  : 
; 263  : 				g_renderType = RenderType::D3D10;
; 264  : 
; 265  : 				return Status::Success;
; 266  : #endif
; 267  : 			}
; 268  : 			else if (_renderType == RenderType::D3D11)
; 269  : 			{
; 270  : #if KIERO_INCLUDE_D3D11
; 271  : 				HMODULE libD3D11;
; 272  : 				if ((libD3D11 = ::GetModuleHandle(KIERO_TEXT("d3d11.dll"))) == NULL)
; 273  : 				{
; 274  : 					::DestroyWindow(window);
; 275  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 276  : 					return Status::ModuleNotFoundError;
; 277  : 				}
; 278  : 
; 279  : 				void* D3D11CreateDeviceAndSwapChain;
; 280  : 				if ((D3D11CreateDeviceAndSwapChain = ::GetProcAddress(libD3D11, "D3D11CreateDeviceAndSwapChain")) == NULL)
; 281  : 				{
; 282  : 					::DestroyWindow(window);
; 283  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 284  : 					return Status::UnknownError;
; 285  : 				}
; 286  : 
; 287  : 				D3D_FEATURE_LEVEL featureLevel;
; 288  : 				const D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };
; 289  : 
; 290  : 				DXGI_RATIONAL refreshRate;
; 291  : 				refreshRate.Numerator = 60;
; 292  : 				refreshRate.Denominator = 1;
; 293  : 
; 294  : 				DXGI_MODE_DESC bufferDesc;
; 295  : 				bufferDesc.Width = 100;
; 296  : 				bufferDesc.Height = 100;
; 297  : 				bufferDesc.RefreshRate = refreshRate;
; 298  : 				bufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 299  : 				bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
; 300  : 				bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
; 301  : 
; 302  : 				DXGI_SAMPLE_DESC sampleDesc;
; 303  : 				sampleDesc.Count = 1;
; 304  : 				sampleDesc.Quality = 0;
; 305  : 
; 306  : 				DXGI_SWAP_CHAIN_DESC swapChainDesc;
; 307  : 				swapChainDesc.BufferDesc = bufferDesc;
; 308  : 				swapChainDesc.SampleDesc = sampleDesc;
; 309  : 				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
; 310  : 				swapChainDesc.BufferCount = 1;
; 311  : 				swapChainDesc.OutputWindow = window;
; 312  : 				swapChainDesc.Windowed = 1;
; 313  : 				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
; 314  : 				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 315  : 
; 316  : 				IDXGISwapChain* swapChain;
; 317  : 				ID3D11Device* device;
; 318  : 				ID3D11DeviceContext* context;
; 319  : 
; 320  : 				if (((long(__stdcall*)(
; 321  : 					IDXGIAdapter*,
; 322  : 					D3D_DRIVER_TYPE,
; 323  : 					HMODULE,
; 324  : 					UINT,
; 325  : 					const D3D_FEATURE_LEVEL*,
; 326  : 					UINT,
; 327  : 					UINT,
; 328  : 					const DXGI_SWAP_CHAIN_DESC*,
; 329  : 					IDXGISwapChain**,
; 330  : 					ID3D11Device**,
; 331  : 					D3D_FEATURE_LEVEL*,
; 332  : 					ID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, featureLevels, 1, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)
; 333  : 				{
; 334  : 					::DestroyWindow(window);
; 335  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 336  : 					return Status::UnknownError;
; 337  : 				}
; 338  : 
; 339  : 				g_methodsTable = (uint150_t*)::calloc(205, sizeof(uint150_t));
; 340  : 				::memcpy(g_methodsTable, *(uint150_t**)swapChain, 18 * sizeof(uint150_t));
; 341  : 				::memcpy(g_methodsTable + 18, *(uint150_t**)device, 43 * sizeof(uint150_t));
; 342  : 				::memcpy(g_methodsTable + 18 + 43, *(uint150_t**)context, 144 * sizeof(uint150_t));
; 343  : 
; 344  : #if KIERO_USE_MINHOOK
; 345  : 				MH_Initialize();
; 346  : #endif
; 347  : 
; 348  : 				swapChain->Release();
; 349  : 				swapChain = NULL;
; 350  : 
; 351  : 				device->Release();
; 352  : 				device = NULL;
; 353  : 
; 354  : 				context->Release();
; 355  : 				context = NULL;
; 356  : 
; 357  : 				::DestroyWindow(window);
; 358  : 				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 359  : 
; 360  : 				g_renderType = RenderType::D3D11;
; 361  : 
; 362  : 				return Status::Success;
; 363  : #endif
; 364  : 			}
; 365  : 			else if (_renderType == RenderType::D3D12)
; 366  : 			{
; 367  : #if KIERO_INCLUDE_D3D12
; 368  : 				HMODULE libDXGI;
; 369  : 				HMODULE libD3D12;
; 370  : 				if ((libDXGI = ::GetModuleHandle(KIERO_TEXT("dxgi.dll"))) == NULL || (libD3D12 = ::GetModuleHandle(KIERO_TEXT("d3d12.dll"))) == NULL)
; 371  : 				{
; 372  : 					::DestroyWindow(window);
; 373  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 374  : 					return Status::ModuleNotFoundError;
; 375  : 				}
; 376  : 
; 377  : 				void* CreateDXGIFactory;
; 378  : 				if ((CreateDXGIFactory = ::GetProcAddress(libDXGI, "CreateDXGIFactory")) == NULL)
; 379  : 				{
; 380  : 					::DestroyWindow(window);
; 381  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 382  : 					return Status::UnknownError;
; 383  : 				}
; 384  : 
; 385  : 				IDXGIFactory* factory;
; 386  : 				if (((long(__stdcall*)(const IID&, void**))(CreateDXGIFactory))(__uuidof(IDXGIFactory), (void**)&factory) < 0)
; 387  : 				{
; 388  : 					::DestroyWindow(window);
; 389  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 390  : 					return Status::UnknownError;
; 391  : 				}
; 392  : 
; 393  : 				IDXGIAdapter* adapter;
; 394  : 				if (factory->EnumAdapters(0, &adapter) == DXGI_ERROR_NOT_FOUND)
; 395  : 				{
; 396  : 					::DestroyWindow(window);
; 397  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 398  : 					return Status::UnknownError;
; 399  : 				}
; 400  : 
; 401  : 				void* D3D12CreateDevice;
; 402  : 				if ((D3D12CreateDevice = ::GetProcAddress(libD3D12, "D3D12CreateDevice")) == NULL)
; 403  : 				{
; 404  : 					::DestroyWindow(window);
; 405  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 406  : 					return Status::UnknownError;
; 407  : 				}
; 408  : 
; 409  : 				ID3D12Device* device;
; 410  : 				if (((long(__stdcall*)(IUnknown*, D3D_FEATURE_LEVEL, const IID&, void**))(D3D12CreateDevice))(adapter, D3D_FEATURE_LEVEL_11_0, __uuidof(ID3D12Device), (void**)&device) < 0)
; 411  : 				{
; 412  : 					::DestroyWindow(window);
; 413  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 414  : 					return Status::UnknownError;
; 415  : 				}
; 416  : 
; 417  : 				D3D12_COMMAND_QUEUE_DESC queueDesc;
; 418  : 				queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
; 419  : 				queueDesc.Priority = 0;
; 420  : 				queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
; 421  : 				queueDesc.NodeMask = 0;
; 422  : 
; 423  : 				ID3D12CommandQueue* commandQueue;
; 424  : 				if (device->CreateCommandQueue(&queueDesc, __uuidof(ID3D12CommandQueue), (void**)&commandQueue) < 0)
; 425  : 				{
; 426  : 					::DestroyWindow(window);
; 427  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 428  : 					return Status::UnknownError;
; 429  : 				}
; 430  : 
; 431  : 				ID3D12CommandAllocator* commandAllocator;
; 432  : 				if (device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, __uuidof(ID3D12CommandAllocator), (void**)&commandAllocator) < 0)
; 433  : 				{
; 434  : 					::DestroyWindow(window);
; 435  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 436  : 					return Status::UnknownError;
; 437  : 				}
; 438  : 
; 439  : 				ID3D12GraphicsCommandList* commandList;
; 440  : 				if (device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, NULL, __uuidof(ID3D12GraphicsCommandList), (void**)&commandList) < 0)
; 441  : 				{
; 442  : 					::DestroyWindow(window);
; 443  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 444  : 					return Status::UnknownError;
; 445  : 				}
; 446  : 
; 447  : 				DXGI_RATIONAL refreshRate;
; 448  : 				refreshRate.Numerator = 60;
; 449  : 				refreshRate.Denominator = 1;
; 450  : 
; 451  : 				DXGI_MODE_DESC bufferDesc;
; 452  : 				bufferDesc.Width = 100;
; 453  : 				bufferDesc.Height = 100;
; 454  : 				bufferDesc.RefreshRate = refreshRate;
; 455  : 				bufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 456  : 				bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
; 457  : 				bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
; 458  : 
; 459  : 				DXGI_SAMPLE_DESC sampleDesc;
; 460  : 				sampleDesc.Count = 1;
; 461  : 				sampleDesc.Quality = 0;
; 462  : 
; 463  : 				DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
; 464  : 				swapChainDesc.BufferDesc = bufferDesc;
; 465  : 				swapChainDesc.SampleDesc = sampleDesc;
; 466  : 				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
; 467  : 				swapChainDesc.BufferCount = 2;
; 468  : 				swapChainDesc.OutputWindow = window;
; 469  : 				swapChainDesc.Windowed = 1;
; 470  : 				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
; 471  : 				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 472  : 
; 473  : 				IDXGISwapChain* swapChain;
; 474  : 				if (factory->CreateSwapChain(commandQueue, &swapChainDesc, &swapChain) < 0)
; 475  : 				{
; 476  : 					::DestroyWindow(window);
; 477  : 					::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 478  : 					return Status::UnknownError;
; 479  : 				}
; 480  : 
; 481  : 				g_methodsTable = (uint150_t*)::calloc(150, sizeof(uint150_t));
; 482  : 				::memcpy(g_methodsTable, *(uint150_t**)device, 44 * sizeof(uint150_t));
; 483  : 				::memcpy(g_methodsTable + 44, *(uint150_t**)commandQueue, 19 * sizeof(uint150_t));
; 484  : 				::memcpy(g_methodsTable + 44 + 19, *(uint150_t**)commandAllocator, 9 * sizeof(uint150_t));
; 485  : 				::memcpy(g_methodsTable + 44 + 19 + 9, *(uint150_t**)commandList, 60 * sizeof(uint150_t));
; 486  : 				::memcpy(g_methodsTable + 44 + 19 + 9 + 60, *(uint150_t**)swapChain, 18 * sizeof(uint150_t));
; 487  : 
; 488  : #if KIERO_USE_MINHOOK
; 489  : 				MH_Initialize();
; 490  : #endif
; 491  : 
; 492  : 				device->Release();
; 493  : 				device = NULL;
; 494  : 
; 495  : 				commandQueue->Release();
; 496  : 				commandQueue = NULL;
; 497  : 
; 498  : 				commandAllocator->Release();
; 499  : 				commandAllocator = NULL;
; 500  : 
; 501  : 				commandList->Release();
; 502  : 				commandList = NULL;
; 503  : 
; 504  : 				swapChain->Release();
; 505  : 				swapChain = NULL;
; 506  : 
; 507  : 				::DestroyWindow(window);
; 508  : 				::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);
; 509  : 
; 510  : 				g_renderType = RenderType::D3D12;
; 511  : 
; 512  : 				return Status::Success;
; 513  : #endif
; 514  : 			}
; 515  : 
; 516  : 			::DestroyWindow(window);

  0041c	8b f4		 mov	 esi, esp
  0041e	8b 45 bc	 mov	 eax, DWORD PTR _window$8[ebp]
  00421	50		 push	 eax
  00422	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00428	3b f4		 cmp	 esi, esp
  0042a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 517  : 			::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);

  0042f	8b f4		 mov	 esi, esp
  00431	8b 45 dc	 mov	 eax, DWORD PTR _windowClass$9[ebp+20]
  00434	50		 push	 eax
  00435	8b 4d f0	 mov	 ecx, DWORD PTR _windowClass$9[ebp+40]
  00438	51		 push	 ecx
  00439	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  0043f	3b f4		 cmp	 esi, esp
  00441	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 518  : 
; 519  : 			return Status::NotSupportedError;

  00446	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0044b	e9 1e 01 00 00	 jmp	 $LN1@init

; 520  : 		}

  00450	e9 17 01 00 00	 jmp	 $LN3@init
$LN4@init:

; 521  : 		else if (_renderType == RenderType::OpenGL)

  00455	83 7d 08 05	 cmp	 DWORD PTR __renderType$[ebp], 5
  00459	75 05		 jne	 SHORT $LN18@init

; 522  : 		{
; 523  : #if KIERO_INCLUDE_OPENGL
; 524  : 			HMODULE libOpenGL32;
; 525  : 			if ((libOpenGL32 = ::GetModuleHandle(KIERO_TEXT("opengl32.dll"))) == NULL)
; 526  : 			{
; 527  : 				return Status::ModuleNotFoundError;
; 528  : 			}
; 529  : 
; 530  : 			const char* const methodsNames[] = {
; 531  : 				"glAccum", "glAlphaFunc", "glAreTexturesResident", "glArrayElement", "glBegin", "glBindTexture", "glBitmap", "glBlendFunc", "glCallList", "glCallLists", "glClear", "glClearAccum",
; 532  : 				"glClearColor", "glClearDepth", "glClearIndex", "glClearStencil", "glClipPlane", "glColor3b", "glColor3bv", "glColor3d", "glColor3dv", "glColor3f", "glColor3fv", "glColor3i", "glColor3iv",
; 533  : 				"glColor3s", "glColor3sv", "glColor3ub", "glColor3ubv", "glColor3ui", "glColor3uiv", "glColor3us", "glColor3usv", "glColor4b", "glColor4bv", "glColor4d", "glColor4dv", "glColor4f",
; 534  : 				"glColor4fv", "glColor4i", "glColor4iv", "glColor4s", "glColor4sv", "glColor4ub", "glColor4ubv", "glColor4ui", "glColor4uiv", "glColor4us", "glColor4usv", "glColorMask", "glColorMaterial",
; 535  : 				"glColorPointer", "glCopyPixels", "glCopyTexImage1D", "glCopyTexImage2D", "glCopyTexSubImage1D", "glCopyTexSubImage2D", "glCullFaceglCullFace", "glDeleteLists", "glDeleteTextures",
; 536  : 				"glDepthFunc", "glDepthMask", "glDepthRange", "glDisable", "glDisableClientState", "glDrawArrays", "glDrawBuffer", "glDrawElements", "glDrawPixels", "glEdgeFlag", "glEdgeFlagPointer",
; 537  : 				"glEdgeFlagv", "glEnable", "glEnableClientState", "glEnd", "glEndList", "glEvalCoord1d", "glEvalCoord1dv", "glEvalCoord1f", "glEvalCoord1fv", "glEvalCoord2d", "glEvalCoord2dv",
; 538  : 				"glEvalCoord2f", "glEvalCoord2fv", "glEvalMesh1", "glEvalMesh2", "glEvalPoint1", "glEvalPoint2", "glFeedbackBuffer", "glFinish", "glFlush", "glFogf", "glFogfv", "glFogi", "glFogiv",
; 539  : 				"glFrontFace", "glFrustum", "glGenLists", "glGenTextures", "glGetBooleanv", "glGetClipPlane", "glGetDoublev", "glGetError", "glGetFloatv", "glGetIntegerv", "glGetLightfv", "glGetLightiv",
; 540  : 				"glGetMapdv", "glGetMapfv", "glGetMapiv", "glGetMaterialfv", "glGetMaterialiv", "glGetPixelMapfv", "glGetPixelMapuiv", "glGetPixelMapusv", "glGetPointerv", "glGetPolygonStipple",
; 541  : 				"glGetString", "glGetTexEnvfv", "glGetTexEnviv", "glGetTexGendv", "glGetTexGenfv", "glGetTexGeniv", "glGetTexImage", "glGetTexLevelParameterfv", "glGetTexLevelParameteriv",
; 542  : 				"glGetTexParameterfv", "glGetTexParameteriv", "glHint", "glIndexMask", "glIndexPointer", "glIndexd", "glIndexdv", "glIndexf", "glIndexfv", "glIndexi", "glIndexiv", "glIndexs", "glIndexsv",
; 543  : 				"glIndexub", "glIndexubv", "glInitNames", "glInterleavedArrays", "glIsEnabled", "glIsList", "glIsTexture", "glLightModelf", "glLightModelfv", "glLightModeli", "glLightModeliv", "glLightf",
; 544  : 				"glLightfv", "glLighti", "glLightiv", "glLineStipple", "glLineWidth", "glListBase", "glLoadIdentity", "glLoadMatrixd", "glLoadMatrixf", "glLoadName", "glLogicOp", "glMap1d", "glMap1f",
; 545  : 				"glMap2d", "glMap2f", "glMapGrid1d", "glMapGrid1f", "glMapGrid2d", "glMapGrid2f", "glMaterialf", "glMaterialfv", "glMateriali", "glMaterialiv", "glMatrixMode", "glMultMatrixd",
; 546  : 				"glMultMatrixf", "glNewList", "glNormal3b", "glNormal3bv", "glNormal3d", "glNormal3dv", "glNormal3f", "glNormal3fv", "glNormal3i", "glNormal3iv", "glNormal3s", "glNormal3sv",
; 547  : 				"glNormalPointer", "glOrtho", "glPassThrough", "glPixelMapfv", "glPixelMapuiv", "glPixelMapusv", "glPixelStoref", "glPixelStorei", "glPixelTransferf", "glPixelTransferi", "glPixelZoom",
; 548  : 				"glPointSize", "glPolygonMode", "glPolygonOffset", "glPolygonStipple", "glPopAttrib", "glPopClientAttrib", "glPopMatrix", "glPopName", "glPrioritizeTextures", "glPushAttrib",
; 549  : 				"glPushClientAttrib", "glPushMatrix", "glPushName", "glRasterPos2d", "glRasterPos2dv", "glRasterPos2f", "glRasterPos2fv", "glRasterPos2i", "glRasterPos2iv", "glRasterPos2s",
; 550  : 				"glRasterPos2sv", "glRasterPos3d", "glRasterPos3dv", "glRasterPos3f", "glRasterPos3fv", "glRasterPos3i", "glRasterPos3iv", "glRasterPos3s", "glRasterPos3sv", "glRasterPos4d",
; 551  : 				"glRasterPos4dv", "glRasterPos4f", "glRasterPos4fv", "glRasterPos4i", "glRasterPos4iv", "glRasterPos4s", "glRasterPos4sv", "glReadBuffer", "glReadPixels", "glRectd", "glRectdv", "glRectf",
; 552  : 				"glRectfv", "glRecti", "glRectiv", "glRects", "glRectsv", "glRenderMode", "glRotated", "glRotatef", "glScaled", "glScalef", "glScissor", "glSelectBuffer", "glShadeModel", "glStencilFunc",
; 553  : 				"glStencilMask", "glStencilOp", "glTexCoord1d", "glTexCoord1dv", "glTexCoord1f", "glTexCoord1fv", "glTexCoord1i", "glTexCoord1iv", "glTexCoord1s", "glTexCoord1sv", "glTexCoord2d",
; 554  : 				"glTexCoord2dv", "glTexCoord2f", "glTexCoord2fv", "glTexCoord2i", "glTexCoord2iv", "glTexCoord2s", "glTexCoord2sv", "glTexCoord3d", "glTexCoord3dv", "glTexCoord3f", "glTexCoord3fv",
; 555  : 				"glTexCoord3i", "glTexCoord3iv", "glTexCoord3s", "glTexCoord3sv", "glTexCoord4d", "glTexCoord4dv", "glTexCoord4f", "glTexCoord4fv", "glTexCoord4i", "glTexCoord4iv", "glTexCoord4s",
; 556  : 				"glTexCoord4sv", "glTexCoordPointer", "glTexEnvf", "glTexEnvfv", "glTexEnvi", "glTexEnviv", "glTexGend", "glTexGendv", "glTexGenf", "glTexGenfv", "glTexGeni", "glTexGeniv", "glTexImage1D",
; 557  : 				"glTexImage2D", "glTexParameterf", "glTexParameterfv", "glTexParameteri", "glTexParameteriv", "glTexSubImage1D", "glTexSubImage2D", "glTranslated", "glTranslatef", "glVertex2d",
; 558  : 				"glVertex2dv", "glVertex2f", "glVertex2fv", "glVertex2i", "glVertex2iv", "glVertex2s", "glVertex2sv", "glVertex3d", "glVertex3dv", "glVertex3f", "glVertex3fv", "glVertex3i", "glVertex3iv",
; 559  : 				"glVertex3s", "glVertex3sv", "glVertex4d", "glVertex4dv", "glVertex4f", "glVertex4fv", "glVertex4i", "glVertex4iv", "glVertex4s", "glVertex4sv", "glVertexPointer", "glViewport"
; 560  : 			};
; 561  : 
; 562  : 			size_t size = KIERO_ARRAY_SIZE(methodsNames);
; 563  : 
; 564  : 			g_methodsTable = (uint150_t*)::calloc(size, sizeof(uint150_t));
; 565  : 
; 566  : 			for (int i = 0; i < size; i++)
; 567  : 			{
; 568  : 				g_methodsTable[i] = (uint150_t)::GetProcAddress(libOpenGL32, methodsNames[i]);
; 569  : 			}
; 570  : 
; 571  : #if KIERO_USE_MINHOOK
; 572  : 			MH_Initialize();
; 573  : #endif
; 574  : 
; 575  : 			g_renderType = RenderType::OpenGL;
; 576  : 
; 577  : 			return Status::Success;
; 578  : #endif
; 579  : 		}

  0045b	e9 0c 01 00 00	 jmp	 $LN3@init
$LN18@init:

; 580  : 		else if (_renderType == RenderType::Vulkan)

  00460	83 7d 08 06	 cmp	 DWORD PTR __renderType$[ebp], 6
  00464	75 05		 jne	 SHORT $LN20@init

; 581  : 		{
; 582  : #if KIERO_INCLUDE_VULKAN
; 583  : 			HMODULE libVulkan;
; 584  : 			if ((libVulkan = GetModuleHandle(KIERO_TEXT("vulcan-1.dll"))) == NULL)
; 585  : 			{
; 586  : 				return Status::ModuleNotFoundError;
; 587  : 			}
; 588  : 
; 589  : 			const char* const methodsNames[] = {
; 590  : 				"vkCreateInstance", "vkDestroyInstance", "vkEnumeratePhysicalDevices", "vkGetPhysicalDeviceFeatures", "vkGetPhysicalDeviceFormatProperties", "vkGetPhysicalDeviceImageFormatProperties",
; 591  : 				"vkGetPhysicalDeviceProperties", "vkGetPhysicalDeviceQueueFamilyProperties", "vkGetPhysicalDeviceMemoryProperties", "vkGetInstanceProcAddr", "vkGetDeviceProcAddr", "vkCreateDevice",
; 592  : 				"vkDestroyDevice", "vkEnumerateInstanceExtensionProperties", "vkEnumerateDeviceExtensionProperties", "vkEnumerateDeviceLayerProperties", "vkGetDeviceQueue", "vkQueueSubmit", "vkQueueWaitIdle",
; 593  : 				"vkDeviceWaitIdle", "vkAllocateMemory", "vkFreeMemory", "vkMapMemory", "vkUnmapMemory", "vkFlushMappedMemoryRanges", "vkInvalidateMappedMemoryRanges", "vkGetDeviceMemoryCommitment",
; 594  : 				"vkBindBufferMemory", "vkBindImageMemory", "vkGetBufferMemoryRequirements", "vkGetImageMemoryRequirements", "vkGetImageSparseMemoryRequirements", "vkGetPhysicalDeviceSparseImageFormatProperties",
; 595  : 				"vkQueueBindSparse", "vkCreateFence", "vkDestroyFence", "vkResetFences", "vkGetFenceStatus", "vkWaitForFences", "vkCreateSemaphore", "vkDestroySemaphore", "vkCreateEvent", "vkDestroyEvent",
; 596  : 				"vkGetEventStatus", "vkSetEvent", "vkResetEvent", "vkCreateQueryPool", "vkDestroyQueryPool", "vkGetQueryPoolResults", "vkCreateBuffer", "vkDestroyBuffer", "vkCreateBufferView", "vkDestroyBufferView",
; 597  : 				"vkCreateImage", "vkDestroyImage", "vkGetImageSubresourceLayout", "vkCreateImageView", "vkDestroyImageView", "vkCreateShaderModule", "vkDestroyShaderModule", "vkCreatePipelineCache",
; 598  : 				"vkDestroyPipelineCache", "vkGetPipelineCacheData", "vkMergePipelineCaches", "vkCreateGraphicsPipelines", "vkCreateComputePipelines", "vkDestroyPipeline", "vkCreatePipelineLayout",
; 599  : 				"vkDestroyPipelineLayout", "vkCreateSampler", "vkDestroySampler", "vkCreateDescriptorSetLayout", "vkDestroyDescriptorSetLayout", "vkCreateDescriptorPool", "vkDestroyDescriptorPool",
; 600  : 				"vkResetDescriptorPool", "vkAllocateDescriptorSets", "vkFreeDescriptorSets", "vkUpdateDescriptorSets", "vkCreateFramebuffer", "vkDestroyFramebuffer", "vkCreateRenderPass", "vkDestroyRenderPass",
; 601  : 				"vkGetRenderAreaGranularity", "vkCreateCommandPool", "vkDestroyCommandPool", "vkResetCommandPool", "vkAllocateCommandBuffers", "vkFreeCommandBuffers", "vkBeginCommandBuffer", "vkEndCommandBuffer",
; 602  : 				"vkResetCommandBuffer", "vkCmdBindPipeline", "vkCmdSetViewport", "vkCmdSetScissor", "vkCmdSetLineWidth", "vkCmdSetDepthBias", "vkCmdSetBlendConstants", "vkCmdSetDepthBounds",
; 603  : 				"vkCmdSetStencilCompareMask", "vkCmdSetStencilWriteMask", "vkCmdSetStencilReference", "vkCmdBindDescriptorSets", "vkCmdBindIndexBuffer", "vkCmdBindVertexBuffers", "vkCmdDraw", "vkCmdDrawIndexed",
; 604  : 				"vkCmdDrawIndirect", "vkCmdDrawIndexedIndirect", "vkCmdDispatch", "vkCmdDispatchIndirect", "vkCmdCopyBuffer", "vkCmdCopyImage", "vkCmdBlitImage", "vkCmdCopyBufferToImage", "vkCmdCopyImageToBuffer",
; 605  : 				"vkCmdUpdateBuffer", "vkCmdFillBuffer", "vkCmdClearColorImage", "vkCmdClearDepthStencilImage", "vkCmdClearAttachments", "vkCmdResolveImage", "vkCmdSetEvent", "vkCmdResetEvent", "vkCmdWaitEvents",
; 606  : 				"vkCmdPipelineBarrier", "vkCmdBeginQuery", "vkCmdEndQuery", "vkCmdResetQueryPool", "vkCmdWriteTimestamp", "vkCmdCopyQueryPoolResults", "vkCmdPushConstants", "vkCmdBeginRenderPass", "vkCmdNextSubpass",
; 607  : 				"vkCmdEndRenderPass", "vkCmdExecuteCommands"
; 608  : 			};
; 609  : 
; 610  : 			size_t size = KIERO_ARRAY_SIZE(methodsNames);
; 611  : 
; 612  : 			g_methodsTable = (uint150_t*)::calloc(size, sizeof(uint150_t));
; 613  : 
; 614  : 			for (int i = 0; i < size; i++)
; 615  : 			{
; 616  : 				g_methodsTable[i] = (uint150_t)::GetProcAddress(libVulkan, methodsNames[i]);
; 617  : 			}
; 618  : 
; 619  : #if KIERO_USE_MINHOOK
; 620  : 			MH_Initialize();
; 621  : #endif
; 622  : 
; 623  : 			g_renderType = RenderType::Vulkan;
; 624  : 
; 625  : 			return Status::Success;
; 626  : #endif
; 627  : 		}

  00466	e9 01 01 00 00	 jmp	 $LN3@init
$LN20@init:

; 628  : 		else if (_renderType == RenderType::Auto)

  0046b	83 7d 08 07	 cmp	 DWORD PTR __renderType$[ebp], 7
  0046f	0f 85 f7 00 00
	00		 jne	 $LN3@init

; 629  : 		{
; 630  : 			RenderType::Enum type = RenderType::None;

  00475	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$1[ebp], 0

; 631  : 
; 632  : 			if (::GetModuleHandle(KIERO_TEXT("d3d9.dll")) != NULL)

  0047f	8b f4		 mov	 esi, esp
  00481	68 00 00 00 00	 push	 OFFSET ??_C@_08NIHLGCK@d3d9?4dll@
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0048c	3b f4		 cmp	 esi, esp
  0048e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00493	85 c0		 test	 eax, eax
  00495	74 0f		 je	 SHORT $LN23@init

; 633  : 			{
; 634  : 				type = RenderType::D3D9;

  00497	c7 85 28 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _type$1[ebp], 1

; 635  : 			}

  004a1	e9 b5 00 00 00	 jmp	 $LN24@init
$LN23@init:

; 636  : 			else if (::GetModuleHandle(KIERO_TEXT("d3d10.dll")) != NULL)

  004a6	8b f4		 mov	 esi, esp
  004a8	68 00 00 00 00	 push	 OFFSET ??_C@_09MPDKCPEA@d3d10?4dll@
  004ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  004b3	3b f4		 cmp	 esi, esp
  004b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004ba	85 c0		 test	 eax, eax
  004bc	74 0f		 je	 SHORT $LN25@init

; 637  : 			{
; 638  : 				type = RenderType::D3D10;

  004be	c7 85 28 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _type$1[ebp], 2

; 639  : 			}

  004c8	e9 8e 00 00 00	 jmp	 $LN24@init
$LN25@init:

; 640  : 			else if (::GetModuleHandle(KIERO_TEXT("d3d11.dll")) != NULL)

  004cd	8b f4		 mov	 esi, esp
  004cf	68 00 00 00 00	 push	 OFFSET ??_C@_09EGGPMOF@d3d11?4dll@
  004d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  004da	3b f4		 cmp	 esi, esp
  004dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004e1	85 c0		 test	 eax, eax
  004e3	74 0c		 je	 SHORT $LN27@init

; 641  : 			{
; 642  : 				type = RenderType::D3D11;

  004e5	c7 85 28 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _type$1[ebp], 3

; 643  : 			}

  004ef	eb 6a		 jmp	 SHORT $LN24@init
$LN27@init:

; 644  : 			else if (::GetModuleHandle(KIERO_TEXT("d3d12.dll")) != NULL)

  004f1	8b f4		 mov	 esi, esp
  004f3	68 00 00 00 00	 push	 OFFSET ??_C@_09ICPCIOEL@d3d12?4dll@
  004f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  004fe	3b f4		 cmp	 esi, esp
  00500	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00505	85 c0		 test	 eax, eax
  00507	74 0c		 je	 SHORT $LN29@init

; 645  : 			{
; 646  : 				type = RenderType::D3D12;

  00509	c7 85 28 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR _type$1[ebp], 4

; 647  : 			}

  00513	eb 46		 jmp	 SHORT $LN24@init
$LN29@init:

; 648  : 			else if (::GetModuleHandle(KIERO_TEXT("opengl32.dll")) != NULL)

  00515	8b f4		 mov	 esi, esp
  00517	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DOKAJOHF@opengl32?4dll@
  0051c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00522	3b f4		 cmp	 esi, esp
  00524	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00529	85 c0		 test	 eax, eax
  0052b	74 0c		 je	 SHORT $LN31@init

; 649  : 			{
; 650  : 				type = RenderType::OpenGL;

  0052d	c7 85 28 ff ff
	ff 05 00 00 00	 mov	 DWORD PTR _type$1[ebp], 5

; 651  : 			}

  00537	eb 22		 jmp	 SHORT $LN24@init
$LN31@init:

; 652  : 			else if (::GetModuleHandle(KIERO_TEXT("vulcan-1.dll")) != NULL)

  00539	8b f4		 mov	 esi, esp
  0053b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JLGIBLKI@vulcan?91?4dll@
  00540	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00546	3b f4		 cmp	 esi, esp
  00548	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0054d	85 c0		 test	 eax, eax
  0054f	74 0a		 je	 SHORT $LN24@init

; 653  : 			{
; 654  : 				type = RenderType::Vulkan;

  00551	c7 85 28 ff ff
	ff 06 00 00 00	 mov	 DWORD PTR _type$1[ebp], 6
$LN24@init:

; 655  : 			}
; 656  : 
; 657  : 			return init(type);

  0055b	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _type$1[ebp]
  00561	50		 push	 eax
  00562	e8 00 00 00 00	 call	 ?init@kiero@@YA?AW4Enum@Status@1@W42RenderType@1@@Z ; kiero::init
  00567	83 c4 04	 add	 esp, 4
  0056a	eb 02		 jmp	 SHORT $LN1@init
$LN3@init:

; 658  : 		}
; 659  : 	}
; 660  : 
; 661  : 	return Status::Success;

  0056c	33 c0		 xor	 eax, eax
$LN1@init:

; 662  : }

  0056e	52		 push	 edx
  0056f	8b cd		 mov	 ecx, ebp
  00571	50		 push	 eax
  00572	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN40@init
  00578	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0057d	58		 pop	 eax
  0057e	5a		 pop	 edx
  0057f	5f		 pop	 edi
  00580	5e		 pop	 esi
  00581	5b		 pop	 ebx
  00582	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00585	33 cd		 xor	 ecx, ebp
  00587	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058c	81 c4 9c 01 00
	00		 add	 esp, 412		; 0000019cH
  00592	3b ec		 cmp	 ebp, esp
  00594	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00599	8b e5		 mov	 esp, ebp
  0059b	5d		 pop	 ebp
  0059c	c3		 ret	 0
  0059d	0f 1f 00	 npad	 3
$LN40@init:
  005a0	04 00 00 00	 DD	 4
  005a4	00 00 00 00	 DD	 $LN39@init
$LN39@init:
  005a8	c8 ff ff ff	 DD	 -56			; ffffffc8H
  005ac	30 00 00 00	 DD	 48			; 00000030H
  005b0	00 00 00 00	 DD	 $LN35@init
  005b4	80 ff ff ff	 DD	 -128			; ffffff80H
  005b8	10 00 00 00	 DD	 16			; 00000010H
  005bc	00 00 00 00	 DD	 $LN36@init
  005c0	40 ff ff ff	 DD	 -192			; ffffff40H
  005c4	38 00 00 00	 DD	 56			; 00000038H
  005c8	00 00 00 00	 DD	 $LN37@init
  005cc	34 ff ff ff	 DD	 -204			; ffffff34H
  005d0	04 00 00 00	 DD	 4
  005d4	00 00 00 00	 DD	 $LN38@init
$LN38@init:
  005d8	64		 DB	 100			; 00000064H
  005d9	65		 DB	 101			; 00000065H
  005da	76		 DB	 118			; 00000076H
  005db	69		 DB	 105			; 00000069H
  005dc	63		 DB	 99			; 00000063H
  005dd	65		 DB	 101			; 00000065H
  005de	00		 DB	 0
$LN37@init:
  005df	70		 DB	 112			; 00000070H
  005e0	61		 DB	 97			; 00000061H
  005e1	72		 DB	 114			; 00000072H
  005e2	61		 DB	 97			; 00000061H
  005e3	6d		 DB	 109			; 0000006dH
  005e4	73		 DB	 115			; 00000073H
  005e5	00		 DB	 0
$LN36@init:
  005e6	64		 DB	 100			; 00000064H
  005e7	69		 DB	 105			; 00000069H
  005e8	73		 DB	 115			; 00000073H
  005e9	70		 DB	 112			; 00000070H
  005ea	6c		 DB	 108			; 0000006cH
  005eb	61		 DB	 97			; 00000061H
  005ec	79		 DB	 121			; 00000079H
  005ed	4d		 DB	 77			; 0000004dH
  005ee	6f		 DB	 111			; 0000006fH
  005ef	64		 DB	 100			; 00000064H
  005f0	65		 DB	 101			; 00000065H
  005f1	00		 DB	 0
$LN35@init:
  005f2	77		 DB	 119			; 00000077H
  005f3	69		 DB	 105			; 00000069H
  005f4	6e		 DB	 110			; 0000006eH
  005f5	64		 DB	 100			; 00000064H
  005f6	6f		 DB	 111			; 0000006fH
  005f7	77		 DB	 119			; 00000077H
  005f8	43		 DB	 67			; 00000043H
  005f9	6c		 DB	 108			; 0000006cH
  005fa	61		 DB	 97			; 00000061H
  005fb	73		 DB	 115			; 00000073H
  005fc	73		 DB	 115			; 00000073H
  005fd	00		 DB	 0
?init@kiero@@YA?AW4Enum@Status@1@W42RenderType@1@@Z ENDP ; kiero::init
_TEXT	ENDS
END
