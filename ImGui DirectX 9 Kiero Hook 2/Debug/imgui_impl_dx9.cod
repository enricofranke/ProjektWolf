; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__241EEA0C_corecrt_memory@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__42049807_imgui@h DB 01H
__F5601360_stdlib@h DB 01H
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__692346AF_guiddef@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__2908CC08_winuser@h DB 01H
__E6E7469F_winioctl@h DB 01H
__1E567087_propidl@h DB 01H
__9FABC30B_oleauto@h DB 01H
__08182E14_stralign@h DB 01H
__2B73F502_imgui_impl_dx9@cpp DB 01H
msvcjmc	ENDS
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?ImGui_ImplDX9_Init@@YA_NPAUIDirect3DDevice9@@@Z ; ImGui_ImplDX9_Init
PUBLIC	?ImGui_ImplDX9_Shutdown@@YAXXZ			; ImGui_ImplDX9_Shutdown
PUBLIC	?ImGui_ImplDX9_NewFrame@@YAXXZ			; ImGui_ImplDX9_NewFrame
PUBLIC	?ImGui_ImplDX9_RenderDrawData@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX9_RenderDrawData
PUBLIC	?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ	; ImGui_ImplDX9_CreateDeviceObjects
PUBLIC	?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXXZ	; ImGui_ImplDX9_InvalidateDeviceObjects
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_0P@PJLJBPPP@imgui_impl_dx9@		; `string'
PUBLIC	??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
EXTRN	_memcpy:PROC
EXTRN	__imp___wassert:PROC
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z:PROC ; ImFontAtlas::GetTexDataAsRGBA32
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__ftoui3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_pd3dDevice@@3PAUIDirect3DDevice9@@A DD 01H DUP (?)	; g_pd3dDevice
?g_pVB@@3PAUIDirect3DVertexBuffer9@@A DD 01H DUP (?)	; g_pVB
?g_pIB@@3PAUIDirect3DIndexBuffer9@@A DD 01H DUP (?)	; g_pIB
?g_FontTexture@@3PAUIDirect3DTexture9@@A DD 01H DUP (?)	; g_FontTexture
_BSS	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@ DB 'i', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PJLJBPPP@imgui_impl_dx9@
CONST	SEGMENT
??_C@_0P@PJLJBPPP@imgui_impl_dx9@ DB 'imgui_impl_dx9', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?g_VertexBufferSize@@3HA DD 01388H			; g_VertexBufferSize
?g_IndexBufferSize@@3HA DD 02710H			; g_IndexBufferSize
_DATA	ENDS
;	COMDAT ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ
_TEXT	SEGMENT
_y$1 = -88						; size = 4
_tex_locked_rect$ = -76					; size = 8
_bytes_per_pixel$ = -60					; size = 4
_height$ = -48						; size = 4
_width$ = -36						; size = 4
_pixels$ = -24						; size = 4
_io$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ PROC		; ImGui_ImplDX9_CreateFontsTexture, COMDAT

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-284]
  00012	b9 47 00 00 00	 mov	 ecx, 71			; 00000047H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 239  :     // Build texture atlas
; 240  :     ImGuiIO& io = ImGui::GetIO();

  00032	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  00037	89 45 f4	 mov	 DWORD PTR _io$[ebp], eax

; 241  :     unsigned char* pixels;
; 242  :     int width, height, bytes_per_pixel;
; 243  :     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);

  0003a	8d 45 c4	 lea	 eax, DWORD PTR _bytes_per_pixel$[ebp]
  0003d	50		 push	 eax
  0003e	8d 4d d0	 lea	 ecx, DWORD PTR _height$[ebp]
  00041	51		 push	 ecx
  00042	8d 55 dc	 lea	 edx, DWORD PTR _width$[ebp]
  00045	52		 push	 edx
  00046	8d 45 e8	 lea	 eax, DWORD PTR _pixels$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  0004d	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [ecx+144]
  00053	e8 00 00 00 00	 call	 ?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32

; 244  : 
; 245  :     // Upload texture to graphics system
; 246  :     g_FontTexture = NULL;

  00058	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A, 0

; 247  :     if (g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &g_FontTexture, NULL) < 0)

  00062	8b f4		 mov	 esi, esp
  00064	6a 00		 push	 0
  00066	68 00 00 00 00	 push	 OFFSET ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  0006b	6a 00		 push	 0
  0006d	6a 15		 push	 21			; 00000015H
  0006f	68 00 02 00 00	 push	 512			; 00000200H
  00074	6a 01		 push	 1
  00076	8b 45 d0	 mov	 eax, DWORD PTR _height$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d dc	 mov	 ecx, DWORD PTR _width$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0008c	51		 push	 ecx
  0008d	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  00090	ff d2		 call	 edx
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	85 c0		 test	 eax, eax
  0009b	7d 07		 jge	 SHORT $LN5@ImGui_Impl

; 248  :         return false;

  0009d	32 c0		 xor	 al, al
  0009f	e9 a6 00 00 00	 jmp	 $LN1@ImGui_Impl
$LN5@ImGui_Impl:

; 249  :     D3DLOCKED_RECT tex_locked_rect;
; 250  :     if (g_FontTexture->LockRect(0, &tex_locked_rect, NULL, 0) != D3D_OK)

  000a4	8b f4		 mov	 esi, esp
  000a6	6a 00		 push	 0
  000a8	6a 00		 push	 0
  000aa	8d 45 b4	 lea	 eax, DWORD PTR _tex_locked_rect$[ebp]
  000ad	50		 push	 eax
  000ae	6a 00		 push	 0
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  000bd	50		 push	 eax
  000be	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  000c1	ff d1		 call	 ecx
  000c3	3b f4		 cmp	 esi, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ca	85 c0		 test	 eax, eax
  000cc	74 04		 je	 SHORT $LN6@ImGui_Impl

; 251  :         return false;

  000ce	32 c0		 xor	 al, al
  000d0	eb 78		 jmp	 SHORT $LN1@ImGui_Impl
$LN6@ImGui_Impl:

; 252  :     for (int y = 0; y < height; y++)

  000d2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _y$1[ebp], 0
  000d9	eb 09		 jmp	 SHORT $LN4@ImGui_Impl
$LN2@ImGui_Impl:
  000db	8b 45 a8	 mov	 eax, DWORD PTR _y$1[ebp]
  000de	83 c0 01	 add	 eax, 1
  000e1	89 45 a8	 mov	 DWORD PTR _y$1[ebp], eax
$LN4@ImGui_Impl:
  000e4	8b 45 a8	 mov	 eax, DWORD PTR _y$1[ebp]
  000e7	3b 45 d0	 cmp	 eax, DWORD PTR _height$[ebp]
  000ea	7d 2c		 jge	 SHORT $LN3@ImGui_Impl

; 253  :         memcpy((unsigned char *)tex_locked_rect.pBits + tex_locked_rect.Pitch * y, pixels + (width * bytes_per_pixel) * y, (width * bytes_per_pixel));

  000ec	8b 45 dc	 mov	 eax, DWORD PTR _width$[ebp]
  000ef	0f af 45 c4	 imul	 eax, DWORD PTR _bytes_per_pixel$[ebp]
  000f3	50		 push	 eax
  000f4	8b 4d dc	 mov	 ecx, DWORD PTR _width$[ebp]
  000f7	0f af 4d c4	 imul	 ecx, DWORD PTR _bytes_per_pixel$[ebp]
  000fb	0f af 4d a8	 imul	 ecx, DWORD PTR _y$1[ebp]
  000ff	03 4d e8	 add	 ecx, DWORD PTR _pixels$[ebp]
  00102	51		 push	 ecx
  00103	8b 55 b4	 mov	 edx, DWORD PTR _tex_locked_rect$[ebp]
  00106	0f af 55 a8	 imul	 edx, DWORD PTR _y$1[ebp]
  0010a	03 55 b8	 add	 edx, DWORD PTR _tex_locked_rect$[ebp+4]
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 _memcpy
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH
  00116	eb c3		 jmp	 SHORT $LN2@ImGui_Impl
$LN3@ImGui_Impl:

; 254  :     g_FontTexture->UnlockRect(0);

  00118	8b f4		 mov	 esi, esp
  0011a	6a 00		 push	 0
  0011c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  00121	8b 08		 mov	 ecx, DWORD PTR [eax]
  00123	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  00129	52		 push	 edx
  0012a	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  0012d	ff d0		 call	 eax
  0012f	3b f4		 cmp	 esi, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 255  : 
; 256  :     // Store our identifier
; 257  :     io.Fonts->TexID = (ImTextureID)g_FontTexture;

  00136	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  00139	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0013f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  00145	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 258  : 
; 259  :     return true;

  00148	b0 01		 mov	 al, 1
$LN1@ImGui_Impl:

; 260  : }

  0014a	52		 push	 edx
  0014b	8b cd		 mov	 ecx, ebp
  0014d	50		 push	 eax
  0014e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@ImGui_Impl
  00154	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00159	58		 pop	 eax
  0015a	5a		 pop	 edx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00161	33 cd		 xor	 ecx, ebp
  00163	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00168	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  0016e	3b ec		 cmp	 ebp, esp
  00170	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
  00179	0f 1f 00	 npad	 3
$LN14@ImGui_Impl:
  0017c	05 00 00 00	 DD	 5
  00180	00 00 00 00	 DD	 $LN13@ImGui_Impl
$LN13@ImGui_Impl:
  00184	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00188	04 00 00 00	 DD	 4
  0018c	00 00 00 00	 DD	 $LN8@ImGui_Impl
  00190	dc ff ff ff	 DD	 -36			; ffffffdcH
  00194	04 00 00 00	 DD	 4
  00198	00 00 00 00	 DD	 $LN9@ImGui_Impl
  0019c	d0 ff ff ff	 DD	 -48			; ffffffd0H
  001a0	04 00 00 00	 DD	 4
  001a4	00 00 00 00	 DD	 $LN10@ImGui_Impl
  001a8	c4 ff ff ff	 DD	 -60			; ffffffc4H
  001ac	04 00 00 00	 DD	 4
  001b0	00 00 00 00	 DD	 $LN11@ImGui_Impl
  001b4	b4 ff ff ff	 DD	 -76			; ffffffb4H
  001b8	08 00 00 00	 DD	 8
  001bc	00 00 00 00	 DD	 $LN12@ImGui_Impl
$LN12@ImGui_Impl:
  001c0	74		 DB	 116			; 00000074H
  001c1	65		 DB	 101			; 00000065H
  001c2	78		 DB	 120			; 00000078H
  001c3	5f		 DB	 95			; 0000005fH
  001c4	6c		 DB	 108			; 0000006cH
  001c5	6f		 DB	 111			; 0000006fH
  001c6	63		 DB	 99			; 00000063H
  001c7	6b		 DB	 107			; 0000006bH
  001c8	65		 DB	 101			; 00000065H
  001c9	64		 DB	 100			; 00000064H
  001ca	5f		 DB	 95			; 0000005fH
  001cb	72		 DB	 114			; 00000072H
  001cc	65		 DB	 101			; 00000065H
  001cd	63		 DB	 99			; 00000063H
  001ce	74		 DB	 116			; 00000074H
  001cf	00		 DB	 0
$LN11@ImGui_Impl:
  001d0	62		 DB	 98			; 00000062H
  001d1	79		 DB	 121			; 00000079H
  001d2	74		 DB	 116			; 00000074H
  001d3	65		 DB	 101			; 00000065H
  001d4	73		 DB	 115			; 00000073H
  001d5	5f		 DB	 95			; 0000005fH
  001d6	70		 DB	 112			; 00000070H
  001d7	65		 DB	 101			; 00000065H
  001d8	72		 DB	 114			; 00000072H
  001d9	5f		 DB	 95			; 0000005fH
  001da	70		 DB	 112			; 00000070H
  001db	69		 DB	 105			; 00000069H
  001dc	78		 DB	 120			; 00000078H
  001dd	65		 DB	 101			; 00000065H
  001de	6c		 DB	 108			; 0000006cH
  001df	00		 DB	 0
$LN10@ImGui_Impl:
  001e0	68		 DB	 104			; 00000068H
  001e1	65		 DB	 101			; 00000065H
  001e2	69		 DB	 105			; 00000069H
  001e3	67		 DB	 103			; 00000067H
  001e4	68		 DB	 104			; 00000068H
  001e5	74		 DB	 116			; 00000074H
  001e6	00		 DB	 0
$LN9@ImGui_Impl:
  001e7	77		 DB	 119			; 00000077H
  001e8	69		 DB	 105			; 00000069H
  001e9	64		 DB	 100			; 00000064H
  001ea	74		 DB	 116			; 00000074H
  001eb	68		 DB	 104			; 00000068H
  001ec	00		 DB	 0
$LN8@ImGui_Impl:
  001ed	70		 DB	 112			; 00000070H
  001ee	69		 DB	 105			; 00000069H
  001ef	78		 DB	 120			; 00000078H
  001f0	65		 DB	 101			; 00000065H
  001f1	6c		 DB	 108			; 0000006cH
  001f2	73		 DB	 115			; 00000073H
  001f3	00		 DB	 0
?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ ENDP		; ImGui_ImplDX9_CreateFontsTexture
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_SetupRenderState@@YAXPAUImDrawData@@@Z
_TEXT	SEGMENT
_mat_projection$1 = -224				; size = 64
_mat_identity$2 = -152					; size = 64
_B$3 = -80						; size = 4
_T$4 = -68						; size = 4
_R$5 = -56						; size = 4
_L$6 = -44						; size = 4
_vp$ = -32						; size = 24
__$ArrayPad$ = -4					; size = 4
_draw_data$ = 8						; size = 4
?ImGui_ImplDX9_SetupRenderState@@YAXPAUImDrawData@@@Z PROC ; ImGui_ImplDX9_SetupRenderState, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 5c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-420]
  00012	b9 69 00 00 00	 mov	 ecx, 105		; 00000069H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 50   :     // Setup viewport
; 51   :     D3DVIEWPORT9 vp;
; 52   :     vp.X = vp.Y = 0;

  00032	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _vp$[ebp+4], 0
  00039	8b 45 e4	 mov	 eax, DWORD PTR _vp$[ebp+4]
  0003c	89 45 e0	 mov	 DWORD PTR _vp$[ebp], eax

; 53   :     vp.Width = (DWORD)draw_data->DisplaySize.x;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00042	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  00047	e8 00 00 00 00	 call	 __ftoui3
  0004c	89 45 e8	 mov	 DWORD PTR _vp$[ebp+8], eax

; 54   :     vp.Height = (DWORD)draw_data->DisplaySize.y;

  0004f	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00052	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  00057	e8 00 00 00 00	 call	 __ftoui3
  0005c	89 45 ec	 mov	 DWORD PTR _vp$[ebp+12], eax

; 55   :     vp.MinZ = 0.0f;

  0005f	0f 57 c0	 xorps	 xmm0, xmm0
  00062	f3 0f 11 45 f0	 movss	 DWORD PTR _vp$[ebp+16], xmm0

; 56   :     vp.MaxZ = 1.0f;

  00067	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0006f	f3 0f 11 45 f4	 movss	 DWORD PTR _vp$[ebp+20], xmm0

; 57   :     g_pd3dDevice->SetViewport(&vp);

  00074	8b f4		 mov	 esi, esp
  00076	8d 45 e0	 lea	 eax, DWORD PTR _vp$[ebp]
  00079	50		 push	 eax
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00080	8b 11		 mov	 edx, DWORD PTR [ecx]
  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00087	50		 push	 eax
  00088	8b 8a bc 00 00
	00		 mov	 ecx, DWORD PTR [edx+188]
  0008e	ff d1		 call	 ecx
  00090	3b f4		 cmp	 esi, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 58   : 
; 59   :     // Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing, shade mode (for gradient)
; 60   :     g_pd3dDevice->SetPixelShader(NULL);

  00097	8b f4		 mov	 esi, esp
  00099	6a 00		 push	 0
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000a8	52		 push	 edx
  000a9	8b 81 ac 01 00
	00		 mov	 eax, DWORD PTR [ecx+428]
  000af	ff d0		 call	 eax
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 61   :     g_pd3dDevice->SetVertexShader(NULL);

  000b8	8b f4		 mov	 esi, esp
  000ba	6a 00		 push	 0
  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000c9	52		 push	 edx
  000ca	8b 81 70 01 00
	00		 mov	 eax, DWORD PTR [ecx+368]
  000d0	ff d0		 call	 eax
  000d2	3b f4		 cmp	 esi, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 62   :     g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

  000d9	8b f4		 mov	 esi, esp
  000db	6a 01		 push	 1
  000dd	6a 16		 push	 22			; 00000016H
  000df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000ec	52		 push	 edx
  000ed	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  000f3	ff d0		 call	 eax
  000f5	3b f4		 cmp	 esi, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 63   :     g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, false);

  000fc	8b f4		 mov	 esi, esp
  000fe	6a 00		 push	 0
  00100	68 89 00 00 00	 push	 137			; 00000089H
  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0010a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00112	52		 push	 edx
  00113	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  00119	ff d0		 call	 eax
  0011b	3b f4		 cmp	 esi, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 64   :     g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, false);

  00122	8b f4		 mov	 esi, esp
  00124	6a 00		 push	 0
  00126	6a 07		 push	 7
  00128	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00135	52		 push	 edx
  00136	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  0013c	ff d0		 call	 eax
  0013e	3b f4		 cmp	 esi, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 65   :     g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);

  00145	8b f4		 mov	 esi, esp
  00147	6a 01		 push	 1
  00149	6a 1b		 push	 27			; 0000001bH
  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00158	52		 push	 edx
  00159	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  0015f	ff d0		 call	 eax
  00161	3b f4		 cmp	 esi, esp
  00163	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   :     g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, false);

  00168	8b f4		 mov	 esi, esp
  0016a	6a 00		 push	 0
  0016c	6a 0f		 push	 15			; 0000000fH
  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00173	8b 08		 mov	 ecx, DWORD PTR [eax]
  00175	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0017b	52		 push	 edx
  0017c	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  00182	ff d0		 call	 eax
  00184	3b f4		 cmp	 esi, esp
  00186	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 67   :     g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);

  0018b	8b f4		 mov	 esi, esp
  0018d	6a 01		 push	 1
  0018f	68 ab 00 00 00	 push	 171			; 000000abH
  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00199	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001a1	52		 push	 edx
  001a2	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  001a8	ff d0		 call	 eax
  001aa	3b f4		 cmp	 esi, esp
  001ac	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 68   :     g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  001b1	8b f4		 mov	 esi, esp
  001b3	6a 05		 push	 5
  001b5	6a 13		 push	 19			; 00000013H
  001b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001c4	52		 push	 edx
  001c5	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  001cb	ff d0		 call	 eax
  001cd	3b f4		 cmp	 esi, esp
  001cf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 69   :     g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  001d4	8b f4		 mov	 esi, esp
  001d6	6a 06		 push	 6
  001d8	6a 14		 push	 20			; 00000014H
  001da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001df	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001e7	52		 push	 edx
  001e8	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  001ee	ff d0		 call	 eax
  001f0	3b f4		 cmp	 esi, esp
  001f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 70   :     g_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, true);

  001f7	8b f4		 mov	 esi, esp
  001f9	6a 01		 push	 1
  001fb	68 ae 00 00 00	 push	 174			; 000000aeH
  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00205	8b 08		 mov	 ecx, DWORD PTR [eax]
  00207	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0020d	52		 push	 edx
  0020e	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  00214	ff d0		 call	 eax
  00216	3b f4		 cmp	 esi, esp
  00218	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 71   :     g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);

  0021d	8b f4		 mov	 esi, esp
  0021f	6a 02		 push	 2
  00221	6a 09		 push	 9
  00223	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00228	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00230	52		 push	 edx
  00231	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  00237	ff d0		 call	 eax
  00239	3b f4		 cmp	 esi, esp
  0023b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 72   :     g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, false);

  00240	8b f4		 mov	 esi, esp
  00242	6a 00		 push	 0
  00244	6a 1c		 push	 28			; 0000001cH
  00246	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0024b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00253	52		 push	 edx
  00254	8b 81 e4 00 00
	00		 mov	 eax, DWORD PTR [ecx+228]
  0025a	ff d0		 call	 eax
  0025c	3b f4		 cmp	 esi, esp
  0025e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 73   :     g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

  00263	8b f4		 mov	 esi, esp
  00265	6a 04		 push	 4
  00267	6a 01		 push	 1
  00269	6a 00		 push	 0
  0026b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00270	8b 08		 mov	 ecx, DWORD PTR [eax]
  00272	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00278	52		 push	 edx
  00279	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  0027f	ff d0		 call	 eax
  00281	3b f4		 cmp	 esi, esp
  00283	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 74   :     g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00288	8b f4		 mov	 esi, esp
  0028a	6a 02		 push	 2
  0028c	6a 02		 push	 2
  0028e	6a 00		 push	 0
  00290	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00295	8b 08		 mov	 ecx, DWORD PTR [eax]
  00297	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0029d	52		 push	 edx
  0029e	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  002a4	ff d0		 call	 eax
  002a6	3b f4		 cmp	 esi, esp
  002a8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 75   :     g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  002ad	8b f4		 mov	 esi, esp
  002af	6a 00		 push	 0
  002b1	6a 03		 push	 3
  002b3	6a 00		 push	 0
  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  002ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  002bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  002c2	52		 push	 edx
  002c3	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  002c9	ff d0		 call	 eax
  002cb	3b f4		 cmp	 esi, esp
  002cd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 76   :     g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);

  002d2	8b f4		 mov	 esi, esp
  002d4	6a 04		 push	 4
  002d6	6a 04		 push	 4
  002d8	6a 00		 push	 0
  002da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  002df	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  002e7	52		 push	 edx
  002e8	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  002ee	ff d0		 call	 eax
  002f0	3b f4		 cmp	 esi, esp
  002f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 77   :     g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  002f7	8b f4		 mov	 esi, esp
  002f9	6a 02		 push	 2
  002fb	6a 05		 push	 5
  002fd	6a 00		 push	 0
  002ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00304	8b 08		 mov	 ecx, DWORD PTR [eax]
  00306	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0030c	52		 push	 edx
  0030d	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  00313	ff d0		 call	 eax
  00315	3b f4		 cmp	 esi, esp
  00317	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 78   :     g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

  0031c	8b f4		 mov	 esi, esp
  0031e	6a 00		 push	 0
  00320	6a 06		 push	 6
  00322	6a 00		 push	 0
  00324	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00329	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00331	52		 push	 edx
  00332	8b 81 0c 01 00
	00		 mov	 eax, DWORD PTR [ecx+268]
  00338	ff d0		 call	 eax
  0033a	3b f4		 cmp	 esi, esp
  0033c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 79   :     g_pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);

  00341	8b f4		 mov	 esi, esp
  00343	6a 02		 push	 2
  00345	6a 06		 push	 6
  00347	6a 00		 push	 0
  00349	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0034e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00350	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00356	52		 push	 edx
  00357	8b 81 14 01 00
	00		 mov	 eax, DWORD PTR [ecx+276]
  0035d	ff d0		 call	 eax
  0035f	3b f4		 cmp	 esi, esp
  00361	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 80   :     g_pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);

  00366	8b f4		 mov	 esi, esp
  00368	6a 02		 push	 2
  0036a	6a 05		 push	 5
  0036c	6a 00		 push	 0
  0036e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00373	8b 08		 mov	 ecx, DWORD PTR [eax]
  00375	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0037b	52		 push	 edx
  0037c	8b 81 14 01 00
	00		 mov	 eax, DWORD PTR [ecx+276]
  00382	ff d0		 call	 eax
  00384	3b f4		 cmp	 esi, esp
  00386	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 81   : 
; 82   :     // Setup orthographic projection matrix
; 83   :     // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
; 84   :     // Being agnostic of whether <d3dx9.h> or <DirectXMath.h> can be used, we aren't relying on D3DXMatrixIdentity()/D3DXMatrixOrthoOffCenterLH() or DirectX::XMMatrixIdentity()/DirectX::XMMatrixOrthographicOffCenterLH()
; 85   :     {
; 86   :         float L = draw_data->DisplayPos.x + 0.5f;

  0038b	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  0038e	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00393	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0039b	f3 0f 11 45 d4	 movss	 DWORD PTR _L$6[ebp], xmm0

; 87   :         float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x + 0.5f;

  003a0	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  003a3	8b 4d 08	 mov	 ecx, DWORD PTR _draw_data$[ebp]
  003a6	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  003ab	f3 0f 58 41 1c	 addss	 xmm0, DWORD PTR [ecx+28]
  003b0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  003b8	f3 0f 11 45 c8	 movss	 DWORD PTR _R$5[ebp], xmm0

; 88   :         float T = draw_data->DisplayPos.y + 0.5f;

  003bd	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  003c0	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  003c5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  003cd	f3 0f 11 45 bc	 movss	 DWORD PTR _T$4[ebp], xmm0

; 89   :         float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y + 0.5f;

  003d2	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  003d5	8b 4d 08	 mov	 ecx, DWORD PTR _draw_data$[ebp]
  003d8	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  003dd	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [ecx+32]
  003e2	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  003ea	f3 0f 11 45 b0	 movss	 DWORD PTR _B$3[ebp], xmm0

; 90   :         D3DMATRIX mat_identity = { { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } } };

  003ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003f7	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _mat_identity$2[ebp], xmm0
  003ff	0f 57 c0	 xorps	 xmm0, xmm0
  00402	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _mat_identity$2[ebp+4], xmm0
  0040a	0f 57 c0	 xorps	 xmm0, xmm0
  0040d	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _mat_identity$2[ebp+8], xmm0
  00415	0f 57 c0	 xorps	 xmm0, xmm0
  00418	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _mat_identity$2[ebp+12], xmm0
  00420	0f 57 c0	 xorps	 xmm0, xmm0
  00423	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _mat_identity$2[ebp+16], xmm0
  0042b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00433	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _mat_identity$2[ebp+20], xmm0
  0043b	0f 57 c0	 xorps	 xmm0, xmm0
  0043e	f3 0f 11 45 80	 movss	 DWORD PTR _mat_identity$2[ebp+24], xmm0
  00443	0f 57 c0	 xorps	 xmm0, xmm0
  00446	f3 0f 11 45 84	 movss	 DWORD PTR _mat_identity$2[ebp+28], xmm0
  0044b	0f 57 c0	 xorps	 xmm0, xmm0
  0044e	f3 0f 11 45 88	 movss	 DWORD PTR _mat_identity$2[ebp+32], xmm0
  00453	0f 57 c0	 xorps	 xmm0, xmm0
  00456	f3 0f 11 45 8c	 movss	 DWORD PTR _mat_identity$2[ebp+36], xmm0
  0045b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00463	f3 0f 11 45 90	 movss	 DWORD PTR _mat_identity$2[ebp+40], xmm0
  00468	0f 57 c0	 xorps	 xmm0, xmm0
  0046b	f3 0f 11 45 94	 movss	 DWORD PTR _mat_identity$2[ebp+44], xmm0
  00470	0f 57 c0	 xorps	 xmm0, xmm0
  00473	f3 0f 11 45 98	 movss	 DWORD PTR _mat_identity$2[ebp+48], xmm0
  00478	0f 57 c0	 xorps	 xmm0, xmm0
  0047b	f3 0f 11 45 9c	 movss	 DWORD PTR _mat_identity$2[ebp+52], xmm0
  00480	0f 57 c0	 xorps	 xmm0, xmm0
  00483	f3 0f 11 45 a0	 movss	 DWORD PTR _mat_identity$2[ebp+56], xmm0
  00488	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00490	f3 0f 11 45 a4	 movss	 DWORD PTR _mat_identity$2[ebp+60], xmm0

; 91   :         D3DMATRIX mat_projection =
; 92   :         { { {
; 93   :             2.0f/(R-L),   0.0f,         0.0f,  0.0f,

  00495	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _R$5[ebp]
  0049a	f3 0f 5c 45 d4	 subss	 xmm0, DWORD PTR _L$6[ebp]
  0049f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  004a7	f3 0f 5e c8	 divss	 xmm1, xmm0
  004ab	f3 0f 11 8d 20
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp], xmm1
  004b3	0f 57 c0	 xorps	 xmm0, xmm0
  004b6	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+4], xmm0
  004be	0f 57 c0	 xorps	 xmm0, xmm0
  004c1	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+8], xmm0
  004c9	0f 57 c0	 xorps	 xmm0, xmm0
  004cc	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+12], xmm0

; 94   :             0.0f,         2.0f/(T-B),   0.0f,  0.0f,

  004d4	0f 57 c0	 xorps	 xmm0, xmm0
  004d7	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+16], xmm0
  004df	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _T$4[ebp]
  004e4	f3 0f 5c 45 b0	 subss	 xmm0, DWORD PTR _B$3[ebp]
  004e9	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40000000
  004f1	f3 0f 5e c8	 divss	 xmm1, xmm0
  004f5	f3 0f 11 8d 34
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+20], xmm1
  004fd	0f 57 c0	 xorps	 xmm0, xmm0
  00500	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+24], xmm0
  00508	0f 57 c0	 xorps	 xmm0, xmm0
  0050b	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+28], xmm0

; 95   :             0.0f,         0.0f,         0.5f,  0.0f,

  00513	0f 57 c0	 xorps	 xmm0, xmm0
  00516	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+32], xmm0
  0051e	0f 57 c0	 xorps	 xmm0, xmm0
  00521	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+36], xmm0
  00529	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00531	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+40], xmm0
  00539	0f 57 c0	 xorps	 xmm0, xmm0
  0053c	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+44], xmm0

; 96   :             (L+R)/(L-R),  (T+B)/(B-T),  0.5f,  1.0f

  00544	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _L$6[ebp]
  00549	f3 0f 58 45 c8	 addss	 xmm0, DWORD PTR _R$5[ebp]
  0054e	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR _L$6[ebp]
  00553	f3 0f 5c 4d c8	 subss	 xmm1, DWORD PTR _R$5[ebp]
  00558	f3 0f 5e c1	 divss	 xmm0, xmm1
  0055c	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+48], xmm0
  00564	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _T$4[ebp]
  00569	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _B$3[ebp]
  0056e	f3 0f 10 4d b0	 movss	 xmm1, DWORD PTR _B$3[ebp]
  00573	f3 0f 5c 4d bc	 subss	 xmm1, DWORD PTR _T$4[ebp]
  00578	f3 0f 5e c1	 divss	 xmm0, xmm1
  0057c	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+52], xmm0
  00584	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0058c	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+56], xmm0
  00594	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0059c	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _mat_projection$1[ebp+60], xmm0

; 97   :         } } };
; 98   :         g_pd3dDevice->SetTransform(D3DTS_WORLD, &mat_identity);

  005a4	8b f4		 mov	 esi, esp
  005a6	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _mat_identity$2[ebp]
  005ac	50		 push	 eax
  005ad	68 00 01 00 00	 push	 256			; 00000100H
  005b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  005b8	8b 11		 mov	 edx, DWORD PTR [ecx]
  005ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  005bf	50		 push	 eax
  005c0	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  005c6	ff d1		 call	 ecx
  005c8	3b f4		 cmp	 esi, esp
  005ca	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 99   :         g_pd3dDevice->SetTransform(D3DTS_VIEW, &mat_identity);

  005cf	8b f4		 mov	 esi, esp
  005d1	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _mat_identity$2[ebp]
  005d7	50		 push	 eax
  005d8	6a 02		 push	 2
  005da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  005e0	8b 11		 mov	 edx, DWORD PTR [ecx]
  005e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  005e7	50		 push	 eax
  005e8	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  005ee	ff d1		 call	 ecx
  005f0	3b f4		 cmp	 esi, esp
  005f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 100  :         g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mat_projection);

  005f7	8b f4		 mov	 esi, esp
  005f9	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _mat_projection$1[ebp]
  005ff	50		 push	 eax
  00600	6a 03		 push	 3
  00602	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00608	8b 11		 mov	 edx, DWORD PTR [ecx]
  0060a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0060f	50		 push	 eax
  00610	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  00616	ff d1		 call	 ecx
  00618	3b f4		 cmp	 esi, esp
  0061a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 101  :     }
; 102  : }

  0061f	52		 push	 edx
  00620	8b cd		 mov	 ecx, ebp
  00622	50		 push	 eax
  00623	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@ImGui_Impl
  00629	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0062e	58		 pop	 eax
  0062f	5a		 pop	 edx
  00630	5f		 pop	 edi
  00631	5e		 pop	 esi
  00632	5b		 pop	 ebx
  00633	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00636	33 cd		 xor	 ecx, ebp
  00638	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0063d	81 c4 a4 01 00
	00		 add	 esp, 420		; 000001a4H
  00643	3b ec		 cmp	 ebp, esp
  00645	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0064a	8b e5		 mov	 esp, ebp
  0064c	5d		 pop	 ebp
  0064d	c3		 ret	 0
  0064e	66 90		 npad	 2
$LN7@ImGui_Impl:
  00650	03 00 00 00	 DD	 3
  00654	00 00 00 00	 DD	 $LN6@ImGui_Impl
$LN6@ImGui_Impl:
  00658	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0065c	18 00 00 00	 DD	 24			; 00000018H
  00660	00 00 00 00	 DD	 $LN3@ImGui_Impl
  00664	68 ff ff ff	 DD	 -152			; ffffff68H
  00668	40 00 00 00	 DD	 64			; 00000040H
  0066c	00 00 00 00	 DD	 $LN4@ImGui_Impl
  00670	20 ff ff ff	 DD	 -224			; ffffff20H
  00674	40 00 00 00	 DD	 64			; 00000040H
  00678	00 00 00 00	 DD	 $LN5@ImGui_Impl
$LN5@ImGui_Impl:
  0067c	6d		 DB	 109			; 0000006dH
  0067d	61		 DB	 97			; 00000061H
  0067e	74		 DB	 116			; 00000074H
  0067f	5f		 DB	 95			; 0000005fH
  00680	70		 DB	 112			; 00000070H
  00681	72		 DB	 114			; 00000072H
  00682	6f		 DB	 111			; 0000006fH
  00683	6a		 DB	 106			; 0000006aH
  00684	65		 DB	 101			; 00000065H
  00685	63		 DB	 99			; 00000063H
  00686	74		 DB	 116			; 00000074H
  00687	69		 DB	 105			; 00000069H
  00688	6f		 DB	 111			; 0000006fH
  00689	6e		 DB	 110			; 0000006eH
  0068a	00		 DB	 0
$LN4@ImGui_Impl:
  0068b	6d		 DB	 109			; 0000006dH
  0068c	61		 DB	 97			; 00000061H
  0068d	74		 DB	 116			; 00000074H
  0068e	5f		 DB	 95			; 0000005fH
  0068f	69		 DB	 105			; 00000069H
  00690	64		 DB	 100			; 00000064H
  00691	65		 DB	 101			; 00000065H
  00692	6e		 DB	 110			; 0000006eH
  00693	74		 DB	 116			; 00000074H
  00694	69		 DB	 105			; 00000069H
  00695	74		 DB	 116			; 00000074H
  00696	79		 DB	 121			; 00000079H
  00697	00		 DB	 0
$LN3@ImGui_Impl:
  00698	76		 DB	 118			; 00000076H
  00699	70		 DB	 112			; 00000070H
  0069a	00		 DB	 0
?ImGui_ImplDX9_SetupRenderState@@YAXPAUImDrawData@@@Z ENDP ; ImGui_ImplDX9_SetupRenderState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXXZ PROC	; ImGui_ImplDX9_InvalidateDeviceObjects, COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 273  :     if (!g_pd3dDevice)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, 0
  0002f	75 05		 jne	 SHORT $LN2@ImGui_Impl

; 274  :         return;

  00031	e9 9f 00 00 00	 jmp	 $LN1@ImGui_Impl
$LN2@ImGui_Impl:

; 275  :     if (g_pVB) { g_pVB->Release(); g_pVB = NULL; }

  00036	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A, 0
  0003d	74 26		 je	 SHORT $LN3@ImGui_Impl
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	8b f4		 mov	 esi, esp
  00048	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  0004e	52		 push	 edx
  0004f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00052	ff d0		 call	 eax
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A, 0
$LN3@ImGui_Impl:

; 276  :     if (g_pIB) { g_pIB->Release(); g_pIB = NULL; }

  00065	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A, 0
  0006c	74 26		 je	 SHORT $LN4@ImGui_Impl
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	8b f4		 mov	 esi, esp
  00077	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  0007d	52		 push	 edx
  0007e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00081	ff d0		 call	 eax
  00083	3b f4		 cmp	 esi, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A, 0
$LN4@ImGui_Impl:

; 277  :     if (g_FontTexture) { g_FontTexture->Release(); g_FontTexture = NULL; ImGui::GetIO().Fonts->TexID = NULL; } // We copied g_pFontTextureView to io.Fonts->TexID so let's clear that as well.

  00094	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A, 0
  0009b	74 38		 je	 SHORT $LN1@ImGui_Impl
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	8b f4		 mov	 esi, esp
  000a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
  000ac	52		 push	 edx
  000ad	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000b0	ff d0		 call	 eax
  000b2	3b f4		 cmp	 esi, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A, 0
  000c3	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  000c8	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [eax+144]
  000ce	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@ImGui_Impl:

; 278  : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000de	3b ec		 cmp	 ebp, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXXZ ENDP	; ImGui_ImplDX9_InvalidateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ
_TEXT	SEGMENT
?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ PROC		; ImGui_ImplDX9_CreateDeviceObjects, COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 264  :     if (!g_pd3dDevice)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, 0
  0002f	75 04		 jne	 SHORT $LN2@ImGui_Impl

; 265  :         return false;

  00031	32 c0		 xor	 al, al
  00033	eb 12		 jmp	 SHORT $LN1@ImGui_Impl
$LN2@ImGui_Impl:

; 266  :     if (!ImGui_ImplDX9_CreateFontsTexture())

  00035	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ ; ImGui_ImplDX9_CreateFontsTexture
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	75 04		 jne	 SHORT $LN3@ImGui_Impl

; 267  :         return false;

  00041	32 c0		 xor	 al, al
  00043	eb 02		 jmp	 SHORT $LN1@ImGui_Impl
$LN3@ImGui_Impl:

; 268  :     return true;

  00045	b0 01		 mov	 al, 1
$LN1@ImGui_Impl:

; 269  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ ENDP		; ImGui_ImplDX9_CreateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_RenderDrawData@@YAXPAUImDrawData@@@Z
_TEXT	SEGMENT
_texture$1 = -424					; size = 4
_r$2 = -412						; size = 16
_pcmd$3 = -388						; size = 4
_cmd_i$4 = -376						; size = 4
_cmd_list$5 = -364					; size = 4
_n$6 = -352						; size = 4
_clip_off$ = -340					; size = 8
_global_idx_offset$ = -324				; size = 4
_global_vtx_offset$ = -312				; size = 4
_i$7 = -300						; size = 4
_vtx_src$8 = -288					; size = 4
_cmd_list$9 = -276					; size = 4
_n$10 = -264						; size = 4
_idx_dst$ = -252					; size = 4
_vtx_dst$ = -240					; size = 4
_last_projection$ = -228				; size = 64
_last_view$ = -156					; size = 64
_last_world$ = -84					; size = 64
_d3d9_state_block$ = -12				; size = 4
__$ArrayPad$ = -4					; size = 4
_draw_data$ = 8						; size = 4
?ImGui_ImplDX9_RenderDrawData@@YAXPAUImDrawData@@@Z PROC ; ImGui_ImplDX9_RenderDrawData, COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 02 00
	00		 sub	 esp, 620		; 0000026cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 94 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-620]
  00012	b9 9b 00 00 00	 mov	 ecx, 155		; 0000009bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 108  :     // Avoid rendering when minimized
; 109  :     if (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f)

  00032	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00035	0f 57 c0	 xorps	 xmm0, xmm0
  00038	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [eax+28]
  0003c	73 0c		 jae	 SHORT $LN15@ImGui_Impl
  0003e	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00041	0f 57 c0	 xorps	 xmm0, xmm0
  00044	0f 2f 40 20	 comiss	 xmm0, DWORD PTR [eax+32]
  00048	72 05		 jb	 SHORT $LN14@ImGui_Impl
$LN15@ImGui_Impl:

; 110  :         return;

  0004a	e9 bc 07 00 00	 jmp	 $LN1@ImGui_Impl
$LN14@ImGui_Impl:

; 111  : 
; 112  :     // Create and grow buffers if needed
; 113  :     if (!g_pVB || g_VertexBufferSize < draw_data->TotalVtxCount)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A, 0
  00056	74 12		 je	 SHORT $LN17@ImGui_Impl
  00058	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_VertexBufferSize@@3HA
  00061	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00064	0f 8d 81 00 00
	00		 jge	 $LN19@ImGui_Impl
$LN17@ImGui_Impl:

; 114  :     {
; 115  :         if (g_pVB) { g_pVB->Release(); g_pVB = NULL; }

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A, 0
  00071	74 26		 je	 SHORT $LN18@ImGui_Impl
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	8b f4		 mov	 esi, esp
  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  00082	52		 push	 edx
  00083	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00086	ff d0		 call	 eax
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A, 0
$LN18@ImGui_Impl:

; 116  :         g_VertexBufferSize = draw_data->TotalVtxCount + 5000;

  00099	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  0009c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0009f	81 c1 88 13 00
	00		 add	 ecx, 5000		; 00001388H
  000a5	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_VertexBufferSize@@3HA, ecx

; 117  :         if (g_pd3dDevice->CreateVertexBuffer(g_VertexBufferSize * sizeof(CUSTOMVERTEX), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &g_pVB, NULL) < 0)

  000ab	8b f4		 mov	 esi, esp
  000ad	6a 00		 push	 0
  000af	68 00 00 00 00	 push	 OFFSET ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  000b4	6a 00		 push	 0
  000b6	68 42 01 00 00	 push	 322			; 00000142H
  000bb	68 08 02 00 00	 push	 520			; 00000208H
  000c0	6b 05 00 00 00
	00 18		 imul	 eax, DWORD PTR ?g_VertexBufferSize@@3HA, 24
  000c7	50		 push	 eax
  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  000d5	50		 push	 eax
  000d6	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  000d9	ff d1		 call	 ecx
  000db	3b f4		 cmp	 esi, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	85 c0		 test	 eax, eax
  000e4	7d 05		 jge	 SHORT $LN19@ImGui_Impl

; 118  :             return;

  000e6	e9 20 07 00 00	 jmp	 $LN1@ImGui_Impl
$LN19@ImGui_Impl:

; 119  :     }
; 120  :     if (!g_pIB || g_IndexBufferSize < draw_data->TotalIdxCount)

  000eb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A, 0
  000f2	74 0e		 je	 SHORT $LN21@ImGui_Impl
  000f4	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_IndexBufferSize@@3HA
  000fd	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00100	7d 7e		 jge	 SHORT $LN23@ImGui_Impl
$LN21@ImGui_Impl:

; 121  :     {
; 122  :         if (g_pIB) { g_pIB->Release(); g_pIB = NULL; }

  00102	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A, 0
  00109	74 26		 je	 SHORT $LN22@ImGui_Impl
  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  00110	8b 08		 mov	 ecx, DWORD PTR [eax]
  00112	8b f4		 mov	 esi, esp
  00114	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  0011a	52		 push	 edx
  0011b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0011e	ff d0		 call	 eax
  00120	3b f4		 cmp	 esi, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A, 0
$LN22@ImGui_Impl:

; 123  :         g_IndexBufferSize = draw_data->TotalIdxCount + 10000;

  00131	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00134	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00137	81 c1 10 27 00
	00		 add	 ecx, 10000		; 00002710H
  0013d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?g_IndexBufferSize@@3HA, ecx

; 124  :         if (g_pd3dDevice->CreateIndexBuffer(g_IndexBufferSize * sizeof(ImDrawIdx), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, sizeof(ImDrawIdx) == 2 ? D3DFMT_INDEX16 : D3DFMT_INDEX32, D3DPOOL_DEFAULT, &g_pIB, NULL) < 0)

  00143	8b f4		 mov	 esi, esp
  00145	6a 00		 push	 0
  00147	68 00 00 00 00	 push	 OFFSET ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  0014c	6a 00		 push	 0
  0014e	6a 65		 push	 101			; 00000065H
  00150	68 08 02 00 00	 push	 520			; 00000208H
  00155	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_IndexBufferSize@@3HA
  0015a	d1 e0		 shl	 eax, 1
  0015c	50		 push	 eax
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00163	8b 11		 mov	 edx, DWORD PTR [ecx]
  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0016a	50		 push	 eax
  0016b	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  0016e	ff d1		 call	 ecx
  00170	3b f4		 cmp	 esi, esp
  00172	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00177	85 c0		 test	 eax, eax
  00179	7d 05		 jge	 SHORT $LN23@ImGui_Impl

; 125  :             return;

  0017b	e9 8b 06 00 00	 jmp	 $LN1@ImGui_Impl
$LN23@ImGui_Impl:

; 126  :     }
; 127  : 
; 128  :     // Backup the DX9 state
; 129  :     IDirect3DStateBlock9* d3d9_state_block = NULL;

  00180	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _d3d9_state_block$[ebp], 0

; 130  :     if (g_pd3dDevice->CreateStateBlock(D3DSBT_PIXELSTATE, &d3d9_state_block) < 0)

  00187	8b f4		 mov	 esi, esp
  00189	8d 45 f4	 lea	 eax, DWORD PTR _d3d9_state_block$[ebp]
  0018c	50		 push	 eax
  0018d	6a 02		 push	 2
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00195	8b 11		 mov	 edx, DWORD PTR [ecx]
  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0019c	50		 push	 eax
  0019d	8b 8a ec 00 00
	00		 mov	 ecx, DWORD PTR [edx+236]
  001a3	ff d1		 call	 ecx
  001a5	3b f4		 cmp	 esi, esp
  001a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ac	85 c0		 test	 eax, eax
  001ae	7d 05		 jge	 SHORT $LN24@ImGui_Impl

; 131  :         return;

  001b0	e9 56 06 00 00	 jmp	 $LN1@ImGui_Impl
$LN24@ImGui_Impl:

; 132  : 
; 133  :     // Backup the DX9 transform (DX9 documentation suggests that it is included in the StateBlock but it doesn't appear to)
; 134  :     D3DMATRIX last_world, last_view, last_projection;
; 135  :     g_pd3dDevice->GetTransform(D3DTS_WORLD, &last_world);

  001b5	8b f4		 mov	 esi, esp
  001b7	8d 45 ac	 lea	 eax, DWORD PTR _last_world$[ebp]
  001ba	50		 push	 eax
  001bb	68 00 01 00 00	 push	 256			; 00000100H
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001cd	50		 push	 eax
  001ce	8b 8a b4 00 00
	00		 mov	 ecx, DWORD PTR [edx+180]
  001d4	ff d1		 call	 ecx
  001d6	3b f4		 cmp	 esi, esp
  001d8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 136  :     g_pd3dDevice->GetTransform(D3DTS_VIEW, &last_view);

  001dd	8b f4		 mov	 esi, esp
  001df	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _last_view$[ebp]
  001e5	50		 push	 eax
  001e6	6a 02		 push	 2
  001e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  001f5	50		 push	 eax
  001f6	8b 8a b4 00 00
	00		 mov	 ecx, DWORD PTR [edx+180]
  001fc	ff d1		 call	 ecx
  001fe	3b f4		 cmp	 esi, esp
  00200	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 137  :     g_pd3dDevice->GetTransform(D3DTS_PROJECTION, &last_projection);

  00205	8b f4		 mov	 esi, esp
  00207	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _last_projection$[ebp]
  0020d	50		 push	 eax
  0020e	6a 03		 push	 3
  00210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00216	8b 11		 mov	 edx, DWORD PTR [ecx]
  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0021d	50		 push	 eax
  0021e	8b 8a b4 00 00
	00		 mov	 ecx, DWORD PTR [edx+180]
  00224	ff d1		 call	 ecx
  00226	3b f4		 cmp	 esi, esp
  00228	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 138  : 
; 139  :     // Copy and convert all vertices into a single contiguous buffer, convert colors to DX9 default format.
; 140  :     // FIXME-OPT: This is a waste of resource, the ideal is to use imconfig.h and
; 141  :     //  1) to avoid repacking colors:   #define IMGUI_USE_BGRA_PACKED_COLOR
; 142  :     //  2) to avoid repacking vertices: #define IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT struct ImDrawVert { ImVec2 pos; float z; ImU32 col; ImVec2 uv; }
; 143  :     CUSTOMVERTEX* vtx_dst;
; 144  :     ImDrawIdx* idx_dst;
; 145  :     if (g_pVB->Lock(0, (UINT)(draw_data->TotalVtxCount * sizeof(CUSTOMVERTEX)), (void**)&vtx_dst, D3DLOCK_DISCARD) < 0)

  0022d	8b f4		 mov	 esi, esp
  0022f	68 00 20 00 00	 push	 8192			; 00002000H
  00234	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _vtx_dst$[ebp]
  0023a	50		 push	 eax
  0023b	8b 4d 08	 mov	 ecx, DWORD PTR _draw_data$[ebp]
  0023e	6b 51 10 18	 imul	 edx, DWORD PTR [ecx+16], 24
  00242	52		 push	 edx
  00243	6a 00		 push	 0
  00245	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  0024a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  00252	52		 push	 edx
  00253	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00256	ff d0		 call	 eax
  00258	3b f4		 cmp	 esi, esp
  0025a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025f	85 c0		 test	 eax, eax
  00261	7d 05		 jge	 SHORT $LN25@ImGui_Impl

; 146  :         return;

  00263	e9 a3 05 00 00	 jmp	 $LN1@ImGui_Impl
$LN25@ImGui_Impl:

; 147  :     if (g_pIB->Lock(0, (UINT)(draw_data->TotalIdxCount * sizeof(ImDrawIdx)), (void**)&idx_dst, D3DLOCK_DISCARD) < 0)

  00268	8b f4		 mov	 esi, esp
  0026a	68 00 20 00 00	 push	 8192			; 00002000H
  0026f	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _idx_dst$[ebp]
  00275	50		 push	 eax
  00276	8b 4d 08	 mov	 ecx, DWORD PTR _draw_data$[ebp]
  00279	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0027c	d1 e2		 shl	 edx, 1
  0027e	52		 push	 edx
  0027f	6a 00		 push	 0
  00281	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  00286	8b 08		 mov	 ecx, DWORD PTR [eax]
  00288	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  0028e	52		 push	 edx
  0028f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00292	ff d0		 call	 eax
  00294	3b f4		 cmp	 esi, esp
  00296	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029b	85 c0		 test	 eax, eax
  0029d	7d 05		 jge	 SHORT $LN26@ImGui_Impl

; 148  :         return;

  0029f	e9 67 05 00 00	 jmp	 $LN1@ImGui_Impl
$LN26@ImGui_Impl:

; 149  :     for (int n = 0; n < draw_data->CmdListsCount; n++)

  002a4	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$10[ebp], 0
  002ae	eb 0f		 jmp	 SHORT $LN4@ImGui_Impl
$LN2@ImGui_Impl:
  002b0	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _n$10[ebp]
  002b6	83 c0 01	 add	 eax, 1
  002b9	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _n$10[ebp], eax
$LN4@ImGui_Impl:
  002bf	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  002c2	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _n$10[ebp]
  002c8	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  002cb	0f 8d 75 01 00
	00		 jge	 $LN3@ImGui_Impl

; 150  :     {
; 151  :         const ImDrawList* cmd_list = draw_data->CmdLists[n];

  002d1	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  002d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002d7	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _n$10[ebp]
  002dd	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  002e0	89 85 ec fe ff
	ff		 mov	 DWORD PTR _cmd_list$9[ebp], eax

; 152  :         const ImDrawVert* vtx_src = cmd_list->VtxBuffer.Data;

  002e6	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _cmd_list$9[ebp]
  002ec	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  002ef	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _vtx_src$8[ebp], ecx

; 153  :         for (int i = 0; i < cmd_list->VtxBuffer.Size; i++)

  002f5	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$7[ebp], 0
  002ff	eb 0f		 jmp	 SHORT $LN7@ImGui_Impl
$LN5@ImGui_Impl:
  00301	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _i$7[ebp]
  00307	83 c0 01	 add	 eax, 1
  0030a	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _i$7[ebp], eax
$LN7@ImGui_Impl:
  00310	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _cmd_list$9[ebp]
  00316	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$7[ebp]
  0031c	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0031f	0f 8d df 00 00
	00		 jge	 $LN6@ImGui_Impl

; 154  :         {
; 155  :             vtx_dst->pos[0] = vtx_src->pos.x;

  00325	b8 04 00 00 00	 mov	 eax, 4
  0032a	6b c8 00	 imul	 ecx, eax, 0
  0032d	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_dst$[ebp]
  00333	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _vtx_src$8[ebp]
  00339	8b 00		 mov	 eax, DWORD PTR [eax]
  0033b	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 156  :             vtx_dst->pos[1] = vtx_src->pos.y;

  0033e	b8 04 00 00 00	 mov	 eax, 4
  00343	c1 e0 00	 shl	 eax, 0
  00346	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_dst$[ebp]
  0034c	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _vtx_src$8[ebp]
  00352	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00355	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 157  :             vtx_dst->pos[2] = 0.0f;

  00358	b8 04 00 00 00	 mov	 eax, 4
  0035d	d1 e0		 shl	 eax, 1
  0035f	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_dst$[ebp]
  00365	0f 57 c0	 xorps	 xmm0, xmm0
  00368	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 158  :             vtx_dst->col = (vtx_src->col & 0xFF00FF00) | ((vtx_src->col & 0xFF0000) >> 16) | ((vtx_src->col & 0xFF) << 16);     // RGBA --> ARGB for DirectX9

  0036d	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _vtx_src$8[ebp]
  00373	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00376	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  0037c	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _vtx_src$8[ebp]
  00382	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00385	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0038a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0038d	0b c8		 or	 ecx, eax
  0038f	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _vtx_src$8[ebp]
  00395	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00398	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0039d	c1 e0 10	 shl	 eax, 16			; 00000010H
  003a0	0b c8		 or	 ecx, eax
  003a2	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_dst$[ebp]
  003a8	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 159  :             vtx_dst->uv[0] = vtx_src->uv.x;

  003ab	b8 04 00 00 00	 mov	 eax, 4
  003b0	6b c8 00	 imul	 ecx, eax, 0
  003b3	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_dst$[ebp]
  003b9	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _vtx_src$8[ebp]
  003bf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  003c2	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 160  :             vtx_dst->uv[1] = vtx_src->uv.y;

  003c6	b8 04 00 00 00	 mov	 eax, 4
  003cb	c1 e0 00	 shl	 eax, 0
  003ce	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_dst$[ebp]
  003d4	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _vtx_src$8[ebp]
  003da	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  003dd	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx

; 161  :             vtx_dst++;

  003e1	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _vtx_dst$[ebp]
  003e7	83 c0 18	 add	 eax, 24			; 00000018H
  003ea	89 85 10 ff ff
	ff		 mov	 DWORD PTR _vtx_dst$[ebp], eax

; 162  :             vtx_src++;

  003f0	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _vtx_src$8[ebp]
  003f6	83 c0 14	 add	 eax, 20			; 00000014H
  003f9	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _vtx_src$8[ebp], eax

; 163  :         }

  003ff	e9 fd fe ff ff	 jmp	 $LN5@ImGui_Impl
$LN6@ImGui_Impl:

; 164  :         memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));

  00404	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _cmd_list$9[ebp]
  0040a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0040d	d1 e1		 shl	 ecx, 1
  0040f	51		 push	 ecx
  00410	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _cmd_list$9[ebp]
  00416	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00419	50		 push	 eax
  0041a	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _idx_dst$[ebp]
  00420	51		 push	 ecx
  00421	e8 00 00 00 00	 call	 _memcpy
  00426	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  :         idx_dst += cmd_list->IdxBuffer.Size;

  00429	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _cmd_list$9[ebp]
  0042f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00432	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _idx_dst$[ebp]
  00438	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0043b	89 85 04 ff ff
	ff		 mov	 DWORD PTR _idx_dst$[ebp], eax

; 166  :     }

  00441	e9 6a fe ff ff	 jmp	 $LN2@ImGui_Impl
$LN3@ImGui_Impl:

; 167  :     g_pVB->Unlock();

  00446	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  0044b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0044d	8b f4		 mov	 esi, esp
  0044f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  00455	52		 push	 edx
  00456	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00459	ff d0		 call	 eax
  0045b	3b f4		 cmp	 esi, esp
  0045d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 168  :     g_pIB->Unlock();

  00462	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  00467	8b 08		 mov	 ecx, DWORD PTR [eax]
  00469	8b f4		 mov	 esi, esp
  0046b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  00471	52		 push	 edx
  00472	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00475	ff d0		 call	 eax
  00477	3b f4		 cmp	 esi, esp
  00479	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 169  :     g_pd3dDevice->SetStreamSource(0, g_pVB, 0, sizeof(CUSTOMVERTEX));

  0047e	8b f4		 mov	 esi, esp
  00480	6a 18		 push	 24			; 00000018H
  00482	6a 00		 push	 0
  00484	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
  00489	50		 push	 eax
  0048a	6a 00		 push	 0
  0048c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00492	8b 11		 mov	 edx, DWORD PTR [ecx]
  00494	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00499	50		 push	 eax
  0049a	8b 8a 90 01 00
	00		 mov	 ecx, DWORD PTR [edx+400]
  004a0	ff d1		 call	 ecx
  004a2	3b f4		 cmp	 esi, esp
  004a4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 170  :     g_pd3dDevice->SetIndices(g_pIB);

  004a9	8b f4		 mov	 esi, esp
  004ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
  004b0	50		 push	 eax
  004b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  004b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  004b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  004be	50		 push	 eax
  004bf	8b 8a a0 01 00
	00		 mov	 ecx, DWORD PTR [edx+416]
  004c5	ff d1		 call	 ecx
  004c7	3b f4		 cmp	 esi, esp
  004c9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 171  :     g_pd3dDevice->SetFVF(D3DFVF_CUSTOMVERTEX);

  004ce	8b f4		 mov	 esi, esp
  004d0	68 42 01 00 00	 push	 322			; 00000142H
  004d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  004da	8b 08		 mov	 ecx, DWORD PTR [eax]
  004dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  004e2	52		 push	 edx
  004e3	8b 81 64 01 00
	00		 mov	 eax, DWORD PTR [ecx+356]
  004e9	ff d0		 call	 eax
  004eb	3b f4		 cmp	 esi, esp
  004ed	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 172  : 
; 173  :     // Setup desired DX state
; 174  :     ImGui_ImplDX9_SetupRenderState(draw_data);

  004f2	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  004f5	50		 push	 eax
  004f6	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_SetupRenderState@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX9_SetupRenderState
  004fb	83 c4 04	 add	 esp, 4

; 175  : 
; 176  :     // Render command lists
; 177  :     // (Because we merged all buffers into a single one, we maintain our own offset into them)
; 178  :     int global_vtx_offset = 0;

  004fe	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _global_vtx_offset$[ebp], 0

; 179  :     int global_idx_offset = 0;

  00508	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _global_idx_offset$[ebp], 0

; 180  :     ImVec2 clip_off = draw_data->DisplayPos;

  00512	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00515	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00518	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0051b	89 8d ac fe ff
	ff		 mov	 DWORD PTR _clip_off$[ebp], ecx
  00521	89 95 b0 fe ff
	ff		 mov	 DWORD PTR _clip_off$[ebp+4], edx

; 181  :     for (int n = 0; n < draw_data->CmdListsCount; n++)

  00527	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$6[ebp], 0
  00531	eb 0f		 jmp	 SHORT $LN10@ImGui_Impl
$LN8@ImGui_Impl:
  00533	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _n$6[ebp]
  00539	83 c0 01	 add	 eax, 1
  0053c	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _n$6[ebp], eax
$LN10@ImGui_Impl:
  00542	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00545	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _n$6[ebp]
  0054b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0054e	0f 8d 11 02 00
	00		 jge	 $LN9@ImGui_Impl

; 182  :     {
; 183  :         const ImDrawList* cmd_list = draw_data->CmdLists[n];

  00554	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  00557	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0055a	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _n$6[ebp]
  00560	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00563	89 85 94 fe ff
	ff		 mov	 DWORD PTR _cmd_list$5[ebp], eax

; 184  :         for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

  00569	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _cmd_i$4[ebp], 0
  00573	eb 0f		 jmp	 SHORT $LN13@ImGui_Impl
$LN11@ImGui_Impl:
  00575	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _cmd_i$4[ebp]
  0057b	83 c0 01	 add	 eax, 1
  0057e	89 85 88 fe ff
	ff		 mov	 DWORD PTR _cmd_i$4[ebp], eax
$LN13@ImGui_Impl:
  00584	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _cmd_list$5[ebp]
  0058a	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _cmd_i$4[ebp]
  00590	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00592	0f 8d 9e 01 00
	00		 jge	 $LN12@ImGui_Impl

; 185  :         {
; 186  :             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];

  00598	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _cmd_i$4[ebp]
  0059e	50		 push	 eax
  0059f	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _cmd_list$5[ebp]
  005a5	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  005aa	89 85 7c fe ff
	ff		 mov	 DWORD PTR _pcmd$3[ebp], eax

; 187  :             if (pcmd->UserCallback != NULL)

  005b0	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  005b6	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  005ba	74 44		 je	 SHORT $LN27@ImGui_Impl

; 188  :             {
; 189  :                 // User callback, registered via ImDrawList::AddCallback()
; 190  :                 // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
; 191  :                 if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)

  005bc	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  005c2	83 78 20 ff	 cmp	 DWORD PTR [eax+32], -1
  005c6	75 0e		 jne	 SHORT $LN29@ImGui_Impl

; 192  :                     ImGui_ImplDX9_SetupRenderState(draw_data);

  005c8	8b 45 08	 mov	 eax, DWORD PTR _draw_data$[ebp]
  005cb	50		 push	 eax
  005cc	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_SetupRenderState@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX9_SetupRenderState
  005d1	83 c4 04	 add	 esp, 4
  005d4	eb 25		 jmp	 SHORT $LN30@ImGui_Impl
$LN29@ImGui_Impl:

; 193  :                 else
; 194  :                     pcmd->UserCallback(cmd_list, pcmd);

  005d6	8b f4		 mov	 esi, esp
  005d8	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  005de	50		 push	 eax
  005df	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _cmd_list$5[ebp]
  005e5	51		 push	 ecx
  005e6	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _pcmd$3[ebp]
  005ec	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  005ef	ff d0		 call	 eax
  005f1	83 c4 08	 add	 esp, 8
  005f4	3b f4		 cmp	 esi, esp
  005f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN30@ImGui_Impl:

; 195  :             }

  005fb	e9 31 01 00 00	 jmp	 $LN28@ImGui_Impl
$LN27@ImGui_Impl:

; 196  :             else
; 197  :             {
; 198  :                 const RECT r = { (LONG)(pcmd->ClipRect.x - clip_off.x), (LONG)(pcmd->ClipRect.y - clip_off.y), (LONG)(pcmd->ClipRect.z - clip_off.x), (LONG)(pcmd->ClipRect.w - clip_off.y) };

  00600	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  00606	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0060b	f3 0f 5c 85 ac
	fe ff ff	 subss	 xmm0, DWORD PTR _clip_off$[ebp]
  00613	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00617	89 8d 64 fe ff
	ff		 mov	 DWORD PTR _r$2[ebp], ecx
  0061d	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  00623	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00628	f3 0f 5c 85 b0
	fe ff ff	 subss	 xmm0, DWORD PTR _clip_off$[ebp+4]
  00630	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00634	89 8d 68 fe ff
	ff		 mov	 DWORD PTR _r$2[ebp+4], ecx
  0063a	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  00640	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00645	f3 0f 5c 85 ac
	fe ff ff	 subss	 xmm0, DWORD PTR _clip_off$[ebp]
  0064d	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00651	89 8d 6c fe ff
	ff		 mov	 DWORD PTR _r$2[ebp+8], ecx
  00657	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  0065d	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00662	f3 0f 5c 85 b0
	fe ff ff	 subss	 xmm0, DWORD PTR _clip_off$[ebp+4]
  0066a	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0066e	89 8d 70 fe ff
	ff		 mov	 DWORD PTR _r$2[ebp+12], ecx

; 199  :                 const LPDIRECT3DTEXTURE9 texture = (LPDIRECT3DTEXTURE9)pcmd->TextureId;

  00674	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  0067a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0067d	89 8d 58 fe ff
	ff		 mov	 DWORD PTR _texture$1[ebp], ecx

; 200  :                 g_pd3dDevice->SetTexture(0, texture);

  00683	8b f4		 mov	 esi, esp
  00685	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _texture$1[ebp]
  0068b	50		 push	 eax
  0068c	6a 00		 push	 0
  0068e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00694	8b 11		 mov	 edx, DWORD PTR [ecx]
  00696	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0069b	50		 push	 eax
  0069c	8b 8a 04 01 00
	00		 mov	 ecx, DWORD PTR [edx+260]
  006a2	ff d1		 call	 ecx
  006a4	3b f4		 cmp	 esi, esp
  006a6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 201  :                 g_pd3dDevice->SetScissorRect(&r);

  006ab	8b f4		 mov	 esi, esp
  006ad	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _r$2[ebp]
  006b3	50		 push	 eax
  006b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  006ba	8b 11		 mov	 edx, DWORD PTR [ecx]
  006bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  006c1	50		 push	 eax
  006c2	8b 8a 2c 01 00
	00		 mov	 ecx, DWORD PTR [edx+300]
  006c8	ff d1		 call	 ecx
  006ca	3b f4		 cmp	 esi, esp
  006cc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 202  :                 g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, pcmd->VtxOffset + global_vtx_offset, 0, (UINT)cmd_list->VtxBuffer.Size, pcmd->IdxOffset + global_idx_offset, pcmd->ElemCount/3);

  006d1	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  006d7	8b 00		 mov	 eax, DWORD PTR [eax]
  006d9	33 d2		 xor	 edx, edx
  006db	b9 03 00 00 00	 mov	 ecx, 3
  006e0	f7 f1		 div	 ecx
  006e2	8b f4		 mov	 esi, esp
  006e4	50		 push	 eax
  006e5	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _pcmd$3[ebp]
  006eb	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  006ee	03 85 bc fe ff
	ff		 add	 eax, DWORD PTR _global_idx_offset$[ebp]
  006f4	50		 push	 eax
  006f5	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _cmd_list$5[ebp]
  006fb	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006fe	52		 push	 edx
  006ff	6a 00		 push	 0
  00701	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _pcmd$3[ebp]
  00707	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0070a	03 8d c8 fe ff
	ff		 add	 ecx, DWORD PTR _global_vtx_offset$[ebp]
  00710	51		 push	 ecx
  00711	6a 04		 push	 4
  00713	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00719	8b 02		 mov	 eax, DWORD PTR [edx]
  0071b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00721	51		 push	 ecx
  00722	8b 90 48 01 00
	00		 mov	 edx, DWORD PTR [eax+328]
  00728	ff d2		 call	 edx
  0072a	3b f4		 cmp	 esi, esp
  0072c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN28@ImGui_Impl:

; 203  :             }
; 204  :         }

  00731	e9 3f fe ff ff	 jmp	 $LN11@ImGui_Impl
$LN12@ImGui_Impl:

; 205  :         global_idx_offset += cmd_list->IdxBuffer.Size;

  00736	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _cmd_list$5[ebp]
  0073c	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR _global_idx_offset$[ebp]
  00742	03 48 0c	 add	 ecx, DWORD PTR [eax+12]
  00745	89 8d bc fe ff
	ff		 mov	 DWORD PTR _global_idx_offset$[ebp], ecx

; 206  :         global_vtx_offset += cmd_list->VtxBuffer.Size;

  0074b	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _cmd_list$5[ebp]
  00751	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _global_vtx_offset$[ebp]
  00757	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  0075a	89 8d c8 fe ff
	ff		 mov	 DWORD PTR _global_vtx_offset$[ebp], ecx

; 207  :     }

  00760	e9 ce fd ff ff	 jmp	 $LN8@ImGui_Impl
$LN9@ImGui_Impl:

; 208  : 
; 209  :     // Restore the DX9 transform
; 210  :     g_pd3dDevice->SetTransform(D3DTS_WORLD, &last_world);

  00765	8b f4		 mov	 esi, esp
  00767	8d 45 ac	 lea	 eax, DWORD PTR _last_world$[ebp]
  0076a	50		 push	 eax
  0076b	68 00 01 00 00	 push	 256			; 00000100H
  00770	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00776	8b 11		 mov	 edx, DWORD PTR [ecx]
  00778	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0077d	50		 push	 eax
  0077e	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  00784	ff d1		 call	 ecx
  00786	3b f4		 cmp	 esi, esp
  00788	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 211  :     g_pd3dDevice->SetTransform(D3DTS_VIEW, &last_view);

  0078d	8b f4		 mov	 esi, esp
  0078f	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _last_view$[ebp]
  00795	50		 push	 eax
  00796	6a 02		 push	 2
  00798	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0079e	8b 11		 mov	 edx, DWORD PTR [ecx]
  007a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  007a5	50		 push	 eax
  007a6	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  007ac	ff d1		 call	 ecx
  007ae	3b f4		 cmp	 esi, esp
  007b0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 212  :     g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &last_projection);

  007b5	8b f4		 mov	 esi, esp
  007b7	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _last_projection$[ebp]
  007bd	50		 push	 eax
  007be	6a 03		 push	 3
  007c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  007c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  007c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  007cd	50		 push	 eax
  007ce	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  007d4	ff d1		 call	 ecx
  007d6	3b f4		 cmp	 esi, esp
  007d8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 213  : 
; 214  :     // Restore the DX9 state
; 215  :     d3d9_state_block->Apply();

  007dd	8b 45 f4	 mov	 eax, DWORD PTR _d3d9_state_block$[ebp]
  007e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  007e2	8b f4		 mov	 esi, esp
  007e4	8b 55 f4	 mov	 edx, DWORD PTR _d3d9_state_block$[ebp]
  007e7	52		 push	 edx
  007e8	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  007eb	ff d0		 call	 eax
  007ed	3b f4		 cmp	 esi, esp
  007ef	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 216  :     d3d9_state_block->Release();

  007f4	8b 45 f4	 mov	 eax, DWORD PTR _d3d9_state_block$[ebp]
  007f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  007f9	8b f4		 mov	 esi, esp
  007fb	8b 55 f4	 mov	 edx, DWORD PTR _d3d9_state_block$[ebp]
  007fe	52		 push	 edx
  007ff	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00802	ff d0		 call	 eax
  00804	3b f4		 cmp	 esi, esp
  00806	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@ImGui_Impl:

; 217  : }

  0080b	52		 push	 edx
  0080c	8b cd		 mov	 ecx, ebp
  0080e	50		 push	 eax
  0080f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN41@ImGui_Impl
  00815	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0081a	58		 pop	 eax
  0081b	5a		 pop	 edx
  0081c	5f		 pop	 edi
  0081d	5e		 pop	 esi
  0081e	5b		 pop	 ebx
  0081f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00822	33 cd		 xor	 ecx, ebp
  00824	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00829	81 c4 6c 02 00
	00		 add	 esp, 620		; 0000026cH
  0082f	3b ec		 cmp	 ebp, esp
  00831	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00836	8b e5		 mov	 esp, ebp
  00838	5d		 pop	 ebp
  00839	c3		 ret	 0
  0083a	66 90		 npad	 2
$LN41@ImGui_Impl:
  0083c	08 00 00 00	 DD	 8
  00840	00 00 00 00	 DD	 $LN40@ImGui_Impl
$LN40@ImGui_Impl:
  00844	f4 ff ff ff	 DD	 -12			; fffffff4H
  00848	04 00 00 00	 DD	 4
  0084c	00 00 00 00	 DD	 $LN32@ImGui_Impl
  00850	ac ff ff ff	 DD	 -84			; ffffffacH
  00854	40 00 00 00	 DD	 64			; 00000040H
  00858	00 00 00 00	 DD	 $LN33@ImGui_Impl
  0085c	64 ff ff ff	 DD	 -156			; ffffff64H
  00860	40 00 00 00	 DD	 64			; 00000040H
  00864	00 00 00 00	 DD	 $LN34@ImGui_Impl
  00868	1c ff ff ff	 DD	 -228			; ffffff1cH
  0086c	40 00 00 00	 DD	 64			; 00000040H
  00870	00 00 00 00	 DD	 $LN35@ImGui_Impl
  00874	10 ff ff ff	 DD	 -240			; ffffff10H
  00878	04 00 00 00	 DD	 4
  0087c	00 00 00 00	 DD	 $LN36@ImGui_Impl
  00880	04 ff ff ff	 DD	 -252			; ffffff04H
  00884	04 00 00 00	 DD	 4
  00888	00 00 00 00	 DD	 $LN37@ImGui_Impl
  0088c	ac fe ff ff	 DD	 -340			; fffffeacH
  00890	08 00 00 00	 DD	 8
  00894	00 00 00 00	 DD	 $LN38@ImGui_Impl
  00898	64 fe ff ff	 DD	 -412			; fffffe64H
  0089c	10 00 00 00	 DD	 16			; 00000010H
  008a0	00 00 00 00	 DD	 $LN39@ImGui_Impl
$LN39@ImGui_Impl:
  008a4	72		 DB	 114			; 00000072H
  008a5	00		 DB	 0
$LN38@ImGui_Impl:
  008a6	63		 DB	 99			; 00000063H
  008a7	6c		 DB	 108			; 0000006cH
  008a8	69		 DB	 105			; 00000069H
  008a9	70		 DB	 112			; 00000070H
  008aa	5f		 DB	 95			; 0000005fH
  008ab	6f		 DB	 111			; 0000006fH
  008ac	66		 DB	 102			; 00000066H
  008ad	66		 DB	 102			; 00000066H
  008ae	00		 DB	 0
$LN37@ImGui_Impl:
  008af	69		 DB	 105			; 00000069H
  008b0	64		 DB	 100			; 00000064H
  008b1	78		 DB	 120			; 00000078H
  008b2	5f		 DB	 95			; 0000005fH
  008b3	64		 DB	 100			; 00000064H
  008b4	73		 DB	 115			; 00000073H
  008b5	74		 DB	 116			; 00000074H
  008b6	00		 DB	 0
$LN36@ImGui_Impl:
  008b7	76		 DB	 118			; 00000076H
  008b8	74		 DB	 116			; 00000074H
  008b9	78		 DB	 120			; 00000078H
  008ba	5f		 DB	 95			; 0000005fH
  008bb	64		 DB	 100			; 00000064H
  008bc	73		 DB	 115			; 00000073H
  008bd	74		 DB	 116			; 00000074H
  008be	00		 DB	 0
$LN35@ImGui_Impl:
  008bf	6c		 DB	 108			; 0000006cH
  008c0	61		 DB	 97			; 00000061H
  008c1	73		 DB	 115			; 00000073H
  008c2	74		 DB	 116			; 00000074H
  008c3	5f		 DB	 95			; 0000005fH
  008c4	70		 DB	 112			; 00000070H
  008c5	72		 DB	 114			; 00000072H
  008c6	6f		 DB	 111			; 0000006fH
  008c7	6a		 DB	 106			; 0000006aH
  008c8	65		 DB	 101			; 00000065H
  008c9	63		 DB	 99			; 00000063H
  008ca	74		 DB	 116			; 00000074H
  008cb	69		 DB	 105			; 00000069H
  008cc	6f		 DB	 111			; 0000006fH
  008cd	6e		 DB	 110			; 0000006eH
  008ce	00		 DB	 0
$LN34@ImGui_Impl:
  008cf	6c		 DB	 108			; 0000006cH
  008d0	61		 DB	 97			; 00000061H
  008d1	73		 DB	 115			; 00000073H
  008d2	74		 DB	 116			; 00000074H
  008d3	5f		 DB	 95			; 0000005fH
  008d4	76		 DB	 118			; 00000076H
  008d5	69		 DB	 105			; 00000069H
  008d6	65		 DB	 101			; 00000065H
  008d7	77		 DB	 119			; 00000077H
  008d8	00		 DB	 0
$LN33@ImGui_Impl:
  008d9	6c		 DB	 108			; 0000006cH
  008da	61		 DB	 97			; 00000061H
  008db	73		 DB	 115			; 00000073H
  008dc	74		 DB	 116			; 00000074H
  008dd	5f		 DB	 95			; 0000005fH
  008de	77		 DB	 119			; 00000077H
  008df	6f		 DB	 111			; 0000006fH
  008e0	72		 DB	 114			; 00000072H
  008e1	6c		 DB	 108			; 0000006cH
  008e2	64		 DB	 100			; 00000064H
  008e3	00		 DB	 0
$LN32@ImGui_Impl:
  008e4	64		 DB	 100			; 00000064H
  008e5	33		 DB	 51			; 00000033H
  008e6	64		 DB	 100			; 00000064H
  008e7	39		 DB	 57			; 00000039H
  008e8	5f		 DB	 95			; 0000005fH
  008e9	73		 DB	 115			; 00000073H
  008ea	74		 DB	 116			; 00000074H
  008eb	61		 DB	 97			; 00000061H
  008ec	74		 DB	 116			; 00000074H
  008ed	65		 DB	 101			; 00000065H
  008ee	5f		 DB	 95			; 0000005fH
  008ef	62		 DB	 98			; 00000062H
  008f0	6c		 DB	 108			; 0000006cH
  008f1	6f		 DB	 111			; 0000006fH
  008f2	63		 DB	 99			; 00000063H
  008f3	6b		 DB	 107			; 0000006bH
  008f4	00		 DB	 0
?ImGui_ImplDX9_RenderDrawData@@YAXPAUImDrawData@@@Z ENDP ; ImGui_ImplDX9_RenderDrawData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_NewFrame@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplDX9_NewFrame@@YAXXZ PROC			; ImGui_ImplDX9_NewFrame, COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 282  :     if (!g_FontTexture)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A, 0
  0002f	75 05		 jne	 SHORT $LN1@ImGui_Impl

; 283  :         ImGui_ImplDX9_CreateDeviceObjects();

  00031	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ ; ImGui_ImplDX9_CreateDeviceObjects
$LN1@ImGui_Impl:

; 284  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?ImGui_ImplDX9_NewFrame@@YAXXZ ENDP			; ImGui_ImplDX9_NewFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_Shutdown@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplDX9_Shutdown@@YAXXZ PROC			; ImGui_ImplDX9_Shutdown, COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 233  :     ImGui_ImplDX9_InvalidateDeviceObjects();

  00028	e8 00 00 00 00	 call	 ?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXXZ ; ImGui_ImplDX9_InvalidateDeviceObjects

; 234  :     if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = NULL; }

  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, 0
  00034	74 26		 je	 SHORT $LN1@ImGui_Impl
  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8b f4		 mov	 esi, esp
  0003f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00045	52		 push	 edx
  00046	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00049	ff d0		 call	 eax
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, 0
$LN1@ImGui_Impl:

; 235  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?ImGui_ImplDX9_Shutdown@@YAXXZ ENDP			; ImGui_ImplDX9_Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_dx9.cpp
;	COMDAT ?ImGui_ImplDX9_Init@@YA_NPAUIDirect3DDevice9@@@Z
_TEXT	SEGMENT
_io$ = -8						; size = 4
_device$ = 8						; size = 4
?ImGui_ImplDX9_Init@@YA_NPAUIDirect3DDevice9@@@Z PROC	; ImGui_ImplDX9_Init, COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __2B73F502_imgui_impl_dx9@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 221  :     // Setup back-end capabilities flags
; 222  :     ImGuiIO& io = ImGui::GetIO();

  00028	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  0002d	89 45 f8	 mov	 DWORD PTR _io$[ebp], eax

; 223  :     io.BackendRendererName = "imgui_impl_dx9";

  00030	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00033	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+184], OFFSET ??_C@_0P@PJLJBPPP@imgui_impl_dx9@

; 224  :     io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	83 c9 08	 or	 ecx, 8
  00046	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00049	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 225  : 
; 226  :     g_pd3dDevice = device;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _device$[ebp]
  0004f	a3 00 00 00 00	 mov	 DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, eax

; 227  :     g_pd3dDevice->AddRef();

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b f4		 mov	 esi, esp
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A
  00063	52		 push	 edx
  00064	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00067	ff d0		 call	 eax
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 228  :     return true;

  00070	b0 01		 mov	 al, 1

; 229  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?ImGui_ImplDX9_Init@@YA_NPAUIDirect3DDevice9@@@Z ENDP	; ImGui_ImplDX9_Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT
; _this$ = ecx

; 1273 :     inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f9 04 00 00	 push	 1273			; 000004f9H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 28	 imul	 eax, DWORD PTR _i$[ebp], 40
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
END
