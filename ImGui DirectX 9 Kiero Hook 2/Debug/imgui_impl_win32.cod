; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__241EEA0C_corecrt_memory@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__8BAA8EBB_imgui@h DB 01H
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__692346AF_guiddef@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__2908CC08_winuser@h DB 01H
__08182E14_stralign@h DB 01H
__E356832D_mbstring@h DB 01H
__5039A673_tchar@h DB 01H
__3551C0EC_imgui_impl_win32@cpp DB 01H
msvcjmc	ENDS
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	?IsBuilt@ImFontAtlas@@QBE_NXZ			; ImFontAtlas::IsBuilt
PUBLIC	?ImGui_ImplWin32_Init@@YA_NPAX@Z		; ImGui_ImplWin32_Init
PUBLIC	?ImGui_ImplWin32_Shutdown@@YAXXZ		; ImGui_ImplWin32_Shutdown
PUBLIC	?ImGui_ImplWin32_NewFrame@@YAXXZ		; ImGui_ImplWin32_NewFrame
PUBLIC	?ImGui_ImplWin32_WndProcHandler@@YAJPAUHWND__@@IIJ@Z ; ImGui_ImplWin32_WndProcHandler
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BB@FLGJPPJK@imgui_impl_win32@		; `string'
PUBLIC	?__LINE__Var@?0??ImGui_ImplWin32_NewFrame@@YAXXZ@4JA ; `ImGui_ImplWin32_NewFrame'::`1'::__LINE__Var
PUBLIC	??_C@_0JI@BOCHPLMB@Font?5atlas?5not?5built?$CB?5It?5is?5gen@ ; `string'
PUBLIC	??_C@_1NE@DKPNOKMD@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1BGC@BEKJJODG@?$AAi?$AAo?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?9?$AA?$DO?$AAI?$AAs?$AAB?$AAu?$AAi@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@42f00000
PUBLIC	__real@46c2ac00
PUBLIC	__real@c6c2ac00
PUBLIC	__real@c6c2ae00
PUBLIC	__real@ff7fffff
EXTRN	_memset:PROC
EXTRN	__imp___wassert:PROC
EXTRN	?GetCurrentContext@ImGui@@YAPAUImGuiContext@@XZ:PROC ; ImGui::GetCurrentContext
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?IsAnyMouseDown@ImGui@@YA_NXZ:PROC		; ImGui::IsAnyMouseDown
EXTRN	?GetMouseCursor@ImGui@@YAHXZ:PROC		; ImGui::GetMouseCursor
EXTRN	?AddInputCharacter@ImGuiIO@@QAEXI@Z:PROC	; ImGuiIO::AddInputCharacter
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__IsChild@8:PROC
EXTRN	__imp__GetKeyState@4:PROC
EXTRN	__imp__GetCapture@0:PROC
EXTRN	__imp__SetCapture@4:PROC
EXTRN	__imp__ReleaseCapture@0:PROC
EXTRN	__imp__GetForegroundWindow@0:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__SetCursorPos@8:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	_XInputGetState@8:PROC
EXTRN	_XInputGetCapabilities@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__ltod3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_hWnd@@3PAUHWND__@@A DD 01H DUP (?)			; g_hWnd
	ALIGN	8

?g_Time@@3_JA DQ 01H DUP (?)				; g_Time
?g_TicksPerSecond@@3_JA DQ 01H DUP (?)			; g_TicksPerSecond
?g_HasGamepad@@3_NA DB 01H DUP (?)			; g_HasGamepad
_BSS	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+38
CONST	ENDS
;	COMDAT __real@c6c2ae00
CONST	SEGMENT
__real@c6c2ae00 DD 0c6c2ae00r			; -24919
CONST	ENDS
;	COMDAT __real@c6c2ac00
CONST	SEGMENT
__real@c6c2ac00 DD 0c6c2ac00r			; -24918
CONST	ENDS
;	COMDAT __real@46c2ac00
CONST	SEGMENT
__real@46c2ac00 DD 046c2ac00r			; 24918
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1BGC@BEKJJODG@?$AAi?$AAo?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?9?$AA?$DO?$AAI?$AAs?$AAB?$AAu?$AAi@
CONST	SEGMENT
??_C@_1BGC@BEKJJODG@?$AAi?$AAo?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?9?$AA?$DO?$AAI?$AAs?$AAB?$AAu?$AAi@ DB 'i'
	DB	00H, 'o', 00H, '.', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'I', 00H, 's', 00H, 'B', 00H, 'u'
	DB	00H, 'i', 00H, 'l', 00H, 't', 00H, '(', 00H, ')', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'F', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'b'
	DB	00H, 'u', 00H, 'i', 00H, 'l', 00H, 't', 00H, '!', 00H, ' ', 00H
	DB	'I', 00H, 't', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'g'
	DB	00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, 'y', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'i', 00H, 'l'
	DB	00H, 't', 00H, ' ', 00H, 'b', 00H, 'y', 00H, ' ', 00H, 't', 00H
	DB	'h', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, 'e', 00H, 'r', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'b', 00H
	DB	'a', 00H, 'c', 00H, 'k', 00H, '-', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, '.', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 's', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '_', 00H, 'N', 00H, 'e', 00H, 'w', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, '?', 00H, ' ', 00H, 'e', 00H, '.', 00H, 'g'
	DB	00H, '.', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H
	DB	'i', 00H, '_', 00H, 'I', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'O'
	DB	00H, 'p', 00H, 'e', 00H, 'n', 00H, 'G', 00H, 'L', 00H, '3', 00H
	DB	'_', 00H, 'N', 00H, 'e', 00H, 'w', 00H, 'F', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, '(', 00H, ')', 00H, '.', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@DKPNOKMD@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1NE@DKPNOKMD@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'P', 00H, 'r'
	DB	00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H, 'W', 00H
	DB	'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm', 00H, 'G'
	DB	00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 'r', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9', 00H, ' '
	DB	00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H
	DB	'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2', 00H, '\'
	DB	00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '\', 00H
	DB	'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, '_', 00H, 'w', 00H, 'i', 00H
	DB	'n', 00H, '3', 00H, '2', 00H, '.', 00H, 'c', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0JI@BOCHPLMB@Font?5atlas?5not?5built?$CB?5It?5is?5gen@
CONST	SEGMENT
??_C@_0JI@BOCHPLMB@Font?5atlas?5not?5built?$CB?5It?5is?5gen@ DB 'Font atl'
	DB	'as not built! It is generally built by the renderer back-end.'
	DB	' Missing call to renderer _NewFrame() function? e.g. ImGui_Im'
	DB	'plOpenGL3_NewFrame().', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ImGui_ImplWin32_NewFrame@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ImGui_ImplWin32_NewFrame@@YAXXZ@4JA DD 0ccH ; `ImGui_ImplWin32_NewFrame'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@FLGJPPJK@imgui_impl_win32@
CONST	SEGMENT
??_C@_0BB@FLGJPPJK@imgui_impl_win32@ DB 'imgui_impl_win32', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?g_LastMouseCursor@@3HA DD 09H				; g_LastMouseCursor
?g_WantUpdateHasGamepad@@3_NA DB 01H			; g_WantUpdateHasGamepad
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
;	COMDAT ?ImGui_ImplWin32_WndProcHandler@@YAJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv132 = -232						; size = 4
tv81 = -232						; size = 4
tv67 = -232						; size = 4
_button$1 = -32						; size = 4
_button$2 = -20						; size = 4
_io$ = -8						; size = 4
_hwnd$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?ImGui_ImplWin32_WndProcHandler@@YAJPAUHWND__@@IIJ@Z PROC ; ImGui_ImplWin32_WndProcHandler, COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __3551C0EC_imgui_impl_win32@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 258  :     if (ImGui::GetCurrentContext() == NULL)

  00028	e8 00 00 00 00	 call	 ?GetCurrentContext@ImGui@@YAPAUImGuiContext@@XZ ; ImGui::GetCurrentContext
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN4@ImGui_Impl

; 259  :         return 0;

  00031	33 c0		 xor	 eax, eax
  00033	e9 09 03 00 00	 jmp	 $LN1@ImGui_Impl
$LN4@ImGui_Impl:

; 260  : 
; 261  :     ImGuiIO& io = ImGui::GetIO();

  00038	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  0003d	89 45 f8	 mov	 DWORD PTR _io$[ebp], eax

; 262  :     switch (msg)

  00040	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00043	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  00049	81 bd 18 ff ff
	ff 01 02 00 00	 cmp	 DWORD PTR tv67[ebp], 513 ; 00000201H
  00053	77 3f		 ja	 SHORT $LN37@ImGui_Impl
  00055	81 bd 18 ff ff
	ff 01 02 00 00	 cmp	 DWORD PTR tv67[ebp], 513 ; 00000201H
  0005f	74 66		 je	 SHORT $LN5@ImGui_Impl
  00061	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  00067	83 e9 20	 sub	 ecx, 32			; 00000020H
  0006a	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  00070	81 bd 18 ff ff
	ff e5 00 00 00	 cmp	 DWORD PTR tv67[ebp], 229 ; 000000e5H
  0007a	0f 87 bf 02 00
	00		 ja	 $LN2@ImGui_Impl
  00080	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv67[ebp]
  00086	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN38@ImGui_Impl[edx]
  0008d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN39@ImGui_Impl[eax*4]
$LN37@ImGui_Impl:
  00094	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  0009a	81 e9 02 02 00
	00		 sub	 ecx, 514		; 00000202H
  000a0	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  000a6	83 bd 18 ff ff
	ff 17		 cmp	 DWORD PTR tv67[ebp], 23	; 00000017H
  000ad	0f 87 8c 02 00
	00		 ja	 $LN2@ImGui_Impl
  000b3	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv67[ebp]
  000b9	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN40@ImGui_Impl[edx]
  000c0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN41@ImGui_Impl[eax*4]
$LN5@ImGui_Impl:

; 263  :     {
; 264  :     case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
; 265  :     case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
; 266  :     case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
; 267  :     case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
; 268  :     {
; 269  :         int button = 0;

  000c7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _button$2[ebp], 0

; 270  :         if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) { button = 0; }

  000ce	81 7d 0c 01 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 513 ; 00000201H
  000d5	74 09		 je	 SHORT $LN7@ImGui_Impl
  000d7	81 7d 0c 03 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 515 ; 00000203H
  000de	75 07		 jne	 SHORT $LN6@ImGui_Impl
$LN7@ImGui_Impl:
  000e0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _button$2[ebp], 0
$LN6@ImGui_Impl:

; 271  :         if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) { button = 1; }

  000e7	81 7d 0c 04 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 516 ; 00000204H
  000ee	74 09		 je	 SHORT $LN9@ImGui_Impl
  000f0	81 7d 0c 06 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 518 ; 00000206H
  000f7	75 07		 jne	 SHORT $LN8@ImGui_Impl
$LN9@ImGui_Impl:
  000f9	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _button$2[ebp], 1
$LN8@ImGui_Impl:

; 272  :         if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) { button = 2; }

  00100	81 7d 0c 07 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 519 ; 00000207H
  00107	74 09		 je	 SHORT $LN11@ImGui_Impl
  00109	81 7d 0c 09 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 521 ; 00000209H
  00110	75 07		 jne	 SHORT $LN10@ImGui_Impl
$LN11@ImGui_Impl:
  00112	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _button$2[ebp], 2
$LN10@ImGui_Impl:

; 273  :         if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }

  00119	81 7d 0c 0b 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 523 ; 0000020bH
  00120	74 09		 je	 SHORT $LN13@ImGui_Impl
  00122	81 7d 0c 0d 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 525 ; 0000020dH
  00129	75 32		 jne	 SHORT $LN12@ImGui_Impl
$LN13@ImGui_Impl:
  0012b	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0012e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00131	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00136	0f b7 c8	 movzx	 ecx, ax
  00139	83 f9 01	 cmp	 ecx, 1
  0013c	75 0c		 jne	 SHORT $LN33@ImGui_Impl
  0013e	c7 85 18 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR tv81[ebp], 3
  00148	eb 0a		 jmp	 SHORT $LN34@ImGui_Impl
$LN33@ImGui_Impl:
  0014a	c7 85 18 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR tv81[ebp], 4
$LN34@ImGui_Impl:
  00154	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv81[ebp]
  0015a	89 55 ec	 mov	 DWORD PTR _button$2[ebp], edx
$LN12@ImGui_Impl:

; 274  :         if (!ImGui::IsAnyMouseDown() && ::GetCapture() == NULL)

  0015d	e8 00 00 00 00	 call	 ?IsAnyMouseDown@ImGui@@YA_NXZ ; ImGui::IsAnyMouseDown
  00162	0f b6 c0	 movzx	 eax, al
  00165	85 c0		 test	 eax, eax
  00167	75 26		 jne	 SHORT $LN14@ImGui_Impl
  00169	8b f4		 mov	 esi, esp
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCapture@0
  00171	3b f4		 cmp	 esi, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00178	85 c0		 test	 eax, eax
  0017a	75 13		 jne	 SHORT $LN14@ImGui_Impl

; 275  :             ::SetCapture(hwnd);

  0017c	8b f4		 mov	 esi, esp
  0017e	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00181	50		 push	 eax
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCapture@4
  00188	3b f4		 cmp	 esi, esp
  0018a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@ImGui_Impl:

; 276  :         io.MouseDown[button] = true;

  0018f	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00192	03 45 ec	 add	 eax, DWORD PTR _button$2[ebp]
  00195	c6 80 e8 00 00
	00 01		 mov	 BYTE PTR [eax+232], 1

; 277  :         return 0;

  0019c	33 c0		 xor	 eax, eax
  0019e	e9 9e 01 00 00	 jmp	 $LN1@ImGui_Impl
$LN15@ImGui_Impl:

; 278  :     }
; 279  :     case WM_LBUTTONUP:
; 280  :     case WM_RBUTTONUP:
; 281  :     case WM_MBUTTONUP:
; 282  :     case WM_XBUTTONUP:
; 283  :     {
; 284  :         int button = 0;

  001a3	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _button$1[ebp], 0

; 285  :         if (msg == WM_LBUTTONUP) { button = 0; }

  001aa	81 7d 0c 02 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 514 ; 00000202H
  001b1	75 07		 jne	 SHORT $LN16@ImGui_Impl
  001b3	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _button$1[ebp], 0
$LN16@ImGui_Impl:

; 286  :         if (msg == WM_RBUTTONUP) { button = 1; }

  001ba	81 7d 0c 05 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 517 ; 00000205H
  001c1	75 07		 jne	 SHORT $LN17@ImGui_Impl
  001c3	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _button$1[ebp], 1
$LN17@ImGui_Impl:

; 287  :         if (msg == WM_MBUTTONUP) { button = 2; }

  001ca	81 7d 0c 08 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 520 ; 00000208H
  001d1	75 07		 jne	 SHORT $LN18@ImGui_Impl
  001d3	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _button$1[ebp], 2
$LN18@ImGui_Impl:

; 288  :         if (msg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }

  001da	81 7d 0c 0c 02
	00 00		 cmp	 DWORD PTR _msg$[ebp], 524 ; 0000020cH
  001e1	75 32		 jne	 SHORT $LN19@ImGui_Impl
  001e3	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  001e6	c1 e8 10	 shr	 eax, 16			; 00000010H
  001e9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001ee	0f b7 c8	 movzx	 ecx, ax
  001f1	83 f9 01	 cmp	 ecx, 1
  001f4	75 0c		 jne	 SHORT $LN35@ImGui_Impl
  001f6	c7 85 18 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR tv132[ebp], 3
  00200	eb 0a		 jmp	 SHORT $LN36@ImGui_Impl
$LN35@ImGui_Impl:
  00202	c7 85 18 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR tv132[ebp], 4
$LN36@ImGui_Impl:
  0020c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv132[ebp]
  00212	89 55 e0	 mov	 DWORD PTR _button$1[ebp], edx
$LN19@ImGui_Impl:

; 289  :         io.MouseDown[button] = false;

  00215	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00218	03 45 e0	 add	 eax, DWORD PTR _button$1[ebp]
  0021b	c6 80 e8 00 00
	00 00		 mov	 BYTE PTR [eax+232], 0

; 290  :         if (!ImGui::IsAnyMouseDown() && ::GetCapture() == hwnd)

  00222	e8 00 00 00 00	 call	 ?IsAnyMouseDown@ImGui@@YA_NXZ ; ImGui::IsAnyMouseDown
  00227	0f b6 c0	 movzx	 eax, al
  0022a	85 c0		 test	 eax, eax
  0022c	75 23		 jne	 SHORT $LN20@ImGui_Impl
  0022e	8b f4		 mov	 esi, esp
  00230	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCapture@0
  00236	3b f4		 cmp	 esi, esp
  00238	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023d	3b 45 08	 cmp	 eax, DWORD PTR _hwnd$[ebp]
  00240	75 0f		 jne	 SHORT $LN20@ImGui_Impl

; 291  :             ::ReleaseCapture();

  00242	8b f4		 mov	 esi, esp
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0
  0024a	3b f4		 cmp	 esi, esp
  0024c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@ImGui_Impl:

; 292  :         return 0;

  00251	33 c0		 xor	 eax, eax
  00253	e9 e9 00 00 00	 jmp	 $LN1@ImGui_Impl
$LN21@ImGui_Impl:

; 293  :     }
; 294  :     case WM_MOUSEWHEEL:
; 295  :         io.MouseWheel += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;

  00258	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0025b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0025e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00263	0f bf c8	 movsx	 ecx, ax
  00266	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0026a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42f00000
  00272	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00275	f3 0f 58 82 f0
	00 00 00	 addss	 xmm0, DWORD PTR [edx+240]
  0027d	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00280	f3 0f 11 80 f0
	00 00 00	 movss	 DWORD PTR [eax+240], xmm0

; 296  :         return 0;

  00288	33 c0		 xor	 eax, eax
  0028a	e9 b2 00 00 00	 jmp	 $LN1@ImGui_Impl
$LN22@ImGui_Impl:

; 297  :     case WM_MOUSEHWHEEL:
; 298  :         io.MouseWheelH += (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA;

  0028f	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00292	c1 e8 10	 shr	 eax, 16			; 00000010H
  00295	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0029a	0f bf c8	 movsx	 ecx, ax
  0029d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  002a1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42f00000
  002a9	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  002ac	f3 0f 58 82 f4
	00 00 00	 addss	 xmm0, DWORD PTR [edx+244]
  002b4	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  002b7	f3 0f 11 80 f4
	00 00 00	 movss	 DWORD PTR [eax+244], xmm0

; 299  :         return 0;

  002bf	33 c0		 xor	 eax, eax
  002c1	eb 7e		 jmp	 SHORT $LN1@ImGui_Impl
$LN23@ImGui_Impl:

; 300  :     case WM_KEYDOWN:
; 301  :     case WM_SYSKEYDOWN:
; 302  :         if (wParam < 256)

  002c3	81 7d 10 00 01
	00 00		 cmp	 DWORD PTR _wParam$[ebp], 256 ; 00000100H
  002ca	73 0d		 jae	 SHORT $LN24@ImGui_Impl

; 303  :             io.KeysDown[wParam] = 1;

  002cc	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  002cf	03 45 10	 add	 eax, DWORD PTR _wParam$[ebp]
  002d2	c6 80 fc 00 00
	00 01		 mov	 BYTE PTR [eax+252], 1
$LN24@ImGui_Impl:

; 304  :         return 0;

  002d9	33 c0		 xor	 eax, eax
  002db	eb 64		 jmp	 SHORT $LN1@ImGui_Impl
$LN25@ImGui_Impl:

; 305  :     case WM_KEYUP:
; 306  :     case WM_SYSKEYUP:
; 307  :         if (wParam < 256)

  002dd	81 7d 10 00 01
	00 00		 cmp	 DWORD PTR _wParam$[ebp], 256 ; 00000100H
  002e4	73 0d		 jae	 SHORT $LN26@ImGui_Impl

; 308  :             io.KeysDown[wParam] = 0;

  002e6	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  002e9	03 45 10	 add	 eax, DWORD PTR _wParam$[ebp]
  002ec	c6 80 fc 00 00
	00 00		 mov	 BYTE PTR [eax+252], 0
$LN26@ImGui_Impl:

; 309  :         return 0;

  002f3	33 c0		 xor	 eax, eax
  002f5	eb 4a		 jmp	 SHORT $LN1@ImGui_Impl
$LN27@ImGui_Impl:

; 310  :     case WM_CHAR:
; 311  :         // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
; 312  :         io.AddInputCharacter((unsigned int)wParam);

  002f7	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  002fa	50		 push	 eax
  002fb	8b 4d f8	 mov	 ecx, DWORD PTR _io$[ebp]
  002fe	e8 00 00 00 00	 call	 ?AddInputCharacter@ImGuiIO@@QAEXI@Z ; ImGuiIO::AddInputCharacter

; 313  :         return 0;

  00303	33 c0		 xor	 eax, eax
  00305	eb 3a		 jmp	 SHORT $LN1@ImGui_Impl
$LN28@ImGui_Impl:

; 314  :     case WM_SETCURSOR:
; 315  :         if (LOWORD(lParam) == HTCLIENT && ImGui_ImplWin32_UpdateMouseCursor())

  00307	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0030a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0030f	0f b7 c8	 movzx	 ecx, ax
  00312	83 f9 01	 cmp	 ecx, 1
  00315	75 13		 jne	 SHORT $LN29@ImGui_Impl
  00317	e8 00 00 00 00	 call	 ?ImGui_ImplWin32_UpdateMouseCursor@@YA_NXZ ; ImGui_ImplWin32_UpdateMouseCursor
  0031c	0f b6 c0	 movzx	 eax, al
  0031f	85 c0		 test	 eax, eax
  00321	74 07		 je	 SHORT $LN29@ImGui_Impl

; 316  :             return 1;

  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	eb 17		 jmp	 SHORT $LN1@ImGui_Impl
$LN29@ImGui_Impl:

; 317  :         return 0;

  0032a	33 c0		 xor	 eax, eax
  0032c	eb 13		 jmp	 SHORT $LN1@ImGui_Impl
$LN30@ImGui_Impl:

; 318  :     case WM_DEVICECHANGE:
; 319  :         if ((UINT)wParam == DBT_DEVNODES_CHANGED)

  0032e	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  00332	75 07		 jne	 SHORT $LN31@ImGui_Impl

; 320  :             g_WantUpdateHasGamepad = true;

  00334	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_WantUpdateHasGamepad@@3_NA, 1
$LN31@ImGui_Impl:

; 321  :         return 0;

  0033b	33 c0		 xor	 eax, eax
  0033d	eb 02		 jmp	 SHORT $LN1@ImGui_Impl
$LN2@ImGui_Impl:

; 322  :     }
; 323  :     return 0;

  0033f	33 c0		 xor	 eax, eax
$LN1@ImGui_Impl:

; 324  : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0034a	3b ec		 cmp	 ebp, esp
  0034c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00351	8b e5		 mov	 esp, ebp
  00353	5d		 pop	 ebp
  00354	c3		 ret	 0
  00355	0f 1f 00	 npad	 3
$LN39@ImGui_Impl:
  00358	00 00 00 00	 DD	 $LN28@ImGui_Impl
  0035c	00 00 00 00	 DD	 $LN23@ImGui_Impl
  00360	00 00 00 00	 DD	 $LN25@ImGui_Impl
  00364	00 00 00 00	 DD	 $LN27@ImGui_Impl
  00368	00 00 00 00	 DD	 $LN2@ImGui_Impl
$LN38@ImGui_Impl:
  0036c	00		 DB	 0
  0036d	04		 DB	 4
  0036e	04		 DB	 4
  0036f	04		 DB	 4
  00370	04		 DB	 4
  00371	04		 DB	 4
  00372	04		 DB	 4
  00373	04		 DB	 4
  00374	04		 DB	 4
  00375	04		 DB	 4
  00376	04		 DB	 4
  00377	04		 DB	 4
  00378	04		 DB	 4
  00379	04		 DB	 4
  0037a	04		 DB	 4
  0037b	04		 DB	 4
  0037c	04		 DB	 4
  0037d	04		 DB	 4
  0037e	04		 DB	 4
  0037f	04		 DB	 4
  00380	04		 DB	 4
  00381	04		 DB	 4
  00382	04		 DB	 4
  00383	04		 DB	 4
  00384	04		 DB	 4
  00385	04		 DB	 4
  00386	04		 DB	 4
  00387	04		 DB	 4
  00388	04		 DB	 4
  00389	04		 DB	 4
  0038a	04		 DB	 4
  0038b	04		 DB	 4
  0038c	04		 DB	 4
  0038d	04		 DB	 4
  0038e	04		 DB	 4
  0038f	04		 DB	 4
  00390	04		 DB	 4
  00391	04		 DB	 4
  00392	04		 DB	 4
  00393	04		 DB	 4
  00394	04		 DB	 4
  00395	04		 DB	 4
  00396	04		 DB	 4
  00397	04		 DB	 4
  00398	04		 DB	 4
  00399	04		 DB	 4
  0039a	04		 DB	 4
  0039b	04		 DB	 4
  0039c	04		 DB	 4
  0039d	04		 DB	 4
  0039e	04		 DB	 4
  0039f	04		 DB	 4
  003a0	04		 DB	 4
  003a1	04		 DB	 4
  003a2	04		 DB	 4
  003a3	04		 DB	 4
  003a4	04		 DB	 4
  003a5	04		 DB	 4
  003a6	04		 DB	 4
  003a7	04		 DB	 4
  003a8	04		 DB	 4
  003a9	04		 DB	 4
  003aa	04		 DB	 4
  003ab	04		 DB	 4
  003ac	04		 DB	 4
  003ad	04		 DB	 4
  003ae	04		 DB	 4
  003af	04		 DB	 4
  003b0	04		 DB	 4
  003b1	04		 DB	 4
  003b2	04		 DB	 4
  003b3	04		 DB	 4
  003b4	04		 DB	 4
  003b5	04		 DB	 4
  003b6	04		 DB	 4
  003b7	04		 DB	 4
  003b8	04		 DB	 4
  003b9	04		 DB	 4
  003ba	04		 DB	 4
  003bb	04		 DB	 4
  003bc	04		 DB	 4
  003bd	04		 DB	 4
  003be	04		 DB	 4
  003bf	04		 DB	 4
  003c0	04		 DB	 4
  003c1	04		 DB	 4
  003c2	04		 DB	 4
  003c3	04		 DB	 4
  003c4	04		 DB	 4
  003c5	04		 DB	 4
  003c6	04		 DB	 4
  003c7	04		 DB	 4
  003c8	04		 DB	 4
  003c9	04		 DB	 4
  003ca	04		 DB	 4
  003cb	04		 DB	 4
  003cc	04		 DB	 4
  003cd	04		 DB	 4
  003ce	04		 DB	 4
  003cf	04		 DB	 4
  003d0	04		 DB	 4
  003d1	04		 DB	 4
  003d2	04		 DB	 4
  003d3	04		 DB	 4
  003d4	04		 DB	 4
  003d5	04		 DB	 4
  003d6	04		 DB	 4
  003d7	04		 DB	 4
  003d8	04		 DB	 4
  003d9	04		 DB	 4
  003da	04		 DB	 4
  003db	04		 DB	 4
  003dc	04		 DB	 4
  003dd	04		 DB	 4
  003de	04		 DB	 4
  003df	04		 DB	 4
  003e0	04		 DB	 4
  003e1	04		 DB	 4
  003e2	04		 DB	 4
  003e3	04		 DB	 4
  003e4	04		 DB	 4
  003e5	04		 DB	 4
  003e6	04		 DB	 4
  003e7	04		 DB	 4
  003e8	04		 DB	 4
  003e9	04		 DB	 4
  003ea	04		 DB	 4
  003eb	04		 DB	 4
  003ec	04		 DB	 4
  003ed	04		 DB	 4
  003ee	04		 DB	 4
  003ef	04		 DB	 4
  003f0	04		 DB	 4
  003f1	04		 DB	 4
  003f2	04		 DB	 4
  003f3	04		 DB	 4
  003f4	04		 DB	 4
  003f5	04		 DB	 4
  003f6	04		 DB	 4
  003f7	04		 DB	 4
  003f8	04		 DB	 4
  003f9	04		 DB	 4
  003fa	04		 DB	 4
  003fb	04		 DB	 4
  003fc	04		 DB	 4
  003fd	04		 DB	 4
  003fe	04		 DB	 4
  003ff	04		 DB	 4
  00400	04		 DB	 4
  00401	04		 DB	 4
  00402	04		 DB	 4
  00403	04		 DB	 4
  00404	04		 DB	 4
  00405	04		 DB	 4
  00406	04		 DB	 4
  00407	04		 DB	 4
  00408	04		 DB	 4
  00409	04		 DB	 4
  0040a	04		 DB	 4
  0040b	04		 DB	 4
  0040c	04		 DB	 4
  0040d	04		 DB	 4
  0040e	04		 DB	 4
  0040f	04		 DB	 4
  00410	04		 DB	 4
  00411	04		 DB	 4
  00412	04		 DB	 4
  00413	04		 DB	 4
  00414	04		 DB	 4
  00415	04		 DB	 4
  00416	04		 DB	 4
  00417	04		 DB	 4
  00418	04		 DB	 4
  00419	04		 DB	 4
  0041a	04		 DB	 4
  0041b	04		 DB	 4
  0041c	04		 DB	 4
  0041d	04		 DB	 4
  0041e	04		 DB	 4
  0041f	04		 DB	 4
  00420	04		 DB	 4
  00421	04		 DB	 4
  00422	04		 DB	 4
  00423	04		 DB	 4
  00424	04		 DB	 4
  00425	04		 DB	 4
  00426	04		 DB	 4
  00427	04		 DB	 4
  00428	04		 DB	 4
  00429	04		 DB	 4
  0042a	04		 DB	 4
  0042b	04		 DB	 4
  0042c	04		 DB	 4
  0042d	04		 DB	 4
  0042e	04		 DB	 4
  0042f	04		 DB	 4
  00430	04		 DB	 4
  00431	04		 DB	 4
  00432	04		 DB	 4
  00433	04		 DB	 4
  00434	04		 DB	 4
  00435	04		 DB	 4
  00436	04		 DB	 4
  00437	04		 DB	 4
  00438	04		 DB	 4
  00439	04		 DB	 4
  0043a	04		 DB	 4
  0043b	04		 DB	 4
  0043c	04		 DB	 4
  0043d	04		 DB	 4
  0043e	04		 DB	 4
  0043f	04		 DB	 4
  00440	04		 DB	 4
  00441	04		 DB	 4
  00442	04		 DB	 4
  00443	04		 DB	 4
  00444	04		 DB	 4
  00445	04		 DB	 4
  00446	04		 DB	 4
  00447	04		 DB	 4
  00448	04		 DB	 4
  00449	04		 DB	 4
  0044a	04		 DB	 4
  0044b	04		 DB	 4
  0044c	01		 DB	 1
  0044d	02		 DB	 2
  0044e	03		 DB	 3
  0044f	04		 DB	 4
  00450	01		 DB	 1
  00451	02		 DB	 2
  00452	66 90		 npad	 2
$LN41@ImGui_Impl:
  00454	00 00 00 00	 DD	 $LN15@ImGui_Impl
  00458	00 00 00 00	 DD	 $LN5@ImGui_Impl
  0045c	00 00 00 00	 DD	 $LN21@ImGui_Impl
  00460	00 00 00 00	 DD	 $LN22@ImGui_Impl
  00464	00 00 00 00	 DD	 $LN30@ImGui_Impl
  00468	00 00 00 00	 DD	 $LN2@ImGui_Impl
$LN40@ImGui_Impl:
  0046c	00		 DB	 0
  0046d	01		 DB	 1
  0046e	01		 DB	 1
  0046f	00		 DB	 0
  00470	01		 DB	 1
  00471	01		 DB	 1
  00472	00		 DB	 0
  00473	01		 DB	 1
  00474	02		 DB	 2
  00475	01		 DB	 1
  00476	00		 DB	 0
  00477	01		 DB	 1
  00478	03		 DB	 3
  00479	05		 DB	 5
  0047a	05		 DB	 5
  0047b	05		 DB	 5
  0047c	05		 DB	 5
  0047d	05		 DB	 5
  0047e	05		 DB	 5
  0047f	05		 DB	 5
  00480	05		 DB	 5
  00481	05		 DB	 5
  00482	05		 DB	 5
  00483	04		 DB	 4
?ImGui_ImplWin32_WndProcHandler@@YAJPAUHWND__@@IIJ@Z ENDP ; ImGui_ImplWin32_WndProcHandler
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
;	COMDAT ?ImGui_ImplWin32_UpdateGamepads@@YAXXZ
_TEXT	SEGMENT
tv220 = -324						; size = 4
tv212 = -324						; size = 4
tv204 = -324						; size = 4
tv196 = -324						; size = 4
tv188 = -324						; size = 4
tv180 = -324						; size = 4
tv172 = -324						; size = 4
tv164 = -324						; size = 4
tv156 = -324						; size = 4
tv148 = -324						; size = 4
tv140 = -324						; size = 4
tv132 = -324						; size = 4
tv79 = -324						; size = 4
_vn$1 = -124						; size = 4
_vn$2 = -112						; size = 4
_vn$3 = -100						; size = 4
_vn$4 = -88						; size = 4
_gamepad$5 = -76					; size = 4
_xinput_state$ = -64					; size = 16
_caps$6 = -40						; size = 20
_io$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?ImGui_ImplWin32_UpdateGamepads@@YAXXZ PROC		; ImGui_ImplWin32_UpdateGamepads, COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd bc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-324]
  00012	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __3551C0EC_imgui_impl_win32@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 159  :     ImGuiIO& io = ImGui::GetIO();

  00032	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  00037	89 45 f4	 mov	 DWORD PTR _io$[ebp], eax

; 160  :     memset(io.NavInputs, 0, sizeof(io.NavInputs));

  0003a	6a 54		 push	 84			; 00000054H
  0003c	6a 00		 push	 0
  0003e	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  00041	05 fc 02 00 00	 add	 eax, 764		; 000002fcH
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _memset
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  :     if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0)

  0004f	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	83 e1 02	 and	 ecx, 2
  00057	75 05		 jne	 SHORT $LN2@ImGui_Impl

; 162  :         return;

  00059	e9 ba 05 00 00	 jmp	 $LN1@ImGui_Impl
$LN2@ImGui_Impl:

; 163  : 
; 164  :     // Calling XInputGetState() every frame on disconnected gamepads is unfortunately too slow.
; 165  :     // Instead we refresh gamepad availability by calling XInputGetCapabilities() _only_ after receiving WM_DEVICECHANGE.
; 166  :     if (g_WantUpdateHasGamepad)

  0005e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?g_WantUpdateHasGamepad@@3_NA
  00065	85 c0		 test	 eax, eax
  00067	74 3a		 je	 SHORT $LN3@ImGui_Impl

; 167  :     {
; 168  :         XINPUT_CAPABILITIES caps;
; 169  :         g_HasGamepad = (XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &caps) == ERROR_SUCCESS);

  00069	8d 45 d8	 lea	 eax, DWORD PTR _caps$6[ebp]
  0006c	50		 push	 eax
  0006d	6a 01		 push	 1
  0006f	6a 00		 push	 0
  00071	e8 00 00 00 00	 call	 _XInputGetCapabilities@12
  00076	85 c0		 test	 eax, eax
  00078	75 0c		 jne	 SHORT $LN14@ImGui_Impl
  0007a	c7 85 bc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv79[ebp], 1
  00084	eb 0a		 jmp	 SHORT $LN15@ImGui_Impl
$LN14@ImGui_Impl:
  00086	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
$LN15@ImGui_Impl:
  00090	8a 8d bc fe ff
	ff		 mov	 cl, BYTE PTR tv79[ebp]
  00096	88 0d 00 00 00
	00		 mov	 BYTE PTR ?g_HasGamepad@@3_NA, cl

; 170  :         g_WantUpdateHasGamepad = false;

  0009c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_WantUpdateHasGamepad@@3_NA, 0
$LN3@ImGui_Impl:

; 171  :     }
; 172  : 
; 173  :     XINPUT_STATE xinput_state;
; 174  :     io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;

  000a3	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  000a6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a9	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000ac	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  000af	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 175  :     if (g_HasGamepad && XInputGetState(0, &xinput_state) == ERROR_SUCCESS)

  000b2	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?g_HasGamepad@@3_NA
  000b9	85 c0		 test	 eax, eax
  000bb	0f 84 57 05 00
	00		 je	 $LN12@ImGui_Impl
  000c1	8d 45 c0	 lea	 eax, DWORD PTR _xinput_state$[ebp]
  000c4	50		 push	 eax
  000c5	6a 00		 push	 0
  000c7	e8 00 00 00 00	 call	 _XInputGetState@8
  000cc	85 c0		 test	 eax, eax
  000ce	0f 85 44 05 00
	00		 jne	 $LN12@ImGui_Impl

; 176  :     {
; 177  :         const XINPUT_GAMEPAD& gamepad = xinput_state.Gamepad;

  000d4	8d 45 c4	 lea	 eax, DWORD PTR _xinput_state$[ebp+4]
  000d7	89 45 b4	 mov	 DWORD PTR _gamepad$5[ebp], eax

; 178  :         io.BackendFlags |= ImGuiBackendFlags_HasGamepad;

  000da	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  000dd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e0	83 c9 01	 or	 ecx, 1
  000e3	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  000e6	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 179  : 
; 180  :         #define MAP_BUTTON(NAV_NO, BUTTON_ENUM)     { io.NavInputs[NAV_NO] = (gamepad.wButtons & BUTTON_ENUM) ? 1.0f : 0.0f; }
; 181  :         #define MAP_ANALOG(NAV_NO, VALUE, V0, V1)   { float vn = (float)(VALUE - V0) / (float)(V1 - V0); if (vn > 1.0f) vn = 1.0f; if (vn > 0.0f && io.NavInputs[NAV_NO] < vn) io.NavInputs[NAV_NO] = vn; }
; 182  :         MAP_BUTTON(ImGuiNavInput_Activate,      XINPUT_GAMEPAD_A);              // Cross / A

  000e9	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  000ec	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000ef	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  000f5	74 12		 je	 SHORT $LN16@ImGui_Impl
  000f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ff	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv132[ebp], xmm0
  00107	eb 0b		 jmp	 SHORT $LN17@ImGui_Impl
$LN16@ImGui_Impl:
  00109	0f 57 c0	 xorps	 xmm0, xmm0
  0010c	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv132[ebp], xmm0
$LN17@ImGui_Impl:
  00114	ba 04 00 00 00	 mov	 edx, 4
  00119	6b c2 00	 imul	 eax, edx, 0
  0011c	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  0011f	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv132[ebp]
  00127	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 183  :         MAP_BUTTON(ImGuiNavInput_Cancel,        XINPUT_GAMEPAD_B);              // Circle / B

  00130	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  00133	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00136	81 e1 00 20 00
	00		 and	 ecx, 8192		; 00002000H
  0013c	74 12		 je	 SHORT $LN18@ImGui_Impl
  0013e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00146	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv140[ebp], xmm0
  0014e	eb 0b		 jmp	 SHORT $LN19@ImGui_Impl
$LN18@ImGui_Impl:
  00150	0f 57 c0	 xorps	 xmm0, xmm0
  00153	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv140[ebp], xmm0
$LN19@ImGui_Impl:
  0015b	ba 04 00 00 00	 mov	 edx, 4
  00160	c1 e2 00	 shl	 edx, 0
  00163	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  00166	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv140[ebp]
  0016e	f3 0f 11 84 10
	fc 02 00 00	 movss	 DWORD PTR [eax+edx+764], xmm0

; 184  :         MAP_BUTTON(ImGuiNavInput_Menu,          XINPUT_GAMEPAD_X);              // Square / X

  00177	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  0017a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0017d	81 e1 00 40 00
	00		 and	 ecx, 16384		; 00004000H
  00183	74 12		 je	 SHORT $LN20@ImGui_Impl
  00185	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0018d	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv148[ebp], xmm0
  00195	eb 0b		 jmp	 SHORT $LN21@ImGui_Impl
$LN20@ImGui_Impl:
  00197	0f 57 c0	 xorps	 xmm0, xmm0
  0019a	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv148[ebp], xmm0
$LN21@ImGui_Impl:
  001a2	ba 04 00 00 00	 mov	 edx, 4
  001a7	6b c2 03	 imul	 eax, edx, 3
  001aa	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  001ad	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv148[ebp]
  001b5	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 185  :         MAP_BUTTON(ImGuiNavInput_Input,         XINPUT_GAMEPAD_Y);              // Triangle / Y

  001be	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  001c1	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001c4	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  001ca	74 12		 je	 SHORT $LN22@ImGui_Impl
  001cc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001d4	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv156[ebp], xmm0
  001dc	eb 0b		 jmp	 SHORT $LN23@ImGui_Impl
$LN22@ImGui_Impl:
  001de	0f 57 c0	 xorps	 xmm0, xmm0
  001e1	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv156[ebp], xmm0
$LN23@ImGui_Impl:
  001e9	ba 04 00 00 00	 mov	 edx, 4
  001ee	d1 e2		 shl	 edx, 1
  001f0	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  001f3	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv156[ebp]
  001fb	f3 0f 11 84 10
	fc 02 00 00	 movss	 DWORD PTR [eax+edx+764], xmm0

; 186  :         MAP_BUTTON(ImGuiNavInput_DpadLeft,      XINPUT_GAMEPAD_DPAD_LEFT);      // D-Pad Left

  00204	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  00207	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0020a	83 e1 04	 and	 ecx, 4
  0020d	74 12		 je	 SHORT $LN24@ImGui_Impl
  0020f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00217	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv164[ebp], xmm0
  0021f	eb 0b		 jmp	 SHORT $LN25@ImGui_Impl
$LN24@ImGui_Impl:
  00221	0f 57 c0	 xorps	 xmm0, xmm0
  00224	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv164[ebp], xmm0
$LN25@ImGui_Impl:
  0022c	ba 04 00 00 00	 mov	 edx, 4
  00231	c1 e2 02	 shl	 edx, 2
  00234	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  00237	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv164[ebp]
  0023f	f3 0f 11 84 10
	fc 02 00 00	 movss	 DWORD PTR [eax+edx+764], xmm0

; 187  :         MAP_BUTTON(ImGuiNavInput_DpadRight,     XINPUT_GAMEPAD_DPAD_RIGHT);     // D-Pad Right

  00248	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  0024b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0024e	83 e1 08	 and	 ecx, 8
  00251	74 12		 je	 SHORT $LN26@ImGui_Impl
  00253	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0025b	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
  00263	eb 0b		 jmp	 SHORT $LN27@ImGui_Impl
$LN26@ImGui_Impl:
  00265	0f 57 c0	 xorps	 xmm0, xmm0
  00268	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
$LN27@ImGui_Impl:
  00270	ba 04 00 00 00	 mov	 edx, 4
  00275	6b c2 05	 imul	 eax, edx, 5
  00278	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  0027b	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv172[ebp]
  00283	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 188  :         MAP_BUTTON(ImGuiNavInput_DpadUp,        XINPUT_GAMEPAD_DPAD_UP);        // D-Pad Up

  0028c	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  0028f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00292	83 e1 01	 and	 ecx, 1
  00295	74 12		 je	 SHORT $LN28@ImGui_Impl
  00297	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0029f	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv180[ebp], xmm0
  002a7	eb 0b		 jmp	 SHORT $LN29@ImGui_Impl
$LN28@ImGui_Impl:
  002a9	0f 57 c0	 xorps	 xmm0, xmm0
  002ac	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv180[ebp], xmm0
$LN29@ImGui_Impl:
  002b4	ba 04 00 00 00	 mov	 edx, 4
  002b9	6b c2 06	 imul	 eax, edx, 6
  002bc	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  002bf	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv180[ebp]
  002c7	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 189  :         MAP_BUTTON(ImGuiNavInput_DpadDown,      XINPUT_GAMEPAD_DPAD_DOWN);      // D-Pad Down

  002d0	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  002d3	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002d6	83 e1 02	 and	 ecx, 2
  002d9	74 12		 je	 SHORT $LN30@ImGui_Impl
  002db	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002e3	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv188[ebp], xmm0
  002eb	eb 0b		 jmp	 SHORT $LN31@ImGui_Impl
$LN30@ImGui_Impl:
  002ed	0f 57 c0	 xorps	 xmm0, xmm0
  002f0	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv188[ebp], xmm0
$LN31@ImGui_Impl:
  002f8	ba 04 00 00 00	 mov	 edx, 4
  002fd	6b c2 07	 imul	 eax, edx, 7
  00300	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  00303	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv188[ebp]
  0030b	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 190  :         MAP_BUTTON(ImGuiNavInput_FocusPrev,     XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB

  00314	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  00317	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0031a	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  00320	74 12		 je	 SHORT $LN32@ImGui_Impl
  00322	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0032a	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv196[ebp], xmm0
  00332	eb 0b		 jmp	 SHORT $LN33@ImGui_Impl
$LN32@ImGui_Impl:
  00334	0f 57 c0	 xorps	 xmm0, xmm0
  00337	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv196[ebp], xmm0
$LN33@ImGui_Impl:
  0033f	ba 04 00 00 00	 mov	 edx, 4
  00344	6b c2 0c	 imul	 eax, edx, 12
  00347	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  0034a	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv196[ebp]
  00352	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 191  :         MAP_BUTTON(ImGuiNavInput_FocusNext,     XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB

  0035b	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  0035e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00361	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00367	74 12		 je	 SHORT $LN34@ImGui_Impl
  00369	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00371	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv204[ebp], xmm0
  00379	eb 0b		 jmp	 SHORT $LN35@ImGui_Impl
$LN34@ImGui_Impl:
  0037b	0f 57 c0	 xorps	 xmm0, xmm0
  0037e	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv204[ebp], xmm0
$LN35@ImGui_Impl:
  00386	ba 04 00 00 00	 mov	 edx, 4
  0038b	6b c2 0d	 imul	 eax, edx, 13
  0038e	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  00391	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv204[ebp]
  00399	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 192  :         MAP_BUTTON(ImGuiNavInput_TweakSlow,     XINPUT_GAMEPAD_LEFT_SHOULDER);  // L1 / LB

  003a2	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  003a5	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  003a8	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  003ae	74 12		 je	 SHORT $LN36@ImGui_Impl
  003b0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003b8	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv212[ebp], xmm0
  003c0	eb 0b		 jmp	 SHORT $LN37@ImGui_Impl
$LN36@ImGui_Impl:
  003c2	0f 57 c0	 xorps	 xmm0, xmm0
  003c5	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv212[ebp], xmm0
$LN37@ImGui_Impl:
  003cd	ba 04 00 00 00	 mov	 edx, 4
  003d2	6b c2 0e	 imul	 eax, edx, 14
  003d5	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  003d8	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv212[ebp]
  003e0	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 193  :         MAP_BUTTON(ImGuiNavInput_TweakFast,     XINPUT_GAMEPAD_RIGHT_SHOULDER); // R1 / RB

  003e9	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  003ec	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  003ef	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  003f5	74 12		 je	 SHORT $LN38@ImGui_Impl
  003f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003ff	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv220[ebp], xmm0
  00407	eb 0b		 jmp	 SHORT $LN39@ImGui_Impl
$LN38@ImGui_Impl:
  00409	0f 57 c0	 xorps	 xmm0, xmm0
  0040c	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv220[ebp], xmm0
$LN39@ImGui_Impl:
  00414	ba 04 00 00 00	 mov	 edx, 4
  00419	6b c2 0f	 imul	 eax, edx, 15
  0041c	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  0041f	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR tv220[ebp]
  00427	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0

; 194  :         MAP_ANALOG(ImGuiNavInput_LStickLeft,    gamepad.sThumbLX,  -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);

  00430	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  00433	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00437	81 c1 a9 1e 00
	00		 add	 ecx, 7849		; 00001ea9H
  0043d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00441	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@c6c2ae00
  00449	f3 0f 11 45 a8	 movss	 DWORD PTR _vn$4[ebp], xmm0
  0044e	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _vn$4[ebp]
  00453	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0045a	76 0d		 jbe	 SHORT $LN5@ImGui_Impl
  0045c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00464	f3 0f 11 45 a8	 movss	 DWORD PTR _vn$4[ebp], xmm0
$LN5@ImGui_Impl:
  00469	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _vn$4[ebp]
  0046e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00475	76 33		 jbe	 SHORT $LN6@ImGui_Impl
  00477	b8 04 00 00 00	 mov	 eax, 4
  0047c	c1 e0 03	 shl	 eax, 3
  0047f	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  00482	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _vn$4[ebp]
  00487	0f 2f 84 01 fc
	02 00 00	 comiss	 xmm0, DWORD PTR [ecx+eax+764]
  0048f	76 19		 jbe	 SHORT $LN6@ImGui_Impl
  00491	b8 04 00 00 00	 mov	 eax, 4
  00496	c1 e0 03	 shl	 eax, 3
  00499	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  0049c	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _vn$4[ebp]
  004a1	f3 0f 11 84 01
	fc 02 00 00	 movss	 DWORD PTR [ecx+eax+764], xmm0
$LN6@ImGui_Impl:

; 195  :         MAP_ANALOG(ImGuiNavInput_LStickRight,   gamepad.sThumbLX,  +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);

  004aa	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  004ad	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  004b1	81 e9 a9 1e 00
	00		 sub	 ecx, 7849		; 00001ea9H
  004b7	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  004bb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46c2ac00
  004c3	f3 0f 11 45 9c	 movss	 DWORD PTR _vn$3[ebp], xmm0
  004c8	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _vn$3[ebp]
  004cd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  004d4	76 0d		 jbe	 SHORT $LN7@ImGui_Impl
  004d6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004de	f3 0f 11 45 9c	 movss	 DWORD PTR _vn$3[ebp], xmm0
$LN7@ImGui_Impl:
  004e3	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _vn$3[ebp]
  004e8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  004ef	76 33		 jbe	 SHORT $LN8@ImGui_Impl
  004f1	b8 04 00 00 00	 mov	 eax, 4
  004f6	6b c8 09	 imul	 ecx, eax, 9
  004f9	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  004fc	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _vn$3[ebp]
  00501	0f 2f 84 0a fc
	02 00 00	 comiss	 xmm0, DWORD PTR [edx+ecx+764]
  00509	76 19		 jbe	 SHORT $LN8@ImGui_Impl
  0050b	b8 04 00 00 00	 mov	 eax, 4
  00510	6b c8 09	 imul	 ecx, eax, 9
  00513	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  00516	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _vn$3[ebp]
  0051b	f3 0f 11 84 0a
	fc 02 00 00	 movss	 DWORD PTR [edx+ecx+764], xmm0
$LN8@ImGui_Impl:

; 196  :         MAP_ANALOG(ImGuiNavInput_LStickUp,      gamepad.sThumbLY,  +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);

  00524	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  00527	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0052b	81 e9 a9 1e 00
	00		 sub	 ecx, 7849		; 00001ea9H
  00531	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00535	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46c2ac00
  0053d	f3 0f 11 45 90	 movss	 DWORD PTR _vn$2[ebp], xmm0
  00542	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _vn$2[ebp]
  00547	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0054e	76 0d		 jbe	 SHORT $LN9@ImGui_Impl
  00550	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00558	f3 0f 11 45 90	 movss	 DWORD PTR _vn$2[ebp], xmm0
$LN9@ImGui_Impl:
  0055d	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _vn$2[ebp]
  00562	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00569	76 33		 jbe	 SHORT $LN10@ImGui_Impl
  0056b	b8 04 00 00 00	 mov	 eax, 4
  00570	6b c8 0a	 imul	 ecx, eax, 10
  00573	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  00576	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _vn$2[ebp]
  0057b	0f 2f 84 0a fc
	02 00 00	 comiss	 xmm0, DWORD PTR [edx+ecx+764]
  00583	76 19		 jbe	 SHORT $LN10@ImGui_Impl
  00585	b8 04 00 00 00	 mov	 eax, 4
  0058a	6b c8 0a	 imul	 ecx, eax, 10
  0058d	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  00590	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _vn$2[ebp]
  00595	f3 0f 11 84 0a
	fc 02 00 00	 movss	 DWORD PTR [edx+ecx+764], xmm0
$LN10@ImGui_Impl:

; 197  :         MAP_ANALOG(ImGuiNavInput_LStickDown,    gamepad.sThumbLY,  -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32767);

  0059e	8b 45 b4	 mov	 eax, DWORD PTR _gamepad$5[ebp]
  005a1	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  005a5	81 c1 a9 1e 00
	00		 add	 ecx, 7849		; 00001ea9H
  005ab	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  005af	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@c6c2ac00
  005b7	f3 0f 11 45 84	 movss	 DWORD PTR _vn$1[ebp], xmm0
  005bc	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _vn$1[ebp]
  005c1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  005c8	76 0d		 jbe	 SHORT $LN11@ImGui_Impl
  005ca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005d2	f3 0f 11 45 84	 movss	 DWORD PTR _vn$1[ebp], xmm0
$LN11@ImGui_Impl:
  005d7	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _vn$1[ebp]
  005dc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  005e3	76 33		 jbe	 SHORT $LN12@ImGui_Impl
  005e5	b8 04 00 00 00	 mov	 eax, 4
  005ea	6b c8 0b	 imul	 ecx, eax, 11
  005ed	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  005f0	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _vn$1[ebp]
  005f5	0f 2f 84 0a fc
	02 00 00	 comiss	 xmm0, DWORD PTR [edx+ecx+764]
  005fd	76 19		 jbe	 SHORT $LN12@ImGui_Impl
  005ff	b8 04 00 00 00	 mov	 eax, 4
  00604	6b c8 0b	 imul	 ecx, eax, 11
  00607	8b 55 f4	 mov	 edx, DWORD PTR _io$[ebp]
  0060a	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _vn$1[ebp]
  0060f	f3 0f 11 84 0a
	fc 02 00 00	 movss	 DWORD PTR [edx+ecx+764], xmm0
$LN12@ImGui_Impl:
$LN1@ImGui_Impl:

; 198  :         #undef MAP_BUTTON
; 199  :         #undef MAP_ANALOG
; 200  :     }
; 201  : }

  00618	52		 push	 edx
  00619	8b cd		 mov	 ecx, ebp
  0061b	50		 push	 eax
  0061c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN43@ImGui_Impl
  00622	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00627	58		 pop	 eax
  00628	5a		 pop	 edx
  00629	5f		 pop	 edi
  0062a	5e		 pop	 esi
  0062b	5b		 pop	 ebx
  0062c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062f	33 cd		 xor	 ecx, ebp
  00631	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00636	81 c4 44 01 00
	00		 add	 esp, 324		; 00000144H
  0063c	3b ec		 cmp	 ebp, esp
  0063e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00643	8b e5		 mov	 esp, ebp
  00645	5d		 pop	 ebp
  00646	c3		 ret	 0
  00647	90		 npad	 1
$LN43@ImGui_Impl:
  00648	02 00 00 00	 DD	 2
  0064c	00 00 00 00	 DD	 $LN42@ImGui_Impl
$LN42@ImGui_Impl:
  00650	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00654	14 00 00 00	 DD	 20			; 00000014H
  00658	00 00 00 00	 DD	 $LN40@ImGui_Impl
  0065c	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00660	10 00 00 00	 DD	 16			; 00000010H
  00664	00 00 00 00	 DD	 $LN41@ImGui_Impl
$LN41@ImGui_Impl:
  00668	78		 DB	 120			; 00000078H
  00669	69		 DB	 105			; 00000069H
  0066a	6e		 DB	 110			; 0000006eH
  0066b	70		 DB	 112			; 00000070H
  0066c	75		 DB	 117			; 00000075H
  0066d	74		 DB	 116			; 00000074H
  0066e	5f		 DB	 95			; 0000005fH
  0066f	73		 DB	 115			; 00000073H
  00670	74		 DB	 116			; 00000074H
  00671	61		 DB	 97			; 00000061H
  00672	74		 DB	 116			; 00000074H
  00673	65		 DB	 101			; 00000065H
  00674	00		 DB	 0
$LN40@ImGui_Impl:
  00675	63		 DB	 99			; 00000063H
  00676	61		 DB	 97			; 00000061H
  00677	70		 DB	 112			; 00000070H
  00678	73		 DB	 115			; 00000073H
  00679	00		 DB	 0
?ImGui_ImplWin32_UpdateGamepads@@YAXXZ ENDP		; ImGui_ImplWin32_UpdateGamepads
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
;	COMDAT ?ImGui_ImplWin32_UpdateMousePos@@YAXXZ
_TEXT	SEGMENT
$T1 = -280						; size = 8
$T2 = -264						; size = 8
_active_window$3 = -56					; size = 4
_pos$ = -44						; size = 8
_pos$4 = -28						; size = 8
_io$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?ImGui_ImplWin32_UpdateMousePos@@YAXXZ PROC		; ImGui_ImplWin32_UpdateMousePos, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-284]
  00012	b9 47 00 00 00	 mov	 ecx, 71			; 00000047H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __3551C0EC_imgui_impl_win32@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 133  :     ImGuiIO& io = ImGui::GetIO();

  00032	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  00037	89 45 f4	 mov	 DWORD PTR _io$[ebp], eax

; 134  : 
; 135  :     // Set OS mouse position if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
; 136  :     if (io.WantSetMousePos)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  0003d	0f b6 88 53 03
	00 00		 movzx	 ecx, BYTE PTR [eax+851]
  00044	85 c9		 test	 ecx, ecx
  00046	74 4d		 je	 SHORT $LN2@ImGui_Impl

; 137  :     {
; 138  :         POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };

  00048	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  0004b	f3 0f 2c 88 e0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+224]
  00053	89 4d e4	 mov	 DWORD PTR _pos$4[ebp], ecx
  00056	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  00059	f3 0f 2c 88 e4
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+228]
  00061	89 4d e8	 mov	 DWORD PTR _pos$4[ebp+4], ecx

; 139  :         ::ClientToScreen(g_hWnd, &pos);

  00064	8b f4		 mov	 esi, esp
  00066	8d 45 e4	 lea	 eax, DWORD PTR _pos$4[ebp]
  00069	50		 push	 eax
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClientToScreen@8
  00077	3b f4		 cmp	 esi, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 140  :         ::SetCursorPos(pos.x, pos.y);

  0007e	8b f4		 mov	 esi, esp
  00080	8b 45 e8	 mov	 eax, DWORD PTR _pos$4[ebp+4]
  00083	50		 push	 eax
  00084	8b 4d e4	 mov	 ecx, DWORD PTR _pos$4[ebp]
  00087	51		 push	 ecx
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursorPos@8
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@ImGui_Impl:

; 141  :     }
; 142  : 
; 143  :     // Set mouse position
; 144  :     io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);

  00095	51		 push	 ecx
  00096	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  0009e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a3	51		 push	 ecx
  000a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  000ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b1	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b7	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  000c4	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx
  000ca	89 90 e4 00 00
	00		 mov	 DWORD PTR [eax+228], edx

; 145  :     POINT pos;
; 146  :     if (HWND active_window = ::GetForegroundWindow())

  000d0	8b f4		 mov	 esi, esp
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetForegroundWindow@0
  000d8	3b f4		 cmp	 esi, esp
  000da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000df	89 45 c8	 mov	 DWORD PTR _active_window$3[ebp], eax
  000e2	83 7d c8 00	 cmp	 DWORD PTR _active_window$3[ebp], 0
  000e6	0f 84 92 00 00
	00		 je	 $LN6@ImGui_Impl

; 147  :         if (active_window == g_hWnd || ::IsChild(active_window, g_hWnd))

  000ec	8b 45 c8	 mov	 eax, DWORD PTR _active_window$3[ebp]
  000ef	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A
  000f5	74 1d		 je	 SHORT $LN5@ImGui_Impl
  000f7	8b f4		 mov	 esi, esp
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A
  000fe	50		 push	 eax
  000ff	8b 4d c8	 mov	 ecx, DWORD PTR _active_window$3[ebp]
  00102	51		 push	 ecx
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsChild@8
  00109	3b f4		 cmp	 esi, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	85 c0		 test	 eax, eax
  00112	74 6a		 je	 SHORT $LN6@ImGui_Impl
$LN5@ImGui_Impl:

; 148  :             if (::GetCursorPos(&pos) && ::ScreenToClient(g_hWnd, &pos))

  00114	8b f4		 mov	 esi, esp
  00116	8d 45 d4	 lea	 eax, DWORD PTR _pos$[ebp]
  00119	50		 push	 eax
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4
  00120	3b f4		 cmp	 esi, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	85 c0		 test	 eax, eax
  00129	74 53		 je	 SHORT $LN6@ImGui_Impl
  0012b	8b f4		 mov	 esi, esp
  0012d	8d 45 d4	 lea	 eax, DWORD PTR _pos$[ebp]
  00130	50		 push	 eax
  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A
  00137	51		 push	 ecx
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ScreenToClient@8
  0013e	3b f4		 cmp	 esi, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00145	85 c0		 test	 eax, eax
  00147	74 35		 je	 SHORT $LN6@ImGui_Impl

; 149  :                 io.MousePos = ImVec2((float)pos.x, (float)pos.y);

  00149	f3 0f 2a 45 d8	 cvtsi2ss xmm0, DWORD PTR _pos$[ebp+4]
  0014e	51		 push	 ecx
  0014f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00154	f3 0f 2a 45 d4	 cvtsi2ss xmm0, DWORD PTR _pos$[ebp]
  00159	51		 push	 ecx
  0015a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015f	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00165	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0016f	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  00172	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx
  00178	89 90 e4 00 00
	00		 mov	 DWORD PTR [eax+228], edx
$LN6@ImGui_Impl:

; 150  : }

  0017e	52		 push	 edx
  0017f	8b cd		 mov	 ecx, ebp
  00181	50		 push	 eax
  00182	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@ImGui_Impl
  00188	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0018d	58		 pop	 eax
  0018e	5a		 pop	 edx
  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00195	33 cd		 xor	 ecx, ebp
  00197	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019c	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  001a2	3b ec		 cmp	 ebp, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c3		 ret	 0
  001ad	0f 1f 00	 npad	 3
$LN11@ImGui_Impl:
  001b0	02 00 00 00	 DD	 2
  001b4	00 00 00 00	 DD	 $LN10@ImGui_Impl
$LN10@ImGui_Impl:
  001b8	e4 ff ff ff	 DD	 -28			; ffffffe4H
  001bc	08 00 00 00	 DD	 8
  001c0	00 00 00 00	 DD	 $LN8@ImGui_Impl
  001c4	d4 ff ff ff	 DD	 -44			; ffffffd4H
  001c8	08 00 00 00	 DD	 8
  001cc	00 00 00 00	 DD	 $LN9@ImGui_Impl
$LN9@ImGui_Impl:
  001d0	70		 DB	 112			; 00000070H
  001d1	6f		 DB	 111			; 0000006fH
  001d2	73		 DB	 115			; 00000073H
  001d3	00		 DB	 0
$LN8@ImGui_Impl:
  001d4	70		 DB	 112			; 00000070H
  001d5	6f		 DB	 111			; 0000006fH
  001d6	73		 DB	 115			; 00000073H
  001d7	00		 DB	 0
?ImGui_ImplWin32_UpdateMousePos@@YAXXZ ENDP		; ImGui_ImplWin32_UpdateMousePos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
;	COMDAT ?ImGui_ImplWin32_UpdateMouseCursor@@YA_NXZ
_TEXT	SEGMENT
tv73 = -232						; size = 4
_win32_cursor$1 = -32					; size = 4
_imgui_cursor$ = -20					; size = 4
_io$ = -8						; size = 4
?ImGui_ImplWin32_UpdateMouseCursor@@YA_NXZ PROC		; ImGui_ImplWin32_UpdateMouseCursor, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __3551C0EC_imgui_impl_win32@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 100  :     ImGuiIO& io = ImGui::GetIO();

  00028	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  0002d	89 45 f8	 mov	 DWORD PTR _io$[ebp], eax

; 101  :     if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	83 e1 20	 and	 ecx, 32			; 00000020H
  00038	74 07		 je	 SHORT $LN4@ImGui_Impl

; 102  :         return false;

  0003a	32 c0		 xor	 al, al
  0003c	e9 ce 00 00 00	 jmp	 $LN1@ImGui_Impl
$LN4@ImGui_Impl:

; 103  : 
; 104  :     ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();

  00041	e8 00 00 00 00	 call	 ?GetMouseCursor@ImGui@@YAHXZ ; ImGui::GetMouseCursor
  00046	89 45 ec	 mov	 DWORD PTR _imgui_cursor$[ebp], eax

; 105  :     if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)

  00049	83 7d ec ff	 cmp	 DWORD PTR _imgui_cursor$[ebp], -1
  0004d	74 0e		 je	 SHORT $LN7@ImGui_Impl
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00052	0f b6 88 a8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+168]
  00059	85 c9		 test	 ecx, ecx
  0005b	74 16		 je	 SHORT $LN5@ImGui_Impl
$LN7@ImGui_Impl:

; 106  :     {
; 107  :         // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
; 108  :         ::SetCursor(NULL);

  0005d	8b f4		 mov	 esi, esp
  0005f	6a 00		 push	 0
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 109  :     }

  0006e	e9 9a 00 00 00	 jmp	 $LN6@ImGui_Impl
$LN5@ImGui_Impl:

; 110  :     else
; 111  :     {
; 112  :         // Show OS mouse cursor
; 113  :         LPTSTR win32_cursor = IDC_ARROW;

  00073	c7 45 e0 00 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32512 ; 00007f00H

; 114  :         switch (imgui_cursor)

  0007a	8b 45 ec	 mov	 eax, DWORD PTR _imgui_cursor$[ebp]
  0007d	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  00083	83 bd 18 ff ff
	ff 08		 cmp	 DWORD PTR tv73[ebp], 8
  0008a	77 5c		 ja	 SHORT $LN2@ImGui_Impl
  0008c	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN18@ImGui_Impl[ecx*4]
$LN8@ImGui_Impl:

; 115  :         {
; 116  :         case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;

  00099	c7 45 e0 00 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32512 ; 00007f00H
  000a0	eb 46		 jmp	 SHORT $LN2@ImGui_Impl
$LN9@ImGui_Impl:

; 117  :         case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;

  000a2	c7 45 e0 01 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32513 ; 00007f01H
  000a9	eb 3d		 jmp	 SHORT $LN2@ImGui_Impl
$LN10@ImGui_Impl:

; 118  :         case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;

  000ab	c7 45 e0 86 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32646 ; 00007f86H
  000b2	eb 34		 jmp	 SHORT $LN2@ImGui_Impl
$LN11@ImGui_Impl:

; 119  :         case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;

  000b4	c7 45 e0 84 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32644 ; 00007f84H
  000bb	eb 2b		 jmp	 SHORT $LN2@ImGui_Impl
$LN12@ImGui_Impl:

; 120  :         case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;

  000bd	c7 45 e0 85 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32645 ; 00007f85H
  000c4	eb 22		 jmp	 SHORT $LN2@ImGui_Impl
$LN13@ImGui_Impl:

; 121  :         case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;

  000c6	c7 45 e0 83 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32643 ; 00007f83H
  000cd	eb 19		 jmp	 SHORT $LN2@ImGui_Impl
$LN14@ImGui_Impl:

; 122  :         case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;

  000cf	c7 45 e0 82 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32642 ; 00007f82H
  000d6	eb 10		 jmp	 SHORT $LN2@ImGui_Impl
$LN15@ImGui_Impl:

; 123  :         case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;

  000d8	c7 45 e0 89 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32649 ; 00007f89H
  000df	eb 07		 jmp	 SHORT $LN2@ImGui_Impl
$LN16@ImGui_Impl:

; 124  :         case ImGuiMouseCursor_NotAllowed:   win32_cursor = IDC_NO; break;

  000e1	c7 45 e0 88 7f
	00 00		 mov	 DWORD PTR _win32_cursor$1[ebp], 32648 ; 00007f88H
$LN2@ImGui_Impl:

; 125  :         }
; 126  :         ::SetCursor(::LoadCursor(NULL, win32_cursor));

  000e8	8b f4		 mov	 esi, esp
  000ea	8b 45 e0	 mov	 eax, DWORD PTR _win32_cursor$1[ebp]
  000ed	50		 push	 eax
  000ee	6a 00		 push	 0
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  000f6	3b f4		 cmp	 esi, esp
  000f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fd	8b f4		 mov	 esi, esp
  000ff	50		 push	 eax
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
  00106	3b f4		 cmp	 esi, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@ImGui_Impl:

; 127  :     }
; 128  :     return true;

  0010d	b0 01		 mov	 al, 1
$LN1@ImGui_Impl:

; 129  : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00118	3b ec		 cmp	 ebp, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
  00123	90		 npad	 1
$LN18@ImGui_Impl:
  00124	00 00 00 00	 DD	 $LN8@ImGui_Impl
  00128	00 00 00 00	 DD	 $LN9@ImGui_Impl
  0012c	00 00 00 00	 DD	 $LN10@ImGui_Impl
  00130	00 00 00 00	 DD	 $LN12@ImGui_Impl
  00134	00 00 00 00	 DD	 $LN11@ImGui_Impl
  00138	00 00 00 00	 DD	 $LN13@ImGui_Impl
  0013c	00 00 00 00	 DD	 $LN14@ImGui_Impl
  00140	00 00 00 00	 DD	 $LN15@ImGui_Impl
  00144	00 00 00 00	 DD	 $LN16@ImGui_Impl
?ImGui_ImplWin32_UpdateMouseCursor@@YA_NXZ ENDP		; ImGui_ImplWin32_UpdateMouseCursor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
;	COMDAT ?ImGui_ImplWin32_NewFrame@@YAXXZ
_TEXT	SEGMENT
tv220 = -280						; size = 4
tv155 = -280						; size = 4
tv148 = -280						; size = 4
tv140 = -280						; size = 4
tv132 = -280						; size = 4
$T1 = -272						; size = 8
_mouse_cursor$ = -64					; size = 4
_current_time$ = -52					; size = 8
_rect$ = -36						; size = 16
_io$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?ImGui_ImplWin32_NewFrame@@YAXXZ PROC			; ImGui_ImplWin32_NewFrame, COMDAT

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __3551C0EC_imgui_impl_win32@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 205  :     ImGuiIO& io = ImGui::GetIO();

  00032	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  00037	89 45 f4	 mov	 DWORD PTR _io$[ebp], eax

; 206  :     IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  0003d	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  00043	e8 00 00 00 00	 call	 ?IsBuilt@ImFontAtlas@@QBE_NXZ ; ImFontAtlas::IsBuilt
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 09		 je	 SHORT $LN4@ImGui_Impl
  0004f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0JI@BOCHPLMB@Font?5atlas?5not?5built?$CB?5It?5is?5gen@
  00054	85 d2		 test	 edx, edx
  00056	75 25		 jne	 SHORT $LN5@ImGui_Impl
$LN4@ImGui_Impl:
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImGui_ImplWin32_NewFrame@@YAXXZ@4JA
  0005d	83 c0 02	 add	 eax, 2
  00060	8b f4		 mov	 esi, esp
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_1NE@DKPNOKMD@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_1BGC@BEKJJODG@?$AAi?$AAo?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?9?$AA?$DO?$AAI?$AAs?$AAB?$AAu?$AAi@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@ImGui_Impl:

; 207  : 
; 208  :     // Setup display size (every frame to accommodate for window resizing)
; 209  :     RECT rect;
; 210  :     ::GetClientRect(g_hWnd, &rect);

  0007d	8b f4		 mov	 esi, esp
  0007f	8d 45 dc	 lea	 eax, DWORD PTR _rect$[ebp]
  00082	50		 push	 eax
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_hWnd@@3PAUHWND__@@A
  00089	51		 push	 ecx
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00090	3b f4		 cmp	 esi, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 211  :     io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

  00097	8b 45 e8	 mov	 eax, DWORD PTR _rect$[ebp+12]
  0009a	2b 45 e0	 sub	 eax, DWORD PTR _rect$[ebp+4]
  0009d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000a1	51		 push	 ecx
  000a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  000aa	2b 4d dc	 sub	 ecx, DWORD PTR _rect$[ebp]
  000ad	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000b1	51		 push	 ecx
  000b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b7	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000bd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000c2	8b 10		 mov	 edx, DWORD PTR [eax]
  000c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c7	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  000ca	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000cd	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 212  : 
; 213  :     // Setup time step
; 214  :     INT64 current_time;
; 215  :     ::QueryPerformanceCounter((LARGE_INTEGER *)&current_time);

  000d0	8b f4		 mov	 esi, esp
  000d2	8d 45 cc	 lea	 eax, DWORD PTR _current_time$[ebp]
  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 216  :     io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;

  000e3	8b 4d cc	 mov	 ecx, DWORD PTR _current_time$[ebp]
  000e6	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?g_Time@@3_JA
  000ec	8b 55 d0	 mov	 edx, DWORD PTR _current_time$[ebp+4]
  000ef	1b 15 04 00 00
	00		 sbb	 edx, DWORD PTR ?g_Time@@3_JA+4
  000f5	e8 00 00 00 00	 call	 __ltod3
  000fa	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000fe	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?g_TicksPerSecond@@3_JA+4
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_TicksPerSecond@@3_JA
  0010a	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR tv220[ebp], xmm0
  00112	e8 00 00 00 00	 call	 __ltod3
  00117	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0011b	f3 0f 10 8d e8
	fe ff ff	 movss	 xmm1, DWORD PTR tv220[ebp]
  00123	f3 0f 5e c8	 divss	 xmm1, xmm0
  00127	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  0012a	f3 0f 11 48 10	 movss	 DWORD PTR [eax+16], xmm1

; 217  :     g_Time = current_time;

  0012f	8b 45 cc	 mov	 eax, DWORD PTR _current_time$[ebp]
  00132	a3 00 00 00 00	 mov	 DWORD PTR ?g_Time@@3_JA, eax
  00137	8b 4d d0	 mov	 ecx, DWORD PTR _current_time$[ebp+4]
  0013a	89 0d 04 00 00
	00		 mov	 DWORD PTR ?g_Time@@3_JA+4, ecx

; 218  : 
; 219  :     // Read keyboard modifiers inputs
; 220  :     io.KeyCtrl = (::GetKeyState(VK_CONTROL) & 0x8000) != 0;

  00140	8b f4		 mov	 esi, esp
  00142	6a 11		 push	 17			; 00000011H
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  0014a	3b f4		 cmp	 esi, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	98		 cwde
  00152	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00157	74 0c		 je	 SHORT $LN6@ImGui_Impl
  00159	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv132[ebp], 1
  00163	eb 0a		 jmp	 SHORT $LN7@ImGui_Impl
$LN6@ImGui_Impl:
  00165	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv132[ebp], 0
$LN7@ImGui_Impl:
  0016f	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  00172	8a 95 e8 fe ff
	ff		 mov	 dl, BYTE PTR tv132[ebp]
  00178	88 91 f8 00 00
	00		 mov	 BYTE PTR [ecx+248], dl

; 221  :     io.KeyShift = (::GetKeyState(VK_SHIFT) & 0x8000) != 0;

  0017e	8b f4		 mov	 esi, esp
  00180	6a 10		 push	 16			; 00000010H
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  00188	3b f4		 cmp	 esi, esp
  0018a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018f	98		 cwde
  00190	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00195	74 0c		 je	 SHORT $LN8@ImGui_Impl
  00197	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv140[ebp], 1
  001a1	eb 0a		 jmp	 SHORT $LN9@ImGui_Impl
$LN8@ImGui_Impl:
  001a3	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
$LN9@ImGui_Impl:
  001ad	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  001b0	8a 95 e8 fe ff
	ff		 mov	 dl, BYTE PTR tv140[ebp]
  001b6	88 91 f9 00 00
	00		 mov	 BYTE PTR [ecx+249], dl

; 222  :     io.KeyAlt = (::GetKeyState(VK_MENU) & 0x8000) != 0;

  001bc	8b f4		 mov	 esi, esp
  001be	6a 12		 push	 18			; 00000012H
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyState@4
  001c6	3b f4		 cmp	 esi, esp
  001c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cd	98		 cwde
  001ce	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  001d3	74 0c		 je	 SHORT $LN10@ImGui_Impl
  001d5	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv148[ebp], 1
  001df	eb 0a		 jmp	 SHORT $LN11@ImGui_Impl
$LN10@ImGui_Impl:
  001e1	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
$LN11@ImGui_Impl:
  001eb	8b 4d f4	 mov	 ecx, DWORD PTR _io$[ebp]
  001ee	8a 95 e8 fe ff
	ff		 mov	 dl, BYTE PTR tv148[ebp]
  001f4	88 91 fa 00 00
	00		 mov	 BYTE PTR [ecx+250], dl

; 223  :     io.KeySuper = false;

  001fa	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  001fd	c6 80 fb 00 00
	00 00		 mov	 BYTE PTR [eax+251], 0

; 224  :     // io.KeysDown[], io.MousePos, io.MouseDown[], io.MouseWheel: filled by the WndProc handler below.
; 225  : 
; 226  :     // Update OS mouse position
; 227  :     ImGui_ImplWin32_UpdateMousePos();

  00204	e8 00 00 00 00	 call	 ?ImGui_ImplWin32_UpdateMousePos@@YAXXZ ; ImGui_ImplWin32_UpdateMousePos

; 228  : 
; 229  :     // Update OS mouse cursor with the cursor requested by imgui
; 230  :     ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();

  00209	8b 45 f4	 mov	 eax, DWORD PTR _io$[ebp]
  0020c	0f b6 88 a8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+168]
  00213	85 c9		 test	 ecx, ecx
  00215	74 0c		 je	 SHORT $LN12@ImGui_Impl
  00217	c7 85 e8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv155[ebp], -1
  00221	eb 0b		 jmp	 SHORT $LN13@ImGui_Impl
$LN12@ImGui_Impl:
  00223	e8 00 00 00 00	 call	 ?GetMouseCursor@ImGui@@YAHXZ ; ImGui::GetMouseCursor
  00228	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv155[ebp], eax
$LN13@ImGui_Impl:
  0022e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv155[ebp]
  00234	89 55 c0	 mov	 DWORD PTR _mouse_cursor$[ebp], edx

; 231  :     if (g_LastMouseCursor != mouse_cursor)

  00237	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_LastMouseCursor@@3HA
  0023c	3b 45 c0	 cmp	 eax, DWORD PTR _mouse_cursor$[ebp]
  0023f	74 0d		 je	 SHORT $LN2@ImGui_Impl

; 232  :     {
; 233  :         g_LastMouseCursor = mouse_cursor;

  00241	8b 45 c0	 mov	 eax, DWORD PTR _mouse_cursor$[ebp]
  00244	a3 00 00 00 00	 mov	 DWORD PTR ?g_LastMouseCursor@@3HA, eax

; 234  :         ImGui_ImplWin32_UpdateMouseCursor();

  00249	e8 00 00 00 00	 call	 ?ImGui_ImplWin32_UpdateMouseCursor@@YA_NXZ ; ImGui_ImplWin32_UpdateMouseCursor
$LN2@ImGui_Impl:

; 235  :     }
; 236  : 
; 237  :     // Update game controllers (if enabled and available)
; 238  :     ImGui_ImplWin32_UpdateGamepads();

  0024e	e8 00 00 00 00	 call	 ?ImGui_ImplWin32_UpdateGamepads@@YAXXZ ; ImGui_ImplWin32_UpdateGamepads

; 239  : }

  00253	52		 push	 edx
  00254	8b cd		 mov	 ecx, ebp
  00256	50		 push	 eax
  00257	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@ImGui_Impl
  0025d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00262	58		 pop	 eax
  00263	5a		 pop	 edx
  00264	5f		 pop	 edi
  00265	5e		 pop	 esi
  00266	5b		 pop	 ebx
  00267	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026a	33 cd		 xor	 ecx, ebp
  0026c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00271	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00277	3b ec		 cmp	 ebp, esp
  00279	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c3		 ret	 0
  00282	66 90		 npad	 2
$LN17@ImGui_Impl:
  00284	02 00 00 00	 DD	 2
  00288	00 00 00 00	 DD	 $LN16@ImGui_Impl
$LN16@ImGui_Impl:
  0028c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00290	10 00 00 00	 DD	 16			; 00000010H
  00294	00 00 00 00	 DD	 $LN14@ImGui_Impl
  00298	cc ff ff ff	 DD	 -52			; ffffffccH
  0029c	08 00 00 00	 DD	 8
  002a0	00 00 00 00	 DD	 $LN15@ImGui_Impl
$LN15@ImGui_Impl:
  002a4	63		 DB	 99			; 00000063H
  002a5	75		 DB	 117			; 00000075H
  002a6	72		 DB	 114			; 00000072H
  002a7	72		 DB	 114			; 00000072H
  002a8	65		 DB	 101			; 00000065H
  002a9	6e		 DB	 110			; 0000006eH
  002aa	74		 DB	 116			; 00000074H
  002ab	5f		 DB	 95			; 0000005fH
  002ac	74		 DB	 116			; 00000074H
  002ad	69		 DB	 105			; 00000069H
  002ae	6d		 DB	 109			; 0000006dH
  002af	65		 DB	 101			; 00000065H
  002b0	00		 DB	 0
$LN14@ImGui_Impl:
  002b1	72		 DB	 114			; 00000072H
  002b2	65		 DB	 101			; 00000065H
  002b3	63		 DB	 99			; 00000063H
  002b4	74		 DB	 116			; 00000074H
  002b5	00		 DB	 0
?ImGui_ImplWin32_NewFrame@@YAXXZ ENDP			; ImGui_ImplWin32_NewFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
;	COMDAT ?ImGui_ImplWin32_Shutdown@@YAXXZ
_TEXT	SEGMENT
?ImGui_ImplWin32_Shutdown@@YAXXZ PROC			; ImGui_ImplWin32_Shutdown, COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __3551C0EC_imgui_impl_win32@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 95   :     g_hWnd = (HWND)0;

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_hWnd@@3PAUHWND__@@A, 0

; 96   : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?ImGui_ImplWin32_Shutdown@@YAXXZ ENDP			; ImGui_ImplWin32_Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_impl_win32.cpp
;	COMDAT ?ImGui_ImplWin32_Init@@YA_NPAX@Z
_TEXT	SEGMENT
_io$ = -8						; size = 4
_hwnd$ = 8						; size = 4
?ImGui_ImplWin32_Init@@YA_NPAX@Z PROC			; ImGui_ImplWin32_Init, COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __3551C0EC_imgui_impl_win32@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 53   :     if (!::QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))

  00028	8b f4		 mov	 esi, esp
  0002a	68 00 00 00 00	 push	 OFFSET ?g_TicksPerSecond@@3_JA
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	85 c0		 test	 eax, eax
  0003e	75 07		 jne	 SHORT $LN2@ImGui_Impl

; 54   :         return false;

  00040	32 c0		 xor	 al, al
  00042	e9 09 02 00 00	 jmp	 $LN1@ImGui_Impl
$LN2@ImGui_Impl:

; 55   :     if (!::QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))

  00047	8b f4		 mov	 esi, esp
  00049	68 00 00 00 00	 push	 OFFSET ?g_Time@@3_JA
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	85 c0		 test	 eax, eax
  0005d	75 07		 jne	 SHORT $LN3@ImGui_Impl

; 56   :         return false;

  0005f	32 c0		 xor	 al, al
  00061	e9 ea 01 00 00	 jmp	 $LN1@ImGui_Impl
$LN3@ImGui_Impl:

; 57   : 
; 58   :     // Setup back-end capabilities flags
; 59   :     g_hWnd = (HWND)hwnd;

  00066	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?g_hWnd@@3PAUHWND__@@A, eax

; 60   :     ImGuiIO& io = ImGui::GetIO();

  0006e	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAAUImGuiIO@@XZ ; ImGui::GetIO
  00073	89 45 f8	 mov	 DWORD PTR _io$[ebp], eax

; 61   :     io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)

  00076	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00079	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007c	83 c9 02	 or	 ecx, 2
  0007f	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00082	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 62   :     io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)

  00085	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00088	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008b	83 c9 04	 or	 ecx, 4
  0008e	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00091	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 63   :     io.BackendPlatformName = "imgui_impl_win32";

  00094	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  00097	c7 80 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+180], OFFSET ??_C@_0BB@FLGJPPJK@imgui_impl_win32@

; 64   :     io.ImeWindowHandle = hwnd;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _io$[ebp]
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  000a7	89 88 d8 00 00
	00		 mov	 DWORD PTR [eax+216], ecx

; 65   : 
; 66   :     // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.
; 67   :     io.KeyMap[ImGuiKey_Tab] = VK_TAB;

  000ad	b8 04 00 00 00	 mov	 eax, 4
  000b2	6b c8 00	 imul	 ecx, eax, 0
  000b5	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  000b8	c7 44 0a 2c 09
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 9

; 68   :     io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;

  000c0	b8 04 00 00 00	 mov	 eax, 4
  000c5	c1 e0 00	 shl	 eax, 0
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _io$[ebp]
  000cb	c7 44 01 2c 25
	00 00 00	 mov	 DWORD PTR [ecx+eax+44], 37 ; 00000025H

; 69   :     io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;

  000d3	b8 04 00 00 00	 mov	 eax, 4
  000d8	d1 e0		 shl	 eax, 1
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _io$[ebp]
  000dd	c7 44 01 2c 27
	00 00 00	 mov	 DWORD PTR [ecx+eax+44], 39 ; 00000027H

; 70   :     io.KeyMap[ImGuiKey_UpArrow] = VK_UP;

  000e5	b8 04 00 00 00	 mov	 eax, 4
  000ea	6b c8 03	 imul	 ecx, eax, 3
  000ed	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  000f0	c7 44 0a 2c 26
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 38 ; 00000026H

; 71   :     io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;

  000f8	b8 04 00 00 00	 mov	 eax, 4
  000fd	c1 e0 02	 shl	 eax, 2
  00100	8b 4d f8	 mov	 ecx, DWORD PTR _io$[ebp]
  00103	c7 44 01 2c 28
	00 00 00	 mov	 DWORD PTR [ecx+eax+44], 40 ; 00000028H

; 72   :     io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;

  0010b	b8 04 00 00 00	 mov	 eax, 4
  00110	6b c8 05	 imul	 ecx, eax, 5
  00113	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00116	c7 44 0a 2c 21
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 33 ; 00000021H

; 73   :     io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;

  0011e	b8 04 00 00 00	 mov	 eax, 4
  00123	6b c8 06	 imul	 ecx, eax, 6
  00126	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00129	c7 44 0a 2c 22
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 34 ; 00000022H

; 74   :     io.KeyMap[ImGuiKey_Home] = VK_HOME;

  00131	b8 04 00 00 00	 mov	 eax, 4
  00136	6b c8 07	 imul	 ecx, eax, 7
  00139	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  0013c	c7 44 0a 2c 24
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 36 ; 00000024H

; 75   :     io.KeyMap[ImGuiKey_End] = VK_END;

  00144	b8 04 00 00 00	 mov	 eax, 4
  00149	c1 e0 03	 shl	 eax, 3
  0014c	8b 4d f8	 mov	 ecx, DWORD PTR _io$[ebp]
  0014f	c7 44 01 2c 23
	00 00 00	 mov	 DWORD PTR [ecx+eax+44], 35 ; 00000023H

; 76   :     io.KeyMap[ImGuiKey_Insert] = VK_INSERT;

  00157	b8 04 00 00 00	 mov	 eax, 4
  0015c	6b c8 09	 imul	 ecx, eax, 9
  0015f	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00162	c7 44 0a 2c 2d
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 45 ; 0000002dH

; 77   :     io.KeyMap[ImGuiKey_Delete] = VK_DELETE;

  0016a	b8 04 00 00 00	 mov	 eax, 4
  0016f	6b c8 0a	 imul	 ecx, eax, 10
  00172	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00175	c7 44 0a 2c 2e
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 46 ; 0000002eH

; 78   :     io.KeyMap[ImGuiKey_Backspace] = VK_BACK;

  0017d	b8 04 00 00 00	 mov	 eax, 4
  00182	6b c8 0b	 imul	 ecx, eax, 11
  00185	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00188	c7 44 0a 2c 08
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 8

; 79   :     io.KeyMap[ImGuiKey_Space] = VK_SPACE;

  00190	b8 04 00 00 00	 mov	 eax, 4
  00195	6b c8 0c	 imul	 ecx, eax, 12
  00198	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  0019b	c7 44 0a 2c 20
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 32 ; 00000020H

; 80   :     io.KeyMap[ImGuiKey_Enter] = VK_RETURN;

  001a3	b8 04 00 00 00	 mov	 eax, 4
  001a8	6b c8 0d	 imul	 ecx, eax, 13
  001ab	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  001ae	c7 44 0a 2c 0d
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 13 ; 0000000dH

; 81   :     io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;

  001b6	b8 04 00 00 00	 mov	 eax, 4
  001bb	6b c8 0e	 imul	 ecx, eax, 14
  001be	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  001c1	c7 44 0a 2c 1b
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 27 ; 0000001bH

; 82   :     io.KeyMap[ImGuiKey_KeyPadEnter] = VK_RETURN;

  001c9	b8 04 00 00 00	 mov	 eax, 4
  001ce	6b c8 0f	 imul	 ecx, eax, 15
  001d1	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  001d4	c7 44 0a 2c 0d
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 13 ; 0000000dH

; 83   :     io.KeyMap[ImGuiKey_A] = 'A';

  001dc	b8 04 00 00 00	 mov	 eax, 4
  001e1	c1 e0 04	 shl	 eax, 4
  001e4	8b 4d f8	 mov	 ecx, DWORD PTR _io$[ebp]
  001e7	c7 44 01 2c 41
	00 00 00	 mov	 DWORD PTR [ecx+eax+44], 65 ; 00000041H

; 84   :     io.KeyMap[ImGuiKey_C] = 'C';

  001ef	b8 04 00 00 00	 mov	 eax, 4
  001f4	6b c8 11	 imul	 ecx, eax, 17
  001f7	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  001fa	c7 44 0a 2c 43
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 67 ; 00000043H

; 85   :     io.KeyMap[ImGuiKey_V] = 'V';

  00202	b8 04 00 00 00	 mov	 eax, 4
  00207	6b c8 12	 imul	 ecx, eax, 18
  0020a	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  0020d	c7 44 0a 2c 56
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 86 ; 00000056H

; 86   :     io.KeyMap[ImGuiKey_X] = 'X';

  00215	b8 04 00 00 00	 mov	 eax, 4
  0021a	6b c8 13	 imul	 ecx, eax, 19
  0021d	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00220	c7 44 0a 2c 58
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 88 ; 00000058H

; 87   :     io.KeyMap[ImGuiKey_Y] = 'Y';

  00228	b8 04 00 00 00	 mov	 eax, 4
  0022d	6b c8 14	 imul	 ecx, eax, 20
  00230	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00233	c7 44 0a 2c 59
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 89 ; 00000059H

; 88   :     io.KeyMap[ImGuiKey_Z] = 'Z';

  0023b	b8 04 00 00 00	 mov	 eax, 4
  00240	6b c8 15	 imul	 ecx, eax, 21
  00243	8b 55 f8	 mov	 edx, DWORD PTR _io$[ebp]
  00246	c7 44 0a 2c 5a
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 90 ; 0000005aH

; 89   : 
; 90   :     return true;

  0024e	b0 01		 mov	 al, 1
$LN1@ImGui_Impl:

; 91   : }

  00250	5f		 pop	 edi
  00251	5e		 pop	 esi
  00252	5b		 pop	 ebx
  00253	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00259	3b ec		 cmp	 ebp, esp
  0025b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
?ImGui_ImplWin32_Init@@YA_NPAX@Z ENDP			; ImGui_ImplWin32_Init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?IsBuilt@ImFontAtlas@@QBE_NXZ
_TEXT	SEGMENT
tv71 = -208						; size = 4
_this$ = -8						; size = 4
?IsBuilt@ImFontAtlas@@QBE_NXZ PROC			; ImFontAtlas::IsBuilt, COMDAT
; _this$ = ecx

; 2130 :     bool                        IsBuilt() const             { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __8BAA8EBB_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00034	7e 1e		 jle	 SHORT $LN4@IsBuilt
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0003d	75 09		 jne	 SHORT $LN3@IsBuilt
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00042	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00046	74 0c		 je	 SHORT $LN4@IsBuilt
$LN3@IsBuilt:
  00048	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
  00052	eb 0a		 jmp	 SHORT $LN5@IsBuilt
$LN4@IsBuilt:
  00054	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@IsBuilt:
  0005e	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv71[ebp]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?IsBuilt@ImFontAtlas@@QBE_NXZ ENDP			; ImFontAtlas::IsBuilt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 187  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __8BAA8EBB_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __x$[ebp]
  00035	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __y$[ebp]
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
END
