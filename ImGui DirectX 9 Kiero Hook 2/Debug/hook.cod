; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_isLocked
PUBLIC	_g_hHeap
_BSS	SEGMENT
_g_isLocked DD	01H DUP (?)
_g_hHeap DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_hooks:BYTE:0cH
_DATA	ENDS
msvcjmc	SEGMENT
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__E6E7469F_winioctl@h DB 01H
__08182E14_stralign@h DB 01H
__29301DEE_hook@c DB 01H
msvcjmc	ENDS
PUBLIC	_MH_Initialize@0
PUBLIC	_MH_Uninitialize@0
PUBLIC	_MH_CreateHook@12
PUBLIC	_MH_CreateHookApi@16
PUBLIC	_MH_CreateHookApiEx@20
PUBLIC	_MH_RemoveHook@4
PUBLIC	_MH_EnableHook@4
PUBLIC	_MH_DisableHook@4
PUBLIC	_MH_QueueEnableHook@4
PUBLIC	_MH_QueueDisableHook@4
PUBLIC	_MH_ApplyQueued@0
PUBLIC	_MH_StatusToString@4
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0L@OGPCCONM@MH_UNKNOWN@			; `string'
PUBLIC	??_C@_05GOFNBHKB@MH_OK@				; `string'
PUBLIC	??_C@_0BN@NKPDILDH@MH_ERROR_ALREADY_INITIALIZED@ ; `string'
PUBLIC	??_C@_0BJ@NEFDEEIO@MH_ERROR_NOT_INITIALIZED@	; `string'
PUBLIC	??_C@_0BJ@EMFAAEGJ@MH_ERROR_ALREADY_CREATED@	; `string'
PUBLIC	??_C@_0BF@KAPHKAPP@MH_ERROR_NOT_CREATED@	; `string'
PUBLIC	??_C@_0BB@HHFKFOJC@MH_ERROR_ENABLED@		; `string'
PUBLIC	??_C@_0BC@CCPCFLPI@MH_ERROR_DISABLED@		; `string'
PUBLIC	??_C@_0BI@ONHKLIEE@MH_ERROR_NOT_EXECUTABLE@	; `string'
PUBLIC	??_C@_0BO@JGLOGLHI@MH_ERROR_UNSUPPORTED_FUNCTION@ ; `string'
PUBLIC	??_C@_0BG@FHKMAOCO@MH_ERROR_MEMORY_ALLOC@	; `string'
PUBLIC	??_C@_0BI@HDILIFIJ@MH_ERROR_MEMORY_PROTECT@	; `string'
PUBLIC	??_C@_0BK@FENDNJHO@MH_ERROR_MODULE_NOT_FOUND@	; `string'
PUBLIC	??_C@_0BM@JPINPKML@MH_ERROR_FUNCTION_NOT_FOUND@	; `string'
PUBLIC	??_C@_09GPGAJHPD@?$CIunknown?$CJ@		; `string'
EXTRN	_memcpy:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__HeapCreate@12:PROC
EXTRN	__imp__HeapDestroy@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapReAlloc@16:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__OpenThread@12:PROC
EXTRN	__imp__SuspendThread@4:PROC
EXTRN	__imp__ResumeThread@4:PROC
EXTRN	__imp__GetThreadContext@8:PROC
EXTRN	__imp__SetThreadContext@8:PROC
EXTRN	__imp__FlushInstructionCache@12:PROC
EXTRN	__imp__VirtualProtect@16:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	_CreateToolhelp32Snapshot@8:PROC
EXTRN	_Thread32First@8:PROC
EXTRN	_Thread32Next@8:PROC
EXTRN	_InitializeBuffer:PROC
EXTRN	_UninitializeBuffer:PROC
EXTRN	_AllocateBuffer:PROC
EXTRN	_FreeBuffer:PROC
EXTRN	_IsExecutableAddress:PROC
EXTRN	_CreateTrampolineFunction:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ@
CONST	SEGMENT
??_C@_09GPGAJHPD@?$CIunknown?$CJ@ DB '(unknown)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JPINPKML@MH_ERROR_FUNCTION_NOT_FOUND@
CONST	SEGMENT
??_C@_0BM@JPINPKML@MH_ERROR_FUNCTION_NOT_FOUND@ DB 'MH_ERROR_FUNCTION_NOT'
	DB	'_FOUND', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FENDNJHO@MH_ERROR_MODULE_NOT_FOUND@
CONST	SEGMENT
??_C@_0BK@FENDNJHO@MH_ERROR_MODULE_NOT_FOUND@ DB 'MH_ERROR_MODULE_NOT_FOU'
	DB	'ND', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HDILIFIJ@MH_ERROR_MEMORY_PROTECT@
CONST	SEGMENT
??_C@_0BI@HDILIFIJ@MH_ERROR_MEMORY_PROTECT@ DB 'MH_ERROR_MEMORY_PROTECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FHKMAOCO@MH_ERROR_MEMORY_ALLOC@
CONST	SEGMENT
??_C@_0BG@FHKMAOCO@MH_ERROR_MEMORY_ALLOC@ DB 'MH_ERROR_MEMORY_ALLOC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JGLOGLHI@MH_ERROR_UNSUPPORTED_FUNCTION@
CONST	SEGMENT
??_C@_0BO@JGLOGLHI@MH_ERROR_UNSUPPORTED_FUNCTION@ DB 'MH_ERROR_UNSUPPORTE'
	DB	'D_FUNCTION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ONHKLIEE@MH_ERROR_NOT_EXECUTABLE@
CONST	SEGMENT
??_C@_0BI@ONHKLIEE@MH_ERROR_NOT_EXECUTABLE@ DB 'MH_ERROR_NOT_EXECUTABLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CCPCFLPI@MH_ERROR_DISABLED@
CONST	SEGMENT
??_C@_0BC@CCPCFLPI@MH_ERROR_DISABLED@ DB 'MH_ERROR_DISABLED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HHFKFOJC@MH_ERROR_ENABLED@
CONST	SEGMENT
??_C@_0BB@HHFKFOJC@MH_ERROR_ENABLED@ DB 'MH_ERROR_ENABLED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KAPHKAPP@MH_ERROR_NOT_CREATED@
CONST	SEGMENT
??_C@_0BF@KAPHKAPP@MH_ERROR_NOT_CREATED@ DB 'MH_ERROR_NOT_CREATED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EMFAAEGJ@MH_ERROR_ALREADY_CREATED@
CONST	SEGMENT
??_C@_0BJ@EMFAAEGJ@MH_ERROR_ALREADY_CREATED@ DB 'MH_ERROR_ALREADY_CREATED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NEFDEEIO@MH_ERROR_NOT_INITIALIZED@
CONST	SEGMENT
??_C@_0BJ@NEFDEEIO@MH_ERROR_NOT_INITIALIZED@ DB 'MH_ERROR_NOT_INITIALIZED'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NKPDILDH@MH_ERROR_ALREADY_INITIALIZED@
CONST	SEGMENT
??_C@_0BN@NKPDILDH@MH_ERROR_ALREADY_INITIALIZED@ DB 'MH_ERROR_ALREADY_INI'
	DB	'TIALIZED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05GOFNBHKB@MH_OK@
CONST	SEGMENT
??_C@_05GOFNBHKB@MH_OK@ DB 'MH_OK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGPCCONM@MH_UNKNOWN@
CONST	SEGMENT
??_C@_0L@OGPCCONM@MH_UNKNOWN@ DB 'MH_UNKNOWN', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _QueueHook
_TEXT	SEGMENT
_pos$1 = -32						; size = 4
_i$2 = -20						; size = 4
_status$ = -8						; size = 4
_pTarget$ = 8						; size = 4
_queueEnable$ = 12					; size = 4
_QueueHook PROC						; COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 738  :     MH_STATUS status = MH_OK;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 739  : 
; 740  :     EnterSpinLock();

  0002f	e8 00 00 00 00	 call	 _EnterSpinLock

; 741  : 
; 742  :     if (g_hHeap != NULL)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  0003b	0f 84 99 00 00
	00		 je	 $LN5@QueueHook

; 743  :     {
; 744  :         if (pTarget == MH_ALL_HOOKS)

  00041	83 7d 08 00	 cmp	 DWORD PTR _pTarget$[ebp], 0
  00045	75 4a		 jne	 SHORT $LN7@QueueHook

; 745  :         {
; 746  :             UINT i;
; 747  :             for (i = 0; i < g_hooks.size; ++i)

  00047	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0004e	eb 09		 jmp	 SHORT $LN4@QueueHook
$LN2@QueueHook:
  00050	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 ec	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@QueueHook:
  00059	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  0005c	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+8
  00062	73 2b		 jae	 SHORT $LN3@QueueHook

; 748  :                 g_hooks.pItems[i].queueEnable = queueEnable;

  00064	6b 45 ec 2c	 imul	 eax, DWORD PTR _i$2[ebp], 44
  00068	8a 4d 0c	 mov	 cl, BYTE PTR _queueEnable$[ebp]
  0006b	80 e1 01	 and	 cl, 1
  0006e	c0 e1 02	 shl	 cl, 2
  00071	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hooks
  00077	8a 44 02 14	 mov	 al, BYTE PTR [edx+eax+20]
  0007b	24 fb		 and	 al, 251			; 000000fbH
  0007d	0a c1		 or	 al, cl
  0007f	6b 4d ec 2c	 imul	 ecx, DWORD PTR _i$2[ebp], 44
  00083	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hooks
  00089	88 44 0a 14	 mov	 BYTE PTR [edx+ecx+20], al
  0008d	eb c1		 jmp	 SHORT $LN2@QueueHook
$LN3@QueueHook:

; 749  :         }

  0008f	eb 47		 jmp	 SHORT $LN8@QueueHook
$LN7@QueueHook:

; 750  :         else
; 751  :         {
; 752  :             UINT pos = FindHookEntry(pTarget);

  00091	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _FindHookEntry
  0009a	83 c4 04	 add	 esp, 4
  0009d	89 45 e0	 mov	 DWORD PTR _pos$1[ebp], eax

; 753  :             if (pos != INVALID_HOOK_POS)

  000a0	83 7d e0 ff	 cmp	 DWORD PTR _pos$1[ebp], -1
  000a4	74 2b		 je	 SHORT $LN9@QueueHook

; 754  :             {
; 755  :                 g_hooks.pItems[pos].queueEnable = queueEnable;

  000a6	6b 45 e0 2c	 imul	 eax, DWORD PTR _pos$1[ebp], 44
  000aa	8a 4d 0c	 mov	 cl, BYTE PTR _queueEnable$[ebp]
  000ad	80 e1 01	 and	 cl, 1
  000b0	c0 e1 02	 shl	 cl, 2
  000b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hooks
  000b9	8a 44 02 14	 mov	 al, BYTE PTR [edx+eax+20]
  000bd	24 fb		 and	 al, 251			; 000000fbH
  000bf	0a c1		 or	 al, cl
  000c1	6b 4d e0 2c	 imul	 ecx, DWORD PTR _pos$1[ebp], 44
  000c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hooks
  000cb	88 44 0a 14	 mov	 BYTE PTR [edx+ecx+20], al

; 756  :             }

  000cf	eb 07		 jmp	 SHORT $LN8@QueueHook
$LN9@QueueHook:

; 757  :             else
; 758  :             {
; 759  :                 status = MH_ERROR_NOT_CREATED;

  000d1	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _status$[ebp], 4
$LN8@QueueHook:

; 760  :             }
; 761  :         }
; 762  :     }

  000d8	eb 07		 jmp	 SHORT $LN6@QueueHook
$LN5@QueueHook:

; 763  :     else
; 764  :     {
; 765  :         status = MH_ERROR_NOT_INITIALIZED;

  000da	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _status$[ebp], 2
$LN6@QueueHook:

; 766  :     }
; 767  : 
; 768  :     LeaveSpinLock();

  000e1	e8 00 00 00 00	 call	 _LeaveSpinLock

; 769  : 
; 770  :     return status;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]

; 771  : }

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000f2	3b ec		 cmp	 ebp, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
_QueueHook ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _EnableHook
_TEXT	SEGMENT
tv86 = -244						; size = 4
_pos$1 = -44						; size = 4
_threads$2 = -32					; size = 12
_status$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTarget$ = 8						; size = 4
_enable$ = 12						; size = 4
_EnableHook PROC					; COMDAT

; 677  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 678  :     MH_STATUS status = MH_OK;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 679  : 
; 680  :     EnterSpinLock();

  00039	e8 00 00 00 00	 call	 _EnterSpinLock

; 681  : 
; 682  :     if (g_hHeap != NULL)

  0003e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  00045	0f 84 ad 00 00
	00		 je	 $LN2@EnableHook

; 683  :     {
; 684  :         if (pTarget == MH_ALL_HOOKS)

  0004b	83 7d 08 00	 cmp	 DWORD PTR _pTarget$[ebp], 0
  0004f	75 14		 jne	 SHORT $LN4@EnableHook

; 685  :         {
; 686  :             status = EnableAllHooksLL(enable);

  00051	8b 45 0c	 mov	 eax, DWORD PTR _enable$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _EnableAllHooksLL
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 687  :         }

  00060	e9 91 00 00 00	 jmp	 $LN5@EnableHook
$LN4@EnableHook:

; 688  :         else
; 689  :         {
; 690  :             FROZEN_THREADS threads;
; 691  :             UINT pos = FindHookEntry(pTarget);

  00065	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _FindHookEntry
  0006e	83 c4 04	 add	 esp, 4
  00071	89 45 d4	 mov	 DWORD PTR _pos$1[ebp], eax

; 692  :             if (pos != INVALID_HOOK_POS)

  00074	83 7d d4 ff	 cmp	 DWORD PTR _pos$1[ebp], -1
  00078	74 75		 je	 SHORT $LN6@EnableHook

; 693  :             {
; 694  :                 if (g_hooks.pItems[pos].isEnabled != enable)

  0007a	6b 45 d4 2c	 imul	 eax, DWORD PTR _pos$1[ebp], 44
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks
  00084	8a 54 01 14	 mov	 dl, BYTE PTR [ecx+eax+20]
  00088	d0 ea		 shr	 dl, 1
  0008a	80 e2 01	 and	 dl, 1
  0008d	0f b6 c2	 movzx	 eax, dl
  00090	3b 45 0c	 cmp	 eax, DWORD PTR _enable$[ebp]
  00093	74 33		 je	 SHORT $LN8@EnableHook

; 695  :                 {
; 696  :                     Freeze(&threads, pos, ACTION_ENABLE);

  00095	6a 01		 push	 1
  00097	8b 45 d4	 mov	 eax, DWORD PTR _pos$1[ebp]
  0009a	50		 push	 eax
  0009b	8d 4d e0	 lea	 ecx, DWORD PTR _threads$2[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _Freeze
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 697  : 
; 698  :                     status = EnableHookLL(pos, enable);

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _enable$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d d4	 mov	 ecx, DWORD PTR _pos$1[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _EnableHookLL
  000b4	83 c4 08	 add	 esp, 8
  000b7	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 699  : 
; 700  :                     Unfreeze(&threads);

  000ba	8d 45 e0	 lea	 eax, DWORD PTR _threads$2[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _Unfreeze
  000c3	83 c4 04	 add	 esp, 4

; 701  :                 }

  000c6	eb 25		 jmp	 SHORT $LN9@EnableHook
$LN8@EnableHook:

; 702  :                 else
; 703  :                 {
; 704  :                     status = enable ? MH_ERROR_ENABLED : MH_ERROR_DISABLED;

  000c8	83 7d 0c 00	 cmp	 DWORD PTR _enable$[ebp], 0
  000cc	74 0c		 je	 SHORT $LN11@EnableHook
  000ce	c7 85 0c ff ff
	ff 05 00 00 00	 mov	 DWORD PTR tv86[ebp], 5
  000d8	eb 0a		 jmp	 SHORT $LN12@EnableHook
$LN11@EnableHook:
  000da	c7 85 0c ff ff
	ff 06 00 00 00	 mov	 DWORD PTR tv86[ebp], 6
$LN12@EnableHook:
  000e4	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv86[ebp]
  000ea	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax
$LN9@EnableHook:

; 705  :                 }
; 706  :             }

  000ed	eb 07		 jmp	 SHORT $LN5@EnableHook
$LN6@EnableHook:

; 707  :             else
; 708  :             {
; 709  :                 status = MH_ERROR_NOT_CREATED;

  000ef	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _status$[ebp], 4
$LN5@EnableHook:

; 710  :             }
; 711  :         }
; 712  :     }

  000f6	eb 07		 jmp	 SHORT $LN3@EnableHook
$LN2@EnableHook:

; 713  :     else
; 714  :     {
; 715  :         status = MH_ERROR_NOT_INITIALIZED;

  000f8	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _status$[ebp], 2
$LN3@EnableHook:

; 716  :     }
; 717  : 
; 718  :     LeaveSpinLock();

  000ff	e8 00 00 00 00	 call	 _LeaveSpinLock

; 719  : 
; 720  :     return status;

  00104	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]

; 721  : }

  00107	52		 push	 edx
  00108	8b cd		 mov	 ecx, ebp
  0010a	50		 push	 eax
  0010b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@EnableHook
  00111	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00116	58		 pop	 eax
  00117	5a		 pop	 edx
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011e	33 cd		 xor	 ecx, ebp
  00120	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00125	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  0012b	3b ec		 cmp	 ebp, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
  00136	66 90		 npad	 2
$LN15@EnableHook:
  00138	01 00 00 00	 DD	 1
  0013c	00 00 00 00	 DD	 $LN14@EnableHook
$LN14@EnableHook:
  00140	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00144	0c 00 00 00	 DD	 12			; 0000000cH
  00148	00 00 00 00	 DD	 $LN13@EnableHook
$LN13@EnableHook:
  0014c	74		 DB	 116			; 00000074H
  0014d	68		 DB	 104			; 00000068H
  0014e	72		 DB	 114			; 00000072H
  0014f	65		 DB	 101			; 00000065H
  00150	61		 DB	 97			; 00000061H
  00151	64		 DB	 100			; 00000064H
  00152	73		 DB	 115			; 00000073H
  00153	00		 DB	 0
_EnableHook ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _LeaveSpinLock
_TEXT	SEGMENT
_LeaveSpinLock PROC					; COMDAT

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 459  :     // No need to generate a memory barrier here, since InterlockedExchange()
; 460  :     // generates a full memory barrier itself.
; 461  : 
; 462  :     InterlockedExchange(&g_isLocked, FALSE);

  00028	33 c0		 xor	 eax, eax
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET _g_isLocked
  0002f	87 01		 xchg	 DWORD PTR [ecx], eax

; 463  : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_LeaveSpinLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _EnterSpinLock
_TEXT	SEGMENT
_spinCount$ = -8					; size = 4
_EnterSpinLock PROC					; COMDAT

; 437  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 438  :     SIZE_T spinCount = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _spinCount$[ebp], 0
$LN2@EnterSpinL:

; 439  : 
; 440  :     // Wait until the flag is FALSE.
; 441  :     while (InterlockedCompareExchange(&g_isLocked, TRUE, FALSE) != FALSE)

  0002f	b9 01 00 00 00	 mov	 ecx, 1
  00034	ba 00 00 00 00	 mov	 edx, OFFSET _g_isLocked
  00039	33 c0		 xor	 eax, eax
  0003b	f0 0f b1 0a	 lock cmpxchg DWORD PTR [edx], ecx
  0003f	85 c0		 test	 eax, eax
  00041	74 35		 je	 SHORT $LN1@EnterSpinL

; 442  :     {
; 443  :         // No need to generate a memory barrier here, since InterlockedCompareExchange()
; 444  :         // generates a full memory barrier itself.
; 445  : 
; 446  :         // Prevent the loop from being too busy.
; 447  :         if (spinCount < 32)

  00043	83 7d f8 20	 cmp	 DWORD PTR _spinCount$[ebp], 32 ; 00000020H
  00047	73 13		 jae	 SHORT $LN4@EnterSpinL

; 448  :             Sleep(0);

  00049	8b f4		 mov	 esi, esp
  0004b	6a 00		 push	 0
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	eb 11		 jmp	 SHORT $LN5@EnterSpinL
$LN4@EnterSpinL:

; 449  :         else
; 450  :             Sleep(1);

  0005c	8b f4		 mov	 esi, esp
  0005e	6a 01		 push	 1
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@EnterSpinL:

; 451  : 
; 452  :         spinCount++;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _spinCount$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 f8	 mov	 DWORD PTR _spinCount$[ebp], eax

; 453  :     }

  00076	eb b7		 jmp	 SHORT $LN2@EnterSpinL
$LN1@EnterSpinL:

; 454  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_EnterSpinLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _EnableAllHooksLL
_TEXT	SEGMENT
tv75 = -256						; size = 4
_threads$1 = -56					; size = 12
_first$ = -36						; size = 4
_i$ = -24						; size = 4
_status$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_enable$ = 8						; size = 4
_EnableAllHooksLL PROC					; COMDAT

; 401  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 402  :     MH_STATUS status = MH_OK;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 403  :     UINT i, first = INVALID_HOOK_POS;

  00039	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _first$[ebp], -1

; 404  : 
; 405  :     for (i = 0; i < g_hooks.size; ++i)

  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00047	eb 09		 jmp	 SHORT $LN4@EnableAllH
$LN2@EnableAllH:
  00049	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@EnableAllH:
  00052	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00055	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+8
  0005b	73 25		 jae	 SHORT $LN3@EnableAllH

; 406  :     {
; 407  :         if (g_hooks.pItems[i].isEnabled != enable)

  0005d	6b 45 e8 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks
  00067	8a 54 01 14	 mov	 dl, BYTE PTR [ecx+eax+20]
  0006b	d0 ea		 shr	 dl, 1
  0006d	80 e2 01	 and	 dl, 1
  00070	0f b6 c2	 movzx	 eax, dl
  00073	3b 45 08	 cmp	 eax, DWORD PTR _enable$[ebp]
  00076	74 08		 je	 SHORT $LN8@EnableAllH

; 408  :         {
; 409  :             first = i;

  00078	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0007b	89 45 dc	 mov	 DWORD PTR _first$[ebp], eax

; 410  :             break;

  0007e	eb 02		 jmp	 SHORT $LN3@EnableAllH
$LN8@EnableAllH:

; 411  :         }
; 412  :     }

  00080	eb c7		 jmp	 SHORT $LN2@EnableAllH
$LN3@EnableAllH:

; 413  : 
; 414  :     if (first != INVALID_HOOK_POS)

  00082	83 7d dc ff	 cmp	 DWORD PTR _first$[ebp], -1
  00086	0f 84 91 00 00
	00		 je	 $LN9@EnableAllH

; 415  :     {
; 416  :         FROZEN_THREADS threads;
; 417  :         Freeze(&threads, ALL_HOOKS_POS, enable ? ACTION_ENABLE : ACTION_DISABLE);

  0008c	83 7d 08 00	 cmp	 DWORD PTR _enable$[ebp], 0
  00090	74 0c		 je	 SHORT $LN13@EnableAllH
  00092	c7 85 00 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv75[ebp], 1
  0009c	eb 0a		 jmp	 SHORT $LN14@EnableAllH
$LN13@EnableAllH:
  0009e	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], 0
$LN14@EnableAllH:
  000a8	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]
  000ae	50		 push	 eax
  000af	6a ff		 push	 -1
  000b1	8d 4d c8	 lea	 ecx, DWORD PTR _threads$1[ebp]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _Freeze
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 418  : 
; 419  :         for (i = first; i < g_hooks.size; ++i)

  000bd	8b 45 dc	 mov	 eax, DWORD PTR _first$[ebp]
  000c0	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  000c3	eb 09		 jmp	 SHORT $LN7@EnableAllH
$LN5@EnableAllH:
  000c5	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000c8	83 c0 01	 add	 eax, 1
  000cb	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@EnableAllH:
  000ce	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000d1	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+8
  000d7	73 38		 jae	 SHORT $LN6@EnableAllH

; 420  :         {
; 421  :             if (g_hooks.pItems[i].isEnabled != enable)

  000d9	6b 45 e8 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks
  000e3	8a 54 01 14	 mov	 dl, BYTE PTR [ecx+eax+20]
  000e7	d0 ea		 shr	 dl, 1
  000e9	80 e2 01	 and	 dl, 1
  000ec	0f b6 c2	 movzx	 eax, dl
  000ef	3b 45 08	 cmp	 eax, DWORD PTR _enable$[ebp]
  000f2	74 1b		 je	 SHORT $LN10@EnableAllH

; 422  :             {
; 423  :                 status = EnableHookLL(i, enable);

  000f4	8b 45 08	 mov	 eax, DWORD PTR _enable$[ebp]
  000f7	50		 push	 eax
  000f8	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 _EnableHookLL
  00101	83 c4 08	 add	 esp, 8
  00104	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 424  :                 if (status != MH_OK)

  00107	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  0010b	74 02		 je	 SHORT $LN10@EnableAllH

; 425  :                     break;

  0010d	eb 02		 jmp	 SHORT $LN6@EnableAllH
$LN10@EnableAllH:

; 426  :             }
; 427  :         }

  0010f	eb b4		 jmp	 SHORT $LN5@EnableAllH
$LN6@EnableAllH:

; 428  : 
; 429  :         Unfreeze(&threads);

  00111	8d 45 c8	 lea	 eax, DWORD PTR _threads$1[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 _Unfreeze
  0011a	83 c4 04	 add	 esp, 4
$LN9@EnableAllH:

; 430  :     }
; 431  : 
; 432  :     return status;

  0011d	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]

; 433  : }

  00120	52		 push	 edx
  00121	8b cd		 mov	 ecx, ebp
  00123	50		 push	 eax
  00124	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@EnableAllH
  0012a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012f	58		 pop	 eax
  00130	5a		 pop	 edx
  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx
  00134	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00137	33 cd		 xor	 ecx, ebp
  00139	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013e	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  00144	3b ec		 cmp	 ebp, esp
  00146	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
  0014f	90		 npad	 1
$LN17@EnableAllH:
  00150	01 00 00 00	 DD	 1
  00154	00 00 00 00	 DD	 $LN16@EnableAllH
$LN16@EnableAllH:
  00158	c8 ff ff ff	 DD	 -56			; ffffffc8H
  0015c	0c 00 00 00	 DD	 12			; 0000000cH
  00160	00 00 00 00	 DD	 $LN15@EnableAllH
$LN15@EnableAllH:
  00164	74		 DB	 116			; 00000074H
  00165	68		 DB	 104			; 00000068H
  00166	72		 DB	 114			; 00000072H
  00167	65		 DB	 101			; 00000065H
  00168	61		 DB	 97			; 00000061H
  00169	64		 DB	 100			; 00000064H
  0016a	73		 DB	 115			; 00000073H
  0016b	00		 DB	 0
_EnableAllHooksLL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _EnableHookLL
_TEXT	SEGMENT
_pShortJmp$1 = -72					; size = 4
_pJmp$2 = -60						; size = 4
_pPatchTarget$ = -48					; size = 4
_patchSize$ = -36					; size = 4
_oldProtect$ = -24					; size = 4
_pHook$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_enable$ = 12						; size = 4
_EnableHookLL PROC					; COMDAT

; 352  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 353  :     PHOOK_ENTRY pHook = &g_hooks.pItems[pos];

  00032	6b 45 08 2c	 imul	 eax, DWORD PTR _pos$[ebp], 44
  00036	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_hooks
  0003c	89 45 f4	 mov	 DWORD PTR _pHook$[ebp], eax

; 354  :     DWORD  oldProtect;
; 355  :     SIZE_T patchSize    = sizeof(JMP_REL);

  0003f	c7 45 dc 05 00
	00 00		 mov	 DWORD PTR _patchSize$[ebp], 5

; 356  :     LPBYTE pPatchTarget = (LPBYTE)pHook->pTarget;

  00046	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	89 4d d0	 mov	 DWORD PTR _pPatchTarget$[ebp], ecx

; 357  : 
; 358  :     if (pHook->patchAbove)

  0004e	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  00051	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00054	80 e1 01	 and	 cl, 1
  00057	0f b6 d1	 movzx	 edx, cl
  0005a	85 d2		 test	 edx, edx
  0005c	74 12		 je	 SHORT $LN2@EnableHook

; 359  :     {
; 360  :         pPatchTarget -= sizeof(JMP_REL);

  0005e	8b 45 d0	 mov	 eax, DWORD PTR _pPatchTarget$[ebp]
  00061	83 e8 05	 sub	 eax, 5
  00064	89 45 d0	 mov	 DWORD PTR _pPatchTarget$[ebp], eax

; 361  :         patchSize    += sizeof(JMP_REL_SHORT);

  00067	8b 45 dc	 mov	 eax, DWORD PTR _patchSize$[ebp]
  0006a	83 c0 02	 add	 eax, 2
  0006d	89 45 dc	 mov	 DWORD PTR _patchSize$[ebp], eax
$LN2@EnableHook:

; 362  :     }
; 363  : 
; 364  :     if (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &oldProtect))

  00070	8b f4		 mov	 esi, esp
  00072	8d 45 e8	 lea	 eax, DWORD PTR _oldProtect$[ebp]
  00075	50		 push	 eax
  00076	6a 40		 push	 64			; 00000040H
  00078	8b 4d dc	 mov	 ecx, DWORD PTR _patchSize$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 d0	 mov	 edx, DWORD PTR _pPatchTarget$[ebp]
  0007f	52		 push	 edx
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualProtect@16
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	85 c0		 test	 eax, eax
  0008f	75 0a		 jne	 SHORT $LN3@EnableHook

; 365  :         return MH_ERROR_MEMORY_PROTECT;

  00091	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00096	e9 02 01 00 00	 jmp	 $LN1@EnableHook
$LN3@EnableHook:

; 366  : 
; 367  :     if (enable)

  0009b	83 7d 0c 00	 cmp	 DWORD PTR _enable$[ebp], 0
  0009f	74 47		 je	 SHORT $LN4@EnableHook

; 368  :     {
; 369  :         PJMP_REL pJmp = (PJMP_REL)pPatchTarget;

  000a1	8b 45 d0	 mov	 eax, DWORD PTR _pPatchTarget$[ebp]
  000a4	89 45 c4	 mov	 DWORD PTR _pJmp$2[ebp], eax

; 370  :         pJmp->opcode = 0xE9;

  000a7	8b 45 c4	 mov	 eax, DWORD PTR _pJmp$2[ebp]
  000aa	c6 00 e9	 mov	 BYTE PTR [eax], 233	; 000000e9H

; 371  :         pJmp->operand = (UINT32)((LPBYTE)pHook->pDetour - (pPatchTarget + sizeof(JMP_REL)));

  000ad	8b 45 d0	 mov	 eax, DWORD PTR _pPatchTarget$[ebp]
  000b0	83 c0 05	 add	 eax, 5
  000b3	8b 4d f4	 mov	 ecx, DWORD PTR _pHook$[ebp]
  000b6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b9	2b d0		 sub	 edx, eax
  000bb	8b 45 c4	 mov	 eax, DWORD PTR _pJmp$2[ebp]
  000be	89 50 01	 mov	 DWORD PTR [eax+1], edx

; 372  : 
; 373  :         if (pHook->patchAbove)

  000c1	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  000c4	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  000c7	80 e1 01	 and	 cl, 1
  000ca	0f b6 d1	 movzx	 edx, cl
  000cd	85 d2		 test	 edx, edx
  000cf	74 15		 je	 SHORT $LN6@EnableHook

; 374  :         {
; 375  :             PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook->pTarget;

  000d1	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  000d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d6	89 4d b8	 mov	 DWORD PTR _pShortJmp$1[ebp], ecx

; 376  :             pShortJmp->opcode = 0xEB;

  000d9	8b 45 b8	 mov	 eax, DWORD PTR _pShortJmp$1[ebp]
  000dc	c6 00 eb	 mov	 BYTE PTR [eax], 235	; 000000ebH

; 377  :             pShortJmp->operand = (UINT8)(0 - (sizeof(JMP_REL_SHORT) + sizeof(JMP_REL)));

  000df	8b 45 b8	 mov	 eax, DWORD PTR _pShortJmp$1[ebp]
  000e2	c6 40 01 f9	 mov	 BYTE PTR [eax+1], 249	; 000000f9H
$LN6@EnableHook:

; 378  :         }
; 379  :     }

  000e6	eb 3c		 jmp	 SHORT $LN5@EnableHook
$LN4@EnableHook:

; 380  :     else
; 381  :     {
; 382  :         if (pHook->patchAbove)

  000e8	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  000eb	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  000ee	80 e1 01	 and	 cl, 1
  000f1	0f b6 d1	 movzx	 edx, cl
  000f4	85 d2		 test	 edx, edx
  000f6	74 17		 je	 SHORT $LN7@EnableHook

; 383  :             memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));

  000f8	6a 07		 push	 7
  000fa	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  000fd	83 c0 0c	 add	 eax, 12			; 0000000cH
  00100	50		 push	 eax
  00101	8b 4d d0	 mov	 ecx, DWORD PTR _pPatchTarget$[ebp]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 _memcpy
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010d	eb 15		 jmp	 SHORT $LN5@EnableHook
$LN7@EnableHook:

; 384  :         else
; 385  :             memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL));

  0010f	6a 05		 push	 5
  00111	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  00114	83 c0 0c	 add	 eax, 12			; 0000000cH
  00117	50		 push	 eax
  00118	8b 4d d0	 mov	 ecx, DWORD PTR _pPatchTarget$[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _memcpy
  00121	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@EnableHook:

; 386  :     }
; 387  : 
; 388  :     VirtualProtect(pPatchTarget, patchSize, oldProtect, &oldProtect);

  00124	8b f4		 mov	 esi, esp
  00126	8d 45 e8	 lea	 eax, DWORD PTR _oldProtect$[ebp]
  00129	50		 push	 eax
  0012a	8b 4d e8	 mov	 ecx, DWORD PTR _oldProtect$[ebp]
  0012d	51		 push	 ecx
  0012e	8b 55 dc	 mov	 edx, DWORD PTR _patchSize$[ebp]
  00131	52		 push	 edx
  00132	8b 45 d0	 mov	 eax, DWORD PTR _pPatchTarget$[ebp]
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualProtect@16
  0013c	3b f4		 cmp	 esi, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 389  : 
; 390  :     // Just-in-case measure.
; 391  :     FlushInstructionCache(GetCurrentProcess(), pPatchTarget, patchSize);

  00143	8b f4		 mov	 esi, esp
  00145	8b 45 dc	 mov	 eax, DWORD PTR _patchSize$[ebp]
  00148	50		 push	 eax
  00149	8b 4d d0	 mov	 ecx, DWORD PTR _pPatchTarget$[ebp]
  0014c	51		 push	 ecx
  0014d	8b fc		 mov	 edi, esp
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00155	3b fc		 cmp	 edi, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015c	50		 push	 eax
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushInstructionCache@12
  00163	3b f4		 cmp	 esi, esp
  00165	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 392  : 
; 393  :     pHook->isEnabled   = enable;

  0016a	8a 45 0c	 mov	 al, BYTE PTR _enable$[ebp]
  0016d	24 01		 and	 al, 1
  0016f	d0 e0		 shl	 al, 1
  00171	8b 4d f4	 mov	 ecx, DWORD PTR _pHook$[ebp]
  00174	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00177	80 e2 fd	 and	 dl, 253			; 000000fdH
  0017a	0a d0		 or	 dl, al
  0017c	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  0017f	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 394  :     pHook->queueEnable = enable;

  00182	8a 45 0c	 mov	 al, BYTE PTR _enable$[ebp]
  00185	24 01		 and	 al, 1
  00187	c0 e0 02	 shl	 al, 2
  0018a	8b 4d f4	 mov	 ecx, DWORD PTR _pHook$[ebp]
  0018d	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00190	80 e2 fb	 and	 dl, 251			; 000000fbH
  00193	0a d0		 or	 dl, al
  00195	8b 45 f4	 mov	 eax, DWORD PTR _pHook$[ebp]
  00198	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 395  : 
; 396  :     return MH_OK;

  0019b	33 c0		 xor	 eax, eax
$LN1@EnableHook:

; 397  : }

  0019d	52		 push	 edx
  0019e	8b cd		 mov	 ecx, ebp
  001a0	50		 push	 eax
  001a1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@EnableHook
  001a7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ac	58		 pop	 eax
  001ad	5a		 pop	 edx
  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi
  001b0	5b		 pop	 ebx
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	33 cd		 xor	 ecx, ebp
  001b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bb	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  001c1	3b ec		 cmp	 ebp, esp
  001c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
$LN12@EnableHook:
  001cc	01 00 00 00	 DD	 1
  001d0	00 00 00 00	 DD	 $LN11@EnableHook
$LN11@EnableHook:
  001d4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  001d8	04 00 00 00	 DD	 4
  001dc	00 00 00 00	 DD	 $LN10@EnableHook
$LN10@EnableHook:
  001e0	6f		 DB	 111			; 0000006fH
  001e1	6c		 DB	 108			; 0000006cH
  001e2	64		 DB	 100			; 00000064H
  001e3	50		 DB	 80			; 00000050H
  001e4	72		 DB	 114			; 00000072H
  001e5	6f		 DB	 111			; 0000006fH
  001e6	74		 DB	 116			; 00000074H
  001e7	65		 DB	 101			; 00000065H
  001e8	63		 DB	 99			; 00000063H
  001e9	74		 DB	 116			; 00000074H
  001ea	00		 DB	 0
_EnableHookLL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _Unfreeze
_TEXT	SEGMENT
_hThread$1 = -20					; size = 4
_i$2 = -8						; size = 4
_pThreads$ = 8						; size = 4
_Unfreeze PROC						; COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 333  :     if (pThreads->pItems != NULL)

  00028	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	0f 84 8b 00 00
	00		 je	 $LN1@Unfreeze

; 334  :     {
; 335  :         UINT i;
; 336  :         for (i = 0; i < pThreads->size; ++i)

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@Unfreeze
$LN2@Unfreeze:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@Unfreeze:
  00046	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  0004c	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0004f	73 50		 jae	 SHORT $LN3@Unfreeze

; 337  :         {
; 338  :             HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);

  00051	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	8b f4		 mov	 esi, esp
  00058	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  0005b	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0005e	50		 push	 eax
  0005f	6a 00		 push	 0
  00061	6a 5a		 push	 90			; 0000005aH
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenThread@12
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	89 45 ec	 mov	 DWORD PTR _hThread$1[ebp], eax

; 339  :             if (hThread != NULL)

  00073	83 7d ec 00	 cmp	 DWORD PTR _hThread$1[ebp], 0
  00077	74 26		 je	 SHORT $LN6@Unfreeze

; 340  :             {
; 341  :                 ResumeThread(hThread);

  00079	8b f4		 mov	 esi, esp
  0007b	8b 45 ec	 mov	 eax, DWORD PTR _hThread$1[ebp]
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResumeThread@4
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 342  :                 CloseHandle(hThread);

  0008c	8b f4		 mov	 esi, esp
  0008e	8b 45 ec	 mov	 eax, DWORD PTR _hThread$1[ebp]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@Unfreeze:

; 343  :             }
; 344  :         }

  0009f	eb 9c		 jmp	 SHORT $LN2@Unfreeze
$LN3@Unfreeze:

; 345  : 
; 346  :         HeapFree(g_hHeap, 0, pThreads->pItems);

  000a1	8b f4		 mov	 esi, esp
  000a3	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	51		 push	 ecx
  000a9	6a 00		 push	 0
  000ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hHeap
  000b1	52		 push	 edx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Unfreeze:

; 347  :     }
; 348  : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c8	3b ec		 cmp	 ebp, esp
  000ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
_Unfreeze ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _Freeze
_TEXT	SEGMENT
_hThread$1 = -20					; size = 4
_i$2 = -8						; size = 4
_pThreads$ = 8						; size = 4
_pos$ = 12						; size = 4
_action$ = 16						; size = 4
_Freeze	PROC						; COMDAT

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 309  :     pThreads->pItems   = NULL;

  00028	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 310  :     pThreads->capacity = 0;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00034	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 311  :     pThreads->size     = 0;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  0003e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 312  :     EnumerateThreads(pThreads);

  00045	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _EnumerateThreads
  0004e	83 c4 04	 add	 esp, 4

; 313  : 
; 314  :     if (pThreads->pItems != NULL)

  00051	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	0f 84 81 00 00
	00		 je	 $LN1@Freeze

; 315  :     {
; 316  :         UINT i;
; 317  :         for (i = 0; i < pThreads->size; ++i)

  0005d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00064	eb 09		 jmp	 SHORT $LN4@Freeze
$LN2@Freeze:
  00066	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00069	83 c0 01	 add	 eax, 1
  0006c	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@Freeze:
  0006f	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00072	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00075	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00078	73 64		 jae	 SHORT $LN1@Freeze

; 318  :         {
; 319  :             HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);

  0007a	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	8b f4		 mov	 esi, esp
  00081	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00084	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00087	50		 push	 eax
  00088	6a 00		 push	 0
  0008a	6a 5a		 push	 90			; 0000005aH
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenThread@12
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	89 45 ec	 mov	 DWORD PTR _hThread$1[ebp], eax

; 320  :             if (hThread != NULL)

  0009c	83 7d ec 00	 cmp	 DWORD PTR _hThread$1[ebp], 0
  000a0	74 3a		 je	 SHORT $LN6@Freeze

; 321  :             {
; 322  :                 SuspendThread(hThread);

  000a2	8b f4		 mov	 esi, esp
  000a4	8b 45 ec	 mov	 eax, DWORD PTR _hThread$1[ebp]
  000a7	50		 push	 eax
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SuspendThread@4
  000ae	3b f4		 cmp	 esi, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 323  :                 ProcessThreadIPs(hThread, pos, action);

  000b5	8b 45 10	 mov	 eax, DWORD PTR _action$[ebp]
  000b8	50		 push	 eax
  000b9	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  000bc	51		 push	 ecx
  000bd	8b 55 ec	 mov	 edx, DWORD PTR _hThread$1[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 _ProcessThreadIPs
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 324  :                 CloseHandle(hThread);

  000c9	8b f4		 mov	 esi, esp
  000cb	8b 45 ec	 mov	 eax, DWORD PTR _hThread$1[ebp]
  000ce	50		 push	 eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  000d5	3b f4		 cmp	 esi, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@Freeze:

; 325  :             }
; 326  :         }

  000dc	eb 88		 jmp	 SHORT $LN2@Freeze
$LN1@Freeze:

; 327  :     }
; 328  : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000e7	3b ec		 cmp	 ebp, esp
  000e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
_Freeze	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _EnumerateThreads
_TEXT	SEGMENT
_p$1 = -60						; size = 4
_te$2 = -48						; size = 28
_hSnapshot$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_pThreads$ = 8						; size = 4
_EnumerateThreads PROC					; COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 265  :     HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

  00032	6a 00		 push	 0
  00034	6a 04		 push	 4
  00036	e8 00 00 00 00	 call	 _CreateToolhelp32Snapshot@8
  0003b	89 45 f4	 mov	 DWORD PTR _hSnapshot$[ebp], eax

; 266  :     if (hSnapshot != INVALID_HANDLE_VALUE)

  0003e	83 7d f4 ff	 cmp	 DWORD PTR _hSnapshot$[ebp], -1
  00042	0f 84 46 01 00
	00		 je	 $LN1@EnumerateT

; 267  :     {
; 268  :         THREADENTRY32 te;
; 269  :         te.dwSize = sizeof(THREADENTRY32);

  00048	c7 45 d0 1c 00
	00 00		 mov	 DWORD PTR _te$2[ebp], 28 ; 0000001cH

; 270  :         if (Thread32First(hSnapshot, &te))

  0004f	8d 45 d0	 lea	 eax, DWORD PTR _te$2[ebp]
  00052	50		 push	 eax
  00053	8b 4d f4	 mov	 ecx, DWORD PTR _hSnapshot$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _Thread32First@8
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 17 01 00
	00		 je	 $LN6@EnumerateT
$LN4@EnumerateT:

; 271  :         {
; 272  :             do
; 273  :             {
; 274  :                 if (te.dwSize >= (FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(DWORD))
; 275  :                     && te.th32OwnerProcessID == GetCurrentProcessId()
; 276  :                     && te.th32ThreadID != GetCurrentThreadId())

  00064	83 7d d0 10	 cmp	 DWORD PTR _te$2[ebp], 16 ; 00000010H
  00068	0f 82 f1 00 00
	00		 jb	 $LN7@EnumerateT
  0006e	8b f4		 mov	 esi, esp
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	39 45 dc	 cmp	 DWORD PTR _te$2[ebp+12], eax
  00080	0f 85 d9 00 00
	00		 jne	 $LN7@EnumerateT
  00086	8b f4		 mov	 esi, esp
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	39 45 d8	 cmp	 DWORD PTR _te$2[ebp+8], eax
  00098	0f 84 c1 00 00
	00		 je	 $LN7@EnumerateT

; 277  :                 {
; 278  :                     if (pThreads->pItems == NULL)

  0009e	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  000a1	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a4	75 40		 jne	 SHORT $LN8@EnumerateT

; 279  :                     {
; 280  :                         pThreads->capacity = INITIAL_THREAD_CAPACITY;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  000a9	c7 40 04 80 00
	00 00		 mov	 DWORD PTR [eax+4], 128	; 00000080H

; 281  :                         pThreads->pItems
; 282  :                             = (LPDWORD)HeapAlloc(g_hHeap, 0, pThreads->capacity * sizeof(DWORD));

  000b0	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  000b3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b6	c1 e1 02	 shl	 ecx, 2
  000b9	8b f4		 mov	 esi, esp
  000bb	51		 push	 ecx
  000bc	6a 00		 push	 0
  000be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hHeap
  000c4	52		 push	 edx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  000cb	3b f4		 cmp	 esi, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _pThreads$[ebp]
  000d5	89 01		 mov	 DWORD PTR [ecx], eax

; 283  :                         if (pThreads->pItems == NULL)

  000d7	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  000da	83 38 00	 cmp	 DWORD PTR [eax], 0
  000dd	75 05		 jne	 SHORT $LN10@EnumerateT

; 284  :                             break;

  000df	e9 97 00 00 00	 jmp	 $LN6@EnumerateT
$LN10@EnumerateT:

; 285  :                     }

  000e4	eb 59		 jmp	 SHORT $LN9@EnumerateT
$LN8@EnumerateT:

; 286  :                     else if (pThreads->size >= pThreads->capacity)

  000e6	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _pThreads$[ebp]
  000ec	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000ef	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000f2	72 4b		 jb	 SHORT $LN9@EnumerateT

; 287  :                     {
; 288  :                         LPDWORD p = (LPDWORD)HeapReAlloc(

  000f4	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  000f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fa	d1 e1		 shl	 ecx, 1
  000fc	c1 e1 02	 shl	 ecx, 2
  000ff	8b f4		 mov	 esi, esp
  00101	51		 push	 ecx
  00102	8b 55 08	 mov	 edx, DWORD PTR _pThreads$[ebp]
  00105	8b 02		 mov	 eax, DWORD PTR [edx]
  00107	50		 push	 eax
  00108	6a 00		 push	 0
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hHeap
  00110	51		 push	 ecx
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapReAlloc@16
  00117	3b f4		 cmp	 esi, esp
  00119	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011e	89 45 c4	 mov	 DWORD PTR _p$1[ebp], eax

; 289  :                             g_hHeap, 0, pThreads->pItems, (pThreads->capacity * 2) * sizeof(DWORD));
; 290  :                         if (p == NULL)

  00121	83 7d c4 00	 cmp	 DWORD PTR _p$1[ebp], 0
  00125	75 02		 jne	 SHORT $LN12@EnumerateT

; 291  :                             break;

  00127	eb 52		 jmp	 SHORT $LN6@EnumerateT
$LN12@EnumerateT:

; 292  : 
; 293  :                         pThreads->capacity *= 2;

  00129	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  0012c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012f	d1 e1		 shl	 ecx, 1
  00131	8b 55 08	 mov	 edx, DWORD PTR _pThreads$[ebp]
  00134	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 294  :                         pThreads->pItems = p;

  00137	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  0013a	8b 4d c4	 mov	 ecx, DWORD PTR _p$1[ebp]
  0013d	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@EnumerateT:

; 295  :                     }
; 296  :                     pThreads->pItems[pThreads->size++] = te.th32ThreadID;

  0013f	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00142	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00145	8b 55 08	 mov	 edx, DWORD PTR _pThreads$[ebp]
  00148	8b 02		 mov	 eax, DWORD PTR [edx]
  0014a	8b 55 d8	 mov	 edx, DWORD PTR _te$2[ebp+8]
  0014d	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  00150	8b 45 08	 mov	 eax, DWORD PTR _pThreads$[ebp]
  00153	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00156	83 c1 01	 add	 ecx, 1
  00159	8b 55 08	 mov	 edx, DWORD PTR _pThreads$[ebp]
  0015c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN7@EnumerateT:

; 297  :                 }
; 298  : 
; 299  :                 te.dwSize = sizeof(THREADENTRY32);

  0015f	c7 45 d0 1c 00
	00 00		 mov	 DWORD PTR _te$2[ebp], 28 ; 0000001cH

; 300  :             } while (Thread32Next(hSnapshot, &te));

  00166	8d 45 d0	 lea	 eax, DWORD PTR _te$2[ebp]
  00169	50		 push	 eax
  0016a	8b 4d f4	 mov	 ecx, DWORD PTR _hSnapshot$[ebp]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 _Thread32Next@8
  00173	85 c0		 test	 eax, eax
  00175	0f 85 e9 fe ff
	ff		 jne	 $LN4@EnumerateT
$LN6@EnumerateT:

; 301  :         }
; 302  :         CloseHandle(hSnapshot);

  0017b	8b f4		 mov	 esi, esp
  0017d	8b 45 f4	 mov	 eax, DWORD PTR _hSnapshot$[ebp]
  00180	50		 push	 eax
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00187	3b f4		 cmp	 esi, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@EnumerateT:

; 303  :     }
; 304  : }

  0018e	52		 push	 edx
  0018f	8b cd		 mov	 ecx, ebp
  00191	50		 push	 eax
  00192	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@EnumerateT
  00198	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0019d	58		 pop	 eax
  0019e	5a		 pop	 edx
  0019f	5f		 pop	 edi
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a5	33 cd		 xor	 ecx, ebp
  001a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ac	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  001b2	3b ec		 cmp	 ebp, esp
  001b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
  001bd	0f 1f 00	 npad	 3
$LN16@EnumerateT:
  001c0	01 00 00 00	 DD	 1
  001c4	00 00 00 00	 DD	 $LN15@EnumerateT
$LN15@EnumerateT:
  001c8	d0 ff ff ff	 DD	 -48			; ffffffd0H
  001cc	1c 00 00 00	 DD	 28			; 0000001cH
  001d0	00 00 00 00	 DD	 $LN14@EnumerateT
$LN14@EnumerateT:
  001d4	74		 DB	 116			; 00000074H
  001d5	65		 DB	 101			; 00000065H
  001d6	00		 DB	 0
_EnumerateThreads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _ProcessThreadIPs
_TEXT	SEGMENT
tv74 = -1176						; size = 4
_ip$1 = -784						; size = 4
_enable$2 = -772					; size = 4
_pHook$3 = -760						; size = 4
_count$ = -748						; size = 4
_pIP$ = -736						; size = 4
_c$ = -724						; size = 716
__$ArrayPad$ = -4					; size = 4
_hThread$ = 8						; size = 4
_pos$ = 12						; size = 4
_action$ = 16						; size = 4
_ProcessThreadIPs PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 04 00
	00		 sub	 esp, 1176		; 00000498H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 68 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1176]
  00012	b9 26 01 00 00	 mov	 ecx, 294		; 00000126H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 201  :     // If the thread suspended in the overwritten area,
; 202  :     // move IP to the proper address.
; 203  : 
; 204  :     CONTEXT c;
; 205  : #if defined(_M_X64) || defined(__x86_64__)
; 206  :     DWORD64 *pIP = &c.Rip;
; 207  : #else
; 208  :     DWORD   *pIP = &c.Eip;

  00032	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _c$[ebp+184]
  00038	89 85 20 fd ff
	ff		 mov	 DWORD PTR _pIP$[ebp], eax

; 209  : #endif
; 210  :     UINT count;
; 211  : 
; 212  :     c.ContextFlags = CONTEXT_CONTROL;

  0003e	c7 85 2c fd ff
	ff 01 00 01 00	 mov	 DWORD PTR _c$[ebp], 65537 ; 00010001H

; 213  :     if (!GetThreadContext(hThread, &c))

  00048	8b f4		 mov	 esi, esp
  0004a	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR _c$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _hThread$[ebp]
  00054	51		 push	 ecx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadContext@8
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	85 c0		 test	 eax, eax
  00064	75 05		 jne	 SHORT $LN7@ProcessThr

; 214  :         return;

  00066	e9 38 01 00 00	 jmp	 $LN1@ProcessThr
$LN7@ProcessThr:

; 215  : 
; 216  :     if (pos == ALL_HOOKS_POS)

  0006b	83 7d 0c ff	 cmp	 DWORD PTR _pos$[ebp], -1
  0006f	75 14		 jne	 SHORT $LN8@ProcessThr

; 217  :     {
; 218  :         pos = 0;

  00071	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _pos$[ebp], 0

; 219  :         count = g_hooks.size;

  00078	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_hooks+8
  0007d	89 85 14 fd ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 220  :     }

  00083	eb 0c		 jmp	 SHORT $LN9@ProcessThr
$LN8@ProcessThr:

; 221  :     else
; 222  :     {
; 223  :         count = pos + 1;

  00085	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 85 14 fd ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN9@ProcessThr:

; 224  :     }
; 225  : 
; 226  :     for (; pos < count; ++pos)

  00091	eb 09		 jmp	 SHORT $LN4@ProcessThr
$LN2@ProcessThr:
  00093	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 0c	 mov	 DWORD PTR _pos$[ebp], eax
$LN4@ProcessThr:
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0009f	3b 85 14 fd ff
	ff		 cmp	 eax, DWORD PTR _count$[ebp]
  000a5	0f 83 f8 00 00
	00		 jae	 $LN1@ProcessThr

; 227  :     {
; 228  :         PHOOK_ENTRY pHook = &g_hooks.pItems[pos];

  000ab	6b 45 0c 2c	 imul	 eax, DWORD PTR _pos$[ebp], 44
  000af	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_hooks
  000b5	89 85 08 fd ff
	ff		 mov	 DWORD PTR _pHook$3[ebp], eax

; 229  :         BOOL        enable;
; 230  :         DWORD_PTR   ip;
; 231  : 
; 232  :         switch (action)

  000bb	8b 45 10	 mov	 eax, DWORD PTR _action$[ebp]
  000be	89 85 68 fb ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  000c4	83 bd 68 fb ff
	ff 00		 cmp	 DWORD PTR tv74[ebp], 0
  000cb	74 0b		 je	 SHORT $LN10@ProcessThr
  000cd	83 bd 68 fb ff
	ff 01		 cmp	 DWORD PTR tv74[ebp], 1
  000d4	74 0e		 je	 SHORT $LN11@ProcessThr
  000d6	eb 18		 jmp	 SHORT $LN12@ProcessThr
$LN10@ProcessThr:

; 233  :         {
; 234  :         case ACTION_DISABLE:
; 235  :             enable = FALSE;

  000d8	c7 85 fc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _enable$2[ebp], 0

; 236  :             break;

  000e2	eb 24		 jmp	 SHORT $LN5@ProcessThr
$LN11@ProcessThr:

; 237  : 
; 238  :         case ACTION_ENABLE:
; 239  :             enable = TRUE;

  000e4	c7 85 fc fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _enable$2[ebp], 1

; 240  :             break;

  000ee	eb 18		 jmp	 SHORT $LN5@ProcessThr
$LN12@ProcessThr:

; 241  : 
; 242  :         default: // ACTION_APPLY_QUEUED
; 243  :             enable = pHook->queueEnable;

  000f0	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _pHook$3[ebp]
  000f6	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  000f9	c0 e9 02	 shr	 cl, 2
  000fc	80 e1 01	 and	 cl, 1
  000ff	0f b6 d1	 movzx	 edx, cl
  00102	89 95 fc fc ff
	ff		 mov	 DWORD PTR _enable$2[ebp], edx
$LN5@ProcessThr:

; 244  :             break;
; 245  :         }
; 246  :         if (pHook->isEnabled == enable)

  00108	8b 85 08 fd ff
	ff		 mov	 eax, DWORD PTR _pHook$3[ebp]
  0010e	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00111	d0 e9		 shr	 cl, 1
  00113	80 e1 01	 and	 cl, 1
  00116	0f b6 d1	 movzx	 edx, cl
  00119	3b 95 fc fc ff
	ff		 cmp	 edx, DWORD PTR _enable$2[ebp]
  0011f	75 05		 jne	 SHORT $LN13@ProcessThr

; 247  :             continue;

  00121	e9 6d ff ff ff	 jmp	 $LN2@ProcessThr
$LN13@ProcessThr:

; 248  : 
; 249  :         if (enable)

  00126	83 bd fc fc ff
	ff 00		 cmp	 DWORD PTR _enable$2[ebp], 0
  0012d	74 20		 je	 SHORT $LN14@ProcessThr

; 250  :             ip = FindNewIP(pHook, *pIP);

  0012f	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _pIP$[ebp]
  00135	8b 08		 mov	 ecx, DWORD PTR [eax]
  00137	51		 push	 ecx
  00138	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _pHook$3[ebp]
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 _FindNewIP
  00144	83 c4 08	 add	 esp, 8
  00147	89 85 f0 fc ff
	ff		 mov	 DWORD PTR _ip$1[ebp], eax
  0014d	eb 1e		 jmp	 SHORT $LN15@ProcessThr
$LN14@ProcessThr:

; 251  :         else
; 252  :             ip = FindOldIP(pHook, *pIP);

  0014f	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _pIP$[ebp]
  00155	8b 08		 mov	 ecx, DWORD PTR [eax]
  00157	51		 push	 ecx
  00158	8b 95 08 fd ff
	ff		 mov	 edx, DWORD PTR _pHook$3[ebp]
  0015e	52		 push	 edx
  0015f	e8 00 00 00 00	 call	 _FindOldIP
  00164	83 c4 08	 add	 esp, 8
  00167	89 85 f0 fc ff
	ff		 mov	 DWORD PTR _ip$1[ebp], eax
$LN15@ProcessThr:

; 253  : 
; 254  :         if (ip != 0)

  0016d	83 bd f0 fc ff
	ff 00		 cmp	 DWORD PTR _ip$1[ebp], 0
  00174	74 28		 je	 SHORT $LN16@ProcessThr

; 255  :         {
; 256  :             *pIP = ip;

  00176	8b 85 20 fd ff
	ff		 mov	 eax, DWORD PTR _pIP$[ebp]
  0017c	8b 8d f0 fc ff
	ff		 mov	 ecx, DWORD PTR _ip$1[ebp]
  00182	89 08		 mov	 DWORD PTR [eax], ecx

; 257  :             SetThreadContext(hThread, &c);

  00184	8b f4		 mov	 esi, esp
  00186	8d 85 2c fd ff
	ff		 lea	 eax, DWORD PTR _c$[ebp]
  0018c	50		 push	 eax
  0018d	8b 4d 08	 mov	 ecx, DWORD PTR _hThread$[ebp]
  00190	51		 push	 ecx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadContext@8
  00197	3b f4		 cmp	 esi, esp
  00199	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@ProcessThr:

; 258  :         }
; 259  :     }

  0019e	e9 f0 fe ff ff	 jmp	 $LN2@ProcessThr
$LN1@ProcessThr:

; 260  : }

  001a3	52		 push	 edx
  001a4	8b cd		 mov	 ecx, ebp
  001a6	50		 push	 eax
  001a7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@ProcessThr
  001ad	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001b2	58		 pop	 eax
  001b3	5a		 pop	 edx
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi
  001b6	5b		 pop	 ebx
  001b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ba	33 cd		 xor	 ecx, ebp
  001bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c1	81 c4 98 04 00
	00		 add	 esp, 1176		; 00000498H
  001c7	3b ec		 cmp	 ebp, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
  001d2	66 90		 npad	 2
$LN20@ProcessThr:
  001d4	01 00 00 00	 DD	 1
  001d8	00 00 00 00	 DD	 $LN19@ProcessThr
$LN19@ProcessThr:
  001dc	2c fd ff ff	 DD	 -724			; fffffd2cH
  001e0	cc 02 00 00	 DD	 716			; 000002ccH
  001e4	00 00 00 00	 DD	 $LN18@ProcessThr
$LN18@ProcessThr:
  001e8	63		 DB	 99			; 00000063H
  001e9	00		 DB	 0
_ProcessThreadIPs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _FindNewIP
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pHook$ = 8						; size = 4
_ip$ = 12						; size = 4
_FindNewIP PROC						; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 188  :     UINT i;
; 189  :     for (i = 0; i < pHook->nIP; ++i)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@FindNewIP
$LN2@FindNewIP:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FindNewIP:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  0003d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00040	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00043	39 4d f8	 cmp	 DWORD PTR _i$[ebp], ecx
  00046	73 28		 jae	 SHORT $LN3@FindNewIP

; 190  :     {
; 191  :         if (ip == ((DWORD_PTR)pHook->pTarget + pHook->oldIPs[i]))

  00048	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  0004b	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0004e	0f b6 48 1c	 movzx	 ecx, BYTE PTR [eax+28]
  00052	8b 55 08	 mov	 edx, DWORD PTR _pHook$[ebp]
  00055	03 0a		 add	 ecx, DWORD PTR [edx]
  00057	39 4d 0c	 cmp	 DWORD PTR _ip$[ebp], ecx
  0005a	75 12		 jne	 SHORT $LN5@FindNewIP

; 192  :             return (DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i];

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  0005f	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00062	0f b6 40 24	 movzx	 eax, BYTE PTR [eax+36]
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _pHook$[ebp]
  00069	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0006c	eb 04		 jmp	 SHORT $LN1@FindNewIP
$LN5@FindNewIP:

; 193  :     }

  0006e	eb c1		 jmp	 SHORT $LN2@FindNewIP
$LN3@FindNewIP:

; 194  : 
; 195  :     return 0;

  00070	33 c0		 xor	 eax, eax
$LN1@FindNewIP:

; 196  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_FindNewIP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _FindOldIP
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pHook$ = 8						; size = 4
_ip$ = 12						; size = 4
_FindOldIP PROC						; COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 165  :     UINT i;
; 166  : 
; 167  :     if (pHook->patchAbove && ip == ((DWORD_PTR)pHook->pTarget - sizeof(JMP_REL)))

  00028	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  0002b	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  0002e	80 e1 01	 and	 cl, 1
  00031	0f b6 d1	 movzx	 edx, cl
  00034	85 d2		 test	 edx, edx
  00036	74 14		 je	 SHORT $LN5@FindOldIP
  00038	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	83 e9 05	 sub	 ecx, 5
  00040	39 4d 0c	 cmp	 DWORD PTR _ip$[ebp], ecx
  00043	75 07		 jne	 SHORT $LN5@FindOldIP

; 168  :         return (DWORD_PTR)pHook->pTarget;

  00045	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	eb 4a		 jmp	 SHORT $LN1@FindOldIP
$LN5@FindOldIP:

; 169  : 
; 170  :     for (i = 0; i < pHook->nIP; ++i)

  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00053	eb 09		 jmp	 SHORT $LN4@FindOldIP
$LN2@FindOldIP:
  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FindOldIP:
  0005e	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  00061	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00064	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00067	39 4d f8	 cmp	 DWORD PTR _i$[ebp], ecx
  0006a	73 28		 jae	 SHORT $LN3@FindOldIP

; 171  :     {
; 172  :         if (ip == ((DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i]))

  0006c	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  0006f	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00072	0f b6 48 24	 movzx	 ecx, BYTE PTR [eax+36]
  00076	8b 55 08	 mov	 edx, DWORD PTR _pHook$[ebp]
  00079	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  0007c	39 4d 0c	 cmp	 DWORD PTR _ip$[ebp], ecx
  0007f	75 11		 jne	 SHORT $LN6@FindOldIP

; 173  :             return (DWORD_PTR)pHook->pTarget + pHook->oldIPs[i];

  00081	8b 45 08	 mov	 eax, DWORD PTR _pHook$[ebp]
  00084	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00087	0f b6 40 1c	 movzx	 eax, BYTE PTR [eax+28]
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _pHook$[ebp]
  0008e	03 01		 add	 eax, DWORD PTR [ecx]
  00090	eb 04		 jmp	 SHORT $LN1@FindOldIP
$LN6@FindOldIP:

; 174  :     }

  00092	eb c1		 jmp	 SHORT $LN2@FindOldIP
$LN3@FindOldIP:

; 175  : 
; 176  : #if defined(_M_X64) || defined(__x86_64__)
; 177  :     // Check relay function.
; 178  :     if (ip == (DWORD_PTR)pHook->pDetour)
; 179  :         return (DWORD_PTR)pHook->pTarget;
; 180  : #endif
; 181  : 
; 182  :     return 0;

  00094	33 c0		 xor	 eax, eax
$LN1@FindOldIP:

; 183  : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
_FindOldIP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _DeleteHookEntry
_TEXT	SEGMENT
_p$1 = -8						; size = 4
_pos$ = 8						; size = 4
_DeleteHookEntry PROC					; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 145  :     if (pos < g_hooks.size - 1)

  00028	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_hooks+8
  0002d	83 e8 01	 sub	 eax, 1
  00030	39 45 08	 cmp	 DWORD PTR _pos$[ebp], eax
  00033	73 22		 jae	 SHORT $LN2@DeleteHook

; 146  :         g_hooks.pItems[pos] = g_hooks.pItems[g_hooks.size - 1];

  00035	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_hooks+8
  0003a	83 e8 01	 sub	 eax, 1
  0003d	6b f0 2c	 imul	 esi, eax, 44
  00040	03 35 00 00 00
	00		 add	 esi, DWORD PTR _g_hooks
  00046	6b 7d 08 2c	 imul	 edi, DWORD PTR _pos$[ebp], 44
  0004a	03 3d 00 00 00
	00		 add	 edi, DWORD PTR _g_hooks
  00050	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00055	f3 a5		 rep movsd
$LN2@DeleteHook:

; 147  : 
; 148  :     g_hooks.size--;

  00057	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_hooks+8
  0005c	83 e8 01	 sub	 eax, 1
  0005f	a3 08 00 00 00	 mov	 DWORD PTR _g_hooks+8, eax

; 149  : 
; 150  :     if (g_hooks.capacity / 2 >= INITIAL_HOOK_CAPACITY && g_hooks.capacity / 2 >= g_hooks.size)

  00064	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_hooks+4
  00069	d1 e8		 shr	 eax, 1
  0006b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0006e	72 57		 jb	 SHORT $LN1@DeleteHook
  00070	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_hooks+4
  00075	d1 e8		 shr	 eax, 1
  00077	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+8
  0007d	72 48		 jb	 SHORT $LN1@DeleteHook

; 151  :     {
; 152  :         PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(

  0007f	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_hooks+4
  00084	d1 e8		 shr	 eax, 1
  00086	6b c8 2c	 imul	 ecx, eax, 44
  00089	8b f4		 mov	 esi, esp
  0008b	51		 push	 ecx
  0008c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hooks
  00092	52		 push	 edx
  00093	6a 00		 push	 0
  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hHeap
  0009a	50		 push	 eax
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapReAlloc@16
  000a1	3b f4		 cmp	 esi, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	89 45 f8	 mov	 DWORD PTR _p$1[ebp], eax

; 153  :             g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity / 2) * sizeof(HOOK_ENTRY));
; 154  :         if (p == NULL)

  000ab	83 7d f8 00	 cmp	 DWORD PTR _p$1[ebp], 0
  000af	75 02		 jne	 SHORT $LN4@DeleteHook

; 155  :             return;

  000b1	eb 14		 jmp	 SHORT $LN1@DeleteHook
$LN4@DeleteHook:

; 156  : 
; 157  :         g_hooks.capacity /= 2;

  000b3	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_hooks+4
  000b8	d1 e8		 shr	 eax, 1
  000ba	a3 04 00 00 00	 mov	 DWORD PTR _g_hooks+4, eax

; 158  :         g_hooks.pItems = p;

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _p$1[ebp]
  000c2	a3 00 00 00 00	 mov	 DWORD PTR _g_hooks, eax
$LN1@DeleteHook:

; 159  :     }
; 160  : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d0	3b ec		 cmp	 ebp, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
_DeleteHookEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _AddHookEntry
_TEXT	SEGMENT
tv90 = -208						; size = 4
_p$1 = -8						; size = 4
_AddHookEntry PROC					; COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 120  :     if (g_hooks.pItems == NULL)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hooks, 0
  0002f	75 41		 jne	 SHORT $LN2@AddHookEnt

; 121  :     {
; 122  :         g_hooks.capacity = INITIAL_HOOK_CAPACITY;

  00031	c7 05 04 00 00
	00 20 00 00 00	 mov	 DWORD PTR _g_hooks+4, 32 ; 00000020H

; 123  :         g_hooks.pItems = (PHOOK_ENTRY)HeapAlloc(

  0003b	6b 05 04 00 00
	00 2c		 imul	 eax, DWORD PTR _g_hooks+4, 44
  00042	8b f4		 mov	 esi, esp
  00044	50		 push	 eax
  00045	6a 00		 push	 0
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hHeap
  0004d	51		 push	 ecx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	a3 00 00 00 00	 mov	 DWORD PTR _g_hooks, eax

; 124  :             g_hHeap, 0, g_hooks.capacity * sizeof(HOOK_ENTRY));
; 125  :         if (g_hooks.pItems == NULL)

  00060	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hooks, 0
  00067	75 07		 jne	 SHORT $LN4@AddHookEnt

; 126  :             return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 81 00 00 00	 jmp	 $LN1@AddHookEnt
$LN4@AddHookEnt:

; 127  :     }

  00070	eb 57		 jmp	 SHORT $LN3@AddHookEnt
$LN2@AddHookEnt:

; 128  :     else if (g_hooks.size >= g_hooks.capacity)

  00072	a1 08 00 00 00	 mov	 eax, DWORD PTR _g_hooks+8
  00077	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+4
  0007d	72 4a		 jb	 SHORT $LN3@AddHookEnt

; 129  :     {
; 130  :         PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(

  0007f	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_hooks+4
  00084	d1 e0		 shl	 eax, 1
  00086	6b c8 2c	 imul	 ecx, eax, 44
  00089	8b f4		 mov	 esi, esp
  0008b	51		 push	 ecx
  0008c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hooks
  00092	52		 push	 edx
  00093	6a 00		 push	 0
  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hHeap
  0009a	50		 push	 eax
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapReAlloc@16
  000a1	3b f4		 cmp	 esi, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	89 45 f8	 mov	 DWORD PTR _p$1[ebp], eax

; 131  :             g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity * 2) * sizeof(HOOK_ENTRY));
; 132  :         if (p == NULL)

  000ab	83 7d f8 00	 cmp	 DWORD PTR _p$1[ebp], 0
  000af	75 04		 jne	 SHORT $LN6@AddHookEnt

; 133  :             return NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	eb 3c		 jmp	 SHORT $LN1@AddHookEnt
$LN6@AddHookEnt:

; 134  : 
; 135  :         g_hooks.capacity *= 2;

  000b5	a1 04 00 00 00	 mov	 eax, DWORD PTR _g_hooks+4
  000ba	d1 e0		 shl	 eax, 1
  000bc	a3 04 00 00 00	 mov	 DWORD PTR _g_hooks+4, eax

; 136  :         g_hooks.pItems = p;

  000c1	8b 45 f8	 mov	 eax, DWORD PTR _p$1[ebp]
  000c4	a3 00 00 00 00	 mov	 DWORD PTR _g_hooks, eax
$LN3@AddHookEnt:

; 137  :     }
; 138  : 
; 139  :     return &g_hooks.pItems[g_hooks.size++];

  000c9	6b 05 08 00 00
	00 2c		 imul	 eax, DWORD PTR _g_hooks+8, 44
  000d0	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_hooks
  000d6	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  000dc	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks+8
  000e2	83 c1 01	 add	 ecx, 1
  000e5	89 0d 08 00 00
	00		 mov	 DWORD PTR _g_hooks+8, ecx
  000eb	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv90[ebp]
$LN1@AddHookEnt:

; 140  : }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000fa	3b ec		 cmp	 ebp, esp
  000fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_AddHookEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _FindHookEntry
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pTarget$ = 8						; size = 4
_FindHookEntry PROC					; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 107  :     UINT i;
; 108  :     for (i = 0; i < g_hooks.size; ++i)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@FindHookEn
$LN2@FindHookEn:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FindHookEn:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+8
  00043	73 19		 jae	 SHORT $LN3@FindHookEn

; 109  :     {
; 110  :         if ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)

  00045	6b 45 f8 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks
  0004f	8b 55 08	 mov	 edx, DWORD PTR _pTarget$[ebp]
  00052	3b 14 01	 cmp	 edx, DWORD PTR [ecx+eax]
  00055	75 05		 jne	 SHORT $LN5@FindHookEn

; 111  :             return i;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	eb 05		 jmp	 SHORT $LN1@FindHookEn
$LN5@FindHookEn:

; 112  :     }

  0005c	eb d3		 jmp	 SHORT $LN2@FindHookEn
$LN3@FindHookEn:

; 113  : 
; 114  :     return INVALID_HOOK_POS;

  0005e	83 c8 ff	 or	 eax, -1
$LN1@FindHookEn:

; 115  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_FindHookEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_StatusToString@4
_TEXT	SEGMENT
tv64 = -196						; size = 4
_status$ = 8						; size = 4
_MH_StatusToString@4 PROC				; COMDAT

; 864  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 865  : #define MH_ST2STR(x)    \
; 866  :     case x:             \
; 867  :         return #x;
; 868  : 
; 869  :     switch (status) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _status$[ebp]
  0002b	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00031	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  00037	83 c1 01	 add	 ecx, 1
  0003a	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  00040	83 bd 3c ff ff
	ff 0d		 cmp	 DWORD PTR tv64[ebp], 13	; 0000000dH
  00047	77 6f		 ja	 SHORT $LN2@MH_StatusT
  00049	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  0004f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN19@MH_StatusT[edx*4]
$LN4@MH_StatusT:

; 870  :         MH_ST2STR(MH_UNKNOWN)

  00056	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@OGPCCONM@MH_UNKNOWN@
  0005b	eb 60		 jmp	 SHORT $LN1@MH_StatusT
$LN5@MH_StatusT:

; 871  :         MH_ST2STR(MH_OK)

  0005d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05GOFNBHKB@MH_OK@
  00062	eb 59		 jmp	 SHORT $LN1@MH_StatusT
$LN6@MH_StatusT:

; 872  :         MH_ST2STR(MH_ERROR_ALREADY_INITIALIZED)

  00064	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BN@NKPDILDH@MH_ERROR_ALREADY_INITIALIZED@
  00069	eb 52		 jmp	 SHORT $LN1@MH_StatusT
$LN7@MH_StatusT:

; 873  :         MH_ST2STR(MH_ERROR_NOT_INITIALIZED)

  0006b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BJ@NEFDEEIO@MH_ERROR_NOT_INITIALIZED@
  00070	eb 4b		 jmp	 SHORT $LN1@MH_StatusT
$LN8@MH_StatusT:

; 874  :         MH_ST2STR(MH_ERROR_ALREADY_CREATED)

  00072	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BJ@EMFAAEGJ@MH_ERROR_ALREADY_CREATED@
  00077	eb 44		 jmp	 SHORT $LN1@MH_StatusT
$LN9@MH_StatusT:

; 875  :         MH_ST2STR(MH_ERROR_NOT_CREATED)

  00079	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BF@KAPHKAPP@MH_ERROR_NOT_CREATED@
  0007e	eb 3d		 jmp	 SHORT $LN1@MH_StatusT
$LN10@MH_StatusT:

; 876  :         MH_ST2STR(MH_ERROR_ENABLED)

  00080	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BB@HHFKFOJC@MH_ERROR_ENABLED@
  00085	eb 36		 jmp	 SHORT $LN1@MH_StatusT
$LN11@MH_StatusT:

; 877  :         MH_ST2STR(MH_ERROR_DISABLED)

  00087	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@CCPCFLPI@MH_ERROR_DISABLED@
  0008c	eb 2f		 jmp	 SHORT $LN1@MH_StatusT
$LN12@MH_StatusT:

; 878  :         MH_ST2STR(MH_ERROR_NOT_EXECUTABLE)

  0008e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BI@ONHKLIEE@MH_ERROR_NOT_EXECUTABLE@
  00093	eb 28		 jmp	 SHORT $LN1@MH_StatusT
$LN13@MH_StatusT:

; 879  :         MH_ST2STR(MH_ERROR_UNSUPPORTED_FUNCTION)

  00095	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BO@JGLOGLHI@MH_ERROR_UNSUPPORTED_FUNCTION@
  0009a	eb 21		 jmp	 SHORT $LN1@MH_StatusT
$LN14@MH_StatusT:

; 880  :         MH_ST2STR(MH_ERROR_MEMORY_ALLOC)

  0009c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BG@FHKMAOCO@MH_ERROR_MEMORY_ALLOC@
  000a1	eb 1a		 jmp	 SHORT $LN1@MH_StatusT
$LN15@MH_StatusT:

; 881  :         MH_ST2STR(MH_ERROR_MEMORY_PROTECT)

  000a3	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BI@HDILIFIJ@MH_ERROR_MEMORY_PROTECT@
  000a8	eb 13		 jmp	 SHORT $LN1@MH_StatusT
$LN16@MH_StatusT:

; 882  :         MH_ST2STR(MH_ERROR_MODULE_NOT_FOUND)

  000aa	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BK@FENDNJHO@MH_ERROR_MODULE_NOT_FOUND@
  000af	eb 0c		 jmp	 SHORT $LN1@MH_StatusT
$LN17@MH_StatusT:

; 883  :         MH_ST2STR(MH_ERROR_FUNCTION_NOT_FOUND)

  000b1	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BM@JPINPKML@MH_ERROR_FUNCTION_NOT_FOUND@
  000b6	eb 05		 jmp	 SHORT $LN1@MH_StatusT
$LN2@MH_StatusT:

; 884  :     }
; 885  : 
; 886  : #undef MH_ST2STR
; 887  : 
; 888  :     return "(unknown)";

  000b8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GPGAJHPD@?$CIunknown?$CJ@
$LN1@MH_StatusT:

; 889  : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000c6	3b ec		 cmp	 ebp, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 04 00	 ret	 4
  000d3	90		 npad	 1
$LN19@MH_StatusT:
  000d4	00 00 00 00	 DD	 $LN4@MH_StatusT
  000d8	00 00 00 00	 DD	 $LN5@MH_StatusT
  000dc	00 00 00 00	 DD	 $LN6@MH_StatusT
  000e0	00 00 00 00	 DD	 $LN7@MH_StatusT
  000e4	00 00 00 00	 DD	 $LN8@MH_StatusT
  000e8	00 00 00 00	 DD	 $LN9@MH_StatusT
  000ec	00 00 00 00	 DD	 $LN10@MH_StatusT
  000f0	00 00 00 00	 DD	 $LN11@MH_StatusT
  000f4	00 00 00 00	 DD	 $LN12@MH_StatusT
  000f8	00 00 00 00	 DD	 $LN13@MH_StatusT
  000fc	00 00 00 00	 DD	 $LN14@MH_StatusT
  00100	00 00 00 00	 DD	 $LN15@MH_StatusT
  00104	00 00 00 00	 DD	 $LN16@MH_StatusT
  00108	00 00 00 00	 DD	 $LN17@MH_StatusT
_MH_StatusToString@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_ApplyQueued@0
_TEXT	SEGMENT
_pHook$1 = -68						; size = 4
_threads$2 = -56					; size = 12
_first$ = -36						; size = 4
_i$ = -24						; size = 4
_status$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_MH_ApplyQueued@0 PROC					; COMDAT

; 787  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 788  :     MH_STATUS status = MH_OK;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 789  :     UINT i, first = INVALID_HOOK_POS;

  00039	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _first$[ebp], -1

; 790  : 
; 791  :     EnterSpinLock();

  00040	e8 00 00 00 00	 call	 _EnterSpinLock

; 792  : 
; 793  :     if (g_hHeap != NULL)

  00045	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  0004c	0f 84 f3 00 00
	00		 je	 $LN8@MH_ApplyQu

; 794  :     {
; 795  :         for (i = 0; i < g_hooks.size; ++i)

  00052	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00059	eb 09		 jmp	 SHORT $LN4@MH_ApplyQu
$LN2@MH_ApplyQu:
  0005b	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@MH_ApplyQu:
  00064	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00067	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+8
  0006d	73 3b		 jae	 SHORT $LN3@MH_ApplyQu

; 796  :         {
; 797  :             if (g_hooks.pItems[i].isEnabled != g_hooks.pItems[i].queueEnable)

  0006f	6b 45 e8 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks
  00079	8a 54 01 14	 mov	 dl, BYTE PTR [ecx+eax+20]
  0007d	d0 ea		 shr	 dl, 1
  0007f	80 e2 01	 and	 dl, 1
  00082	0f b6 c2	 movzx	 eax, dl
  00085	6b 4d e8 2c	 imul	 ecx, DWORD PTR _i$[ebp], 44
  00089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_hooks
  0008f	8a 4c 0a 14	 mov	 cl, BYTE PTR [edx+ecx+20]
  00093	c0 e9 02	 shr	 cl, 2
  00096	80 e1 01	 and	 cl, 1
  00099	0f b6 d1	 movzx	 edx, cl
  0009c	3b c2		 cmp	 eax, edx
  0009e	74 08		 je	 SHORT $LN10@MH_ApplyQu

; 798  :             {
; 799  :                 first = i;

  000a0	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	89 45 dc	 mov	 DWORD PTR _first$[ebp], eax

; 800  :                 break;

  000a6	eb 02		 jmp	 SHORT $LN3@MH_ApplyQu
$LN10@MH_ApplyQu:

; 801  :             }
; 802  :         }

  000a8	eb b1		 jmp	 SHORT $LN2@MH_ApplyQu
$LN3@MH_ApplyQu:

; 803  : 
; 804  :         if (first != INVALID_HOOK_POS)

  000aa	83 7d dc ff	 cmp	 DWORD PTR _first$[ebp], -1
  000ae	0f 84 8f 00 00
	00		 je	 $LN11@MH_ApplyQu

; 805  :         {
; 806  :             FROZEN_THREADS threads;
; 807  :             Freeze(&threads, ALL_HOOKS_POS, ACTION_APPLY_QUEUED);

  000b4	6a 02		 push	 2
  000b6	6a ff		 push	 -1
  000b8	8d 45 c8	 lea	 eax, DWORD PTR _threads$2[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _Freeze
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 808  : 
; 809  :             for (i = first; i < g_hooks.size; ++i)

  000c4	8b 45 dc	 mov	 eax, DWORD PTR _first$[ebp]
  000c7	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  000ca	eb 09		 jmp	 SHORT $LN7@MH_ApplyQu
$LN5@MH_ApplyQu:
  000cc	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@MH_ApplyQu:
  000d5	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  000d8	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR _g_hooks+8
  000de	73 57		 jae	 SHORT $LN6@MH_ApplyQu

; 810  :             {
; 811  :                 PHOOK_ENTRY pHook = &g_hooks.pItems[i];

  000e0	6b 45 e8 2c	 imul	 eax, DWORD PTR _i$[ebp], 44
  000e4	03 05 00 00 00
	00		 add	 eax, DWORD PTR _g_hooks
  000ea	89 45 bc	 mov	 DWORD PTR _pHook$1[ebp], eax

; 812  :                 if (pHook->isEnabled != pHook->queueEnable)

  000ed	8b 45 bc	 mov	 eax, DWORD PTR _pHook$1[ebp]
  000f0	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  000f3	d0 e9		 shr	 cl, 1
  000f5	80 e1 01	 and	 cl, 1
  000f8	0f b6 d1	 movzx	 edx, cl
  000fb	8b 45 bc	 mov	 eax, DWORD PTR _pHook$1[ebp]
  000fe	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00101	c0 e9 02	 shr	 cl, 2
  00104	80 e1 01	 and	 cl, 1
  00107	0f b6 c1	 movzx	 eax, cl
  0010a	3b d0		 cmp	 edx, eax
  0010c	74 27		 je	 SHORT $LN12@MH_ApplyQu

; 813  :                 {
; 814  :                     status = EnableHookLL(i, pHook->queueEnable);

  0010e	8b 45 bc	 mov	 eax, DWORD PTR _pHook$1[ebp]
  00111	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00114	c0 e9 02	 shr	 cl, 2
  00117	80 e1 01	 and	 cl, 1
  0011a	0f b6 d1	 movzx	 edx, cl
  0011d	52		 push	 edx
  0011e	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _EnableHookLL
  00127	83 c4 08	 add	 esp, 8
  0012a	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 815  :                     if (status != MH_OK)

  0012d	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  00131	74 02		 je	 SHORT $LN12@MH_ApplyQu

; 816  :                         break;

  00133	eb 02		 jmp	 SHORT $LN6@MH_ApplyQu
$LN12@MH_ApplyQu:

; 817  :                 }
; 818  :             }

  00135	eb 95		 jmp	 SHORT $LN5@MH_ApplyQu
$LN6@MH_ApplyQu:

; 819  : 
; 820  :             Unfreeze(&threads);

  00137	8d 45 c8	 lea	 eax, DWORD PTR _threads$2[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 _Unfreeze
  00140	83 c4 04	 add	 esp, 4
$LN11@MH_ApplyQu:

; 821  :         }
; 822  :     }

  00143	eb 07		 jmp	 SHORT $LN9@MH_ApplyQu
$LN8@MH_ApplyQu:

; 823  :     else
; 824  :     {
; 825  :         status = MH_ERROR_NOT_INITIALIZED;

  00145	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _status$[ebp], 2
$LN9@MH_ApplyQu:

; 826  :     }
; 827  : 
; 828  :     LeaveSpinLock();

  0014c	e8 00 00 00 00	 call	 _LeaveSpinLock

; 829  : 
; 830  :     return status;

  00151	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]

; 831  : }

  00154	52		 push	 edx
  00155	8b cd		 mov	 ecx, ebp
  00157	50		 push	 eax
  00158	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@MH_ApplyQu
  0015e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00163	58		 pop	 eax
  00164	5a		 pop	 edx
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00178	3b ec		 cmp	 ebp, esp
  0017a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
  00183	90		 npad	 1
$LN17@MH_ApplyQu:
  00184	01 00 00 00	 DD	 1
  00188	00 00 00 00	 DD	 $LN16@MH_ApplyQu
$LN16@MH_ApplyQu:
  0018c	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00190	0c 00 00 00	 DD	 12			; 0000000cH
  00194	00 00 00 00	 DD	 $LN15@MH_ApplyQu
$LN15@MH_ApplyQu:
  00198	74		 DB	 116			; 00000074H
  00199	68		 DB	 104			; 00000068H
  0019a	72		 DB	 114			; 00000072H
  0019b	65		 DB	 101			; 00000065H
  0019c	61		 DB	 97			; 00000061H
  0019d	64		 DB	 100			; 00000064H
  0019e	73		 DB	 115			; 00000073H
  0019f	00		 DB	 0
_MH_ApplyQueued@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_QueueDisableHook@4
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_MH_QueueDisableHook@4 PROC				; COMDAT

; 781  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 782  :     return QueueHook(pTarget, FALSE);

  00028	6a 00		 push	 0
  0002a	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _QueueHook
  00033	83 c4 08	 add	 esp, 8

; 783  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
_MH_QueueDisableHook@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_QueueEnableHook@4
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_MH_QueueEnableHook@4 PROC				; COMDAT

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 776  :     return QueueHook(pTarget, TRUE);

  00028	6a 01		 push	 1
  0002a	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _QueueHook
  00033	83 c4 08	 add	 esp, 8

; 777  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
_MH_QueueEnableHook@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_DisableHook@4
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_MH_DisableHook@4 PROC					; COMDAT

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 732  :     return EnableHook(pTarget, FALSE);

  00028	6a 00		 push	 0
  0002a	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _EnableHook
  00033	83 c4 08	 add	 esp, 8

; 733  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
_MH_DisableHook@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_EnableHook@4
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_MH_EnableHook@4 PROC					; COMDAT

; 725  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 726  :     return EnableHook(pTarget, TRUE);

  00028	6a 01		 push	 1
  0002a	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _EnableHook
  00033	83 c4 08	 add	 esp, 8

; 727  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
_MH_EnableHook@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_RemoveHook@4
_TEXT	SEGMENT
_threads$1 = -44					; size = 12
_pos$2 = -24						; size = 4
_status$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTarget$ = 8						; size = 4
_MH_RemoveHook@4 PROC					; COMDAT

; 634  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 635  :     MH_STATUS status = MH_OK;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 636  : 
; 637  :     EnterSpinLock();

  00039	e8 00 00 00 00	 call	 _EnterSpinLock

; 638  : 
; 639  :     if (g_hHeap != NULL)

  0003e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  00045	0f 84 92 00 00
	00		 je	 $LN2@MH_RemoveH

; 640  :     {
; 641  :         UINT pos = FindHookEntry(pTarget);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _FindHookEntry
  00054	83 c4 04	 add	 esp, 4
  00057	89 45 e8	 mov	 DWORD PTR _pos$2[ebp], eax

; 642  :         if (pos != INVALID_HOOK_POS)

  0005a	83 7d e8 ff	 cmp	 DWORD PTR _pos$2[ebp], -1
  0005e	74 74		 je	 SHORT $LN4@MH_RemoveH

; 643  :         {
; 644  :             if (g_hooks.pItems[pos].isEnabled)

  00060	6b 45 e8 2c	 imul	 eax, DWORD PTR _pos$2[ebp], 44
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks
  0006a	8a 54 01 14	 mov	 dl, BYTE PTR [ecx+eax+20]
  0006e	d0 ea		 shr	 dl, 1
  00070	80 e2 01	 and	 dl, 1
  00073	0f b6 c2	 movzx	 eax, dl
  00076	85 c0		 test	 eax, eax
  00078	74 2f		 je	 SHORT $LN6@MH_RemoveH

; 645  :             {
; 646  :                 FROZEN_THREADS threads;
; 647  :                 Freeze(&threads, pos, ACTION_DISABLE);

  0007a	6a 00		 push	 0
  0007c	8b 45 e8	 mov	 eax, DWORD PTR _pos$2[ebp]
  0007f	50		 push	 eax
  00080	8d 4d d4	 lea	 ecx, DWORD PTR _threads$1[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _Freeze
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 648  : 
; 649  :                 status = EnableHookLL(pos, FALSE);

  0008c	6a 00		 push	 0
  0008e	8b 45 e8	 mov	 eax, DWORD PTR _pos$2[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _EnableHookLL
  00097	83 c4 08	 add	 esp, 8
  0009a	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 650  : 
; 651  :                 Unfreeze(&threads);

  0009d	8d 45 d4	 lea	 eax, DWORD PTR _threads$1[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _Unfreeze
  000a6	83 c4 04	 add	 esp, 4
$LN6@MH_RemoveH:

; 652  :             }
; 653  : 
; 654  :             if (status == MH_OK)

  000a9	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  000ad	75 23		 jne	 SHORT $LN7@MH_RemoveH

; 655  :             {
; 656  :                 FreeBuffer(g_hooks.pItems[pos].pTrampoline);

  000af	6b 45 e8 2c	 imul	 eax, DWORD PTR _pos$2[ebp], 44
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hooks
  000b9	8b 54 01 08	 mov	 edx, DWORD PTR [ecx+eax+8]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _FreeBuffer
  000c3	83 c4 04	 add	 esp, 4

; 657  :                 DeleteHookEntry(pos);

  000c6	8b 45 e8	 mov	 eax, DWORD PTR _pos$2[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _DeleteHookEntry
  000cf	83 c4 04	 add	 esp, 4
$LN7@MH_RemoveH:

; 658  :             }
; 659  :         }

  000d2	eb 07		 jmp	 SHORT $LN5@MH_RemoveH
$LN4@MH_RemoveH:

; 660  :         else
; 661  :         {
; 662  :             status = MH_ERROR_NOT_CREATED;

  000d4	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _status$[ebp], 4
$LN5@MH_RemoveH:

; 663  :         }
; 664  :     }

  000db	eb 07		 jmp	 SHORT $LN3@MH_RemoveH
$LN2@MH_RemoveH:

; 665  :     else
; 666  :     {
; 667  :         status = MH_ERROR_NOT_INITIALIZED;

  000dd	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _status$[ebp], 2
$LN3@MH_RemoveH:

; 668  :     }
; 669  : 
; 670  :     LeaveSpinLock();

  000e4	e8 00 00 00 00	 call	 _LeaveSpinLock

; 671  : 
; 672  :     return status;

  000e9	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]

; 673  : }

  000ec	52		 push	 edx
  000ed	8b cd		 mov	 ecx, ebp
  000ef	50		 push	 eax
  000f0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@MH_RemoveH
  000f6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fb	58		 pop	 eax
  000fc	5a		 pop	 edx
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00103	33 cd		 xor	 ecx, ebp
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00110	3b ec		 cmp	 ebp, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 04 00	 ret	 4
  0011d	0f 1f 00	 npad	 3
$LN11@MH_RemoveH:
  00120	01 00 00 00	 DD	 1
  00124	00 00 00 00	 DD	 $LN10@MH_RemoveH
$LN10@MH_RemoveH:
  00128	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0012c	0c 00 00 00	 DD	 12			; 0000000cH
  00130	00 00 00 00	 DD	 $LN9@MH_RemoveH
$LN9@MH_RemoveH:
  00134	74		 DB	 116			; 00000074H
  00135	68		 DB	 104			; 00000068H
  00136	72		 DB	 114			; 00000072H
  00137	65		 DB	 101			; 00000065H
  00138	61		 DB	 97			; 00000061H
  00139	64		 DB	 100			; 00000064H
  0013a	73		 DB	 115			; 00000073H
  0013b	00		 DB	 0
_MH_RemoveHook@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_CreateHookApiEx@20
_TEXT	SEGMENT
_pTarget$ = -20						; size = 4
_hModule$ = -8						; size = 4
_pszModule$ = 8						; size = 4
_pszProcName$ = 12					; size = 4
_pDetour$ = 16						; size = 4
_ppOriginal$ = 20					; size = 4
_ppTarget$ = 24						; size = 4
_MH_CreateHookApiEx@20 PROC				; COMDAT

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 838  :     HMODULE hModule;
; 839  :     LPVOID  pTarget;
; 840  : 
; 841  :     hModule = GetModuleHandleW(pszModule);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 08	 mov	 eax, DWORD PTR _pszModule$[ebp]
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4
  00034	3b f4		 cmp	 esi, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	89 45 f8	 mov	 DWORD PTR _hModule$[ebp], eax

; 842  :     if (hModule == NULL)

  0003e	83 7d f8 00	 cmp	 DWORD PTR _hModule$[ebp], 0
  00042	75 07		 jne	 SHORT $LN2@MH_CreateH

; 843  :         return MH_ERROR_MODULE_NOT_FOUND;

  00044	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00049	eb 46		 jmp	 SHORT $LN1@MH_CreateH
$LN2@MH_CreateH:

; 844  : 
; 845  :     pTarget = (LPVOID)GetProcAddress(hModule, pszProcName);

  0004b	8b f4		 mov	 esi, esp
  0004d	8b 45 0c	 mov	 eax, DWORD PTR _pszProcName$[ebp]
  00050	50		 push	 eax
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _hModule$[ebp]
  00054	51		 push	 ecx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	89 45 ec	 mov	 DWORD PTR _pTarget$[ebp], eax

; 846  :     if (pTarget == NULL)

  00065	83 7d ec 00	 cmp	 DWORD PTR _pTarget$[ebp], 0
  00069	75 07		 jne	 SHORT $LN3@MH_CreateH

; 847  :         return MH_ERROR_FUNCTION_NOT_FOUND;

  0006b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00070	eb 1f		 jmp	 SHORT $LN1@MH_CreateH
$LN3@MH_CreateH:

; 848  : 
; 849  :     if(ppTarget != NULL)

  00072	83 7d 18 00	 cmp	 DWORD PTR _ppTarget$[ebp], 0
  00076	74 08		 je	 SHORT $LN4@MH_CreateH

; 850  :         *ppTarget = pTarget;

  00078	8b 45 18	 mov	 eax, DWORD PTR _ppTarget$[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@MH_CreateH:

; 851  : 
; 852  :     return MH_CreateHook(pTarget, pDetour, ppOriginal);

  00080	8b 45 14	 mov	 eax, DWORD PTR _ppOriginal$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 10	 mov	 ecx, DWORD PTR _pDetour$[ebp]
  00087	51		 push	 ecx
  00088	8b 55 ec	 mov	 edx, DWORD PTR _pTarget$[ebp]
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 _MH_CreateHook@12
$LN1@MH_CreateH:

; 853  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 14 00	 ret	 20			; 00000014H
_MH_CreateHookApiEx@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_CreateHookApi@16
_TEXT	SEGMENT
_pszModule$ = 8						; size = 4
_pszProcName$ = 12					; size = 4
_pDetour$ = 16						; size = 4
_ppOriginal$ = 20					; size = 4
_MH_CreateHookApi@16 PROC				; COMDAT

; 858  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 859  :    return MH_CreateHookApiEx(pszModule, pszProcName, pDetour, ppOriginal, NULL);

  00028	6a 00		 push	 0
  0002a	8b 45 14	 mov	 eax, DWORD PTR _ppOriginal$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _pDetour$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _pszProcName$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _pszModule$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _MH_CreateHookApiEx@20

; 860  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 10 00	 ret	 16			; 00000010H
_MH_CreateHookApi@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_CreateHook@12
_TEXT	SEGMENT
_pHook$1 = -92						; size = 4
_ct$2 = -80						; size = 36
_pBuffer$3 = -36					; size = 4
_pos$4 = -24						; size = 4
_status$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTarget$ = 8						; size = 4
_pDetour$ = 12						; size = 4
_ppOriginal$ = 16					; size = 4
_MH_CreateHook@12 PROC					; COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 537  :     MH_STATUS status = MH_OK;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 538  : 
; 539  :     EnterSpinLock();

  00039	e8 00 00 00 00	 call	 _EnterSpinLock

; 540  : 
; 541  :     if (g_hHeap != NULL)

  0003e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  00045	0f 84 a8 01 00
	00		 je	 $LN2@MH_CreateH

; 542  :     {
; 543  :         if (IsExecutableAddress(pTarget) && IsExecutableAddress(pDetour))

  0004b	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _IsExecutableAddress
  00054	83 c4 04	 add	 esp, 4
  00057	85 c0		 test	 eax, eax
  00059	0f 84 8b 01 00
	00		 je	 $LN4@MH_CreateH
  0005f	8b 45 0c	 mov	 eax, DWORD PTR _pDetour$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _IsExecutableAddress
  00068	83 c4 04	 add	 esp, 4
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 77 01 00
	00		 je	 $LN4@MH_CreateH

; 544  :         {
; 545  :             UINT pos = FindHookEntry(pTarget);

  00073	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _FindHookEntry
  0007c	83 c4 04	 add	 esp, 4
  0007f	89 45 e8	 mov	 DWORD PTR _pos$4[ebp], eax

; 546  :             if (pos == INVALID_HOOK_POS)

  00082	83 7d e8 ff	 cmp	 DWORD PTR _pos$4[ebp], -1
  00086	0f 85 55 01 00
	00		 jne	 $LN6@MH_CreateH

; 547  :             {
; 548  :                 LPVOID pBuffer = AllocateBuffer(pTarget);

  0008c	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _AllocateBuffer
  00095	83 c4 04	 add	 esp, 4
  00098	89 45 dc	 mov	 DWORD PTR _pBuffer$3[ebp], eax

; 549  :                 if (pBuffer != NULL)

  0009b	83 7d dc 00	 cmp	 DWORD PTR _pBuffer$3[ebp], 0
  0009f	0f 84 33 01 00
	00		 je	 $LN8@MH_CreateH

; 550  :                 {
; 551  :                     TRAMPOLINE ct;
; 552  : 
; 553  :                     ct.pTarget     = pTarget;

  000a5	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  000a8	89 45 b0	 mov	 DWORD PTR _ct$2[ebp], eax

; 554  :                     ct.pDetour     = pDetour;

  000ab	8b 45 0c	 mov	 eax, DWORD PTR _pDetour$[ebp]
  000ae	89 45 b4	 mov	 DWORD PTR _ct$2[ebp+4], eax

; 555  :                     ct.pTrampoline = pBuffer;

  000b1	8b 45 dc	 mov	 eax, DWORD PTR _pBuffer$3[ebp]
  000b4	89 45 b8	 mov	 DWORD PTR _ct$2[ebp+8], eax

; 556  :                     if (CreateTrampolineFunction(&ct))

  000b7	8d 45 b0	 lea	 eax, DWORD PTR _ct$2[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _CreateTrampolineFunction
  000c0	83 c4 04	 add	 esp, 4
  000c3	85 c0		 test	 eax, eax
  000c5	0f 84 f2 00 00
	00		 je	 $LN10@MH_CreateH

; 557  :                     {
; 558  :                         PHOOK_ENTRY pHook = AddHookEntry();

  000cb	e8 00 00 00 00	 call	 _AddHookEntry
  000d0	89 45 a4	 mov	 DWORD PTR _pHook$1[ebp], eax

; 559  :                         if (pHook != NULL)

  000d3	83 7d a4 00	 cmp	 DWORD PTR _pHook$1[ebp], 0
  000d7	0f 84 d7 00 00
	00		 je	 $LN12@MH_CreateH

; 560  :                         {
; 561  :                             pHook->pTarget     = ct.pTarget;

  000dd	8b 45 a4	 mov	 eax, DWORD PTR _pHook$1[ebp]
  000e0	8b 4d b0	 mov	 ecx, DWORD PTR _ct$2[ebp]
  000e3	89 08		 mov	 DWORD PTR [eax], ecx

; 562  : #if defined(_M_X64) || defined(__x86_64__)
; 563  :                             pHook->pDetour     = ct.pRelay;
; 564  : #else
; 565  :                             pHook->pDetour     = ct.pDetour;

  000e5	8b 45 a4	 mov	 eax, DWORD PTR _pHook$1[ebp]
  000e8	8b 4d b4	 mov	 ecx, DWORD PTR _ct$2[ebp+4]
  000eb	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 566  : #endif
; 567  :                             pHook->pTrampoline = ct.pTrampoline;

  000ee	8b 45 a4	 mov	 eax, DWORD PTR _pHook$1[ebp]
  000f1	8b 4d b8	 mov	 ecx, DWORD PTR _ct$2[ebp+8]
  000f4	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 568  :                             pHook->patchAbove  = ct.patchAbove;

  000f7	8a 45 bc	 mov	 al, BYTE PTR _ct$2[ebp+12]
  000fa	24 01		 and	 al, 1
  000fc	8b 4d a4	 mov	 ecx, DWORD PTR _pHook$1[ebp]
  000ff	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00102	80 e2 fe	 and	 dl, 254			; 000000feH
  00105	0a d0		 or	 dl, al
  00107	8b 45 a4	 mov	 eax, DWORD PTR _pHook$1[ebp]
  0010a	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 569  :                             pHook->isEnabled   = FALSE;

  0010d	8b 45 a4	 mov	 eax, DWORD PTR _pHook$1[ebp]
  00110	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00113	80 e1 fd	 and	 cl, 253			; 000000fdH
  00116	8b 55 a4	 mov	 edx, DWORD PTR _pHook$1[ebp]
  00119	88 4a 14	 mov	 BYTE PTR [edx+20], cl

; 570  :                             pHook->queueEnable = FALSE;

  0011c	8b 45 a4	 mov	 eax, DWORD PTR _pHook$1[ebp]
  0011f	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00122	80 e1 fb	 and	 cl, 251			; 000000fbH
  00125	8b 55 a4	 mov	 edx, DWORD PTR _pHook$1[ebp]
  00128	88 4a 14	 mov	 BYTE PTR [edx+20], cl

; 571  :                             pHook->nIP         = ct.nIP;

  0012b	8b 45 c0	 mov	 eax, DWORD PTR _ct$2[ebp+16]
  0012e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00131	8b 4d a4	 mov	 ecx, DWORD PTR _pHook$1[ebp]
  00134	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00137	83 e2 f0	 and	 edx, -16		; fffffff0H
  0013a	0b d0		 or	 edx, eax
  0013c	8b 45 a4	 mov	 eax, DWORD PTR _pHook$1[ebp]
  0013f	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 572  :                             memcpy(pHook->oldIPs, ct.oldIPs, ARRAYSIZE(ct.oldIPs));

  00142	6a 08		 push	 8
  00144	8d 45 c4	 lea	 eax, DWORD PTR _ct$2[ebp+20]
  00147	50		 push	 eax
  00148	8b 4d a4	 mov	 ecx, DWORD PTR _pHook$1[ebp]
  0014b	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0014e	51		 push	 ecx
  0014f	e8 00 00 00 00	 call	 _memcpy
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH

; 573  :                             memcpy(pHook->newIPs, ct.newIPs, ARRAYSIZE(ct.newIPs));

  00157	6a 08		 push	 8
  00159	8d 45 cc	 lea	 eax, DWORD PTR _ct$2[ebp+28]
  0015c	50		 push	 eax
  0015d	8b 4d a4	 mov	 ecx, DWORD PTR _pHook$1[ebp]
  00160	83 c1 24	 add	 ecx, 36			; 00000024H
  00163	51		 push	 ecx
  00164	e8 00 00 00 00	 call	 _memcpy
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH

; 574  : 
; 575  :                             // Back up the target function.
; 576  : 
; 577  :                             if (ct.patchAbove)

  0016c	83 7d bc 00	 cmp	 DWORD PTR _ct$2[ebp+12], 0
  00170	74 1a		 je	 SHORT $LN14@MH_CreateH

; 578  :                             {
; 579  :                                 memcpy(

  00172	6a 07		 push	 7
  00174	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00177	83 e8 05	 sub	 eax, 5
  0017a	50		 push	 eax
  0017b	8b 4d a4	 mov	 ecx, DWORD PTR _pHook$1[ebp]
  0017e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00181	51		 push	 ecx
  00182	e8 00 00 00 00	 call	 _memcpy
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH

; 580  :                                     pHook->backup,
; 581  :                                     (LPBYTE)pTarget - sizeof(JMP_REL),
; 582  :                                     sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
; 583  :                             }

  0018a	eb 15		 jmp	 SHORT $LN15@MH_CreateH
$LN14@MH_CreateH:

; 584  :                             else
; 585  :                             {
; 586  :                                 memcpy(pHook->backup, pTarget, sizeof(JMP_REL));

  0018c	6a 05		 push	 5
  0018e	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00191	50		 push	 eax
  00192	8b 4d a4	 mov	 ecx, DWORD PTR _pHook$1[ebp]
  00195	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00198	51		 push	 ecx
  00199	e8 00 00 00 00	 call	 _memcpy
  0019e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@MH_CreateH:

; 587  :                             }
; 588  : 
; 589  :                             if (ppOriginal != NULL)

  001a1	83 7d 10 00	 cmp	 DWORD PTR _ppOriginal$[ebp], 0
  001a5	74 0b		 je	 SHORT $LN16@MH_CreateH

; 590  :                                 *ppOriginal = pHook->pTrampoline;

  001a7	8b 45 10	 mov	 eax, DWORD PTR _ppOriginal$[ebp]
  001aa	8b 4d a4	 mov	 ecx, DWORD PTR _pHook$1[ebp]
  001ad	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001b0	89 10		 mov	 DWORD PTR [eax], edx
$LN16@MH_CreateH:

; 591  :                         }

  001b2	eb 07		 jmp	 SHORT $LN13@MH_CreateH
$LN12@MH_CreateH:

; 592  :                         else
; 593  :                         {
; 594  :                             status = MH_ERROR_MEMORY_ALLOC;

  001b4	c7 45 f4 09 00
	00 00		 mov	 DWORD PTR _status$[ebp], 9
$LN13@MH_CreateH:

; 595  :                         }
; 596  :                     }

  001bb	eb 07		 jmp	 SHORT $LN11@MH_CreateH
$LN10@MH_CreateH:

; 597  :                     else
; 598  :                     {
; 599  :                         status = MH_ERROR_UNSUPPORTED_FUNCTION;

  001bd	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _status$[ebp], 8
$LN11@MH_CreateH:

; 600  :                     }
; 601  : 
; 602  :                     if (status != MH_OK)

  001c4	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  001c8	74 0c		 je	 SHORT $LN17@MH_CreateH

; 603  :                     {
; 604  :                         FreeBuffer(pBuffer);

  001ca	8b 45 dc	 mov	 eax, DWORD PTR _pBuffer$3[ebp]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 _FreeBuffer
  001d3	83 c4 04	 add	 esp, 4
$LN17@MH_CreateH:

; 605  :                     }
; 606  :                 }

  001d6	eb 07		 jmp	 SHORT $LN9@MH_CreateH
$LN8@MH_CreateH:

; 607  :                 else
; 608  :                 {
; 609  :                     status = MH_ERROR_MEMORY_ALLOC;

  001d8	c7 45 f4 09 00
	00 00		 mov	 DWORD PTR _status$[ebp], 9
$LN9@MH_CreateH:

; 610  :                 }
; 611  :             }

  001df	eb 07		 jmp	 SHORT $LN7@MH_CreateH
$LN6@MH_CreateH:

; 612  :             else
; 613  :             {
; 614  :                 status = MH_ERROR_ALREADY_CREATED;

  001e1	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _status$[ebp], 3
$LN7@MH_CreateH:

; 615  :             }
; 616  :         }

  001e8	eb 07		 jmp	 SHORT $LN5@MH_CreateH
$LN4@MH_CreateH:

; 617  :         else
; 618  :         {
; 619  :             status = MH_ERROR_NOT_EXECUTABLE;

  001ea	c7 45 f4 07 00
	00 00		 mov	 DWORD PTR _status$[ebp], 7
$LN5@MH_CreateH:

; 620  :         }
; 621  :     }

  001f1	eb 07		 jmp	 SHORT $LN3@MH_CreateH
$LN2@MH_CreateH:

; 622  :     else
; 623  :     {
; 624  :         status = MH_ERROR_NOT_INITIALIZED;

  001f3	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _status$[ebp], 2
$LN3@MH_CreateH:

; 625  :     }
; 626  : 
; 627  :     LeaveSpinLock();

  001fa	e8 00 00 00 00	 call	 _LeaveSpinLock

; 628  : 
; 629  :     return status;

  001ff	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]

; 630  : }

  00202	52		 push	 edx
  00203	8b cd		 mov	 ecx, ebp
  00205	50		 push	 eax
  00206	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@MH_CreateH
  0020c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00211	58		 pop	 eax
  00212	5a		 pop	 edx
  00213	5f		 pop	 edi
  00214	5e		 pop	 esi
  00215	5b		 pop	 ebx
  00216	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00219	33 cd		 xor	 ecx, ebp
  0021b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00220	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  00226	3b ec		 cmp	 ebp, esp
  00228	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022d	8b e5		 mov	 esp, ebp
  0022f	5d		 pop	 ebp
  00230	c2 0c 00	 ret	 12			; 0000000cH
  00233	90		 npad	 1
$LN21@MH_CreateH:
  00234	01 00 00 00	 DD	 1
  00238	00 00 00 00	 DD	 $LN20@MH_CreateH
$LN20@MH_CreateH:
  0023c	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00240	24 00 00 00	 DD	 36			; 00000024H
  00244	00 00 00 00	 DD	 $LN19@MH_CreateH
$LN19@MH_CreateH:
  00248	63		 DB	 99			; 00000063H
  00249	74		 DB	 116			; 00000074H
  0024a	00		 DB	 0
_MH_CreateHook@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_Uninitialize@0
_TEXT	SEGMENT
_status$ = -8						; size = 4
_MH_Uninitialize@0 PROC					; COMDAT

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 498  :     MH_STATUS status = MH_OK;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 499  : 
; 500  :     EnterSpinLock();

  0002f	e8 00 00 00 00	 call	 _EnterSpinLock

; 501  : 
; 502  :     if (g_hHeap != NULL)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  0003b	74 75		 je	 SHORT $LN2@MH_Uniniti

; 503  :     {
; 504  :         status = EnableAllHooksLL(FALSE);

  0003d	6a 00		 push	 0
  0003f	e8 00 00 00 00	 call	 _EnableAllHooksLL
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 505  :         if (status == MH_OK)

  0004a	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  0004e	75 60		 jne	 SHORT $LN4@MH_Uniniti

; 506  :         {
; 507  :             // Free the internal function buffer.
; 508  : 
; 509  :             // HeapFree is actually not required, but some tools detect a false
; 510  :             // memory leak without HeapFree.
; 511  : 
; 512  :             UninitializeBuffer();

  00050	e8 00 00 00 00	 call	 _UninitializeBuffer

; 513  : 
; 514  :             HeapFree(g_hHeap, 0, g_hooks.pItems);

  00055	8b f4		 mov	 esi, esp
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hooks
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_hHeap
  00065	51		 push	 ecx
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 515  :             HeapDestroy(g_hHeap);

  00073	8b f4		 mov	 esi, esp
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _g_hHeap
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapDestroy@4
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 516  : 
; 517  :             g_hHeap = NULL;

  00088	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hHeap, 0

; 518  : 
; 519  :             g_hooks.pItems   = NULL;

  00092	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hooks, 0

; 520  :             g_hooks.capacity = 0;

  0009c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hooks+4, 0

; 521  :             g_hooks.size     = 0;

  000a6	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_hooks+8, 0
$LN4@MH_Uniniti:

; 522  :         }
; 523  :     }

  000b0	eb 07		 jmp	 SHORT $LN3@MH_Uniniti
$LN2@MH_Uniniti:

; 524  :     else
; 525  :     {
; 526  :         status = MH_ERROR_NOT_INITIALIZED;

  000b2	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _status$[ebp], 2
$LN3@MH_Uniniti:

; 527  :     }
; 528  : 
; 529  :     LeaveSpinLock();

  000b9	e8 00 00 00 00	 call	 _LeaveSpinLock

; 530  : 
; 531  :     return status;

  000be	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]

; 532  : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000ca	3b ec		 cmp	 ebp, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
_MH_Uninitialize@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\kiero\minhook\src\hook.c
;	COMDAT _MH_Initialize@0
_TEXT	SEGMENT
_status$ = -8						; size = 4
_MH_Initialize@0 PROC					; COMDAT

; 467  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __29301DEE_hook@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 468  :     MH_STATUS status = MH_OK;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _status$[ebp], 0

; 469  : 
; 470  :     EnterSpinLock();

  0002f	e8 00 00 00 00	 call	 _EnterSpinLock

; 471  : 
; 472  :     if (g_hHeap == NULL)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  0003b	75 33		 jne	 SHORT $LN2@MH_Initial

; 473  :     {
; 474  :         g_hHeap = HeapCreate(0, 0, 0);

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	6a 00		 push	 0
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapCreate@12
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	a3 00 00 00 00	 mov	 DWORD PTR _g_hHeap, eax

; 475  :         if (g_hHeap != NULL)

  00057	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_hHeap, 0
  0005e	74 07		 je	 SHORT $LN4@MH_Initial

; 476  :         {
; 477  :             // Initialize the internal function buffer.
; 478  :             InitializeBuffer();

  00060	e8 00 00 00 00	 call	 _InitializeBuffer

; 479  :         }

  00065	eb 07		 jmp	 SHORT $LN5@MH_Initial
$LN4@MH_Initial:

; 480  :         else
; 481  :         {
; 482  :             status = MH_ERROR_MEMORY_ALLOC;

  00067	c7 45 f8 09 00
	00 00		 mov	 DWORD PTR _status$[ebp], 9
$LN5@MH_Initial:

; 483  :         }
; 484  :     }

  0006e	eb 07		 jmp	 SHORT $LN3@MH_Initial
$LN2@MH_Initial:

; 485  :     else
; 486  :     {
; 487  :         status = MH_ERROR_ALREADY_INITIALIZED;

  00070	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _status$[ebp], 1
$LN3@MH_Initial:

; 488  :     }
; 489  : 
; 490  :     LeaveSpinLock();

  00077	e8 00 00 00 00	 call	 _LeaveSpinLock

; 491  : 
; 492  :     return status;

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]

; 493  : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_MH_Initialize@0 ENDP
_TEXT	ENDS
END
