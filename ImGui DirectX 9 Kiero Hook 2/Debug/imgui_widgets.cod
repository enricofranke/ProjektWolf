; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu@				; `string'
PUBLIC	??_C@_05LLAMLEHD@?$CFI64d@			; `string'
PUBLIC	??_C@_05OINFJHGD@?$CFI64u@			; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf@			; `string'
PUBLIC	??_C@_03CEFFAPNG@?$CD?$CDX@			; `string'
PUBLIC	??_C@_03DNEODOJH@?$CD?$CDY@			; `string'
PUBLIC	??_C@_03BGGDGNFE@?$CD?$CDZ@			; `string'
PUBLIC	??_C@_03KDMNBDBJ@?$CD?$CDW@			; `string'
PUBLIC	??_C@_03GOOLIKIF@?$CF3d@			; `string'
PUBLIC	??_C@_05FELKPNOB@R?3?$CF3d@			; `string'
PUBLIC	??_C@_05HKBGOMJ@G?3?$CF3d@			; `string'
PUBLIC	??_C@_05FHGMPPHK@B?3?$CF3d@			; `string'
PUBLIC	??_C@_05NBPIINNE@A?3?$CF3d@			; `string'
PUBLIC	??_C@_05PGPHNMBM@H?3?$CF3d@			; `string'
PUBLIC	??_C@_05JPOGCOEE@S?3?$CF3d@			; `string'
PUBLIC	??_C@_05MPCLLPPH@V?3?$CF3d@			; `string'
PUBLIC	??_C@_05ONBKDNLK@?$CF0?43f@			; `string'
PUBLIC	??_C@_07CCOKENNH@R?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07BGLBHCJI@G?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07FOFBHMPM@B?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07NANOHLBP@A?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07MPJBGADE@H?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07OOEAENEJ@S?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07KGKAEDCN@V?3?$CF0?43f@			; `string'
msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__241EEA0C_corecrt_memory@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__42049807_imgui@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__F5601360_stdlib@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__71512A68_imgui_internal@h DB 01H
__40DF0D2D_ctype@h DB 01H
__E7AA0281_imstb_textedit@h DB 01H
__32F429E7_imgui_widgets@cpp DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_07KGKAEDCN@V?3?$CF0?43f@
CONST	SEGMENT
??_C@_07KGKAEDCN@V?3?$CF0?43f@ DB 'V:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOEAENEJ@S?3?$CF0?43f@
CONST	SEGMENT
??_C@_07OOEAENEJ@S?3?$CF0?43f@ DB 'S:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPJBGADE@H?3?$CF0?43f@
CONST	SEGMENT
??_C@_07MPJBGADE@H?3?$CF0?43f@ DB 'H:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NANOHLBP@A?3?$CF0?43f@
CONST	SEGMENT
??_C@_07NANOHLBP@A?3?$CF0?43f@ DB 'A:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOFBHMPM@B?3?$CF0?43f@
CONST	SEGMENT
??_C@_07FOFBHMPM@B?3?$CF0?43f@ DB 'B:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGLBHCJI@G?3?$CF0?43f@
CONST	SEGMENT
??_C@_07BGLBHCJI@G?3?$CF0?43f@ DB 'G:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCOKENNH@R?3?$CF0?43f@
CONST	SEGMENT
??_C@_07CCOKENNH@R?3?$CF0?43f@ DB 'R:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONBKDNLK@?$CF0?43f@
CONST	SEGMENT
??_C@_05ONBKDNLK@?$CF0?43f@ DB '%0.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPCLLPPH@V?3?$CF3d@
CONST	SEGMENT
??_C@_05MPCLLPPH@V?3?$CF3d@ DB 'V:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPOGCOEE@S?3?$CF3d@
CONST	SEGMENT
??_C@_05JPOGCOEE@S?3?$CF3d@ DB 'S:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGPHNMBM@H?3?$CF3d@
CONST	SEGMENT
??_C@_05PGPHNMBM@H?3?$CF3d@ DB 'H:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NBPIINNE@A?3?$CF3d@
CONST	SEGMENT
??_C@_05NBPIINNE@A?3?$CF3d@ DB 'A:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHGMPPHK@B?3?$CF3d@
CONST	SEGMENT
??_C@_05FHGMPPHK@B?3?$CF3d@ DB 'B:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKBGOMJ@G?3?$CF3d@
CONST	SEGMENT
??_C@_05HKBGOMJ@G?3?$CF3d@ DB 'G:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FELKPNOB@R?3?$CF3d@
CONST	SEGMENT
??_C@_05FELKPNOB@R?3?$CF3d@ DB 'R:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GOOLIKIF@?$CF3d@
CONST	SEGMENT
??_C@_03GOOLIKIF@?$CF3d@ DB '%3d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDMNBDBJ@?$CD?$CDW@
CONST	SEGMENT
??_C@_03KDMNBDBJ@?$CD?$CDW@ DB '##W', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BGGDGNFE@?$CD?$CDZ@
CONST	SEGMENT
??_C@_03BGGDGNFE@?$CD?$CDZ@ DB '##Z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNEODOJH@?$CD?$CDY@
CONST	SEGMENT
??_C@_03DNEODOJH@?$CD?$CDY@ DB '##Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CEFFAPNG@?$CD?$CDX@
CONST	SEGMENT
??_C@_03CEFFAPNG@?$CD?$CDX@ DB '##X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf@ DB '%lf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OINFJHGD@?$CFI64u@
CONST	SEGMENT
??_C@_05OINFJHGD@?$CFI64u@ DB '%I64u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d@
CONST	SEGMENT
??_C@_05LLAMLEHD@?$CFI64d@ DB '%I64d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu@ DB '%u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B DD 01H		; GDataTypeInfo
	DD	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DD	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DD	01H
	DD	FLAT:??_C@_02GMHACPFF@?$CFu@
	DD	FLAT:??_C@_02GMHACPFF@?$CFu@
	DD	02H
	DD	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DD	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DD	02H
	DD	FLAT:??_C@_02GMHACPFF@?$CFu@
	DD	FLAT:??_C@_02GMHACPFF@?$CFu@
	DD	04H
	DD	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DD	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DD	04H
	DD	FLAT:??_C@_02GMHACPFF@?$CFu@
	DD	FLAT:??_C@_02GMHACPFF@?$CFu@
	DD	08H
	DD	FLAT:??_C@_05LLAMLEHD@?$CFI64d@
	DD	FLAT:??_C@_05LLAMLEHD@?$CFI64d@
	DD	08H
	DD	FLAT:??_C@_05OINFJHGD@?$CFI64u@
	DD	FLAT:??_C@_05OINFJHGD@?$CFI64u@
	DD	04H
	DD	FLAT:??_C@_02NJPGOMH@?$CFf@
	DD	FLAT:??_C@_02NJPGOMH@?$CFf@
	DD	08H
	DD	FLAT:??_C@_02NJPGOMH@?$CFf@
	DD	FLAT:??_C@_03DLDNIBIK@?$CFlf@
?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB DD 03f800000r ; 1 ; `GetMinimumStepAtDecimalPrecision'::`2'::min_steps
	DD	03dcccccdr			; 0.1
	DD	03c23d70ar			; 0.01
	DD	03a83126fr			; 0.001
	DD	038d1b717r			; 0.0001
	DD	03727c5acr			; 1e-05
	DD	0358637bdr			; 1e-06
	DD	033d6bf95r			; 1e-07
	DD	0322bcc77r			; 1e-08
	DD	03089705fr			; 1e-09
CONST	ENDS
PUBLIC	??0ImVec2@@QAE@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??AImVec2@@QBEMI@Z				; ImVec2::operator[]
PUBLIC	??AImVec2@@QAEAAMI@Z				; ImVec2::operator[]
PUBLIC	??0ImVec4@@QAE@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QAE@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?Separator@ImGui@@YAXXZ				; ImGui::Separator
PUBLIC	?NewLine@ImGui@@YAXXZ				; ImGui::NewLine
PUBLIC	?Spacing@ImGui@@YAXXZ				; ImGui::Spacing
PUBLIC	?Dummy@ImGui@@YAXABUImVec2@@@Z			; ImGui::Dummy
PUBLIC	?AlignTextToFramePadding@ImGui@@YAXXZ		; ImGui::AlignTextToFramePadding
PUBLIC	?TextUnformatted@ImGui@@YAXPBD0@Z		; ImGui::TextUnformatted
PUBLIC	?Text@ImGui@@YAXPBDZZ				; ImGui::Text
PUBLIC	?TextV@ImGui@@YAXPBDPAD@Z			; ImGui::TextV
PUBLIC	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ		; ImGui::TextColored
PUBLIC	?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z	; ImGui::TextColoredV
PUBLIC	?TextDisabled@ImGui@@YAXPBDZZ			; ImGui::TextDisabled
PUBLIC	?TextDisabledV@ImGui@@YAXPBDPAD@Z		; ImGui::TextDisabledV
PUBLIC	?TextWrapped@ImGui@@YAXPBDZZ			; ImGui::TextWrapped
PUBLIC	?TextWrappedV@ImGui@@YAXPBDPAD@Z		; ImGui::TextWrappedV
PUBLIC	?LabelText@ImGui@@YAXPBD0ZZ			; ImGui::LabelText
PUBLIC	?LabelTextV@ImGui@@YAXPBD0PAD@Z			; ImGui::LabelTextV
PUBLIC	?BulletText@ImGui@@YAXPBDZZ			; ImGui::BulletText
PUBLIC	?BulletTextV@ImGui@@YAXPBDPAD@Z			; ImGui::BulletTextV
PUBLIC	?Button@ImGui@@YA_NPBDABUImVec2@@@Z		; ImGui::Button
PUBLIC	?SmallButton@ImGui@@YA_NPBD@Z			; ImGui::SmallButton
PUBLIC	?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::InvisibleButton
PUBLIC	?ArrowButton@ImGui@@YA_NPBDH@Z			; ImGui::ArrowButton
PUBLIC	?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z	; ImGui::Image
PUBLIC	?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z ; ImGui::ImageButton
PUBLIC	?Checkbox@ImGui@@YA_NPBDPA_N@Z			; ImGui::Checkbox
PUBLIC	?CheckboxFlags@ImGui@@YA_NPBDPAII@Z		; ImGui::CheckboxFlags
PUBLIC	?RadioButton@ImGui@@YA_NPBD_N@Z			; ImGui::RadioButton
PUBLIC	?RadioButton@ImGui@@YA_NPBDPAHH@Z		; ImGui::RadioButton
PUBLIC	?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z	; ImGui::ProgressBar
PUBLIC	?Bullet@ImGui@@YAXXZ				; ImGui::Bullet
PUBLIC	?BeginCombo@ImGui@@YA_NPBD0H@Z			; ImGui::BeginCombo
PUBLIC	?EndCombo@ImGui@@YAXXZ				; ImGui::EndCombo
PUBLIC	?Combo@ImGui@@YA_NPBDPAHQBQBDHH@Z		; ImGui::Combo
PUBLIC	?Combo@ImGui@@YA_NPBDPAH0H@Z			; ImGui::Combo
PUBLIC	?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z	; ImGui::Combo
PUBLIC	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z		; ImGui::DragFloat
PUBLIC	?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z		; ImGui::DragFloat2
PUBLIC	?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z		; ImGui::DragFloat3
PUBLIC	?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z		; ImGui::DragFloat4
PUBLIC	?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z	; ImGui::DragFloatRange2
PUBLIC	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z		; ImGui::DragInt
PUBLIC	?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z		; ImGui::DragInt2
PUBLIC	?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z		; ImGui::DragInt3
PUBLIC	?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z		; ImGui::DragInt4
PUBLIC	?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z	; ImGui::DragIntRange2
PUBLIC	?DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z		; ImGui::DragScalar
PUBLIC	?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z	; ImGui::DragScalarN
PUBLIC	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z		; ImGui::SliderFloat
PUBLIC	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z		; ImGui::SliderFloat2
PUBLIC	?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z		; ImGui::SliderFloat3
PUBLIC	?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z		; ImGui::SliderFloat4
PUBLIC	?SliderAngle@ImGui@@YA_NPBDPAMMM0@Z		; ImGui::SliderAngle
PUBLIC	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z		; ImGui::SliderInt
PUBLIC	?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z		; ImGui::SliderInt2
PUBLIC	?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z		; ImGui::SliderInt3
PUBLIC	?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z		; ImGui::SliderInt4
PUBLIC	?SliderScalar@ImGui@@YA_NPBDHPAXPBX20M@Z	; ImGui::SliderScalar
PUBLIC	?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z	; ImGui::SliderScalarN
PUBLIC	?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ; ImGui::VSliderFloat
PUBLIC	?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z	; ImGui::VSliderInt
PUBLIC	?VSliderScalar@ImGui@@YA_NPBDABUImVec2@@HPAXPBX30M@Z ; ImGui::VSliderScalar
PUBLIC	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputText
PUBLIC	?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputTextMultiline
PUBLIC	?InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputTextWithHint
PUBLIC	?InputFloat@ImGui@@YA_NPBDPAMMM0H@Z		; ImGui::InputFloat
PUBLIC	?InputFloat2@ImGui@@YA_NPBDQAM0H@Z		; ImGui::InputFloat2
PUBLIC	?InputFloat3@ImGui@@YA_NPBDQAM0H@Z		; ImGui::InputFloat3
PUBLIC	?InputFloat4@ImGui@@YA_NPBDQAM0H@Z		; ImGui::InputFloat4
PUBLIC	?InputInt@ImGui@@YA_NPBDPAHHHH@Z		; ImGui::InputInt
PUBLIC	?InputInt2@ImGui@@YA_NPBDQAHH@Z			; ImGui::InputInt2
PUBLIC	?InputInt3@ImGui@@YA_NPBDQAHH@Z			; ImGui::InputInt3
PUBLIC	?InputInt4@ImGui@@YA_NPBDQAHH@Z			; ImGui::InputInt4
PUBLIC	?InputDouble@ImGui@@YA_NPBDPANNN0H@Z		; ImGui::InputDouble
PUBLIC	?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z		; ImGui::InputScalar
PUBLIC	?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z	; ImGui::InputScalarN
PUBLIC	?ColorEdit3@ImGui@@YA_NPBDQAMH@Z		; ImGui::ColorEdit3
PUBLIC	?ColorEdit4@ImGui@@YA_NPBDQAMH@Z		; ImGui::ColorEdit4
PUBLIC	?ColorPicker3@ImGui@@YA_NPBDQAMH@Z		; ImGui::ColorPicker3
PUBLIC	?ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z		; ImGui::ColorPicker4
PUBLIC	?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
PUBLIC	?SetColorEditOptions@ImGui@@YAXH@Z		; ImGui::SetColorEditOptions
PUBLIC	?TreeNode@ImGui@@YA_NPBD@Z			; ImGui::TreeNode
PUBLIC	?TreeNode@ImGui@@YA_NPBD0ZZ			; ImGui::TreeNode
PUBLIC	?TreeNode@ImGui@@YA_NPBXPBDZZ			; ImGui::TreeNode
PUBLIC	?TreeNodeV@ImGui@@YA_NPBD0PAD@Z			; ImGui::TreeNodeV
PUBLIC	?TreeNodeV@ImGui@@YA_NPBXPBDPAD@Z		; ImGui::TreeNodeV
PUBLIC	?TreeNodeEx@ImGui@@YA_NPBDH@Z			; ImGui::TreeNodeEx
PUBLIC	?TreeNodeEx@ImGui@@YA_NPBDH0ZZ			; ImGui::TreeNodeEx
PUBLIC	?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ		; ImGui::TreeNodeEx
PUBLIC	?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z		; ImGui::TreeNodeExV
PUBLIC	?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z		; ImGui::TreeNodeExV
PUBLIC	?TreePush@ImGui@@YAXPBD@Z			; ImGui::TreePush
PUBLIC	?TreePush@ImGui@@YAXPBX@Z			; ImGui::TreePush
PUBLIC	?TreePop@ImGui@@YAXXZ				; ImGui::TreePop
PUBLIC	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ		; ImGui::GetTreeNodeToLabelSpacing
PUBLIC	?CollapsingHeader@ImGui@@YA_NPBDH@Z		; ImGui::CollapsingHeader
PUBLIC	?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z		; ImGui::CollapsingHeader
PUBLIC	?SetNextItemOpen@ImGui@@YAX_NH@Z		; ImGui::SetNextItemOpen
PUBLIC	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z	; ImGui::Selectable
PUBLIC	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z	; ImGui::Selectable
PUBLIC	?ListBox@ImGui@@YA_NPBDPAHQBQBDHH@Z		; ImGui::ListBox
PUBLIC	?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z	; ImGui::ListBox
PUBLIC	?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::ListBoxHeader
PUBLIC	?ListBoxHeader@ImGui@@YA_NPBDHH@Z		; ImGui::ListBoxHeader
PUBLIC	?ListBoxFooter@ImGui@@YAXXZ			; ImGui::ListBoxFooter
PUBLIC	?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z	; ImGui::PlotLines
PUBLIC	?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotLines
PUBLIC	?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ; ImGui::PlotHistogram
PUBLIC	?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotHistogram
PUBLIC	?Value@ImGui@@YAXPBD_N@Z			; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPBDH@Z				; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPBDI@Z				; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPBDM0@Z			; ImGui::Value
PUBLIC	?BeginMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMenuBar
PUBLIC	?EndMenuBar@ImGui@@YAXXZ			; ImGui::EndMenuBar
PUBLIC	?BeginMainMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMainMenuBar
PUBLIC	?EndMainMenuBar@ImGui@@YAXXZ			; ImGui::EndMainMenuBar
PUBLIC	?BeginMenu@ImGui@@YA_NPBD_N@Z			; ImGui::BeginMenu
PUBLIC	?EndMenu@ImGui@@YAXXZ				; ImGui::EndMenu
PUBLIC	?MenuItem@ImGui@@YA_NPBD0_N1@Z			; ImGui::MenuItem
PUBLIC	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z		; ImGui::MenuItem
PUBLIC	?Columns@ImGui@@YAXHPBD_N@Z			; ImGui::Columns
PUBLIC	?NextColumn@ImGui@@YAXXZ			; ImGui::NextColumn
PUBLIC	?GetColumnIndex@ImGui@@YAHXZ			; ImGui::GetColumnIndex
PUBLIC	?GetColumnWidth@ImGui@@YAMH@Z			; ImGui::GetColumnWidth
PUBLIC	?SetColumnWidth@ImGui@@YAXHM@Z			; ImGui::SetColumnWidth
PUBLIC	?GetColumnOffset@ImGui@@YAMH@Z			; ImGui::GetColumnOffset
PUBLIC	?SetColumnOffset@ImGui@@YAXHM@Z			; ImGui::SetColumnOffset
PUBLIC	?GetColumnsCount@ImGui@@YAHXZ			; ImGui::GetColumnsCount
PUBLIC	?BeginTabBar@ImGui@@YA_NPBDH@Z			; ImGui::BeginTabBar
PUBLIC	?EndTabBar@ImGui@@YAXXZ				; ImGui::EndTabBar
PUBLIC	?BeginTabItem@ImGui@@YA_NPBDPA_NH@Z		; ImGui::BeginTabItem
PUBLIC	?EndTabItem@ImGui@@YAXXZ			; ImGui::EndTabItem
PUBLIC	?SetTabItemClosed@ImGui@@YAXPBD@Z		; ImGui::SetTabItemClosed
PUBLIC	??2@YAPAXIUImNewDummy@@PAX@Z			; operator new
PUBLIC	??3@YAXPAXUImNewDummy@@0@Z			; operator delete
PUBLIC	?empty@?$ImVector@G@@QBE_NXZ			; ImVector<unsigned short>::empty
PUBLIC	??A?$ImVector@G@@QAEAAGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	??A?$ImVector@G@@QBEABGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@G@@QBEHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?reserve@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	?contains@?$ImVector@G@@QBE_NABG@Z		; ImVector<unsigned short>::contains
PUBLIC	??0ImGuiInputTextCallbackData@@QAE@XZ		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData
PUBLIC	?DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z ; ImGuiInputTextCallbackData::DeleteChars
PUBLIC	?InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z ; ImGuiInputTextCallbackData::InsertChars
PUBLIC	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z		; ImGui::InputFloat
PUBLIC	?InputFloat2@ImGui@@YA_NPBDQAMHH@Z		; ImGui::InputFloat2
PUBLIC	?InputFloat3@ImGui@@YA_NPBDQAMHH@Z		; ImGui::InputFloat3
PUBLIC	?InputFloat4@ImGui@@YA_NPBDQAMHH@Z		; ImGui::InputFloat4
PUBLIC	??0?$ImVector@D@@QAE@XZ				; ImVector<char>::ImVector<char>
PUBLIC	?_grow_capacity@?$ImVector@D@@QBEHH@Z		; ImVector<char>::_grow_capacity
PUBLIC	?resize@?$ImVector@D@@QAEXH@Z			; ImVector<char>::resize
PUBLIC	?reserve@?$ImVector@D@@QAEXH@Z			; ImVector<char>::reserve
PUBLIC	??0ImGuiTextBuffer@@QAE@XZ			; ImGuiTextBuffer::ImGuiTextBuffer
PUBLIC	?size@ImGuiTextBuffer@@QBEHXZ			; ImGuiTextBuffer::size
PUBLIC	??0ImGuiListClipper@@QAE@HM@Z			; ImGuiListClipper::ImGuiListClipper
PUBLIC	??1ImGuiListClipper@@QAE@XZ			; ImGuiListClipper::~ImGuiListClipper
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	?PathFillConvex@ImDrawList@@QAEXI@Z		; ImDrawList::PathFillConvex
PUBLIC	?PathStroke@ImDrawList@@QAEXI_NM@Z		; ImDrawList::PathStroke
PUBLIC	?ChannelsSplit@ImDrawList@@QAEXH@Z		; ImDrawList::ChannelsSplit
PUBLIC	?ChannelsMerge@ImDrawList@@QAEXXZ		; ImDrawList::ChannelsMerge
PUBLIC	?ChannelsSetCurrent@ImDrawList@@QAEXH@Z		; ImDrawList::ChannelsSetCurrent
PUBLIC	?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z	; ImDrawList::PrimWriteVtx
PUBLIC	?PrimWriteIdx@ImDrawList@@QAEXG@Z		; ImDrawList::PrimWriteIdx
PUBLIC	?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z	; ImDrawList::PrimVtx
PUBLIC	?back@?$ImVector@I@@QAEAAIXZ			; ImVector<unsigned int>::back
PUBLIC	?_grow_capacity@?$ImVector@I@@QBEHH@Z		; ImVector<unsigned int>::_grow_capacity
PUBLIC	?reserve@?$ImVector@I@@QAEXH@Z			; ImVector<unsigned int>::reserve
PUBLIC	?push_back@?$ImVector@I@@QAEXABI@Z		; ImVector<unsigned int>::push_back
PUBLIC	?pop_back@?$ImVector@I@@QAEXXZ			; ImVector<unsigned int>::pop_back
PUBLIC	?empty@?$ImVector@M@@QBE_NXZ			; ImVector<float>::empty
PUBLIC	??A?$ImVector@M@@QBEABMH@Z			; ImVector<float>::operator[]
PUBLIC	?empty@?$ImVector@UImFontGlyph@@@@QBE_NXZ	; ImVector<ImFontGlyph>::empty
PUBLIC	?GetCharAdvance@ImFont@@QBEMG@Z			; ImFont::GetCharAdvance
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vsscanf_l
PUBLIC	_sscanf
PUBLIC	_atan2f
PUBLIC	_cosf
PUBLIC	_fabsf
PUBLIC	_fmodf
PUBLIC	_powf
PUBLIC	_sinf
PUBLIC	?ImParseFormatFindStart@@YAPBDPBD@Z		; ImParseFormatFindStart
PUBLIC	?ImParseFormatFindEnd@@YAPBDPBD@Z		; ImParseFormatFindEnd
PUBLIC	?ImParseFormatTrimDecorations@@YAPBDPBDPADI@Z	; ImParseFormatTrimDecorations
PUBLIC	?ImParseFormatPrecision@@YAHPBDH@Z		; ImParseFormatPrecision
PUBLIC	??0ImRect@@QAE@XZ				; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@ABUImVec2@@0@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@ABUImVec4@@@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@MMMM@Z				; ImRect::ImRect
PUBLIC	?GetCenter@ImRect@@QBE?AUImVec2@@XZ		; ImRect::GetCenter
PUBLIC	?GetSize@ImRect@@QBE?AUImVec2@@XZ		; ImRect::GetSize
PUBLIC	?GetWidth@ImRect@@QBEMXZ			; ImRect::GetWidth
PUBLIC	?GetHeight@ImRect@@QBEMXZ			; ImRect::GetHeight
PUBLIC	?GetTL@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetTL
PUBLIC	?GetTR@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetTR
PUBLIC	?GetBL@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetBL
PUBLIC	?GetBR@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetBR
PUBLIC	?Contains@ImRect@@QBE_NABUImVec2@@@Z		; ImRect::Contains
PUBLIC	?Contains@ImRect@@QBE_NABU1@@Z			; ImRect::Contains
PUBLIC	?Overlaps@ImRect@@QBE_NABU1@@Z			; ImRect::Overlaps
PUBLIC	?Expand@ImRect@@QAEXM@Z				; ImRect::Expand
PUBLIC	?Expand@ImRect@@QAEXABUImVec2@@@Z		; ImRect::Expand
PUBLIC	?Translate@ImRect@@QAEXABUImVec2@@@Z		; ImRect::Translate
PUBLIC	?ClipWith@ImRect@@QAEXABU1@@Z			; ImRect::ClipWith
PUBLIC	??0ImGuiMenuColumns@@QAE@XZ			; ImGuiMenuColumns::ImGuiMenuColumns
PUBLIC	?Update@ImGuiMenuColumns@@QAEXHM_N@Z		; ImGuiMenuColumns::Update
PUBLIC	?DeclColumns@ImGuiMenuColumns@@QAEMMMM@Z	; ImGuiMenuColumns::DeclColumns
PUBLIC	?CalcExtraSpace@ImGuiMenuColumns@@QBEMM@Z	; ImGuiMenuColumns::CalcExtraSpace
PUBLIC	?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z	; ImGuiInputTextState::OnKeyPressed
PUBLIC	?CursorAnimReset@ImGuiInputTextState@@QAEXXZ	; ImGuiInputTextState::CursorAnimReset
PUBLIC	?CursorClamp@ImGuiInputTextState@@QAEXXZ	; ImGuiInputTextState::CursorClamp
PUBLIC	?HasSelection@ImGuiInputTextState@@QBE_NXZ	; ImGuiInputTextState::HasSelection
PUBLIC	?ClearSelection@ImGuiInputTextState@@QAEXXZ	; ImGuiInputTextState::ClearSelection
PUBLIC	?SelectAll@ImGuiInputTextState@@QAEXXZ		; ImGuiInputTextState::SelectAll
PUBLIC	??0ImGuiColumnData@@QAE@XZ			; ImGuiColumnData::ImGuiColumnData
PUBLIC	??0?$ImVector@UImGuiColumnData@@@@QAE@XZ	; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
PUBLIC	??1?$ImVector@UImGuiColumnData@@@@QAE@XZ	; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
PUBLIC	??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
PUBLIC	?clear@?$ImVector@UImGuiColumnData@@@@QAEXXZ	; ImVector<ImGuiColumnData>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QBEHH@Z ; ImVector<ImGuiColumnData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z	; ImVector<ImGuiColumnData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z	; ImVector<ImGuiColumnData>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiColumnData@@@@QAEXABUImGuiColumnData@@@Z ; ImVector<ImGuiColumnData>::push_back
PUBLIC	??0ImGuiColumns@@QAE@XZ				; ImGuiColumns::ImGuiColumns
PUBLIC	?Clear@ImGuiColumns@@QAEXXZ			; ImGuiColumns::Clear
PUBLIC	??1ImGuiColumns@@QAE@XZ				; ImGuiColumns::~ImGuiColumns
PUBLIC	?ClearFlags@ImGuiNextItemData@@QAEXXZ		; ImGuiNextItemData::ClearFlags
PUBLIC	??0ImGuiPtrOrIndex@@QAE@PAX@Z			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
PUBLIC	??0ImGuiPtrOrIndex@@QAE@H@Z			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
PUBLIC	??A?$ImVector@UImGuiPopupData@@@@QAEAAUImGuiPopupData@@H@Z ; ImVector<ImGuiPopupData>::operator[]
PUBLIC	??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QBEHH@Z ; ImVector<ImGuiTabBar>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTabBar@@@@QAEXH@Z	; ImVector<ImGuiTabBar>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTabBar@@@@QAEXH@Z	; ImVector<ImGuiTabBar>::reserve
PUBLIC	?GetByIndex@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@H@Z ; ImPool<ImGuiTabBar>::GetByIndex
PUBLIC	?GetIndex@?$ImPool@UImGuiTabBar@@@@QBEHPBUImGuiTabBar@@@Z ; ImPool<ImGuiTabBar>::GetIndex
PUBLIC	?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@I@Z ; ImPool<ImGuiTabBar>::GetOrAddByKey
PUBLIC	?Contains@?$ImPool@UImGuiTabBar@@@@QBE_NPBUImGuiTabBar@@@Z ; ImPool<ImGuiTabBar>::Contains
PUBLIC	?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ ; ImPool<ImGuiTabBar>::Add
PUBLIC	?empty@?$ImVector@UImGuiPtrOrIndex@@@@QBE_NXZ	; ImVector<ImGuiPtrOrIndex>::empty
PUBLIC	?back@?$ImVector@UImGuiPtrOrIndex@@@@QAEAAUImGuiPtrOrIndex@@XZ ; ImVector<ImGuiPtrOrIndex>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QBEHH@Z ; ImVector<ImGuiPtrOrIndex>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QAEXH@Z	; ImVector<ImGuiPtrOrIndex>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXABUImGuiPtrOrIndex@@@Z ; ImVector<ImGuiPtrOrIndex>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXXZ	; ImVector<ImGuiPtrOrIndex>::pop_back
PUBLIC	??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z ; ImVector<ImGuiShrinkWidthItem>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QBEHH@Z ; ImVector<ImGuiShrinkWidthItem>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z ; ImVector<ImGuiShrinkWidthItem>::resize
PUBLIC	?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z ; ImVector<ImGuiShrinkWidthItem>::reserve
PUBLIC	?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ	; ImVector<ImGuiGroupData>::empty
PUBLIC	?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
PUBLIC	??A?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@H@Z ; ImVector<ImGuiColumns>::operator[]
PUBLIC	?back@?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@XZ ; ImVector<ImGuiColumns>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiColumns@@@@QBEHH@Z ; ImVector<ImGuiColumns>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiColumns@@@@QAEXH@Z	; ImVector<ImGuiColumns>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiColumns@@@@QAEXABUImGuiColumns@@@Z ; ImVector<ImGuiColumns>::push_back
PUBLIC	?Rect@ImGuiWindow@@QBE?AUImRect@@XZ		; ImGuiWindow::Rect
PUBLIC	?CalcFontSize@ImGuiWindow@@QBEMXZ		; ImGuiWindow::CalcFontSize
PUBLIC	?TitleBarHeight@ImGuiWindow@@QBEMXZ		; ImGuiWindow::TitleBarHeight
PUBLIC	?MenuBarHeight@ImGuiWindow@@QBEMXZ		; ImGuiWindow::MenuBarHeight
PUBLIC	?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ	; ImGuiWindow::MenuBarRect
PUBLIC	??0ImGuiItemHoveredDataBackup@@QAE@XZ		; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup
PUBLIC	?Backup@ImGuiItemHoveredDataBackup@@QAEXXZ	; ImGuiItemHoveredDataBackup::Backup
PUBLIC	?Restore@ImGuiItemHoveredDataBackup@@QBEXXZ	; ImGuiItemHoveredDataBackup::Restore
PUBLIC	??0ImGuiTabItem@@QAE@XZ				; ImGuiTabItem::ImGuiTabItem
PUBLIC	??0?$ImVector@UImGuiTabItem@@@@QAE@XZ		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
PUBLIC	??1?$ImVector@UImGuiTabItem@@@@QAE@XZ		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
PUBLIC	??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
PUBLIC	?back@?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@XZ ; ImVector<ImGuiTabItem>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QBEHH@Z ; ImVector<ImGuiTabItem>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiTabItem@@@@QAEXH@Z	; ImVector<ImGuiTabItem>::resize
PUBLIC	?reserve@?$ImVector@UImGuiTabItem@@@@QAEXH@Z	; ImVector<ImGuiTabItem>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiTabItem@@@@QAEXABUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::push_back
PUBLIC	?erase@?$ImVector@UImGuiTabItem@@@@QAEPAUImGuiTabItem@@PBU2@@Z ; ImVector<ImGuiTabItem>::erase
PUBLIC	?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QBEHPBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::index_from_ptr
PUBLIC	??0ImGuiTabBar@@QAE@XZ				; ImGuiTabBar::ImGuiTabBar
PUBLIC	?GetTabOrder@ImGuiTabBar@@QBEHPBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
PUBLIC	?GetTabName@ImGuiTabBar@@QBEPBDPBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabName
PUBLIC	?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
PUBLIC	?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ	; ImGui::GetCurrentWindow
PUBLIC	?ShrinkWidths@ImGui@@YAXPAUImGuiShrinkWidthItem@@HM@Z ; ImGui::ShrinkWidths
PUBLIC	?IsKeyPressedMap@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressedMap
PUBLIC	?IsNavInputDown@ImGui@@YA_NH@Z			; ImGui::IsNavInputDown
PUBLIC	?IsNavInputTest@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputTest
PUBLIC	?BeginColumns@ImGui@@YAXPBDHH@Z			; ImGui::BeginColumns
PUBLIC	?EndColumns@ImGui@@YAXXZ			; ImGui::EndColumns
PUBLIC	?PushColumnClipRect@ImGui@@YAXH@Z		; ImGui::PushColumnClipRect
PUBLIC	?PushColumnsBackground@ImGui@@YAXXZ		; ImGui::PushColumnsBackground
PUBLIC	?PopColumnsBackground@ImGui@@YAXXZ		; ImGui::PopColumnsBackground
PUBLIC	?GetColumnsID@ImGui@@YAIPBDH@Z			; ImGui::GetColumnsID
PUBLIC	?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z ; ImGui::FindOrCreateColumns
PUBLIC	?GetColumnOffsetFromNorm@ImGui@@YAMPBUImGuiColumns@@M@Z ; ImGui::GetColumnOffsetFromNorm
PUBLIC	?GetColumnNormFromOffset@ImGui@@YAMPBUImGuiColumns@@M@Z ; ImGui::GetColumnNormFromOffset
PUBLIC	?BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z ; ImGui::BeginTabBarEx
PUBLIC	?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
PUBLIC	?TabBarRemoveTab@ImGui@@YAXPAUImGuiTabBar@@I@Z	; ImGui::TabBarRemoveTab
PUBLIC	?TabBarCloseTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z ; ImGui::TabBarCloseTab
PUBLIC	?TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
PUBLIC	?TabItemEx@ImGui@@YA_NPAUImGuiTabBar@@PBDPA_NH@Z ; ImGui::TabItemEx
PUBLIC	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PBD_N@Z	; ImGui::TabItemCalcSize
PUBLIC	?TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z ; ImGui::TabItemBackground
PUBLIC	?TabItemLabelAndCloseButton@ImGui@@YA_NPAUImDrawList@@ABUImRect@@HUImVec2@@PBDII@Z ; ImGui::TabItemLabelAndCloseButton
PUBLIC	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
PUBLIC	?TextEx@ImGui@@YAXPBD0H@Z			; ImGui::TextEx
PUBLIC	?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z		; ImGui::ButtonEx
PUBLIC	?CloseButton@ImGui@@YA_NIABUImVec2@@@Z		; ImGui::CloseButton
PUBLIC	?CollapseButton@ImGui@@YA_NIABUImVec2@@@Z	; ImGui::CollapseButton
PUBLIC	?ArrowButtonEx@ImGui@@YA_NPBDHUImVec2@@H@Z	; ImGui::ArrowButtonEx
PUBLIC	?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z		; ImGui::Scrollbar
PUBLIC	?ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z ; ImGui::ScrollbarEx
PUBLIC	?GetWindowScrollbarID@ImGui@@YAIPAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetWindowScrollbarID
PUBLIC	?SeparatorEx@ImGui@@YAXH@Z			; ImGui::SeparatorEx
PUBLIC	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z	; ImGui::ButtonBehavior
PUBLIC	?DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z	; ImGui::DragBehavior
PUBLIC	?SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU2@@Z ; ImGui::SliderBehavior
PUBLIC	?SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z ; ImGui::SplitterBehavior
PUBLIC	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z		; ImGui::TreeNodeBehavior
PUBLIC	?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z		; ImGui::TreeNodeBehaviorIsOpen
PUBLIC	?TreePushOverrideID@ImGui@@YAXI@Z		; ImGui::TreePushOverrideID
PUBLIC	?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z ; ImGui::DataTypeGetInfo
PUBLIC	?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z	; ImGui::DataTypeFormatString
PUBLIC	?DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z		; ImGui::DataTypeApplyOp
PUBLIC	?DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z	; ImGui::DataTypeApplyOpFromText
PUBLIC	?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
PUBLIC	?TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z ; ImGui::TempInputTextScalar
PUBLIC	?TempInputTextIsActive@ImGui@@YA_NI@Z		; ImGui::TempInputTextIsActive
PUBLIC	?ColorTooltip@ImGui@@YAXPBDPBMH@Z		; ImGui::ColorTooltip
PUBLIC	?ColorEditOptionsPopup@ImGui@@YAXPBMH@Z		; ImGui::ColorEditOptionsPopup
PUBLIC	?ColorPickerOptionsPopup@ImGui@@YAXPBMH@Z	; ImGui::ColorPickerOptionsPopup
PUBLIC	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
PUBLIC	??$DragBehaviorT@HHM@ImGui@@YA_NHPAHMHHPBDMH@Z	; ImGui::DragBehaviorT<int,int,float>
PUBLIC	??$DragBehaviorT@IHM@ImGui@@YA_NHPAIMIIPBDMH@Z	; ImGui::DragBehaviorT<unsigned int,int,float>
PUBLIC	??$DragBehaviorT@_J_JN@ImGui@@YA_NHPA_JM_J1PBDMH@Z ; ImGui::DragBehaviorT<__int64,__int64,double>
PUBLIC	??$DragBehaviorT@_K_JN@ImGui@@YA_NHPA_KM_K1PBDMH@Z ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
PUBLIC	??$DragBehaviorT@MMM@ImGui@@YA_NHPAMMMMPBDMH@Z	; ImGui::DragBehaviorT<float,float,float>
PUBLIC	??$DragBehaviorT@NNN@ImGui@@YA_NHPANMNNPBDMH@Z	; ImGui::DragBehaviorT<double,double,double>
PUBLIC	??$SliderBehaviorT@HHM@ImGui@@YA_NABUImRect@@IHPAHHHPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<int,int,float>
PUBLIC	??$SliderBehaviorT@IHM@ImGui@@YA_NABUImRect@@IHPAIIIPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<unsigned int,int,float>
PUBLIC	??$SliderBehaviorT@_J_JN@ImGui@@YA_NABUImRect@@IHPA_J_J2PBDMHPAU1@@Z ; ImGui::SliderBehaviorT<__int64,__int64,double>
PUBLIC	??$SliderBehaviorT@_K_JN@ImGui@@YA_NABUImRect@@IHPA_K_K2PBDMHPAU1@@Z ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>
PUBLIC	??$SliderBehaviorT@MMM@ImGui@@YA_NABUImRect@@IHPAMMMPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<float,float,float>
PUBLIC	??$SliderBehaviorT@NNN@ImGui@@YA_NABUImRect@@IHPANNNPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<double,double,double>
PUBLIC	??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData
PUBLIC	??$RoundScalarWithFormatT@HH@ImGui@@YAHPBDHH@Z	; ImGui::RoundScalarWithFormatT<int,int>
PUBLIC	??$RoundScalarWithFormatT@IH@ImGui@@YAIPBDHI@Z	; ImGui::RoundScalarWithFormatT<unsigned int,int>
PUBLIC	??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64,__int64>
PUBLIC	??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
PUBLIC	??$RoundScalarWithFormatT@MM@ImGui@@YAMPBDHM@Z	; ImGui::RoundScalarWithFormatT<float,float>
PUBLIC	??$RoundScalarWithFormatT@NN@ImGui@@YANPBDHN@Z	; ImGui::RoundScalarWithFormatT<double,double>
PUBLIC	??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ; ImGui::SliderCalcRatioFromValueT<int,float>
PUBLIC	??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
PUBLIC	??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ; ImGui::SliderCalcRatioFromValueT<__int64,double>
PUBLIC	??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
PUBLIC	??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ; ImGui::SliderCalcRatioFromValueT<float,float>
PUBLIC	??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ; ImGui::SliderCalcRatioFromValueT<double,double>
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1BC@IIGHOJGM@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	??_C@_1CC@IHACEFEE@?$AAI?$AAt?$AAe?$AAm?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9@ ; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_1LE@HAMNIKDF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1HM@PJKJLKEH@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAN?$AAa?$AAm?$AAe?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt@ ; `string'
PUBLIC	?__LINE__Var@?0??TextEx@ImGui@@YAXPBD0H@Z@4JA	; `ImGui::TextEx'::`1'::__LINE__Var
PUBLIC	??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1BE@HMGDGFIB@?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z@4JA ; `ImGui::InvisibleButton'::`1'::__LINE__Var
PUBLIC	??_C@_1FC@KJEAANOI@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAa?$AAr?$AAg?$AA?4?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_08ENAFOMOP@?$CDSCROLLX@			; `string'
PUBLIC	??_C@_08FEBONNKO@?$CDSCROLLY@			; `string'
PUBLIC	?__LINE__Var@?0??ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z@4JA ; `ImGui::ScrollbarEx'::`1'::__LINE__Var
PUBLIC	??_C@_1FI@OFJDJLOI@?$AAI?$AAm?$AAM?$AAa?$AAx?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAc?$AAo?$AAn?$AAt@ ; `string'
PUBLIC	?__LINE__Var@?0??Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z@4JA ; `ImGui::Scrollbar'::`1'::__LINE__Var
PUBLIC	??_C@_1CM@GFPJIOBE@?$AAs?$AAc?$AAr?$AAo?$AAl?$AAl?$AAb?$AAa?$AAr?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5@ ; `string'
PUBLIC	??_C@_06EBHDMMP@?$CDimage@			; `string'
PUBLIC	??_C@_03JHEALCLB@?$FLx?$FN@			; `string'
PUBLIC	??_C@_03PFOPMNLJ@?$FL?5?$FN@			; `string'
PUBLIC	??_C@_03KFJJABDB@?$CIx?$CJ@			; `string'
PUBLIC	??_C@_03MHDGHODJ@?$CI?5?$CJ@			; `string'
PUBLIC	??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@		; `string'
PUBLIC	?__LINE__Var@?0??SeparatorEx@ImGui@@YAXH@Z@4JA	; `ImGui::SeparatorEx'::`1'::__LINE__Var
PUBLIC	??_C@_1LA@FPPCKOP@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ ; `string'
PUBLIC	??_C@_02LLHJFGPH@?5?$HM@			; `string'
PUBLIC	??_C@_0CB@GNHPAIID@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	?__LINE__Var@?0??SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z@4JA ; `ImGui::SplitterBehavior'::`1'::__LINE__Var
PUBLIC	??_C@_1EE@HJGLFFIG@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA1?$AA?5?$AA?$CL?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@ ; `string'
PUBLIC	??_C@_1EE@LBEKBPGJ@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA2?$AA?5?$AA?9?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@ ; `string'
PUBLIC	?__LINE__Var@?0??BeginCombo@ImGui@@YA_NPBD0H@Z@4JA ; `ImGui::BeginCombo'::`1'::__LINE__Var
PUBLIC	??_C@_1BAK@ONBANIIG@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAI?$AAm?$AAG?$AAu?$AAi@ ; `string'
PUBLIC	??_C@_1GI@IOEAHNLK@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ ; `string'
PUBLIC	??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@	; `string'
PUBLIC	??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@	; `string'
PUBLIC	??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@	; `string'
PUBLIC	?__LINE__Var@?0??DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z@4JA ; `ImGui::DataTypeGetInfo'::`1'::__LINE__Var
PUBLIC	??_C@_1GE@PMGCKKHF@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z@4JA ; `ImGui::DataTypeFormatString'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z@4JA ; `ImGui::DataTypeApplyOp'::`1'::__LINE__Var
PUBLIC	??_C@_1CO@LEDHMGOL@?$AAo?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AA?$CL?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAp@ ; `string'
PUBLIC	?__LINE__Var@?0??DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z@4JA ; `ImGui::DataTypeApplyOpFromText'::`1'::__LINE__Var
PUBLIC	??_C@_1EA@ILBKEPMO@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5?$AAI?$AAm?$AAG@ ; `string'
PUBLIC	??_C@_1EO@OEMFLDEM@?$AAt?$AAy?$AAp?$AAe?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z@4JA ; `ImGui::DragBehavior'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z@4JA ; `ImGui::DragScalar'::`1'::__LINE__Var
PUBLIC	??_C@_1DC@IAANKGPJ@?$AAp?$AA_?$AAm?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_05DMFAOFEI@?$CD?$CDmin@			; `string'
PUBLIC	??_C@_05CONLABCH@?$CD?$CDmax@			; `string'
PUBLIC	?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA ; `ImGui::SliderBehavior'::`1'::__LINE__Var
PUBLIC	??_C@_1JK@KBPJHMJO@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA3?$AA2?$AA?$CK?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EK@CNKAEFCM@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA3?$AA2?$AA?$CK?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1JK@NOHGLDJN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA6?$AA4?$AA?$CK?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EK@CBABBPPD@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA6?$AA4?$AA?$CK?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1MA@ELIKKGKL@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$CK?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1OA@OEHGOKMN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$CK@ ; `string'
PUBLIC	??_C@_08FKIHKODH@?$CF?40f?5deg@			; `string'
PUBLIC	?__LINE__Var@?0??TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z@4JA ; `ImGui::TempInputTextScalar'::`1'::__LINE__Var
PUBLIC	??_C@_1CC@LLIJAMKA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_01MIFGBAGJ@?$CL@				; `string'
PUBLIC	??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@		; `string'
PUBLIC	??_C@_04JIMNDDED@?$CF08X@			; `string'
PUBLIC	?__LINE__Var@?0??InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA ; `ImGui::InputText'::`1'::__LINE__Var
PUBLIC	??_C@_1FC@IFNBIILP@?$AA?$CB?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi@ ; `string'
PUBLIC	?__LINE__Var@?0??InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA ; `ImGui::InputTextWithHint'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z@4JA ; `ImStb::STB_TEXTEDIT_INSERTCHARS'::`1'::__LINE__Var
PUBLIC	??_C@_1CA@MNHDBBDP@?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1DG@IEAPMEMO@?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAo?$AAb?$AAj?$AA?9@ ; `string'
PUBLIC	?__LINE__Var@?0??stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@2@@Z@4JA ; `ImStb::stb_textedit_discard_redo'::`1'::__LINE__Var
PUBLIC	??_C@_1LE@DPFBMFBF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1HI@OHEJKGLD@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@ ; `string'
PUBLIC	??_C@_1JE@JEJNCKKO@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@ ; `string'
PUBLIC	?__LINE__Var@?0??DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z@4JA ; `ImGuiInputTextCallbackData::DeleteChars'::`1'::__LINE__Var
PUBLIC	??_C@_1EA@OOMMGKHM@?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAc?$AAo?$AAu@ ; `string'
PUBLIC	?__LINE__Var@?0??InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z@4JA ; `ImGuiInputTextCallbackData::InsertChars'::`1'::__LINE__Var
PUBLIC	??_C@_1GI@EFFMAEBL@?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5@ ; `string'
PUBLIC	??_C@_1DM@LDGOBGNL@?$AAB?$AAu?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa@ ; `string'
PUBLIC	?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA ; `ImGui::InputTextEx'::`1'::__LINE__Var
PUBLIC	??_C@_1LI@BDNHGOFF@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@ ; `string'
PUBLIC	??_C@_1MG@MGOPIKJM@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@ ; `string'
PUBLIC	??_C@_1BM@CBGPMFEC@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1DC@CMKEKNGP@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@ ; `string'
PUBLIC	??_C@_1NI@EFFIGGBI@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AA_?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1BG@FOPGMADN@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1EO@GEAEFBFI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@ ; `string'
PUBLIC	??_C@_1FK@GDPCIOA@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@ ; `string'
PUBLIC	??_C@_1DK@HOPDKFNI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAF@ ; `string'
PUBLIC	??_C@_1HG@EHLBBEIB@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@ ; `string'
PUBLIC	??_C@_1DG@CHDFECEK@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@ ; `string'
PUBLIC	??_C@_1EE@MOOHJKEO@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@ ; `string'
PUBLIC	?__LINE__Var@?0??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4JA ; `ImGui::ColorEdit4'::`1'::__LINE__Var
PUBLIC	??_C@_1HC@IFIJNDDD@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ ; `string'
PUBLIC	??_C@_1GO@CDHIBPHM@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ ; `string'
PUBLIC	??_C@_07FFNLLALM@M?30?4000@			; `string'
PUBLIC	??_C@_05BNGMMMAL@M?3000@			; `string'
PUBLIC	??_C@_07JKKCBBMM@context@			; `string'
PUBLIC	??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_06MNCEJPDI@?$CD?$CDText@			; `string'
PUBLIC	??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@		; `string'
PUBLIC	??_C@_06MAKAMBBI@picker@			; `string'
PUBLIC	??_C@_08HHEANBBL@?$CD?$CDpicker@		; `string'
PUBLIC	??_C@_06LFKNFKEK@_COL3F@			; `string'
PUBLIC	??_C@_06LAOCEMMP@_COL4F@			; `string'
PUBLIC	?__LINE__Var@?0??ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z@4JA ; `ImGui::ColorPicker4'::`1'::__LINE__Var
PUBLIC	??_C@_1HA@IEGAFBEB@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ ; `string'
PUBLIC	??_C@_03PPLPHHG@hsv@				; `string'
PUBLIC	??_C@_02CPGMCOJE@sv@				; `string'
PUBLIC	??_C@_03GKJJMKFG@hue@				; `string'
PUBLIC	??_C@_05IAEKHIAN@alpha@				; `string'
PUBLIC	??_C@_07EDIFFIJI@Current@			; `string'
PUBLIC	??_C@_09CDENILGE@?$CD?$CDcurrent@		; `string'
PUBLIC	??_C@_08DCPBJHAO@Original@			; `string'
PUBLIC	??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@		; `string'
PUBLIC	??_C@_05JCABMAIH@?$CD?$CDrgb@			; `string'
PUBLIC	??_C@_05JICEKLIF@?$CD?$CDhsv@			; `string'
PUBLIC	??_C@_05BOAMFJMJ@?$CD?$CDhex@			; `string'
PUBLIC	??_C@_05PDOBBJNA@Color@				; `string'
PUBLIC	?__LINE__Var@?0??SetColorEditOptions@ImGui@@YAXH@Z@4JA ; `ImGui::SetColorEditOptions'::`1'::__LINE__Var
PUBLIC	??_C@_1HE@ECJOEGME@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ ; `string'
PUBLIC	??_C@_09JCCDBEFL@?$CD?$CDpreview@		; `string'
PUBLIC	??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@ ; `string'
PUBLIC	??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@ ; `string'
PUBLIC	??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@ ; `string'
PUBLIC	??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@ ; `string'
PUBLIC	??_C@_03ICFFBAI@RGB@				; `string'
PUBLIC	??_C@_03CAADKAK@HSV@				; `string'
PUBLIC	??_C@_03CJOBKKAE@Hex@				; `string'
PUBLIC	??_C@_06FDBEKFBH@0?4?4255@			; `string'
PUBLIC	??_C@_0L@MDNPBJBM@0?400?4?41?400@		; `string'
PUBLIC	??_C@_09NMCCFHEI@Copy?5as?4?4@			; `string'
PUBLIC	??_C@_04OPMHGHMB@Copy@				; `string'
PUBLIC	??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@ ; `string'
PUBLIC	??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_0N@KFBFGFJL@?$CD?$CDselectable@		; `string'
PUBLIC	??_C@_0O@KNMNNHNH@?$CD?$CDdummypicker@		; `string'
PUBLIC	??_C@_09KEDLMDJL@Alpha?5Bar@			; `string'
PUBLIC	??_C@_03DFKEEPFP@?6?$CD?$CD@			; `string'
PUBLIC	??_C@_02IEBMKJDF@?$CD?$CD@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO@				; `string'
PUBLIC	??_C@_09GHACPMKF@?$CDTreePush@			; `string'
PUBLIC	?__LINE__Var@?0??TreePop@ImGui@@YAXXZ@4JA	; `ImGui::TreePop'::`1'::__LINE__Var
PUBLIC	??_C@_1DC@KOOPJPAL@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk@ ; `string'
PUBLIC	?__LINE__Var@?0??PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z@4JA ; `ImGui::PlotEx'::`1'::__LINE__Var
PUBLIC	??_C@_1EG@HCGMCBDC@?$AAv?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv@ ; `string'
PUBLIC	??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@ ; `string'
PUBLIC	??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@		; `string'
PUBLIC	??_C@_1EK@JIGPMMPH@?$AAv?$AA1?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_06DJHOIPC@?$CFs?3?5?$CFs@			; `string'
PUBLIC	??_C@_06GBEGMGE@?$CFs?3?5?$CFd@			; `string'
PUBLIC	??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@		; `string'
PUBLIC	??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@		; `string'
PUBLIC	?__LINE__Var@?0??Update@ImGuiMenuColumns@@QAEXHM_N@Z@4JA ; `ImGuiMenuColumns::Update'::`1'::__LINE__Var
PUBLIC	??_C@_1FK@BNPKANMO@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?0??BeginMenuBar@ImGui@@YA_NXZ@4JA	; `ImGui::BeginMenuBar'::`1'::__LINE__Var
PUBLIC	??_C@_1DK@MIADNLCN@?$AA?$CB?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_09FHPMMDGK@?$CD?$CDmenubar@		; `string'
PUBLIC	?__LINE__Var@?0??EndMenuBar@ImGui@@YAXXZ@4JA	; `ImGui::EndMenuBar'::`1'::__LINE__Var
PUBLIC	??_C@_1GC@NKCHGHAD@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAN?$AAa?$AAv?$AAL@ ; `string'
PUBLIC	??_C@_1FC@MMAFNJJP@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1DI@HJHPMKIH@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn?$AAu@ ; `string'
PUBLIC	??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@		; `string'
PUBLIC	?__LINE__Var@?0??BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z@4JA ; `ImGui::BeginTabBarEx'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??EndTabBar@ImGui@@YAXXZ@4JA	; `ImGui::EndTabBar'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@DPIPLNLI@Mismatched?5BeginTabBar?$CI?$CJ?1EndTab@ ; `string'
PUBLIC	??_C@_1HE@HMPOLDED@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z@4JA ; `ImGui::TabBarLayout'::`1'::__LINE__Var
PUBLIC	??_C@_1GG@ODBMJKON@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAV@ ; `string'
PUBLIC	??_C@_1CE@HKABMAAD@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4@ ; `string'
PUBLIC	?__LINE__Var@?0??TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z@4JA ; `ImGui::TabBarQueueChangeTabOrder'::`1'::__LINE__Var
PUBLIC	??_C@_1CO@FGAFEEBL@?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAi@ ; `string'
PUBLIC	??_C@_1EE@NGAACFPK@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAR?$AAe?$AAo?$AAr?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_03CFMEKBHF@?$CD?$CD?$DM@			; `string'
PUBLIC	??_C@_03BHPCMDPH@?$CD?$CD?$DO@			; `string'
PUBLIC	??_C@_03CPFCAGPK@?$CD?$CDv@			; `string'
PUBLIC	?__LINE__Var@?0??BeginTabItem@ImGui@@YA_NPBDPA_NH@Z@4JA ; `ImGui::BeginTabItem'::`1'::__LINE__Var
PUBLIC	??_C@_0EJ@BGGEHPHF@BeginTabItem?$CI?$CJ?5Needs?5to?5be?5call@ ; `string'
PUBLIC	??_C@_1LA@GNEGANEK@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAB@ ; `string'
PUBLIC	?__LINE__Var@?0??EndTabItem@ImGui@@YAXXZ@4JA	; `ImGui::EndTabItem'::`1'::__LINE__Var
PUBLIC	??_C@_0DK@EHILAJFJ@Needs?5to?5be?5called?5between?5Begi@ ; `string'
PUBLIC	??_C@_1JI@HFPIFMIP@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@ ; `string'
PUBLIC	??_C@_1DK@HGEILAOB@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAT?$AAa@ ; `string'
PUBLIC	??_C@_04EBNJJJJI@?$CF?4?$CKs@			; `string'
PUBLIC	?__LINE__Var@?0??SetTabItemClosed@ImGui@@YAXPBD@Z@4JA ; `ImGui::SetTabItemClosed'::`1'::__LINE__Var
PUBLIC	??_C@_1CI@FDDNDGMG@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAW?$AAa?$AAn?$AAt?$AAL?$AAa@ ; `string'
PUBLIC	?__LINE__Var@?0??TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z@4JA ; `ImGui::TabItemBackground'::`1'::__LINE__Var
PUBLIC	??_C@_1BK@HMBBPDPB@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf@ ; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z@4JA ; `GetDraggedColumnOffset'::`1'::__LINE__Var
PUBLIC	??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5@ ; `string'
PUBLIC	??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc@ ; `string'
PUBLIC	?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA ; `ImGui::GetColumnOffset'::`1'::__LINE__Var
PUBLIC	??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA ; `ImGui::SetColumnOffset'::`1'::__LINE__Var
PUBLIC	??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA ; `ImGui::SetColumnWidth'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??PushColumnsBackground@ImGui@@YAXXZ@4JA ; `ImGui::PushColumnsBackground'::`1'::__LINE__Var
PUBLIC	??_C@_1FK@BKCOEDF@?$AAc?$AAm?$AAd?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAw?$AAi?$AAn@ ; `string'
PUBLIC	??_C@_07HIFEPIJN@columns@			; `string'
PUBLIC	?__LINE__Var@?0??BeginColumns@ImGui@@YAXPBDHH@Z@4JA ; `ImGui::BeginColumns'::`1'::__LINE__Var
PUBLIC	??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO@ ; `string'
PUBLIC	??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr@ ; `string'
PUBLIC	??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA	; `ImGui::NextColumn'::`1'::__LINE__Var
PUBLIC	??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn@ ; `string'
PUBLIC	?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA	; `ImGui::EndColumns'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Columns@ImGui@@YAXHPBD_N@Z@4JA	; `ImGui::Columns'::`1'::__LINE__Var
PUBLIC	??_C@_1DO@NPHOAPAC@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@00800000
PUBLIC	__real@358637bd
PUBLIC	__real@3727c5ac
PUBLIC	__real@38d1b717
PUBLIC	__real@3b808081
PUBLIC	__real@3c23d70a
PUBLIC	__real@3cdd2f1b
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e09374c
PUBLIC	__real@3e19999a
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f19999a
PUBLIC	__real@3f266666
PUBLIC	__real@3f333333
PUBLIC	__real@3f350481
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f5db22d
PUBLIC	__real@3f5db3d0
PUBLIC	__real@3f7ff972
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@3fb33333
PUBLIC	__real@3fc00000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@403f5c29
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@4059000000000000
PUBLIC	__real@40666666
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40eccccd
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41a00000
PUBLIC	__real@41f00000
PUBLIC	__real@428c0000
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@43b40000
PUBLIC	__real@43e0000000000000
PUBLIC	__real@47efffffe0000000
PUBLIC	__real@7effffff
PUBLIC	__real@7f7fffff
PUBLIC	__real@7fdfffffffffffff
PUBLIC	__real@7fefffffffffffff
PUBLIC	__real@be99999a
PUBLIC	__real@bf000000
PUBLIC	__real@bf400000
PUBLIC	__real@bf5db3d0
PUBLIC	__real@bf800000
PUBLIC	__real@c059000000000000
PUBLIC	__real@c2c80000
PUBLIC	__real@feffffff
PUBLIC	__real@ff7fffff
PUBLIC	__real@ffdfffffffffffff
PUBLIC	__real@ffefffffffffffff
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memchr:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___wassert:PROC
EXTRN	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?Begin@ImGui@@YA_NPBDPA_NH@Z:PROC		; ImGui::Begin
EXTRN	?End@ImGui@@YAXXZ:PROC				; ImGui::End
EXTRN	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H0@Z:PROC ; ImGui::SetNextWindowPos
EXTRN	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z:PROC ; ImGui::SetNextWindowSize
EXTRN	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeCallbackData@@@ZPAX@Z:PROC ; ImGui::SetNextWindowSizeConstraints
EXTRN	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetContentRegionMax
EXTRN	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetContentRegionAvail
EXTRN	?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetWindowContentRegionMax
EXTRN	?GetScrollMaxY@ImGui@@YAMXZ:PROC		; ImGui::GetScrollMaxY
EXTRN	?PushFont@ImGui@@YAXPAUImFont@@@Z:PROC		; ImGui::PushFont
EXTRN	?PopFont@ImGui@@YAXXZ:PROC			; ImGui::PopFont
EXTRN	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z:PROC	; ImGui::PushStyleColor
EXTRN	?PopStyleColor@ImGui@@YAXH@Z:PROC		; ImGui::PopStyleColor
EXTRN	?PushStyleVar@ImGui@@YAXHM@Z:PROC		; ImGui::PushStyleVar
EXTRN	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z:PROC	; ImGui::PushStyleVar
EXTRN	?PopStyleVar@ImGui@@YAXH@Z:PROC			; ImGui::PopStyleVar
EXTRN	?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetFontTexUvWhitePixel
EXTRN	?GetColorU32@ImGui@@YAIHM@Z:PROC		; ImGui::GetColorU32
EXTRN	?GetColorU32@ImGui@@YAIABUImVec4@@@Z:PROC	; ImGui::GetColorU32
EXTRN	?GetColorU32@ImGui@@YAII@Z:PROC			; ImGui::GetColorU32
EXTRN	?PushItemWidth@ImGui@@YAXM@Z:PROC		; ImGui::PushItemWidth
EXTRN	?PopItemWidth@ImGui@@YAXXZ:PROC			; ImGui::PopItemWidth
EXTRN	?SetNextItemWidth@ImGui@@YAXM@Z:PROC		; ImGui::SetNextItemWidth
EXTRN	?CalcItemWidth@ImGui@@YAMXZ:PROC		; ImGui::CalcItemWidth
EXTRN	?PushTextWrapPos@ImGui@@YAXM@Z:PROC		; ImGui::PushTextWrapPos
EXTRN	?PopTextWrapPos@ImGui@@YAXXZ:PROC		; ImGui::PopTextWrapPos
EXTRN	?SameLine@ImGui@@YAXMM@Z:PROC			; ImGui::SameLine
EXTRN	?Indent@ImGui@@YAXM@Z:PROC			; ImGui::Indent
EXTRN	?Unindent@ImGui@@YAXM@Z:PROC			; ImGui::Unindent
EXTRN	?BeginGroup@ImGui@@YAXXZ:PROC			; ImGui::BeginGroup
EXTRN	?EndGroup@ImGui@@YAXXZ:PROC			; ImGui::EndGroup
EXTRN	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ:PROC	; ImGui::GetCursorScreenPos
EXTRN	?SetCursorScreenPos@ImGui@@YAXABUImVec2@@@Z:PROC ; ImGui::SetCursorScreenPos
EXTRN	?GetTextLineHeight@ImGui@@YAMXZ:PROC		; ImGui::GetTextLineHeight
EXTRN	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ:PROC	; ImGui::GetTextLineHeightWithSpacing
EXTRN	?GetFrameHeight@ImGui@@YAMXZ:PROC		; ImGui::GetFrameHeight
EXTRN	?PushID@ImGui@@YAXPBD@Z:PROC			; ImGui::PushID
EXTRN	?PushID@ImGui@@YAXPBX@Z:PROC			; ImGui::PushID
EXTRN	?PushID@ImGui@@YAXH@Z:PROC			; ImGui::PushID
EXTRN	?PopID@ImGui@@YAXXZ:PROC			; ImGui::PopID
EXTRN	?GetID@ImGui@@YAIPBD@Z:PROC			; ImGui::GetID
EXTRN	?EndTooltip@ImGui@@YAXXZ:PROC			; ImGui::EndTooltip
EXTRN	?SetTooltip@ImGui@@YAXPBDZZ:PROC		; ImGui::SetTooltip
EXTRN	?OpenPopup@ImGui@@YAXPBD@Z:PROC			; ImGui::OpenPopup
EXTRN	?BeginPopup@ImGui@@YA_NPBDH@Z:PROC		; ImGui::BeginPopup
EXTRN	?EndPopup@ImGui@@YAXXZ:PROC			; ImGui::EndPopup
EXTRN	?OpenPopupOnItemClick@ImGui@@YA_NPBDH@Z:PROC	; ImGui::OpenPopupOnItemClick
EXTRN	?CloseCurrentPopup@ImGui@@YAXXZ:PROC		; ImGui::CloseCurrentPopup
EXTRN	?LogText@ImGui@@YAXPBDZZ:PROC			; ImGui::LogText
EXTRN	?BeginDragDropSource@ImGui@@YA_NH@Z:PROC	; ImGui::BeginDragDropSource
EXTRN	?SetDragDropPayload@ImGui@@YA_NPBDPBXIH@Z:PROC	; ImGui::SetDragDropPayload
EXTRN	?EndDragDropSource@ImGui@@YAXXZ:PROC		; ImGui::EndDragDropSource
EXTRN	?BeginDragDropTarget@ImGui@@YA_NXZ:PROC		; ImGui::BeginDragDropTarget
EXTRN	?AcceptDragDropPayload@ImGui@@YAPBUImGuiPayload@@PBDH@Z:PROC ; ImGui::AcceptDragDropPayload
EXTRN	?EndDragDropTarget@ImGui@@YAXXZ:PROC		; ImGui::EndDragDropTarget
EXTRN	?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z:PROC	; ImGui::PushClipRect
EXTRN	?PopClipRect@ImGui@@YAXXZ:PROC			; ImGui::PopClipRect
EXTRN	?SetItemDefaultFocus@ImGui@@YAXXZ:PROC		; ImGui::SetItemDefaultFocus
EXTRN	?IsItemHovered@ImGui@@YA_NH@Z:PROC		; ImGui::IsItemHovered
EXTRN	?IsItemActive@ImGui@@YA_NXZ:PROC		; ImGui::IsItemActive
EXTRN	?SetItemAllowOverlap@ImGui@@YAXXZ:PROC		; ImGui::SetItemAllowOverlap
EXTRN	?IsRectVisible@ImGui@@YA_NABUImVec2@@0@Z:PROC	; ImGui::IsRectVisible
EXTRN	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z:PROC ; ImGui::CalcTextSize
EXTRN	?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z:PROC ; ImGui::BeginChildFrame
EXTRN	?EndChildFrame@ImGui@@YAXXZ:PROC		; ImGui::EndChildFrame
EXTRN	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z:PROC ; ImGui::ColorConvertFloat4ToU32
EXTRN	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z:PROC	; ImGui::ColorConvertRGBtoHSV
EXTRN	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z:PROC	; ImGui::ColorConvertHSVtoRGB
EXTRN	?IsKeyPressed@ImGui@@YA_NH_N@Z:PROC		; ImGui::IsKeyPressed
EXTRN	?IsMouseClicked@ImGui@@YA_NH_N@Z:PROC		; ImGui::IsMouseClicked
EXTRN	?IsMouseReleased@ImGui@@YA_NH@Z:PROC		; ImGui::IsMouseReleased
EXTRN	?IsMousePosValid@ImGui@@YA_NPBUImVec2@@@Z:PROC	; ImGui::IsMousePosValid
EXTRN	?IsMouseDragging@ImGui@@YA_NHM@Z:PROC		; ImGui::IsMouseDragging
EXTRN	?SetMouseCursor@ImGui@@YAXH@Z:PROC		; ImGui::SetMouseCursor
EXTRN	?GetClipboardText@ImGui@@YAPBDXZ:PROC		; ImGui::GetClipboardText
EXTRN	?SetClipboardText@ImGui@@YAXPBD@Z:PROC		; ImGui::SetClipboardText
EXTRN	?MemAlloc@ImGui@@YAPAXI@Z:PROC			; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPAX@Z:PROC			; ImGui::MemFree
EXTRN	?append@ImGuiTextBuffer@@QAEXPBD0@Z:PROC	; ImGuiTextBuffer::append
EXTRN	?GetInt@ImGuiStorage@@QBEHIH@Z:PROC		; ImGuiStorage::GetInt
EXTRN	?SetInt@ImGuiStorage@@QAEXIH@Z:PROC		; ImGuiStorage::SetInt
EXTRN	?GetIntRef@ImGuiStorage@@QAEPAHIH@Z:PROC	; ImGuiStorage::GetIntRef
EXTRN	?Step@ImGuiListClipper@@QAE_NXZ:PROC		; ImGuiListClipper::Step
EXTRN	?Begin@ImGuiListClipper@@QAEXHM@Z:PROC		; ImGuiListClipper::Begin
EXTRN	?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z:PROC ; ImDrawListSplitter::Split
EXTRN	?Merge@ImDrawListSplitter@@QAEXPAUImDrawList@@@Z:PROC ; ImDrawListSplitter::Merge
EXTRN	?SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z:PROC ; ImDrawListSplitter::SetCurrentChannel
EXTRN	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z:PROC	; ImDrawList::AddLine
EXTRN	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z:PROC ; ImDrawList::AddRect
EXTRN	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z:PROC ; ImDrawList::AddRectFilled
EXTRN	?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z:PROC ; ImDrawList::AddRectFilledMultiColor
EXTRN	?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z:PROC ; ImDrawList::AddTriangle
EXTRN	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z:PROC ; ImDrawList::AddCircle
EXTRN	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z:PROC ; ImDrawList::AddCircleFilled
EXTRN	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z:PROC ; ImDrawList::AddText
EXTRN	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM@Z:PROC ; ImDrawList::AddPolyline
EXTRN	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI@Z:PROC ; ImDrawList::AddConvexPolyFilled
EXTRN	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z:PROC ; ImDrawList::AddImage
EXTRN	?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z:PROC ; ImDrawList::PathArcTo
EXTRN	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z:PROC ; ImDrawList::PathArcToFast
EXTRN	?PrimReserve@ImDrawList@@QAEXHH@Z:PROC		; ImDrawList::PrimReserve
EXTRN	?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z:PROC	; ImFont::FindGlyph
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	__imp__qsort:PROC
EXTRN	__imp__atof:PROC
EXTRN	_atan2:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_fmod:PROC
EXTRN	_pow:PROC
EXTRN	_sin:PROC
EXTRN	?ImHashStr@@YAIPBDII@Z:PROC			; ImHashStr
EXTRN	?ImStrncpy@@YAXPADPBDI@Z:PROC			; ImStrncpy
EXTRN	?ImStrbolW@@YAPBGPBG0@Z:PROC			; ImStrbolW
EXTRN	?ImStrTrimBlanks@@YAXPAD@Z:PROC			; ImStrTrimBlanks
EXTRN	?ImFormatString@@YAHPADIPBDZZ:PROC		; ImFormatString
EXTRN	?ImFormatStringV@@YAHPADIPBD0@Z:PROC		; ImFormatStringV
EXTRN	?ImTextStrToUtf8@@YAHPADHPBG1@Z:PROC		; ImTextStrToUtf8
EXTRN	?ImTextCharFromUtf8@@YAHPAIPBD1@Z:PROC		; ImTextCharFromUtf8
EXTRN	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z:PROC	; ImTextStrFromUtf8
EXTRN	?ImTextCountCharsFromUtf8@@YAHPBD0@Z:PROC	; ImTextCountCharsFromUtf8
EXTRN	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z:PROC	; ImTextCountUtf8BytesFromStr
EXTRN	?ImTriangleContainsPoint@@YA_NABUImVec2@@000@Z:PROC ; ImTriangleContainsPoint
EXTRN	?ImTriangleClosestPoint@@YA?AUImVec2@@ABU1@000@Z:PROC ; ImTriangleClosestPoint
EXTRN	?ImTriangleBarycentricCoords@@YAXABUImVec2@@000AAM11@Z:PROC ; ImTriangleBarycentricCoords
EXTRN	?GetID@ImGuiWindow@@QAEIPBD0@Z:PROC		; ImGuiWindow::GetID
EXTRN	?GetID@ImGuiWindow@@QAEIPBX@Z:PROC		; ImGuiWindow::GetID
EXTRN	?GetIDNoKeepAlive@ImGuiWindow@@QAEIPBD0@Z:PROC	; ImGuiWindow::GetIDNoKeepAlive
EXTRN	?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z:PROC ; ImGui::FindWindowByName
EXTRN	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z:PROC	; ImGui::FocusWindow
EXTRN	?FocusTopMostWindowUnderOne@ImGui@@YAXPAUImGuiWindow@@0@Z:PROC ; ImGui::FocusTopMostWindowUnderOne
EXTRN	?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PAUImGuiWindow@@@Z:PROC ; ImGui::CalcWindowExpectedSize
EXTRN	?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PAUImGuiWindow@@@Z:PROC ; ImGui::GetWindowAllowedExtentRect
EXTRN	?StartMouseMovingWindow@ImGui@@YAXPAUImGuiWindow@@@Z:PROC ; ImGui::StartMouseMovingWindow
EXTRN	?MarkIniSettingsDirty@ImGui@@YAXXZ:PROC		; ImGui::MarkIniSettingsDirty
EXTRN	?SetScrollY@ImGui@@YAXPAUImGuiWindow@@M@Z:PROC	; ImGui::SetScrollY
EXTRN	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z:PROC	; ImGui::SetActiveID
EXTRN	?SetFocusID@ImGui@@YAXIPAUImGuiWindow@@@Z:PROC	; ImGui::SetFocusID
EXTRN	?ClearActiveID@ImGui@@YAXXZ:PROC		; ImGui::ClearActiveID
EXTRN	?SetHoveredID@ImGui@@YAXI@Z:PROC		; ImGui::SetHoveredID
EXTRN	?KeepAliveID@ImGui@@YAXI@Z:PROC			; ImGui::KeepAliveID
EXTRN	?MarkItemEdited@ImGui@@YAXI@Z:PROC		; ImGui::MarkItemEdited
EXTRN	?PushOverrideID@ImGui@@YAXI@Z:PROC		; ImGui::PushOverrideID
EXTRN	?ItemSize@ImGui@@YAXABUImVec2@@M@Z:PROC		; ImGui::ItemSize
EXTRN	?ItemSize@ImGui@@YAXABUImRect@@M@Z:PROC		; ImGui::ItemSize
EXTRN	?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z:PROC	; ImGui::ItemAdd
EXTRN	?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z:PROC	; ImGui::ItemHoverable
EXTRN	?IsClippedEx@ImGui@@YA_NABUImRect@@I_N@Z:PROC	; ImGui::IsClippedEx
EXTRN	?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I@Z:PROC ; ImGui::FocusableItemRegister
EXTRN	?FocusableItemUnregister@ImGui@@YAXPAUImGuiWindow@@@Z:PROC ; ImGui::FocusableItemUnregister
EXTRN	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z:PROC	; ImGui::CalcItemSize
EXTRN	?CalcWrapWidthForPos@ImGui@@YAMABUImVec2@@M@Z:PROC ; ImGui::CalcWrapWidthForPos
EXTRN	?PushMultiItemsWidths@ImGui@@YAXHM@Z:PROC	; ImGui::PushMultiItemsWidths
EXTRN	?PushItemFlag@ImGui@@YAXH_N@Z:PROC		; ImGui::PushItemFlag
EXTRN	?PopItemFlag@ImGui@@YAXXZ:PROC			; ImGui::PopItemFlag
EXTRN	?OpenPopupEx@ImGui@@YAXI@Z:PROC			; ImGui::OpenPopupEx
EXTRN	?ClosePopupToLevel@ImGui@@YAXH_N@Z:PROC		; ImGui::ClosePopupToLevel
EXTRN	?IsPopupOpen@ImGui@@YA_NI@Z:PROC		; ImGui::IsPopupOpen
EXTRN	?BeginPopupEx@ImGui@@YA_NIH@Z:PROC		; ImGui::BeginPopupEx
EXTRN	?BeginTooltipEx@ImGui@@YAXH_N@Z:PROC		; ImGui::BeginTooltipEx
EXTRN	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@ABU2@0PAHABUImRect@@2W4ImGuiPopupPositionPolicy@@@Z:PROC ; ImGui::FindBestWindowPosForPopupEx
EXTRN	?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ:PROC ; ImGui::NavMoveRequestButNoResultYet
EXTRN	?NavMoveRequestCancel@ImGui@@YAXXZ:PROC		; ImGui::NavMoveRequestCancel
EXTRN	?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z:PROC ; ImGui::GetNavInputAmount
EXTRN	?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z:PROC ; ImGui::GetNavInputAmount2d
EXTRN	?CalcTypematicRepeatAmount@ImGui@@YAHMMMM@Z:PROC ; ImGui::CalcTypematicRepeatAmount
EXTRN	?SetNavID@ImGui@@YAXIH@Z:PROC			; ImGui::SetNavID
EXTRN	?SetNavIDWithRectRel@ImGui@@YAXIHABUImRect@@@Z:PROC ; ImGui::SetNavIDWithRectRel
EXTRN	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z:PROC	; ImGui::RenderText
EXTRN	?RenderTextWrapped@ImGui@@YAXUImVec2@@PBD1M@Z:PROC ; ImGui::RenderTextWrapped
EXTRN	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z:PROC ; ImGui::RenderTextClipped
EXTRN	?RenderTextClippedEx@ImGui@@YAXPAUImDrawList@@ABUImVec2@@1PBD2PBU3@1PBUImRect@@@Z:PROC ; ImGui::RenderTextClippedEx
EXTRN	?RenderTextEllipsis@ImGui@@YAXPAUImDrawList@@ABUImVec2@@1MMPBD2PBU3@@Z:PROC ; ImGui::RenderTextEllipsis
EXTRN	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z:PROC	; ImGui::RenderFrame
EXTRN	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z:PROC	; ImGui::RenderFrameBorder
EXTRN	?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z:PROC	; ImGui::RenderCheckMark
EXTRN	?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z:PROC ; ImGui::RenderNavHighlight
EXTRN	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z:PROC	; ImGui::FindRenderedTextEnd
EXTRN	?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z:PROC ; ImGui::LogRenderedText
EXTRN	?RenderArrow@ImGui@@YAXPAUImDrawList@@UImVec2@@IHM@Z:PROC ; ImGui::RenderArrow
EXTRN	?RenderBullet@ImGui@@YAXPAUImDrawList@@UImVec2@@I@Z:PROC ; ImGui::RenderBullet
EXTRN	?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z:PROC ; ImGui::RenderArrowPointingAt
EXTRN	?RenderRectFilledRangeH@ImGui@@YAXPAUImDrawList@@ABUImRect@@IMMM@Z:PROC ; ImGui::RenderRectFilledRangeH
EXTRN	?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPAUImDrawList@@HHUImVec2@@1II@Z:PROC ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
EXTRN	__dtol3:PROC
EXTRN	__dtoul3:PROC
EXTRN	__ftol2:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ftol3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__ftoul3:PROC
EXTRN	__ltod3:PROC
EXTRN	__ultod3:PROC
EXTRN	?GImGui@@3PAUImGuiContext@@A:DWORD		; GImGui
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@ffefffffffffffff
CONST	SEGMENT
__real@ffefffffffffffff DQ 0ffefffffffffffffr	; -1.79769e+308
CONST	ENDS
;	COMDAT __real@ffdfffffffffffff
CONST	SEGMENT
__real@ffdfffffffffffff DQ 0ffdfffffffffffffr	; -8.98847e+307
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+38
CONST	ENDS
;	COMDAT __real@feffffff
CONST	SEGMENT
__real@feffffff DD 0feffffffr			; -1.70141e+38
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c059000000000000
CONST	SEGMENT
__real@c059000000000000 DQ 0c059000000000000r	; -100
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf5db3d0
CONST	SEGMENT
__real@bf5db3d0 DD 0bf5db3d0r			; -0.866025
CONST	ENDS
;	COMDAT __real@bf400000
CONST	SEGMENT
__real@bf400000 DD 0bf400000r			; -0.75
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@be99999a
CONST	SEGMENT
__real@be99999a DD 0be99999ar			; -0.3
CONST	ENDS
;	COMDAT __real@7fefffffffffffff
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
CONST	ENDS
;	COMDAT __real@7fdfffffffffffff
CONST	SEGMENT
__real@7fdfffffffffffff DQ 07fdfffffffffffffr	; 8.98847e+307
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@7effffff
CONST	SEGMENT
__real@7effffff DD 07effffffr			; 1.70141e+38
CONST	ENDS
;	COMDAT __real@47efffffe0000000
CONST	SEGMENT
__real@47efffffe0000000 DQ 047efffffe0000000r	; 3.40282e+38
CONST	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+18
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@428c0000
CONST	SEGMENT
__real@428c0000 DD 0428c0000r			; 70
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40eccccd
CONST	SEGMENT
__real@40eccccd DD 040eccccdr			; 7.4
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40666666
CONST	SEGMENT
__real@40666666 DD 040666666r			; 3.6
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@403f5c29
CONST	SEGMENT
__real@403f5c29 DD 0403f5c29r			; 2.99
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb33333
CONST	SEGMENT
__real@3fb33333 DD 03fb33333r			; 1.4
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ff972
CONST	SEGMENT
__real@3f7ff972 DD 03f7ff972r			; 0.9999
CONST	ENDS
;	COMDAT __real@3f5db3d0
CONST	SEGMENT
__real@3f5db3d0 DD 03f5db3d0r			; 0.866025
CONST	ENDS
;	COMDAT __real@3f5db22d
CONST	SEGMENT
__real@3f5db22d DD 03f5db22dr			; 0.866
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f350481
CONST	SEGMENT
__real@3f350481 DD 03f350481r			; 0.7071
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3e09374c
CONST	SEGMENT
__real@3e09374c DD 03e09374cr			; 0.134
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3cdd2f1b
CONST	SEGMENT
__real@3cdd2f1b DD 03cdd2f1br			; 0.027
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-05
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-06
CONST	ENDS
;	COMDAT __real@00800000
CONST	SEGMENT
__real@00800000 DD 000800000r			; 1.17549e-38
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG@ DB 'p'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'f', 00H, '.', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'p', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'B', 00H, 'u', 00H, 'f', 00H, '.', 00H, 'D', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'B', 00H
	DB	'u', 00H, 'f', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@ DB 'i', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@ DB 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ DB 'i'
	DB	00H, 't', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, '+', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@NPHOAPAC@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1DO@NPHOAPAC@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ DB 'i'
	DB	00H, 't', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'S'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Columns@ImGui@@YAXHPBD_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Columns@ImGui@@YAXHPBD_N@Z@4JA DD 01dbdH ; `ImGui::Columns'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA DD 01d71H	; `ImGui::EndColumns'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn@
CONST	SEGMENT
??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'-', 00H, '>', 00H, 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA DD 01d3eH	; `ImGui::NextColumn'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'-', 00H, '>', 00H, 'I', 00H, 'D', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'i', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr@
CONST	SEGMENT
??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr@ DB 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H
	DB	'>', 00H, 'D', 00H, 'C', 00H, '.', 00H, 'C', 00H, 'u', 00H, 'r'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'C', 00H, 'o', 00H
	DB	'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO@
CONST	SEGMENT
??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPBDHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BeginColumns@ImGui@@YAXPBDHH@Z@4JA DD 01cf2H ; `ImGui::BeginColumns'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07HIFEPIJN@columns@
CONST	SEGMENT
??_C@_07HIFEPIJN@columns@ DB 'columns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@BKCOEDF@?$AAc?$AAm?$AAd?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAw?$AAi?$AAn@
CONST	SEGMENT
??_C@_1FK@BKCOEDF@?$AAc?$AAm?$AAd?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAw?$AAi?$AAn@ DB 'c'
	DB	00H, 'm', 00H, 'd', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H, '>', 00H
	DB	'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'L', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '-', 00H, '>', 00H, 'C', 00H, 'm', 00H, 'd', 00H
	DB	'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, '.'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??PushColumnsBackground@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??PushColumnsBackground@ImGui@@YAXXZ@4JA DD 01cc1H ; `ImGui::PushColumnsBackground'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA DD 01caaH ; `ImGui::SetColumnWidth'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA DD 01c94H ; `ImGui::SetColumnOffset'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5@
CONST	SEGMENT
??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H
	DB	'n', 00H, 's', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'l'
	DB	00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H, '.', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA DD 01c6aH ; `ImGui::GetColumnOffset'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc@ DB 'g'
	DB	00H, '.', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'e', 00H, 'I', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'I', 00H, 'D', 00H, ' ', 00H, '+'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'I', 00H, 'D', 00H, '(', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 'm', 00H, 'n', 00H, '_', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'x', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5@
CONST	SEGMENT
??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, '_', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z@4JA DD 01c59H ; `GetDraggedColumnOffset'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@HMBBPDPB@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf@
CONST	SEGMENT
??_C@_1BK@HMBBPDPB@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf@ DB 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z@4JA DD 01bddH ; `ImGui::TabItemBackground'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CI@FDDNDGMG@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAW?$AAa?$AAn?$AAt?$AAL?$AAa@
CONST	SEGMENT
??_C@_1CI@FDDNDGMG@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAW?$AAa?$AAn?$AAt?$AAL?$AAa@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, '_', 00H, 'b', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, '>', 00H, 'W', 00H, 'a', 00H, 'n', 00H, 't', 00H, 'L'
	DB	00H, 'a', 00H, 'y', 00H, 'o', 00H, 'u', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetTabItemClosed@ImGui@@YAXPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetTabItemClosed@ImGui@@YAXPBD@Z@4JA DD 01bc4H ; `ImGui::SetTabItemClosed'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04EBNJJJJI@?$CF?4?$CKs@
CONST	SEGMENT
??_C@_04EBNJJJJI@?$CF?4?$CKs@ DB '%.*s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@HGEILAOB@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAT?$AAa@
CONST	SEGMENT
??_C@_1DK@HGEILAOB@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAT?$AAa@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, '_', 00H, 'b', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, '>', 00H, 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'T'
	DB	00H, 'a', 00H, 'b', 00H, 'I', 00H, 't', 00H, 'e', 00H, 'm', 00H
	DB	'I', 00H, 'd', 00H, 'x', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1JI@HFPIFMIP@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@
CONST	SEGMENT
??_C@_1JI@HFPIFMIP@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, '_', 00H, 'b', 00H, 'a', 00H, 'r', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, '"', 00H, 'N', 00H, 'e', 00H, 'e', 00H
	DB	'd', 00H, 's', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'b'
	DB	00H, 'e', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 't', 00H, 'w'
	DB	00H, 'e', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'B', 00H, 'e', 00H
	DB	'g', 00H, 'i', 00H, 'n', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'B'
	DB	00H, 'a', 00H, 'r', 00H, '(', 00H, ')', 00H, ' ', 00H, 'a', 00H
	DB	'n', 00H, 'd', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'd', 00H, 'T'
	DB	00H, 'a', 00H, 'b', 00H, 'B', 00H, 'a', 00H, 'r', 00H, '(', 00H
	DB	')', 00H, '!', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EHILAJFJ@Needs?5to?5be?5called?5between?5Begi@
CONST	SEGMENT
??_C@_0DK@EHILAJFJ@Needs?5to?5be?5called?5between?5Begi@ DB 'Needs to be '
	DB	'called between BeginTabBar() and EndTabBar()!', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??EndTabItem@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??EndTabItem@ImGui@@YAXXZ@4JA DD 01ae9H	; `ImGui::EndTabItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1LA@GNEGANEK@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAB@
CONST	SEGMENT
??_C@_1LA@GNEGANEK@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAB@ DB '('
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, '_', 00H, 'b', 00H, 'a', 00H
	DB	'r', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"'
	DB	00H, 'B', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'T', 00H
	DB	'a', 00H, 'b', 00H, 'I', 00H, 't', 00H, 'e', 00H, 'm', 00H, '('
	DB	00H, ')', 00H, ' ', 00H, 'N', 00H, 'e', 00H, 'e', 00H, 'd', 00H
	DB	's', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'b', 00H, 'e'
	DB	00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 't', 00H, 'w', 00H, 'e'
	DB	00H, 'e', 00H, 'n', 00H, ' ', 00H, 'B', 00H, 'e', 00H, 'g', 00H
	DB	'i', 00H, 'n', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'B', 00H, 'a'
	DB	00H, 'r', 00H, '(', 00H, ')', 00H, ' ', 00H, 'a', 00H, 'n', 00H
	DB	'd', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'd', 00H, 'T', 00H, 'a'
	DB	00H, 'b', 00H, 'B', 00H, 'a', 00H, 'r', 00H, '(', 00H, ')', 00H
	DB	'!', 00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@BGGEHPHF@BeginTabItem?$CI?$CJ?5Needs?5to?5be?5call@
CONST	SEGMENT
??_C@_0EJ@BGGEHPHF@BeginTabItem?$CI?$CJ?5Needs?5to?5be?5call@ DB 'BeginTa'
	DB	'bItem() Needs to be called between BeginTabBar() and EndTabBa'
	DB	'r()!', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??BeginTabItem@ImGui@@YA_NPBDPA_NH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BeginTabItem@ImGui@@YA_NPBDPA_NH@Z@4JA DD 01ad3H ; `ImGui::BeginTabItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03CPFCAGPK@?$CD?$CDv@
CONST	SEGMENT
??_C@_03CPFCAGPK@?$CD?$CDv@ DB '##v', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHPCMDPH@?$CD?$CD?$DO@
CONST	SEGMENT
??_C@_03BHPCMDPH@?$CD?$CD?$DO@ DB '##>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFMEKBHF@?$CD?$CD?$DM@
CONST	SEGMENT
??_C@_03CFMEKBHF@?$CD?$CD?$DM@ DB '##<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@NGAACFPK@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAR?$AAe?$AAo?$AAr?$AAd?$AAe@
CONST	SEGMENT
??_C@_1EE@NGAACFPK@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAR?$AAe?$AAo?$AAr?$AAd?$AAe@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, '_', 00H, 'b', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, '>', 00H, 'R', 00H, 'e', 00H, 'o', 00H, 'r', 00H, 'd'
	DB	00H, 'e', 00H, 'r', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H
	DB	'e', 00H, 's', 00H, 't', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'I'
	DB	00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@FGAFEEBL@?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAi@
CONST	SEGMENT
??_C@_1CO@FGAFEEBL@?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAi@ DB 'd'
	DB	00H, 'i', 00H, 'r', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'-', 00H, '1', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'd'
	DB	00H, 'i', 00H, 'r', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'+', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z@4JA DD 01a63H ; `ImGui::TabBarQueueChangeTabOrder'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CE@HKABMAAD@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4@
CONST	SEGMENT
??_C@_1CE@HKABMAAD@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, '-', 00H, '>', 00H, 'W', 00H, 'i', 00H
	DB	'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, '.', 00H, '0', 00H, 'f', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@ODBMJKON@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAV@
CONST	SEGMENT
??_C@_1GG@ODBMJKON@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAV@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, '-', 00H, '>', 00H, 'L', 00H, 'a', 00H
	DB	's', 00H, 't', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e'
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 't', 00H, 'a'
	DB	00H, 'b', 00H, '_', 00H, 'b', 00H, 'a', 00H, 'r', 00H, '-', 00H
	DB	'>', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'F', 00H, 'r'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, 'V', 00H, 'i', 00H, 's', 00H
	DB	'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z@4JA DD 01966H ; `ImGui::TabBarLayout'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1HE@HMPOLDED@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5@
CONST	SEGMENT
??_C@_1HE@HMPOLDED@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5@ DB '('
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, '_', 00H, 'b', 00H, 'a', 00H
	DB	'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, ')'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'M', 00H
	DB	'i', 00H, 's', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, 'B', 00H, 'e', 00H, 'g', 00H
	DB	'i', 00H, 'n', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'B', 00H, 'a'
	DB	00H, 'r', 00H, '(', 00H, ')', 00H, '/', 00H, 'E', 00H, 'n', 00H
	DB	'd', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'B', 00H, 'a', 00H, 'r'
	DB	00H, '(', 00H, ')', 00H, '!', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DPIPLNLI@Mismatched?5BeginTabBar?$CI?$CJ?1EndTab@
CONST	SEGMENT
??_C@_0CG@DPIPLNLI@Mismatched?5BeginTabBar?$CI?$CJ?1EndTab@ DB 'Mismatche'
	DB	'd BeginTabBar()/EndTabBar()!', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??EndTabBar@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??EndTabBar@ImGui@@YAXXZ@4JA DD 01946H	; `ImGui::EndTabBar'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z@4JA DD 01912H ; `ImGui::BeginTabBarEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@
CONST	SEGMENT
??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@ DB '##MainMenuBar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@HJHPMKIH@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn?$AAu@
CONST	SEGMENT
??_C@_1DI@HJHPMKIH@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn?$AAu@ DB 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H
	DB	'>', 00H, 'D', 00H, 'C', 00H, '.', 00H, 'M', 00H, 'e', 00H, 'n'
	DB	00H, 'u', 00H, 'B', 00H, 'a', 00H, 'r', 00H, 'A', 00H, 'p', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@MMAFNJJP@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1FC@MMAFNJJP@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG@ DB 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H
	DB	'>', 00H, 'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' '
	DB	00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H
	DB	'i', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H
	DB	'M', 00H, 'e', 00H, 'n', 00H, 'u', 00H, 'B', 00H, 'a', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@NKCHGHAD@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAN?$AAa?$AAv?$AAL@
CONST	SEGMENT
??_C@_1GC@NKCHGHAD@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAN?$AAa?$AAv?$AAL@ DB 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H
	DB	'>', 00H, 'D', 00H, 'C', 00H, '.', 00H, 'N', 00H, 'a', 00H, 'v'
	DB	00H, 'L', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, 'A', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'M', 00H, 'a'
	DB	00H, 's', 00H, 'k', 00H, 'N', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, '(', 00H, '1', 00H, ' ', 00H, '<'
	DB	00H, '<', 00H, ' ', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H
	DB	'r', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??EndMenuBar@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??EndMenuBar@ImGui@@YAXXZ@4JA DD 0179cH	; `ImGui::EndMenuBar'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09FHPMMDGK@?$CD?$CDmenubar@
CONST	SEGMENT
??_C@_09FHPMMDGK@?$CD?$CDmenubar@ DB '##menubar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@MIADNLCN@?$AA?$CB?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn@
CONST	SEGMENT
??_C@_1DK@MIADNLCN@?$AA?$CB?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn@ DB '!'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	'-', 00H, '>', 00H, 'D', 00H, 'C', 00H, '.', 00H, 'M', 00H, 'e'
	DB	00H, 'n', 00H, 'u', 00H, 'B', 00H, 'a', 00H, 'r', 00H, 'A', 00H
	DB	'p', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??BeginMenuBar@ImGui@@YA_NXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BeginMenuBar@ImGui@@YA_NXZ@4JA DD 01780H ; `ImGui::BeginMenuBar'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FK@BNPKANMO@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ@
CONST	SEGMENT
??_C@_1FK@BNPKANMO@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ@ DB 'c'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '(', 00H, '(', 00H, 'i', 00H, 'n', 00H, 't'
	DB	00H, ')', 00H, '(', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'o', 00H, 'f', 00H, '(', 00H, 'P', 00H, 'o', 00H, 's', 00H, ')'
	DB	00H, ' ', 00H, '/', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, '*', 00H, 'P', 00H, 'o'
	DB	00H, 's', 00H, ')', 00H, ')', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Update@ImGuiMenuColumns@@QAEXHM_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Update@ImGuiMenuColumns@@QAEXHM_N@Z@4JA DD 0175aH ; `ImGuiMenuColumns::Update'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@
CONST	SEGMENT
??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@ DB '%s: %.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@
CONST	SEGMENT
??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@ DB '%%s: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GBEGMGE@?$CFs?3?5?$CFd@
CONST	SEGMENT
??_C@_06GBEGMGE@?$CFs?3?5?$CFd@ DB '%s: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DJHOIPC@?$CFs?3?5?$CFs@
CONST	SEGMENT
??_C@_06DJHOIPC@?$CFs?3?5?$CFs@ DB '%s: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@JIGPMMPH@?$AAv?$AA1?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1EK@JIGPMMPH@?$AAv?$AA1?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB 'v'
	DB	00H, '1', 00H, '_', 00H, 'i', 00H, 'd', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'v', 00H, '1', 00H, '_', 00H, 'i', 00H, 'd', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l'
	DB	00H, 'u', 00H, 'e', 00H, 's', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@
CONST	SEGMENT
??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@ DB '%d: %8.4g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@
CONST	SEGMENT
??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@ DB '%d: %8.4g', 0aH
	DB	'%d: %8.4g', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@HCGMCBDC@?$AAv?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv@
CONST	SEGMENT
??_C@_1EG@HCGMCBDC@?$AAv?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv@ DB 'v'
	DB	00H, '_', 00H, 'i', 00H, 'd', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'v', 00H, '_', 00H, 'i', 00H, 'd', 00H, 'x', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e'
	DB	00H, 's', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z@4JA DD 0168aH ; `ImGui::PlotEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@KOOPJPAL@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk@
CONST	SEGMENT
??_C@_1DC@KOOPJPAL@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk@ DB 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '-', 00H
	DB	'>', 00H, 'I', 00H, 'D', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TreePop@ImGui@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TreePop@ImGui@@YAXXZ@4JA DD 0152aH	; `ImGui::TreePop'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09GHACPMKF@?$CDTreePush@
CONST	SEGMENT
??_C@_09GHACPMKF@?$CDTreePush@ DB '#TreePush', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEBMKJDF@?$CD?$CD@
CONST	SEGMENT
??_C@_02IEBMKJDF@?$CD?$CD@ DB '##', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DFKEEPFP@?6?$CD?$CD@
CONST	SEGMENT
??_C@_03DFKEEPFP@?6?$CD?$CD@ DB 0aH, '##', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KEDLMDJL@Alpha?5Bar@
CONST	SEGMENT
??_C@_09KEDLMDJL@Alpha?5Bar@ DB 'Alpha Bar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KNMNNHNH@?$CD?$CDdummypicker@
CONST	SEGMENT
??_C@_0O@KNMNNHNH@?$CD?$CDdummypicker@ DB '##dummypicker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFBFGFJL@?$CD?$CDselectable@
CONST	SEGMENT
??_C@_0N@KFBFGFJL@?$CD?$CDselectable@ DB '##selectable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@ DB '0x%02X%02X%02X%02X'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@ DB '0x%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@
CONST	SEGMENT
??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@ DB '(%d,%d,%d,%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@
CONST	SEGMENT
??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@ DB '('
	DB	'%.3ff, %.3ff, %.3ff, %.3ff)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPMHGHMB@Copy@
CONST	SEGMENT
??_C@_04OPMHGHMB@Copy@ DB 'Copy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMCCFHEI@Copy?5as?4?4@
CONST	SEGMENT
??_C@_09NMCCFHEI@Copy?5as?4?4@ DB 'Copy as..', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDNPBJBM@0?400?4?41?400@
CONST	SEGMENT
??_C@_0L@MDNPBJBM@0?400?4?41?400@ DB '0.00..1.00', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDBEKFBH@0?4?4255@
CONST	SEGMENT
??_C@_06FDBEKFBH@0?4?4255@ DB '0..255', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJOBKKAE@Hex@
CONST	SEGMENT
??_C@_03CJOBKKAE@Hex@ DB 'Hex', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CAADKAK@HSV@
CONST	SEGMENT
??_C@_03CAADKAK@HSV@ DB 'HSV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICFFBAI@RGB@
CONST	SEGMENT
??_C@_03ICFFBAI@RGB@ DB 'RGB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@
CONST	SEGMENT
??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@ DB 'H'
	DB	': %.3f, S: %.3f, V: %.3f, A: %.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@
CONST	SEGMENT
??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@ DB 'H'
	DB	': %.3f, S: %.3f, V: %.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@
CONST	SEGMENT
??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@ DB '#'
	DB	'%02X%02X%02X%02X', 0aH, 'R:%d, G:%d, B:%d, A:%d', 0aH, '(%.3f'
	DB	', %.3f, %.3f, %.3f)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@
CONST	SEGMENT
??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@ DB '#'
	DB	'%02X%02X%02X', 0aH, 'R: %d, G: %d, B: %d', 0aH, '(%.3f, %.3f,'
	DB	' %.3f)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCCDBEFL@?$CD?$CDpreview@
CONST	SEGMENT
??_C@_09JCCDBEFL@?$CD?$CDpreview@ DB '##preview', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@ECJOEGME@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
CONST	SEGMENT
??_C@_1HE@ECJOEGME@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ DB 'I'
	DB	00H, 'm', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, 'O', 00H, 'f', 00H, 'T', 00H, 'w', 00H, 'o'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'r', 00H
	DB	'E', 00H, 'd', 00H, 'i', 00H, 't', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, '_', 00H, '_', 00H, 'D', 00H, 'a', 00H
	DB	't', 00H, 'a', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'M'
	DB	00H, 'a', 00H, 's', 00H, 'k', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetColorEditOptions@ImGui@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetColorEditOptions@ImGui@@YAXH@Z@4JA DD 0133eH ; `ImGui::SetColorEditOptions'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05PDOBBJNA@Color@
CONST	SEGMENT
??_C@_05PDOBBJNA@Color@ DB 'Color', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BOAMFJMJ@?$CD?$CDhex@
CONST	SEGMENT
??_C@_05BOAMFJMJ@?$CD?$CDhex@ DB '##hex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JICEKLIF@?$CD?$CDhsv@
CONST	SEGMENT
??_C@_05JICEKLIF@?$CD?$CDhsv@ DB '##hsv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCABMAIH@?$CD?$CDrgb@
CONST	SEGMENT
??_C@_05JCABMAIH@?$CD?$CDrgb@ DB '##rgb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@
CONST	SEGMENT
??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@ DB '##original', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DCPBJHAO@Original@
CONST	SEGMENT
??_C@_08DCPBJHAO@Original@ DB 'Original', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CDENILGE@?$CD?$CDcurrent@
CONST	SEGMENT
??_C@_09CDENILGE@?$CD?$CDcurrent@ DB '##current', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EDIFFIJI@Current@
CONST	SEGMENT
??_C@_07EDIFFIJI@Current@ DB 'Current', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAEKHIAN@alpha@
CONST	SEGMENT
??_C@_05IAEKHIAN@alpha@ DB 'alpha', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GKJJMKFG@hue@
CONST	SEGMENT
??_C@_03GKJJMKFG@hue@ DB 'hue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CPGMCOJE@sv@
CONST	SEGMENT
??_C@_02CPGMCOJE@sv@ DB 'sv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PPLPHHG@hsv@
CONST	SEGMENT
??_C@_03PPLPHHG@hsv@ DB 'hsv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@IEGAFBEB@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
CONST	SEGMENT
??_C@_1HA@IEGAFBEB@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ DB 'I'
	DB	00H, 'm', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, 'O', 00H, 'f', 00H, 'T', 00H, 'w', 00H, 'o'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'r', 00H
	DB	'E', 00H, 'd', 00H, 'i', 00H, 't', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, '_', 00H, '_', 00H, 'P', 00H, 'i', 00H
	DB	'c', 00H, 'k', 00H, 'e', 00H, 'r', 00H, 'M', 00H, 'a', 00H, 's'
	DB	00H, 'k', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z@4JA DD 01181H ; `ImGui::ColorPicker4'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06LAOCEMMP@_COL4F@
CONST	SEGMENT
??_C@_06LAOCEMMP@_COL4F@ DB '_COL4F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LFKNFKEK@_COL3F@
CONST	SEGMENT
??_C@_06LFKNFKEK@_COL3F@ DB '_COL3F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HHEANBBL@?$CD?$CDpicker@
CONST	SEGMENT
??_C@_08HHEANBBL@?$CD?$CDpicker@ DB '##picker', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAKAMBBI@picker@
CONST	SEGMENT
??_C@_06MAKAMBBI@picker@ DB 'picker', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@
CONST	SEGMENT
??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@ DB '##ColorButton', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@ DB '%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@ DB '%02X%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNCEJPDI@?$CD?$CDText@
CONST	SEGMENT
??_C@_06MNCEJPDI@?$CD?$CDText@ DB '##Text', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@ DB '#%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@ DB '#%02X%02X%02X%02'
	DB	'X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKKCBBMM@context@
CONST	SEGMENT
??_C@_07JKKCBBMM@context@ DB 'context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNGMMMAL@M?3000@
CONST	SEGMENT
??_C@_05BNGMMMAL@M?3000@ DB 'M:000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFNLLALM@M?30?4000@
CONST	SEGMENT
??_C@_07FFNLLALM@M?30?4000@ DB 'M:0.000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@CDHIBPHM@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
CONST	SEGMENT
??_C@_1GO@CDHIBPHM@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ DB 'I'
	DB	00H, 'm', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, 'O', 00H, 'f', 00H, 'T', 00H, 'w', 00H, 'o'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'r', 00H
	DB	'E', 00H, 'd', 00H, 'i', 00H, 't', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, '_', 00H, '_', 00H, 'I', 00H, 'n', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, 'M', 00H, 'a', 00H, 's', 00H, 'k'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HC@IFIJNDDD@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
CONST	SEGMENT
??_C@_1HC@IFIJNDDD@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ DB 'I'
	DB	00H, 'm', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, 'O', 00H, 'f', 00H, 'T', 00H, 'w', 00H, 'o'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'r', 00H
	DB	'E', 00H, 'd', 00H, 'i', 00H, 't', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, '_', 00H, '_', 00H, 'D', 00H, 'i', 00H
	DB	's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'M', 00H, 'a'
	DB	00H, 's', 00H, 'k', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4JA DD 01055H ; `ImGui::ColorEdit4'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EE@MOOHJKEO@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@
CONST	SEGMENT
??_C@_1EE@MOOHJKEO@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@ DB 'a'
	DB	00H, 'p', 00H, 'p', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'n', 00H
	DB	'e', 00H, 'w', 00H, '_', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'b', 00H, 'u'
	DB	00H, 'f', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@CHDFECEK@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@
CONST	SEGMENT
??_C@_1DG@CHDFECEK@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@ DB 'a'
	DB	00H, 'p', 00H, 'p', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'n', 00H
	DB	'e', 00H, 'w', 00H, '_', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@EHLBBEIB@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@
CONST	SEGMENT
??_C@_1HG@EHLBBEIB@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@ DB 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, '_', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.'
	DB	00H, 'B', 00H, 'u', 00H, 'f', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'L', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, 'i', 00H, 'n', 00H, 't', 00H, ')', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'l', 00H, 'e', 00H, 'n', 00H, '('
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, '_', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a'
	DB	00H, '.', 00H, 'B', 00H, 'u', 00H, 'f', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@HOPDKFNI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAF@
CONST	SEGMENT
??_C@_1DK@HOPDKFNI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAF@ DB 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, '_', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.'
	DB	00H, 'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g'
	DB	00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@GDPCIOA@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@
CONST	SEGMENT
??_C@_1FK@GDPCIOA@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@ DB 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, '_', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.'
	DB	00H, 'B', 00H, 'u', 00H, 'f', 00H, 'S', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>', 00H, 'B', 00H
	DB	'u', 00H, 'f', 00H, 'C', 00H, 'a', 00H, 'p', 00H, 'a', 00H, 'c'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 'A', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@GEAEFBFI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@
CONST	SEGMENT
??_C@_1EO@GEAEFBFI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@ DB 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, '_', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.'
	DB	00H, 'B', 00H, 'u', 00H, 'f', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'A', 00H
	DB	'.', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FOPGMADN@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BG@FOPGMADN@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NI@EFFIGGBI@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AA_?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1NI@EFFIGGBI@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AA_?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO@ DB 'p'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, 'w', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, '_', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H, '-'
	DB	00H, '>', 00H, 'G', 00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h', 00H
	DB	's', 00H, '.', 00H, 'e', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'p', 00H, 'a', 00H, 's', 00H, 's', 00H, 'w', 00H, 'o', 00H, 'r'
	DB	00H, 'd', 00H, '_', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H
	DB	'-', 00H, '>', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x'
	DB	00H, 'A', 00H, 'd', 00H, 'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H
	DB	'e', 00H, 'X', 00H, '.', 00H, 'e', 00H, 'm', 00H, 'p', 00H, 't'
	DB	00H, 'y', 00H, '(', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'p', 00H, 'a', 00H, 's', 00H, 's', 00H, 'w', 00H, 'o'
	DB	00H, 'r', 00H, 'd', 00H, '_', 00H, 'f', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, '-', 00H, '>', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e'
	DB	00H, 'x', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'k', 00H, 'u', 00H
	DB	'p', 00H, '.', 00H, 'e', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y'
	DB	00H, '(', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@CMKEKNGP@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@
CONST	SEGMENT
??_C@_1DC@CMKEKNGP@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@ DB 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '-', 00H, '>', 00H, 'I', 00H, 'D', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'i', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CBGPMFEC@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BM@CBGPMFEC@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@MGOPIKJM@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@
CONST	SEGMENT
??_C@_1MG@MGOPIKJM@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@ DB '!'
	DB	00H, '(', 00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H
	DB	's', 00H, ' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G'
	DB	00H, 'u', 00H, 'i', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'C', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, ')', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H
	DB	's', 00H, ' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G'
	DB	00H, 'u', 00H, 'i', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'A', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'w', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'I'
	DB	00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, ')', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1LI@BDNHGOFF@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@
CONST	SEGMENT
??_C@_1LI@BDNHGOFF@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@ DB '!'
	DB	00H, '(', 00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H
	DB	's', 00H, ' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G'
	DB	00H, 'u', 00H, 'i', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'C', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'H'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '(', 00H, 'f'
	DB	00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, '&', 00H
	DB	' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H, 'I'
	DB	00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, 'T', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's'
	DB	00H, '_', 00H, 'M', 00H, 'u', 00H, 'l', 00H, 't', 00H, 'i', 00H
	DB	'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, ')', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA DD 0d47H ; `ImGui::InputTextEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DM@LDGOBGNL@?$AAB?$AAu?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa@
CONST	SEGMENT
??_C@_1DM@LDGOBGNL@?$AAB?$AAu?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa@ DB 'B'
	DB	00H, 'u', 00H, 'f', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'e', 00H, 'd', 00H, 'i', 00H, 't', 00H, '_', 00H, 's', 00H, 't'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>', 00H, 'T', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, 'A', 00H, '.', 00H, 'D', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@EFFMAEBL@?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5@
CONST	SEGMENT
??_C@_1GI@EFFMAEBL@?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5@ DB 'e'
	DB	00H, 'd', 00H, 'i', 00H, 't', 00H, '_', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>', 00H, 'I', 00H, 'D'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'g', 00H, '.', 00H, 'A', 00H, 'c'
	DB	00H, 't', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'I', 00H, 'd', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'e', 00H, 'd', 00H, 'i'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, '-', 00H, '>', 00H, 'I', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z@4JA DD 0cd9H ; `ImGuiInputTextCallbackData::InsertChars'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EA@OOMMGKHM@?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAc?$AAo?$AAu@
CONST	SEGMENT
??_C@_1EA@OOMMGKHM@?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAc?$AAo?$AAu@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'b', 00H
	DB	'y', 00H, 't', 00H, 'e', 00H, 's', 00H, '_', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'T', 00H, 'e', 00H, 'x'
	DB	00H, 't', 00H, 'L', 00H, 'e', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z@4JA DD 0cc7H ; `ImGuiInputTextCallbackData::DeleteChars'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1JE@JEJNCKKO@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@
CONST	SEGMENT
??_C@_1JE@JEJNCKKO@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@ DB '('
	DB	00H, '(', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '*', 00H
	DB	')', 00H, '(', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '-', 00H, '>', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'_', 00H, 'r', 00H, 'e', 00H, 'c', 00H, ' ', 00H, '+', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'r', 00H, 'e', 00H, 'd', 00H, 'o', 00H, '_', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, '1', 00H, ')', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'm'
	DB	00H, 'o', 00H, 'v', 00H, 'e', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ')', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, 'b', 00H, 'u', 00H, 'f', 00H, '_', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HI@OHEJKGLD@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@
CONST	SEGMENT
??_C@_1HI@OHEJKGLD@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@ DB '('
	DB	00H, '(', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '*', 00H
	DB	')', 00H, '(', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '-', 00H, '>', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'_', 00H, 'r', 00H, 'e', 00H, 'c', 00H, ' ', 00H, '+', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'r', 00H, 'e', 00H, 'd', 00H, 'o', 00H, '_', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, '_', 00H, 'b', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1LE@DPFBMFBF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LE@DPFBMFBF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 's', 00H, 't', 00H, 'b', 00H, '_'
	DB	00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'i', 00H, 't', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@2@@Z@4JA DD 0461H ; `ImStb::stb_textedit_discard_redo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DG@IEAPMEMO@?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAo?$AAb?$AAj?$AA?9@
CONST	SEGMENT
??_C@_1DG@IEAPMEMO@?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAo?$AAb?$AAj?$AA?9@ DB 't'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, '_', 00H, 'l', 00H, 'e', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'o', 00H, 'b', 00H, 'j'
	DB	00H, '-', 00H, '>', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'W', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@MNHDBBDP@?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn@
CONST	SEGMENT
??_C@_1CA@MNHDBBDP@?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'e', 00H, 'x', 00H, 't', 00H, '_', 00H, 'l', 00H, 'e'
	DB	00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z@4JA DD 0c83H ; `ImStb::STB_TEXTEDIT_INSERTCHARS'::`1'::__LINE__Var
_DATA	ENDS
_DATA	SEGMENT
?STB_TEXTEDIT_NEWLINE@ImStb@@3GA DW 0aH			; ImStb::STB_TEXTEDIT_NEWLINE
	ORG $+2
?ids@?BL@??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4PAPBDA DD FLAT:??_C@_03CEFFAPNG@?$CD?$CDX@ ; `ImGui::ColorEdit4'::`27'::ids
	DD	FLAT:??_C@_03DNEODOJH@?$CD?$CDY@
	DD	FLAT:??_C@_03BGGDGNFE@?$CD?$CDZ@
	DD	FLAT:??_C@_03KDMNBDBJ@?$CD?$CDW@
?fmt_table_int@?BL@??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4PAY03PBDA DD FLAT:??_C@_03GOOLIKIF@?$CF3d@ ; `ImGui::ColorEdit4'::`27'::fmt_table_int
	DD	FLAT:??_C@_03GOOLIKIF@?$CF3d@
	DD	FLAT:??_C@_03GOOLIKIF@?$CF3d@
	DD	FLAT:??_C@_03GOOLIKIF@?$CF3d@
	DD	FLAT:??_C@_05FELKPNOB@R?3?$CF3d@
	DD	FLAT:??_C@_05HKBGOMJ@G?3?$CF3d@
	DD	FLAT:??_C@_05FHGMPPHK@B?3?$CF3d@
	DD	FLAT:??_C@_05NBPIINNE@A?3?$CF3d@
	DD	FLAT:??_C@_05PGPHNMBM@H?3?$CF3d@
	DD	FLAT:??_C@_05JPOGCOEE@S?3?$CF3d@
	DD	FLAT:??_C@_05MPCLLPPH@V?3?$CF3d@
	DD	FLAT:??_C@_05NBPIINNE@A?3?$CF3d@
?fmt_table_float@?BL@??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4PAY03PBDA DD FLAT:??_C@_05ONBKDNLK@?$CF0?43f@ ; `ImGui::ColorEdit4'::`27'::fmt_table_float
	DD	FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	DD	FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	DD	FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	DD	FLAT:??_C@_07CCOKENNH@R?3?$CF0?43f@
	DD	FLAT:??_C@_07BGLBHCJI@G?3?$CF0?43f@
	DD	FLAT:??_C@_07FOFBHMPM@B?3?$CF0?43f@
	DD	FLAT:??_C@_07NANOHLBP@A?3?$CF0?43f@
	DD	FLAT:??_C@_07MPJBGADE@H?3?$CF0?43f@
	DD	FLAT:??_C@_07OOEAENEJ@S?3?$CF0?43f@
	DD	FLAT:??_C@_07KGKAEDCN@V?3?$CF0?43f@
	DD	FLAT:??_C@_07NANOHLBP@A?3?$CF0?43f@
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA DD 0c11H ; `ImGui::InputTextWithHint'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FC@IFNBIILP@?$AA?$CB?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi@
CONST	SEGMENT
??_C@_1FC@IFNBIILP@?$AA?$CB?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi@ DB '!'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, '_', 00H, 'M', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA DD 0c06H ; `ImGui::InputText'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04JIMNDDED@?$CF08X@
CONST	SEGMENT
??_C@_04JIMNDDED@?$CF08X@ DB '%08X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
CONST	SEGMENT
??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@ DB '%%.%df', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL@ DB '+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@LLIJAMKA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1CC@LLIJAMKA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi@ DB 'g'
	DB	00H, '.', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'e', 00H, 'I', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'i', 00H, 'd', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z@4JA DD 0b19H ; `ImGui::TempInputTextScalar'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08FKIHKODH@?$CF?40f?5deg@
CONST	SEGMENT
??_C@_08FKIHKODH@?$CF?40f?5deg@ DB '%.0f deg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1OA@OEHGOKMN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$CK@
CONST	SEGMENT
??_C@_1OA@OEHGOKMN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$CK@ DB '*'
	DB	00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'o', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, '*', 00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'i', 00H
	DB	'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '-', 00H, '1'
	DB	00H, '.', 00H, '7', 00H, '9', 00H, '7', 00H, '6', 00H, '9', 00H
	DB	'3', 00H, '1', 00H, '3', 00H, '4', 00H, '8', 00H, '6', 00H, '2'
	DB	00H, '3', 00H, '1', 00H, '5', 00H, '8', 00H, 'e', 00H, '+', 00H
	DB	'3', 00H, '0', 00H, '8', 00H, '/', 00H, '2', 00H, '.', 00H, '0'
	DB	00H, 'f', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '*', 00H
	DB	'(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, ' '
	DB	00H, 'd', 00H, 'o', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'*', 00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'x'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '1', 00H, '.', 00H
	DB	'7', 00H, '9', 00H, '7', 00H, '6', 00H, '9', 00H, '3', 00H, '1'
	DB	00H, '3', 00H, '4', 00H, '8', 00H, '6', 00H, '2', 00H, '3', 00H
	DB	'1', 00H, '5', 00H, '8', 00H, 'e', 00H, '+', 00H, '3', 00H, '0'
	DB	00H, '8', 00H, '/', 00H, '2', 00H, '.', 00H, '0', 00H, 'f', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@ELIKKGKL@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$CK?$AA?$CJ@
CONST	SEGMENT
??_C@_1MA@ELIKKGKL@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$CK?$AA?$CJ@ DB '*'
	DB	00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'f', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, '*'
	DB	00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '-', 00H, '3', 00H, '.'
	DB	00H, '4', 00H, '0', 00H, '2', 00H, '8', 00H, '2', 00H, '3', 00H
	DB	'4', 00H, '6', 00H, '6', 00H, 'e', 00H, '+', 00H, '3', 00H, '8'
	DB	00H, 'F', 00H, '/', 00H, '2', 00H, '.', 00H, '0', 00H, 'f', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '*', 00H, '(', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, ' ', 00H, 'f', 00H
	DB	'l', 00H, 'o', 00H, 'a', 00H, 't', 00H, '*', 00H, ')', 00H, 'p'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '3', 00H, '.', 00H, '4', 00H, '0', 00H, '2'
	DB	00H, '8', 00H, '2', 00H, '3', 00H, '4', 00H, '6', 00H, '6', 00H
	DB	'e', 00H, '+', 00H, '3', 00H, '8', 00H, 'F', 00H, '/', 00H, '2'
	DB	00H, '.', 00H, '0', 00H, 'f', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@CBABBPPD@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA6?$AA4?$AA?$CK?$AA?$CJ@
CONST	SEGMENT
??_C@_1EK@CBABBPPD@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA6?$AA4?$AA?$CK?$AA?$CJ@ DB '*'
	DB	00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'I', 00H, 'm', 00H, 'U', 00H, '6', 00H, '4', 00H, '*'
	DB	00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'x', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'M', 00H, '_'
	DB	00H, 'U', 00H, '6', 00H, '4', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'X', 00H, '/', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1JK@NOHGLDJN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA6?$AA4?$AA?$CK?$AA?$CJ@
CONST	SEGMENT
??_C@_1JK@NOHGLDJN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA6?$AA4?$AA?$CK?$AA?$CJ@ DB '*'
	DB	00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'I', 00H, 'm', 00H, 'S', 00H, '6', 00H, '4', 00H, '*'
	DB	00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'M', 00H, '_'
	DB	00H, 'S', 00H, '6', 00H, '4', 00H, '_', 00H, 'M', 00H, 'I', 00H
	DB	'N', 00H, '/', 00H, '2', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '*', 00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'S', 00H, '6', 00H, '4'
	DB	00H, '*', 00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'a', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'M'
	DB	00H, '_', 00H, 'S', 00H, '6', 00H, '4', 00H, '_', 00H, 'M', 00H
	DB	'A', 00H, 'X', 00H, '/', 00H, '2', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@CNKAEFCM@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA3?$AA2?$AA?$CK?$AA?$CJ@
CONST	SEGMENT
??_C@_1EK@CNKAEFCM@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA3?$AA2?$AA?$CK?$AA?$CJ@ DB '*'
	DB	00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'I', 00H, 'm', 00H, 'U', 00H, '3', 00H, '2', 00H, '*'
	DB	00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'x', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'M', 00H, '_'
	DB	00H, 'U', 00H, '3', 00H, '2', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'X', 00H, '/', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1JK@KBPJHMJO@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA3?$AA2?$AA?$CK?$AA?$CJ@
CONST	SEGMENT
??_C@_1JK@KBPJHMJO@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA3?$AA2?$AA?$CK?$AA?$CJ@ DB '*'
	DB	00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'I', 00H, 'm', 00H, 'S', 00H, '3', 00H, '2', 00H, '*'
	DB	00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'M', 00H, '_'
	DB	00H, 'S', 00H, '3', 00H, '2', 00H, '_', 00H, 'M', 00H, 'I', 00H
	DB	'N', 00H, '/', 00H, '2', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '*', 00H, '(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H
	DB	't', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'S', 00H, '3', 00H, '2'
	DB	00H, '*', 00H, ')', 00H, 'p', 00H, '_', 00H, 'm', 00H, 'a', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'I', 00H, 'M'
	DB	00H, '_', 00H, 'S', 00H, '3', 00H, '2', 00H, '_', 00H, 'M', 00H
	DB	'A', 00H, 'X', 00H, '/', 00H, '2', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA DD 09b1H ; `ImGui::SliderBehavior'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05CONLABCH@?$CD?$CDmax@
CONST	SEGMENT
??_C@_05CONLABCH@?$CD?$CDmax@ DB '##max', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMFAOFEI@?$CD?$CDmin@
CONST	SEGMENT
??_C@_05DMFAOFEI@?$CD?$CDmin@ DB '##min', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@IAANKGPJ@?$AAp?$AA_?$AAm?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp@
CONST	SEGMENT
??_C@_1DC@IAANKGPJ@?$AAp?$AA_?$AAm?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp@ DB 'p'
	DB	00H, '_', 00H, 'm', 00H, 'i', 00H, 'n', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'p', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'x', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z@4JA DD 080dH ; `ImGui::DragScalar'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z@4JA DD 07ecH ; `ImGui::DragBehavior'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EO@OEMFLDEM@?$AAt?$AAy?$AAp?$AAe?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1EO@OEMFLDEM@?$AAt?$AAy?$AAp?$AAe?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe@ DB 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'i', 00H, 'n', 00H
	DB	'f', 00H, 'o', 00H, '-', 00H, '>', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'b', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, 'u', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@ILBKEPMO@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5?$AAI?$AAm?$AAG@
CONST	SEGMENT
??_C@_1EA@ILBKEPMO@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5?$AAI?$AAm?$AAG@ DB 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, 'D', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'C'
	DB	00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z@4JA DD 06e0H ; `ImGui::DataTypeApplyOpFromText'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CO@LEDHMGOL@?$AAo?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AA?$CL?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAp@
CONST	SEGMENT
??_C@_1CO@LEDHMGOL@?$AAo?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AA?$CL?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAp@ DB 'o'
	DB	00H, 'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '''', 00H
	DB	'+', 00H, '''', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'o'
	DB	00H, 'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '''', 00H
	DB	'-', 00H, '''', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z@4JA DD 06acH ; `ImGui::DataTypeApplyOp'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z@4JA DD 0695H ; `ImGui::DataTypeFormatString'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GE@PMGCKKHF@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
CONST	SEGMENT
??_C@_1GE@PMGCKKHF@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@ DB 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'd', 00H, 'a', 00H
	DB	't', 00H, 'a', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H
	DB	'u', 00H, 'i', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'T'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'O', 00H
	DB	'U', 00H, 'N', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z@4JA DD 068fH ; `ImGui::DataTypeGetInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@
CONST	SEGMENT
??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@ DB '%.*s%%d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
CONST	SEGMENT
??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@ DB '*Unknown item*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@
CONST	SEGMENT
??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@ DB '##Combo_%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@IOEAHNLK@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
CONST	SEGMENT
??_C@_1GI@IOEAHNLK@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ DB 'I'
	DB	00H, 'm', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, 'O', 00H, 'f', 00H, 'T', 00H, 'w', 00H, 'o'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'b', 00H, 'o', 00H
	DB	'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'H'
	DB	00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, 'M', 00H
	DB	'a', 00H, 's', 00H, 'k', 00H, '_', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAK@ONBANIIG@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAI?$AAm?$AAG?$AAu?$AAi@
CONST	SEGMENT
??_C@_1BAK@ONBANIIG@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAI?$AAm?$AAG?$AAu?$AAi@ DB '('
	DB	00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H
	DB	'&', 00H, ' ', 00H, '(', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u'
	DB	00H, 'i', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'b', 00H, 'o', 00H
	DB	'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'N'
	DB	00H, 'o', 00H, 'A', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'w', 00H
	DB	'B', 00H, 'u', 00H, 't', 00H, 't', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, '|', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H
	DB	'i', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'b', 00H, 'o', 00H, 'F'
	DB	00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'N', 00H
	DB	'o', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, ')', 00H, ')', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, '(', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'b', 00H, 'o', 00H, 'F', 00H
	DB	'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'N', 00H, 'o'
	DB	00H, 'A', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'w', 00H, 'B', 00H
	DB	'u', 00H, 't', 00H, 't', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '|'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'b', 00H, 'o', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'N', 00H, 'o', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??BeginCombo@ImGui@@YA_NPBD0H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BeginCombo@ImGui@@YA_NPBD0H@Z@4JA DD 058aH ; `ImGui::BeginCombo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EE@LBEKBPGJ@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA2?$AA?5?$AA?9?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EE@LBEKBPGJ@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA2?$AA?5?$AA?9?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@ DB '*'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '2', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, 'm', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e'
	DB	00H, '_', 00H, 'd', 00H, 'e', 00H, 'l', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'm', 00H, 'i', 00H, 'n'
	DB	00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '2', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@HJGLFFIG@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA1?$AA?5?$AA?$CL?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EE@HJGLFFIG@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA1?$AA?5?$AA?$CL?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@ DB '*'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '1', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, 'm', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e'
	DB	00H, '_', 00H, 'd', 00H, 'e', 00H, 'l', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'm', 00H, 'i', 00H, 'n'
	DB	00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z@4JA DD 0514H ; `ImGui::SplitterBehavior'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@GNHPAIID@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0CB@GNHPAIID@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLHJFGPH@?5?$HM@
CONST	SEGMENT
??_C@_02LLHJFGPH@?5?$HM@ DB ' |', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1LA@FPPCKOP@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
CONST	SEGMENT
??_C@_1LA@FPPCKOP@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@ DB 'I'
	DB	00H, 'm', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'r', 00H, 'O', 00H, 'f', 00H, 'T', 00H, 'w', 00H, 'o'
	DB	00H, '(', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, '(', 00H, 'I', 00H, 'm', 00H, 'G'
	DB	00H, 'u', 00H, 'i', 00H, 'S', 00H, 'e', 00H, 'p', 00H, 'a', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'F', 00H, 'l'
	DB	00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'H', 00H, 'o', 00H
	DB	'r', 00H, 'i', 00H, 'z', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a'
	DB	00H, 'l', 00H, ' ', 00H, '|', 00H, ' ', 00H, 'I', 00H, 'm', 00H
	DB	'G', 00H, 'u', 00H, 'i', 00H, 'S', 00H, 'e', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'F', 00H
	DB	'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, '_', 00H, 'V', 00H, 'e'
	DB	00H, 'r', 00H, 't', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 'l', 00H
	DB	')', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SeparatorEx@ImGui@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SeparatorEx@ImGui@@YAXH@Z@4JA DD 04c6H	; `ImGui::SeparatorEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@
CONST	SEGMENT
??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@ DB '%.0f%%', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHDGHODJ@?$CI?5?$CJ@
CONST	SEGMENT
??_C@_03MHDGHODJ@?$CI?5?$CJ@ DB '( )', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KFJJABDB@?$CIx?$CJ@
CONST	SEGMENT
??_C@_03KFJJABDB@?$CIx?$CJ@ DB '(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFOPMNLJ@?$FL?5?$FN@
CONST	SEGMENT
??_C@_03PFOPMNLJ@?$FL?5?$FN@ DB '[ ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JHEALCLB@?$FLx?$FN@
CONST	SEGMENT
??_C@_03JHEALCLB@?$FLx?$FN@ DB '[x]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBHDMMP@?$CDimage@
CONST	SEGMENT
??_C@_06EBHDMMP@?$CDimage@ DB '#image', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@GFPJIOBE@?$AAs?$AAc?$AAr?$AAo?$AAl?$AAl?$AAb?$AAa?$AAr?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5@
CONST	SEGMENT
??_C@_1CM@GFPJIOBE@?$AAs?$AAc?$AAr?$AAo?$AAl?$AAl?$AAb?$AAa?$AAr?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5@ DB 's'
	DB	00H, 'c', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'b', 00H
	DB	'a', 00H, 'r', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H
	DB	'f', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z@4JA DD 0370H ; `ImGui::Scrollbar'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FI@OFJDJLOI@?$AAI?$AAm?$AAM?$AAa?$AAx?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAc?$AAo?$AAn?$AAt@
CONST	SEGMENT
??_C@_1FI@OFJDJLOI@?$AAI?$AAm?$AAM?$AAa?$AAx?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAc?$AAo?$AAn?$AAt@ DB 'I'
	DB	00H, 'm', 00H, 'M', 00H, 'a', 00H, 'x', 00H, '(', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '_', 00H
	DB	'v', 00H, ',', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '_', 00H, 'a', 00H, 'v', 00H, 'a', 00H, 'i', 00H, 'l', 00H
	DB	'_', 00H, 'v', 00H, ')', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, '.', 00H, '0', 00H, 'f', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z@4JA DD 0315H ; `ImGui::ScrollbarEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08FEBONNKO@?$CDSCROLLY@
CONST	SEGMENT
??_C@_08FEBONNKO@?$CDSCROLLY@ DB '#SCROLLY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENAFOMOP@?$CDSCROLLX@
CONST	SEGMENT
??_C@_08ENAFOMOP@?$CDSCROLLX@ DB '#SCROLLX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@KJEAANOI@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAa?$AAr?$AAg?$AA?4?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1FC@KJEAANOI@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAa?$AAr?$AAg?$AA?4?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'r', 00H
	DB	'g', 00H, '.', 00H, 'x', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, '.', 00H, '0', 00H, 'f', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '_'
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, '.', 00H, 'y', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z@4JA DD 0298H ; `ImGui::InvisibleButton'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BE@HMGDGFIB@?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BE@HMGDGFIB@?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 't'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '_'
	DB	00H, 'w', 00H, 'i', 00H, 'd', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	's', 00H, '.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??TextEx@ImGui@@YAXPBD0H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??TextEx@ImGui@@YAXPBD0H@Z@4JA DD 084H	; `ImGui::TextEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1HM@PJKJLKEH@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAN?$AAa?$AAm?$AAe?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt@
CONST	SEGMENT
??_C@_1HM@PJKJLKEH@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAN?$AAa?$AAm?$AAe?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt@ DB 't'
	DB	00H, 'a', 00H, 'b', 00H, '-', 00H, '>', 00H, 'N', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, 'O', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'e'
	DB	00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '-', 00H
	DB	'1', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't', 00H, 'a'
	DB	00H, 'b', 00H, '-', 00H, '>', 00H, 'N', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 'O', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'T', 00H, 'a', 00H, 'b', 00H
	DB	's', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's', 00H, '.'
	DB	00H, 'B', 00H, 'u', 00H, 'f', 00H, '.', 00H, 'S', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1LE@HAMNIKDF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LE@HAMNIKDF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '_'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'a', 00H, 'l', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@IHACEFEE@?$AAI?$AAt?$AAe?$AAm?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9@
CONST	SEGMENT
??_C@_1CC@IHACEFEE@?$AAI?$AAt?$AAe?$AAm?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9@ DB 'I'
	DB	00H, 't', 00H, 'e', 00H, 'm', 00H, 's', 00H, 'C', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '-', 00H, '1', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@IIGHOJGM@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1@
CONST	SEGMENT
??_C@_1BC@IIGHOJGM@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1@ DB 'i'
	DB	00H, 'd', 00H, 'x', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z$0
__ehfuncinfo$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImGuiTabBar@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImGuiTabBar@@QAE@XZ$0
__ehfuncinfo$??0ImGuiTabBar@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImGuiTabBar@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiTabItem@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ$0
__ehfuncinfo$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImGuiColumns@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImGuiColumns@@QAE@XZ$0
__ehfuncinfo$??0ImGuiColumns@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImGuiColumns@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImGuiListClipper@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3@YAXPAXUImNewDummy@@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z$0
__ehfuncinfo$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@N@@YANNNN@Z
_TEXT	SEGMENT
tv66 = -208						; size = 8
tv67 = -200						; size = 8
_v$ = 8							; size = 8
_mn$ = 16						; size = 8
_mx$ = 24						; size = 8
??$ImClamp@N@@YANNNN@Z PROC				; ImClamp<double>, COMDAT

; 316  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _mn$[ebp]
  0002d	66 0f 2f 45 08	 comisd	 xmm0, QWORD PTR _v$[ebp]
  00032	76 0f		 jbe	 SHORT $LN5@ImClamp
  00034	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _mn$[ebp]
  00039	f2 0f 11 85 38
	ff ff ff	 movsd	 QWORD PTR tv67[ebp], xmm0
  00041	eb 38		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  00043	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _v$[ebp]
  00048	66 0f 2f 45 18	 comisd	 xmm0, QWORD PTR _mx$[ebp]
  0004d	76 0f		 jbe	 SHORT $LN3@ImClamp
  0004f	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _mx$[ebp]
  00054	f2 0f 11 85 30
	ff ff ff	 movsd	 QWORD PTR tv66[ebp], xmm0
  0005c	eb 0d		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  0005e	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _v$[ebp]
  00063	f2 0f 11 85 30
	ff ff ff	 movsd	 QWORD PTR tv66[ebp], xmm0
$LN4@ImClamp:
  0006b	f2 0f 10 85 30
	ff ff ff	 movsd	 xmm0, QWORD PTR tv66[ebp]
  00073	f2 0f 11 85 38
	ff ff ff	 movsd	 QWORD PTR tv67[ebp], xmm0
$LN6@ImClamp:
  0007b	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv67[ebp]
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
??$ImClamp@N@@YANNNN@Z ENDP				; ImClamp<double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@_K@@YA_K_K00@Z
_TEXT	SEGMENT
tv66 = -208						; size = 8
tv67 = -200						; size = 8
_v$ = 8							; size = 8
_mn$ = 16						; size = 8
_mx$ = 24						; size = 8
??$ImClamp@_K@@YA_K_K00@Z PROC				; ImClamp<unsigned __int64>, COMDAT

; 316  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp+4]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _mn$[ebp+4]
  0002e	77 1e		 ja	 SHORT $LN5@ImClamp
  00030	72 08		 jb	 SHORT $LN7@ImClamp
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00035	3b 4d 10	 cmp	 ecx, DWORD PTR _mn$[ebp]
  00038	73 14		 jae	 SHORT $LN5@ImClamp
$LN7@ImClamp:
  0003a	8b 55 10	 mov	 edx, DWORD PTR _mn$[ebp]
  0003d	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], edx
  00043	8b 45 14	 mov	 eax, DWORD PTR _mn$[ebp+4]
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp+4], eax
  0004c	eb 50		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp+4]
  00051	3b 4d 1c	 cmp	 ecx, DWORD PTR _mx$[ebp+4]
  00054	72 1e		 jb	 SHORT $LN3@ImClamp
  00056	77 08		 ja	 SHORT $LN8@ImClamp
  00058	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0005b	3b 55 18	 cmp	 edx, DWORD PTR _mx$[ebp]
  0005e	76 14		 jbe	 SHORT $LN3@ImClamp
$LN8@ImClamp:
  00060	8b 45 18	 mov	 eax, DWORD PTR _mx$[ebp]
  00063	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00069	8b 4d 1c	 mov	 ecx, DWORD PTR _mx$[ebp+4]
  0006c	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv66[ebp+4], ecx
  00072	eb 12		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  00074	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00077	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], edx
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp+4]
  00080	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv66[ebp+4], eax
$LN4@ImClamp:
  00086	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0008c	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  00092	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp+4]
  00098	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp+4], edx
$LN6@ImClamp:
  0009e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv67[ebp]
  000a4	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv67[ebp+4]
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
??$ImClamp@_K@@YA_K_K00@Z ENDP				; ImClamp<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@_J@@YA_J_J00@Z
_TEXT	SEGMENT
tv66 = -208						; size = 8
tv67 = -200						; size = 8
_v$ = 8							; size = 8
_mn$ = 16						; size = 8
_mx$ = 24						; size = 8
??$ImClamp@_J@@YA_J_J00@Z PROC				; ImClamp<__int64>, COMDAT

; 316  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp+4]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _mn$[ebp+4]
  0002e	7f 1e		 jg	 SHORT $LN5@ImClamp
  00030	7c 08		 jl	 SHORT $LN7@ImClamp
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00035	3b 4d 10	 cmp	 ecx, DWORD PTR _mn$[ebp]
  00038	73 14		 jae	 SHORT $LN5@ImClamp
$LN7@ImClamp:
  0003a	8b 55 10	 mov	 edx, DWORD PTR _mn$[ebp]
  0003d	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], edx
  00043	8b 45 14	 mov	 eax, DWORD PTR _mn$[ebp+4]
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp+4], eax
  0004c	eb 50		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp+4]
  00051	3b 4d 1c	 cmp	 ecx, DWORD PTR _mx$[ebp+4]
  00054	7c 1e		 jl	 SHORT $LN3@ImClamp
  00056	7f 08		 jg	 SHORT $LN8@ImClamp
  00058	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0005b	3b 55 18	 cmp	 edx, DWORD PTR _mx$[ebp]
  0005e	76 14		 jbe	 SHORT $LN3@ImClamp
$LN8@ImClamp:
  00060	8b 45 18	 mov	 eax, DWORD PTR _mx$[ebp]
  00063	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00069	8b 4d 1c	 mov	 ecx, DWORD PTR _mx$[ebp+4]
  0006c	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv66[ebp+4], ecx
  00072	eb 12		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  00074	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00077	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], edx
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp+4]
  00080	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv66[ebp+4], eax
$LN4@ImClamp:
  00086	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0008c	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  00092	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp+4]
  00098	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp+4], edx
$LN6@ImClamp:
  0009e	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv67[ebp]
  000a4	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv67[ebp+4]
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
??$ImClamp@_J@@YA_J_J00@Z ENDP				; ImClamp<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@I@@YAIIII@Z
_TEXT	SEGMENT
tv66 = -200						; size = 4
tv67 = -196						; size = 4
_v$ = 8							; size = 4
_mn$ = 12						; size = 4
_mx$ = 16						; size = 4
??$ImClamp@I@@YAIIII@Z PROC				; ImClamp<unsigned int>, COMDAT

; 316  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _mn$[ebp]
  0002e	73 0b		 jae	 SHORT $LN5@ImClamp
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _mn$[ebp]
  00033	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  00039	eb 28		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  0003b	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0003e	3b 55 10	 cmp	 edx, DWORD PTR _mx$[ebp]
  00041	76 0b		 jbe	 SHORT $LN3@ImClamp
  00043	8b 45 10	 mov	 eax, DWORD PTR _mx$[ebp]
  00046	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  0004c	eb 09		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00051	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], ecx
$LN4@ImClamp:
  00057	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp]
  0005d	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp], edx
$LN6@ImClamp:
  00063	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv67[ebp]
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
??$ImClamp@I@@YAIIII@Z ENDP				; ImClamp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$ImAtoi@N@@YAPBDPBDPAN@Z
_TEXT	SEGMENT
tv82 = -228						; size = 8
_v$ = -24						; size = 8
_negative$ = -8						; size = 4
_src$ = 8						; size = 4
_output$ = 12						; size = 4
??$ImAtoi@N@@YAPBDPBDPAN@Z PROC				; ImAtoi<double>, COMDAT

; 1870 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1871 :     int negative = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 0

; 1872 :     if (*src == '-') { negative = 1; src++; }

  0002f	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00038	75 10		 jne	 SHORT $LN4@ImAtoi
  0003a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 1
  00041	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN4@ImAtoi:

; 1873 :     if (*src == '+') { src++; }

  0004a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0004d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00050	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00053	75 09		 jne	 SHORT $LN5@ImAtoi
  00055	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN5@ImAtoi:

; 1874 :     TYPE v = 0;

  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	f2 0f 11 45 e8	 movsd	 QWORD PTR _v$[ebp], xmm0
$LN2@ImAtoi:

; 1875 :     while (*src >= '0' && *src <= '9')

  00066	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00069	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006c	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0006f	7c 39		 jl	 SHORT $LN3@ImAtoi
  00071	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00074	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00077	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0007a	7f 2e		 jg	 SHORT $LN3@ImAtoi

; 1876 :         v = (v * 10) + (*src++ - '0');

  0007c	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _v$[ebp]
  00081	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  00089	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0008c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008f	83 e9 30	 sub	 ecx, 48			; 00000030H
  00092	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  00096	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0009a	f2 0f 11 45 e8	 movsd	 QWORD PTR _v$[ebp], xmm0
  0009f	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  000a2	83 c2 01	 add	 edx, 1
  000a5	89 55 08	 mov	 DWORD PTR _src$[ebp], edx
  000a8	eb bc		 jmp	 SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 1877 :     *output = negative ? -v : v;

  000aa	83 7d f8 00	 cmp	 DWORD PTR _negative$[ebp], 0
  000ae	74 16		 je	 SHORT $LN7@ImAtoi
  000b0	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _v$[ebp]
  000b5	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  000bc	f2 0f 11 85 1c
	ff ff ff	 movsd	 QWORD PTR tv82[ebp], xmm0
  000c4	eb 0d		 jmp	 SHORT $LN8@ImAtoi
$LN7@ImAtoi:
  000c6	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _v$[ebp]
  000cb	f2 0f 11 85 1c
	ff ff ff	 movsd	 QWORD PTR tv82[ebp], xmm0
$LN8@ImAtoi:
  000d3	8b 45 0c	 mov	 eax, DWORD PTR _output$[ebp]
  000d6	f2 0f 10 85 1c
	ff ff ff	 movsd	 xmm0, QWORD PTR tv82[ebp]
  000de	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 1878 :     return src;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 1879 : }

  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000ee	3b ec		 cmp	 ebp, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
??$ImAtoi@N@@YAPBDPBDPAN@Z ENDP				; ImAtoi<double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$ImAtoi@M@@YAPBDPBDPAM@Z
_TEXT	SEGMENT
tv82 = -220						; size = 4
_v$ = -20						; size = 4
_negative$ = -8						; size = 4
_src$ = 8						; size = 4
_output$ = 12						; size = 4
??$ImAtoi@M@@YAPBDPBDPAM@Z PROC				; ImAtoi<float>, COMDAT

; 1870 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1871 :     int negative = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 0

; 1872 :     if (*src == '-') { negative = 1; src++; }

  0002f	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00038	75 10		 jne	 SHORT $LN4@ImAtoi
  0003a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 1
  00041	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN4@ImAtoi:

; 1873 :     if (*src == '+') { src++; }

  0004a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0004d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00050	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00053	75 09		 jne	 SHORT $LN5@ImAtoi
  00055	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN5@ImAtoi:

; 1874 :     TYPE v = 0;

  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	f3 0f 11 45 ec	 movss	 DWORD PTR _v$[ebp], xmm0
$LN2@ImAtoi:

; 1875 :     while (*src >= '0' && *src <= '9')

  00066	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00069	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006c	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0006f	7c 39		 jl	 SHORT $LN3@ImAtoi
  00071	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00074	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00077	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0007a	7f 2e		 jg	 SHORT $LN3@ImAtoi

; 1876 :         v = (v * 10) + (*src++ - '0');

  0007c	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v$[ebp]
  00081	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00089	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0008c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008f	83 e9 30	 sub	 ecx, 48			; 00000030H
  00092	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00096	f3 0f 58 c1	 addss	 xmm0, xmm1
  0009a	f3 0f 11 45 ec	 movss	 DWORD PTR _v$[ebp], xmm0
  0009f	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  000a2	83 c2 01	 add	 edx, 1
  000a5	89 55 08	 mov	 DWORD PTR _src$[ebp], edx
  000a8	eb bc		 jmp	 SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 1877 :     *output = negative ? -v : v;

  000aa	83 7d f8 00	 cmp	 DWORD PTR _negative$[ebp], 0
  000ae	74 16		 je	 SHORT $LN7@ImAtoi
  000b0	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v$[ebp]
  000b5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000bc	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv82[ebp], xmm0
  000c4	eb 0d		 jmp	 SHORT $LN8@ImAtoi
$LN7@ImAtoi:
  000c6	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v$[ebp]
  000cb	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv82[ebp], xmm0
$LN8@ImAtoi:
  000d3	8b 45 0c	 mov	 eax, DWORD PTR _output$[ebp]
  000d6	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv82[ebp]
  000de	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1878 :     return src;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 1879 : }

  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000ee	3b ec		 cmp	 ebp, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
??$ImAtoi@M@@YAPBDPBDPAM@Z ENDP				; ImAtoi<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$ImAtoi@_J@@YAPBDPBDPA_J@Z
_TEXT	SEGMENT
tv82 = -228						; size = 8
_v$ = -24						; size = 8
_negative$ = -8						; size = 4
_src$ = 8						; size = 4
_output$ = 12						; size = 4
??$ImAtoi@_J@@YAPBDPBDPA_J@Z PROC			; ImAtoi<__int64>, COMDAT

; 1870 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1871 :     int negative = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 0

; 1872 :     if (*src == '-') { negative = 1; src++; }

  0002f	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00038	75 10		 jne	 SHORT $LN4@ImAtoi
  0003a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 1
  00041	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN4@ImAtoi:

; 1873 :     if (*src == '+') { src++; }

  0004a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0004d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00050	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00053	75 09		 jne	 SHORT $LN5@ImAtoi
  00055	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN5@ImAtoi:

; 1874 :     TYPE v = 0;

  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	66 0f 13 45 e8	 movlpd	 QWORD PTR _v$[ebp], xmm0
$LN2@ImAtoi:

; 1875 :     while (*src >= '0' && *src <= '9')

  00066	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00069	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006c	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0006f	7c 3f		 jl	 SHORT $LN3@ImAtoi
  00071	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00074	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00077	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0007a	7f 34		 jg	 SHORT $LN3@ImAtoi

; 1876 :         v = (v * 10) + (*src++ - '0');

  0007c	6a 00		 push	 0
  0007e	6a 0a		 push	 10			; 0000000aH
  00080	8b 45 ec	 mov	 eax, DWORD PTR _v$[ebp+4]
  00083	50		 push	 eax
  00084	8b 4d e8	 mov	 ecx, DWORD PTR _v$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 __allmul
  0008d	8b c8		 mov	 ecx, eax
  0008f	8b f2		 mov	 esi, edx
  00091	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00094	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00097	83 e8 30	 sub	 eax, 48			; 00000030H
  0009a	99		 cdq
  0009b	03 c8		 add	 ecx, eax
  0009d	13 f2		 adc	 esi, edx
  0009f	89 4d e8	 mov	 DWORD PTR _v$[ebp], ecx
  000a2	89 75 ec	 mov	 DWORD PTR _v$[ebp+4], esi
  000a5	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
  000ae	eb b6		 jmp	 SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 1877 :     *output = negative ? -v : v;

  000b0	83 7d f8 00	 cmp	 DWORD PTR _negative$[ebp], 0
  000b4	74 1b		 je	 SHORT $LN7@ImAtoi
  000b6	8b 45 e8	 mov	 eax, DWORD PTR _v$[ebp]
  000b9	f7 d8		 neg	 eax
  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _v$[ebp+4]
  000be	83 d1 00	 adc	 ecx, 0
  000c1	f7 d9		 neg	 ecx
  000c3	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  000c9	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv82[ebp+4], ecx
  000cf	eb 12		 jmp	 SHORT $LN8@ImAtoi
$LN7@ImAtoi:
  000d1	8b 55 e8	 mov	 edx, DWORD PTR _v$[ebp]
  000d4	89 95 1c ff ff
	ff		 mov	 DWORD PTR tv82[ebp], edx
  000da	8b 45 ec	 mov	 eax, DWORD PTR _v$[ebp+4]
  000dd	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv82[ebp+4], eax
$LN8@ImAtoi:
  000e3	8b 4d 0c	 mov	 ecx, DWORD PTR _output$[ebp]
  000e6	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv82[ebp]
  000ec	89 11		 mov	 DWORD PTR [ecx], edx
  000ee	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv82[ebp+4]
  000f4	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1878 :     return src;

  000f7	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 1879 : }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00103	3b ec		 cmp	 ebp, esp
  00105	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
??$ImAtoi@_J@@YAPBDPBDPA_J@Z ENDP			; ImAtoi<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@N@@YANNN@Z
_TEXT	SEGMENT
tv65 = -200						; size = 8
_lhs$ = 8						; size = 8
_rhs$ = 16						; size = 8
??$ImMax@N@@YANNN@Z PROC				; ImMax<double>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _lhs$[ebp]
  0002d	66 0f 2f 45 10	 comisd	 xmm0, QWORD PTR _rhs$[ebp]
  00032	72 0f		 jb	 SHORT $LN3@ImMax
  00034	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _lhs$[ebp]
  00039	f2 0f 11 85 38
	ff ff ff	 movsd	 QWORD PTR tv65[ebp], xmm0
  00041	eb 0d		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  00043	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _rhs$[ebp]
  00048	f2 0f 11 85 38
	ff ff ff	 movsd	 QWORD PTR tv65[ebp], xmm0
$LN4@ImMax:
  00050	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv65[ebp]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$ImMax@N@@YANNN@Z ENDP				; ImMax<double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@N@@YANNNM@Z
_TEXT	SEGMENT
tv73 = -200						; size = 8
_a$ = 8							; size = 8
_b$ = 16						; size = 8
_t$ = 24						; size = 4
??$ImLerp@N@@YANNNM@Z PROC				; ImLerp<double>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _b$[ebp]
  0002d	f2 0f 5c 45 08	 subsd	 xmm0, QWORD PTR _a$[ebp]
  00032	f3 0f 5a 4d 18	 cvtss2sd xmm1, DWORD PTR _t$[ebp]
  00037	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0003b	f2 0f 58 45 08	 addsd	 xmm0, QWORD PTR _a$[ebp]
  00040	f2 0f 11 85 38
	ff ff ff	 movsd	 QWORD PTR tv73[ebp], xmm0
  00048	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv73[ebp]
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$ImLerp@N@@YANNNM@Z ENDP				; ImLerp<double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMin@N@@YANNN@Z
_TEXT	SEGMENT
tv65 = -200						; size = 8
_lhs$ = 8						; size = 8
_rhs$ = 16						; size = 8
??$ImMin@N@@YANNN@Z PROC				; ImMin<double>, COMDAT

; 314  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _rhs$[ebp]
  0002d	66 0f 2f 45 08	 comisd	 xmm0, QWORD PTR _lhs$[ebp]
  00032	76 0f		 jbe	 SHORT $LN3@ImMin
  00034	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _lhs$[ebp]
  00039	f2 0f 11 85 38
	ff ff ff	 movsd	 QWORD PTR tv65[ebp], xmm0
  00041	eb 0d		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  00043	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _rhs$[ebp]
  00048	f2 0f 11 85 38
	ff ff ff	 movsd	 QWORD PTR tv65[ebp], xmm0
$LN4@ImMin:
  00050	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv65[ebp]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$ImMin@N@@YANNN@Z ENDP				; ImMin<double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z
_TEXT	SEGMENT
tv228 = -268						; size = 8
tv251 = -260						; size = 8
tv198 = -260						; size = 8
tv249 = -252						; size = 8
tv241 = -252						; size = 4
tv219 = -252						; size = 8
tv210 = -252						; size = 4
tv78 = -252						; size = 8
tv246 = -248						; size = 4
tv237 = -248						; size = 4
tv207 = -248						; size = 4
tv68 = -245						; size = 1
_f$1 = -48						; size = 4
_f$2 = -36						; size = 4
_v_clamped$ = -24					; size = 8
_is_power$ = -5						; size = 1
_data_type$ = 8						; size = 4
_v$ = 12						; size = 8
_v_min$ = 20						; size = 8
_v_max$ = 28						; size = 8
_power$ = 36						; size = 4
_linear_zero_pos$ = 40					; size = 4
??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<double,double>, COMDAT

; 2282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2283 :     if (v_min == v_max)

  00028	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  0002d	66 0f 2e 45 1c	 ucomisd xmm0, QWORD PTR _v_max$[ebp]
  00032	9f		 lahf
  00033	f6 c4 44	 test	 ah, 68			; 00000044H
  00036	7a 07		 jp	 SHORT $LN2@SliderCalc

; 2284 :         return 0.0f;

  00038	d9 ee		 fldz
  0003a	e9 9c 02 00 00	 jmp	 $LN1@SliderCalc
$LN2@SliderCalc:

; 2285 : 
; 2286 :     const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

  0003f	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00044	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0004b	9f		 lahf
  0004c	f6 c4 44	 test	 ah, 68			; 00000044H
  0004f	7b 15		 jnp	 SHORT $LN8@SliderCalc
  00051	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00055	74 06		 je	 SHORT $LN7@SliderCalc
  00057	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  0005b	75 09		 jne	 SHORT $LN8@SliderCalc
$LN7@SliderCalc:
  0005d	c6 85 0b ff ff
	ff 01		 mov	 BYTE PTR tv68[ebp], 1
  00064	eb 07		 jmp	 SHORT $LN9@SliderCalc
$LN8@SliderCalc:
  00066	c6 85 0b ff ff
	ff 00		 mov	 BYTE PTR tv68[ebp], 0
$LN9@SliderCalc:
  0006d	8a 85 0b ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00073	88 45 fb	 mov	 BYTE PTR _is_power$[ebp], al

; 2287 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

  00076	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  0007b	66 0f 2f 45 14	 comisd	 xmm0, QWORD PTR _v_min$[ebp]
  00080	76 37		 jbe	 SHORT $LN10@SliderCalc
  00082	83 ec 08	 sub	 esp, 8
  00085	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  0008a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0008f	83 ec 08	 sub	 esp, 8
  00092	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  00097	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0009c	83 ec 08	 sub	 esp, 8
  0009f	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _v$[ebp]
  000a4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000a9	e8 00 00 00 00	 call	 ??$ImClamp@N@@YANNNN@Z	; ImClamp<double>
  000ae	83 c4 18	 add	 esp, 24			; 00000018H
  000b1	dd 9d 04 ff ff
	ff		 fstp	 QWORD PTR tv78[ebp]
  000b7	eb 35		 jmp	 SHORT $LN11@SliderCalc
$LN10@SliderCalc:
  000b9	83 ec 08	 sub	 esp, 8
  000bc	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  000c1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c6	83 ec 08	 sub	 esp, 8
  000c9	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  000ce	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000d3	83 ec 08	 sub	 esp, 8
  000d6	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _v$[ebp]
  000db	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000e0	e8 00 00 00 00	 call	 ??$ImClamp@N@@YANNNN@Z	; ImClamp<double>
  000e5	83 c4 18	 add	 esp, 24			; 00000018H
  000e8	dd 9d 04 ff ff
	ff		 fstp	 QWORD PTR tv78[ebp]
$LN11@SliderCalc:
  000ee	f2 0f 10 85 04
	ff ff ff	 movsd	 xmm0, QWORD PTR tv78[ebp]
  000f6	f2 0f 11 45 e8	 movsd	 QWORD PTR _v_clamped$[ebp], xmm0

; 2288 :     if (is_power)

  000fb	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  000ff	85 c0		 test	 eax, eax
  00101	0f 84 aa 01 00
	00		 je	 $LN5@SliderCalc

; 2289 :     {
; 2290 :         if (v_clamped < 0.0f)

  00107	0f 57 c0	 xorps	 xmm0, xmm0
  0010a	66 0f 2f 45 e8	 comisd	 xmm0, QWORD PTR _v_clamped$[ebp]
  0010f	0f 86 bf 00 00
	00		 jbe	 $LN4@SliderCalc

; 2291 :         {
; 2292 :             const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

  00115	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _v_clamped$[ebp]
  0011a	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  0011f	83 ec 08	 sub	 esp, 8
  00122	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR _v_max$[ebp]
  00127	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0012c	83 ec 08	 sub	 esp, 8
  0012f	0f 57 c9	 xorps	 xmm1, xmm1
  00132	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00137	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv249[ebp], xmm0
  0013f	e8 00 00 00 00	 call	 ??$ImMin@N@@YANNN@Z	; ImMin<double>
  00144	83 c4 10	 add	 esp, 16			; 00000010H
  00147	dd 9d fc fe ff
	ff		 fstp	 QWORD PTR tv198[ebp]
  0014d	f2 0f 10 85 fc
	fe ff ff	 movsd	 xmm0, QWORD PTR tv198[ebp]
  00155	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  0015a	f2 0f 10 8d 04
	ff ff ff	 movsd	 xmm1, QWORD PTR tv249[ebp]
  00162	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00166	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  0016a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00172	f3 0f 5c c8	 subss	 xmm1, xmm0
  00176	f3 0f 11 4d dc	 movss	 DWORD PTR _f$2[ebp], xmm1

; 2293 :             return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;

  0017b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00183	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00188	51		 push	 ecx
  00189	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018e	51		 push	 ecx
  0018f	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _f$2[ebp]
  00194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00199	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0019e	83 c4 08	 add	 esp, 8
  001a1	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv207[ebp]
  001a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001af	f3 0f 5c 85 08
	ff ff ff	 subss	 xmm0, DWORD PTR tv207[ebp]
  001b7	f3 0f 59 45 28	 mulss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  001bc	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR tv210[ebp], xmm0
  001c4	d9 85 04 ff ff
	ff		 fld	 DWORD PTR tv210[ebp]
  001ca	e9 0c 01 00 00	 jmp	 $LN1@SliderCalc

; 2294 :         }

  001cf	e9 dd 00 00 00	 jmp	 $LN5@SliderCalc
$LN4@SliderCalc:

; 2295 :         else
; 2296 :         {
; 2297 :             const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

  001d4	83 ec 08	 sub	 esp, 8
  001d7	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  001dc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001e1	83 ec 08	 sub	 esp, 8
  001e4	0f 57 c0	 xorps	 xmm0, xmm0
  001e7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001ec	e8 00 00 00 00	 call	 ??$ImMax@N@@YANNN@Z	; ImMax<double>
  001f1	83 c4 10	 add	 esp, 16			; 00000010H
  001f4	dd 9d 04 ff ff
	ff		 fstp	 QWORD PTR tv219[ebp]
  001fa	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _v_clamped$[ebp]
  001ff	f2 0f 5c 85 04
	ff ff ff	 subsd	 xmm0, QWORD PTR tv219[ebp]
  00207	83 ec 08	 sub	 esp, 8
  0020a	f2 0f 10 4d 14	 movsd	 xmm1, QWORD PTR _v_min$[ebp]
  0020f	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00214	83 ec 08	 sub	 esp, 8
  00217	0f 57 c9	 xorps	 xmm1, xmm1
  0021a	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0021f	f2 0f 11 85 fc
	fe ff ff	 movsd	 QWORD PTR tv251[ebp], xmm0
  00227	e8 00 00 00 00	 call	 ??$ImMax@N@@YANNN@Z	; ImMax<double>
  0022c	83 c4 10	 add	 esp, 16			; 00000010H
  0022f	dd 9d f4 fe ff
	ff		 fstp	 QWORD PTR tv228[ebp]
  00235	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  0023a	f2 0f 5c 85 f4
	fe ff ff	 subsd	 xmm0, QWORD PTR tv228[ebp]
  00242	f2 0f 10 8d fc
	fe ff ff	 movsd	 xmm1, QWORD PTR tv251[ebp]
  0024a	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0024e	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  00252	f3 0f 11 45 d0	 movss	 DWORD PTR _f$1[ebp], xmm0

; 2298 :             return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);

  00257	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0025f	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00264	51		 push	 ecx
  00265	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026a	51		 push	 ecx
  0026b	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _f$1[ebp]
  00270	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00275	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0027a	83 c4 08	 add	 esp, 8
  0027d	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv237[ebp]
  00283	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR tv237[ebp]
  0028b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00293	f3 0f 5c 4d 28	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  00298	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0029c	f3 0f 58 45 28	 addss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  002a1	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR tv241[ebp], xmm0
  002a9	d9 85 04 ff ff
	ff		 fld	 DWORD PTR tv241[ebp]
  002af	eb 2a		 jmp	 SHORT $LN1@SliderCalc
$LN5@SliderCalc:

; 2299 :         }
; 2300 :     }
; 2301 : 
; 2302 :     // Linear slider
; 2303 :     return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

  002b1	f2 0f 10 45 e8	 movsd	 xmm0, QWORD PTR _v_clamped$[ebp]
  002b6	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  002bb	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR _v_max$[ebp]
  002c0	f2 0f 5c 4d 14	 subsd	 xmm1, QWORD PTR _v_min$[ebp]
  002c5	f2 0f 5e c1	 divsd	 xmm0, xmm1
  002c9	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002cd	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv246[ebp], xmm0
  002d5	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv246[ebp]
$LN1@SliderCalc:

; 2304 : }

  002db	5f		 pop	 edi
  002dc	5e		 pop	 esi
  002dd	5b		 pop	 ebx
  002de	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  002e4	3b ec		 cmp	 ebp, esp
  002e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002eb	8b e5		 mov	 esp, ebp
  002ed	5d		 pop	 ebp
  002ee	c3		 ret	 0
??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<double,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z
_TEXT	SEGMENT
tv225 = -252						; size = 4
tv248 = -248						; size = 4
tv238 = -248						; size = 4
tv207 = -248						; size = 4
tv195 = -248						; size = 4
tv246 = -244						; size = 4
tv243 = -244						; size = 4
tv234 = -244						; size = 4
tv216 = -244						; size = 4
tv204 = -244						; size = 4
tv78 = -244						; size = 4
tv68 = -241						; size = 1
_f$1 = -44						; size = 4
_f$2 = -32						; size = 4
_v_clamped$ = -20					; size = 4
_is_power$ = -5						; size = 1
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_power$ = 24						; size = 4
_linear_zero_pos$ = 28					; size = 4
??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<float,float>, COMDAT

; 2282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2283 :     if (v_min == v_max)

  00028	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  0002d	0f 2e 45 14	 ucomiss xmm0, DWORD PTR _v_max$[ebp]
  00031	9f		 lahf
  00032	f6 c4 44	 test	 ah, 68			; 00000044H
  00035	7a 07		 jp	 SHORT $LN2@SliderCalc

; 2284 :         return 0.0f;

  00037	d9 ee		 fldz
  00039	e9 76 02 00 00	 jmp	 $LN1@SliderCalc
$LN2@SliderCalc:

; 2285 : 
; 2286 :     const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

  0003e	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _power$[ebp]
  00043	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0004a	9f		 lahf
  0004b	f6 c4 44	 test	 ah, 68			; 00000044H
  0004e	7b 15		 jnp	 SHORT $LN8@SliderCalc
  00050	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00054	74 06		 je	 SHORT $LN7@SliderCalc
  00056	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  0005a	75 09		 jne	 SHORT $LN8@SliderCalc
$LN7@SliderCalc:
  0005c	c6 85 0f ff ff
	ff 01		 mov	 BYTE PTR tv68[ebp], 1
  00063	eb 07		 jmp	 SHORT $LN9@SliderCalc
$LN8@SliderCalc:
  00065	c6 85 0f ff ff
	ff 00		 mov	 BYTE PTR tv68[ebp], 0
$LN9@SliderCalc:
  0006c	8a 85 0f ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00072	88 45 fb	 mov	 BYTE PTR _is_power$[ebp], al

; 2287 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

  00075	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  0007a	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _v_min$[ebp]
  0007e	76 31		 jbe	 SHORT $LN10@SliderCalc
  00080	51		 push	 ecx
  00081	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00086	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008b	51		 push	 ecx
  0008c	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00091	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00096	51		 push	 ecx
  00097	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _v$[ebp]
  0009c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a1	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv78[ebp]
  000af	eb 2f		 jmp	 SHORT $LN11@SliderCalc
$LN10@SliderCalc:
  000b1	51		 push	 ecx
  000b2	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  000b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bc	51		 push	 ecx
  000bd	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  000c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c7	51		 push	 ecx
  000c8	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _v$[ebp]
  000cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d2	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv78[ebp]
$LN11@SliderCalc:
  000e0	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR tv78[ebp]
  000e8	f3 0f 11 45 ec	 movss	 DWORD PTR _v_clamped$[ebp], xmm0

; 2288 :     if (is_power)

  000ed	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  000f1	85 c0		 test	 eax, eax
  000f3	0f 84 95 01 00
	00		 je	 $LN5@SliderCalc

; 2289 :     {
; 2290 :         if (v_clamped < 0.0f)

  000f9	0f 57 c0	 xorps	 xmm0, xmm0
  000fc	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _v_clamped$[ebp]
  00100	0f 86 b7 00 00
	00		 jbe	 $LN4@SliderCalc

; 2291 :         {
; 2292 :             const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

  00106	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v_clamped$[ebp]
  0010b	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  00110	51		 push	 ecx
  00111	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _v_max$[ebp]
  00116	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0011b	51		 push	 ecx
  0011c	0f 57 c9	 xorps	 xmm1, xmm1
  0011f	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00124	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR tv246[ebp], xmm0
  0012c	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00131	83 c4 08	 add	 esp, 8
  00134	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv195[ebp]
  0013a	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR tv195[ebp]
  00142	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  00147	f3 0f 10 8d 0c
	ff ff ff	 movss	 xmm1, DWORD PTR tv246[ebp]
  0014f	f3 0f 5e c8	 divss	 xmm1, xmm0
  00153	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0015f	f3 0f 11 45 e0	 movss	 DWORD PTR _f$2[ebp], xmm0

; 2293 :             return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;

  00164	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0016c	f3 0f 5e 45 18	 divss	 xmm0, DWORD PTR _power$[ebp]
  00171	51		 push	 ecx
  00172	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00177	51		 push	 ecx
  00178	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _f$2[ebp]
  0017d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00182	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00187	83 c4 08	 add	 esp, 8
  0018a	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv204[ebp]
  00190	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00198	f3 0f 5c 85 0c
	ff ff ff	 subss	 xmm0, DWORD PTR tv204[ebp]
  001a0	f3 0f 59 45 1c	 mulss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  001a5	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv207[ebp], xmm0
  001ad	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv207[ebp]
  001b3	e9 fc 00 00 00	 jmp	 $LN1@SliderCalc

; 2294 :         }

  001b8	e9 d1 00 00 00	 jmp	 $LN5@SliderCalc
$LN4@SliderCalc:

; 2295 :         else
; 2296 :         {
; 2297 :             const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

  001bd	51		 push	 ecx
  001be	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  001c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c8	51		 push	 ecx
  001c9	0f 57 c0	 xorps	 xmm0, xmm0
  001cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d1	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001d6	83 c4 08	 add	 esp, 8
  001d9	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv216[ebp]
  001df	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v_clamped$[ebp]
  001e4	f3 0f 5c 85 0c
	ff ff ff	 subss	 xmm0, DWORD PTR tv216[ebp]
  001ec	51		 push	 ecx
  001ed	f3 0f 10 4d 10	 movss	 xmm1, DWORD PTR _v_min$[ebp]
  001f2	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001f7	51		 push	 ecx
  001f8	0f 57 c9	 xorps	 xmm1, xmm1
  001fb	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00200	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv248[ebp], xmm0
  00208	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0020d	83 c4 08	 add	 esp, 8
  00210	d9 9d 04 ff ff
	ff		 fstp	 DWORD PTR tv225[ebp]
  00216	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  0021b	f3 0f 5c 85 04
	ff ff ff	 subss	 xmm0, DWORD PTR tv225[ebp]
  00223	f3 0f 10 8d 08
	ff ff ff	 movss	 xmm1, DWORD PTR tv248[ebp]
  0022b	f3 0f 5e c8	 divss	 xmm1, xmm0
  0022f	f3 0f 11 4d d4	 movss	 DWORD PTR _f$1[ebp], xmm1

; 2298 :             return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);

  00234	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0023c	f3 0f 5e 45 18	 divss	 xmm0, DWORD PTR _power$[ebp]
  00241	51		 push	 ecx
  00242	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00247	51		 push	 ecx
  00248	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f$1[ebp]
  0024d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00252	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00257	83 c4 08	 add	 esp, 8
  0025a	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv234[ebp]
  00260	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR tv234[ebp]
  00268	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00270	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  00275	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00279	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0027e	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv238[ebp], xmm0
  00286	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv238[ebp]
  0028c	eb 26		 jmp	 SHORT $LN1@SliderCalc
$LN5@SliderCalc:

; 2299 :         }
; 2300 :     }
; 2301 : 
; 2302 :     // Linear slider
; 2303 :     return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

  0028e	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v_clamped$[ebp]
  00293	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  00298	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _v_max$[ebp]
  0029d	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR _v_min$[ebp]
  002a2	f3 0f 5e c1	 divss	 xmm0, xmm1
  002a6	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR tv243[ebp], xmm0
  002ae	d9 85 0c ff ff
	ff		 fld	 DWORD PTR tv243[ebp]
$LN1@SliderCalc:

; 2304 : }

  002b4	5f		 pop	 edi
  002b5	5e		 pop	 esi
  002b6	5b		 pop	 ebx
  002b7	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  002bd	3b ec		 cmp	 ebp, esp
  002bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c4	8b e5		 mov	 esp, ebp
  002c6	5d		 pop	 ebp
  002c7	c3		 ret	 0
??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<float,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@_K@@YA_K_K0@Z
_TEXT	SEGMENT
tv65 = -200						; size = 8
_lhs$ = 8						; size = 8
_rhs$ = 16						; size = 8
??$ImMax@_K@@YA_K_K0@Z PROC				; ImMax<unsigned __int64>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _rhs$[ebp+4]
  0002e	72 1e		 jb	 SHORT $LN3@ImMax
  00030	77 08		 ja	 SHORT $LN5@ImMax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00035	3b 4d 10	 cmp	 ecx, DWORD PTR _rhs$[ebp]
  00038	72 14		 jb	 SHORT $LN3@ImMax
$LN5@ImMax:
  0003a	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003d	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
  00043	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], eax
  0004c	eb 12		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00051	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00057	8b 55 14	 mov	 edx, DWORD PTR _rhs$[ebp+4]
  0005a	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], edx
$LN4@ImMax:
  00060	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00066	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp+4]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
??$ImMax@_K@@YA_K_K0@Z ENDP				; ImMax<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@_K@@YA_K_K0M@Z
_TEXT	SEGMENT
tv94 = -196						; size = 4
_a$ = 8							; size = 8
_b$ = 16						; size = 8
_t$ = 24						; size = 4
??$ImLerp@_K@@YA_K_K0M@Z PROC				; ImLerp<unsigned __int64>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	e8 00 00 00 00	 call	 __ultod3
  00033	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _b$[ebp]
  0003a	2b 4d 08	 sub	 ecx, DWORD PTR _a$[ebp]
  0003d	8b 55 14	 mov	 edx, DWORD PTR _b$[ebp+4]
  00040	1b 55 0c	 sbb	 edx, DWORD PTR _a$[ebp+4]
  00043	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv94[ebp], xmm0
  0004b	e8 00 00 00 00	 call	 __ultod3
  00050	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00054	f3 0f 59 45 18	 mulss	 xmm0, DWORD PTR _t$[ebp]
  00059	f3 0f 10 8d 3c
	ff ff ff	 movss	 xmm1, DWORD PTR tv94[ebp]
  00061	f3 0f 58 c8	 addss	 xmm1, xmm0
  00065	0f 28 c1	 movaps	 xmm0, xmm1
  00068	e8 00 00 00 00	 call	 __ftoul3
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
??$ImLerp@_K@@YA_K_K0M@Z ENDP				; ImLerp<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMin@_K@@YA_K_K0@Z
_TEXT	SEGMENT
tv65 = -200						; size = 8
_lhs$ = 8						; size = 8
_rhs$ = 16						; size = 8
??$ImMin@_K@@YA_K_K0@Z PROC				; ImMin<unsigned __int64>, COMDAT

; 314  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _rhs$[ebp+4]
  0002e	77 1e		 ja	 SHORT $LN3@ImMin
  00030	72 08		 jb	 SHORT $LN5@ImMin
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00035	3b 4d 10	 cmp	 ecx, DWORD PTR _rhs$[ebp]
  00038	73 14		 jae	 SHORT $LN3@ImMin
$LN5@ImMin:
  0003a	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003d	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
  00043	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], eax
  0004c	eb 12		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00051	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00057	8b 55 14	 mov	 edx, DWORD PTR _rhs$[ebp+4]
  0005a	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], edx
$LN4@ImMin:
  00060	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00066	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp+4]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
??$ImMin@_K@@YA_K_K0@Z ENDP				; ImMin<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z
_TEXT	SEGMENT
tv337 = -256						; size = 4
tv340 = -252						; size = 8
tv318 = -252						; size = 4
tv258 = -252						; size = 4
tv78 = -252						; size = 8
tv314 = -248						; size = 4
tv255 = -248						; size = 4
tv68 = -245						; size = 1
_f$1 = -48						; size = 4
_f$2 = -36						; size = 4
_v_clamped$ = -24					; size = 8
_is_power$ = -5						; size = 1
_data_type$ = 8						; size = 4
_v$ = 12						; size = 8
_v_min$ = 20						; size = 8
_v_max$ = 28						; size = 8
_power$ = 36						; size = 4
_linear_zero_pos$ = 40					; size = 4
??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z PROC ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>, COMDAT

; 2282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2283 :     if (v_min == v_max)

  00028	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  0002b	3b 45 1c	 cmp	 eax, DWORD PTR _v_max$[ebp]
  0002e	75 0f		 jne	 SHORT $LN2@SliderCalc
  00030	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00033	3b 4d 20	 cmp	 ecx, DWORD PTR _v_max$[ebp+4]
  00036	75 07		 jne	 SHORT $LN2@SliderCalc

; 2284 :         return 0.0f;

  00038	d9 ee		 fldz
  0003a	e9 77 02 00 00	 jmp	 $LN1@SliderCalc
$LN2@SliderCalc:

; 2285 : 
; 2286 :     const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

  0003f	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00044	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0004b	9f		 lahf
  0004c	f6 c4 44	 test	 ah, 68			; 00000044H
  0004f	7b 15		 jnp	 SHORT $LN8@SliderCalc
  00051	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00055	74 06		 je	 SHORT $LN7@SliderCalc
  00057	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  0005b	75 09		 jne	 SHORT $LN8@SliderCalc
$LN7@SliderCalc:
  0005d	c6 85 0b ff ff
	ff 01		 mov	 BYTE PTR tv68[ebp], 1
  00064	eb 07		 jmp	 SHORT $LN9@SliderCalc
$LN8@SliderCalc:
  00066	c6 85 0b ff ff
	ff 00		 mov	 BYTE PTR tv68[ebp], 0
$LN9@SliderCalc:
  0006d	8a 85 0b ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00073	88 45 fb	 mov	 BYTE PTR _is_power$[ebp], al

; 2287 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

  00076	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00079	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  0007c	77 38		 ja	 SHORT $LN10@SliderCalc
  0007e	72 08		 jb	 SHORT $LN12@SliderCalc
  00080	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00083	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  00086	73 2e		 jae	 SHORT $LN10@SliderCalc
$LN12@SliderCalc:
  00088	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  0008b	52		 push	 edx
  0008c	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00093	51		 push	 ecx
  00094	8b 55 14	 mov	 edx, DWORD PTR _v_min$[ebp]
  00097	52		 push	 edx
  00098	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp+4]
  0009b	50		 push	 eax
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ??$ImClamp@_K@@YA_K_K00@Z ; ImClamp<unsigned __int64>
  000a5	83 c4 18	 add	 esp, 24			; 00000018H
  000a8	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  000ae	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv78[ebp+4], edx
  000b4	eb 2c		 jmp	 SHORT $LN11@SliderCalc
$LN10@SliderCalc:
  000b6	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  000b9	52		 push	 edx
  000ba	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp+4]
  000c1	51		 push	 ecx
  000c2	8b 55 1c	 mov	 edx, DWORD PTR _v_max$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp+4]
  000c9	50		 push	 eax
  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ??$ImClamp@_K@@YA_K_K00@Z ; ImClamp<unsigned __int64>
  000d3	83 c4 18	 add	 esp, 24			; 00000018H
  000d6	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  000dc	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv78[ebp+4], edx
$LN11@SliderCalc:
  000e2	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  000e8	89 55 e8	 mov	 DWORD PTR _v_clamped$[ebp], edx
  000eb	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp+4]
  000f1	89 45 ec	 mov	 DWORD PTR _v_clamped$[ebp+4], eax

; 2288 :     if (is_power)

  000f4	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  000f8	85 c0		 test	 eax, eax
  000fa	0f 84 6e 01 00
	00		 je	 $LN5@SliderCalc

; 2289 :     {
; 2290 :         if (v_clamped < 0.0f)

  00100	8b 55 ec	 mov	 edx, DWORD PTR _v_clamped$[ebp+4]
  00103	8b 4d e8	 mov	 ecx, DWORD PTR _v_clamped$[ebp]
  00106	e8 00 00 00 00	 call	 __ultod3
  0010b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0010f	0f 57 c9	 xorps	 xmm1, xmm1
  00112	0f 2f c8	 comiss	 xmm1, xmm0
  00115	0f 86 a4 00 00
	00		 jbe	 $LN4@SliderCalc

; 2291 :         {
; 2292 :             const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

  0011b	8b 75 e8	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  0011e	2b 75 14	 sub	 esi, DWORD PTR _v_min$[ebp]
  00121	8b 7d ec	 mov	 edi, DWORD PTR _v_clamped$[ebp+4]
  00124	1b 7d 18	 sbb	 edi, DWORD PTR _v_min$[ebp+4]
  00127	8b 45 20	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  0012a	50		 push	 eax
  0012b	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0012e	51		 push	 ecx
  0012f	6a 00		 push	 0
  00131	6a 00		 push	 0
  00133	e8 00 00 00 00	 call	 ??$ImMin@_K@@YA_K_K0@Z	; ImMin<unsigned __int64>
  00138	83 c4 10	 add	 esp, 16			; 00000010H
  0013b	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  0013e	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00141	52		 push	 edx
  00142	50		 push	 eax
  00143	57		 push	 edi
  00144	56		 push	 esi
  00145	e8 00 00 00 00	 call	 __aulldiv
  0014a	8b c8		 mov	 ecx, eax
  0014c	e8 00 00 00 00	 call	 __ultod3
  00151	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00155	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0015d	f3 0f 5c c8	 subss	 xmm1, xmm0
  00161	f3 0f 11 4d dc	 movss	 DWORD PTR _f$2[ebp], xmm1

; 2293 :             return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;

  00166	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0016e	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00173	51		 push	 ecx
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	51		 push	 ecx
  0017a	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _f$2[ebp]
  0017f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00184	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00189	83 c4 08	 add	 esp, 8
  0018c	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv255[ebp]
  00192	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019a	f3 0f 5c 85 08
	ff ff ff	 subss	 xmm0, DWORD PTR tv255[ebp]
  001a2	f3 0f 59 45 28	 mulss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  001a7	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR tv258[ebp], xmm0
  001af	d9 85 04 ff ff
	ff		 fld	 DWORD PTR tv258[ebp]
  001b5	e9 fc 00 00 00	 jmp	 $LN1@SliderCalc

; 2294 :         }

  001ba	e9 af 00 00 00	 jmp	 $LN5@SliderCalc
$LN4@SliderCalc:

; 2295 :         else
; 2296 :         {
; 2297 :             const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

  001bf	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  001c2	50		 push	 eax
  001c3	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  001c6	51		 push	 ecx
  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	e8 00 00 00 00	 call	 ??$ImMax@_K@@YA_K_K0@Z	; ImMax<unsigned __int64>
  001d0	83 c4 10	 add	 esp, 16			; 00000010H
  001d3	8b 75 e8	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  001d6	2b f0		 sub	 esi, eax
  001d8	8b 7d ec	 mov	 edi, DWORD PTR _v_clamped$[ebp+4]
  001db	1b fa		 sbb	 edi, edx
  001dd	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  001e0	52		 push	 edx
  001e1	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  001e4	50		 push	 eax
  001e5	6a 00		 push	 0
  001e7	6a 00		 push	 0
  001e9	e8 00 00 00 00	 call	 ??$ImMax@_K@@YA_K_K0@Z	; ImMax<unsigned __int64>
  001ee	83 c4 10	 add	 esp, 16			; 00000010H
  001f1	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  001f4	2b c8		 sub	 ecx, eax
  001f6	8b 45 20	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  001f9	1b c2		 sbb	 eax, edx
  001fb	50		 push	 eax
  001fc	51		 push	 ecx
  001fd	57		 push	 edi
  001fe	56		 push	 esi
  001ff	e8 00 00 00 00	 call	 __aulldiv
  00204	8b c8		 mov	 ecx, eax
  00206	e8 00 00 00 00	 call	 __ultod3
  0020b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0020f	f3 0f 11 45 d0	 movss	 DWORD PTR _f$1[ebp], xmm0

; 2298 :             return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);

  00214	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0021c	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00221	51		 push	 ecx
  00222	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00227	51		 push	 ecx
  00228	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _f$1[ebp]
  0022d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00232	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00237	83 c4 08	 add	 esp, 8
  0023a	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv314[ebp]
  00240	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR tv314[ebp]
  00248	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00250	f3 0f 5c 4d 28	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  00255	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00259	f3 0f 58 45 28	 addss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0025e	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR tv318[ebp], xmm0
  00266	d9 85 04 ff ff
	ff		 fld	 DWORD PTR tv318[ebp]
  0026c	eb 48		 jmp	 SHORT $LN1@SliderCalc
$LN5@SliderCalc:

; 2299 :         }
; 2300 :     }
; 2301 : 
; 2302 :     // Linear slider
; 2303 :     return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

  0026e	8b 4d e8	 mov	 ecx, DWORD PTR _v_clamped$[ebp]
  00271	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00274	8b 55 ec	 mov	 edx, DWORD PTR _v_clamped$[ebp+4]
  00277	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0027a	e8 00 00 00 00	 call	 __ultod3
  0027f	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00282	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00285	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00288	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0028b	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv340[ebp], xmm0
  00293	e8 00 00 00 00	 call	 __ultod3
  00298	f2 0f 10 8d 04
	ff ff ff	 movsd	 xmm1, QWORD PTR tv340[ebp]
  002a0	f2 0f 5e c8	 divsd	 xmm1, xmm0
  002a4	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  002a8	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv337[ebp], xmm0
  002b0	d9 85 00 ff ff
	ff		 fld	 DWORD PTR tv337[ebp]
$LN1@SliderCalc:

; 2304 : }

  002b6	5f		 pop	 edi
  002b7	5e		 pop	 esi
  002b8	5b		 pop	 ebx
  002b9	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  002bf	3b ec		 cmp	 ebp, esp
  002c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c6	8b e5		 mov	 esp, ebp
  002c8	5d		 pop	 ebp
  002c9	c3		 ret	 0
??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ENDP ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@_J@@YA_J_J0@Z
_TEXT	SEGMENT
tv65 = -200						; size = 8
_lhs$ = 8						; size = 8
_rhs$ = 16						; size = 8
??$ImMax@_J@@YA_J_J0@Z PROC				; ImMax<__int64>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _rhs$[ebp+4]
  0002e	7c 1e		 jl	 SHORT $LN3@ImMax
  00030	7f 08		 jg	 SHORT $LN5@ImMax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00035	3b 4d 10	 cmp	 ecx, DWORD PTR _rhs$[ebp]
  00038	72 14		 jb	 SHORT $LN3@ImMax
$LN5@ImMax:
  0003a	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003d	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
  00043	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], eax
  0004c	eb 12		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00051	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00057	8b 55 14	 mov	 edx, DWORD PTR _rhs$[ebp+4]
  0005a	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], edx
$LN4@ImMax:
  00060	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00066	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp+4]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
??$ImMax@_J@@YA_J_J0@Z ENDP				; ImMax<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@_J@@YA_J_J0M@Z
_TEXT	SEGMENT
tv94 = -196						; size = 4
_a$ = 8							; size = 8
_b$ = 16						; size = 8
_t$ = 24						; size = 4
??$ImLerp@_J@@YA_J_J0M@Z PROC				; ImLerp<__int64>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	e8 00 00 00 00	 call	 __ltod3
  00033	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _b$[ebp]
  0003a	2b 4d 08	 sub	 ecx, DWORD PTR _a$[ebp]
  0003d	8b 55 14	 mov	 edx, DWORD PTR _b$[ebp+4]
  00040	1b 55 0c	 sbb	 edx, DWORD PTR _a$[ebp+4]
  00043	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv94[ebp], xmm0
  0004b	e8 00 00 00 00	 call	 __ltod3
  00050	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00054	f3 0f 59 45 18	 mulss	 xmm0, DWORD PTR _t$[ebp]
  00059	f3 0f 10 8d 3c
	ff ff ff	 movss	 xmm1, DWORD PTR tv94[ebp]
  00061	f3 0f 58 c8	 addss	 xmm1, xmm0
  00065	0f 28 c1	 movaps	 xmm0, xmm1
  00068	e8 00 00 00 00	 call	 __ftol3
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
??$ImLerp@_J@@YA_J_J0M@Z ENDP				; ImLerp<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMin@_J@@YA_J_J0@Z
_TEXT	SEGMENT
tv65 = -200						; size = 8
_lhs$ = 8						; size = 8
_rhs$ = 16						; size = 8
??$ImMin@_J@@YA_J_J0@Z PROC				; ImMin<__int64>, COMDAT

; 314  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _rhs$[ebp+4]
  0002e	7f 1e		 jg	 SHORT $LN3@ImMin
  00030	7c 08		 jl	 SHORT $LN5@ImMin
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00035	3b 4d 10	 cmp	 ecx, DWORD PTR _rhs$[ebp]
  00038	73 14		 jae	 SHORT $LN3@ImMin
$LN5@ImMin:
  0003a	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003d	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
  00043	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp+4]
  00046	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], eax
  0004c	eb 12		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00051	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00057	8b 55 14	 mov	 edx, DWORD PTR _rhs$[ebp+4]
  0005a	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp+4], edx
$LN4@ImMin:
  00060	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00066	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp+4]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
??$ImMin@_J@@YA_J_J0@Z ENDP				; ImMin<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z
_TEXT	SEGMENT
tv337 = -256						; size = 4
tv340 = -252						; size = 8
tv318 = -252						; size = 4
tv258 = -252						; size = 4
tv78 = -252						; size = 8
tv314 = -248						; size = 4
tv255 = -248						; size = 4
tv68 = -245						; size = 1
_f$1 = -48						; size = 4
_f$2 = -36						; size = 4
_v_clamped$ = -24					; size = 8
_is_power$ = -5						; size = 1
_data_type$ = 8						; size = 4
_v$ = 12						; size = 8
_v_min$ = 20						; size = 8
_v_max$ = 28						; size = 8
_power$ = 36						; size = 4
_linear_zero_pos$ = 40					; size = 4
??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z PROC ; ImGui::SliderCalcRatioFromValueT<__int64,double>, COMDAT

; 2282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2283 :     if (v_min == v_max)

  00028	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  0002b	3b 45 1c	 cmp	 eax, DWORD PTR _v_max$[ebp]
  0002e	75 0f		 jne	 SHORT $LN2@SliderCalc
  00030	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00033	3b 4d 20	 cmp	 ecx, DWORD PTR _v_max$[ebp+4]
  00036	75 07		 jne	 SHORT $LN2@SliderCalc

; 2284 :         return 0.0f;

  00038	d9 ee		 fldz
  0003a	e9 77 02 00 00	 jmp	 $LN1@SliderCalc
$LN2@SliderCalc:

; 2285 : 
; 2286 :     const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

  0003f	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00044	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0004b	9f		 lahf
  0004c	f6 c4 44	 test	 ah, 68			; 00000044H
  0004f	7b 15		 jnp	 SHORT $LN8@SliderCalc
  00051	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00055	74 06		 je	 SHORT $LN7@SliderCalc
  00057	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  0005b	75 09		 jne	 SHORT $LN8@SliderCalc
$LN7@SliderCalc:
  0005d	c6 85 0b ff ff
	ff 01		 mov	 BYTE PTR tv68[ebp], 1
  00064	eb 07		 jmp	 SHORT $LN9@SliderCalc
$LN8@SliderCalc:
  00066	c6 85 0b ff ff
	ff 00		 mov	 BYTE PTR tv68[ebp], 0
$LN9@SliderCalc:
  0006d	8a 85 0b ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00073	88 45 fb	 mov	 BYTE PTR _is_power$[ebp], al

; 2287 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

  00076	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00079	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  0007c	7f 38		 jg	 SHORT $LN10@SliderCalc
  0007e	7c 08		 jl	 SHORT $LN12@SliderCalc
  00080	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00083	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  00086	73 2e		 jae	 SHORT $LN10@SliderCalc
$LN12@SliderCalc:
  00088	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  0008b	52		 push	 edx
  0008c	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00093	51		 push	 ecx
  00094	8b 55 14	 mov	 edx, DWORD PTR _v_min$[ebp]
  00097	52		 push	 edx
  00098	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp+4]
  0009b	50		 push	 eax
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ??$ImClamp@_J@@YA_J_J00@Z ; ImClamp<__int64>
  000a5	83 c4 18	 add	 esp, 24			; 00000018H
  000a8	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  000ae	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv78[ebp+4], edx
  000b4	eb 2c		 jmp	 SHORT $LN11@SliderCalc
$LN10@SliderCalc:
  000b6	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  000b9	52		 push	 edx
  000ba	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp+4]
  000c1	51		 push	 ecx
  000c2	8b 55 1c	 mov	 edx, DWORD PTR _v_max$[ebp]
  000c5	52		 push	 edx
  000c6	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp+4]
  000c9	50		 push	 eax
  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ??$ImClamp@_J@@YA_J_J00@Z ; ImClamp<__int64>
  000d3	83 c4 18	 add	 esp, 24			; 00000018H
  000d6	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  000dc	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv78[ebp+4], edx
$LN11@SliderCalc:
  000e2	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  000e8	89 55 e8	 mov	 DWORD PTR _v_clamped$[ebp], edx
  000eb	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp+4]
  000f1	89 45 ec	 mov	 DWORD PTR _v_clamped$[ebp+4], eax

; 2288 :     if (is_power)

  000f4	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  000f8	85 c0		 test	 eax, eax
  000fa	0f 84 6e 01 00
	00		 je	 $LN5@SliderCalc

; 2289 :     {
; 2290 :         if (v_clamped < 0.0f)

  00100	8b 55 ec	 mov	 edx, DWORD PTR _v_clamped$[ebp+4]
  00103	8b 4d e8	 mov	 ecx, DWORD PTR _v_clamped$[ebp]
  00106	e8 00 00 00 00	 call	 __ltod3
  0010b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0010f	0f 57 c9	 xorps	 xmm1, xmm1
  00112	0f 2f c8	 comiss	 xmm1, xmm0
  00115	0f 86 a4 00 00
	00		 jbe	 $LN4@SliderCalc

; 2291 :         {
; 2292 :             const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

  0011b	8b 75 e8	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  0011e	2b 75 14	 sub	 esi, DWORD PTR _v_min$[ebp]
  00121	8b 7d ec	 mov	 edi, DWORD PTR _v_clamped$[ebp+4]
  00124	1b 7d 18	 sbb	 edi, DWORD PTR _v_min$[ebp+4]
  00127	8b 45 20	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  0012a	50		 push	 eax
  0012b	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0012e	51		 push	 ecx
  0012f	6a 00		 push	 0
  00131	6a 00		 push	 0
  00133	e8 00 00 00 00	 call	 ??$ImMin@_J@@YA_J_J0@Z	; ImMin<__int64>
  00138	83 c4 10	 add	 esp, 16			; 00000010H
  0013b	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  0013e	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00141	52		 push	 edx
  00142	50		 push	 eax
  00143	57		 push	 edi
  00144	56		 push	 esi
  00145	e8 00 00 00 00	 call	 __alldiv
  0014a	8b c8		 mov	 ecx, eax
  0014c	e8 00 00 00 00	 call	 __ltod3
  00151	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00155	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0015d	f3 0f 5c c8	 subss	 xmm1, xmm0
  00161	f3 0f 11 4d dc	 movss	 DWORD PTR _f$2[ebp], xmm1

; 2293 :             return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;

  00166	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0016e	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00173	51		 push	 ecx
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	51		 push	 ecx
  0017a	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _f$2[ebp]
  0017f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00184	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00189	83 c4 08	 add	 esp, 8
  0018c	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv255[ebp]
  00192	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019a	f3 0f 5c 85 08
	ff ff ff	 subss	 xmm0, DWORD PTR tv255[ebp]
  001a2	f3 0f 59 45 28	 mulss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  001a7	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR tv258[ebp], xmm0
  001af	d9 85 04 ff ff
	ff		 fld	 DWORD PTR tv258[ebp]
  001b5	e9 fc 00 00 00	 jmp	 $LN1@SliderCalc

; 2294 :         }

  001ba	e9 af 00 00 00	 jmp	 $LN5@SliderCalc
$LN4@SliderCalc:

; 2295 :         else
; 2296 :         {
; 2297 :             const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

  001bf	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  001c2	50		 push	 eax
  001c3	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  001c6	51		 push	 ecx
  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	e8 00 00 00 00	 call	 ??$ImMax@_J@@YA_J_J0@Z	; ImMax<__int64>
  001d0	83 c4 10	 add	 esp, 16			; 00000010H
  001d3	8b 75 e8	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  001d6	2b f0		 sub	 esi, eax
  001d8	8b 7d ec	 mov	 edi, DWORD PTR _v_clamped$[ebp+4]
  001db	1b fa		 sbb	 edi, edx
  001dd	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  001e0	52		 push	 edx
  001e1	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  001e4	50		 push	 eax
  001e5	6a 00		 push	 0
  001e7	6a 00		 push	 0
  001e9	e8 00 00 00 00	 call	 ??$ImMax@_J@@YA_J_J0@Z	; ImMax<__int64>
  001ee	83 c4 10	 add	 esp, 16			; 00000010H
  001f1	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  001f4	2b c8		 sub	 ecx, eax
  001f6	8b 45 20	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  001f9	1b c2		 sbb	 eax, edx
  001fb	50		 push	 eax
  001fc	51		 push	 ecx
  001fd	57		 push	 edi
  001fe	56		 push	 esi
  001ff	e8 00 00 00 00	 call	 __alldiv
  00204	8b c8		 mov	 ecx, eax
  00206	e8 00 00 00 00	 call	 __ltod3
  0020b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0020f	f3 0f 11 45 d0	 movss	 DWORD PTR _f$1[ebp], xmm0

; 2298 :             return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);

  00214	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0021c	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00221	51		 push	 ecx
  00222	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00227	51		 push	 ecx
  00228	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _f$1[ebp]
  0022d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00232	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00237	83 c4 08	 add	 esp, 8
  0023a	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv314[ebp]
  00240	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR tv314[ebp]
  00248	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00250	f3 0f 5c 4d 28	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  00255	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00259	f3 0f 58 45 28	 addss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0025e	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR tv318[ebp], xmm0
  00266	d9 85 04 ff ff
	ff		 fld	 DWORD PTR tv318[ebp]
  0026c	eb 48		 jmp	 SHORT $LN1@SliderCalc
$LN5@SliderCalc:

; 2299 :         }
; 2300 :     }
; 2301 : 
; 2302 :     // Linear slider
; 2303 :     return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

  0026e	8b 4d e8	 mov	 ecx, DWORD PTR _v_clamped$[ebp]
  00271	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00274	8b 55 ec	 mov	 edx, DWORD PTR _v_clamped$[ebp+4]
  00277	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0027a	e8 00 00 00 00	 call	 __ltod3
  0027f	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00282	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00285	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00288	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0028b	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv340[ebp], xmm0
  00293	e8 00 00 00 00	 call	 __ltod3
  00298	f2 0f 10 8d 04
	ff ff ff	 movsd	 xmm1, QWORD PTR tv340[ebp]
  002a0	f2 0f 5e c8	 divsd	 xmm1, xmm0
  002a4	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  002a8	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv337[ebp], xmm0
  002b0	d9 85 00 ff ff
	ff		 fld	 DWORD PTR tv337[ebp]
$LN1@SliderCalc:

; 2304 : }

  002b6	5f		 pop	 edi
  002b7	5e		 pop	 esi
  002b8	5b		 pop	 ebx
  002b9	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  002bf	3b ec		 cmp	 ebp, esp
  002c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c6	8b e5		 mov	 esp, ebp
  002c8	5d		 pop	 ebp
  002c9	c3		 ret	 0
??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ENDP ; ImGui::SliderCalcRatioFromValueT<__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@I@@YAIII@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMax@I@@YAIII@Z PROC				; ImMax<unsigned int>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _rhs$[ebp]
  0002e	72 0b		 jb	 SHORT $LN3@ImMax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00033	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00039	eb 09		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _rhs$[ebp]
  0003e	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
$LN4@ImMax:
  00044	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImMax@I@@YAIII@Z ENDP				; ImMax<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@I@@YAIIIM@Z
_TEXT	SEGMENT
tv85 = -216						; size = 8
tv82 = -208						; size = 4
tv76 = -204						; size = 8
tv72 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_t$ = 16						; size = 4
??$ImLerp@I@@YAIIIM@Z PROC				; ImLerp<unsigned int>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002b	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00031	f2 0f 2a 85 3c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv72[ebp]
  00039	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  0003f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00042	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  0004b	f2 0f 11 85 34
	ff ff ff	 movsd	 QWORD PTR tv76[ebp], xmm0
  00053	f2 0f 5a 85 34
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv76[ebp]
  0005b	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  0005e	2b 55 08	 sub	 edx, DWORD PTR _a$[ebp]
  00061	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv82[ebp], edx
  00067	f2 0f 2a 8d 30
	ff ff ff	 cvtsi2sd xmm1, DWORD PTR tv82[ebp]
  0006f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv82[ebp]
  00075	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00078	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00081	f2 0f 11 8d 28
	ff ff ff	 movsd	 QWORD PTR tv85[ebp], xmm1
  00089	f2 0f 5a 8d 28
	ff ff ff	 cvtsd2ss xmm1, QWORD PTR tv85[ebp]
  00091	f3 0f 59 4d 10	 mulss	 xmm1, DWORD PTR _t$[ebp]
  00096	f3 0f 58 c1	 addss	 xmm0, xmm1
  0009a	e8 00 00 00 00	 call	 __ftoui3
  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
??$ImLerp@I@@YAIIIM@Z ENDP				; ImLerp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z
_TEXT	SEGMENT
tv259 = -268						; size = 4
tv254 = -264						; size = 8
tv251 = -256						; size = 4
tv245 = -252						; size = 8
tv223 = -252						; size = 8
tv193 = -252						; size = 8
tv178 = -252						; size = 8
tv238 = -248						; size = 4
tv208 = -248						; size = 4
tv242 = -244						; size = 4
tv234 = -244						; size = 4
tv220 = -244						; size = 4
tv205 = -244						; size = 4
tv190 = -244						; size = 4
tv174 = -244						; size = 4
tv78 = -244						; size = 4
tv68 = -241						; size = 1
_f$1 = -44						; size = 4
_f$2 = -32						; size = 4
_v_clamped$ = -20					; size = 4
_is_power$ = -5						; size = 1
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_power$ = 24						; size = 4
_linear_zero_pos$ = 28					; size = 4
??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<unsigned int,float>, COMDAT

; 2282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2283 :     if (v_min == v_max)

  00028	8b 45 10	 mov	 eax, DWORD PTR _v_min$[ebp]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _v_max$[ebp]
  0002e	75 07		 jne	 SHORT $LN2@SliderCalc

; 2284 :         return 0.0f;

  00030	d9 ee		 fldz
  00032	e9 bb 02 00 00	 jmp	 $LN1@SliderCalc
$LN2@SliderCalc:

; 2285 : 
; 2286 :     const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

  00037	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _power$[ebp]
  0003c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  00043	9f		 lahf
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7b 15		 jnp	 SHORT $LN8@SliderCalc
  00049	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0004d	74 06		 je	 SHORT $LN7@SliderCalc
  0004f	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00053	75 09		 jne	 SHORT $LN8@SliderCalc
$LN7@SliderCalc:
  00055	c6 85 0f ff ff
	ff 01		 mov	 BYTE PTR tv68[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN9@SliderCalc
$LN8@SliderCalc:
  0005e	c6 85 0f ff ff
	ff 00		 mov	 BYTE PTR tv68[ebp], 0
$LN9@SliderCalc:
  00065	8a 85 0f ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  0006b	88 45 fb	 mov	 BYTE PTR _is_power$[ebp], al

; 2287 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

  0006e	8b 45 10	 mov	 eax, DWORD PTR _v_min$[ebp]
  00071	3b 45 14	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00074	73 1c		 jae	 SHORT $LN10@SliderCalc
  00076	8b 4d 14	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 10	 mov	 edx, DWORD PTR _v_min$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$ImClamp@I@@YAIIII@Z	; ImClamp<unsigned int>
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00090	eb 1a		 jmp	 SHORT $LN11@SliderCalc
$LN10@SliderCalc:
  00092	8b 4d 10	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00095	51		 push	 ecx
  00096	8b 55 14	 mov	 edx, DWORD PTR _v_max$[ebp]
  00099	52		 push	 edx
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ??$ImClamp@I@@YAIIII@Z	; ImClamp<unsigned int>
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
$LN11@SliderCalc:
  000ac	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  000b2	89 4d ec	 mov	 DWORD PTR _v_clamped$[ebp], ecx

; 2288 :     if (is_power)

  000b5	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	0f 84 b3 01 00
	00		 je	 $LN5@SliderCalc

; 2289 :     {
; 2290 :         if (v_clamped < 0.0f)

  000c1	8b 45 ec	 mov	 eax, DWORD PTR _v_clamped$[ebp]
  000c4	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  000ca	f2 0f 2a 85 0c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv174[ebp]
  000d2	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv174[ebp]
  000d8	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000db	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  000e4	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv178[ebp], xmm0
  000ec	f2 0f 5a 85 04
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv178[ebp]
  000f4	0f 57 c9	 xorps	 xmm1, xmm1
  000f7	0f 2f c8	 comiss	 xmm1, xmm0
  000fa	0f 86 b9 00 00
	00		 jbe	 $LN4@SliderCalc

; 2291 :         {
; 2292 :             const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

  00100	8b 75 ec	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  00103	2b 75 10	 sub	 esi, DWORD PTR _v_min$[ebp]
  00106	8b 45 14	 mov	 eax, DWORD PTR _v_max$[ebp]
  00109	50		 push	 eax
  0010a	6a 00		 push	 0
  0010c	e8 00 00 00 00	 call	 ??$ImMin@I@@YAIII@Z	; ImMin<unsigned int>
  00111	83 c4 08	 add	 esp, 8
  00114	8b c8		 mov	 ecx, eax
  00116	2b 4d 10	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00119	8b c6		 mov	 eax, esi
  0011b	33 d2		 xor	 edx, edx
  0011d	f7 f1		 div	 ecx
  0011f	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv190[ebp], eax
  00125	f2 0f 2a 85 0c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv190[ebp]
  0012d	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv190[ebp]
  00133	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  00136	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  0013f	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv193[ebp], xmm0
  00147	f2 0f 5a 85 04
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv193[ebp]
  0014f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00157	f3 0f 5c c8	 subss	 xmm1, xmm0
  0015b	f3 0f 11 4d e0	 movss	 DWORD PTR _f$2[ebp], xmm1

; 2293 :             return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;

  00160	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00168	f3 0f 5e 45 18	 divss	 xmm0, DWORD PTR _power$[ebp]
  0016d	51		 push	 ecx
  0016e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00173	51		 push	 ecx
  00174	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _f$2[ebp]
  00179	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017e	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00183	83 c4 08	 add	 esp, 8
  00186	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv205[ebp]
  0018c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00194	f3 0f 5c 85 0c
	ff ff ff	 subss	 xmm0, DWORD PTR tv205[ebp]
  0019c	f3 0f 59 45 1c	 mulss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  001a1	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv208[ebp], xmm0
  001a9	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv208[ebp]
  001af	e9 3e 01 00 00	 jmp	 $LN1@SliderCalc

; 2294 :         }

  001b4	e9 bb 00 00 00	 jmp	 $LN5@SliderCalc
$LN4@SliderCalc:

; 2295 :         else
; 2296 :         {
; 2297 :             const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

  001b9	8b 45 10	 mov	 eax, DWORD PTR _v_min$[ebp]
  001bc	50		 push	 eax
  001bd	6a 00		 push	 0
  001bf	e8 00 00 00 00	 call	 ??$ImMax@I@@YAIII@Z	; ImMax<unsigned int>
  001c4	83 c4 08	 add	 esp, 8
  001c7	8b 75 ec	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  001ca	2b f0		 sub	 esi, eax
  001cc	8b 4d 10	 mov	 ecx, DWORD PTR _v_min$[ebp]
  001cf	51		 push	 ecx
  001d0	6a 00		 push	 0
  001d2	e8 00 00 00 00	 call	 ??$ImMax@I@@YAIII@Z	; ImMax<unsigned int>
  001d7	83 c4 08	 add	 esp, 8
  001da	8b 4d 14	 mov	 ecx, DWORD PTR _v_max$[ebp]
  001dd	2b c8		 sub	 ecx, eax
  001df	8b c6		 mov	 eax, esi
  001e1	33 d2		 xor	 edx, edx
  001e3	f7 f1		 div	 ecx
  001e5	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv220[ebp], eax
  001eb	f2 0f 2a 85 0c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv220[ebp]
  001f3	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  001f9	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  001fc	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  00205	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv223[ebp], xmm0
  0020d	f2 0f 5a 85 04
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv223[ebp]
  00215	f3 0f 11 45 d4	 movss	 DWORD PTR _f$1[ebp], xmm0

; 2298 :             return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);

  0021a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00222	f3 0f 5e 45 18	 divss	 xmm0, DWORD PTR _power$[ebp]
  00227	51		 push	 ecx
  00228	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022d	51		 push	 ecx
  0022e	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f$1[ebp]
  00233	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00238	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0023d	83 c4 08	 add	 esp, 8
  00240	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv234[ebp]
  00246	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR tv234[ebp]
  0024e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00256	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  0025b	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0025f	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00264	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv238[ebp], xmm0
  0026c	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv238[ebp]
  00272	eb 7e		 jmp	 SHORT $LN1@SliderCalc
$LN5@SliderCalc:

; 2299 :         }
; 2300 :     }
; 2301 : 
; 2302 :     // Linear slider
; 2303 :     return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

  00274	8b 45 ec	 mov	 eax, DWORD PTR _v_clamped$[ebp]
  00277	2b 45 10	 sub	 eax, DWORD PTR _v_min$[ebp]
  0027a	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv242[ebp], eax
  00280	f2 0f 2a 85 0c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv242[ebp]
  00288	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv242[ebp]
  0028e	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00291	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  0029a	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv245[ebp], xmm0
  002a2	f2 0f 5a 85 04
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv245[ebp]
  002aa	8b 55 14	 mov	 edx, DWORD PTR _v_max$[ebp]
  002ad	2b 55 10	 sub	 edx, DWORD PTR _v_min$[ebp]
  002b0	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv251[ebp], edx
  002b6	f2 0f 2a 8d 00
	ff ff ff	 cvtsi2sd xmm1, DWORD PTR tv251[ebp]
  002be	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv251[ebp]
  002c4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002c7	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  002d0	f2 0f 11 8d f8
	fe ff ff	 movsd	 QWORD PTR tv254[ebp], xmm1
  002d8	f2 0f 5a 8d f8
	fe ff ff	 cvtsd2ss xmm1, QWORD PTR tv254[ebp]
  002e0	f3 0f 5e c1	 divss	 xmm0, xmm1
  002e4	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR tv259[ebp], xmm0
  002ec	d9 85 f4 fe ff
	ff		 fld	 DWORD PTR tv259[ebp]
$LN1@SliderCalc:

; 2304 : }

  002f2	5f		 pop	 edi
  002f3	5e		 pop	 esi
  002f4	5b		 pop	 ebx
  002f5	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  002fb	3b ec		 cmp	 ebp, esp
  002fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z
_TEXT	SEGMENT
tv215 = -248						; size = 4
tv192 = -248						; size = 4
tv220 = -244						; size = 4
tv211 = -244						; size = 4
tv189 = -244						; size = 4
tv78 = -244						; size = 4
tv68 = -241						; size = 1
_f$1 = -44						; size = 4
_f$2 = -32						; size = 4
_v_clamped$ = -20					; size = 4
_is_power$ = -5						; size = 1
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_power$ = 24						; size = 4
_linear_zero_pos$ = 28					; size = 4
??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z PROC	; ImGui::SliderCalcRatioFromValueT<int,float>, COMDAT

; 2282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2283 :     if (v_min == v_max)

  00028	8b 45 10	 mov	 eax, DWORD PTR _v_min$[ebp]
  0002b	3b 45 14	 cmp	 eax, DWORD PTR _v_max$[ebp]
  0002e	75 07		 jne	 SHORT $LN2@SliderCalc

; 2284 :         return 0.0f;

  00030	d9 ee		 fldz
  00032	e9 db 01 00 00	 jmp	 $LN1@SliderCalc
$LN2@SliderCalc:

; 2285 : 
; 2286 :     const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);

  00037	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _power$[ebp]
  0003c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  00043	9f		 lahf
  00044	f6 c4 44	 test	 ah, 68			; 00000044H
  00047	7b 15		 jnp	 SHORT $LN8@SliderCalc
  00049	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0004d	74 06		 je	 SHORT $LN7@SliderCalc
  0004f	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00053	75 09		 jne	 SHORT $LN8@SliderCalc
$LN7@SliderCalc:
  00055	c6 85 0f ff ff
	ff 01		 mov	 BYTE PTR tv68[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN9@SliderCalc
$LN8@SliderCalc:
  0005e	c6 85 0f ff ff
	ff 00		 mov	 BYTE PTR tv68[ebp], 0
$LN9@SliderCalc:
  00065	8a 85 0f ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  0006b	88 45 fb	 mov	 BYTE PTR _is_power$[ebp], al

; 2287 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

  0006e	8b 45 10	 mov	 eax, DWORD PTR _v_min$[ebp]
  00071	3b 45 14	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00074	7d 1c		 jge	 SHORT $LN10@SliderCalc
  00076	8b 4d 14	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 10	 mov	 edx, DWORD PTR _v_min$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00090	eb 1a		 jmp	 SHORT $LN11@SliderCalc
$LN10@SliderCalc:
  00092	8b 4d 10	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00095	51		 push	 ecx
  00096	8b 55 14	 mov	 edx, DWORD PTR _v_max$[ebp]
  00099	52		 push	 edx
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
$LN11@SliderCalc:
  000ac	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  000b2	89 4d ec	 mov	 DWORD PTR _v_clamped$[ebp], ecx

; 2288 :     if (is_power)

  000b5	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	0f 84 2b 01 00
	00		 je	 $LN5@SliderCalc

; 2289 :     {
; 2290 :         if (v_clamped < 0.0f)

  000c1	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _v_clamped$[ebp]
  000c6	0f 57 c9	 xorps	 xmm1, xmm1
  000c9	0f 2f c8	 comiss	 xmm1, xmm0
  000cc	0f 86 8c 00 00
	00		 jbe	 $LN4@SliderCalc

; 2291 :         {
; 2292 :             const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));

  000d2	8b 75 ec	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  000d5	2b 75 10	 sub	 esi, DWORD PTR _v_min$[ebp]
  000d8	8b 45 14	 mov	 eax, DWORD PTR _v_max$[ebp]
  000db	50		 push	 eax
  000dc	6a 00		 push	 0
  000de	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  000e3	83 c4 08	 add	 esp, 8
  000e6	8b c8		 mov	 ecx, eax
  000e8	2b 4d 10	 sub	 ecx, DWORD PTR _v_min$[ebp]
  000eb	8b c6		 mov	 eax, esi
  000ed	99		 cdq
  000ee	f7 f9		 idiv	 ecx
  000f0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000f4	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  000fc	f3 0f 5c c8	 subss	 xmm1, xmm0
  00100	f3 0f 11 4d e0	 movss	 DWORD PTR _f$2[ebp], xmm1

; 2293 :             return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;

  00105	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0010d	f3 0f 5e 45 18	 divss	 xmm0, DWORD PTR _power$[ebp]
  00112	51		 push	 ecx
  00113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00118	51		 push	 ecx
  00119	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _f$2[ebp]
  0011e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00123	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00128	83 c4 08	 add	 esp, 8
  0012b	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv189[ebp]
  00131	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00139	f3 0f 5c 85 0c
	ff ff ff	 subss	 xmm0, DWORD PTR tv189[ebp]
  00141	f3 0f 59 45 1c	 mulss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00146	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv192[ebp], xmm0
  0014e	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv192[ebp]
  00154	e9 b9 00 00 00	 jmp	 $LN1@SliderCalc

; 2294 :         }

  00159	e9 8e 00 00 00	 jmp	 $LN5@SliderCalc
$LN4@SliderCalc:

; 2295 :         else
; 2296 :         {
; 2297 :             const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));

  0015e	8b 45 10	 mov	 eax, DWORD PTR _v_min$[ebp]
  00161	50		 push	 eax
  00162	6a 00		 push	 0
  00164	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  00169	83 c4 08	 add	 esp, 8
  0016c	8b 75 ec	 mov	 esi, DWORD PTR _v_clamped$[ebp]
  0016f	2b f0		 sub	 esi, eax
  00171	8b 4d 10	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00174	51		 push	 ecx
  00175	6a 00		 push	 0
  00177	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  0017c	83 c4 08	 add	 esp, 8
  0017f	8b 4d 14	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00182	2b c8		 sub	 ecx, eax
  00184	8b c6		 mov	 eax, esi
  00186	99		 cdq
  00187	f7 f9		 idiv	 ecx
  00189	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0018d	f3 0f 11 45 d4	 movss	 DWORD PTR _f$1[ebp], xmm0

; 2298 :             return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);

  00192	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019a	f3 0f 5e 45 18	 divss	 xmm0, DWORD PTR _power$[ebp]
  0019f	51		 push	 ecx
  001a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a5	51		 push	 ecx
  001a6	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f$1[ebp]
  001ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b0	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  001b5	83 c4 08	 add	 esp, 8
  001b8	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR tv211[ebp]
  001be	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR tv211[ebp]
  001c6	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  001ce	f3 0f 5c 4d 1c	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  001d3	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001d7	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  001dc	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv215[ebp], xmm0
  001e4	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv215[ebp]
  001ea	eb 26		 jmp	 SHORT $LN1@SliderCalc
$LN5@SliderCalc:

; 2299 :         }
; 2300 :     }
; 2301 : 
; 2302 :     // Linear slider
; 2303 :     return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));

  001ec	8b 45 ec	 mov	 eax, DWORD PTR _v_clamped$[ebp]
  001ef	2b 45 10	 sub	 eax, DWORD PTR _v_min$[ebp]
  001f2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f6	8b 4d 14	 mov	 ecx, DWORD PTR _v_max$[ebp]
  001f9	2b 4d 10	 sub	 ecx, DWORD PTR _v_min$[ebp]
  001fc	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00200	f3 0f 5e c1	 divss	 xmm0, xmm1
  00204	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR tv220[ebp], xmm0
  0020c	d9 85 0c ff ff
	ff		 fld	 DWORD PTR tv220[ebp]
$LN1@SliderCalc:

; 2304 : }

  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	5b		 pop	 ebx
  00215	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  0021b	3b ec		 cmp	 ebp, esp
  0021d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ENDP	; ImGui::SliderCalcRatioFromValueT<int,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@NN@ImGui@@YANPBDHN@Z
_TEXT	SEGMENT
_p$ = -96						; size = 4
_v_str$ = -84						; size = 64
_fmt_start$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_data_type$ = 12					; size = 4
_v$ = 16						; size = 8
??$RoundScalarWithFormatT@NN@ImGui@@YANPBDHN@Z PROC	; ImGui::RoundScalarWithFormatT<double,double>, COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1884 :     const char* fmt_start = ImParseFormatFindStart(format);

  00032	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 1885 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0004c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00050	83 f8 25	 cmp	 eax, 37			; 00000025H
  00053	75 14		 jne	 SHORT $LN5@RoundScala
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 00	 shl	 eax, 0
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00060	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00064	83 fa 25	 cmp	 edx, 37			; 00000025H
  00067	75 05		 jne	 SHORT $LN4@RoundScala
$LN5@RoundScala:

; 1886 :         return v;

  00069	dd 45 10	 fld	 QWORD PTR _v$[ebp]
  0006c	eb 6b		 jmp	 SHORT $LN1@RoundScala
$LN4@RoundScala:

; 1887 :     char v_str[64];
; 1888 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

  0006e	83 ec 08	 sub	 esp, 8
  00071	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _v$[ebp]
  00076	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007b	8b 45 f4	 mov	 eax, DWORD PTR _fmt_start$[ebp]
  0007e	50		 push	 eax
  0007f	6a 40		 push	 64			; 00000040H
  00081	8d 4d ac	 lea	 ecx, DWORD PTR _v_str$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0008a	83 c4 14	 add	 esp, 20			; 00000014H

; 1889 :     const char* p = v_str;

  0008d	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  00090	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
$LN2@RoundScala:

; 1890 :     while (*p == ' ')

  00093	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  00096	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00099	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009c	75 0b		 jne	 SHORT $LN3@RoundScala

; 1891 :         p++;

  0009e	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
  000a7	eb ea		 jmp	 SHORT $LN2@RoundScala
$LN3@RoundScala:

; 1892 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

  000a9	83 7d 0c 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  000ad	74 06		 je	 SHORT $LN8@RoundScala
  000af	83 7d 0c 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000b3	75 11		 jne	 SHORT $LN6@RoundScala
$LN8@RoundScala:

; 1893 :         v = (TYPE)ImAtof(p);

  000b5	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?ImAtof@@YANPBD@Z	; ImAtof
  000be	83 c4 04	 add	 esp, 4
  000c1	dd 5d 10	 fstp	 QWORD PTR _v$[ebp]
  000c4	eb 10		 jmp	 SHORT $LN7@RoundScala
$LN6@RoundScala:

; 1894 :     else
; 1895 :         ImAtoi(p, (SIGNEDTYPE*)&v);

  000c6	8d 45 10	 lea	 eax, DWORD PTR _v$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d a0	 mov	 ecx, DWORD PTR _p$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ??$ImAtoi@N@@YAPBDPBDPAN@Z ; ImAtoi<double>
  000d3	83 c4 08	 add	 esp, 8
$LN7@RoundScala:

; 1896 :     return v;

  000d6	dd 45 10	 fld	 QWORD PTR _v$[ebp]
$LN1@RoundScala:

; 1897 : }

  000d9	52		 push	 edx
  000da	8b cd		 mov	 ecx, ebp
  000dc	50		 push	 eax
  000dd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@RoundScala
  000e3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e8	58		 pop	 eax
  000e9	5a		 pop	 edx
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  000fd	3b ec		 cmp	 ebp, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN12@RoundScala:
  00108	01 00 00 00	 DD	 1
  0010c	00 00 00 00	 DD	 $LN11@RoundScala
$LN11@RoundScala:
  00110	ac ff ff ff	 DD	 -84			; ffffffacH
  00114	40 00 00 00	 DD	 64			; 00000040H
  00118	00 00 00 00	 DD	 $LN10@RoundScala
$LN10@RoundScala:
  0011c	76		 DB	 118			; 00000076H
  0011d	5f		 DB	 95			; 0000005fH
  0011e	73		 DB	 115			; 00000073H
  0011f	74		 DB	 116			; 00000074H
  00120	72		 DB	 114			; 00000072H
  00121	00		 DB	 0
??$RoundScalarWithFormatT@NN@ImGui@@YANPBDHN@Z ENDP	; ImGui::RoundScalarWithFormatT<double,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@MM@ImGui@@YAMPBDHM@Z
_TEXT	SEGMENT
_p$ = -96						; size = 4
_v_str$ = -84						; size = 64
_fmt_start$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_data_type$ = 12					; size = 4
_v$ = 16						; size = 4
??$RoundScalarWithFormatT@MM@ImGui@@YAMPBDHM@Z PROC	; ImGui::RoundScalarWithFormatT<float,float>, COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1884 :     const char* fmt_start = ImParseFormatFindStart(format);

  00032	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 1885 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0004c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00050	83 f8 25	 cmp	 eax, 37			; 00000025H
  00053	75 14		 jne	 SHORT $LN5@RoundScala
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 00	 shl	 eax, 0
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00060	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00064	83 fa 25	 cmp	 edx, 37			; 00000025H
  00067	75 05		 jne	 SHORT $LN4@RoundScala
$LN5@RoundScala:

; 1886 :         return v;

  00069	d9 45 10	 fld	 DWORD PTR _v$[ebp]
  0006c	eb 6b		 jmp	 SHORT $LN1@RoundScala
$LN4@RoundScala:

; 1887 :     char v_str[64];
; 1888 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

  0006e	f3 0f 5a 45 10	 cvtss2sd xmm0, DWORD PTR _v$[ebp]
  00073	83 ec 08	 sub	 esp, 8
  00076	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007b	8b 45 f4	 mov	 eax, DWORD PTR _fmt_start$[ebp]
  0007e	50		 push	 eax
  0007f	6a 40		 push	 64			; 00000040H
  00081	8d 4d ac	 lea	 ecx, DWORD PTR _v_str$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0008a	83 c4 14	 add	 esp, 20			; 00000014H

; 1889 :     const char* p = v_str;

  0008d	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  00090	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
$LN2@RoundScala:

; 1890 :     while (*p == ' ')

  00093	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  00096	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00099	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009c	75 0b		 jne	 SHORT $LN3@RoundScala

; 1891 :         p++;

  0009e	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
  000a7	eb ea		 jmp	 SHORT $LN2@RoundScala
$LN3@RoundScala:

; 1892 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

  000a9	83 7d 0c 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  000ad	74 06		 je	 SHORT $LN8@RoundScala
  000af	83 7d 0c 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000b3	75 11		 jne	 SHORT $LN6@RoundScala
$LN8@RoundScala:

; 1893 :         v = (TYPE)ImAtof(p);

  000b5	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?ImAtof@@YANPBD@Z	; ImAtof
  000be	83 c4 04	 add	 esp, 4
  000c1	d9 5d 10	 fstp	 DWORD PTR _v$[ebp]
  000c4	eb 10		 jmp	 SHORT $LN7@RoundScala
$LN6@RoundScala:

; 1894 :     else
; 1895 :         ImAtoi(p, (SIGNEDTYPE*)&v);

  000c6	8d 45 10	 lea	 eax, DWORD PTR _v$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d a0	 mov	 ecx, DWORD PTR _p$[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ??$ImAtoi@M@@YAPBDPBDPAM@Z ; ImAtoi<float>
  000d3	83 c4 08	 add	 esp, 8
$LN7@RoundScala:

; 1896 :     return v;

  000d6	d9 45 10	 fld	 DWORD PTR _v$[ebp]
$LN1@RoundScala:

; 1897 : }

  000d9	52		 push	 edx
  000da	8b cd		 mov	 ecx, ebp
  000dc	50		 push	 eax
  000dd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@RoundScala
  000e3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e8	58		 pop	 eax
  000e9	5a		 pop	 edx
  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  000fd	3b ec		 cmp	 ebp, esp
  000ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN12@RoundScala:
  00108	01 00 00 00	 DD	 1
  0010c	00 00 00 00	 DD	 $LN11@RoundScala
$LN11@RoundScala:
  00110	ac ff ff ff	 DD	 -84			; ffffffacH
  00114	40 00 00 00	 DD	 64			; 00000040H
  00118	00 00 00 00	 DD	 $LN10@RoundScala
$LN10@RoundScala:
  0011c	76		 DB	 118			; 00000076H
  0011d	5f		 DB	 95			; 0000005fH
  0011e	73		 DB	 115			; 00000073H
  0011f	74		 DB	 116			; 00000074H
  00120	72		 DB	 114			; 00000072H
  00121	00		 DB	 0
??$RoundScalarWithFormatT@MM@ImGui@@YAMPBDHM@Z ENDP	; ImGui::RoundScalarWithFormatT<float,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPBDH_K@Z
_TEXT	SEGMENT
tv85 = -316						; size = 8
tv90 = -308						; size = 8
tv89 = -300						; size = 8
_p$ = -96						; size = 4
_v_str$ = -84						; size = 64
_fmt_start$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_data_type$ = 12					; size = 4
_v$ = 16						; size = 8
??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPBDH_K@Z PROC	; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>, COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-316]
  00012	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1884 :     const char* fmt_start = ImParseFormatFindStart(format);

  00032	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 1885 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0004c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00050	83 f8 25	 cmp	 eax, 37			; 00000025H
  00053	75 14		 jne	 SHORT $LN5@RoundScala
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 00	 shl	 eax, 0
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00060	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00064	83 fa 25	 cmp	 edx, 37			; 00000025H
  00067	75 0b		 jne	 SHORT $LN4@RoundScala
$LN5@RoundScala:

; 1886 :         return v;

  00069	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  0006c	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp+4]
  0006f	e9 f7 00 00 00	 jmp	 $LN1@RoundScala
$LN4@RoundScala:

; 1887 :     char v_str[64];
; 1888 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

  00074	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp+4]
  00077	50		 push	 eax
  00078	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0007f	52		 push	 edx
  00080	6a 40		 push	 64			; 00000040H
  00082	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0008b	83 c4 14	 add	 esp, 20			; 00000014H

; 1889 :     const char* p = v_str;

  0008e	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  00091	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
$LN2@RoundScala:

; 1890 :     while (*p == ' ')

  00094	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  00097	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009a	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009d	75 0b		 jne	 SHORT $LN3@RoundScala

; 1891 :         p++;

  0009f	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000a2	83 c0 01	 add	 eax, 1
  000a5	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
  000a8	eb ea		 jmp	 SHORT $LN2@RoundScala
$LN3@RoundScala:

; 1892 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

  000aa	83 7d 0c 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  000ae	74 0a		 je	 SHORT $LN8@RoundScala
  000b0	83 7d 0c 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000b4	0f 85 9b 00 00
	00		 jne	 $LN6@RoundScala
$LN8@RoundScala:

; 1893 :         v = (TYPE)ImAtof(p);

  000ba	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?ImAtof@@YANPBD@Z	; ImAtof
  000c3	83 c4 04	 add	 esp, 4
  000c6	0f 57 c0	 xorps	 xmm0, xmm0
  000c9	66 0f 13 85 d4
	fe ff ff	 movlpd	 QWORD PTR tv89[ebp], xmm0
  000d1	dd 9d cc fe ff
	ff		 fstp	 QWORD PTR tv90[ebp]
  000d7	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  000dd	dd 85 cc fe ff
	ff		 fld	 QWORD PTR tv90[ebp]
  000e3	df f1		 fcomip	 ST(1)
  000e5	dd d8		 fstp	 ST(0)
  000e7	72 35		 jb	 SHORT $LN10@RoundScala
  000e9	dd 85 cc fe ff
	ff		 fld	 QWORD PTR tv90[ebp]
  000ef	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@43e0000000000000
  000f5	dd 9d cc fe ff
	ff		 fstp	 QWORD PTR tv90[ebp]
  000fb	dd 85 cc fe ff
	ff		 fld	 QWORD PTR tv90[ebp]
  00101	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@43e0000000000000
  00107	df f1		 fcomip	 ST(1)
  00109	dd d8		 fstp	 ST(0)
  0010b	76 11		 jbe	 SHORT $LN10@RoundScala
  0010d	83 85 d4 fe ff
	ff 00		 add	 DWORD PTR tv89[ebp], 0
  00114	81 95 d8 fe ff
	ff 00 00 00 80	 adc	 DWORD PTR tv89[ebp+4], -2147483648 ; 80000000H
$LN10@RoundScala:
  0011e	dd 85 cc fe ff
	ff		 fld	 QWORD PTR tv90[ebp]
  00124	e8 00 00 00 00	 call	 __ftol2
  00129	03 85 d4 fe ff
	ff		 add	 eax, DWORD PTR tv89[ebp]
  0012f	13 95 d8 fe ff
	ff		 adc	 edx, DWORD PTR tv89[ebp+4]
  00135	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  0013b	89 95 c8 fe ff
	ff		 mov	 DWORD PTR tv85[ebp+4], edx
  00141	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  00147	89 4d 10	 mov	 DWORD PTR _v$[ebp], ecx
  0014a	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv85[ebp+4]
  00150	89 55 14	 mov	 DWORD PTR _v$[ebp+4], edx
  00153	eb 10		 jmp	 SHORT $LN7@RoundScala
$LN6@RoundScala:

; 1894 :     else
; 1895 :         ImAtoi(p, (SIGNEDTYPE*)&v);

  00155	8d 45 10	 lea	 eax, DWORD PTR _v$[ebp]
  00158	50		 push	 eax
  00159	8b 4d a0	 mov	 ecx, DWORD PTR _p$[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ??$ImAtoi@_J@@YAPBDPBDPA_J@Z ; ImAtoi<__int64>
  00162	83 c4 08	 add	 esp, 8
$LN7@RoundScala:

; 1896 :     return v;

  00165	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  00168	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp+4]
$LN1@RoundScala:

; 1897 : }

  0016b	52		 push	 edx
  0016c	8b cd		 mov	 ecx, ebp
  0016e	50		 push	 eax
  0016f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@RoundScala
  00175	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0017a	58		 pop	 eax
  0017b	5a		 pop	 edx
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00182	33 cd		 xor	 ecx, ebp
  00184	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00189	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  0018f	3b ec		 cmp	 ebp, esp
  00191	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
  0019a	66 90		 npad	 2
$LN13@RoundScala:
  0019c	01 00 00 00	 DD	 1
  001a0	00 00 00 00	 DD	 $LN12@RoundScala
$LN12@RoundScala:
  001a4	ac ff ff ff	 DD	 -84			; ffffffacH
  001a8	40 00 00 00	 DD	 64			; 00000040H
  001ac	00 00 00 00	 DD	 $LN11@RoundScala
$LN11@RoundScala:
  001b0	76		 DB	 118			; 00000076H
  001b1	5f		 DB	 95			; 0000005fH
  001b2	73		 DB	 115			; 00000073H
  001b3	74		 DB	 116			; 00000074H
  001b4	72		 DB	 114			; 00000072H
  001b5	00		 DB	 0
??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPBDH_K@Z ENDP	; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPBDH_J@Z
_TEXT	SEGMENT
_p$ = -96						; size = 4
_v_str$ = -84						; size = 64
_fmt_start$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_data_type$ = 12					; size = 4
_v$ = 16						; size = 8
??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPBDH_J@Z PROC	; ImGui::RoundScalarWithFormatT<__int64,__int64>, COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1884 :     const char* fmt_start = ImParseFormatFindStart(format);

  00032	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 1885 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0004c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00050	83 f8 25	 cmp	 eax, 37			; 00000025H
  00053	75 14		 jne	 SHORT $LN5@RoundScala
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 00	 shl	 eax, 0
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00060	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00064	83 fa 25	 cmp	 edx, 37			; 00000025H
  00067	75 08		 jne	 SHORT $LN4@RoundScala
$LN5@RoundScala:

; 1886 :         return v;

  00069	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  0006c	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp+4]
  0006f	eb 71		 jmp	 SHORT $LN1@RoundScala
$LN4@RoundScala:

; 1887 :     char v_str[64];
; 1888 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

  00071	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp+4]
  00074	50		 push	 eax
  00075	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0007c	52		 push	 edx
  0007d	6a 40		 push	 64			; 00000040H
  0007f	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00088	83 c4 14	 add	 esp, 20			; 00000014H

; 1889 :     const char* p = v_str;

  0008b	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  0008e	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
$LN2@RoundScala:

; 1890 :     while (*p == ' ')

  00091	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  00094	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00097	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009a	75 0b		 jne	 SHORT $LN3@RoundScala

; 1891 :         p++;

  0009c	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  0009f	83 c0 01	 add	 eax, 1
  000a2	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
  000a5	eb ea		 jmp	 SHORT $LN2@RoundScala
$LN3@RoundScala:

; 1892 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

  000a7	83 7d 0c 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  000ab	74 06		 je	 SHORT $LN8@RoundScala
  000ad	83 7d 0c 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000b1	75 19		 jne	 SHORT $LN6@RoundScala
$LN8@RoundScala:

; 1893 :         v = (TYPE)ImAtof(p);

  000b3	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?ImAtof@@YANPBD@Z	; ImAtof
  000bc	83 c4 04	 add	 esp, 4
  000bf	e8 00 00 00 00	 call	 __ftol2
  000c4	89 45 10	 mov	 DWORD PTR _v$[ebp], eax
  000c7	89 55 14	 mov	 DWORD PTR _v$[ebp+4], edx
  000ca	eb 10		 jmp	 SHORT $LN7@RoundScala
$LN6@RoundScala:

; 1894 :     else
; 1895 :         ImAtoi(p, (SIGNEDTYPE*)&v);

  000cc	8d 45 10	 lea	 eax, DWORD PTR _v$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d a0	 mov	 ecx, DWORD PTR _p$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$ImAtoi@_J@@YAPBDPBDPA_J@Z ; ImAtoi<__int64>
  000d9	83 c4 08	 add	 esp, 8
$LN7@RoundScala:

; 1896 :     return v;

  000dc	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  000df	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp+4]
$LN1@RoundScala:

; 1897 : }

  000e2	52		 push	 edx
  000e3	8b cd		 mov	 ecx, ebp
  000e5	50		 push	 eax
  000e6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@RoundScala
  000ec	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f1	58		 pop	 eax
  000f2	5a		 pop	 edx
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  00106	3b ec		 cmp	 ebp, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
  00111	0f 1f 00	 npad	 3
$LN12@RoundScala:
  00114	01 00 00 00	 DD	 1
  00118	00 00 00 00	 DD	 $LN11@RoundScala
$LN11@RoundScala:
  0011c	ac ff ff ff	 DD	 -84			; ffffffacH
  00120	40 00 00 00	 DD	 64			; 00000040H
  00124	00 00 00 00	 DD	 $LN10@RoundScala
$LN10@RoundScala:
  00128	76		 DB	 118			; 00000076H
  00129	5f		 DB	 95			; 0000005fH
  0012a	73		 DB	 115			; 00000073H
  0012b	74		 DB	 116			; 00000074H
  0012c	72		 DB	 114			; 00000072H
  0012d	00		 DB	 0
??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPBDH_J@Z ENDP	; ImGui::RoundScalarWithFormatT<__int64,__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@IH@ImGui@@YAIPBDHI@Z
_TEXT	SEGMENT
_p$ = -96						; size = 4
_v_str$ = -84						; size = 64
_fmt_start$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_data_type$ = 12					; size = 4
_v$ = 16						; size = 4
??$RoundScalarWithFormatT@IH@ImGui@@YAIPBDHI@Z PROC	; ImGui::RoundScalarWithFormatT<unsigned int,int>, COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1884 :     const char* fmt_start = ImParseFormatFindStart(format);

  00032	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 1885 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0004c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00050	83 f8 25	 cmp	 eax, 37			; 00000025H
  00053	75 14		 jne	 SHORT $LN5@RoundScala
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 00	 shl	 eax, 0
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00060	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00064	83 fa 25	 cmp	 edx, 37			; 00000025H
  00067	75 05		 jne	 SHORT $LN4@RoundScala
$LN5@RoundScala:

; 1886 :         return v;

  00069	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  0006c	eb 67		 jmp	 SHORT $LN1@RoundScala
$LN4@RoundScala:

; 1887 :     char v_str[64];
; 1888 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

  0006e	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  00071	50		 push	 eax
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00075	51		 push	 ecx
  00076	6a 40		 push	 64			; 00000040H
  00078	8d 55 ac	 lea	 edx, DWORD PTR _v_str$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00081	83 c4 10	 add	 esp, 16			; 00000010H

; 1889 :     const char* p = v_str;

  00084	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  00087	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
$LN2@RoundScala:

; 1890 :     while (*p == ' ')

  0008a	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  0008d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00090	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00093	75 0b		 jne	 SHORT $LN3@RoundScala

; 1891 :         p++;

  00095	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
  0009e	eb ea		 jmp	 SHORT $LN2@RoundScala
$LN3@RoundScala:

; 1892 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

  000a0	83 7d 0c 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  000a4	74 06		 je	 SHORT $LN8@RoundScala
  000a6	83 7d 0c 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000aa	75 16		 jne	 SHORT $LN6@RoundScala
$LN8@RoundScala:

; 1893 :         v = (TYPE)ImAtof(p);

  000ac	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?ImAtof@@YANPBD@Z	; ImAtof
  000b5	83 c4 04	 add	 esp, 4
  000b8	e8 00 00 00 00	 call	 __ftol2
  000bd	89 45 10	 mov	 DWORD PTR _v$[ebp], eax
  000c0	eb 10		 jmp	 SHORT $LN7@RoundScala
$LN6@RoundScala:

; 1894 :     else
; 1895 :         ImAtoi(p, (SIGNEDTYPE*)&v);

  000c2	8d 45 10	 lea	 eax, DWORD PTR _v$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d a0	 mov	 ecx, DWORD PTR _p$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ??$ImAtoi@H@@YAPBDPBDPAH@Z ; ImAtoi<int>
  000cf	83 c4 08	 add	 esp, 8
$LN7@RoundScala:

; 1896 :     return v;

  000d2	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
$LN1@RoundScala:

; 1897 : }

  000d5	52		 push	 edx
  000d6	8b cd		 mov	 ecx, ebp
  000d8	50		 push	 eax
  000d9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@RoundScala
  000df	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e4	58		 pop	 eax
  000e5	5a		 pop	 edx
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ec	33 cd		 xor	 ecx, ebp
  000ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f3	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  000f9	3b ec		 cmp	 ebp, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
$LN12@RoundScala:
  00104	01 00 00 00	 DD	 1
  00108	00 00 00 00	 DD	 $LN11@RoundScala
$LN11@RoundScala:
  0010c	ac ff ff ff	 DD	 -84			; ffffffacH
  00110	40 00 00 00	 DD	 64			; 00000040H
  00114	00 00 00 00	 DD	 $LN10@RoundScala
$LN10@RoundScala:
  00118	76		 DB	 118			; 00000076H
  00119	5f		 DB	 95			; 0000005fH
  0011a	73		 DB	 115			; 00000073H
  0011b	74		 DB	 116			; 00000074H
  0011c	72		 DB	 114			; 00000072H
  0011d	00		 DB	 0
??$RoundScalarWithFormatT@IH@ImGui@@YAIPBDHI@Z ENDP	; ImGui::RoundScalarWithFormatT<unsigned int,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@HH@ImGui@@YAHPBDHH@Z
_TEXT	SEGMENT
_p$ = -96						; size = 4
_v_str$ = -84						; size = 64
_fmt_start$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_data_type$ = 12					; size = 4
_v$ = 16						; size = 4
??$RoundScalarWithFormatT@HH@ImGui@@YAHPBDHH@Z PROC	; ImGui::RoundScalarWithFormatT<int,int>, COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00012	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1884 :     const char* fmt_start = ImParseFormatFindStart(format);

  00032	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 1885 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 f4	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  0004c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00050	83 f8 25	 cmp	 eax, 37			; 00000025H
  00053	75 14		 jne	 SHORT $LN5@RoundScala
  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 00	 shl	 eax, 0
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00060	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00064	83 fa 25	 cmp	 edx, 37			; 00000025H
  00067	75 05		 jne	 SHORT $LN4@RoundScala
$LN5@RoundScala:

; 1886 :         return v;

  00069	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  0006c	eb 67		 jmp	 SHORT $LN1@RoundScala
$LN4@RoundScala:

; 1887 :     char v_str[64];
; 1888 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

  0006e	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  00071	50		 push	 eax
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _fmt_start$[ebp]
  00075	51		 push	 ecx
  00076	6a 40		 push	 64			; 00000040H
  00078	8d 55 ac	 lea	 edx, DWORD PTR _v_str$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00081	83 c4 10	 add	 esp, 16			; 00000010H

; 1889 :     const char* p = v_str;

  00084	8d 45 ac	 lea	 eax, DWORD PTR _v_str$[ebp]
  00087	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
$LN2@RoundScala:

; 1890 :     while (*p == ' ')

  0008a	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  0008d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00090	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00093	75 0b		 jne	 SHORT $LN3@RoundScala

; 1891 :         p++;

  00095	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 a0	 mov	 DWORD PTR _p$[ebp], eax
  0009e	eb ea		 jmp	 SHORT $LN2@RoundScala
$LN3@RoundScala:

; 1892 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

  000a0	83 7d 0c 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  000a4	74 06		 je	 SHORT $LN8@RoundScala
  000a6	83 7d 0c 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000aa	75 16		 jne	 SHORT $LN6@RoundScala
$LN8@RoundScala:

; 1893 :         v = (TYPE)ImAtof(p);

  000ac	8b 45 a0	 mov	 eax, DWORD PTR _p$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?ImAtof@@YANPBD@Z	; ImAtof
  000b5	83 c4 04	 add	 esp, 4
  000b8	e8 00 00 00 00	 call	 __ftol2_sse
  000bd	89 45 10	 mov	 DWORD PTR _v$[ebp], eax
  000c0	eb 10		 jmp	 SHORT $LN7@RoundScala
$LN6@RoundScala:

; 1894 :     else
; 1895 :         ImAtoi(p, (SIGNEDTYPE*)&v);

  000c2	8d 45 10	 lea	 eax, DWORD PTR _v$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d a0	 mov	 ecx, DWORD PTR _p$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ??$ImAtoi@H@@YAPBDPBDPAH@Z ; ImAtoi<int>
  000cf	83 c4 08	 add	 esp, 8
$LN7@RoundScala:

; 1896 :     return v;

  000d2	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
$LN1@RoundScala:

; 1897 : }

  000d5	52		 push	 edx
  000d6	8b cd		 mov	 ecx, ebp
  000d8	50		 push	 eax
  000d9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@RoundScala
  000df	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e4	58		 pop	 eax
  000e5	5a		 pop	 edx
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ec	33 cd		 xor	 ecx, ebp
  000ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f3	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  000f9	3b ec		 cmp	 ebp, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
$LN12@RoundScala:
  00104	01 00 00 00	 DD	 1
  00108	00 00 00 00	 DD	 $LN11@RoundScala
$LN11@RoundScala:
  0010c	ac ff ff ff	 DD	 -84			; ffffffacH
  00110	40 00 00 00	 DD	 64			; 00000040H
  00114	00 00 00 00	 DD	 $LN10@RoundScala
$LN10@RoundScala:
  00118	76		 DB	 118			; 00000076H
  00119	5f		 DB	 95			; 0000005fH
  0011a	73		 DB	 115			; 00000073H
  0011b	74		 DB	 116			; 00000074H
  0011c	72		 DB	 114			; 00000072H
  0011d	00		 DB	 0
??$RoundScalarWithFormatT@HH@ImGui@@YAHPBDHH@Z ENDP	; ImGui::RoundScalarWithFormatT<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnWidthEx@@YAMPAUImGuiColumns@@H_N@Z
_TEXT	SEGMENT
_offset_norm$ = -8					; size = 4
_columns$ = 8						; size = 4
_column_index$ = 12					; size = 4
_before_resize$ = 16					; size = 1
?GetColumnWidthEx@@YAMPAUImGuiColumns@@H_N@Z PROC	; GetColumnWidthEx, COMDAT

; 7290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7291 :     if (column_index < 0)

  00028	83 7d 0c 00	 cmp	 DWORD PTR _column_index$[ebp], 0
  0002c	7d 09		 jge	 SHORT $LN2@GetColumnW

; 7292 :         column_index = columns->Current;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _columns$[ebp]
  00031	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00034	89 4d 0c	 mov	 DWORD PTR _column_index$[ebp], ecx
$LN2@GetColumnW:

; 7293 : 
; 7294 :     float offset_norm;
; 7295 :     if (before_resize)

  00037	0f b6 45 10	 movzx	 eax, BYTE PTR _before_resize$[ebp]
  0003b	85 c0		 test	 eax, eax
  0003d	74 34		 je	 SHORT $LN3@GetColumnW

; 7296 :         offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _column_index$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _columns$[ebp]
  00049	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0004c	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00051	8b f0		 mov	 esi, eax
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _column_index$[ebp]
  00056	51		 push	 ecx
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _columns$[ebp]
  0005a	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0005d	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00062	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00067	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  0006c	f3 0f 11 45 f8	 movss	 DWORD PTR _offset_norm$[ebp], xmm0
  00071	eb 30		 jmp	 SHORT $LN4@GetColumnW
$LN3@GetColumnW:

; 7297 :     else
; 7298 :         offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;

  00073	8b 45 0c	 mov	 eax, DWORD PTR _column_index$[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _columns$[ebp]
  0007d	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00080	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00085	8b f0		 mov	 esi, eax
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR _column_index$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _columns$[ebp]
  0008e	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00091	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00096	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0009a	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0009e	f3 0f 11 45 f8	 movss	 DWORD PTR _offset_norm$[ebp], xmm0
$LN4@GetColumnW:

; 7299 :     return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);

  000a3	51		 push	 ecx
  000a4	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _offset_norm$[ebp]
  000a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ae	8b 45 08	 mov	 eax, DWORD PTR _columns$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?GetColumnOffsetFromNorm@ImGui@@YAMPBUImGuiColumns@@M@Z ; ImGui::GetColumnOffsetFromNorm
  000b7	83 c4 08	 add	 esp, 8

; 7300 : }

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000c3	3b ec		 cmp	 ebp, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?GetColumnWidthEx@@YAMPAUImGuiColumns@@H_N@Z ENDP	; GetColumnWidthEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z
_TEXT	SEGMENT
tv180 = -232						; size = 4
tv167 = -232						; size = 4
_x$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
_columns$ = 8						; size = 4
_column_index$ = 12					; size = 4
?GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z PROC	; GetDraggedColumnOffset, COMDAT

; 7257 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7258 :     // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
; 7259 :     // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
; 7260 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 7261 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 7262 :     IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.

  0003c	83 7d 0c 00	 cmp	 DWORD PTR _column_index$[ebp], 0
  00040	7f 25		 jg	 SHORT $LN4@GetDragged
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z@4JA
  00047	83 c0 05	 add	 eax, 5
  0004a	8b f4		 mov	 esi, esp
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@HNMGCLDB@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?5@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@GetDragged:

; 7263 :     IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

  00067	8b 45 08	 mov	 eax, DWORD PTR _columns$[ebp]
  0006a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006c	03 4d 0c	 add	 ecx, DWORD PTR _column_index$[ebp]
  0006f	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00072	39 8a e4 19 00
	00		 cmp	 DWORD PTR [edx+6628], ecx
  00078	74 25		 je	 SHORT $LN5@GetDragged
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z@4JA
  0007f	83 c0 06	 add	 eax, 6
  00082	8b f4		 mov	 esi, esp
  00084	50		 push	 eax
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_1GE@CFLLPKGA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc@
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@GetDragged:

; 7264 : 
; 7265 :     float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  000a5	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+232]
  000ad	f3 0f 5c 81 08
	1a 00 00	 subss	 xmm0, DWORD PTR [ecx+6664]
  000b5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  000bd	8b 55 ec	 mov	 edx, DWORD PTR _window$[ebp]
  000c0	f3 0f 5c 42 0c	 subss	 xmm0, DWORD PTR [edx+12]
  000c5	f3 0f 11 45 e0	 movss	 DWORD PTR _x$[ebp], xmm0

; 7266 :     x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);

  000ca	8b 45 0c	 mov	 eax, DWORD PTR _column_index$[ebp]
  000cd	83 e8 01	 sub	 eax, 1
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  000d6	83 c4 04	 add	 esp, 4
  000d9	d9 9d 18 ff ff
	ff		 fstp	 DWORD PTR tv167[ebp]
  000df	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR tv167[ebp]
  000e7	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  000ea	f3 0f 58 81 74
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5492]
  000f2	51		 push	 ecx
  000f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f8	51		 push	 ecx
  000f9	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x$[ebp]
  000fe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00103	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00108	83 c4 08	 add	 esp, 8
  0010b	d9 5d e0	 fstp	 DWORD PTR _x$[ebp]

; 7267 :     if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))

  0010e	8b 45 08	 mov	 eax, DWORD PTR _columns$[ebp]
  00111	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00114	83 e1 04	 and	 ecx, 4
  00117	74 44		 je	 SHORT $LN2@GetDragged

; 7268 :         x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

  00119	8b 45 0c	 mov	 eax, DWORD PTR _column_index$[ebp]
  0011c	83 c0 01	 add	 eax, 1
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00125	83 c4 04	 add	 esp, 4
  00128	d9 9d 18 ff ff
	ff		 fstp	 DWORD PTR tv180[ebp]
  0012e	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR tv180[ebp]
  00136	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00139	f3 0f 5c 81 74
	15 00 00	 subss	 xmm0, DWORD PTR [ecx+5492]
  00141	51		 push	 ecx
  00142	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00147	51		 push	 ecx
  00148	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x$[ebp]
  0014d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00152	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00157	83 c4 08	 add	 esp, 8
  0015a	d9 5d e0	 fstp	 DWORD PTR _x$[ebp]
$LN2@GetDragged:

; 7269 : 
; 7270 :     return x;

  0015d	d9 45 e0	 fld	 DWORD PTR _x$[ebp]

; 7271 : }

  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx
  00163	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00169	3b ec		 cmp	 ebp, esp
  0016b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c3		 ret	 0
?GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z ENDP	; GetDraggedColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetTabBarRefFromTabBar@@YA?AUImGuiPtrOrIndex@@PAUImGuiTabBar@@@Z
_TEXT	SEGMENT
_g$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_tab_bar$ = 12						; size = 4
?GetTabBarRefFromTabBar@@YA?AUImGuiPtrOrIndex@@PAUImGuiTabBar@@@Z PROC ; GetTabBarRefFromTabBar, COMDAT

; 6396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6397 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6398 :     if (g.TabBars.Contains(tab_bar))

  00030	8b 45 0c	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00037	81 c1 c4 1d 00
	00		 add	 ecx, 7620		; 00001dc4H
  0003d	e8 00 00 00 00	 call	 ?Contains@?$ImPool@UImGuiTabBar@@@@QBE_NPBUImGuiTabBar@@@Z ; ImPool<ImGuiTabBar>::Contains
  00042	0f b6 c8	 movzx	 ecx, al
  00045	85 c9		 test	 ecx, ecx
  00047	74 20		 je	 SHORT $LN2@GetTabBarR

; 6399 :         return ImGuiPtrOrIndex(g.TabBars.GetIndex(tab_bar));

  00049	8b 45 0c	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00050	81 c1 c4 1d 00
	00		 add	 ecx, 7620		; 00001dc4H
  00056	e8 00 00 00 00	 call	 ?GetIndex@?$ImPool@UImGuiTabBar@@@@QBEHPBUImGuiTabBar@@@Z ; ImPool<ImGuiTabBar>::GetIndex
  0005b	50		 push	 eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005f	e8 00 00 00 00	 call	 ??0ImGuiPtrOrIndex@@QAE@H@Z ; ImGuiPtrOrIndex::ImGuiPtrOrIndex
  00064	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00067	eb 0f		 jmp	 SHORT $LN1@GetTabBarR
$LN2@GetTabBarR:

; 6400 :     return ImGuiPtrOrIndex(tab_bar);

  00069	8b 45 0c	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00070	e8 00 00 00 00	 call	 ??0ImGuiPtrOrIndex@@QAE@PAX@Z ; ImGuiPtrOrIndex::ImGuiPtrOrIndex
  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@GetTabBarR:

; 6401 : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?GetTabBarRefFromTabBar@@YA?AUImGuiPtrOrIndex@@PAUImGuiTabBar@@@Z ENDP ; GetTabBarRefFromTabBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetTabBarFromTabBarRef@@YAPAUImGuiTabBar@@ABUImGuiPtrOrIndex@@@Z
_TEXT	SEGMENT
tv72 = -208						; size = 4
_g$ = -8						; size = 4
_ref$ = 8						; size = 4
?GetTabBarFromTabBarRef@@YAPAUImGuiTabBar@@ABUImGuiPtrOrIndex@@@Z PROC ; GetTabBarFromTabBarRef, COMDAT

; 6390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6391 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6392 :     return ref.Ptr ? (ImGuiTabBar*)ref.Ptr : g.TabBars.GetByIndex(ref.Index);

  00030	8b 45 08	 mov	 eax, DWORD PTR _ref$[ebp]
  00033	83 38 00	 cmp	 DWORD PTR [eax], 0
  00036	74 0d		 je	 SHORT $LN3@GetTabBarF
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _ref$[ebp]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
  00043	eb 1b		 jmp	 SHORT $LN4@GetTabBarF
$LN3@GetTabBarF:
  00045	8b 45 08	 mov	 eax, DWORD PTR _ref$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	51		 push	 ecx
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0004f	81 c1 c4 1d 00
	00		 add	 ecx, 7620		; 00001dc4H
  00055	e8 00 00 00 00	 call	 ?GetByIndex@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@H@Z ; ImPool<ImGuiTabBar>::GetByIndex
  0005a	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN4@GetTabBarF:
  00060	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]

; 6393 : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?GetTabBarFromTabBarRef@@YAPAUImGuiTabBar@@ABUImGuiPtrOrIndex@@@Z ENDP ; GetTabBarFromTabBarRef
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemComparerByVisibleOffset@@YAHPBX0@Z
_TEXT	SEGMENT
_b$ = -20						; size = 4
_a$ = -8						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?TabItemComparerByVisibleOffset@@YAHPBX0@Z PROC		; TabItemComparerByVisibleOffset, COMDAT

; 6383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6384 :     const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;

  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _a$[ebp], eax

; 6385 :     const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00031	89 45 ec	 mov	 DWORD PTR _b$[ebp], eax

; 6386 :     return (int)(a->Offset - b->Offset);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _a$[ebp]
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _b$[ebp]
  0003a	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0003f	f3 0f 5c 41 14	 subss	 xmm0, DWORD PTR [ecx+20]
  00044	f3 0f 2c c0	 cvttss2si eax, xmm0

; 6387 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?TabItemComparerByVisibleOffset@@YAHPBX0@Z ENDP		; TabItemComparerByVisibleOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarTabListPopupButton@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z
_TEXT	SEGMENT
tv173 = -389						; size = 1
$T1 = -384						; size = 8
$T2 = -368						; size = 16
$T3 = -344						; size = 8
_tab_name$4 = -136					; size = 4
_tab$5 = -124						; size = 4
_tab_n$6 = -112						; size = 4
_tab_to_select$ = -100					; size = 4
_open$ = -85						; size = 1
_arrow_col$ = -76					; size = 16
_backup_cursor_pos$ = -52				; size = 8
_tab_list_popup_button_width$ = -36			; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_tab_bar$ = 8						; size = 4
?TabBarTabListPopupButton@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z PROC ; ImGui::TabBarTabListPopupButton, COMDAT

; 6817 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 01 00
	00		 sub	 esp, 392		; 00000188H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 78 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-392]
  00012	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6818 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 6819 :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 6820 : 
; 6821 :     // We use g.Style.FramePadding.y to match the square ArrowButton size
; 6822 :     const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;

  00046	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00049	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0004c	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00054	f3 0f 58 81 4c
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5452]
  0005c	f3 0f 11 45 dc	 movss	 DWORD PTR _tab_list_popup_button_width$[ebp], xmm0

; 6823 :     const ImVec2 backup_cursor_pos = window->DC.CursorPos;

  00061	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00064	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0006a	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00070	89 4d cc	 mov	 DWORD PTR _backup_cursor_pos$[ebp], ecx
  00073	89 55 d0	 mov	 DWORD PTR _backup_cursor_pos$[ebp+4], edx

; 6824 :     window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);

  00076	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00079	51		 push	 ecx
  0007a	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  0007f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00087	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  0008a	f3 0f 10 41 24	 movss	 xmm0, DWORD PTR [ecx+36]
  0008f	f3 0f 5c 82 4c
	15 00 00	 subss	 xmm0, DWORD PTR [edx+5452]
  00097	51		 push	 ecx
  00098	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009d	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000a3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000a8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000aa	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ad	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  000b0	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  000b6	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 6825 :     tab_bar->BarRect.Min.x += tab_list_popup_button_width;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000bf	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  000c4	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _tab_list_popup_button_width$[ebp]
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  000cc	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 6826 : 
; 6827 :     ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];

  000d1	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000d6	6b c8 00	 imul	 ecx, eax, 0
  000d9	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  000dc	8d 84 0a c0 15
	00 00		 lea	 eax, DWORD PTR [edx+ecx+5568]
  000e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e5	89 4d b4	 mov	 DWORD PTR _arrow_col$[ebp], ecx
  000e8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000eb	89 55 b8	 mov	 DWORD PTR _arrow_col$[ebp+4], edx
  000ee	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f1	89 4d bc	 mov	 DWORD PTR _arrow_col$[ebp+8], ecx
  000f4	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000f7	89 55 c0	 mov	 DWORD PTR _arrow_col$[ebp+12], edx

; 6828 :     arrow_col.w *= 0.5f;

  000fa	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _arrow_col$[ebp+12]
  000ff	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00107	f3 0f 11 45 c0	 movss	 DWORD PTR _arrow_col$[ebp+12], xmm0

; 6829 :     PushStyleColor(ImGuiCol_Text, arrow_col);

  0010c	8d 45 b4	 lea	 eax, DWORD PTR _arrow_col$[ebp]
  0010f	50		 push	 eax
  00110	6a 00		 push	 0
  00112	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  00117	83 c4 08	 add	 esp, 8

; 6830 :     PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));

  0011a	51		 push	 ecx
  0011b	0f 57 c0	 xorps	 xmm0, xmm0
  0011e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00123	51		 push	 ecx
  00124	0f 57 c0	 xorps	 xmm0, xmm0
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	51		 push	 ecx
  0012d	0f 57 c0	 xorps	 xmm0, xmm0
  00130	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00135	51		 push	 ecx
  00136	0f 57 c0	 xorps	 xmm0, xmm0
  00139	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013e	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00144	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00149	50		 push	 eax
  0014a	6a 15		 push	 21			; 00000015H
  0014c	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  00151	83 c4 08	 add	 esp, 8

; 6831 :     bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview);

  00154	6a 40		 push	 64			; 00000040H
  00156	6a 00		 push	 0
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_03CPFCAGPK@?$CD?$CDv@
  0015d	e8 00 00 00 00	 call	 ?BeginCombo@ImGui@@YA_NPBD0H@Z ; ImGui::BeginCombo
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH
  00165	88 45 ab	 mov	 BYTE PTR _open$[ebp], al

; 6832 :     PopStyleColor(2);

  00168	6a 02		 push	 2
  0016a	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor
  0016f	83 c4 04	 add	 esp, 4

; 6833 : 
; 6834 :     ImGuiTabItem* tab_to_select = NULL;

  00172	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _tab_to_select$[ebp], 0

; 6835 :     if (open)

  00179	0f b6 45 ab	 movzx	 eax, BYTE PTR _open$[ebp]
  0017d	85 c0		 test	 eax, eax
  0017f	0f 84 ac 00 00
	00		 je	 $LN5@TabBarTabL

; 6836 :     {
; 6837 :         for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

  00185	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _tab_n$6[ebp], 0
  0018c	eb 09		 jmp	 SHORT $LN4@TabBarTabL
$LN2@TabBarTabL:
  0018e	8b 45 90	 mov	 eax, DWORD PTR _tab_n$6[ebp]
  00191	83 c0 01	 add	 eax, 1
  00194	89 45 90	 mov	 DWORD PTR _tab_n$6[ebp], eax
$LN4@TabBarTabL:
  00197	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0019a	8b 4d 90	 mov	 ecx, DWORD PTR _tab_n$6[ebp]
  0019d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0019f	0f 8d 87 00 00
	00		 jge	 $LN3@TabBarTabL

; 6838 :         {
; 6839 :             ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

  001a5	8b 45 90	 mov	 eax, DWORD PTR _tab_n$6[ebp]
  001a8	50		 push	 eax
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001ac	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  001b1	89 45 84	 mov	 DWORD PTR _tab$5[ebp], eax

; 6840 :             const char* tab_name = tab_bar->GetTabName(tab);

  001b4	8b 45 84	 mov	 eax, DWORD PTR _tab$5[ebp]
  001b7	50		 push	 eax
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001bb	e8 00 00 00 00	 call	 ?GetTabName@ImGuiTabBar@@QBEPBDPBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabName
  001c0	89 85 78 ff ff
	ff		 mov	 DWORD PTR _tab_name$4[ebp], eax

; 6841 :             if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))

  001c6	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  001c9	8b 4d 84	 mov	 ecx, DWORD PTR _tab$5[ebp]
  001cc	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  001cf	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001d1	75 09		 jne	 SHORT $LN8@TabBarTabL
  001d3	c6 85 7b fe ff
	ff 01		 mov	 BYTE PTR tv173[ebp], 1
  001da	eb 07		 jmp	 SHORT $LN9@TabBarTabL
$LN8@TabBarTabL:
  001dc	c6 85 7b fe ff
	ff 00		 mov	 BYTE PTR tv173[ebp], 0
$LN9@TabBarTabL:
  001e3	51		 push	 ecx
  001e4	0f 57 c0	 xorps	 xmm0, xmm0
  001e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ec	51		 push	 ecx
  001ed	0f 57 c0	 xorps	 xmm0, xmm0
  001f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f5	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001fb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00200	50		 push	 eax
  00201	6a 00		 push	 0
  00203	0f b6 85 7b fe
	ff ff		 movzx	 eax, BYTE PTR tv173[ebp]
  0020a	50		 push	 eax
  0020b	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _tab_name$4[ebp]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  00217	83 c4 10	 add	 esp, 16			; 00000010H
  0021a	0f b6 d0	 movzx	 edx, al
  0021d	85 d2		 test	 edx, edx
  0021f	74 06		 je	 SHORT $LN6@TabBarTabL

; 6842 :                 tab_to_select = tab;

  00221	8b 45 84	 mov	 eax, DWORD PTR _tab$5[ebp]
  00224	89 45 9c	 mov	 DWORD PTR _tab_to_select$[ebp], eax
$LN6@TabBarTabL:

; 6843 :         }

  00227	e9 62 ff ff ff	 jmp	 $LN2@TabBarTabL
$LN3@TabBarTabL:

; 6844 :         EndCombo();

  0022c	e8 00 00 00 00	 call	 ?EndCombo@ImGui@@YAXXZ	; ImGui::EndCombo
$LN5@TabBarTabL:

; 6845 :     }
; 6846 : 
; 6847 :     window->DC.CursorPos = backup_cursor_pos;

  00231	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00234	8b 4d cc	 mov	 ecx, DWORD PTR _backup_cursor_pos$[ebp]
  00237	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  0023d	8b 55 d0	 mov	 edx, DWORD PTR _backup_cursor_pos$[ebp+4]
  00240	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 6848 :     return tab_to_select;

  00246	8b 45 9c	 mov	 eax, DWORD PTR _tab_to_select$[ebp]

; 6849 : }

  00249	52		 push	 edx
  0024a	8b cd		 mov	 ecx, ebp
  0024c	50		 push	 eax
  0024d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@TabBarTabL
  00253	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00258	58		 pop	 eax
  00259	5a		 pop	 edx
  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx
  0025d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00260	33 cd		 xor	 ecx, ebp
  00262	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00267	81 c4 88 01 00
	00		 add	 esp, 392		; 00000188H
  0026d	3b ec		 cmp	 ebp, esp
  0026f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00274	8b e5		 mov	 esp, ebp
  00276	5d		 pop	 ebp
  00277	c3		 ret	 0
$LN13@TabBarTabL:
  00278	02 00 00 00	 DD	 2
  0027c	00 00 00 00	 DD	 $LN12@TabBarTabL
$LN12@TabBarTabL:
  00280	cc ff ff ff	 DD	 -52			; ffffffccH
  00284	08 00 00 00	 DD	 8
  00288	00 00 00 00	 DD	 $LN10@TabBarTabL
  0028c	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00290	10 00 00 00	 DD	 16			; 00000010H
  00294	00 00 00 00	 DD	 $LN11@TabBarTabL
$LN11@TabBarTabL:
  00298	61		 DB	 97			; 00000061H
  00299	72		 DB	 114			; 00000072H
  0029a	72		 DB	 114			; 00000072H
  0029b	6f		 DB	 111			; 0000006fH
  0029c	77		 DB	 119			; 00000077H
  0029d	5f		 DB	 95			; 0000005fH
  0029e	63		 DB	 99			; 00000063H
  0029f	6f		 DB	 111			; 0000006fH
  002a0	6c		 DB	 108			; 0000006cH
  002a1	00		 DB	 0
$LN10@TabBarTabL:
  002a2	62		 DB	 98			; 00000062H
  002a3	61		 DB	 97			; 00000061H
  002a4	63		 DB	 99			; 00000063H
  002a5	6b		 DB	 107			; 0000006bH
  002a6	75		 DB	 117			; 00000075H
  002a7	70		 DB	 112			; 00000070H
  002a8	5f		 DB	 95			; 0000005fH
  002a9	63		 DB	 99			; 00000063H
  002aa	75		 DB	 117			; 00000075H
  002ab	72		 DB	 114			; 00000072H
  002ac	73		 DB	 115			; 00000073H
  002ad	6f		 DB	 111			; 0000006fH
  002ae	72		 DB	 114			; 00000072H
  002af	5f		 DB	 95			; 0000005fH
  002b0	70		 DB	 112			; 00000070H
  002b1	6f		 DB	 111			; 0000006fH
  002b2	73		 DB	 115			; 00000073H
  002b3	00		 DB	 0
?TabBarTabListPopupButton@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarTabListPopupButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarScrollingButtons@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z
_TEXT	SEGMENT
tv248 = -556						; size = 4
tv135 = -556						; size = 4
$T1 = -548						; size = 8
$T2 = -532						; size = 8
$T3 = -516						; size = 16
$T4 = -492						; size = 8
$T5 = -476						; size = 8
$T6 = -460						; size = 8
$T7 = -444						; size = 8
$T8 = -428						; size = 16
_target_order$9 = -212					; size = 4
_selected_order$10 = -200				; size = 4
_tab_item$11 = -188					; size = 4
_backup_repeat_rate$ = -176				; size = 4
_backup_repeat_delay$ = -164				; size = 4
_arrow_col$ = -152					; size = 16
_select_dir$ = -128					; size = 4
_tab_to_select$ = -116					; size = 4
_want_clip_rect$ = -101					; size = 1
_avail_bar_rect$ = -92					; size = 16
_backup_cursor_pos$ = -68				; size = 8
_scrolling_buttons_width$ = -52				; size = 4
_arrow_button_size$ = -40				; size = 8
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_tab_bar$ = 8						; size = 4
?TabBarScrollingButtons@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z PROC ; ImGui::TabBarScrollingButtons, COMDAT

; 6763 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-556]
  00012	b9 8b 00 00 00	 mov	 ecx, 139		; 0000008bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6764 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 6765 :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 6766 : 
; 6767 :     const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);

  00046	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00049	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  00051	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00059	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0005c	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  00064	51		 push	 ecx
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  0006d	f3 0f 10 82 c4
	18 00 00	 movss	 xmm0, DWORD PTR [edx+6340]
  00075	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  0007d	51		 push	 ecx
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	8d 4d d8	 lea	 ecx, DWORD PTR _arrow_button_size$[ebp]
  00086	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 6768 :     const float scrolling_buttons_width = arrow_button_size.x * 2.0f;

  0008b	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _arrow_button_size$[ebp]
  00090	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00098	f3 0f 11 45 cc	 movss	 DWORD PTR _scrolling_buttons_width$[ebp], xmm0

; 6769 : 
; 6770 :     const ImVec2 backup_cursor_pos = window->DC.CursorPos;

  0009d	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  000a0	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  000a6	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  000ac	89 4d bc	 mov	 DWORD PTR _backup_cursor_pos$[ebp], ecx
  000af	89 55 c0	 mov	 DWORD PTR _backup_cursor_pos$[ebp+4], edx

; 6771 :     //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));
; 6772 : 
; 6773 :     const ImRect avail_bar_rect = tab_bar->BarRect;

  000b2	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000b5	83 c0 24	 add	 eax, 36			; 00000024H
  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	89 4d a4	 mov	 DWORD PTR _avail_bar_rect$[ebp], ecx
  000bd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c0	89 55 a8	 mov	 DWORD PTR _avail_bar_rect$[ebp+4], edx
  000c3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c6	89 4d ac	 mov	 DWORD PTR _avail_bar_rect$[ebp+8], ecx
  000c9	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000cc	89 55 b0	 mov	 DWORD PTR _avail_bar_rect$[ebp+12], edx

; 6774 :     bool want_clip_rect = !avail_bar_rect.Contains(ImRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(scrolling_buttons_width, 0.0f)));

  000cf	51		 push	 ecx
  000d0	0f 57 c0	 xorps	 xmm0, xmm0
  000d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d8	51		 push	 ecx
  000d9	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _scrolling_buttons_width$[ebp]
  000de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e3	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  000e9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ee	50		 push	 eax
  000ef	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  000f2	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000f7	50		 push	 eax
  000f8	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
  00107	50		 push	 eax
  00108	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  0010b	81 c2 c8 00 00
	00		 add	 edx, 200		; 000000c8H
  00111	52		 push	 edx
  00112	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00118	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
  0011d	50		 push	 eax
  0011e	8d 4d a4	 lea	 ecx, DWORD PTR _avail_bar_rect$[ebp]
  00121	e8 00 00 00 00	 call	 ?Contains@ImRect@@QBE_NABU1@@Z ; ImRect::Contains
  00126	0f b6 c0	 movzx	 eax, al
  00129	85 c0		 test	 eax, eax
  0012b	75 0c		 jne	 SHORT $LN9@TabBarScro
  0012d	c7 85 d4 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv135[ebp], 1
  00137	eb 0a		 jmp	 SHORT $LN10@TabBarScro
$LN9@TabBarScro:
  00139	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv135[ebp], 0
$LN10@TabBarScro:
  00143	8a 8d d4 fd ff
	ff		 mov	 cl, BYTE PTR tv135[ebp]
  00149	88 4d 9b	 mov	 BYTE PTR _want_clip_rect$[ebp], cl

; 6775 :     if (want_clip_rect)

  0014c	0f b6 45 9b	 movzx	 eax, BYTE PTR _want_clip_rect$[ebp]
  00150	85 c0		 test	 eax, eax
  00152	74 4e		 je	 SHORT $LN2@TabBarScro

; 6776 :         PushClipRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max + ImVec2(g.Style.ItemInnerSpacing.x, 0.0f), true);

  00154	6a 01		 push	 1
  00156	51		 push	 ecx
  00157	0f 57 c0	 xorps	 xmm0, xmm0
  0015a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015f	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00162	51		 push	 ecx
  00163	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  0016b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00170	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00176	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0017b	50		 push	 eax
  0017c	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0017f	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00182	51		 push	 ecx
  00183	8d 95 14 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0018f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00192	50		 push	 eax
  00193	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00196	83 c0 24	 add	 eax, 36			; 00000024H
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 ?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@TabBarScro:

; 6777 : 
; 6778 :     ImGuiTabItem* tab_to_select = NULL;

  001a2	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _tab_to_select$[ebp], 0

; 6779 : 
; 6780 :     int select_dir = 0;

  001a9	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _select_dir$[ebp], 0

; 6781 :     ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];

  001b0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001b5	6b c8 00	 imul	 ecx, eax, 0
  001b8	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  001bb	8d 84 0a c0 15
	00 00		 lea	 eax, DWORD PTR [edx+ecx+5568]
  001c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c4	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _arrow_col$[ebp], ecx
  001ca	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001cd	89 95 6c ff ff
	ff		 mov	 DWORD PTR _arrow_col$[ebp+4], edx
  001d3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d6	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _arrow_col$[ebp+8], ecx
  001dc	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  001df	89 95 74 ff ff
	ff		 mov	 DWORD PTR _arrow_col$[ebp+12], edx

; 6782 :     arrow_col.w *= 0.5f;

  001e5	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _arrow_col$[ebp+12]
  001ed	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001f5	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _arrow_col$[ebp+12], xmm0

; 6783 : 
; 6784 :     PushStyleColor(ImGuiCol_Text, arrow_col);

  001fd	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _arrow_col$[ebp]
  00203	50		 push	 eax
  00204	6a 00		 push	 0
  00206	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  0020b	83 c4 08	 add	 esp, 8

; 6785 :     PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));

  0020e	51		 push	 ecx
  0020f	0f 57 c0	 xorps	 xmm0, xmm0
  00212	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00217	51		 push	 ecx
  00218	0f 57 c0	 xorps	 xmm0, xmm0
  0021b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00220	51		 push	 ecx
  00221	0f 57 c0	 xorps	 xmm0, xmm0
  00224	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00229	51		 push	 ecx
  0022a	0f 57 c0	 xorps	 xmm0, xmm0
  0022d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00232	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00238	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0023d	50		 push	 eax
  0023e	6a 15		 push	 21			; 00000015H
  00240	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  00245	83 c4 08	 add	 esp, 8

; 6786 :     const float backup_repeat_delay = g.IO.KeyRepeatDelay;

  00248	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0024b	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR [eax+140]
  00253	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _backup_repeat_delay$[ebp], xmm0

; 6787 :     const float backup_repeat_rate = g.IO.KeyRepeatRate;

  0025b	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0025e	f3 0f 10 80 90
	00 00 00	 movss	 xmm0, DWORD PTR [eax+144]
  00266	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _backup_repeat_rate$[ebp], xmm0

; 6788 :     g.IO.KeyRepeatDelay = 0.250f;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00271	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  00279	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 6789 :     g.IO.KeyRepeatRate = 0.200f;

  00281	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00284	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0028c	f3 0f 11 80 90
	00 00 00	 movss	 DWORD PTR [eax+144], xmm0

; 6790 :     window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y);

  00294	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00297	51		 push	 ecx
  00298	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  0029d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a2	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  002a5	f3 0f 10 41 2c	 movss	 xmm0, DWORD PTR [ecx+44]
  002aa	f3 0f 5c 45 cc	 subss	 xmm0, DWORD PTR _scrolling_buttons_width$[ebp]
  002af	51		 push	 ecx
  002b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b5	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  002bb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002c0	8b 10		 mov	 edx, DWORD PTR [eax]
  002c2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002c5	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  002c8	89 91 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], edx
  002ce	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax

; 6791 :     if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

  002d4	6a 05		 push	 5
  002d6	8b 45 dc	 mov	 eax, DWORD PTR _arrow_button_size$[ebp+4]
  002d9	50		 push	 eax
  002da	8b 4d d8	 mov	 ecx, DWORD PTR _arrow_button_size$[ebp]
  002dd	51		 push	 ecx
  002de	6a 00		 push	 0
  002e0	68 00 00 00 00	 push	 OFFSET ??_C@_03CFMEKBHF@?$CD?$CD?$DM@
  002e5	e8 00 00 00 00	 call	 ?ArrowButtonEx@ImGui@@YA_NPBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx
  002ea	83 c4 14	 add	 esp, 20			; 00000014H
  002ed	0f b6 d0	 movzx	 edx, al
  002f0	85 d2		 test	 edx, edx
  002f2	74 07		 je	 SHORT $LN3@TabBarScro

; 6792 :         select_dir = -1;

  002f4	c7 45 80 ff ff
	ff ff		 mov	 DWORD PTR _select_dir$[ebp], -1
$LN3@TabBarScro:

; 6793 :     window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x, tab_bar->BarRect.Min.y);

  002fb	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002fe	51		 push	 ecx
  002ff	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00304	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00309	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0030c	f3 0f 10 41 2c	 movss	 xmm0, DWORD PTR [ecx+44]
  00311	f3 0f 5c 45 cc	 subss	 xmm0, DWORD PTR _scrolling_buttons_width$[ebp]
  00316	f3 0f 58 45 d8	 addss	 xmm0, DWORD PTR _arrow_button_size$[ebp]
  0031b	51		 push	 ecx
  0031c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00321	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00327	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0032c	8b 10		 mov	 edx, DWORD PTR [eax]
  0032e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00331	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00334	89 91 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], edx
  0033a	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax

; 6794 :     if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

  00340	6a 05		 push	 5
  00342	8b 45 dc	 mov	 eax, DWORD PTR _arrow_button_size$[ebp+4]
  00345	50		 push	 eax
  00346	8b 4d d8	 mov	 ecx, DWORD PTR _arrow_button_size$[ebp]
  00349	51		 push	 ecx
  0034a	6a 01		 push	 1
  0034c	68 00 00 00 00	 push	 OFFSET ??_C@_03BHPCMDPH@?$CD?$CD?$DO@
  00351	e8 00 00 00 00	 call	 ?ArrowButtonEx@ImGui@@YA_NPBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx
  00356	83 c4 14	 add	 esp, 20			; 00000014H
  00359	0f b6 d0	 movzx	 edx, al
  0035c	85 d2		 test	 edx, edx
  0035e	74 07		 je	 SHORT $LN4@TabBarScro

; 6795 :         select_dir = +1;

  00360	c7 45 80 01 00
	00 00		 mov	 DWORD PTR _select_dir$[ebp], 1
$LN4@TabBarScro:

; 6796 :     PopStyleColor(2);

  00367	6a 02		 push	 2
  00369	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor
  0036e	83 c4 04	 add	 esp, 4

; 6797 :     g.IO.KeyRepeatRate = backup_repeat_rate;

  00371	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00374	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _backup_repeat_rate$[ebp]
  0037c	f3 0f 11 80 90
	00 00 00	 movss	 DWORD PTR [eax+144], xmm0

; 6798 :     g.IO.KeyRepeatDelay = backup_repeat_delay;

  00384	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00387	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _backup_repeat_delay$[ebp]
  0038f	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 6799 : 
; 6800 :     if (want_clip_rect)

  00397	0f b6 45 9b	 movzx	 eax, BYTE PTR _want_clip_rect$[ebp]
  0039b	85 c0		 test	 eax, eax
  0039d	74 05		 je	 SHORT $LN5@TabBarScro

; 6801 :         PopClipRect();

  0039f	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect
$LN5@TabBarScro:

; 6802 : 
; 6803 :     if (select_dir != 0)

  003a4	83 7d 80 00	 cmp	 DWORD PTR _select_dir$[ebp], 0
  003a8	0f 84 81 00 00
	00		 je	 $LN7@TabBarScro

; 6804 :         if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))

  003ae	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  003b1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003b4	51		 push	 ecx
  003b5	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  003b8	52		 push	 edx
  003b9	e8 00 00 00 00	 call	 ?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
  003be	83 c4 08	 add	 esp, 8
  003c1	89 85 44 ff ff
	ff		 mov	 DWORD PTR _tab_item$11[ebp], eax
  003c7	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _tab_item$11[ebp], 0
  003ce	74 5f		 je	 SHORT $LN7@TabBarScro

; 6805 :         {
; 6806 :             int selected_order = tab_bar->GetTabOrder(tab_item);

  003d0	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _tab_item$11[ebp]
  003d6	50		 push	 eax
  003d7	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  003da	e8 00 00 00 00	 call	 ?GetTabOrder@ImGuiTabBar@@QBEHPBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
  003df	89 85 38 ff ff
	ff		 mov	 DWORD PTR _selected_order$10[ebp], eax

; 6807 :             int target_order = selected_order + select_dir;

  003e5	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _selected_order$10[ebp]
  003eb	03 45 80	 add	 eax, DWORD PTR _select_dir$[ebp]
  003ee	89 85 2c ff ff
	ff		 mov	 DWORD PTR _target_order$9[ebp], eax

; 6808 :             tab_to_select = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order]; // If we are at the end of the list, still scroll to make our tab visible

  003f4	78 1b		 js	 SHORT $LN11@TabBarScro
  003f6	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  003f9	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _target_order$9[ebp]
  003ff	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00401	7d 0e		 jge	 SHORT $LN11@TabBarScro
  00403	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _target_order$9[ebp]
  00409	89 95 d4 fd ff
	ff		 mov	 DWORD PTR tv248[ebp], edx
  0040f	eb 0c		 jmp	 SHORT $LN12@TabBarScro
$LN11@TabBarScro:
  00411	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _selected_order$10[ebp]
  00417	89 85 d4 fd ff
	ff		 mov	 DWORD PTR tv248[ebp], eax
$LN12@TabBarScro:
  0041d	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR tv248[ebp]
  00423	51		 push	 ecx
  00424	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00427	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  0042c	89 45 8c	 mov	 DWORD PTR _tab_to_select$[ebp], eax
$LN7@TabBarScro:

; 6809 :         }
; 6810 :     window->DC.CursorPos = backup_cursor_pos;

  0042f	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00432	8b 4d bc	 mov	 ecx, DWORD PTR _backup_cursor_pos$[ebp]
  00435	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  0043b	8b 55 c0	 mov	 edx, DWORD PTR _backup_cursor_pos$[ebp+4]
  0043e	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 6811 :     tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

  00444	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _scrolling_buttons_width$[ebp]
  00449	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00451	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00454	f3 0f 10 48 2c	 movss	 xmm1, DWORD PTR [eax+44]
  00459	f3 0f 5c c8	 subss	 xmm1, xmm0
  0045d	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00460	f3 0f 11 49 2c	 movss	 DWORD PTR [ecx+44], xmm1

; 6812 : 
; 6813 :     return tab_to_select;

  00465	8b 45 8c	 mov	 eax, DWORD PTR _tab_to_select$[ebp]

; 6814 : }

  00468	52		 push	 edx
  00469	8b cd		 mov	 ecx, ebp
  0046b	50		 push	 eax
  0046c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@TabBarScro
  00472	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00477	58		 pop	 eax
  00478	5a		 pop	 edx
  00479	5f		 pop	 edi
  0047a	5e		 pop	 esi
  0047b	5b		 pop	 ebx
  0047c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047f	33 cd		 xor	 ecx, ebp
  00481	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00486	81 c4 2c 02 00
	00		 add	 esp, 556		; 0000022cH
  0048c	3b ec		 cmp	 ebp, esp
  0048e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00493	8b e5		 mov	 esp, ebp
  00495	5d		 pop	 ebp
  00496	c3		 ret	 0
  00497	90		 npad	 1
$LN18@TabBarScro:
  00498	04 00 00 00	 DD	 4
  0049c	00 00 00 00	 DD	 $LN17@TabBarScro
$LN17@TabBarScro:
  004a0	d8 ff ff ff	 DD	 -40			; ffffffd8H
  004a4	08 00 00 00	 DD	 8
  004a8	00 00 00 00	 DD	 $LN13@TabBarScro
  004ac	bc ff ff ff	 DD	 -68			; ffffffbcH
  004b0	08 00 00 00	 DD	 8
  004b4	00 00 00 00	 DD	 $LN14@TabBarScro
  004b8	a4 ff ff ff	 DD	 -92			; ffffffa4H
  004bc	10 00 00 00	 DD	 16			; 00000010H
  004c0	00 00 00 00	 DD	 $LN15@TabBarScro
  004c4	68 ff ff ff	 DD	 -152			; ffffff68H
  004c8	10 00 00 00	 DD	 16			; 00000010H
  004cc	00 00 00 00	 DD	 $LN16@TabBarScro
$LN16@TabBarScro:
  004d0	61		 DB	 97			; 00000061H
  004d1	72		 DB	 114			; 00000072H
  004d2	72		 DB	 114			; 00000072H
  004d3	6f		 DB	 111			; 0000006fH
  004d4	77		 DB	 119			; 00000077H
  004d5	5f		 DB	 95			; 0000005fH
  004d6	63		 DB	 99			; 00000063H
  004d7	6f		 DB	 111			; 0000006fH
  004d8	6c		 DB	 108			; 0000006cH
  004d9	00		 DB	 0
$LN15@TabBarScro:
  004da	61		 DB	 97			; 00000061H
  004db	76		 DB	 118			; 00000076H
  004dc	61		 DB	 97			; 00000061H
  004dd	69		 DB	 105			; 00000069H
  004de	6c		 DB	 108			; 0000006cH
  004df	5f		 DB	 95			; 0000005fH
  004e0	62		 DB	 98			; 00000062H
  004e1	61		 DB	 97			; 00000061H
  004e2	72		 DB	 114			; 00000072H
  004e3	5f		 DB	 95			; 0000005fH
  004e4	72		 DB	 114			; 00000072H
  004e5	65		 DB	 101			; 00000065H
  004e6	63		 DB	 99			; 00000063H
  004e7	74		 DB	 116			; 00000074H
  004e8	00		 DB	 0
$LN14@TabBarScro:
  004e9	62		 DB	 98			; 00000062H
  004ea	61		 DB	 97			; 00000061H
  004eb	63		 DB	 99			; 00000063H
  004ec	6b		 DB	 107			; 0000006bH
  004ed	75		 DB	 117			; 00000075H
  004ee	70		 DB	 112			; 00000070H
  004ef	5f		 DB	 95			; 0000005fH
  004f0	63		 DB	 99			; 00000063H
  004f1	75		 DB	 117			; 00000075H
  004f2	72		 DB	 114			; 00000072H
  004f3	73		 DB	 115			; 00000073H
  004f4	6f		 DB	 111			; 0000006fH
  004f5	72		 DB	 114			; 00000072H
  004f6	5f		 DB	 95			; 0000005fH
  004f7	70		 DB	 112			; 00000070H
  004f8	6f		 DB	 111			; 0000006fH
  004f9	73		 DB	 115			; 00000073H
  004fa	00		 DB	 0
$LN13@TabBarScro:
  004fb	61		 DB	 97			; 00000061H
  004fc	72		 DB	 114			; 00000072H
  004fd	72		 DB	 114			; 00000072H
  004fe	6f		 DB	 111			; 0000006fH
  004ff	77		 DB	 119			; 00000077H
  00500	5f		 DB	 95			; 0000005fH
  00501	62		 DB	 98			; 00000062H
  00502	75		 DB	 117			; 00000075H
  00503	74		 DB	 116			; 00000074H
  00504	74		 DB	 116			; 00000074H
  00505	6f		 DB	 111			; 0000006fH
  00506	6e		 DB	 110			; 0000006eH
  00507	5f		 DB	 95			; 0000005fH
  00508	73		 DB	 115			; 00000073H
  00509	69		 DB	 105			; 00000069H
  0050a	7a		 DB	 122			; 0000007aH
  0050b	65		 DB	 101			; 00000065H
  0050c	00		 DB	 0
?TabBarScrollingButtons@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarScrollingButtons
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarScrollToTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z
_TEXT	SEGMENT
tv182 = -260						; size = 4
tv221 = -256						; size = 4
tv217 = -256						; size = 4
tv204 = -256						; size = 4
tv197 = -256						; size = 4
tv81 = -256						; size = 4
tv72 = -256						; size = 4
_tab_x2$ = -56						; size = 4
_tab_x1$ = -44						; size = 4
_order$ = -32						; size = 4
_margin$ = -20						; size = 4
_g$ = -8						; size = 4
_tab_bar$ = 8						; size = 4
_tab$ = 12						; size = 4
?TabBarScrollToTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z PROC ; ImGui::TabBarScrollToTab, COMDAT

; 6735 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-260]
  00012	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6736 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6737 :     float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  0003b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  00043	f3 0f 11 45 ec	 movss	 DWORD PTR _margin$[ebp], xmm0

; 6738 :     int order = tab_bar->GetTabOrder(tab);

  00048	8b 45 0c	 mov	 eax, DWORD PTR _tab$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetTabOrder@ImGuiTabBar@@QBEHPBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
  00054	89 45 e0	 mov	 DWORD PTR _order$[ebp], eax

; 6739 :     float tab_x1 = tab->Offset + (order > 0 ? -margin : 0.0f);

  00057	83 7d e0 00	 cmp	 DWORD PTR _order$[ebp], 0
  0005b	7e 16		 jle	 SHORT $LN7@TabBarScro
  0005d	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _margin$[ebp]
  00062	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00069	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv72[ebp], xmm0
  00071	eb 0b		 jmp	 SHORT $LN8@TabBarScro
$LN7@TabBarScro:
  00073	0f 57 c0	 xorps	 xmm0, xmm0
  00076	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv72[ebp], xmm0
$LN8@TabBarScro:
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _tab$[ebp]
  00081	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00086	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR tv72[ebp]
  0008e	f3 0f 11 45 d4	 movss	 DWORD PTR _tab_x1$[ebp], xmm0

; 6740 :     float tab_x2 = tab->Offset + tab->Width + (order + 1 < tab_bar->Tabs.Size ? margin : 1.0f);

  00093	8b 45 e0	 mov	 eax, DWORD PTR _order$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0009c	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0009e	7d 0f		 jge	 SHORT $LN9@TabBarScro
  000a0	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _margin$[ebp]
  000a5	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv81[ebp], xmm0
  000ad	eb 10		 jmp	 SHORT $LN10@TabBarScro
$LN9@TabBarScro:
  000af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b7	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv81[ebp], xmm0
$LN10@TabBarScro:
  000bf	8b 55 0c	 mov	 edx, DWORD PTR _tab$[ebp]
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _tab$[ebp]
  000c5	f3 0f 10 42 14	 movss	 xmm0, DWORD PTR [edx+20]
  000ca	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [eax+24]
  000cf	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR tv81[ebp]
  000d7	f3 0f 11 45 c8	 movss	 DWORD PTR _tab_x2$[ebp], xmm0

; 6741 :     tab_bar->ScrollingTargetDistToVisibility = 0.0f;

  000dc	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000df	0f 57 c0	 xorps	 xmm0, xmm0
  000e2	f3 0f 11 40 4c	 movss	 DWORD PTR [eax+76], xmm0

; 6742 :     if (tab_bar->ScrollingTarget > tab_x1 || (tab_x2 - tab_x1 >= tab_bar->BarRect.GetWidth()))

  000e7	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000ea	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  000ef	0f 2f 45 d4	 comiss	 xmm0, DWORD PTR _tab_x1$[ebp]
  000f3	77 34		 ja	 SHORT $LN4@TabBarScro
  000f5	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _tab_x2$[ebp]
  000fa	f3 0f 5c 45 d4	 subss	 xmm0, DWORD PTR _tab_x1$[ebp]
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00102	83 c1 24	 add	 ecx, 36			; 00000024H
  00105	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv221[ebp], xmm0
  0010d	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  00112	d9 9d fc fe ff
	ff		 fstp	 DWORD PTR tv182[ebp]
  00118	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR tv221[ebp]
  00120	0f 2f 85 fc fe
	ff ff		 comiss	 xmm0, DWORD PTR tv182[ebp]
  00127	72 3c		 jb	 SHORT $LN2@TabBarScro
$LN4@TabBarScro:

; 6743 :     {
; 6744 :         tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);

  00129	51		 push	 ecx
  0012a	0f 57 c0	 xorps	 xmm0, xmm0
  0012d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00132	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00135	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  0013a	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _tab_x2$[ebp]
  0013f	51		 push	 ecx
  00140	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00145	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0014a	83 c4 08	 add	 esp, 8
  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00150	d9 59 4c	 fstp	 DWORD PTR [ecx+76]

; 6745 :         tab_bar->ScrollingTarget = tab_x1;

  00153	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00156	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _tab_x1$[ebp]
  0015b	f3 0f 11 40 48	 movss	 DWORD PTR [eax+72], xmm0

; 6746 :     }

  00160	e9 90 00 00 00	 jmp	 $LN5@TabBarScro
$LN2@TabBarScro:

; 6747 :     else if (tab_bar->ScrollingTarget < tab_x2 - tab_bar->BarRect.GetWidth())

  00165	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00168	83 c1 24	 add	 ecx, 36			; 00000024H
  0016b	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  00170	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv197[ebp]
  00176	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _tab_x2$[ebp]
  0017b	f3 0f 5c 85 00
	ff ff ff	 subss	 xmm0, DWORD PTR tv197[ebp]
  00183	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00186	0f 2f 40 48	 comiss	 xmm0, DWORD PTR [eax+72]
  0018a	76 69		 jbe	 SHORT $LN5@TabBarScro

; 6748 :     {
; 6749 :         tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - tab_bar->BarRect.GetWidth()) - tab_bar->ScrollingAnim, 0.0f);

  0018c	51		 push	 ecx
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00198	83 c1 24	 add	 ecx, 36			; 00000024H
  0019b	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  001a0	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv204[ebp]
  001a6	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _tab_x1$[ebp]
  001ab	f3 0f 5c 85 00
	ff ff ff	 subss	 xmm0, DWORD PTR tv204[ebp]
  001b3	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  001b6	f3 0f 5c 40 44	 subss	 xmm0, DWORD PTR [eax+68]
  001bb	51		 push	 ecx
  001bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c1	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001c6	83 c4 08	 add	 esp, 8
  001c9	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001cc	d9 59 4c	 fstp	 DWORD PTR [ecx+76]

; 6750 :         tab_bar->ScrollingTarget = tab_x2 - tab_bar->BarRect.GetWidth();

  001cf	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001d2	83 c1 24	 add	 ecx, 36			; 00000024H
  001d5	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  001da	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv217[ebp]
  001e0	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _tab_x2$[ebp]
  001e5	f3 0f 5c 85 00
	ff ff ff	 subss	 xmm0, DWORD PTR tv217[ebp]
  001ed	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  001f0	f3 0f 11 40 48	 movss	 DWORD PTR [eax+72], xmm0
$LN5@TabBarScro:

; 6751 :     }
; 6752 : }

  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  001fe	3b ec		 cmp	 ebp, esp
  00200	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
?TabBarScrollToTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z ENDP ; ImGui::TabBarScrollToTab
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarScrollClamp@ImGui@@YAMPAUImGuiTabBar@@M@Z
_TEXT	SEGMENT
tv80 = -196						; size = 4
_tab_bar$ = 8						; size = 4
_scrolling$ = 12					; size = 4
?TabBarScrollClamp@ImGui@@YAMPAUImGuiTabBar@@M@Z PROC	; ImGui::TabBarScrollClamp, COMDAT

; 6729 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6730 :     scrolling = ImMin(scrolling, tab_bar->OffsetMax - tab_bar->BarRect.GetWidth());

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0002b	83 c1 24	 add	 ecx, 36			; 00000024H
  0002e	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  00033	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv80[ebp]
  00039	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0003c	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  00041	f3 0f 5c 85 3c
	ff ff ff	 subss	 xmm0, DWORD PTR tv80[ebp]
  00049	51		 push	 ecx
  0004a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004f	51		 push	 ecx
  00050	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _scrolling$[ebp]
  00055	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005a	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0005f	83 c4 08	 add	 esp, 8
  00062	d9 5d 0c	 fstp	 DWORD PTR _scrolling$[ebp]

; 6731 :     return ImMax(scrolling, 0.0f);

  00065	51		 push	 ecx
  00066	0f 57 c0	 xorps	 xmm0, xmm0
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	51		 push	 ecx
  0006f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _scrolling$[ebp]
  00074	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00079	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0007e	83 c4 08	 add	 esp, 8

; 6732 : }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?TabBarScrollClamp@ImGui@@YAMPAUImGuiTabBar@@M@Z ENDP	; ImGui::TabBarScrollClamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarCalcMaxTabWidth@ImGui@@YAMXZ
_TEXT	SEGMENT
tv71 = -208						; size = 4
_g$ = -8						; size = 4
?TabBarCalcMaxTabWidth@ImGui@@YAMXZ PROC		; ImGui::TabBarCalcMaxTabWidth, COMDAT

; 6687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6688 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6689 :     return g.FontSize * 20.0f;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  0003b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41a00000
  00043	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
  0004b	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv71[ebp]

; 6690 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?TabBarCalcMaxTabWidth@ImGui@@YAMXZ ENDP		; ImGui::TabBarCalcMaxTabWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarCalcTabID@ImGui@@YAIPAUImGuiTabBar@@PBD@Z
_TEXT	SEGMENT
_window$1 = -20						; size = 4
_id$2 = -8						; size = 4
_tab_bar$ = 8						; size = 4
_label$ = 12						; size = 4
?TabBarCalcTabID@ImGui@@YAIPAUImGuiTabBar@@PBD@Z PROC	; ImGui::TabBarCalcTabID, COMDAT

; 6672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6673 :     if (tab_bar->Flags & ImGuiTabBarFlags_DockNode)

  00028	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0002b	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0002e	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  00034	74 26		 je	 SHORT $LN2@TabBarCalc

; 6674 :     {
; 6675 :         ImGuiID id = ImHashStr(label);

  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?ImHashStr@@YAIPBDII@Z	; ImHashStr
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	89 45 f8	 mov	 DWORD PTR _id$2[ebp], eax

; 6676 :         KeepAliveID(id);

  00049	8b 45 f8	 mov	 eax, DWORD PTR _id$2[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?KeepAliveID@ImGui@@YAXI@Z ; ImGui::KeepAliveID
  00052	83 c4 04	 add	 esp, 4

; 6677 :         return id;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _id$2[ebp]
  00058	eb 1e		 jmp	 SHORT $LN1@TabBarCalc

; 6678 :     }

  0005a	eb 1c		 jmp	 SHORT $LN1@TabBarCalc
$LN2@TabBarCalc:

; 6679 :     else
; 6680 :     {
; 6681 :         ImGuiWindow* window = GImGui->CurrentWindow;

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00061	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00067	89 4d ec	 mov	 DWORD PTR _window$1[ebp], ecx

; 6682 :         return window->GetID(label);

  0006a	6a 00		 push	 0
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d ec	 mov	 ecx, DWORD PTR _window$1[ebp]
  00073	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
$LN1@TabBarCalc:

; 6683 :     }
; 6684 : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?TabBarCalcTabID@ImGui@@YAIPAUImGuiTabBar@@PBD@Z ENDP	; ImGui::TabBarCalcTabID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z
_TEXT	SEGMENT
tv392 = -641						; size = 1
tv822 = -640						; size = 4
tv785 = -640						; size = 4
tv717 = -640						; size = 4
tv622 = -640						; size = 4
tv476 = -640						; size = 4
tv248 = -640						; size = 4
tv223 = -640						; size = 4
tv461 = -637						; size = 1
tv212 = -637						; size = 1
tv169 = -637						; size = 1
$T1 = -632						; size = 8
_teleport$2 = -421					; size = 1
_scroll_track_selected_tab$3 = -412			; size = 4
_tab_to_select$4 = -400					; size = 4
_scrolling_buttons$ = -385				; size = 1
_tab$5 = -376						; size = 4
_tab_n$6 = -364						; size = 4
_offset_x_ideal$ = -352					; size = 4
_offset_x$ = -340					; size = 4
_tab$7 = -328						; size = 4
_tab_n$8 = -316						; size = 4
_tab_max_width$9 = -304					; size = 4
_tab_n$10 = -292					; size = 4
_width_excess$ = -280					; size = 4
_width_avail$ = -268					; size = 4
_initial_offset_x$ = -256				; size = 4
_has_close_button$11 = -241				; size = 1
_tab_name$12 = -232					; size = 4
_tab$13 = -220						; size = 4
_tab_n$14 = -208					; size = 4
_found_selected_tab_id$ = -193				; size = 1
_most_recently_selected_tab$ = -184			; size = 4
_width_total_contents$ = -172				; size = 4
_tab_to_select$15 = -160				; size = 4
_tab_list_popup_button$ = -145				; size = 1
_item_tmp$16 = -136					; size = 32
_tab2$17 = -96						; size = 4
_tab2_order$18 = -84					; size = 4
_tab1$19 = -72						; size = 4
_scroll_track_selected_tab_id$ = -60			; size = 4
_tab$20 = -48						; size = 4
_tab_src_n$21 = -36					; size = 4
_tab_dst_n$ = -24					; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_tab_bar$ = 8						; size = 4
?TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z PROC		; ImGui::TabBarLayout, COMDAT

; 6502 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 7c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-644]
  00012	b9 a1 00 00 00	 mov	 ecx, 161		; 000000a1H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6503 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 6504 :     tab_bar->WantLayout = false;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0003d	c6 40 5d 00	 mov	 BYTE PTR [eax+93], 0

; 6505 : 
; 6506 :     // Garbage collect
; 6507 :     int tab_dst_n = 0;

  00041	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _tab_dst_n$[ebp], 0

; 6508 :     for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)

  00048	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _tab_src_n$21[ebp], 0
  0004f	eb 09		 jmp	 SHORT $LN4@TabBarLayo
$LN2@TabBarLayo:
  00051	8b 45 dc	 mov	 eax, DWORD PTR _tab_src_n$21[ebp]
  00054	83 c0 01	 add	 eax, 1
  00057	89 45 dc	 mov	 DWORD PTR _tab_src_n$21[ebp], eax
$LN4@TabBarLayo:
  0005a	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0005d	8b 4d dc	 mov	 ecx, DWORD PTR _tab_src_n$21[ebp]
  00060	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00062	7d 6c		 jge	 SHORT $LN3@TabBarLayo

; 6509 :     {
; 6510 :         ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];

  00064	8b 45 dc	 mov	 eax, DWORD PTR _tab_src_n$21[ebp]
  00067	50		 push	 eax
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0006b	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  00070	89 45 d0	 mov	 DWORD PTR _tab$20[ebp], eax

; 6511 :         if (tab->LastFrameVisible < tab_bar->PrevFrameVisible)

  00073	8b 45 d0	 mov	 eax, DWORD PTR _tab$20[ebp]
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00079	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0007c	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  0007f	7d 19		 jge	 SHORT $LN17@TabBarLayo

; 6512 :         {
; 6513 :             if (tab->ID == tab_bar->SelectedTabId)

  00081	8b 45 d0	 mov	 eax, DWORD PTR _tab$20[ebp]
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00087	8b 10		 mov	 edx, DWORD PTR [eax]
  00089	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0008c	75 0a		 jne	 SHORT $LN18@TabBarLayo

; 6514 :                 tab_bar->SelectedTabId = 0;

  0008e	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00091	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN18@TabBarLayo:

; 6515 :             continue;

  00098	eb b7		 jmp	 SHORT $LN2@TabBarLayo
$LN17@TabBarLayo:

; 6516 :         }
; 6517 :         if (tab_dst_n != tab_src_n)

  0009a	8b 45 e8	 mov	 eax, DWORD PTR _tab_dst_n$[ebp]
  0009d	3b 45 dc	 cmp	 eax, DWORD PTR _tab_src_n$21[ebp]
  000a0	74 23		 je	 SHORT $LN19@TabBarLayo

; 6518 :             tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];

  000a2	8b 45 dc	 mov	 eax, DWORD PTR _tab_src_n$21[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  000a9	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  000ae	8b f0		 mov	 esi, eax
  000b0	8b 4d e8	 mov	 ecx, DWORD PTR _tab_dst_n$[ebp]
  000b3	51		 push	 ecx
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  000b7	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  000bc	b9 08 00 00 00	 mov	 ecx, 8
  000c1	8b f8		 mov	 edi, eax
  000c3	f3 a5		 rep movsd
$LN19@TabBarLayo:

; 6519 :         tab_dst_n++;

  000c5	8b 45 e8	 mov	 eax, DWORD PTR _tab_dst_n$[ebp]
  000c8	83 c0 01	 add	 eax, 1
  000cb	89 45 e8	 mov	 DWORD PTR _tab_dst_n$[ebp], eax

; 6520 :     }

  000ce	eb 81		 jmp	 SHORT $LN2@TabBarLayo
$LN3@TabBarLayo:

; 6521 :     if (tab_bar->Tabs.Size != tab_dst_n)

  000d0	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	3b 4d e8	 cmp	 ecx, DWORD PTR _tab_dst_n$[ebp]
  000d8	74 0c		 je	 SHORT $LN20@TabBarLayo

; 6522 :         tab_bar->Tabs.resize(tab_dst_n);

  000da	8b 45 e8	 mov	 eax, DWORD PTR _tab_dst_n$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  000e1	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiTabItem@@@@QAEXH@Z ; ImVector<ImGuiTabItem>::resize
$LN20@TabBarLayo:

; 6523 : 
; 6524 :     // Setup next selected tab
; 6525 :     ImGuiID scroll_track_selected_tab_id = 0;

  000e6	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _scroll_track_selected_tab_id$[ebp], 0

; 6526 :     if (tab_bar->NextSelectedTabId)

  000ed	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000f0	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  000f4	74 1f		 je	 SHORT $LN21@TabBarLayo

; 6527 :     {
; 6528 :         tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;

  000f6	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  000fc	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000ff	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 6529 :         tab_bar->NextSelectedTabId = 0;

  00102	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00105	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 6530 :         scroll_track_selected_tab_id = tab_bar->SelectedTabId;

  0010c	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0010f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00112	89 4d c4	 mov	 DWORD PTR _scroll_track_selected_tab_id$[ebp], ecx
$LN21@TabBarLayo:

; 6531 :     }
; 6532 : 
; 6533 :     // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
; 6534 :     if (tab_bar->ReorderRequestTabId != 0)

  00115	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00118	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0011c	0f 84 bf 00 00
	00		 je	 $LN22@TabBarLayo

; 6535 :     {
; 6536 :         if (ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId))

  00122	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00125	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00128	51		 push	 ecx
  00129	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 ?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
  00132	83 c4 08	 add	 esp, 8
  00135	89 45 b8	 mov	 DWORD PTR _tab1$19[ebp], eax
  00138	83 7d b8 00	 cmp	 DWORD PTR _tab1$19[ebp], 0
  0013c	0f 84 95 00 00
	00		 je	 $LN26@TabBarLayo

; 6537 :         {
; 6538 :             //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
; 6539 :             int tab2_order = tab_bar->GetTabOrder(tab1) + tab_bar->ReorderRequestDir;

  00142	8b 45 b8	 mov	 eax, DWORD PTR _tab1$19[ebp]
  00145	50		 push	 eax
  00146	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00149	e8 00 00 00 00	 call	 ?GetTabOrder@ImGuiTabBar@@QBEHPBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabOrder
  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00151	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00155	03 c2		 add	 eax, edx
  00157	89 45 ac	 mov	 DWORD PTR _tab2_order$18[ebp], eax

; 6540 :             if (tab2_order >= 0 && tab2_order < tab_bar->Tabs.Size)

  0015a	78 68		 js	 SHORT $LN24@TabBarLayo
  0015c	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0015f	8b 4d ac	 mov	 ecx, DWORD PTR _tab2_order$18[ebp]
  00162	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00164	7d 5e		 jge	 SHORT $LN24@TabBarLayo

; 6541 :             {
; 6542 :                 ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];

  00166	8b 45 ac	 mov	 eax, DWORD PTR _tab2_order$18[ebp]
  00169	50		 push	 eax
  0016a	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0016d	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  00172	89 45 a0	 mov	 DWORD PTR _tab2$17[ebp], eax

; 6543 :                 ImGuiTabItem item_tmp = *tab1;

  00175	b9 08 00 00 00	 mov	 ecx, 8
  0017a	8b 75 b8	 mov	 esi, DWORD PTR _tab1$19[ebp]
  0017d	8d bd 78 ff ff
	ff		 lea	 edi, DWORD PTR _item_tmp$16[ebp]
  00183	f3 a5		 rep movsd

; 6544 :                 *tab1 = *tab2;

  00185	b9 08 00 00 00	 mov	 ecx, 8
  0018a	8b 75 a0	 mov	 esi, DWORD PTR _tab2$17[ebp]
  0018d	8b 7d b8	 mov	 edi, DWORD PTR _tab1$19[ebp]
  00190	f3 a5		 rep movsd

; 6545 :                 *tab2 = item_tmp;

  00192	b9 08 00 00 00	 mov	 ecx, 8
  00197	8d b5 78 ff ff
	ff		 lea	 esi, DWORD PTR _item_tmp$16[ebp]
  0019d	8b 7d a0	 mov	 edi, DWORD PTR _tab2$17[ebp]
  001a0	f3 a5		 rep movsd

; 6546 :                 if (tab2->ID == tab_bar->SelectedTabId)

  001a2	8b 45 a0	 mov	 eax, DWORD PTR _tab2$17[ebp]
  001a5	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001a8	8b 10		 mov	 edx, DWORD PTR [eax]
  001aa	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  001ad	75 08		 jne	 SHORT $LN25@TabBarLayo

; 6547 :                     scroll_track_selected_tab_id = tab2->ID;

  001af	8b 45 a0	 mov	 eax, DWORD PTR _tab2$17[ebp]
  001b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b4	89 4d c4	 mov	 DWORD PTR _scroll_track_selected_tab_id$[ebp], ecx
$LN25@TabBarLayo:

; 6548 :                 tab1 = tab2 = NULL;

  001b7	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _tab2$17[ebp], 0
  001be	8b 45 a0	 mov	 eax, DWORD PTR _tab2$17[ebp]
  001c1	89 45 b8	 mov	 DWORD PTR _tab1$19[ebp], eax
$LN24@TabBarLayo:

; 6549 :             }
; 6550 :             if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)

  001c4	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  001c7	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  001ca	81 e1 00 00 40
	00		 and	 ecx, 4194304		; 00400000H
  001d0	74 05		 je	 SHORT $LN26@TabBarLayo

; 6551 :                 MarkIniSettingsDirty();

  001d2	e8 00 00 00 00	 call	 ?MarkIniSettingsDirty@ImGui@@YAXXZ ; ImGui::MarkIniSettingsDirty
$LN26@TabBarLayo:

; 6552 :         }
; 6553 :         tab_bar->ReorderRequestTabId = 0;

  001d7	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  001da	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
$LN22@TabBarLayo:

; 6554 :     }
; 6555 : 
; 6556 :     // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
; 6557 :     const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;

  001e1	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  001e4	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  001e7	83 e1 04	 and	 ecx, 4
  001ea	74 09		 je	 SHORT $LN45@TabBarLayo
  001ec	c6 85 83 fd ff
	ff 01		 mov	 BYTE PTR tv169[ebp], 1
  001f3	eb 07		 jmp	 SHORT $LN46@TabBarLayo
$LN45@TabBarLayo:
  001f5	c6 85 83 fd ff
	ff 00		 mov	 BYTE PTR tv169[ebp], 0
$LN46@TabBarLayo:
  001fc	8a 95 83 fd ff
	ff		 mov	 dl, BYTE PTR tv169[ebp]
  00202	88 95 6f ff ff
	ff		 mov	 BYTE PTR _tab_list_popup_button$[ebp], dl

; 6558 :     if (tab_list_popup_button)

  00208	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _tab_list_popup_button$[ebp]
  0020f	85 c0		 test	 eax, eax
  00211	74 32		 je	 SHORT $LN28@TabBarLayo

; 6559 :         if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Max.x!

  00213	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 ?TabBarTabListPopupButton@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z ; ImGui::TabBarTabListPopupButton
  0021c	83 c4 04	 add	 esp, 4
  0021f	89 85 60 ff ff
	ff		 mov	 DWORD PTR _tab_to_select$15[ebp], eax
  00225	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR _tab_to_select$15[ebp], 0
  0022c	74 17		 je	 SHORT $LN28@TabBarLayo

; 6560 :             scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

  0022e	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00231	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _tab_to_select$15[ebp]
  00237	8b 11		 mov	 edx, DWORD PTR [ecx]
  00239	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0023c	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0023f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00242	89 4d c4	 mov	 DWORD PTR _scroll_track_selected_tab_id$[ebp], ecx
$LN28@TabBarLayo:

; 6561 : 
; 6562 :     // Compute ideal widths
; 6563 :     g.ShrinkWidthBuffer.resize(tab_bar->Tabs.Size);

  00245	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00248	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024a	51		 push	 ecx
  0024b	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0024e	81 c1 ec 1d 00
	00		 add	 ecx, 7660		; 00001decH
  00254	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z ; ImVector<ImGuiShrinkWidthItem>::resize

; 6564 :     float width_total_contents = 0.0f;

  00259	0f 57 c0	 xorps	 xmm0, xmm0
  0025c	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _width_total_contents$[ebp], xmm0

; 6565 :     ImGuiTabItem* most_recently_selected_tab = NULL;

  00264	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _most_recently_selected_tab$[ebp], 0

; 6566 :     bool found_selected_tab_id = false;

  0026e	c6 85 3f ff ff
	ff 00		 mov	 BYTE PTR _found_selected_tab_id$[ebp], 0

; 6567 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

  00275	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _tab_n$14[ebp], 0
  0027f	eb 0f		 jmp	 SHORT $LN7@TabBarLayo
$LN5@TabBarLayo:
  00281	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _tab_n$14[ebp]
  00287	83 c0 01	 add	 eax, 1
  0028a	89 85 30 ff ff
	ff		 mov	 DWORD PTR _tab_n$14[ebp], eax
$LN7@TabBarLayo:
  00290	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00293	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _tab_n$14[ebp]
  00299	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0029b	0f 8d 85 01 00
	00		 jge	 $LN6@TabBarLayo

; 6568 :     {
; 6569 :         ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

  002a1	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _tab_n$14[ebp]
  002a7	50		 push	 eax
  002a8	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  002ab	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  002b0	89 85 24 ff ff
	ff		 mov	 DWORD PTR _tab$13[ebp], eax

; 6570 :         IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);

  002b6	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _tab$13[ebp]
  002bc	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  002bf	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002c2	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  002c5	7d 25		 jge	 SHORT $LN47@TabBarLayo
  002c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z@4JA
  002cc	83 c0 44	 add	 eax, 68			; 00000044H
  002cf	8b f4		 mov	 esi, esp
  002d1	50		 push	 eax
  002d2	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_1GG@ODBMJKON@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAF?$AAr?$AAa?$AAm?$AAe?$AAV@
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  002e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e5	3b f4		 cmp	 esi, esp
  002e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN47@TabBarLayo:

; 6571 : 
; 6572 :         if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)

  002ec	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _most_recently_selected_tab$[ebp], 0
  002f3	74 14		 je	 SHORT $LN30@TabBarLayo
  002f5	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _most_recently_selected_tab$[ebp]
  002fb	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _tab$13[ebp]
  00301	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00304	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00307	7d 0c		 jge	 SHORT $LN29@TabBarLayo
$LN30@TabBarLayo:

; 6573 :             most_recently_selected_tab = tab;

  00309	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _tab$13[ebp]
  0030f	89 85 48 ff ff
	ff		 mov	 DWORD PTR _most_recently_selected_tab$[ebp], eax
$LN29@TabBarLayo:

; 6574 :         if (tab->ID == tab_bar->SelectedTabId)

  00315	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _tab$13[ebp]
  0031b	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0031e	8b 10		 mov	 edx, DWORD PTR [eax]
  00320	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00323	75 07		 jne	 SHORT $LN31@TabBarLayo

; 6575 :             found_selected_tab_id = true;

  00325	c6 85 3f ff ff
	ff 01		 mov	 BYTE PTR _found_selected_tab_id$[ebp], 1
$LN31@TabBarLayo:

; 6576 : 
; 6577 :         // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
; 6578 :         // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
; 6579 :         // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
; 6580 :         const char* tab_name = tab_bar->GetTabName(tab);

  0032c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _tab$13[ebp]
  00332	50		 push	 eax
  00333	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00336	e8 00 00 00 00	 call	 ?GetTabName@ImGuiTabBar@@QBEPBDPBUImGuiTabItem@@@Z ; ImGuiTabBar::GetTabName
  0033b	89 85 18 ff ff
	ff		 mov	 DWORD PTR _tab_name$12[ebp], eax

; 6581 :         const bool has_close_button = (tab->Flags & ImGuiTabItemFlags_NoCloseButton) ? false : true;

  00341	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _tab$13[ebp]
  00347	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0034a	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  00350	74 09		 je	 SHORT $LN48@TabBarLayo
  00352	c6 85 83 fd ff
	ff 00		 mov	 BYTE PTR tv212[ebp], 0
  00359	eb 07		 jmp	 SHORT $LN49@TabBarLayo
$LN48@TabBarLayo:
  0035b	c6 85 83 fd ff
	ff 01		 mov	 BYTE PTR tv212[ebp], 1
$LN49@TabBarLayo:
  00362	8a 95 83 fd ff
	ff		 mov	 dl, BYTE PTR tv212[ebp]
  00368	88 95 0f ff ff
	ff		 mov	 BYTE PTR _has_close_button$11[ebp], dl

; 6582 :         tab->ContentWidth = TabItemCalcSize(tab_name, has_close_button).x;

  0036e	0f b6 85 0f ff
	ff ff		 movzx	 eax, BYTE PTR _has_close_button$11[ebp]
  00375	50		 push	 eax
  00376	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _tab_name$12[ebp]
  0037c	51		 push	 ecx
  0037d	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00383	52		 push	 edx
  00384	e8 00 00 00 00	 call	 ?TabItemCalcSize@ImGui@@YA?AUImVec2@@PBD_N@Z ; ImGui::TabItemCalcSize
  00389	83 c4 0c	 add	 esp, 12			; 0000000cH
  0038c	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _tab$13[ebp]
  00392	8b 10		 mov	 edx, DWORD PTR [eax]
  00394	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 6583 : 
; 6584 :         width_total_contents += (tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0.0f) + tab->ContentWidth;

  00397	83 bd 30 ff ff
	ff 00		 cmp	 DWORD PTR _tab_n$14[ebp], 0
  0039e	7e 15		 jle	 SHORT $LN50@TabBarLayo
  003a0	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  003a3	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  003ab	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv223[ebp], xmm0
  003b3	eb 0b		 jmp	 SHORT $LN51@TabBarLayo
$LN50@TabBarLayo:
  003b5	0f 57 c0	 xorps	 xmm0, xmm0
  003b8	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv223[ebp], xmm0
$LN51@TabBarLayo:
  003c0	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _tab$13[ebp]
  003c6	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv223[ebp]
  003ce	f3 0f 58 41 1c	 addss	 xmm0, DWORD PTR [ecx+28]
  003d3	f3 0f 58 85 54
	ff ff ff	 addss	 xmm0, DWORD PTR _width_total_contents$[ebp]
  003db	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _width_total_contents$[ebp], xmm0

; 6585 : 
; 6586 :         // Store data so we can build an array sorted by width if we need to shrink tabs down
; 6587 :         g.ShrinkWidthBuffer[tab_n].Index = tab_n;

  003e3	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _tab_n$14[ebp]
  003e9	50		 push	 eax
  003ea	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  003ed	81 c1 ec 1d 00
	00		 add	 ecx, 7660		; 00001decH
  003f3	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z ; ImVector<ImGuiShrinkWidthItem>::operator[]
  003f8	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _tab_n$14[ebp]
  003fe	89 08		 mov	 DWORD PTR [eax], ecx

; 6588 :         g.ShrinkWidthBuffer[tab_n].Width = tab->ContentWidth;

  00400	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _tab_n$14[ebp]
  00406	50		 push	 eax
  00407	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0040a	81 c1 ec 1d 00
	00		 add	 ecx, 7660		; 00001decH
  00410	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z ; ImVector<ImGuiShrinkWidthItem>::operator[]
  00415	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _tab$13[ebp]
  0041b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0041e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 6589 :     }

  00421	e9 5b fe ff ff	 jmp	 $LN5@TabBarLayo
$LN6@TabBarLayo:

; 6590 : 
; 6591 :     // Compute width
; 6592 :     const float initial_offset_x = 0.0f; // g.Style.ItemInnerSpacing.x;

  00426	0f 57 c0	 xorps	 xmm0, xmm0
  00429	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _initial_offset_x$[ebp], xmm0

; 6593 :     const float width_avail = ImMax(tab_bar->BarRect.GetWidth() - initial_offset_x, 0.0f);

  00431	51		 push	 ecx
  00432	0f 57 c0	 xorps	 xmm0, xmm0
  00435	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0043a	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0043d	83 c1 24	 add	 ecx, 36			; 00000024H
  00440	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  00445	d9 9d 80 fd ff
	ff		 fstp	 DWORD PTR tv622[ebp]
  0044b	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv622[ebp]
  00453	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@00000000
  0045b	51		 push	 ecx
  0045c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00461	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00466	83 c4 08	 add	 esp, 8
  00469	d9 9d f4 fe ff
	ff		 fstp	 DWORD PTR _width_avail$[ebp]

; 6594 :     float width_excess = (width_avail < width_total_contents) ? (width_total_contents - width_avail) : 0.0f;

  0046f	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _width_total_contents$[ebp]
  00477	0f 2f 85 f4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _width_avail$[ebp]
  0047e	76 1a		 jbe	 SHORT $LN52@TabBarLayo
  00480	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _width_total_contents$[ebp]
  00488	f3 0f 5c 85 f4
	fe ff ff	 subss	 xmm0, DWORD PTR _width_avail$[ebp]
  00490	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv248[ebp], xmm0
  00498	eb 0b		 jmp	 SHORT $LN53@TabBarLayo
$LN52@TabBarLayo:
  0049a	0f 57 c0	 xorps	 xmm0, xmm0
  0049d	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv248[ebp], xmm0
$LN53@TabBarLayo:
  004a5	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv248[ebp]
  004ad	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _width_excess$[ebp], xmm0

; 6595 :     if (width_excess > 0.0f && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown))

  004b5	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _width_excess$[ebp]
  004bd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  004c4	0f 86 bb 00 00
	00		 jbe	 $LN32@TabBarLayo
  004ca	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  004cd	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  004d0	83 e1 40	 and	 ecx, 64			; 00000040H
  004d3	0f 84 ac 00 00
	00		 je	 $LN32@TabBarLayo

; 6596 :     {
; 6597 :         // If we don't have enough room, resize down the largest tabs first
; 6598 :         ShrinkWidths(g.ShrinkWidthBuffer.Data, g.ShrinkWidthBuffer.Size, width_excess);

  004d9	51		 push	 ecx
  004da	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _width_excess$[ebp]
  004e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e7	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  004ea	8b 88 ec 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7660]
  004f0	51		 push	 ecx
  004f1	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  004f4	8b 82 f4 1d 00
	00		 mov	 eax, DWORD PTR [edx+7668]
  004fa	50		 push	 eax
  004fb	e8 00 00 00 00	 call	 ?ShrinkWidths@ImGui@@YAXPAUImGuiShrinkWidthItem@@HM@Z ; ImGui::ShrinkWidths
  00500	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6599 :         for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

  00503	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tab_n$10[ebp], 0
  0050d	eb 0f		 jmp	 SHORT $LN10@TabBarLayo
$LN8@TabBarLayo:
  0050f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _tab_n$10[ebp]
  00515	83 c0 01	 add	 eax, 1
  00518	89 85 dc fe ff
	ff		 mov	 DWORD PTR _tab_n$10[ebp], eax
$LN10@TabBarLayo:
  0051e	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00521	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _tab_n$10[ebp]
  00527	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00529	7d 55		 jge	 SHORT $LN9@TabBarLayo

; 6600 :             tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index].Width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

  0052b	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _tab_n$10[ebp]
  00531	50		 push	 eax
  00532	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00535	81 c1 ec 1d 00
	00		 add	 ecx, 7660		; 00001decH
  0053b	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z ; ImVector<ImGuiShrinkWidthItem>::operator[]
  00540	f3 0f 2c 48 04	 cvttss2si ecx, DWORD PTR [eax+4]
  00545	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00549	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _tab_n$10[ebp]
  0054f	52		 push	 edx
  00550	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00553	81 c1 ec 1d 00
	00		 add	 ecx, 7660		; 00001decH
  00559	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv822[ebp], xmm0
  00561	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z ; ImVector<ImGuiShrinkWidthItem>::operator[]
  00566	8b 00		 mov	 eax, DWORD PTR [eax]
  00568	50		 push	 eax
  00569	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0056c	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  00571	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv822[ebp]
  00579	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
  0057e	eb 8f		 jmp	 SHORT $LN8@TabBarLayo
$LN9@TabBarLayo:

; 6601 :     }

  00580	e9 bb 00 00 00	 jmp	 $LN12@TabBarLayo
$LN32@TabBarLayo:

; 6602 :     else
; 6603 :     {
; 6604 :         const float tab_max_width = TabBarCalcMaxTabWidth();

  00585	e8 00 00 00 00	 call	 ?TabBarCalcMaxTabWidth@ImGui@@YAMXZ ; ImGui::TabBarCalcMaxTabWidth
  0058a	d9 9d d0 fe ff
	ff		 fstp	 DWORD PTR _tab_max_width$9[ebp]

; 6605 :         for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

  00590	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tab_n$8[ebp], 0
  0059a	eb 0f		 jmp	 SHORT $LN13@TabBarLayo
$LN11@TabBarLayo:
  0059c	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _tab_n$8[ebp]
  005a2	83 c0 01	 add	 eax, 1
  005a5	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _tab_n$8[ebp], eax
$LN13@TabBarLayo:
  005ab	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  005ae	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _tab_n$8[ebp]
  005b4	3b 08		 cmp	 ecx, DWORD PTR [eax]
  005b6	0f 8d 84 00 00
	00		 jge	 $LN12@TabBarLayo

; 6606 :         {
; 6607 :             ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

  005bc	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _tab_n$8[ebp]
  005c2	50		 push	 eax
  005c3	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  005c6	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  005cb	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _tab$7[ebp], eax

; 6608 :             tab->Width = ImMin(tab->ContentWidth, tab_max_width);

  005d1	51		 push	 ecx
  005d2	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _tab_max_width$9[ebp]
  005da	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005df	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _tab$7[ebp]
  005e5	51		 push	 ecx
  005e6	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  005eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005f0	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  005f5	83 c4 08	 add	 esp, 8
  005f8	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _tab$7[ebp]
  005fe	d9 59 18	 fstp	 DWORD PTR [ecx+24]

; 6609 :             IM_ASSERT(tab->Width > 0.0f);

  00601	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _tab$7[ebp]
  00607	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0060c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00613	77 26		 ja	 SHORT $LN54@TabBarLayo
  00615	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z@4JA
  0061b	83 c1 6b	 add	 ecx, 107		; 0000006bH
  0061e	8b f4		 mov	 esi, esp
  00620	51		 push	 ecx
  00621	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00626	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@HKABMAAD@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4@
  0062b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00631	83 c4 0c	 add	 esp, 12			; 0000000cH
  00634	3b f4		 cmp	 esi, esp
  00636	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN54@TabBarLayo:

; 6610 :         }

  0063b	e9 5c ff ff ff	 jmp	 $LN11@TabBarLayo
$LN12@TabBarLayo:

; 6611 :     }
; 6612 : 
; 6613 :     // Layout all active tabs
; 6614 :     float offset_x = initial_offset_x;

  00640	0f 57 c0	 xorps	 xmm0, xmm0
  00643	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR _offset_x$[ebp], xmm0

; 6615 :     float offset_x_ideal = offset_x;

  0064b	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _offset_x$[ebp]
  00653	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _offset_x_ideal$[ebp], xmm0

; 6616 :     tab_bar->OffsetNextTab = offset_x; // This is used by non-reorderable tab bar where the submission order is always honored.

  0065b	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0065e	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _offset_x$[ebp]
  00666	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0

; 6617 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

  0066b	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tab_n$6[ebp], 0
  00675	eb 0f		 jmp	 SHORT $LN16@TabBarLayo
$LN14@TabBarLayo:
  00677	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _tab_n$6[ebp]
  0067d	83 c0 01	 add	 eax, 1
  00680	89 85 94 fe ff
	ff		 mov	 DWORD PTR _tab_n$6[ebp], eax
$LN16@TabBarLayo:
  00686	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00689	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR _tab_n$6[ebp]
  0068f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00691	0f 8d 9d 00 00
	00		 jge	 $LN15@TabBarLayo

; 6618 :     {
; 6619 :         ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];

  00697	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _tab_n$6[ebp]
  0069d	50		 push	 eax
  0069e	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  006a1	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  006a6	89 85 88 fe ff
	ff		 mov	 DWORD PTR _tab$5[ebp], eax

; 6620 :         tab->Offset = offset_x;

  006ac	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _tab$5[ebp]
  006b2	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _offset_x$[ebp]
  006ba	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 6621 :         if (scroll_track_selected_tab_id == 0 && g.NavJustMovedToId == tab->ID)

  006bf	83 7d c4 00	 cmp	 DWORD PTR _scroll_track_selected_tab_id$[ebp], 0
  006c3	75 1e		 jne	 SHORT $LN34@TabBarLayo
  006c5	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  006c8	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _tab$5[ebp]
  006ce	8b 90 ec 1a 00
	00		 mov	 edx, DWORD PTR [eax+6892]
  006d4	3b 11		 cmp	 edx, DWORD PTR [ecx]
  006d6	75 0b		 jne	 SHORT $LN34@TabBarLayo

; 6622 :             scroll_track_selected_tab_id = tab->ID;

  006d8	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _tab$5[ebp]
  006de	8b 08		 mov	 ecx, DWORD PTR [eax]
  006e0	89 4d c4	 mov	 DWORD PTR _scroll_track_selected_tab_id$[ebp], ecx
$LN34@TabBarLayo:

; 6623 :         offset_x += tab->Width + g.Style.ItemInnerSpacing.x;

  006e3	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _tab$5[ebp]
  006e9	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  006ec	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  006f1	f3 0f 58 81 60
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5472]
  006f9	f3 0f 58 85 ac
	fe ff ff	 addss	 xmm0, DWORD PTR _offset_x$[ebp]
  00701	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR _offset_x$[ebp], xmm0

; 6624 :         offset_x_ideal += tab->ContentWidth + g.Style.ItemInnerSpacing.x;

  00709	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _tab$5[ebp]
  0070f	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00712	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  00717	f3 0f 58 81 60
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5472]
  0071f	f3 0f 58 85 a0
	fe ff ff	 addss	 xmm0, DWORD PTR _offset_x_ideal$[ebp]
  00727	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _offset_x_ideal$[ebp], xmm0

; 6625 :     }

  0072f	e9 43 ff ff ff	 jmp	 $LN14@TabBarLayo
$LN15@TabBarLayo:

; 6626 :     tab_bar->OffsetMax = ImMax(offset_x - g.Style.ItemInnerSpacing.x, 0.0f);

  00734	51		 push	 ecx
  00735	0f 57 c0	 xorps	 xmm0, xmm0
  00738	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0073d	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00740	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _offset_x$[ebp]
  00748	f3 0f 5c 80 60
	15 00 00	 subss	 xmm0, DWORD PTR [eax+5472]
  00750	51		 push	 ecx
  00751	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00756	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0075b	83 c4 08	 add	 esp, 8
  0075e	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00761	d9 59 38	 fstp	 DWORD PTR [ecx+56]

; 6627 :     tab_bar->OffsetMaxIdeal = ImMax(offset_x_ideal - g.Style.ItemInnerSpacing.x, 0.0f);

  00764	51		 push	 ecx
  00765	0f 57 c0	 xorps	 xmm0, xmm0
  00768	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0076d	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00770	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR _offset_x_ideal$[ebp]
  00778	f3 0f 5c 80 60
	15 00 00	 subss	 xmm0, DWORD PTR [eax+5472]
  00780	51		 push	 ecx
  00781	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00786	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0078b	83 c4 08	 add	 esp, 8
  0078e	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00791	d9 59 3c	 fstp	 DWORD PTR [ecx+60]

; 6628 : 
; 6629 :     // Horizontal scrolling buttons
; 6630 :     const bool scrolling_buttons = (tab_bar->OffsetMax > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll);

  00794	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00797	83 c1 24	 add	 ecx, 36			; 00000024H
  0079a	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  0079f	d9 9d 80 fd ff
	ff		 fstp	 DWORD PTR tv717[ebp]
  007a5	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  007a8	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  007ad	0f 2f 85 80 fd
	ff ff		 comiss	 xmm0, DWORD PTR tv717[ebp]
  007b4	76 2a		 jbe	 SHORT $LN55@TabBarLayo
  007b6	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  007b9	83 39 01	 cmp	 DWORD PTR [ecx], 1
  007bc	7e 22		 jle	 SHORT $LN55@TabBarLayo
  007be	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  007c1	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  007c4	83 e0 10	 and	 eax, 16			; 00000010H
  007c7	75 17		 jne	 SHORT $LN55@TabBarLayo
  007c9	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  007cc	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  007cf	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  007d5	74 09		 je	 SHORT $LN55@TabBarLayo
  007d7	c6 85 7f fd ff
	ff 01		 mov	 BYTE PTR tv392[ebp], 1
  007de	eb 07		 jmp	 SHORT $LN56@TabBarLayo
$LN55@TabBarLayo:
  007e0	c6 85 7f fd ff
	ff 00		 mov	 BYTE PTR tv392[ebp], 0
$LN56@TabBarLayo:
  007e7	8a 85 7f fd ff
	ff		 mov	 al, BYTE PTR tv392[ebp]
  007ed	88 85 7f fe ff
	ff		 mov	 BYTE PTR _scrolling_buttons$[ebp], al

; 6631 :     if (scrolling_buttons)

  007f3	0f b6 85 7f fe
	ff ff		 movzx	 eax, BYTE PTR _scrolling_buttons$[ebp]
  007fa	85 c0		 test	 eax, eax
  007fc	74 32		 je	 SHORT $LN36@TabBarLayo

; 6632 :         if (ImGuiTabItem* tab_to_select = TabBarScrollingButtons(tab_bar)) // NB: Will alter BarRect.Max.x!

  007fe	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00801	50		 push	 eax
  00802	e8 00 00 00 00	 call	 ?TabBarScrollingButtons@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@@Z ; ImGui::TabBarScrollingButtons
  00807	83 c4 04	 add	 esp, 4
  0080a	89 85 70 fe ff
	ff		 mov	 DWORD PTR _tab_to_select$4[ebp], eax
  00810	83 bd 70 fe ff
	ff 00		 cmp	 DWORD PTR _tab_to_select$4[ebp], 0
  00817	74 17		 je	 SHORT $LN36@TabBarLayo

; 6633 :             scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

  00819	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0081c	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _tab_to_select$4[ebp]
  00822	8b 11		 mov	 edx, DWORD PTR [ecx]
  00824	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00827	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0082a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0082d	89 4d c4	 mov	 DWORD PTR _scroll_track_selected_tab_id$[ebp], ecx
$LN36@TabBarLayo:

; 6634 : 
; 6635 :     // If we have lost the selected tab, select the next most recently active one
; 6636 :     if (found_selected_tab_id == false)

  00830	0f b6 85 3f ff
	ff ff		 movzx	 eax, BYTE PTR _found_selected_tab_id$[ebp]
  00837	85 c0		 test	 eax, eax
  00839	75 0a		 jne	 SHORT $LN37@TabBarLayo

; 6637 :         tab_bar->SelectedTabId = 0;

  0083b	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0083e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN37@TabBarLayo:

; 6638 :     if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)

  00845	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00848	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0084c	75 29		 jne	 SHORT $LN38@TabBarLayo
  0084e	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00851	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00855	75 20		 jne	 SHORT $LN38@TabBarLayo
  00857	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _most_recently_selected_tab$[ebp], 0
  0085e	74 17		 je	 SHORT $LN38@TabBarLayo

; 6639 :         scroll_track_selected_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

  00860	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00863	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _most_recently_selected_tab$[ebp]
  00869	8b 11		 mov	 edx, DWORD PTR [ecx]
  0086b	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0086e	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00871	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00874	89 4d c4	 mov	 DWORD PTR _scroll_track_selected_tab_id$[ebp], ecx
$LN38@TabBarLayo:

; 6640 : 
; 6641 :     // Lock in visible tab
; 6642 :     tab_bar->VisibleTabId = tab_bar->SelectedTabId;

  00877	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0087a	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0087d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00880	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 6643 :     tab_bar->VisibleTabWasSubmitted = false;

  00883	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00886	c6 40 5e 00	 mov	 BYTE PTR [eax+94], 0

; 6644 : 
; 6645 :     // Update scrolling
; 6646 :     if (scroll_track_selected_tab_id)

  0088a	83 7d c4 00	 cmp	 DWORD PTR _scroll_track_selected_tab_id$[ebp], 0
  0088e	74 32		 je	 SHORT $LN40@TabBarLayo

; 6647 :         if (ImGuiTabItem* scroll_track_selected_tab = TabBarFindTabByID(tab_bar, scroll_track_selected_tab_id))

  00890	8b 45 c4	 mov	 eax, DWORD PTR _scroll_track_selected_tab_id$[ebp]
  00893	50		 push	 eax
  00894	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00897	51		 push	 ecx
  00898	e8 00 00 00 00	 call	 ?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
  0089d	83 c4 08	 add	 esp, 8
  008a0	89 85 64 fe ff
	ff		 mov	 DWORD PTR _scroll_track_selected_tab$3[ebp], eax
  008a6	83 bd 64 fe ff
	ff 00		 cmp	 DWORD PTR _scroll_track_selected_tab$3[ebp], 0
  008ad	74 13		 je	 SHORT $LN40@TabBarLayo

; 6648 :             TabBarScrollToTab(tab_bar, scroll_track_selected_tab);

  008af	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _scroll_track_selected_tab$3[ebp]
  008b5	50		 push	 eax
  008b6	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  008b9	51		 push	 ecx
  008ba	e8 00 00 00 00	 call	 ?TabBarScrollToTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z ; ImGui::TabBarScrollToTab
  008bf	83 c4 08	 add	 esp, 8
$LN40@TabBarLayo:

; 6649 :     tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);

  008c2	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  008c5	51		 push	 ecx
  008c6	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  008cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d0	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  008d3	51		 push	 ecx
  008d4	e8 00 00 00 00	 call	 ?TabBarScrollClamp@ImGui@@YAMPAUImGuiTabBar@@M@Z ; ImGui::TabBarScrollClamp
  008d9	83 c4 08	 add	 esp, 8
  008dc	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  008df	d9 5a 44	 fstp	 DWORD PTR [edx+68]

; 6650 :     tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);

  008e2	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  008e5	51		 push	 ecx
  008e6	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  008eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008f0	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  008f3	51		 push	 ecx
  008f4	e8 00 00 00 00	 call	 ?TabBarScrollClamp@ImGui@@YAMPAUImGuiTabBar@@M@Z ; ImGui::TabBarScrollClamp
  008f9	83 c4 08	 add	 esp, 8
  008fc	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  008ff	d9 5a 48	 fstp	 DWORD PTR [edx+72]

; 6651 :     if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)

  00902	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00905	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00908	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  0090d	0f 2e 41 48	 ucomiss xmm0, DWORD PTR [ecx+72]
  00911	9f		 lahf
  00912	f6 c4 44	 test	 ah, 68			; 00000044H
  00915	0f 8b 4a 01 00
	00		 jnp	 $LN41@TabBarLayo

; 6652 :     {
; 6653 :         // Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
; 6654 :         // Teleport if we are aiming far off the visible line
; 6655 :         tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);

  0091b	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0091e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@428c0000
  00926	f3 0f 59 80 c4
	18 00 00	 mulss	 xmm0, DWORD PTR [eax+6340]
  0092e	51		 push	 ecx
  0092f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00934	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00937	51		 push	 ecx
  00938	f3 0f 10 41 50	 movss	 xmm0, DWORD PTR [ecx+80]
  0093d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00942	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00947	83 c4 08	 add	 esp, 8
  0094a	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  0094d	d9 5a 50	 fstp	 DWORD PTR [edx+80]

; 6656 :         tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);

  00950	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00953	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00956	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  0095b	f3 0f 5c 41 44	 subss	 xmm0, DWORD PTR [ecx+68]
  00960	51		 push	 ecx
  00961	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00966	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  0096b	83 c4 04	 add	 esp, 4
  0096e	d9 9d 80 fd ff
	ff		 fstp	 DWORD PTR tv785[ebp]
  00974	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv785[ebp]
  0097c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@3e99999a
  00984	51		 push	 ecx
  00985	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0098a	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  0098d	51		 push	 ecx
  0098e	f3 0f 10 42 50	 movss	 xmm0, DWORD PTR [edx+80]
  00993	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00998	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0099d	83 c4 08	 add	 esp, 8
  009a0	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  009a3	d9 58 50	 fstp	 DWORD PTR [eax+80]

; 6657 :         const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);

  009a6	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  009a9	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  009ac	83 c1 01	 add	 ecx, 1
  009af	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  009b2	3b 8a 60 19 00
	00		 cmp	 ecx, DWORD PTR [edx+6496]
  009b8	7c 29		 jl	 SHORT $LN57@TabBarLayo
  009ba	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  009bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  009c5	f3 0f 59 80 c4
	18 00 00	 mulss	 xmm0, DWORD PTR [eax+6340]
  009cd	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  009d0	f3 0f 10 49 4c	 movss	 xmm1, DWORD PTR [ecx+76]
  009d5	0f 2f c8	 comiss	 xmm1, xmm0
  009d8	77 09		 ja	 SHORT $LN57@TabBarLayo
  009da	c6 85 83 fd ff
	ff 00		 mov	 BYTE PTR tv461[ebp], 0
  009e1	eb 07		 jmp	 SHORT $LN58@TabBarLayo
$LN57@TabBarLayo:
  009e3	c6 85 83 fd ff
	ff 01		 mov	 BYTE PTR tv461[ebp], 1
$LN58@TabBarLayo:
  009ea	8a 95 83 fd ff
	ff		 mov	 dl, BYTE PTR tv461[ebp]
  009f0	88 95 5b fe ff
	ff		 mov	 BYTE PTR _teleport$2[ebp], dl

; 6658 :         tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);

  009f6	0f b6 85 5b fe
	ff ff		 movzx	 eax, BYTE PTR _teleport$2[ebp]
  009fd	85 c0		 test	 eax, eax
  009ff	74 12		 je	 SHORT $LN59@TabBarLayo
  00a01	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00a04	f3 0f 10 41 48	 movss	 xmm0, DWORD PTR [ecx+72]
  00a09	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv476[ebp], xmm0
  00a11	eb 40		 jmp	 SHORT $LN60@TabBarLayo
$LN59@TabBarLayo:
  00a13	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00a16	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00a19	f3 0f 10 42 18	 movss	 xmm0, DWORD PTR [edx+24]
  00a1e	f3 0f 59 40 50	 mulss	 xmm0, DWORD PTR [eax+80]
  00a23	51		 push	 ecx
  00a24	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a29	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00a2c	51		 push	 ecx
  00a2d	f3 0f 10 41 48	 movss	 xmm0, DWORD PTR [ecx+72]
  00a32	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a37	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  00a3a	51		 push	 ecx
  00a3b	f3 0f 10 42 44	 movss	 xmm0, DWORD PTR [edx+68]
  00a40	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a45	e8 00 00 00 00	 call	 ?ImLinearSweep@@YAMMMM@Z ; ImLinearSweep
  00a4a	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a4d	d9 9d 80 fd ff
	ff		 fstp	 DWORD PTR tv476[ebp]
$LN60@TabBarLayo:
  00a53	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00a56	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv476[ebp]
  00a5e	f3 0f 11 40 44	 movss	 DWORD PTR [eax+68], xmm0

; 6659 :     }

  00a63	eb 0b		 jmp	 SHORT $LN42@TabBarLayo
$LN41@TabBarLayo:

; 6660 :     else
; 6661 :     {
; 6662 :         tab_bar->ScrollingSpeed = 0.0f;

  00a65	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00a68	0f 57 c0	 xorps	 xmm0, xmm0
  00a6b	f3 0f 11 40 50	 movss	 DWORD PTR [eax+80], xmm0
$LN42@TabBarLayo:

; 6663 :     }
; 6664 : 
; 6665 :     // Clear name buffers
; 6666 :     if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)

  00a70	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00a73	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00a76	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  00a7c	75 0d		 jne	 SHORT $LN43@TabBarLayo

; 6667 :         tab_bar->TabsNames.Buf.resize(0);

  00a7e	6a 00		 push	 0
  00a80	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00a83	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00a86	e8 00 00 00 00	 call	 ?resize@?$ImVector@D@@QAEXH@Z ; ImVector<char>::resize
$LN43@TabBarLayo:

; 6668 : }

  00a8b	52		 push	 edx
  00a8c	8b cd		 mov	 ecx, ebp
  00a8e	50		 push	 eax
  00a8f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN63@TabBarLayo
  00a95	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00a9a	58		 pop	 eax
  00a9b	5a		 pop	 edx
  00a9c	5f		 pop	 edi
  00a9d	5e		 pop	 esi
  00a9e	5b		 pop	 ebx
  00a9f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00aa2	33 cd		 xor	 ecx, ebp
  00aa4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aa9	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  00aaf	3b ec		 cmp	 ebp, esp
  00ab1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ab6	8b e5		 mov	 esp, ebp
  00ab8	5d		 pop	 ebp
  00ab9	c3		 ret	 0
  00aba	66 90		 npad	 2
$LN63@TabBarLayo:
  00abc	01 00 00 00	 DD	 1
  00ac0	00 00 00 00	 DD	 $LN62@TabBarLayo
$LN62@TabBarLayo:
  00ac4	78 ff ff ff	 DD	 -136			; ffffff78H
  00ac8	20 00 00 00	 DD	 32			; 00000020H
  00acc	00 00 00 00	 DD	 $LN61@TabBarLayo
$LN61@TabBarLayo:
  00ad0	69		 DB	 105			; 00000069H
  00ad1	74		 DB	 116			; 00000074H
  00ad2	65		 DB	 101			; 00000065H
  00ad3	6d		 DB	 109			; 0000006dH
  00ad4	5f		 DB	 95			; 0000005fH
  00ad5	74		 DB	 116			; 00000074H
  00ad6	6d		 DB	 109			; 0000006dH
  00ad7	70		 DB	 112			; 00000070H
  00ad8	00		 DB	 0
?TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z ENDP		; ImGui::TabBarLayout
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Plot_ArrayGetter@@YAMPAXH@Z
_TEXT	SEGMENT
_v$ = -20						; size = 4
_plot_data$ = -8					; size = 4
_data$ = 8						; size = 4
_idx$ = 12						; size = 4
?Plot_ArrayGetter@@YAMPAXH@Z PROC			; Plot_ArrayGetter, COMDAT

; 5892 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5893 :     ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;

  00028	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _plot_data$[ebp], eax

; 5894 :     const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _plot_data$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _idx$[ebp]
  00034	0f af 48 04	 imul	 ecx, DWORD PTR [eax+4]
  00038	8b 55 f8	 mov	 edx, DWORD PTR _plot_data$[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00042	f3 0f 11 45 ec	 movss	 DWORD PTR _v$[ebp], xmm0

; 5895 :     return v;

  00047	d9 45 ec	 fld	 DWORD PTR _v$[ebp]

; 5896 : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?Plot_ArrayGetter@@YAMPAXH@Z ENDP			; Plot_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_values$ = 8						; size = 4
_stride$ = 12						; size = 4
??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z PROC		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData, COMDAT
; _this$ = ecx

; 5888 :     ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _values$[ebp]
  00033	89 08		 mov	 DWORD PTR [eax], ecx
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _stride$[ebp]
  0003b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z ENDP		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?RenderArrowsForVerticalBar@@YAXPAUImDrawList@@UImVec2@@1MM@Z
_TEXT	SEGMENT
tv174 = -304						; size = 4
$T1 = -296						; size = 8
$T2 = -280						; size = 8
$T3 = -264						; size = 8
$T4 = -248						; size = 8
$T5 = -232						; size = 8
$T6 = -216						; size = 8
_alpha8$ = -8						; size = 4
_draw_list$ = 8						; size = 4
_pos$ = 12						; size = 8
_half_sz$ = 20						; size = 8
_bar_w$ = 28						; size = 4
_alpha$ = 32						; size = 4
?RenderArrowsForVerticalBar@@YAXPAUImDrawList@@UImVec2@@1MM@Z PROC ; RenderArrowsForVerticalBar, COMDAT

; 4468 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00012	b9 4c 00 00 00	 mov	 ecx, 76			; 0000004cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4469 :     ImU32 alpha8 = IM_F32_TO_INT8_SAT(alpha);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _alpha$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00038	83 c4 04	 add	 esp, 4
  0003b	d9 9d d0 fe ff
	ff		 fstp	 DWORD PTR tv174[ebp]
  00041	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR tv174[ebp]
  00049	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00051	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00059	f3 0f 2c c0	 cvttss2si eax, xmm0
  0005d	89 45 f8	 mov	 DWORD PTR _alpha8$[ebp], eax

; 4470 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32(0,0,0,alpha8));

  00060	8b 45 f8	 mov	 eax, DWORD PTR _alpha8$[ebp]
  00063	c1 e0 18	 shl	 eax, 24			; 00000018H
  00066	50		 push	 eax
  00067	6a 01		 push	 1
  00069	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  0006e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00076	51		 push	 ecx
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _half_sz$[ebp]
  00081	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00089	51		 push	 ecx
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00095	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0009a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009d	51		 push	 ecx
  0009e	8b 10		 mov	 edx, DWORD PTR [eax]
  000a0	52		 push	 edx
  000a1	51		 push	 ecx
  000a2	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  000b1	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _half_sz$[ebp]
  000b6	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  000be	51		 push	 ecx
  000bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c4	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000ca	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d2	51		 push	 ecx
  000d3	8b 10		 mov	 edx, DWORD PTR [eax]
  000d5	52		 push	 edx
  000d6	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
  000df	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4471 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32(255,255,255,alpha8));

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _alpha8$[ebp]
  000e5	c1 e0 18	 shl	 eax, 24			; 00000018H
  000e8	0d 00 00 ff 00	 or	 eax, 16711680		; 00ff0000H
  000ed	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  000f2	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  000f7	50		 push	 eax
  000f8	6a 01		 push	 1
  000fa	8b 4d 18	 mov	 ecx, DWORD PTR _half_sz$[ebp+4]
  000fd	51		 push	 ecx
  000fe	8b 55 14	 mov	 edx, DWORD PTR _half_sz$[ebp]
  00101	52		 push	 edx
  00102	51		 push	 ecx
  00103	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00108	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00112	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _half_sz$[ebp]
  00117	51		 push	 ecx
  00118	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011d	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00123	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	51		 push	 ecx
  0012c	8b 10		 mov	 edx, DWORD PTR [eax]
  0012e	52		 push	 edx
  0012f	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
  00138	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4472 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));

  0013b	8b 45 f8	 mov	 eax, DWORD PTR _alpha8$[ebp]
  0013e	c1 e0 18	 shl	 eax, 24			; 00000018H
  00141	50		 push	 eax
  00142	6a 00		 push	 0
  00144	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  00149	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00151	51		 push	 ecx
  00152	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00157	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _half_sz$[ebp]
  0015c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00164	51		 push	 ecx
  00165	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016a	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00170	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00175	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00178	51		 push	 ecx
  00179	8b 10		 mov	 edx, DWORD PTR [eax]
  0017b	52		 push	 edx
  0017c	51		 push	 ecx
  0017d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00182	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00187	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  0018c	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _bar_w$[ebp]
  00191	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _half_sz$[ebp]
  00196	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0019e	51		 push	 ecx
  0019f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a4	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001aa	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001af	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b2	51		 push	 ecx
  001b3	8b 10		 mov	 edx, DWORD PTR [eax]
  001b5	52		 push	 edx
  001b6	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 ?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
  001bf	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4473 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32(255,255,255,alpha8));

  001c2	8b 45 f8	 mov	 eax, DWORD PTR _alpha8$[ebp]
  001c5	c1 e0 18	 shl	 eax, 24			; 00000018H
  001c8	0d 00 00 ff 00	 or	 eax, 16711680		; 00ff0000H
  001cd	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  001d2	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  001d7	50		 push	 eax
  001d8	6a 00		 push	 0
  001da	8b 4d 18	 mov	 ecx, DWORD PTR _half_sz$[ebp+4]
  001dd	51		 push	 ecx
  001de	8b 55 14	 mov	 edx, DWORD PTR _half_sz$[ebp]
  001e1	52		 push	 edx
  001e2	51		 push	 ecx
  001e3	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  001e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ed	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  001f2	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _bar_w$[ebp]
  001f7	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _half_sz$[ebp]
  001fc	51		 push	 ecx
  001fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00202	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00208	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0020d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00210	51		 push	 ecx
  00211	8b 10		 mov	 edx, DWORD PTR [eax]
  00213	52		 push	 edx
  00214	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 ?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
  0021d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4474 : }

  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5b		 pop	 ebx
  00223	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  00229	3b ec		 cmp	 ebp, esp
  0022b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	c3		 ret	 0
?RenderArrowsForVerticalBar@@YAXPAUImDrawList@@UImVec2@@1MM@Z ENDP ; RenderArrowsForVerticalBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@H@@YAHHHM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_t$ = 16						; size = 4
??$ImLerp@H@@YAHHHM@Z PROC				; ImLerp<int>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _a$[ebp]
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00030	2b 45 08	 sub	 eax, DWORD PTR _a$[ebp]
  00033	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00037	f3 0f 59 4d 10	 mulss	 xmm1, DWORD PTR _t$[ebp]
  0003c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00040	f3 0f 2c c0	 cvttss2si eax, xmm0
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$ImLerp@H@@YAHHHM@Z ENDP				; ImLerp<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ImAlphaBlendColor@@YAIII@Z
_TEXT	SEGMENT
tv132 = -252						; size = 8
tv129 = -244						; size = 4
_b$ = -44						; size = 4
_g$ = -32						; size = 4
_r$ = -20						; size = 4
_t$ = -8						; size = 4
_col_a$ = 8						; size = 4
_col_b$ = 12						; size = 4
?ImAlphaBlendColor@@YAIII@Z PROC			; ImAlphaBlendColor, COMDAT

; 4421 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4422 :     float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _col_b$[ebp]
  0002b	c1 e8 18	 shr	 eax, 24			; 00000018H
  0002e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00033	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  00039	f2 0f 2a 85 0c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv129[ebp]
  00041	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  00047	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0004a	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00053	f2 0f 11 85 04
	ff ff ff	 movsd	 QWORD PTR tv132[ebp], xmm0
  0005b	f2 0f 5a 85 04
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv132[ebp]
  00063	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  0006b	f3 0f 11 45 f8	 movss	 DWORD PTR _t$[ebp], xmm0

; 4423 :     int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);

  00070	51		 push	 ecx
  00071	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _t$[ebp]
  00076	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _col_b$[ebp]
  0007e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00083	50		 push	 eax
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _col_a$[ebp]
  00087	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	89 45 ec	 mov	 DWORD PTR _r$[ebp], eax

; 4424 :     int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);

  00099	51		 push	 ecx
  0009a	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _t$[ebp]
  0009f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a4	8b 45 0c	 mov	 eax, DWORD PTR _col_b$[ebp]
  000a7	c1 e8 08	 shr	 eax, 8
  000aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000af	50		 push	 eax
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _col_a$[ebp]
  000b3	c1 e9 08	 shr	 ecx, 8
  000b6	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	89 45 e0	 mov	 DWORD PTR _g$[ebp], eax

; 4425 :     int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);

  000c8	51		 push	 ecx
  000c9	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _t$[ebp]
  000ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d3	8b 45 0c	 mov	 eax, DWORD PTR _col_b$[ebp]
  000d6	c1 e8 10	 shr	 eax, 16			; 00000010H
  000d9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000de	50		 push	 eax
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _col_a$[ebp]
  000e2	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000e5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	89 45 d4	 mov	 DWORD PTR _b$[ebp], eax

; 4426 :     return IM_COL32(r, g, b, 0xFF);

  000f7	8b 45 d4	 mov	 eax, DWORD PTR _b$[ebp]
  000fa	c1 e0 10	 shl	 eax, 16			; 00000010H
  000fd	0d 00 00 00 ff	 or	 eax, -16777216		; ff000000H
  00102	8b 4d e0	 mov	 ecx, DWORD PTR _g$[ebp]
  00105	c1 e1 08	 shl	 ecx, 8
  00108	0b c1		 or	 eax, ecx
  0010a	0b 45 ec	 or	 eax, DWORD PTR _r$[ebp]

; 4427 : }

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00116	3b ec		 cmp	 ebp, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
?ImAlphaBlendColor@@YAIII@Z ENDP			; ImAlphaBlendColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_paste@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PBGH@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_ctext$ = 16						; size = 4
_len$ = 20						; size = 4
?stb_textedit_paste@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PBGH@Z PROC ; ImStb::stb_textedit_paste, COMDAT

; 1367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1368 :    return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);

  00028	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _ctext$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?stb_textedit_paste_internal@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PAGH@Z ; ImStb::stb_textedit_paste_internal
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 1369 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?stb_textedit_paste@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PBGH@Z ENDP ; ImStb::stb_textedit_paste
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_initialize_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
_is_single_line$ = 12					; size = 4
?stb_textedit_initialize_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z PROC ; ImStb::stb_textedit_initialize_state, COMDAT

; 1357 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1358 :    stb_textedit_clear_state(state, is_single_line);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _is_single_line$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?stb_textedit_clear_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_clear_state
  00035	83 c4 08	 add	 esp, 8

; 1359 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?stb_textedit_initialize_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z ENDP ; ImStb::stb_textedit_initialize_state
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_clear_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
_is_single_line$ = 12					; size = 4
?stb_textedit_clear_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z PROC ; ImStb::stb_textedit_clear_state, COMDAT

; 1340 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1341 :    state->undostate.undo_point = 0;

  00028	33 c0		 xor	 eax, eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002d	66 89 81 16 0e
	00 00		 mov	 WORD PTR [ecx+3606], ax

; 1342 :    state->undostate.undo_char_point = 0;

  00034	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00037	c7 80 1c 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3612], 0

; 1343 :    state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

  00041	b8 63 00 00 00	 mov	 eax, 99			; 00000063H
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00049	66 89 81 18 0e
	00 00		 mov	 WORD PTR [ecx+3608], ax

; 1344 :    state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

  00050	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00053	c7 80 20 0e 00
	00 e7 03 00 00	 mov	 DWORD PTR [eax+3616], 999 ; 000003e7H

; 1345 :    state->select_end = state->select_start = 0;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00060	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 1346 :    state->cursor = 0;

  00071	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1347 :    state->has_preferred_x = 0;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0007d	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 1348 :    state->preferred_x = 0;

  00081	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00084	0f 57 c0	 xorps	 xmm0, xmm0
  00087	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 1349 :    state->cursor_at_end_of_line = 0;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008f	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 1350 :    state->initialized = 1;

  00093	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00096	c6 40 0e 01	 mov	 BYTE PTR [eax+14], 1

; 1351 :    state->single_line = (unsigned char) is_single_line;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	8a 4d 0c	 mov	 cl, BYTE PTR _is_single_line$[ebp]
  000a0	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 1352 :    state->insert_mode = 0;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a6	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1353 : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?stb_textedit_clear_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z ENDP ; ImStb::stb_textedit_clear_state
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_createundo@ImStb@@YAPAGPAUStbUndoState@1@HHH@Z
_TEXT	SEGMENT
_r$ = -8						; size = 4
_state$ = 8						; size = 4
_pos$ = 12						; size = 4
_insert_len$ = 16					; size = 4
_delete_len$ = 20					; size = 4
?stb_text_createundo@ImStb@@YAPAGPAUStbUndoState@1@HHH@Z PROC ; ImStb::stb_text_createundo, COMDAT

; 1175 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1176 :    StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);

  00028	8b 45 10	 mov	 eax, DWORD PTR _insert_len$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?stb_text_create_undo_record@ImStb@@YAPAUStbUndoRecord@1@PAUStbUndoState@1@H@Z ; ImStb::stb_text_create_undo_record
  00035	83 c4 08	 add	 esp, 8
  00038	89 45 f8	 mov	 DWORD PTR _r$[ebp], eax

; 1177 :    if (r == NULL)

  0003b	83 7d f8 00	 cmp	 DWORD PTR _r$[ebp], 0
  0003f	75 04		 jne	 SHORT $LN2@stb_text_c

; 1178 :       return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 64		 jmp	 SHORT $LN1@stb_text_c
$LN2@stb_text_c:

; 1179 : 
; 1180 :    r->where = pos;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  0004b	89 08		 mov	 DWORD PTR [eax], ecx

; 1181 :    r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  00050	8b 4d 10	 mov	 ecx, DWORD PTR _insert_len$[ebp]
  00053	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1182 :    r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  00059	8b 4d 14	 mov	 ecx, DWORD PTR _delete_len$[ebp]
  0005c	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1183 : 
; 1184 :    if (insert_len == 0) {

  0005f	83 7d 10 00	 cmp	 DWORD PTR _insert_len$[ebp], 0
  00063	75 10		 jne	 SHORT $LN3@stb_text_c

; 1185 :       r->char_storage = -1;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  00068	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 1186 :       return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 36		 jmp	 SHORT $LN1@stb_text_c

; 1187 :    } else {

  00073	eb 34		 jmp	 SHORT $LN1@stb_text_c
$LN3@stb_text_c:

; 1188 :       r->char_storage = state->undo_char_point;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0007b	8b 91 04 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3588]
  00081	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1189 :       state->undo_char_point += insert_len;

  00084	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00087	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  0008d	03 4d 10	 add	 ecx, DWORD PTR _insert_len$[ebp]
  00090	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00093	89 8a 04 0e 00
	00		 mov	 DWORD PTR [edx+3588], ecx

; 1190 :       return &state->undo_char[r->char_storage];

  00099	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  0009c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0009f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000a2	8d 84 4a 30 06
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+1584]
$LN1@stb_text_c:

; 1191 :    }
; 1192 : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?stb_text_createundo@ImStb@@YAPAGPAUStbUndoState@1@HHH@Z ENDP ; ImStb::stb_text_createundo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_create_undo_record@ImStb@@YAPAUStbUndoRecord@1@PAUStbUndoState@1@H@Z
_TEXT	SEGMENT
tv84 = -196						; size = 4
_state$ = 8						; size = 4
_numchars$ = 12						; size = 4
?stb_text_create_undo_record@ImStb@@YAPAUStbUndoRecord@1@PAUStbUndoState@1@H@Z PROC ; ImStb::stb_text_create_undo_record, COMDAT

; 1151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1152 :    // any time we create a new undo record, we discard redo
; 1153 :    stb_textedit_flush_redo(state);

  00028	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?stb_textedit_flush_redo@ImStb@@YAXPAUStbUndoState@1@@Z ; ImStb::stb_textedit_flush_redo
  00031	83 c4 04	 add	 esp, 4

; 1154 : 
; 1155 :    // if we have no free records, we have to make room, by sliding the
; 1156 :    // existing records down
; 1157 :    if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

  00034	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00037	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  0003e	83 f9 63	 cmp	 ecx, 99			; 00000063H
  00041	75 0c		 jne	 SHORT $LN4@stb_text_c

; 1158 :       stb_textedit_discard_undo(state);

  00043	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?stb_textedit_discard_undo@ImStb@@YAXPAUStbUndoState@1@@Z ; ImStb::stb_textedit_discard_undo
  0004c	83 c4 04	 add	 esp, 4
$LN4@stb_text_c:

; 1159 : 
; 1160 :    // if the characters to store won't possibly fit in the buffer, we can't undo
; 1161 :    if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {

  0004f	81 7d 0c e7 03
	00 00		 cmp	 DWORD PTR _numchars$[ebp], 999 ; 000003e7H
  00056	7e 1d		 jle	 SHORT $LN2@stb_text_c

; 1162 :       state->undo_point = 0;

  00058	33 c0		 xor	 eax, eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005d	66 89 81 fe 0d
	00 00		 mov	 WORD PTR [ecx+3582], ax

; 1163 :       state->undo_char_point = 0;

  00064	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00067	c7 80 04 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3588], 0

; 1164 :       return NULL;

  00071	33 c0		 xor	 eax, eax
  00073	eb 56		 jmp	 SHORT $LN1@stb_text_c
$LN2@stb_text_c:

; 1165 :    }
; 1166 : 
; 1167 :    // if we don't have enough free characters in the buffer, we have to make room
; 1168 :    while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)

  00075	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00078	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  0007e	03 4d 0c	 add	 ecx, DWORD PTR _numchars$[ebp]
  00081	81 f9 e7 03 00
	00		 cmp	 ecx, 999		; 000003e7H
  00087	7e 0e		 jle	 SHORT $LN3@stb_text_c

; 1169 :       stb_textedit_discard_undo(state);

  00089	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?stb_textedit_discard_undo@ImStb@@YAXPAUStbUndoState@1@@Z ; ImStb::stb_textedit_discard_undo
  00092	83 c4 04	 add	 esp, 4
  00095	eb de		 jmp	 SHORT $LN2@stb_text_c
$LN3@stb_text_c:

; 1170 : 
; 1171 :    return &state->undo_rec[state->undo_point++];

  00097	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0009a	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  000a1	c1 e1 04	 shl	 ecx, 4
  000a4	03 4d 08	 add	 ecx, DWORD PTR _state$[ebp]
  000a7	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv84[ebp], ecx
  000ad	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b0	66 8b 82 fe 0d
	00 00		 mov	 ax, WORD PTR [edx+3582]
  000b7	66 83 c0 01	 add	 ax, 1
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000be	66 89 81 fe 0d
	00 00		 mov	 WORD PTR [ecx+3582], ax
  000c5	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
$LN1@stb_text_c:

; 1172 : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000d4	3b ec		 cmp	 ebp, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
?stb_text_create_undo_record@ImStb@@YAPAUStbUndoRecord@1@PAUStbUndoState@1@H@Z ENDP ; ImStb::stb_text_create_undo_record
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@1@@Z
_TEXT	SEGMENT
_buf_end$1 = -68					; size = 4
_buf_begin$2 = -56					; size = 4
_move_size$3 = -44					; size = 4
_i$4 = -32						; size = 4
_n$5 = -20						; size = 4
_k$ = -8						; size = 4
_state$ = 8						; size = 4
?stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@1@@Z PROC ; ImStb::stb_textedit_discard_redo, COMDAT

; 1121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1122 :    int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;

  00028	c7 45 f8 62 00
	00 00		 mov	 DWORD PTR _k$[ebp], 98	; 00000062H

; 1123 : 
; 1124 :    if (state->redo_point <= k) {

  0002f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00032	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  00039	3b 4d f8	 cmp	 ecx, DWORD PTR _k$[ebp]
  0003c	0f 8f c2 01 00
	00		 jg	 $LN1@stb_texted

; 1125 :       // if the k'th undo state has characters, clean those up
; 1126 :       if (state->undo_rec[k].char_storage >= 0) {

  00042	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00045	c1 e0 04	 shl	 eax, 4
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0004b	83 7c 01 0c 00	 cmp	 DWORD PTR [ecx+eax+12], 0
  00050	0f 8c bc 00 00
	00		 jl	 $LN6@stb_texted

; 1127 :          int n = state->undo_rec[k].insert_length, i;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00059	c1 e0 04	 shl	 eax, 4
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00063	89 55 ec	 mov	 DWORD PTR _n$5[ebp], edx

; 1128 :          // move the remaining redo character data to the end of the buffer
; 1129 :          state->redo_char_point += n;

  00066	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00069	8b 88 08 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3592]
  0006f	03 4d ec	 add	 ecx, DWORD PTR _n$5[ebp]
  00072	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00075	89 8a 08 0e 00
	00		 mov	 DWORD PTR [edx+3592], ecx

; 1130 :          STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));

  0007b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0007e	b9 e7 03 00 00	 mov	 ecx, 999		; 000003e7H
  00083	2b 88 08 0e 00
	00		 sub	 ecx, DWORD PTR [eax+3592]
  00089	d1 e1		 shl	 ecx, 1
  0008b	51		 push	 ecx
  0008c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0008f	8b 82 08 0e 00
	00		 mov	 eax, DWORD PTR [edx+3592]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00098	8d 94 41 30 06
	00 00		 lea	 edx, DWORD PTR [ecx+eax*2+1584]
  0009f	8b 45 ec	 mov	 eax, DWORD PTR _n$5[ebp]
  000a2	d1 e0		 shl	 eax, 1
  000a4	2b d0		 sub	 edx, eax
  000a6	52		 push	 edx
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000aa	8b 91 08 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3592]
  000b0	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000b3	8d 8c 50 30 06
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+1584]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memmove
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1131 :          // adjust the position of all the other records to account for above memmove
; 1132 :          for (i=state->redo_point; i < k; ++i)

  000c3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c6	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  000cd	89 4d e0	 mov	 DWORD PTR _i$4[ebp], ecx
  000d0	eb 09		 jmp	 SHORT $LN4@stb_texted
$LN2@stb_texted:
  000d2	8b 45 e0	 mov	 eax, DWORD PTR _i$4[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 e0	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@stb_texted:
  000db	8b 45 e0	 mov	 eax, DWORD PTR _i$4[ebp]
  000de	3b 45 f8	 cmp	 eax, DWORD PTR _k$[ebp]
  000e1	7d 2f		 jge	 SHORT $LN6@stb_texted

; 1133 :             if (state->undo_rec[i].char_storage >= 0)

  000e3	8b 45 e0	 mov	 eax, DWORD PTR _i$4[ebp]
  000e6	c1 e0 04	 shl	 eax, 4
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ec	83 7c 01 0c 00	 cmp	 DWORD PTR [ecx+eax+12], 0
  000f1	7c 1d		 jl	 SHORT $LN7@stb_texted

; 1134 :                state->undo_rec[i].char_storage += n;

  000f3	8b 45 e0	 mov	 eax, DWORD PTR _i$4[ebp]
  000f6	c1 e0 04	 shl	 eax, 4
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000fc	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00100	03 55 ec	 add	 edx, DWORD PTR _n$5[ebp]
  00103	8b 45 e0	 mov	 eax, DWORD PTR _i$4[ebp]
  00106	c1 e0 04	 shl	 eax, 4
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0010c	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx
$LN7@stb_texted:
  00110	eb c0		 jmp	 SHORT $LN2@stb_texted
$LN6@stb_texted:

; 1135 :       }
; 1136 :       // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
; 1137 :       // {DEAR IMGUI]
; 1138 :       size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));

  00112	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00115	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  0011c	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  00121	2b d1		 sub	 edx, ecx
  00123	83 ea 01	 sub	 edx, 1
  00126	c1 e2 04	 shl	 edx, 4
  00129	89 55 d4	 mov	 DWORD PTR _move_size$3[ebp], edx

; 1139 :       const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;

  0012c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0012f	89 45 c8	 mov	 DWORD PTR _buf_begin$2[ebp], eax

; 1140 :       const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;

  00132	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00135	05 30 06 00 00	 add	 eax, 1584		; 00000630H
  0013a	89 45 bc	 mov	 DWORD PTR _buf_end$1[ebp], eax

; 1141 :       IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);

  0013d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00140	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  00147	c1 e1 04	 shl	 ecx, 4
  0014a	03 4d 08	 add	 ecx, DWORD PTR _state$[ebp]
  0014d	3b 4d c8	 cmp	 ecx, DWORD PTR _buf_begin$2[ebp]
  00150	73 26		 jae	 SHORT $LN9@stb_texted
  00152	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@2@@Z@4JA
  00158	83 c2 14	 add	 edx, 20			; 00000014H
  0015b	8b f4		 mov	 esi, esp
  0015d	52		 push	 edx
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@DPFBMFBF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_1HI@OHEJKGLD@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	3b f4		 cmp	 esi, esp
  00173	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@stb_texted:

; 1142 :       IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);

  00178	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0017b	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  00182	c1 e1 04	 shl	 ecx, 4
  00185	03 4d d4	 add	 ecx, DWORD PTR _move_size$3[ebp]
  00188	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0018b	8d 44 0a 10	 lea	 eax, DWORD PTR [edx+ecx+16]
  0018f	3b 45 bc	 cmp	 eax, DWORD PTR _buf_end$1[ebp]
  00192	76 26		 jbe	 SHORT $LN10@stb_texted
  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@2@@Z@4JA
  0019a	83 c1 15	 add	 ecx, 21			; 00000015H
  0019d	8b f4		 mov	 esi, esp
  0019f	51		 push	 ecx
  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@DPFBMFBF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_1JE@JEJNCKKO@?$AA?$CI?$AA?$CI?$AAc?$AAh?$AAa?$AAr?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b3	3b f4		 cmp	 esi, esp
  001b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@stb_texted:

; 1143 :       STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

  001ba	8b 45 d4	 mov	 eax, DWORD PTR _move_size$3[ebp]
  001bd	50		 push	 eax
  001be	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001c1	0f bf 91 00 0e
	00 00		 movsx	 edx, WORD PTR [ecx+3584]
  001c8	c1 e2 04	 shl	 edx, 4
  001cb	03 55 08	 add	 edx, DWORD PTR _state$[ebp]
  001ce	52		 push	 edx
  001cf	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001d2	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  001d9	c1 e1 04	 shl	 ecx, 4
  001dc	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001df	8d 44 0a 10	 lea	 eax, DWORD PTR [edx+ecx+16]
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 _memmove
  001e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1144 : 
; 1145 :       // now move redo_point to point to the new one
; 1146 :       ++state->redo_point;

  001ec	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001ef	66 8b 88 00 0e
	00 00		 mov	 cx, WORD PTR [eax+3584]
  001f6	66 83 c1 01	 add	 cx, 1
  001fa	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001fd	66 89 8a 00 0e
	00 00		 mov	 WORD PTR [edx+3584], cx
$LN1@stb_texted:

; 1147 :    }
; 1148 : }

  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	5b		 pop	 ebx
  00207	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  0020d	3b ec		 cmp	 ebp, esp
  0020f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c3		 ret	 0
?stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@1@@Z ENDP ; ImStb::stb_textedit_discard_redo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_discard_undo@ImStb@@YAXPAUStbUndoState@1@@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_n$2 = -8						; size = 4
_state$ = 8						; size = 4
?stb_textedit_discard_undo@ImStb@@YAXPAUStbUndoState@1@@Z PROC ; ImStb::stb_textedit_discard_undo, COMDAT

; 1099 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1100 :    if (state->undo_point > 0) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  00032	85 c9		 test	 ecx, ecx
  00034	0f 8e f2 00 00
	00		 jle	 $LN1@stb_texted

; 1101 :       // if the 0th undo state has characters, clean those up
; 1102 :       if (state->undo_rec[0].char_storage >= 0) {

  0003a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00045	83 7c 0a 0c 00	 cmp	 DWORD PTR [edx+ecx+12], 0
  0004a	0f 8c a3 00 00
	00		 jl	 $LN6@stb_texted

; 1103 :          int n = state->undo_rec[0].insert_length, i;

  00050	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00055	6b c8 00	 imul	 ecx, eax, 0
  00058	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005b	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  0005f	89 45 f8	 mov	 DWORD PTR _n$2[ebp], eax

; 1104 :          // delete n characters from all other records
; 1105 :          state->undo_char_point -= n;

  00062	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00065	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  0006b	2b 4d f8	 sub	 ecx, DWORD PTR _n$2[ebp]
  0006e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00071	89 8a 04 0e 00
	00		 mov	 DWORD PTR [edx+3588], ecx

; 1106 :          STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));

  00077	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0007a	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  00080	d1 e1		 shl	 ecx, 1
  00082	51		 push	 ecx
  00083	8b 55 f8	 mov	 edx, DWORD PTR _n$2[ebp]
  00086	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00089	8d 8c 50 30 06
	00 00		 lea	 ecx, DWORD PTR [eax+edx*2+1584]
  00090	51		 push	 ecx
  00091	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00094	81 c2 30 06 00
	00		 add	 edx, 1584		; 00000630H
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 _memmove
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1107 :          for (i=0; i < state->undo_point; ++i)

  000a3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  000aa	eb 09		 jmp	 SHORT $LN4@stb_texted
$LN2@stb_texted:
  000ac	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000af	83 c0 01	 add	 eax, 1
  000b2	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@stb_texted:
  000b5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000b8	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  000bf	39 4d ec	 cmp	 DWORD PTR _i$1[ebp], ecx
  000c2	7d 2f		 jge	 SHORT $LN6@stb_texted

; 1108 :             if (state->undo_rec[i].char_storage >= 0)

  000c4	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000c7	c1 e0 04	 shl	 eax, 4
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000cd	83 7c 01 0c 00	 cmp	 DWORD PTR [ecx+eax+12], 0
  000d2	7c 1d		 jl	 SHORT $LN7@stb_texted

; 1109 :                state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000d7	c1 e0 04	 shl	 eax, 4
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000dd	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  000e1	2b 55 f8	 sub	 edx, DWORD PTR _n$2[ebp]
  000e4	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000e7	c1 e0 04	 shl	 eax, 4
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ed	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx
$LN7@stb_texted:
  000f1	eb b9		 jmp	 SHORT $LN2@stb_texted
$LN6@stb_texted:

; 1110 :       }
; 1111 :       --state->undo_point;

  000f3	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000f6	66 8b 88 fe 0d
	00 00		 mov	 cx, WORD PTR [eax+3582]
  000fd	66 83 e9 01	 sub	 cx, 1
  00101	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00104	66 89 8a fe 0d
	00 00		 mov	 WORD PTR [edx+3582], cx

; 1112 :       STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));

  0010b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0010e	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  00115	c1 e1 04	 shl	 ecx, 4
  00118	51		 push	 ecx
  00119	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0011c	83 c2 10	 add	 edx, 16			; 00000010H
  0011f	52		 push	 edx
  00120	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _memmove
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@stb_texted:

; 1113 :    }
; 1114 : }

  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx
  0012f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00135	3b ec		 cmp	 ebp, esp
  00137	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
?stb_textedit_discard_undo@ImStb@@YAXPAUStbUndoState@1@@Z ENDP ; ImStb::stb_textedit_discard_undo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_flush_redo@ImStb@@YAXPAUStbUndoState@1@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_flush_redo@ImStb@@YAXPAUStbUndoState@1@@Z PROC ; ImStb::stb_textedit_flush_redo, COMDAT

; 1092 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1093 :    state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

  00028	b8 63 00 00 00	 mov	 eax, 99			; 00000063H
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	66 89 81 00 0e
	00 00		 mov	 WORD PTR [ecx+3584], ax

; 1094 :    state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

  00037	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0003a	c7 80 08 0e 00
	00 e7 03 00 00	 mov	 DWORD PTR [eax+3592], 999 ; 000003e7H

; 1095 : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?stb_textedit_flush_redo@ImStb@@YAXPAUStbUndoState@1@@Z ENDP ; ImStb::stb_textedit_flush_redo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_key@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@H@Z
_TEXT	SEGMENT
tv441 = -520						; size = 4
tv333 = -520						; size = 4
tv307 = -520						; size = 4
tv279 = -520						; size = 4
tv252 = -520						; size = 4
tv64 = -520						; size = 4
_n$1 = -320						; size = 4
_n$2 = -308						; size = 4
_n$3 = -296						; size = 4
_dx$4 = -284						; size = 4
_x$5 = -272						; size = 4
_goal_x$6 = -260					; size = 4
_sel$7 = -248						; size = 4
_i$8 = -236						; size = 4
_row$9 = -224						; size = 24
_find$10 = -192						; size = 24
_dx$11 = -160						; size = 4
_start$12 = -148					; size = 4
_x$13 = -136						; size = 4
_goal_x$14 = -124					; size = 4
_sel$15 = -112						; size = 4
_i$16 = -100						; size = 4
_row$17 = -88						; size = 24
_find$18 = -56						; size = 24
_ch$19 = -24						; size = 2
_c$20 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_key$ = 16						; size = 4
?stb_textedit_key@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@H@Z PROC ; ImStb::stb_textedit_key, COMDAT

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-520]
  00012	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$retry$109:

; 730  : retry:
; 731  :    switch (key) {

  00032	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00035	89 85 f8 fd ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  0003b	81 bd f8 fd ff
	ff 00 00 60 00	 cmp	 DWORD PTR tv64[ebp], 6291456 ; 00600000H
  00045	7f 38		 jg	 SHORT $LN98@stb_texted
  00047	81 bd f8 fd ff
	ff 00 00 60 00	 cmp	 DWORD PTR tv64[ebp], 6291456 ; 00600000H
  00051	0f 84 33 02 00
	00		 je	 $LN34@stb_texted
  00057	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  0005d	81 e9 00 00 20
	00		 sub	 ecx, 2097152		; 00200000H
  00063	89 8d f8 fd ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  00069	83 bd f8 fd ff
	ff 0d		 cmp	 DWORD PTR tv64[ebp], 13	; 0000000dH
  00070	77 34		 ja	 SHORT $LN18@stb_texted
  00072	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  00078	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN100@stb_texted[edx*4]
$LN98@stb_texted:
  0007f	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR tv64[ebp]
  00085	2d 01 00 60 00	 sub	 eax, 6291457		; 00600001H
  0008a	89 85 f8 fd ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00090	83 bd f8 fd ff
	ff 0c		 cmp	 DWORD PTR tv64[ebp], 12	; 0000000cH
  00097	77 0d		 ja	 SHORT $LN18@stb_texted
  00099	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  0009f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN101@stb_texted[ecx*4]
$LN18@stb_texted:

; 732  :       default: {
; 733  :          int c = STB_TEXTEDIT_KEYTOTEXT(key);

  000a6	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_KEYTOTEXT@ImStb@@YAHH@Z ; ImStb::STB_TEXTEDIT_KEYTOTEXT
  000af	83 c4 04	 add	 esp, 4
  000b2	89 45 f4	 mov	 DWORD PTR _c$20[ebp], eax

; 734  :          if (c > 0) {

  000b5	83 7d f4 00	 cmp	 DWORD PTR _c$20[ebp], 0
  000b9	0f 8e 08 01 00
	00		 jle	 $LN24@stb_texted

; 735  :             STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

  000bf	66 8b 45 f4	 mov	 ax, WORD PTR _c$20[ebp]
  000c3	66 89 45 e8	 mov	 WORD PTR _ch$19[ebp], ax

; 736  : 
; 737  :             // can't add newline in single-line mode
; 738  :             if (c == '\n' && state->single_line)

  000c7	83 7d f4 0a	 cmp	 DWORD PTR _c$20[ebp], 10 ; 0000000aH
  000cb	75 10		 jne	 SHORT $LN20@stb_texted
  000cd	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000d0	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 05		 je	 SHORT $LN20@stb_texted

; 739  :                break;

  000d8	e9 13 0b 00 00	 jmp	 $LN2@stb_texted
$LN20@stb_texted:

; 740  : 
; 741  :             if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {

  000dd	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000e0	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  000e4	85 c9		 test	 ecx, ecx
  000e6	0f 84 84 00 00
	00		 je	 $LN21@stb_texted
  000ec	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000ef	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  000f2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f5	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000f8	75 76		 jne	 SHORT $LN21@stb_texted
  000fa	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  00103	83 c4 04	 add	 esp, 4
  00106	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00109	39 01		 cmp	 DWORD PTR [ecx], eax
  0010b	7d 63		 jge	 SHORT $LN21@stb_texted

; 742  :                stb_text_makeundo_replace(str, state, state->cursor, 1, 1);

  0010d	6a 01		 push	 1
  0010f	6a 01		 push	 1
  00111	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00114	8b 08		 mov	 ecx, DWORD PTR [eax]
  00116	51		 push	 ecx
  00117	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  0011a	52		 push	 edx
  0011b	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?stb_text_makeundo_replace@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HHH@Z ; ImStb::stb_text_makeundo_replace
  00124	83 c4 14	 add	 esp, 20			; 00000014H

; 743  :                STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);

  00127	6a 01		 push	 1
  00129	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0012c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012e	51		 push	 ecx
  0012f	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00132	52		 push	 edx
  00133	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 744  :                if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

  0013b	6a 01		 push	 1
  0013d	8d 45 e8	 lea	 eax, DWORD PTR _ch$19[ebp]
  00140	50		 push	 eax
  00141	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00144	8b 11		 mov	 edx, DWORD PTR [ecx]
  00146	52		 push	 edx
  00147	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
  00150	83 c4 10	 add	 esp, 16			; 00000010H
  00153	0f b6 c8	 movzx	 ecx, al
  00156	85 c9		 test	 ecx, ecx
  00158	74 14		 je	 SHORT $LN23@stb_texted

; 745  :                   ++state->cursor;

  0015a	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0015d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015f	83 c1 01	 add	 ecx, 1
  00162	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00165	89 0a		 mov	 DWORD PTR [edx], ecx

; 746  :                   state->has_preferred_x = 0;

  00167	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0016a	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0
$LN23@stb_texted:

; 747  :                }
; 748  :             } else {

  0016e	eb 57		 jmp	 SHORT $LN24@stb_texted
$LN21@stb_texted:

; 749  :                stb_textedit_delete_selection(str,state); // implicitly clamps

  00170	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00173	50		 push	 eax
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 ?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection
  0017d	83 c4 08	 add	 esp, 8

; 750  :                if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

  00180	6a 01		 push	 1
  00182	8d 45 e8	 lea	 eax, DWORD PTR _ch$19[ebp]
  00185	50		 push	 eax
  00186	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00189	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018b	52		 push	 edx
  0018c	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
  00195	83 c4 10	 add	 esp, 16			; 00000010H
  00198	0f b6 c8	 movzx	 ecx, al
  0019b	85 c9		 test	 ecx, ecx
  0019d	74 28		 je	 SHORT $LN24@stb_texted

; 751  :                   stb_text_makeundo_insert(state, state->cursor, 1);

  0019f	6a 01		 push	 1
  001a1	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  001a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a6	51		 push	 ecx
  001a7	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  001aa	52		 push	 edx
  001ab	e8 00 00 00 00	 call	 ?stb_text_makeundo_insert@ImStb@@YAXPAUSTB_TexteditState@1@HH@Z ; ImStb::stb_text_makeundo_insert
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 752  :                   ++state->cursor;

  001b3	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  001b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b8	83 c1 01	 add	 ecx, 1
  001bb	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  001be	89 0a		 mov	 DWORD PTR [edx], ecx

; 753  :                   state->has_preferred_x = 0;

  001c0	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  001c3	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0
$LN24@stb_texted:

; 754  :                }
; 755  :             }
; 756  :          }
; 757  :          break;

  001c7	e9 24 0a 00 00	 jmp	 $LN2@stb_texted
$LN25@stb_texted:

; 758  :       }
; 759  : 
; 760  : #ifdef STB_TEXTEDIT_K_INSERT
; 761  :       case STB_TEXTEDIT_K_INSERT:
; 762  :          state->insert_mode = !state->insert_mode;
; 763  :          break;
; 764  : #endif
; 765  :          
; 766  :       case STB_TEXTEDIT_K_UNDO:
; 767  :          stb_text_undo(str, state);

  001cc	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  001cf	50		 push	 eax
  001d0	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  001d3	51		 push	 ecx
  001d4	e8 00 00 00 00	 call	 ?stb_text_undo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_text_undo
  001d9	83 c4 08	 add	 esp, 8

; 768  :          state->has_preferred_x = 0;

  001dc	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  001df	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 769  :          break;

  001e3	e9 08 0a 00 00	 jmp	 $LN2@stb_texted
$LN26@stb_texted:

; 770  : 
; 771  :       case STB_TEXTEDIT_K_REDO:
; 772  :          stb_text_redo(str, state);

  001e8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  001eb	50		 push	 eax
  001ec	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  001ef	51		 push	 ecx
  001f0	e8 00 00 00 00	 call	 ?stb_text_redo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_text_redo
  001f5	83 c4 08	 add	 esp, 8

; 773  :          state->has_preferred_x = 0;

  001f8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  001fb	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 774  :          break;

  001ff	e9 ec 09 00 00	 jmp	 $LN2@stb_texted
$LN27@stb_texted:

; 775  : 
; 776  :       case STB_TEXTEDIT_K_LEFT:
; 777  :          // if currently there's a selection, move cursor to start of selection
; 778  :          if (STB_TEXT_HAS_SELECTION(state))

  00204	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00207	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0020a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0020d	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00210	74 0e		 je	 SHORT $LN28@stb_texted

; 779  :             stb_textedit_move_to_first(state);

  00212	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_first
  0021b	83 c4 04	 add	 esp, 4
  0021e	eb 15		 jmp	 SHORT $LN30@stb_texted
$LN28@stb_texted:

; 780  :          else 
; 781  :             if (state->cursor > 0)

  00220	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00223	83 38 00	 cmp	 DWORD PTR [eax], 0
  00226	7e 0d		 jle	 SHORT $LN30@stb_texted

; 782  :                --state->cursor;

  00228	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0022b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022d	83 e9 01	 sub	 ecx, 1
  00230	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00233	89 0a		 mov	 DWORD PTR [edx], ecx
$LN30@stb_texted:

; 783  :          state->has_preferred_x = 0;

  00235	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00238	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 784  :          break;

  0023c	e9 af 09 00 00	 jmp	 $LN2@stb_texted
$LN31@stb_texted:

; 785  : 
; 786  :       case STB_TEXTEDIT_K_RIGHT:
; 787  :          // if currently there's a selection, move cursor to end of selection
; 788  :          if (STB_TEXT_HAS_SELECTION(state))

  00241	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00244	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00247	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0024a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0024d	74 12		 je	 SHORT $LN32@stb_texted

; 789  :             stb_textedit_move_to_last(str, state);

  0024f	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00252	50		 push	 eax
  00253	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00256	51		 push	 ecx
  00257	e8 00 00 00 00	 call	 ?stb_textedit_move_to_last@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_last
  0025c	83 c4 08	 add	 esp, 8
  0025f	eb 0d		 jmp	 SHORT $LN33@stb_texted
$LN32@stb_texted:

; 790  :          else
; 791  :             ++state->cursor;

  00261	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00264	8b 08		 mov	 ecx, DWORD PTR [eax]
  00266	83 c1 01	 add	 ecx, 1
  00269	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  0026c	89 0a		 mov	 DWORD PTR [edx], ecx
$LN33@stb_texted:

; 792  :          stb_textedit_clamp(str, state);

  0026e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00271	50		 push	 eax
  00272	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00275	51		 push	 ecx
  00276	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  0027b	83 c4 08	 add	 esp, 8

; 793  :          state->has_preferred_x = 0;

  0027e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00281	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 794  :          break;

  00285	e9 66 09 00 00	 jmp	 $LN2@stb_texted
$LN34@stb_texted:

; 795  : 
; 796  :       case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
; 797  :          stb_textedit_clamp(str, state);

  0028a	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0028d	50		 push	 eax
  0028e	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00291	51		 push	 ecx
  00292	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00297	83 c4 08	 add	 esp, 8

; 798  :          stb_textedit_prep_selection_at_cursor(state);

  0029a	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0029d	50		 push	 eax
  0029e	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  002a3	83 c4 04	 add	 esp, 4

; 799  :          // move selection left
; 800  :          if (state->select_end > 0)

  002a6	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  002a9	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  002ad	7e 0f		 jle	 SHORT $LN35@stb_texted

; 801  :             --state->select_end;

  002af	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  002b2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002b5	83 e9 01	 sub	 ecx, 1
  002b8	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  002bb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN35@stb_texted:

; 802  :          state->cursor = state->select_end;

  002be	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  002c1	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  002c4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002c7	89 10		 mov	 DWORD PTR [eax], edx

; 803  :          state->has_preferred_x = 0;

  002c9	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  002cc	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 804  :          break;

  002d0	e9 1b 09 00 00	 jmp	 $LN2@stb_texted
$LN36@stb_texted:

; 805  : 
; 806  : #ifdef STB_TEXTEDIT_MOVEWORDLEFT
; 807  :       case STB_TEXTEDIT_K_WORDLEFT:
; 808  :          if (STB_TEXT_HAS_SELECTION(state))

  002d5	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  002d8	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  002db	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002de	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  002e1	74 0e		 je	 SHORT $LN37@stb_texted

; 809  :             stb_textedit_move_to_first(state);

  002e3	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 ?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_first
  002ec	83 c4 04	 add	 esp, 4
  002ef	eb 27		 jmp	 SHORT $LN38@stb_texted
$LN37@stb_texted:

; 810  :          else {
; 811  :             state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

  002f1	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  002f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f6	51		 push	 ecx
  002f7	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  002fa	52		 push	 edx
  002fb	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
  00300	83 c4 08	 add	 esp, 8
  00303	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00306	89 01		 mov	 DWORD PTR [ecx], eax

; 812  :             stb_textedit_clamp( str, state );

  00308	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0030b	50		 push	 eax
  0030c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0030f	51		 push	 ecx
  00310	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00315	83 c4 08	 add	 esp, 8
$LN38@stb_texted:

; 813  :          }
; 814  :          break;

  00318	e9 d3 08 00 00	 jmp	 $LN2@stb_texted
$LN39@stb_texted:

; 815  : 
; 816  :       case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
; 817  :          if( !STB_TEXT_HAS_SELECTION( state ) )

  0031d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00320	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00323	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00326	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00329	75 0c		 jne	 SHORT $LN40@stb_texted

; 818  :             stb_textedit_prep_selection_at_cursor(state);

  0032b	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  00334	83 c4 04	 add	 esp, 4
$LN40@stb_texted:

; 819  : 
; 820  :          state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

  00337	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0033a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033c	51		 push	 ecx
  0033d	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00340	52		 push	 edx
  00341	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
  00346	83 c4 08	 add	 esp, 8
  00349	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0034c	89 01		 mov	 DWORD PTR [ecx], eax

; 821  :          state->select_end = state->cursor;

  0034e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00351	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00354	8b 11		 mov	 edx, DWORD PTR [ecx]
  00356	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 822  : 
; 823  :          stb_textedit_clamp( str, state );

  00359	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0035c	50		 push	 eax
  0035d	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00360	51		 push	 ecx
  00361	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00366	83 c4 08	 add	 esp, 8

; 824  :          break;

  00369	e9 82 08 00 00	 jmp	 $LN2@stb_texted
$LN41@stb_texted:

; 825  : #endif
; 826  : 
; 827  : #ifdef STB_TEXTEDIT_MOVEWORDRIGHT
; 828  :       case STB_TEXTEDIT_K_WORDRIGHT:
; 829  :          if (STB_TEXT_HAS_SELECTION(state)) 

  0036e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00371	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00374	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00377	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0037a	74 12		 je	 SHORT $LN42@stb_texted

; 830  :             stb_textedit_move_to_last(str, state);

  0037c	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0037f	50		 push	 eax
  00380	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00383	51		 push	 ecx
  00384	e8 00 00 00 00	 call	 ?stb_textedit_move_to_last@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_last
  00389	83 c4 08	 add	 esp, 8
  0038c	eb 27		 jmp	 SHORT $LN43@stb_texted
$LN42@stb_texted:

; 831  :          else {
; 832  :             state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

  0038e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00391	8b 08		 mov	 ecx, DWORD PTR [eax]
  00393	51		 push	 ecx
  00394	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00397	52		 push	 edx
  00398	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
  0039d	83 c4 08	 add	 esp, 8
  003a0	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  003a3	89 01		 mov	 DWORD PTR [ecx], eax

; 833  :             stb_textedit_clamp( str, state );

  003a5	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  003a8	50		 push	 eax
  003a9	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  003ac	51		 push	 ecx
  003ad	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  003b2	83 c4 08	 add	 esp, 8
$LN43@stb_texted:

; 834  :          }
; 835  :          break;

  003b5	e9 36 08 00 00	 jmp	 $LN2@stb_texted
$LN44@stb_texted:

; 836  : 
; 837  :       case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
; 838  :          if( !STB_TEXT_HAS_SELECTION( state ) )

  003ba	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  003bd	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  003c0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003c3	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  003c6	75 0c		 jne	 SHORT $LN45@stb_texted

; 839  :             stb_textedit_prep_selection_at_cursor(state);

  003c8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  003cb	50		 push	 eax
  003cc	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  003d1	83 c4 04	 add	 esp, 4
$LN45@stb_texted:

; 840  : 
; 841  :          state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

  003d4	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  003d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d9	51		 push	 ecx
  003da	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  003dd	52		 push	 edx
  003de	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
  003e3	83 c4 08	 add	 esp, 8
  003e6	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  003e9	89 01		 mov	 DWORD PTR [ecx], eax

; 842  :          state->select_end = state->cursor;

  003eb	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  003ee	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  003f1	8b 11		 mov	 edx, DWORD PTR [ecx]
  003f3	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 843  : 
; 844  :          stb_textedit_clamp( str, state );

  003f6	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  003f9	50		 push	 eax
  003fa	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  003fd	51		 push	 ecx
  003fe	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00403	83 c4 08	 add	 esp, 8

; 845  :          break;

  00406	e9 e5 07 00 00	 jmp	 $LN2@stb_texted
$LN46@stb_texted:

; 846  : #endif
; 847  : 
; 848  :       case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
; 849  :          stb_textedit_prep_selection_at_cursor(state);

  0040b	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  00414	83 c4 04	 add	 esp, 4

; 850  :          // move selection right
; 851  :          ++state->select_end;

  00417	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0041a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0041d	83 c1 01	 add	 ecx, 1
  00420	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00423	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 852  :          stb_textedit_clamp(str, state);

  00426	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00429	50		 push	 eax
  0042a	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0042d	51		 push	 ecx
  0042e	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00433	83 c4 08	 add	 esp, 8

; 853  :          state->cursor = state->select_end;

  00436	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00439	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0043c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0043f	89 10		 mov	 DWORD PTR [eax], edx

; 854  :          state->has_preferred_x = 0;

  00441	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00444	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 855  :          break;

  00448	e9 a3 07 00 00	 jmp	 $LN2@stb_texted
$LN47@stb_texted:

; 856  : 
; 857  :       case STB_TEXTEDIT_K_DOWN:
; 858  :       case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
; 859  :          StbFindState find;
; 860  :          StbTexteditRow row;
; 861  :          int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

  0044d	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00450	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00455	74 0c		 je	 SHORT $LN90@stb_texted
  00457	c7 85 f8 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv252[ebp], 1
  00461	eb 0a		 jmp	 SHORT $LN91@stb_texted
$LN90@stb_texted:
  00463	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv252[ebp], 0
$LN91@stb_texted:
  0046d	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv252[ebp]
  00473	89 4d 90	 mov	 DWORD PTR _sel$15[ebp], ecx

; 862  : 
; 863  :          if (state->single_line) {

  00476	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00479	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0047d	85 c9		 test	 ecx, ecx
  0047f	74 15		 je	 SHORT $LN48@stb_texted

; 864  :             // on windows, up&down in single-line behave like left&right
; 865  :             key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);

  00481	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00484	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00489	0d 01 00 20 00	 or	 eax, 2097153		; 00200001H
  0048e	89 45 10	 mov	 DWORD PTR _key$[ebp], eax

; 866  :             goto retry;

  00491	e9 9c fb ff ff	 jmp	 $retry$109
$LN48@stb_texted:

; 867  :          }
; 868  : 
; 869  :          if (sel)

  00496	83 7d 90 00	 cmp	 DWORD PTR _sel$15[ebp], 0
  0049a	74 0e		 je	 SHORT $LN49@stb_texted

; 870  :             stb_textedit_prep_selection_at_cursor(state);

  0049c	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0049f	50		 push	 eax
  004a0	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  004a5	83 c4 04	 add	 esp, 4
  004a8	eb 1e		 jmp	 SHORT $LN51@stb_texted
$LN49@stb_texted:

; 871  :          else if (STB_TEXT_HAS_SELECTION(state))

  004aa	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  004ad	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  004b0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004b3	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  004b6	74 10		 je	 SHORT $LN51@stb_texted

; 872  :             stb_textedit_move_to_last(str,state);

  004b8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  004bb	50		 push	 eax
  004bc	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  004bf	51		 push	 ecx
  004c0	e8 00 00 00 00	 call	 ?stb_textedit_move_to_last@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_last
  004c5	83 c4 08	 add	 esp, 8
$LN51@stb_texted:

; 873  : 
; 874  :          // compute current position of cursor point
; 875  :          stb_textedit_clamp(str, state);

  004c8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  004cb	50		 push	 eax
  004cc	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  004cf	51		 push	 ecx
  004d0	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  004d5	83 c4 08	 add	 esp, 8

; 876  :          stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

  004d8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  004db	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  004df	51		 push	 ecx
  004e0	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  004e3	8b 02		 mov	 eax, DWORD PTR [edx]
  004e5	50		 push	 eax
  004e6	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  004e9	51		 push	 ecx
  004ea	8d 55 c8	 lea	 edx, DWORD PTR _find$18[ebp]
  004ed	52		 push	 edx
  004ee	e8 00 00 00 00	 call	 ?stb_textedit_find_charpos@ImStb@@YAXPAUStbFindState@1@PAUImGuiInputTextState@@HH@Z ; ImStb::stb_textedit_find_charpos
  004f3	83 c4 10	 add	 esp, 16			; 00000010H

; 877  : 
; 878  :          // now find character position down a row
; 879  :          if (find.length) {

  004f6	83 7d d8 00	 cmp	 DWORD PTR _find$18[ebp+16], 0
  004fa	0f 84 2b 01 00
	00		 je	 $LN55@stb_texted

; 880  :             float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

  00500	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00503	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00507	85 c9		 test	 ecx, ecx
  00509	74 12		 je	 SHORT $LN92@stb_texted
  0050b	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  0050e	f3 0f 10 42 14	 movss	 xmm0, DWORD PTR [edx+20]
  00513	f3 0f 11 85 f8
	fd ff ff	 movss	 DWORD PTR tv279[ebp], xmm0
  0051b	eb 0d		 jmp	 SHORT $LN93@stb_texted
$LN92@stb_texted:
  0051d	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _find$18[ebp]
  00522	f3 0f 11 85 f8
	fd ff ff	 movss	 DWORD PTR tv279[ebp], xmm0
$LN93@stb_texted:
  0052a	f3 0f 10 85 f8
	fd ff ff	 movss	 xmm0, DWORD PTR tv279[ebp]
  00532	f3 0f 11 45 84	 movss	 DWORD PTR _goal_x$14[ebp], xmm0

; 881  :             float x;
; 882  :             int start = find.first_char + find.length;

  00537	8b 45 d4	 mov	 eax, DWORD PTR _find$18[ebp+12]
  0053a	03 45 d8	 add	 eax, DWORD PTR _find$18[ebp+16]
  0053d	89 85 6c ff ff
	ff		 mov	 DWORD PTR _start$12[ebp], eax

; 883  :             state->cursor = start;

  00543	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00546	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _start$12[ebp]
  0054c	89 08		 mov	 DWORD PTR [eax], ecx

; 884  :             STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

  0054e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00551	8b 08		 mov	 ecx, DWORD PTR [eax]
  00553	51		 push	 ecx
  00554	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00557	52		 push	 edx
  00558	8d 45 a8	 lea	 eax, DWORD PTR _row$17[ebp]
  0055b	50		 push	 eax
  0055c	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  00561	83 c4 0c	 add	 esp, 12			; 0000000cH

; 885  :             x = row.x0;

  00564	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _row$17[ebp]
  00569	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _x$13[ebp], xmm0

; 886  :             for (i=0; i < row.num_chars; ++i) {

  00571	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 0
  00578	eb 09		 jmp	 SHORT $LN6@stb_texted
$LN4@stb_texted:
  0057a	8b 45 9c	 mov	 eax, DWORD PTR _i$16[ebp]
  0057d	83 c0 01	 add	 eax, 1
  00580	89 45 9c	 mov	 DWORD PTR _i$16[ebp], eax
$LN6@stb_texted:
  00583	8b 45 9c	 mov	 eax, DWORD PTR _i$16[ebp]
  00586	3b 45 bc	 cmp	 eax, DWORD PTR _row$17[ebp+20]
  00589	7d 6b		 jge	 SHORT $LN5@stb_texted

; 887  :                float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);

  0058b	8b 45 9c	 mov	 eax, DWORD PTR _i$16[ebp]
  0058e	50		 push	 eax
  0058f	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _start$12[ebp]
  00595	51		 push	 ecx
  00596	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00599	52		 push	 edx
  0059a	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_GETWIDTH
  0059f	83 c4 0c	 add	 esp, 12			; 0000000cH
  005a2	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR _dx$11[ebp]

; 888  :                #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
; 889  :                if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

  005a8	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _dx$11[ebp]
  005b0	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@bf800000
  005b7	9f		 lahf
  005b8	f6 c4 44	 test	 ah, 68			; 00000044H
  005bb	7a 02		 jp	 SHORT $LN53@stb_texted

; 890  :                   break;

  005bd	eb 37		 jmp	 SHORT $LN5@stb_texted
$LN53@stb_texted:

; 891  :                #endif
; 892  :                x += dx;

  005bf	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _x$13[ebp]
  005c7	f3 0f 58 85 60
	ff ff ff	 addss	 xmm0, DWORD PTR _dx$11[ebp]
  005cf	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _x$13[ebp], xmm0

; 893  :                if (x > goal_x)

  005d7	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _x$13[ebp]
  005df	0f 2f 45 84	 comiss	 xmm0, DWORD PTR _goal_x$14[ebp]
  005e3	76 02		 jbe	 SHORT $LN54@stb_texted

; 894  :                   break;

  005e5	eb 0f		 jmp	 SHORT $LN5@stb_texted
$LN54@stb_texted:

; 895  :                ++state->cursor;

  005e7	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  005ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  005ec	83 c1 01	 add	 ecx, 1
  005ef	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  005f2	89 0a		 mov	 DWORD PTR [edx], ecx

; 896  :             }

  005f4	eb 84		 jmp	 SHORT $LN4@stb_texted
$LN5@stb_texted:

; 897  :             stb_textedit_clamp(str, state);

  005f6	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  005f9	50		 push	 eax
  005fa	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  005fd	51		 push	 ecx
  005fe	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00603	83 c4 08	 add	 esp, 8

; 898  : 
; 899  :             state->has_preferred_x = 1;

  00606	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00609	c6 40 0f 01	 mov	 BYTE PTR [eax+15], 1

; 900  :             state->preferred_x = goal_x;

  0060d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00610	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _goal_x$14[ebp]
  00615	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 901  : 
; 902  :             if (sel)

  0061a	83 7d 90 00	 cmp	 DWORD PTR _sel$15[ebp], 0
  0061e	74 0b		 je	 SHORT $LN55@stb_texted

; 903  :                state->select_end = state->cursor;

  00620	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00623	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00626	8b 11		 mov	 edx, DWORD PTR [ecx]
  00628	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN55@stb_texted:

; 904  :          }
; 905  :          break;

  0062b	e9 c0 05 00 00	 jmp	 $LN2@stb_texted
$LN56@stb_texted:

; 906  :       }
; 907  :          
; 908  :       case STB_TEXTEDIT_K_UP:
; 909  :       case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
; 910  :          StbFindState find;
; 911  :          StbTexteditRow row;
; 912  :          int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

  00630	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00633	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00638	74 0c		 je	 SHORT $LN94@stb_texted
  0063a	c7 85 f8 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv307[ebp], 1
  00644	eb 0a		 jmp	 SHORT $LN95@stb_texted
$LN94@stb_texted:
  00646	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv307[ebp], 0
$LN95@stb_texted:
  00650	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv307[ebp]
  00656	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _sel$7[ebp], ecx

; 913  : 
; 914  :          if (state->single_line) {

  0065c	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0065f	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00663	85 c9		 test	 ecx, ecx
  00665	74 15		 je	 SHORT $LN57@stb_texted

; 915  :             // on windows, up&down become left&right
; 916  :             key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);

  00667	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  0066a	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0066f	0d 00 00 20 00	 or	 eax, 2097152		; 00200000H
  00674	89 45 10	 mov	 DWORD PTR _key$[ebp], eax

; 917  :             goto retry;

  00677	e9 b6 f9 ff ff	 jmp	 $retry$109
$LN57@stb_texted:

; 918  :          }
; 919  : 
; 920  :          if (sel)

  0067c	83 bd 08 ff ff
	ff 00		 cmp	 DWORD PTR _sel$7[ebp], 0
  00683	74 0e		 je	 SHORT $LN58@stb_texted

; 921  :             stb_textedit_prep_selection_at_cursor(state);

  00685	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00688	50		 push	 eax
  00689	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  0068e	83 c4 04	 add	 esp, 4
  00691	eb 1a		 jmp	 SHORT $LN60@stb_texted
$LN58@stb_texted:

; 922  :          else if (STB_TEXT_HAS_SELECTION(state))

  00693	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00696	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00699	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0069c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0069f	74 0c		 je	 SHORT $LN60@stb_texted

; 923  :             stb_textedit_move_to_first(state);

  006a1	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  006a4	50		 push	 eax
  006a5	e8 00 00 00 00	 call	 ?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_first
  006aa	83 c4 04	 add	 esp, 4
$LN60@stb_texted:

; 924  : 
; 925  :          // compute current position of cursor point
; 926  :          stb_textedit_clamp(str, state);

  006ad	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  006b0	50		 push	 eax
  006b1	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  006b4	51		 push	 ecx
  006b5	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  006ba	83 c4 08	 add	 esp, 8

; 927  :          stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

  006bd	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  006c0	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  006c4	51		 push	 ecx
  006c5	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  006c8	8b 02		 mov	 eax, DWORD PTR [edx]
  006ca	50		 push	 eax
  006cb	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  006ce	51		 push	 ecx
  006cf	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _find$10[ebp]
  006d5	52		 push	 edx
  006d6	e8 00 00 00 00	 call	 ?stb_textedit_find_charpos@ImStb@@YAXPAUStbFindState@1@PAUImGuiInputTextState@@HH@Z ; ImStb::stb_textedit_find_charpos
  006db	83 c4 10	 add	 esp, 16			; 00000010H

; 928  : 
; 929  :          // can only go up if there's a previous row
; 930  :          if (find.prev_first != find.first_char) {

  006de	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _find$10[ebp+20]
  006e4	3b 85 4c ff ff
	ff		 cmp	 eax, DWORD PTR _find$10[ebp+12]
  006ea	0f 84 49 01 00
	00		 je	 $LN64@stb_texted

; 931  :             // now find character position up a row
; 932  :             float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

  006f0	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  006f3	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  006f7	85 c9		 test	 ecx, ecx
  006f9	74 12		 je	 SHORT $LN96@stb_texted
  006fb	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  006fe	f3 0f 10 42 14	 movss	 xmm0, DWORD PTR [edx+20]
  00703	f3 0f 11 85 f8
	fd ff ff	 movss	 DWORD PTR tv333[ebp], xmm0
  0070b	eb 10		 jmp	 SHORT $LN97@stb_texted
$LN96@stb_texted:
  0070d	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _find$10[ebp]
  00715	f3 0f 11 85 f8
	fd ff ff	 movss	 DWORD PTR tv333[ebp], xmm0
$LN97@stb_texted:
  0071d	f3 0f 10 85 f8
	fd ff ff	 movss	 xmm0, DWORD PTR tv333[ebp]
  00725	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _goal_x$6[ebp], xmm0

; 933  :             float x;
; 934  :             state->cursor = find.prev_first;

  0072d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00730	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _find$10[ebp+20]
  00736	89 08		 mov	 DWORD PTR [eax], ecx

; 935  :             STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

  00738	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0073b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0073d	51		 push	 ecx
  0073e	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00741	52		 push	 edx
  00742	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _row$9[ebp]
  00748	50		 push	 eax
  00749	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  0074e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 936  :             x = row.x0;

  00751	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _row$9[ebp]
  00759	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _x$5[ebp], xmm0

; 937  :             for (i=0; i < row.num_chars; ++i) {

  00761	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$8[ebp], 0
  0076b	eb 0f		 jmp	 SHORT $LN9@stb_texted
$LN7@stb_texted:
  0076d	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _i$8[ebp]
  00773	83 c0 01	 add	 eax, 1
  00776	89 85 14 ff ff
	ff		 mov	 DWORD PTR _i$8[ebp], eax
$LN9@stb_texted:
  0077c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _i$8[ebp]
  00782	3b 85 34 ff ff
	ff		 cmp	 eax, DWORD PTR _row$9[ebp+20]
  00788	7d 74		 jge	 SHORT $LN8@stb_texted

; 938  :                float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);

  0078a	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _i$8[ebp]
  00790	50		 push	 eax
  00791	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _find$10[ebp+20]
  00797	51		 push	 ecx
  00798	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0079b	52		 push	 edx
  0079c	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_GETWIDTH
  007a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  007a4	d9 9d e4 fe ff
	ff		 fstp	 DWORD PTR _dx$4[ebp]

; 939  :                #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
; 940  :                if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

  007aa	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _dx$4[ebp]
  007b2	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@bf800000
  007b9	9f		 lahf
  007ba	f6 c4 44	 test	 ah, 68			; 00000044H
  007bd	7a 02		 jp	 SHORT $LN62@stb_texted

; 941  :                   break;

  007bf	eb 3d		 jmp	 SHORT $LN8@stb_texted
$LN62@stb_texted:

; 942  :                #endif
; 943  :                x += dx;

  007c1	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x$5[ebp]
  007c9	f3 0f 58 85 e4
	fe ff ff	 addss	 xmm0, DWORD PTR _dx$4[ebp]
  007d1	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _x$5[ebp], xmm0

; 944  :                if (x > goal_x)

  007d9	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x$5[ebp]
  007e1	0f 2f 85 fc fe
	ff ff		 comiss	 xmm0, DWORD PTR _goal_x$6[ebp]
  007e8	76 02		 jbe	 SHORT $LN63@stb_texted

; 945  :                   break;

  007ea	eb 12		 jmp	 SHORT $LN8@stb_texted
$LN63@stb_texted:

; 946  :                ++state->cursor;

  007ec	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  007ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  007f1	83 c1 01	 add	 ecx, 1
  007f4	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  007f7	89 0a		 mov	 DWORD PTR [edx], ecx

; 947  :             }

  007f9	e9 6f ff ff ff	 jmp	 $LN7@stb_texted
$LN8@stb_texted:

; 948  :             stb_textedit_clamp(str, state);

  007fe	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00801	50		 push	 eax
  00802	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00805	51		 push	 ecx
  00806	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  0080b	83 c4 08	 add	 esp, 8

; 949  : 
; 950  :             state->has_preferred_x = 1;

  0080e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00811	c6 40 0f 01	 mov	 BYTE PTR [eax+15], 1

; 951  :             state->preferred_x = goal_x;

  00815	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00818	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _goal_x$6[ebp]
  00820	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 952  : 
; 953  :             if (sel)

  00825	83 bd 08 ff ff
	ff 00		 cmp	 DWORD PTR _sel$7[ebp], 0
  0082c	74 0b		 je	 SHORT $LN64@stb_texted

; 954  :                state->select_end = state->cursor;

  0082e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00831	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00834	8b 11		 mov	 edx, DWORD PTR [ecx]
  00836	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN64@stb_texted:

; 955  :          }
; 956  :          break;

  00839	e9 b2 03 00 00	 jmp	 $LN2@stb_texted
$LN65@stb_texted:

; 957  :       }
; 958  : 
; 959  :       case STB_TEXTEDIT_K_DELETE:
; 960  :       case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
; 961  :          if (STB_TEXT_HAS_SELECTION(state))

  0083e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00841	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00844	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00847	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0084a	74 12		 je	 SHORT $LN66@stb_texted

; 962  :             stb_textedit_delete_selection(str, state);

  0084c	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0084f	50		 push	 eax
  00850	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00853	51		 push	 ecx
  00854	e8 00 00 00 00	 call	 ?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection
  00859	83 c4 08	 add	 esp, 8
  0085c	eb 37		 jmp	 SHORT $LN68@stb_texted
$LN66@stb_texted:

; 963  :          else {
; 964  :             int n = STB_TEXTEDIT_STRINGLEN(str);

  0085e	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00861	50		 push	 eax
  00862	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  00867	83 c4 04	 add	 esp, 4
  0086a	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _n$3[ebp], eax

; 965  :             if (state->cursor < n)

  00870	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00873	8b 08		 mov	 ecx, DWORD PTR [eax]
  00875	3b 8d d8 fe ff
	ff		 cmp	 ecx, DWORD PTR _n$3[ebp]
  0087b	7d 18		 jge	 SHORT $LN68@stb_texted

; 966  :                stb_textedit_delete(str, state, state->cursor, 1);

  0087d	6a 01		 push	 1
  0087f	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00882	8b 08		 mov	 ecx, DWORD PTR [eax]
  00884	51		 push	 ecx
  00885	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00888	52		 push	 edx
  00889	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0088c	50		 push	 eax
  0088d	e8 00 00 00 00	 call	 ?stb_textedit_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete
  00892	83 c4 10	 add	 esp, 16			; 00000010H
$LN68@stb_texted:

; 967  :          }
; 968  :          state->has_preferred_x = 0;

  00895	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00898	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 969  :          break;

  0089c	e9 4f 03 00 00	 jmp	 $LN2@stb_texted
$LN69@stb_texted:

; 970  : 
; 971  :       case STB_TEXTEDIT_K_BACKSPACE:
; 972  :       case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
; 973  :          if (STB_TEXT_HAS_SELECTION(state))

  008a1	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  008a4	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  008a7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  008aa	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  008ad	74 12		 je	 SHORT $LN70@stb_texted

; 974  :             stb_textedit_delete_selection(str, state);

  008af	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  008b2	50		 push	 eax
  008b3	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  008b6	51		 push	 ecx
  008b7	e8 00 00 00 00	 call	 ?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection
  008bc	83 c4 08	 add	 esp, 8
  008bf	eb 40		 jmp	 SHORT $LN72@stb_texted
$LN70@stb_texted:

; 975  :          else {
; 976  :             stb_textedit_clamp(str, state);

  008c1	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  008c4	50		 push	 eax
  008c5	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  008c8	51		 push	 ecx
  008c9	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  008ce	83 c4 08	 add	 esp, 8

; 977  :             if (state->cursor > 0) {

  008d1	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  008d4	83 38 00	 cmp	 DWORD PTR [eax], 0
  008d7	7e 28		 jle	 SHORT $LN72@stb_texted

; 978  :                stb_textedit_delete(str, state, state->cursor-1, 1);

  008d9	6a 01		 push	 1
  008db	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  008de	8b 08		 mov	 ecx, DWORD PTR [eax]
  008e0	83 e9 01	 sub	 ecx, 1
  008e3	51		 push	 ecx
  008e4	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  008e7	52		 push	 edx
  008e8	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  008eb	50		 push	 eax
  008ec	e8 00 00 00 00	 call	 ?stb_textedit_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete
  008f1	83 c4 10	 add	 esp, 16			; 00000010H

; 979  :                --state->cursor;

  008f4	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  008f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  008f9	83 e9 01	 sub	 ecx, 1
  008fc	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  008ff	89 0a		 mov	 DWORD PTR [edx], ecx
$LN72@stb_texted:

; 980  :             }
; 981  :          }
; 982  :          state->has_preferred_x = 0;

  00901	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00904	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 983  :          break;

  00908	e9 e3 02 00 00	 jmp	 $LN2@stb_texted
$LN73@stb_texted:

; 984  :          
; 985  : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 986  :       case STB_TEXTEDIT_K_TEXTSTART2:
; 987  : #endif
; 988  :       case STB_TEXTEDIT_K_TEXTSTART:
; 989  :          state->cursor = state->select_start = state->select_end = 0;

  0090d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00910	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00917	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0091a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00921	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00924	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 990  :          state->has_preferred_x = 0;

  0092a	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0092d	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 991  :          break;

  00931	e9 ba 02 00 00	 jmp	 $LN2@stb_texted
$LN74@stb_texted:

; 992  : 
; 993  : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 994  :       case STB_TEXTEDIT_K_TEXTEND2:
; 995  : #endif
; 996  :       case STB_TEXTEDIT_K_TEXTEND:
; 997  :          state->cursor = STB_TEXTEDIT_STRINGLEN(str);

  00936	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00939	50		 push	 eax
  0093a	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  0093f	83 c4 04	 add	 esp, 4
  00942	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00945	89 01		 mov	 DWORD PTR [ecx], eax

; 998  :          state->select_start = state->select_end = 0;

  00947	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0094a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00951	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00954	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 999  :          state->has_preferred_x = 0;

  0095b	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0095e	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 1000 :          break;

  00962	e9 89 02 00 00	 jmp	 $LN2@stb_texted
$LN75@stb_texted:

; 1001 :         
; 1002 : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 1003 :       case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
; 1004 : #endif
; 1005 :       case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
; 1006 :          stb_textedit_prep_selection_at_cursor(state);

  00967	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0096a	50		 push	 eax
  0096b	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  00970	83 c4 04	 add	 esp, 4

; 1007 :          state->cursor = state->select_end = 0;

  00973	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00976	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0097d	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00980	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1008 :          state->has_preferred_x = 0;

  00986	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00989	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 1009 :          break;

  0098d	e9 5e 02 00 00	 jmp	 $LN2@stb_texted
$LN76@stb_texted:

; 1010 : 
; 1011 : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 1012 :       case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
; 1013 : #endif
; 1014 :       case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
; 1015 :          stb_textedit_prep_selection_at_cursor(state);

  00992	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00995	50		 push	 eax
  00996	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  0099b	83 c4 04	 add	 esp, 4

; 1016 :          state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);

  0099e	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  009a1	50		 push	 eax
  009a2	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  009a7	83 c4 04	 add	 esp, 4
  009aa	89 85 f8 fd ff
	ff		 mov	 DWORD PTR tv441[ebp], eax
  009b0	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  009b3	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR tv441[ebp]
  009b9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  009bc	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  009bf	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv441[ebp]
  009c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1017 :          state->has_preferred_x = 0;

  009c7	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  009ca	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 1018 :          break;

  009ce	e9 1d 02 00 00	 jmp	 $LN2@stb_texted
$LN77@stb_texted:

; 1019 : 
; 1020 : 
; 1021 : #ifdef STB_TEXTEDIT_K_LINESTART2
; 1022 :       case STB_TEXTEDIT_K_LINESTART2:
; 1023 : #endif
; 1024 :       case STB_TEXTEDIT_K_LINESTART:
; 1025 :          stb_textedit_clamp(str, state);

  009d3	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  009d6	50		 push	 eax
  009d7	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  009da	51		 push	 ecx
  009db	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  009e0	83 c4 08	 add	 esp, 8

; 1026 :          stb_textedit_move_to_first(state);

  009e3	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  009e6	50		 push	 eax
  009e7	e8 00 00 00 00	 call	 ?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_first
  009ec	83 c4 04	 add	 esp, 4

; 1027 :          if (state->single_line)

  009ef	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  009f2	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  009f6	85 c9		 test	 ecx, ecx
  009f8	74 0b		 je	 SHORT $LN78@stb_texted

; 1028 :             state->cursor = 0;

  009fa	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  009fd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00a03	eb 3a		 jmp	 SHORT $LN11@stb_texted
$LN78@stb_texted:

; 1029 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

  00a05	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a08	83 38 00	 cmp	 DWORD PTR [eax], 0
  00a0b	7e 32		 jle	 SHORT $LN11@stb_texted
  00a0d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a10	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a12	83 e9 01	 sub	 ecx, 1
  00a15	51		 push	 ecx
  00a16	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00a19	52		 push	 edx
  00a1a	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00a1f	83 c4 08	 add	 esp, 8
  00a22	0f b7 c0	 movzx	 eax, ax
  00a25	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImStb@@3GA
  00a2c	3b c1		 cmp	 eax, ecx
  00a2e	74 0f		 je	 SHORT $LN11@stb_texted

; 1030 :             --state->cursor;

  00a30	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a33	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a35	83 e9 01	 sub	 ecx, 1
  00a38	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00a3b	89 0a		 mov	 DWORD PTR [edx], ecx
  00a3d	eb c6		 jmp	 SHORT $LN78@stb_texted
$LN11@stb_texted:

; 1031 :          state->has_preferred_x = 0;

  00a3f	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a42	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 1032 :          break;

  00a46	e9 a5 01 00 00	 jmp	 $LN2@stb_texted
$LN80@stb_texted:

; 1033 : 
; 1034 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1035 :       case STB_TEXTEDIT_K_LINEEND2:
; 1036 : #endif
; 1037 :       case STB_TEXTEDIT_K_LINEEND: {
; 1038 :          int n = STB_TEXTEDIT_STRINGLEN(str);

  00a4b	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00a4e	50		 push	 eax
  00a4f	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  00a54	83 c4 04	 add	 esp, 4
  00a57	89 85 cc fe ff
	ff		 mov	 DWORD PTR _n$2[ebp], eax

; 1039 :          stb_textedit_clamp(str, state);

  00a5d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a60	50		 push	 eax
  00a61	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00a64	51		 push	 ecx
  00a65	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00a6a	83 c4 08	 add	 esp, 8

; 1040 :          stb_textedit_move_to_first(state);

  00a6d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a70	50		 push	 eax
  00a71	e8 00 00 00 00	 call	 ?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_move_to_first
  00a76	83 c4 04	 add	 esp, 4

; 1041 :          if (state->single_line)

  00a79	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a7c	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00a80	85 c9		 test	 ecx, ecx
  00a82	74 0d		 je	 SHORT $LN81@stb_texted

; 1042 :              state->cursor = n;

  00a84	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a87	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _n$2[ebp]
  00a8d	89 08		 mov	 DWORD PTR [eax], ecx
  00a8f	eb 3c		 jmp	 SHORT $LN13@stb_texted
$LN81@stb_texted:

; 1043 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

  00a91	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00a94	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a96	3b 8d cc fe ff
	ff		 cmp	 ecx, DWORD PTR _n$2[ebp]
  00a9c	7d 2f		 jge	 SHORT $LN13@stb_texted
  00a9e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00aa1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00aa3	51		 push	 ecx
  00aa4	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00aa7	52		 push	 edx
  00aa8	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00aad	83 c4 08	 add	 esp, 8
  00ab0	0f b7 c0	 movzx	 eax, ax
  00ab3	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImStb@@3GA
  00aba	3b c1		 cmp	 eax, ecx
  00abc	74 0f		 je	 SHORT $LN13@stb_texted

; 1044 :              ++state->cursor;

  00abe	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00ac1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ac3	83 c1 01	 add	 ecx, 1
  00ac6	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00ac9	89 0a		 mov	 DWORD PTR [edx], ecx
  00acb	eb c4		 jmp	 SHORT $LN81@stb_texted
$LN13@stb_texted:

; 1045 :          state->has_preferred_x = 0;

  00acd	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00ad0	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 1046 :          break;

  00ad4	e9 17 01 00 00	 jmp	 $LN2@stb_texted
$LN83@stb_texted:

; 1047 :       }
; 1048 : 
; 1049 : #ifdef STB_TEXTEDIT_K_LINESTART2
; 1050 :       case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
; 1051 : #endif
; 1052 :       case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
; 1053 :          stb_textedit_clamp(str, state);

  00ad9	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00adc	50		 push	 eax
  00add	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00ae0	51		 push	 ecx
  00ae1	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00ae6	83 c4 08	 add	 esp, 8

; 1054 :          stb_textedit_prep_selection_at_cursor(state);

  00ae9	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00aec	50		 push	 eax
  00aed	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  00af2	83 c4 04	 add	 esp, 4

; 1055 :          if (state->single_line)

  00af5	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00af8	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00afc	85 c9		 test	 ecx, ecx
  00afe	74 0b		 je	 SHORT $LN84@stb_texted

; 1056 :             state->cursor = 0;

  00b00	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b03	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00b09	eb 3a		 jmp	 SHORT $LN15@stb_texted
$LN84@stb_texted:

; 1057 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

  00b0b	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b0e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00b11	7e 32		 jle	 SHORT $LN15@stb_texted
  00b13	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b16	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b18	83 e9 01	 sub	 ecx, 1
  00b1b	51		 push	 ecx
  00b1c	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00b1f	52		 push	 edx
  00b20	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00b25	83 c4 08	 add	 esp, 8
  00b28	0f b7 c0	 movzx	 eax, ax
  00b2b	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImStb@@3GA
  00b32	3b c1		 cmp	 eax, ecx
  00b34	74 0f		 je	 SHORT $LN15@stb_texted

; 1058 :             --state->cursor;

  00b36	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b39	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b3b	83 e9 01	 sub	 ecx, 1
  00b3e	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00b41	89 0a		 mov	 DWORD PTR [edx], ecx
  00b43	eb c6		 jmp	 SHORT $LN84@stb_texted
$LN15@stb_texted:

; 1059 :          state->select_end = state->cursor;

  00b45	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b48	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00b4b	8b 11		 mov	 edx, DWORD PTR [ecx]
  00b4d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1060 :          state->has_preferred_x = 0;

  00b50	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b53	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 1061 :          break;

  00b57	e9 94 00 00 00	 jmp	 $LN2@stb_texted
$LN86@stb_texted:

; 1062 : 
; 1063 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1064 :       case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
; 1065 : #endif
; 1066 :       case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
; 1067 :          int n = STB_TEXTEDIT_STRINGLEN(str);

  00b5c	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00b5f	50		 push	 eax
  00b60	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  00b65	83 c4 04	 add	 esp, 4
  00b68	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax

; 1068 :          stb_textedit_clamp(str, state);

  00b6e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b71	50		 push	 eax
  00b72	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00b75	51		 push	 ecx
  00b76	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00b7b	83 c4 08	 add	 esp, 8

; 1069 :          stb_textedit_prep_selection_at_cursor(state);

  00b7e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b81	50		 push	 eax
  00b82	e8 00 00 00 00	 call	 ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_prep_selection_at_cursor
  00b87	83 c4 04	 add	 esp, 4

; 1070 :          if (state->single_line)

  00b8a	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b8d	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00b91	85 c9		 test	 ecx, ecx
  00b93	74 0d		 je	 SHORT $LN87@stb_texted

; 1071 :              state->cursor = n;

  00b95	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00b98	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _n$1[ebp]
  00b9e	89 08		 mov	 DWORD PTR [eax], ecx
  00ba0	eb 3c		 jmp	 SHORT $LN17@stb_texted
$LN87@stb_texted:

; 1072 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

  00ba2	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00ba5	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ba7	3b 8d c0 fe ff
	ff		 cmp	 ecx, DWORD PTR _n$1[ebp]
  00bad	7d 2f		 jge	 SHORT $LN17@stb_texted
  00baf	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00bb2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bb4	51		 push	 ecx
  00bb5	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00bb8	52		 push	 edx
  00bb9	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00bbe	83 c4 08	 add	 esp, 8
  00bc1	0f b7 c0	 movzx	 eax, ax
  00bc4	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImStb@@3GA
  00bcb	3b c1		 cmp	 eax, ecx
  00bcd	74 0f		 je	 SHORT $LN17@stb_texted

; 1073 :             ++state->cursor;

  00bcf	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00bd2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bd4	83 c1 01	 add	 ecx, 1
  00bd7	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00bda	89 0a		 mov	 DWORD PTR [edx], ecx
  00bdc	eb c4		 jmp	 SHORT $LN87@stb_texted
$LN17@stb_texted:

; 1074 :          state->select_end = state->cursor;

  00bde	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00be1	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00be4	8b 11		 mov	 edx, DWORD PTR [ecx]
  00be6	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1075 :          state->has_preferred_x = 0;

  00be9	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00bec	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0
$LN2@stb_texted:

; 1076 :          break;
; 1077 :       }
; 1078 : 
; 1079 : // @TODO:
; 1080 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1081 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1082 :    }
; 1083 : }

  00bf0	52		 push	 edx
  00bf1	8b cd		 mov	 ecx, ebp
  00bf3	50		 push	 eax
  00bf4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN108@stb_texted
  00bfa	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00bff	58		 pop	 eax
  00c00	5a		 pop	 edx
  00c01	5f		 pop	 edi
  00c02	5e		 pop	 esi
  00c03	5b		 pop	 ebx
  00c04	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c07	33 cd		 xor	 ecx, ebp
  00c09	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c0e	81 c4 08 02 00
	00		 add	 esp, 520		; 00000208H
  00c14	3b ec		 cmp	 ebp, esp
  00c16	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c1b	8b e5		 mov	 esp, ebp
  00c1d	5d		 pop	 ebp
  00c1e	c3		 ret	 0
  00c1f	90		 npad	 1
$LN108@stb_texted:
  00c20	05 00 00 00	 DD	 5
  00c24	00 00 00 00	 DD	 $LN107@stb_texted
$LN107@stb_texted:
  00c28	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00c2c	02 00 00 00	 DD	 2
  00c30	00 00 00 00	 DD	 $LN102@stb_texted
  00c34	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00c38	18 00 00 00	 DD	 24			; 00000018H
  00c3c	00 00 00 00	 DD	 $LN103@stb_texted
  00c40	a8 ff ff ff	 DD	 -88			; ffffffa8H
  00c44	18 00 00 00	 DD	 24			; 00000018H
  00c48	00 00 00 00	 DD	 $LN104@stb_texted
  00c4c	40 ff ff ff	 DD	 -192			; ffffff40H
  00c50	18 00 00 00	 DD	 24			; 00000018H
  00c54	00 00 00 00	 DD	 $LN105@stb_texted
  00c58	20 ff ff ff	 DD	 -224			; ffffff20H
  00c5c	18 00 00 00	 DD	 24			; 00000018H
  00c60	00 00 00 00	 DD	 $LN106@stb_texted
$LN106@stb_texted:
  00c64	72		 DB	 114			; 00000072H
  00c65	6f		 DB	 111			; 0000006fH
  00c66	77		 DB	 119			; 00000077H
  00c67	00		 DB	 0
$LN105@stb_texted:
  00c68	66		 DB	 102			; 00000066H
  00c69	69		 DB	 105			; 00000069H
  00c6a	6e		 DB	 110			; 0000006eH
  00c6b	64		 DB	 100			; 00000064H
  00c6c	00		 DB	 0
$LN104@stb_texted:
  00c6d	72		 DB	 114			; 00000072H
  00c6e	6f		 DB	 111			; 0000006fH
  00c6f	77		 DB	 119			; 00000077H
  00c70	00		 DB	 0
$LN103@stb_texted:
  00c71	66		 DB	 102			; 00000066H
  00c72	69		 DB	 105			; 00000069H
  00c73	6e		 DB	 110			; 0000006eH
  00c74	64		 DB	 100			; 00000064H
  00c75	00		 DB	 0
$LN102@stb_texted:
  00c76	63		 DB	 99			; 00000063H
  00c77	68		 DB	 104			; 00000068H
  00c78	00		 DB	 0
  00c79	0f 1f 00	 npad	 3
$LN100@stb_texted:
  00c7c	00 00 00 00	 DD	 $LN27@stb_texted
  00c80	00 00 00 00	 DD	 $LN31@stb_texted
  00c84	00 00 00 00	 DD	 $LN56@stb_texted
  00c88	00 00 00 00	 DD	 $LN47@stb_texted
  00c8c	00 00 00 00	 DD	 $LN77@stb_texted
  00c90	00 00 00 00	 DD	 $LN80@stb_texted
  00c94	00 00 00 00	 DD	 $LN73@stb_texted
  00c98	00 00 00 00	 DD	 $LN74@stb_texted
  00c9c	00 00 00 00	 DD	 $LN65@stb_texted
  00ca0	00 00 00 00	 DD	 $LN69@stb_texted
  00ca4	00 00 00 00	 DD	 $LN25@stb_texted
  00ca8	00 00 00 00	 DD	 $LN26@stb_texted
  00cac	00 00 00 00	 DD	 $LN36@stb_texted
  00cb0	00 00 00 00	 DD	 $LN41@stb_texted
$LN101@stb_texted:
  00cb4	00 00 00 00	 DD	 $LN46@stb_texted
  00cb8	00 00 00 00	 DD	 $LN56@stb_texted
  00cbc	00 00 00 00	 DD	 $LN47@stb_texted
  00cc0	00 00 00 00	 DD	 $LN83@stb_texted
  00cc4	00 00 00 00	 DD	 $LN86@stb_texted
  00cc8	00 00 00 00	 DD	 $LN75@stb_texted
  00ccc	00 00 00 00	 DD	 $LN76@stb_texted
  00cd0	00 00 00 00	 DD	 $LN65@stb_texted
  00cd4	00 00 00 00	 DD	 $LN69@stb_texted
  00cd8	00 00 00 00	 DD	 $LN18@stb_texted
  00cdc	00 00 00 00	 DD	 $LN18@stb_texted
  00ce0	00 00 00 00	 DD	 $LN39@stb_texted
  00ce4	00 00 00 00	 DD	 $LN44@stb_texted
?stb_textedit_key@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@H@Z ENDP ; ImStb::stb_textedit_key
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_paste_internal@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PAGH@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_text$ = 16						; size = 4
_len$ = 20						; size = 4
?stb_textedit_paste_internal@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PAGH@Z PROC ; ImStb::stb_textedit_paste_internal, COMDAT

; 706  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 707  :    // if there's a selection, the paste should delete it
; 708  :    stb_textedit_clamp(str, state);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00035	83 c4 08	 add	 esp, 8

; 709  :    stb_textedit_delete_selection(str,state);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection
  00045	83 c4 08	 add	 esp, 8

; 710  :    // try to insert the characters
; 711  :    if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {

  00048	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 10	 mov	 ecx, DWORD PTR _text$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00053	8b 02		 mov	 eax, DWORD PTR [edx]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	0f b6 d0	 movzx	 edx, al
  00065	85 d2		 test	 edx, edx
  00067	74 31		 je	 SHORT $LN2@stb_texted

; 712  :       stb_text_makeundo_insert(state, state->cursor, len);

  00069	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00070	8b 11		 mov	 edx, DWORD PTR [ecx]
  00072	52		 push	 edx
  00073	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?stb_text_makeundo_insert@ImStb@@YAXPAUSTB_TexteditState@1@HH@Z ; ImStb::stb_text_makeundo_insert
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 713  :       state->cursor += len;

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	03 4d 14	 add	 ecx, DWORD PTR _len$[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  0008a	89 0a		 mov	 DWORD PTR [edx], ecx

; 714  :       state->has_preferred_x = 0;

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0008f	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 715  :       return 1;

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	eb 28		 jmp	 SHORT $LN1@stb_texted
$LN2@stb_texted:

; 716  :    }
; 717  :    // remove the undo since we didn't actually insert the characters
; 718  :    if (state->undostate.undo_point)

  0009a	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	0f bf 88 16 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3606]
  000a4	85 c9		 test	 ecx, ecx
  000a6	74 18		 je	 SHORT $LN3@stb_texted

; 719  :       --state->undostate.undo_point;

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000ab	66 8b 88 16 0e
	00 00		 mov	 cx, WORD PTR [eax+3606]
  000b2	66 83 e9 01	 sub	 cx, 1
  000b6	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  000b9	66 89 8a 16 0e
	00 00		 mov	 WORD PTR [edx+3606], cx
$LN3@stb_texted:

; 720  :    return 0;

  000c0	33 c0		 xor	 eax, eax
$LN1@stb_texted:

; 721  : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?stb_textedit_paste_internal@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PAGH@Z ENDP ; ImStb::stb_textedit_paste_internal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_cut@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_cut@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_cut, COMDAT

; 695  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 696  :    if (STB_TEXT_HAS_SELECTION(state)) {

  00028	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0002e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00031	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00034	74 1e		 je	 SHORT $LN2@stb_texted

; 697  :       stb_textedit_delete_selection(str,state); // implicitly clamps

  00036	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection
  00043	83 c4 08	 add	 esp, 8

; 698  :       state->has_preferred_x = 0;

  00046	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00049	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 699  :       return 1;

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	eb 02		 jmp	 SHORT $LN1@stb_texted
$LN2@stb_texted:

; 700  :    }
; 701  :    return 0;

  00054	33 c0		 xor	 eax, eax
$LN1@stb_texted:

; 702  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?stb_textedit_cut@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_cut
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_prep_selection_at_cursor, COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 687  :    if (!STB_TEXT_HAS_SELECTION(state))

  00028	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00031	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00034	75 19		 jne	 SHORT $LN2@stb_texted

; 688  :       state->select_start = state->select_end = state->cursor;

  00036	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00041	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00047	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0004d	eb 0b		 jmp	 SHORT $LN1@stb_texted
$LN2@stb_texted:

; 689  :    else
; 690  :       state->cursor = state->select_end;

  0004f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00055	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00058	89 10		 mov	 DWORD PTR [eax], edx
$LN1@stb_texted:

; 691  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_prep_selection_at_cursor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_move_to_last@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_move_to_last@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_move_to_last, COMDAT

; 635  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 636  :    if (STB_TEXT_HAS_SELECTION(state)) {

  00028	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0002e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00031	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00034	74 3a		 je	 SHORT $LN1@stb_texted

; 637  :       stb_textedit_sortselection(state);

  00036	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?stb_textedit_sortselection@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_sortselection
  0003f	83 c4 04	 add	 esp, 4

; 638  :       stb_textedit_clamp(str, state);

  00042	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  0004f	83 c4 08	 add	 esp, 8

; 639  :       state->cursor = state->select_end;

  00052	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00058	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005b	89 10		 mov	 DWORD PTR [eax], edx

; 640  :       state->select_start = state->select_end;

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00063	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00066	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 641  :       state->has_preferred_x = 0;

  00069	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0006c	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0
$LN1@stb_texted:

; 642  :    }
; 643  : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?stb_textedit_move_to_last@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_move_to_last
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_move_to_first, COMDAT

; 624  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 625  :    if (STB_TEXT_HAS_SELECTION(state)) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00031	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00034	74 2a		 je	 SHORT $LN1@stb_texted

; 626  :       stb_textedit_sortselection(state);

  00036	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?stb_textedit_sortselection@ImStb@@YAXPAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_sortselection
  0003f	83 c4 04	 add	 esp, 4

; 627  :       state->cursor = state->select_start;

  00042	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00048	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004b	89 10		 mov	 DWORD PTR [eax], edx

; 628  :       state->select_end = state->select_start;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00053	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00056	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 629  :       state->has_preferred_x = 0;

  00059	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0
$LN1@stb_texted:

; 630  :    }
; 631  : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?stb_textedit_move_to_first@ImStb@@YAXPAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_move_to_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_sortselection@ImStb@@YAXPAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_temp$1 = -8						; size = 4
_state$ = 8						; size = 4
?stb_textedit_sortselection@ImStb@@YAXPAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_sortselection, COMDAT

; 614  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 615  :    if (state->select_end < state->select_start) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00031	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00034	7d 1e		 jge	 SHORT $LN1@stb_texted

; 616  :       int temp = state->select_end;

  00036	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00039	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003c	89 4d f8	 mov	 DWORD PTR _temp$1[ebp], ecx

; 617  :       state->select_end = state->select_start;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00045	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00048	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 618  :       state->select_start = temp;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _temp$1[ebp]
  00051	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@stb_texted:

; 619  :    }
; 620  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?stb_textedit_sortselection@ImStb@@YAXPAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_sortselection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_delete_selection, COMDAT

; 598  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 599  :    stb_textedit_clamp(str, state);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_clamp
  00035	83 c4 08	 add	 esp, 8

; 600  :    if (STB_TEXT_HAS_SELECTION(state)) {

  00038	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00041	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00044	0f 84 8b 00 00
	00		 je	 $LN1@stb_texted

; 601  :       if (state->select_start < state->select_end) {

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00053	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00056	7d 3c		 jge	 SHORT $LN3@stb_texted

; 602  :          stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);

  00058	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00061	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00064	52		 push	 edx
  00065	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00068	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006b	51		 push	 ecx
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  0006f	52		 push	 edx
  00070	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?stb_textedit_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete
  00079	83 c4 10	 add	 esp, 16			; 00000010H

; 603  :          state->select_end = state->cursor = state->select_start;

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00082	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00085	89 10		 mov	 DWORD PTR [eax], edx
  00087	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0008d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008f	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 604  :       } else {

  00092	eb 3a		 jmp	 SHORT $LN4@stb_texted
$LN3@stb_texted:

; 605  :          stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);

  00094	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00097	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0009a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009d	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  000a0	52		 push	 edx
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	51		 push	 ecx
  000a8	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?stb_textedit_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete
  000b5	83 c4 10	 add	 esp, 16			; 00000010H

; 606  :          state->select_start = state->cursor = state->select_end;

  000b8	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  000be	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c1	89 10		 mov	 DWORD PTR [eax], edx
  000c3	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  000c9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cb	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN4@stb_texted:

; 607  :       }
; 608  :       state->has_preferred_x = 0;

  000ce	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000d1	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0
$LN1@stb_texted:

; 609  :    }
; 610  : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000de	3b ec		 cmp	 ebp, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?stb_textedit_delete_selection@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_delete_selection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_where$ = 16						; size = 4
_len$ = 20						; size = 4
?stb_textedit_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z PROC ; ImStb::stb_textedit_delete, COMDAT

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 591  :    stb_text_makeundo_delete(str, state, where, len);

  00028	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _where$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00033	52		 push	 edx
  00034	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?stb_text_makeundo_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z ; ImStb::stb_text_makeundo_delete
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 592  :    STB_TEXTEDIT_DELETECHARS(str, where, len);

  00040	8b 45 14	 mov	 eax, DWORD PTR _len$[ebp]
  00043	50		 push	 eax
  00044	8b 4d 10	 mov	 ecx, DWORD PTR _where$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 593  :    state->has_preferred_x = 0;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00057	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 594  : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?stb_textedit_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z ENDP ; ImStb::stb_textedit_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_n$ = -8						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_clamp, COMDAT

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 577  :    int n = STB_TEXTEDIT_STRINGLEN(str);

  00028	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 578  :    if (STB_TEXT_HAS_SELECTION(state)) {

  00037	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0003d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00040	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00043	74 41		 je	 SHORT $LN2@stb_texted

; 579  :       if (state->select_start > n) state->select_start = n;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	3b 4d f8	 cmp	 ecx, DWORD PTR _n$[ebp]
  0004e	7e 09		 jle	 SHORT $LN3@stb_texted
  00050	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@stb_texted:

; 580  :       if (state->select_end   > n) state->select_end = n;

  00059	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005f	3b 4d f8	 cmp	 ecx, DWORD PTR _n$[ebp]
  00062	7e 09		 jle	 SHORT $LN4@stb_texted
  00064	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0006a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@stb_texted:

; 581  :       // if clamping forced them to be equal, move the cursor to match
; 582  :       if (state->select_start == state->select_end)

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00070	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00073	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00076	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00079	75 0b		 jne	 SHORT $LN2@stb_texted

; 583  :          state->cursor = state->select_start;

  0007b	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00084	89 10		 mov	 DWORD PTR [eax], edx
$LN2@stb_texted:

; 584  :    }
; 585  :    if (state->cursor > n) state->cursor = n;

  00086	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	3b 4d f8	 cmp	 ecx, DWORD PTR _n$[ebp]
  0008e	7e 08		 jle	 SHORT $LN1@stb_texted
  00090	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00096	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@stb_texted:

; 586  : }

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?stb_textedit_clamp@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_clamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_find_charpos@ImStb@@YAXPAUStbFindState@1@PAUImGuiInputTextState@@HH@Z
_TEXT	SEGMENT
tv208 = -280						; size = 4
_first$ = -80						; size = 4
_i$ = -68						; size = 4
_z$ = -56						; size = 4
_prev_start$ = -44					; size = 4
_r$ = -32						; size = 24
__$ArrayPad$ = -4					; size = 4
_find$ = 8						; size = 4
_str$ = 12						; size = 4
_n$ = 16						; size = 4
_single_line$ = 20					; size = 4
?stb_textedit_find_charpos@ImStb@@YAXPAUStbFindState@1@PAUImGuiInputTextState@@HH@Z PROC ; ImStb::stb_textedit_find_charpos, COMDAT

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 518  :    StbTexteditRow r;
; 519  :    int prev_start = 0;

  00032	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _prev_start$[ebp], 0

; 520  :    int z = STB_TEXTEDIT_STRINGLEN(str);

  00039	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 c8	 mov	 DWORD PTR _z$[ebp], eax

; 521  :    int i=0, first;

  00048	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 522  : 
; 523  :    if (n == z) {

  0004f	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00052	3b 45 c8	 cmp	 eax, DWORD PTR _z$[ebp]
  00055	0f 85 c9 00 00
	00		 jne	 $LN10@stb_texted

; 524  :       // if it's at the end, then find the last line -- simpler than trying to
; 525  :       // explicitly handle this case in the regular code
; 526  :       if (single_line) {

  0005b	83 7d 14 00	 cmp	 DWORD PTR _single_line$[ebp], 0
  0005f	74 50		 je	 SHORT $LN11@stb_texted

; 527  :          STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

  00061	6a 00		 push	 0
  00063	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00066	50		 push	 eax
  00067	8d 4d e0	 lea	 ecx, DWORD PTR _r$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 528  :          find->y = 0;

  00073	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  00076	0f 57 c0	 xorps	 xmm0, xmm0
  00079	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 529  :          find->first_char = 0;

  0007e	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  00081	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 530  :          find->length = z;

  00088	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  0008b	8b 4d c8	 mov	 ecx, DWORD PTR _z$[ebp]
  0008e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 531  :          find->height = r.ymax - r.ymin;

  00091	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _r$[ebp+16]
  00096	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _r$[ebp+12]
  0009b	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  0009e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 532  :          find->x = r.x1;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  000a6	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _r$[ebp+4]
  000ab	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 533  :       } else {

  000af	eb 6e		 jmp	 SHORT $LN12@stb_texted
$LN11@stb_texted:

; 534  :          find->y = 0;

  000b1	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  000b4	0f 57 c0	 xorps	 xmm0, xmm0
  000b7	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 535  :          find->x = 0;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  000bf	0f 57 c0	 xorps	 xmm0, xmm0
  000c2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 536  :          find->height = 1;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  000c9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d1	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
$LN2@stb_texted:

; 537  :          while (i < z) {

  000d6	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  000d9	3b 45 c8	 cmp	 eax, DWORD PTR _z$[ebp]
  000dc	7d 25		 jge	 SHORT $LN3@stb_texted

; 538  :             STB_TEXTEDIT_LAYOUTROW(&r, str, i);

  000de	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  000e5	51		 push	 ecx
  000e6	8d 55 e0	 lea	 edx, DWORD PTR _r$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 539  :             prev_start = i;

  000f2	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  000f5	89 45 d4	 mov	 DWORD PTR _prev_start$[ebp], eax

; 540  :             i += r.num_chars;

  000f8	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  000fb	03 45 f4	 add	 eax, DWORD PTR _r$[ebp+20]
  000fe	89 45 bc	 mov	 DWORD PTR _i$[ebp], eax

; 541  :          }

  00101	eb d3		 jmp	 SHORT $LN2@stb_texted
$LN3@stb_texted:

; 542  :          find->first_char = i;

  00103	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  00106	8b 4d bc	 mov	 ecx, DWORD PTR _i$[ebp]
  00109	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 543  :          find->length = 0;

  0010c	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  0010f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 544  :          find->prev_first = prev_start;

  00116	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  00119	8b 4d d4	 mov	 ecx, DWORD PTR _prev_start$[ebp]
  0011c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN12@stb_texted:

; 545  :       }
; 546  :       return;

  0011f	e9 e0 00 00 00	 jmp	 $LN1@stb_texted
$LN10@stb_texted:

; 547  :    }
; 548  : 
; 549  :    // search rows to find the one that straddles character n
; 550  :    find->y = 0;

  00124	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  00127	0f 57 c0	 xorps	 xmm0, xmm0
  0012a	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
$LN4@stb_texted:

; 551  : 
; 552  :    for(;;) {
; 553  :       STB_TEXTEDIT_LAYOUTROW(&r, str, i);

  0012f	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  00132	50		 push	 eax
  00133	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  00136	51		 push	 ecx
  00137	8d 55 e0	 lea	 edx, DWORD PTR _r$[ebp]
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 554  :       if (n < i + r.num_chars)

  00143	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  00146	03 45 f4	 add	 eax, DWORD PTR _r$[ebp+20]
  00149	39 45 10	 cmp	 DWORD PTR _n$[ebp], eax
  0014c	7d 02		 jge	 SHORT $LN13@stb_texted

; 555  :          break;

  0014e	eb 26		 jmp	 SHORT $LN5@stb_texted
$LN13@stb_texted:

; 556  :       prev_start = i;

  00150	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  00153	89 45 d4	 mov	 DWORD PTR _prev_start$[ebp], eax

; 557  :       i += r.num_chars;

  00156	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  00159	03 45 f4	 add	 eax, DWORD PTR _r$[ebp+20]
  0015c	89 45 bc	 mov	 DWORD PTR _i$[ebp], eax

; 558  :       find->y += r.baseline_y_delta;

  0015f	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  00162	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00167	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _r$[ebp+8]
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _find$[ebp]
  0016f	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 559  :    }

  00174	eb b9		 jmp	 SHORT $LN4@stb_texted
$LN5@stb_texted:

; 560  : 
; 561  :    find->first_char = first = i;

  00176	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  00179	89 45 b0	 mov	 DWORD PTR _first$[ebp], eax
  0017c	8b 4d 08	 mov	 ecx, DWORD PTR _find$[ebp]
  0017f	8b 55 b0	 mov	 edx, DWORD PTR _first$[ebp]
  00182	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 562  :    find->length = r.num_chars;

  00185	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  00188	8b 4d f4	 mov	 ecx, DWORD PTR _r$[ebp+20]
  0018b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 563  :    find->height = r.ymax - r.ymin;

  0018e	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _r$[ebp+16]
  00193	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _r$[ebp+12]
  00198	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  0019b	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 564  :    find->prev_first = prev_start;

  001a0	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  001a3	8b 4d d4	 mov	 ecx, DWORD PTR _prev_start$[ebp]
  001a6	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 565  : 
; 566  :    // now scan to find xpos
; 567  :    find->x = r.x0;

  001a9	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  001ac	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _r$[ebp]
  001b1	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 568  :    for (i=0; first+i < n; ++i)

  001b5	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001bc	eb 09		 jmp	 SHORT $LN9@stb_texted
$LN7@stb_texted:
  001be	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  001c1	83 c0 01	 add	 eax, 1
  001c4	89 45 bc	 mov	 DWORD PTR _i$[ebp], eax
$LN9@stb_texted:
  001c7	8b 45 b0	 mov	 eax, DWORD PTR _first$[ebp]
  001ca	03 45 bc	 add	 eax, DWORD PTR _i$[ebp]
  001cd	3b 45 10	 cmp	 eax, DWORD PTR _n$[ebp]
  001d0	7d 32		 jge	 SHORT $LN8@stb_texted

; 569  :       find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);

  001d2	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d b0	 mov	 ecx, DWORD PTR _first$[ebp]
  001d9	51		 push	 ecx
  001da	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  001dd	52		 push	 edx
  001de	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_GETWIDTH
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e6	d9 9d e8 fe ff
	ff		 fstp	 DWORD PTR tv208[ebp]
  001ec	8b 45 08	 mov	 eax, DWORD PTR _find$[ebp]
  001ef	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR tv208[ebp]
  001f7	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR _find$[ebp]
  001fe	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00202	eb ba		 jmp	 SHORT $LN7@stb_texted
$LN8@stb_texted:
$LN1@stb_texted:

; 570  : }

  00204	52		 push	 edx
  00205	8b cd		 mov	 ecx, ebp
  00207	50		 push	 eax
  00208	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@stb_texted
  0020e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00213	58		 pop	 eax
  00214	5a		 pop	 edx
  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	5b		 pop	 ebx
  00218	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021b	33 cd		 xor	 ecx, ebp
  0021d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00222	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00228	3b ec		 cmp	 ebp, esp
  0022a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
  00233	90		 npad	 1
$LN17@stb_texted:
  00234	01 00 00 00	 DD	 1
  00238	00 00 00 00	 DD	 $LN16@stb_texted
$LN16@stb_texted:
  0023c	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00240	18 00 00 00	 DD	 24			; 00000018H
  00244	00 00 00 00	 DD	 $LN15@stb_texted
$LN15@stb_texted:
  00248	72		 DB	 114			; 00000072H
  00249	00		 DB	 0
?stb_textedit_find_charpos@ImStb@@YAXPAUStbFindState@1@PAUImGuiInputTextState@@HH@Z ENDP ; ImStb::stb_textedit_find_charpos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_makeundo_replace@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HHH@Z
_TEXT	SEGMENT
_p$ = -20						; size = 4
_i$ = -8						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_where$ = 16						; size = 4
_old_length$ = 20					; size = 4
_new_length$ = 24					; size = 4
?stb_text_makeundo_replace@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HHH@Z PROC ; ImStb::stb_text_makeundo_replace, COMDAT

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1330 :    int i;
; 1331 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);

  00028	8b 45 18	 mov	 eax, DWORD PTR _new_length$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _old_length$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 10	 mov	 edx, DWORD PTR _where$[ebp]
  00033	52		 push	 edx
  00034	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00037	83 c0 18	 add	 eax, 24			; 00000018H
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?stb_text_createundo@ImStb@@YAPAGPAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	89 45 ec	 mov	 DWORD PTR _p$[ebp], eax

; 1332 :    if (p) {

  00046	83 7d ec 00	 cmp	 DWORD PTR _p$[ebp], 0
  0004a	74 39		 je	 SHORT $LN1@stb_text_m

; 1333 :       for (i=0; i < old_length; ++i)

  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00053	eb 09		 jmp	 SHORT $LN4@stb_text_m
$LN2@stb_text_m:
  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stb_text_m:
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00061	3b 45 14	 cmp	 eax, DWORD PTR _old_length$[ebp]
  00064	7d 1f		 jge	 SHORT $LN1@stb_text_m

; 1334 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

  00066	8b 45 10	 mov	 eax, DWORD PTR _where$[ebp]
  00069	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00076	83 c4 08	 add	 esp, 8
  00079	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  0007f	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  00083	eb d0		 jmp	 SHORT $LN2@stb_text_m
$LN1@stb_text_m:

; 1335 :    }
; 1336 : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?stb_text_makeundo_replace@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HHH@Z ENDP ; ImStb::stb_text_makeundo_replace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_makeundo_insert@ImStb@@YAXPAUSTB_TexteditState@1@HH@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
_where$ = 12						; size = 4
_length$ = 16						; size = 4
?stb_text_makeundo_insert@ImStb@@YAXPAUSTB_TexteditState@1@HH@Z PROC ; ImStb::stb_text_makeundo_insert, COMDAT

; 1314 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1315 :    stb_text_createundo(&state->undostate, where, 0, length);

  00028	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _where$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00035	83 c2 18	 add	 edx, 24			; 00000018H
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?stb_text_createundo@ImStb@@YAPAGPAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 1316 : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?stb_text_makeundo_insert@ImStb@@YAXPAUSTB_TexteditState@1@HH@Z ENDP ; ImStb::stb_text_makeundo_insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_makeundo_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z
_TEXT	SEGMENT
_p$ = -20						; size = 4
_i$ = -8						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_where$ = 16						; size = 4
_length$ = 20						; size = 4
?stb_text_makeundo_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z PROC ; ImStb::stb_text_makeundo_delete, COMDAT

; 1319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1320 :    int i;
; 1321 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);

  00028	6a 00		 push	 0
  0002a	8b 45 14	 mov	 eax, DWORD PTR _length$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _where$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  00035	83 c2 18	 add	 edx, 24			; 00000018H
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?stb_text_createundo@ImStb@@YAPAGPAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	89 45 ec	 mov	 DWORD PTR _p$[ebp], eax

; 1322 :    if (p) {

  00044	83 7d ec 00	 cmp	 DWORD PTR _p$[ebp], 0
  00048	74 39		 je	 SHORT $LN1@stb_text_m

; 1323 :       for (i=0; i < length; ++i)

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00051	eb 09		 jmp	 SHORT $LN4@stb_text_m
$LN2@stb_text_m:
  00053	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stb_text_m:
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005f	3b 45 14	 cmp	 eax, DWORD PTR _length$[ebp]
  00062	7d 1f		 jge	 SHORT $LN1@stb_text_m

; 1324 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

  00064	8b 45 10	 mov	 eax, DWORD PTR _where$[ebp]
  00067	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00074	83 c4 08	 add	 esp, 8
  00077	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  0007d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  00081	eb d0		 jmp	 SHORT $LN2@stb_text_m
$LN1@stb_text_m:

; 1325 :    }
; 1326 : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?stb_text_makeundo_delete@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@HH@Z ENDP ; ImStb::stb_text_makeundo_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_redo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_i$1 = -56						; size = 4
_r$ = -44						; size = 16
_u$ = -20						; size = 4
_s$ = -8						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_text_redo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_text_redo, COMDAT

; 1263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1264 :    StbUndoState *s = &state->undostate;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	83 c0 18	 add	 eax, 24			; 00000018H
  0002e	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 1265 :    StbUndoRecord *u, r;
; 1266 :    if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

  00031	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00034	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  0003b	83 f9 63	 cmp	 ecx, 99			; 00000063H
  0003e	75 05		 jne	 SHORT $LN5@stb_text_r

; 1267 :       return;

  00040	e9 93 01 00 00	 jmp	 $LN1@stb_text_r
$LN5@stb_text_r:

; 1268 : 
; 1269 :    // we need to do two things: apply the redo record, and create an undo record
; 1270 :    u = &s->undo_rec[s->undo_point];

  00045	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00048	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  0004f	c1 e1 04	 shl	 ecx, 4
  00052	03 4d f8	 add	 ecx, DWORD PTR _s$[ebp]
  00055	89 4d ec	 mov	 DWORD PTR _u$[ebp], ecx

; 1271 :    r = s->undo_rec[s->redo_point];

  00058	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0005b	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  00062	c1 e1 04	 shl	 ecx, 4
  00065	03 4d f8	 add	 ecx, DWORD PTR _s$[ebp]
  00068	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006a	89 55 d4	 mov	 DWORD PTR _r$[ebp], edx
  0006d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00070	89 45 d8	 mov	 DWORD PTR _r$[ebp+4], eax
  00073	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00076	89 55 dc	 mov	 DWORD PTR _r$[ebp+8], edx
  00079	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0007c	89 45 e0	 mov	 DWORD PTR _r$[ebp+12], eax

; 1272 : 
; 1273 :    // we KNOW there must be room for the undo record, because the redo record
; 1274 :    // was derived from an undo record
; 1275 : 
; 1276 :    u->delete_length = r.insert_length;

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  00082	8b 4d d8	 mov	 ecx, DWORD PTR _r$[ebp+4]
  00085	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1277 :    u->insert_length = r.delete_length;

  00088	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  0008b	8b 4d dc	 mov	 ecx, DWORD PTR _r$[ebp+8]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1278 :    u->where = r.where;

  00091	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  00094	8b 4d d4	 mov	 ecx, DWORD PTR _r$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1279 :    u->char_storage = -1;

  00099	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  0009c	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 1280 : 
; 1281 :    if (r.delete_length) {

  000a3	83 7d dc 00	 cmp	 DWORD PTR _r$[ebp+8], 0
  000a7	0f 84 b3 00 00
	00		 je	 $LN6@stb_text_r

; 1282 :       // the redo record requires us to delete characters, so the undo record
; 1283 :       // needs to store the characters
; 1284 : 
; 1285 :       if (s->undo_char_point + u->insert_length > s->redo_char_point) {

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b0	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  000b6	8b 55 ec	 mov	 edx, DWORD PTR _u$[ebp]
  000b9	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000bc	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000bf	3b 88 08 0e 00
	00		 cmp	 ecx, DWORD PTR [eax+3592]
  000c5	7e 16		 jle	 SHORT $LN7@stb_text_r

; 1286 :          u->insert_length = 0;

  000c7	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  000ca	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1287 :          u->delete_length = 0;

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  000d4	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1288 :       } else {

  000db	eb 6f		 jmp	 SHORT $LN8@stb_text_r
$LN7@stb_text_r:

; 1289 :          int i;
; 1290 :          u->char_storage = s->undo_char_point;

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000e3	8b 91 04 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3588]
  000e9	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1291 :          s->undo_char_point = s->undo_char_point + u->insert_length;

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ef	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  000f5	8b 55 ec	 mov	 edx, DWORD PTR _u$[ebp]
  000f8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000fe	89 88 04 0e 00
	00		 mov	 DWORD PTR [eax+3588], ecx

; 1292 : 
; 1293 :          // now save the characters
; 1294 :          for (i=0; i < u->insert_length; ++i)

  00104	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0010b	eb 09		 jmp	 SHORT $LN4@stb_text_r
$LN2@stb_text_r:
  0010d	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  00110	83 c0 01	 add	 eax, 1
  00113	89 45 c8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@stb_text_r:
  00116	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  00119	8b 4d c8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0011c	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0011f	7d 2b		 jge	 SHORT $LN8@stb_text_r

; 1295 :             s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);

  00121	8b 45 ec	 mov	 eax, DWORD PTR _u$[ebp]
  00124	8b 08		 mov	 ecx, DWORD PTR [eax]
  00126	03 4d c8	 add	 ecx, DWORD PTR _i$1[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00133	83 c4 08	 add	 esp, 8
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _u$[ebp]
  00139	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0013c	03 55 c8	 add	 edx, DWORD PTR _i$1[ebp]
  0013f	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00142	66 89 84 51 30
	06 00 00	 mov	 WORD PTR [ecx+edx*2+1584], ax
  0014a	eb c1		 jmp	 SHORT $LN2@stb_text_r
$LN8@stb_text_r:

; 1296 :       }
; 1297 : 
; 1298 :       STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);

  0014c	8b 45 dc	 mov	 eax, DWORD PTR _r$[ebp+8]
  0014f	50		 push	 eax
  00150	8b 4d d4	 mov	 ecx, DWORD PTR _r$[ebp]
  00153	51		 push	 ecx
  00154	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@stb_text_r:

; 1299 :    }
; 1300 : 
; 1301 :    if (r.insert_length) {

  00160	83 7d d8 00	 cmp	 DWORD PTR _r$[ebp+4], 0
  00164	74 37		 je	 SHORT $LN9@stb_text_r

; 1302 :       // easy case: need to insert n characters
; 1303 :       STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);

  00166	8b 45 d8	 mov	 eax, DWORD PTR _r$[ebp+4]
  00169	50		 push	 eax
  0016a	8b 4d e0	 mov	 ecx, DWORD PTR _r$[ebp+12]
  0016d	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00170	8d 84 4a 30 06
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+1584]
  00177	50		 push	 eax
  00178	8b 4d d4	 mov	 ecx, DWORD PTR _r$[ebp]
  0017b	51		 push	 ecx
  0017c	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0017f	52		 push	 edx
  00180	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
  00185	83 c4 10	 add	 esp, 16			; 00000010H

; 1304 :       s->redo_char_point += r.insert_length;

  00188	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0018b	8b 88 08 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3592]
  00191	03 4d d8	 add	 ecx, DWORD PTR _r$[ebp+4]
  00194	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00197	89 8a 08 0e 00
	00		 mov	 DWORD PTR [edx+3592], ecx
$LN9@stb_text_r:

; 1305 :    }
; 1306 : 
; 1307 :    state->cursor = r.where + r.insert_length;

  0019d	8b 45 d4	 mov	 eax, DWORD PTR _r$[ebp]
  001a0	03 45 d8	 add	 eax, DWORD PTR _r$[ebp+4]
  001a3	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  001a6	89 01		 mov	 DWORD PTR [ecx], eax

; 1308 : 
; 1309 :    s->undo_point++;

  001a8	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001ab	66 8b 88 fe 0d
	00 00		 mov	 cx, WORD PTR [eax+3582]
  001b2	66 83 c1 01	 add	 cx, 1
  001b6	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001b9	66 89 8a fe 0d
	00 00		 mov	 WORD PTR [edx+3582], cx

; 1310 :    s->redo_point++;

  001c0	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001c3	66 8b 88 00 0e
	00 00		 mov	 cx, WORD PTR [eax+3584]
  001ca	66 83 c1 01	 add	 cx, 1
  001ce	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001d1	66 89 8a 00 0e
	00 00		 mov	 WORD PTR [edx+3584], cx
$LN1@stb_text_r:

; 1311 : }

  001d8	52		 push	 edx
  001d9	8b cd		 mov	 ecx, ebp
  001db	50		 push	 eax
  001dc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@stb_text_r
  001e2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001e7	58		 pop	 eax
  001e8	5a		 pop	 edx
  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	5b		 pop	 ebx
  001ec	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  001f2	3b ec		 cmp	 ebp, esp
  001f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
  001fd	0f 1f 00	 npad	 3
$LN13@stb_text_r:
  00200	01 00 00 00	 DD	 1
  00204	00 00 00 00	 DD	 $LN12@stb_text_r
$LN12@stb_text_r:
  00208	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0020c	10 00 00 00	 DD	 16			; 00000010H
  00210	00 00 00 00	 DD	 $LN11@stb_text_r
$LN11@stb_text_r:
  00214	72		 DB	 114			; 00000072H
  00215	00		 DB	 0
?stb_text_redo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_text_redo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_undo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
_i$1 = -56						; size = 4
_r$ = -44						; size = 4
_u$ = -32						; size = 16
_s$ = -8						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_text_undo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_text_undo, COMDAT

; 1195 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1196 :    StbUndoState *s = &state->undostate;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	83 c0 18	 add	 eax, 24			; 00000018H
  0002e	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 1197 :    StbUndoRecord u, *r;
; 1198 :    if (s->undo_point == 0)

  00031	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00034	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  0003b	85 c9		 test	 ecx, ecx
  0003d	75 05		 jne	 SHORT $LN7@stb_text_u

; 1199 :       return;

  0003f	e9 d6 01 00 00	 jmp	 $LN1@stb_text_u
$LN7@stb_text_u:

; 1200 : 
; 1201 :    // we need to do two things: apply the undo record, and create a redo record
; 1202 :    u = s->undo_rec[s->undo_point-1];

  00044	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00047	0f bf 88 fe 0d
	00 00		 movsx	 ecx, WORD PTR [eax+3582]
  0004e	83 e9 01	 sub	 ecx, 1
  00051	c1 e1 04	 shl	 ecx, 4
  00054	03 4d f8	 add	 ecx, DWORD PTR _s$[ebp]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	89 55 e0	 mov	 DWORD PTR _u$[ebp], edx
  0005c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005f	89 45 e4	 mov	 DWORD PTR _u$[ebp+4], eax
  00062	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00065	89 55 e8	 mov	 DWORD PTR _u$[ebp+8], edx
  00068	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0006b	89 45 ec	 mov	 DWORD PTR _u$[ebp+12], eax

; 1203 :    r = &s->undo_rec[s->redo_point-1];

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00071	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  00078	83 e9 01	 sub	 ecx, 1
  0007b	c1 e1 04	 shl	 ecx, 4
  0007e	03 4d f8	 add	 ecx, DWORD PTR _s$[ebp]
  00081	89 4d d4	 mov	 DWORD PTR _r$[ebp], ecx

; 1204 :    r->char_storage = -1;

  00084	8b 45 d4	 mov	 eax, DWORD PTR _r$[ebp]
  00087	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 1205 : 
; 1206 :    r->insert_length = u.delete_length;

  0008e	8b 45 d4	 mov	 eax, DWORD PTR _r$[ebp]
  00091	8b 4d e8	 mov	 ecx, DWORD PTR _u$[ebp+8]
  00094	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1207 :    r->delete_length = u.insert_length;

  00097	8b 45 d4	 mov	 eax, DWORD PTR _r$[ebp]
  0009a	8b 4d e4	 mov	 ecx, DWORD PTR _u$[ebp+4]
  0009d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1208 :    r->where = u.where;

  000a0	8b 45 d4	 mov	 eax, DWORD PTR _r$[ebp]
  000a3	8b 4d e0	 mov	 ecx, DWORD PTR _u$[ebp]
  000a6	89 08		 mov	 DWORD PTR [eax], ecx

; 1209 : 
; 1210 :    if (u.delete_length) {

  000a8	83 7d e8 00	 cmp	 DWORD PTR _u$[ebp+8], 0
  000ac	0f 84 f0 00 00
	00		 je	 $LN8@stb_text_u

; 1211 :       // if the undo record says to delete characters, then the redo record will
; 1212 :       // need to re-insert the characters that get deleted, so we need to store
; 1213 :       // them.
; 1214 : 
; 1215 :       // there are three cases:
; 1216 :       //    there's enough room to store the characters
; 1217 :       //    characters stored for *redoing* don't leave room for redo
; 1218 :       //    characters stored for *undoing* don't leave room for redo
; 1219 :       // if the last is true, we have to bail
; 1220 : 
; 1221 :       if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {

  000b2	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b5	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  000bb	03 4d e8	 add	 ecx, DWORD PTR _u$[ebp+8]
  000be	81 f9 e7 03 00
	00		 cmp	 ecx, 999		; 000003e7H
  000c4	7c 0f		 jl	 SHORT $LN2@stb_text_u

; 1222 :          // the undo records take up too much character space; there's no space to store the redo characters
; 1223 :          r->insert_length = 0;

  000c6	8b 45 d4	 mov	 eax, DWORD PTR _r$[ebp]
  000c9	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1224 :       } else {

  000d0	e9 b9 00 00 00	 jmp	 $LN10@stb_text_u
$LN2@stb_text_u:

; 1225 :          int i;
; 1226 : 
; 1227 :          // there's definitely room to store the characters eventually
; 1228 :          while (s->undo_char_point + u.delete_length > s->redo_char_point) {

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000d8	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  000de	03 4d e8	 add	 ecx, DWORD PTR _u$[ebp+8]
  000e1	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  000e4	3b 8a 08 0e 00
	00		 cmp	 ecx, DWORD PTR [edx+3592]
  000ea	7e 22		 jle	 SHORT $LN3@stb_text_u

; 1229 :             // should never happen:
; 1230 :             if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ef	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  000f6	83 f9 63	 cmp	 ecx, 99			; 00000063H
  000f9	75 05		 jne	 SHORT $LN11@stb_text_u

; 1231 :                return;

  000fb	e9 1a 01 00 00	 jmp	 $LN1@stb_text_u
$LN11@stb_text_u:

; 1232 :             // there's currently not enough room, so discard a redo record
; 1233 :             stb_textedit_discard_redo(s);

  00100	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ?stb_textedit_discard_redo@ImStb@@YAXPAUStbUndoState@1@@Z ; ImStb::stb_textedit_discard_redo
  00109	83 c4 04	 add	 esp, 4

; 1234 :          }

  0010c	eb c7		 jmp	 SHORT $LN2@stb_text_u
$LN3@stb_text_u:

; 1235 :          r = &s->undo_rec[s->redo_point-1];

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00111	0f bf 88 00 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3584]
  00118	83 e9 01	 sub	 ecx, 1
  0011b	c1 e1 04	 shl	 ecx, 4
  0011e	03 4d f8	 add	 ecx, DWORD PTR _s$[ebp]
  00121	89 4d d4	 mov	 DWORD PTR _r$[ebp], ecx

; 1236 : 
; 1237 :          r->char_storage = s->redo_char_point - u.delete_length;

  00124	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00127	8b 88 08 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3592]
  0012d	2b 4d e8	 sub	 ecx, DWORD PTR _u$[ebp+8]
  00130	8b 55 d4	 mov	 edx, DWORD PTR _r$[ebp]
  00133	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1238 :          s->redo_char_point = s->redo_char_point - u.delete_length;

  00136	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00139	8b 88 08 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3592]
  0013f	2b 4d e8	 sub	 ecx, DWORD PTR _u$[ebp+8]
  00142	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00145	89 8a 08 0e 00
	00		 mov	 DWORD PTR [edx+3592], ecx

; 1239 : 
; 1240 :          // now save the characters
; 1241 :          for (i=0; i < u.delete_length; ++i)

  0014b	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00152	eb 09		 jmp	 SHORT $LN6@stb_text_u
$LN4@stb_text_u:
  00154	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  00157	83 c0 01	 add	 eax, 1
  0015a	89 45 c8	 mov	 DWORD PTR _i$1[ebp], eax
$LN6@stb_text_u:
  0015d	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  00160	3b 45 e8	 cmp	 eax, DWORD PTR _u$[ebp+8]
  00163	7d 29		 jge	 SHORT $LN10@stb_text_u

; 1242 :             s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);

  00165	8b 45 e0	 mov	 eax, DWORD PTR _u$[ebp]
  00168	03 45 c8	 add	 eax, DWORD PTR _i$1[ebp]
  0016b	50		 push	 eax
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  00175	83 c4 08	 add	 esp, 8
  00178	8b 55 d4	 mov	 edx, DWORD PTR _r$[ebp]
  0017b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0017e	03 4d c8	 add	 ecx, DWORD PTR _i$1[ebp]
  00181	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00184	66 89 84 4a 30
	06 00 00	 mov	 WORD PTR [edx+ecx*2+1584], ax
  0018c	eb c6		 jmp	 SHORT $LN4@stb_text_u
$LN10@stb_text_u:

; 1243 :       }
; 1244 : 
; 1245 :       // now we can carry out the deletion
; 1246 :       STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);

  0018e	8b 45 e8	 mov	 eax, DWORD PTR _u$[ebp+8]
  00191	50		 push	 eax
  00192	8b 4d e0	 mov	 ecx, DWORD PTR _u$[ebp]
  00195	51		 push	 ecx
  00196	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00199	52		 push	 edx
  0019a	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@stb_text_u:

; 1247 :    }
; 1248 : 
; 1249 :    // check type of recorded action:
; 1250 :    if (u.insert_length) {

  001a2	83 7d e4 00	 cmp	 DWORD PTR _u$[ebp+4], 0
  001a6	74 37		 je	 SHORT $LN12@stb_text_u

; 1251 :       // easy case: was a deletion, so we need to insert n characters
; 1252 :       STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);

  001a8	8b 45 e4	 mov	 eax, DWORD PTR _u$[ebp+4]
  001ab	50		 push	 eax
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _u$[ebp+12]
  001af	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001b2	8d 84 4a 30 06
	00 00		 lea	 eax, DWORD PTR [edx+ecx*2+1584]
  001b9	50		 push	 eax
  001ba	8b 4d e0	 mov	 ecx, DWORD PTR _u$[ebp]
  001bd	51		 push	 ecx
  001be	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  001c1	52		 push	 edx
  001c2	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
  001c7	83 c4 10	 add	 esp, 16			; 00000010H

; 1253 :       s->undo_char_point -= u.insert_length;

  001ca	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001cd	8b 88 04 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3588]
  001d3	2b 4d e4	 sub	 ecx, DWORD PTR _u$[ebp+4]
  001d6	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001d9	89 8a 04 0e 00
	00		 mov	 DWORD PTR [edx+3588], ecx
$LN12@stb_text_u:

; 1254 :    }
; 1255 : 
; 1256 :    state->cursor = u.where + u.insert_length;

  001df	8b 45 e0	 mov	 eax, DWORD PTR _u$[ebp]
  001e2	03 45 e4	 add	 eax, DWORD PTR _u$[ebp+4]
  001e5	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  001e8	89 01		 mov	 DWORD PTR [ecx], eax

; 1257 : 
; 1258 :    s->undo_point--;

  001ea	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001ed	66 8b 88 fe 0d
	00 00		 mov	 cx, WORD PTR [eax+3582]
  001f4	66 83 e9 01	 sub	 cx, 1
  001f8	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001fb	66 89 8a fe 0d
	00 00		 mov	 WORD PTR [edx+3582], cx

; 1259 :    s->redo_point--;

  00202	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00205	66 8b 88 00 0e
	00 00		 mov	 cx, WORD PTR [eax+3584]
  0020c	66 83 e9 01	 sub	 cx, 1
  00210	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00213	66 89 8a 00 0e
	00 00		 mov	 WORD PTR [edx+3584], cx
$LN1@stb_text_u:

; 1260 : }

  0021a	52		 push	 edx
  0021b	8b cd		 mov	 ecx, ebp
  0021d	50		 push	 eax
  0021e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@stb_text_u
  00224	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00229	58		 pop	 eax
  0022a	5a		 pop	 edx
  0022b	5f		 pop	 edi
  0022c	5e		 pop	 esi
  0022d	5b		 pop	 ebx
  0022e	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00234	3b ec		 cmp	 ebp, esp
  00236	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023b	8b e5		 mov	 esp, ebp
  0023d	5d		 pop	 ebp
  0023e	c3		 ret	 0
  0023f	90		 npad	 1
$LN16@stb_text_u:
  00240	01 00 00 00	 DD	 1
  00244	00 00 00 00	 DD	 $LN15@stb_text_u
$LN15@stb_text_u:
  00248	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0024c	10 00 00 00	 DD	 16			; 00000010H
  00250	00 00 00 00	 DD	 $LN14@stb_text_u
$LN14@stb_text_u:
  00254	75		 DB	 117			; 00000075H
  00255	00		 DB	 0
?stb_text_undo@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_text_undo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_drag@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z
_TEXT	SEGMENT
_r$1 = -44						; size = 24
_p$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?stb_textedit_drag@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z PROC ; ImStb::stb_textedit_drag, COMDAT

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 476  :    int p = 0;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 477  : 
; 478  :    // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
; 479  :    // goes off the top or bottom of the text
; 480  :    if( state->single_line )

  00039	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0003c	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00040	85 c9		 test	 ecx, ecx
  00042	74 1c		 je	 SHORT $LN2@stb_texted

; 481  :    {
; 482  :       StbTexteditRow r;
; 483  :       STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

  00044	6a 00		 push	 0
  00046	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00049	50		 push	 eax
  0004a	8d 4d d4	 lea	 ecx, DWORD PTR _r$1[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 484  :       y = r.ymin;

  00056	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _r$1[ebp+12]
  0005b	f3 0f 11 45 14	 movss	 DWORD PTR _y$[ebp], xmm0
$LN2@stb_texted:

; 485  :    }
; 486  : 
; 487  :    if (state->select_start == state->select_end)

  00060	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00066	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00069	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0006c	75 0b		 jne	 SHORT $LN3@stb_texted

; 488  :       state->select_start = state->cursor;

  0006e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00074	8b 11		 mov	 edx, DWORD PTR [ecx]
  00076	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN3@stb_texted:

; 489  : 
; 490  :    p = stb_text_locate_coord(str, x, y);

  00079	51		 push	 ecx
  0007a	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y$[ebp]
  0007f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00084	51		 push	 ecx
  00085	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x$[ebp]
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?stb_text_locate_coord@ImStb@@YAHPAUImGuiInputTextState@@MM@Z ; ImStb::stb_text_locate_coord
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 491  :    state->cursor = state->select_end = p;

  0009e	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR _p$[ebp]
  000a4	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a7	8b 55 0c	 mov	 edx, DWORD PTR _state$[ebp]
  000aa	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  000ad	89 02		 mov	 DWORD PTR [edx], eax

; 492  : }

  000af	52		 push	 edx
  000b0	8b cd		 mov	 ecx, ebp
  000b2	50		 push	 eax
  000b3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@stb_texted
  000b9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000be	58		 pop	 eax
  000bf	5a		 pop	 edx
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	33 cd		 xor	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
  000de	66 90		 npad	 2
$LN7@stb_texted:
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN6@stb_texted
$LN6@stb_texted:
  000e8	d4 ff ff ff	 DD	 -44			; ffffffd4H
  000ec	18 00 00 00	 DD	 24			; 00000018H
  000f0	00 00 00 00	 DD	 $LN5@stb_texted
$LN5@stb_texted:
  000f4	72		 DB	 114			; 00000072H
  000f5	00		 DB	 0
?stb_textedit_drag@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z ENDP ; ImStb::stb_textedit_drag
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_click@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z
_TEXT	SEGMENT
_r$1 = -32						; size = 24
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?stb_textedit_click@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z PROC ; ImStb::stb_textedit_click, COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 458  :    // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
; 459  :    // goes off the top or bottom of the text
; 460  :    if( state->single_line )

  00032	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00035	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 1c		 je	 SHORT $LN2@stb_texted

; 461  :    {
; 462  :       StbTexteditRow r;
; 463  :       STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

  0003d	6a 00		 push	 0
  0003f	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00042	50		 push	 eax
  00043	8d 4d e0	 lea	 ecx, DWORD PTR _r$1[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  :       y = r.ymin;

  0004f	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _r$1[ebp+12]
  00054	f3 0f 11 45 14	 movss	 DWORD PTR _y$[ebp], xmm0
$LN2@stb_texted:

; 465  :    }
; 466  : 
; 467  :    state->cursor = stb_text_locate_coord(str, x, y);

  00059	51		 push	 ecx
  0005a	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y$[ebp]
  0005f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00064	51		 push	 ecx
  00065	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x$[ebp]
  0006a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006f	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?stb_text_locate_coord@ImStb@@YAHPAUImGuiInputTextState@@MM@Z ; ImStb::stb_text_locate_coord
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  0007e	89 01		 mov	 DWORD PTR [ecx], eax

; 468  :    state->select_start = state->cursor;

  00080	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00083	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00086	8b 11		 mov	 edx, DWORD PTR [ecx]
  00088	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 469  :    state->select_end = state->cursor;

  0008b	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR _state$[ebp]
  00091	8b 11		 mov	 edx, DWORD PTR [ecx]
  00093	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 470  :    state->has_preferred_x = 0;

  00096	8b 45 0c	 mov	 eax, DWORD PTR _state$[ebp]
  00099	c6 40 0f 00	 mov	 BYTE PTR [eax+15], 0

; 471  : }

  0009d	52		 push	 edx
  0009e	8b cd		 mov	 ecx, ebp
  000a0	50		 push	 eax
  000a1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@stb_texted
  000a7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ac	58		 pop	 eax
  000ad	5a		 pop	 edx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	33 cd		 xor	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN6@stb_texted:
  000cc	01 00 00 00	 DD	 1
  000d0	00 00 00 00	 DD	 $LN5@stb_texted
$LN5@stb_texted:
  000d4	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000d8	18 00 00 00	 DD	 24			; 00000018H
  000dc	00 00 00 00	 DD	 $LN4@stb_texted
$LN4@stb_texted:
  000e0	72		 DB	 114			; 00000072H
  000e1	00		 DB	 0
?stb_textedit_click@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z ENDP ; ImStb::stb_textedit_click
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_textedit.h
;	COMDAT ?stb_text_locate_coord@ImStb@@YAHPAUImGuiInputTextState@@MM@Z
_TEXT	SEGMENT
_w$1 = -104						; size = 4
_k$ = -92						; size = 4
_i$ = -80						; size = 4
_prev_x$ = -68						; size = 4
_base_y$ = -56						; size = 4
_n$ = -44						; size = 4
_r$ = -32						; size = 24
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?stb_text_locate_coord@ImStb@@YAHPAUImGuiInputTextState@@MM@Z PROC ; ImStb::stb_text_locate_coord, COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __E7AA0281_imstb_textedit@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 398  :    StbTexteditRow r;
; 399  :    int n = STB_TEXTEDIT_STRINGLEN(str);

  00032	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ; ImStb::STB_TEXTEDIT_STRINGLEN
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 d4	 mov	 DWORD PTR _n$[ebp], eax

; 400  :    float base_y = 0, prev_x;

  00041	0f 57 c0	 xorps	 xmm0, xmm0
  00044	f3 0f 11 45 c8	 movss	 DWORD PTR _base_y$[ebp], xmm0

; 401  :    int i=0, k;

  00049	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 402  : 
; 403  :    r.x0 = r.x1 = 0;

  00050	0f 57 c0	 xorps	 xmm0, xmm0
  00053	f3 0f 11 45 e4	 movss	 DWORD PTR _r$[ebp+4], xmm0
  00058	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _r$[ebp+4]
  0005d	f3 0f 11 45 e0	 movss	 DWORD PTR _r$[ebp], xmm0

; 404  :    r.ymin = r.ymax = 0;

  00062	0f 57 c0	 xorps	 xmm0, xmm0
  00065	f3 0f 11 45 f0	 movss	 DWORD PTR _r$[ebp+16], xmm0
  0006a	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _r$[ebp+16]
  0006f	f3 0f 11 45 ec	 movss	 DWORD PTR _r$[ebp+12], xmm0

; 405  :    r.num_chars = 0;

  00074	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp+20], 0
$LN2@stb_text_l:

; 406  : 
; 407  :    // search rows to find one that straddles 'y'
; 408  :    while (i < n) {

  0007b	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  0007e	3b 45 d4	 cmp	 eax, DWORD PTR _n$[ebp]
  00081	7d 6b		 jge	 SHORT $LN3@stb_text_l

; 409  :       STB_TEXTEDIT_LAYOUTROW(&r, str, i);

  00083	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 55 e0	 lea	 edx, DWORD PTR _r$[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 410  :       if (r.num_chars <= 0)

  00097	83 7d f4 00	 cmp	 DWORD PTR _r$[ebp+20], 0
  0009b	7f 08		 jg	 SHORT $LN7@stb_text_l

; 411  :          return n;

  0009d	8b 45 d4	 mov	 eax, DWORD PTR _n$[ebp]
  000a0	e9 3e 01 00 00	 jmp	 $LN17@stb_text_l
$LN7@stb_text_l:

; 412  : 
; 413  :       if (i==0 && y < base_y + r.ymin)

  000a5	83 7d b0 00	 cmp	 DWORD PTR _i$[ebp], 0
  000a9	75 17		 jne	 SHORT $LN8@stb_text_l
  000ab	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _base_y$[ebp]
  000b0	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _r$[ebp+12]
  000b5	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _y$[ebp]
  000b9	76 07		 jbe	 SHORT $LN8@stb_text_l

; 414  :          return 0;

  000bb	33 c0		 xor	 eax, eax
  000bd	e9 21 01 00 00	 jmp	 $LN17@stb_text_l
$LN8@stb_text_l:

; 415  : 
; 416  :       if (y < base_y + r.ymax)

  000c2	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _base_y$[ebp]
  000c7	f3 0f 58 45 f0	 addss	 xmm0, DWORD PTR _r$[ebp+16]
  000cc	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _y$[ebp]
  000d0	76 02		 jbe	 SHORT $LN9@stb_text_l

; 417  :          break;

  000d2	eb 1a		 jmp	 SHORT $LN3@stb_text_l
$LN9@stb_text_l:

; 418  : 
; 419  :       i += r.num_chars;

  000d4	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  000d7	03 45 f4	 add	 eax, DWORD PTR _r$[ebp+20]
  000da	89 45 b0	 mov	 DWORD PTR _i$[ebp], eax

; 420  :       base_y += r.baseline_y_delta;

  000dd	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _base_y$[ebp]
  000e2	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _r$[ebp+8]
  000e7	f3 0f 11 45 c8	 movss	 DWORD PTR _base_y$[ebp], xmm0

; 421  :    }

  000ec	eb 8d		 jmp	 SHORT $LN2@stb_text_l
$LN3@stb_text_l:

; 422  : 
; 423  :    // below all text, return 'after' last character
; 424  :    if (i >= n)

  000ee	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  000f1	3b 45 d4	 cmp	 eax, DWORD PTR _n$[ebp]
  000f4	7c 08		 jl	 SHORT $LN10@stb_text_l

; 425  :       return n;

  000f6	8b 45 d4	 mov	 eax, DWORD PTR _n$[ebp]
  000f9	e9 e5 00 00 00	 jmp	 $LN17@stb_text_l
$LN10@stb_text_l:

; 426  : 
; 427  :    // check if it's before the beginning of the line
; 428  :    if (x < r.x0)

  000fe	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _r$[ebp]
  00103	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _x$[ebp]
  00107	76 08		 jbe	 SHORT $LN11@stb_text_l

; 429  :       return i;

  00109	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  0010c	e9 d2 00 00 00	 jmp	 $LN17@stb_text_l
$LN11@stb_text_l:

; 430  : 
; 431  :    // check if it's before the end of the line
; 432  :    if (x < r.x1) {

  00111	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _r$[ebp+4]
  00116	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _x$[ebp]
  0011a	0f 86 8a 00 00
	00		 jbe	 $LN5@stb_text_l

; 433  :       // search characters in row for one that straddles 'x'
; 434  :       prev_x = r.x0;

  00120	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _r$[ebp]
  00125	f3 0f 11 45 bc	 movss	 DWORD PTR _prev_x$[ebp], xmm0

; 435  :       for (k=0; k < r.num_chars; ++k) {

  0012a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00131	eb 09		 jmp	 SHORT $LN6@stb_text_l
$LN4@stb_text_l:
  00133	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00136	83 c0 01	 add	 eax, 1
  00139	89 45 a4	 mov	 DWORD PTR _k$[ebp], eax
$LN6@stb_text_l:
  0013c	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  0013f	3b 45 f4	 cmp	 eax, DWORD PTR _r$[ebp+20]
  00142	7d 66		 jge	 SHORT $LN5@stb_text_l

; 436  :          float w = STB_TEXTEDIT_GETWIDTH(str, i, k);

  00144	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00147	50		 push	 eax
  00148	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  0014b	51		 push	 ecx
  0014c	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_GETWIDTH
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH
  00158	d9 5d 98	 fstp	 DWORD PTR _w$1[ebp]

; 437  :          if (x < prev_x+w) {

  0015b	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _prev_x$[ebp]
  00160	f3 0f 58 45 98	 addss	 xmm0, DWORD PTR _w$1[ebp]
  00165	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _x$[ebp]
  00169	76 2e		 jbe	 SHORT $LN15@stb_text_l

; 438  :             if (x < prev_x+w/2)

  0016b	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _w$1[ebp]
  00170	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00178	f3 0f 58 45 bc	 addss	 xmm0, DWORD PTR _prev_x$[ebp]
  0017d	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _x$[ebp]
  00181	76 0a		 jbe	 SHORT $LN14@stb_text_l

; 439  :                return k+i;

  00183	8b 45 a4	 mov	 eax, DWORD PTR _k$[ebp]
  00186	03 45 b0	 add	 eax, DWORD PTR _i$[ebp]
  00189	eb 58		 jmp	 SHORT $LN17@stb_text_l
  0018b	eb 0c		 jmp	 SHORT $LN15@stb_text_l
$LN14@stb_text_l:

; 440  :             else
; 441  :                return k+i+1;

  0018d	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00190	8b 4d a4	 mov	 ecx, DWORD PTR _k$[ebp]
  00193	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00197	eb 4a		 jmp	 SHORT $LN17@stb_text_l
$LN15@stb_text_l:

; 442  :          }
; 443  :          prev_x += w;

  00199	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _prev_x$[ebp]
  0019e	f3 0f 58 45 98	 addss	 xmm0, DWORD PTR _w$1[ebp]
  001a3	f3 0f 11 45 bc	 movss	 DWORD PTR _prev_x$[ebp], xmm0

; 444  :       }

  001a8	eb 89		 jmp	 SHORT $LN4@stb_text_l
$LN5@stb_text_l:

; 445  :       // shouldn't happen, but if it does, fall through to end-of-line case
; 446  :    }
; 447  : 
; 448  :    // if the last character is a newline, return that. otherwise return 'after' the last character
; 449  :    if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)

  001aa	8b 45 f4	 mov	 eax, DWORD PTR _r$[ebp+20]
  001ad	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  001b0	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  001b4	52		 push	 edx
  001b5	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_GETCHAR
  001be	83 c4 08	 add	 esp, 8
  001c1	0f b7 c8	 movzx	 ecx, ax
  001c4	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImStb@@3GA
  001cb	3b ca		 cmp	 ecx, edx
  001cd	75 0e		 jne	 SHORT $LN16@stb_text_l

; 450  :       return i+r.num_chars-1;

  001cf	8b 45 f4	 mov	 eax, DWORD PTR _r$[ebp+20]
  001d2	8b 4d b0	 mov	 ecx, DWORD PTR _i$[ebp]
  001d5	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  001d9	eb 08		 jmp	 SHORT $LN17@stb_text_l
  001db	eb 06		 jmp	 SHORT $LN17@stb_text_l
$LN16@stb_text_l:

; 451  :    else
; 452  :       return i+r.num_chars;

  001dd	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  001e0	03 45 f4	 add	 eax, DWORD PTR _r$[ebp+20]
$LN17@stb_text_l:

; 453  : }

  001e3	52		 push	 edx
  001e4	8b cd		 mov	 ecx, ebp
  001e6	50		 push	 eax
  001e7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@stb_text_l
  001ed	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001f2	58		 pop	 eax
  001f3	5a		 pop	 edx
  001f4	5f		 pop	 edi
  001f5	5e		 pop	 esi
  001f6	5b		 pop	 ebx
  001f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fa	33 cd		 xor	 ecx, ebp
  001fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00201	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00207	3b ec		 cmp	 ebp, esp
  00209	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020e	8b e5		 mov	 esp, ebp
  00210	5d		 pop	 ebp
  00211	c3		 ret	 0
  00212	66 90		 npad	 2
$LN21@stb_text_l:
  00214	01 00 00 00	 DD	 1
  00218	00 00 00 00	 DD	 $LN20@stb_text_l
$LN20@stb_text_l:
  0021c	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00220	18 00 00 00	 DD	 24			; 00000018H
  00224	00 00 00 00	 DD	 $LN19@stb_text_l
$LN19@stb_text_l:
  00228	72		 DB	 114			; 00000072H
  00229	00		 DB	 0
?stb_text_locate_coord@ImStb@@YAHPAUImGuiInputTextState@@MM@Z ENDP ; ImStb::stb_text_locate_coord
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z
_TEXT	SEGMENT
tv67 = -241						; size = 1
_text$ = -44						; size = 4
_new_text_len_utf8$ = -32				; size = 4
_text_len$ = -20					; size = 4
_is_resizable$ = -5					; size = 1
_obj$ = 8						; size = 4
_pos$ = 12						; size = 4
_new_text$ = 16						; size = 4
_new_text_len$ = 20					; size = 4
?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z PROC ; ImStb::STB_TEXTEDIT_INSERTCHARS, COMDAT

; 3203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3204 :     const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;

  00028	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  0002b	8b 88 68 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3688]
  00031	81 e1 00 00 04
	00		 and	 ecx, 262144		; 00040000H
  00037	74 09		 je	 SHORT $LN7@STB_TEXTED
  00039	c6 85 0f ff ff
	ff 01		 mov	 BYTE PTR tv67[ebp], 1
  00040	eb 07		 jmp	 SHORT $LN8@STB_TEXTED
$LN7@STB_TEXTED:
  00042	c6 85 0f ff ff
	ff 00		 mov	 BYTE PTR tv67[ebp], 0
$LN8@STB_TEXTED:
  00049	8a 95 0f ff ff
	ff		 mov	 dl, BYTE PTR tv67[ebp]
  0004f	88 55 fb	 mov	 BYTE PTR _is_resizable$[ebp], dl

; 3205 :     const int text_len = obj->CurLenW;

  00052	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00055	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00058	89 4d ec	 mov	 DWORD PTR _text_len$[ebp], ecx

; 3206 :     IM_ASSERT(pos <= text_len);

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0005e	3b 45 ec	 cmp	 eax, DWORD PTR _text_len$[ebp]
  00061	7e 26		 jle	 SHORT $LN9@STB_TEXTED
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z@4JA
  00069	83 c1 03	 add	 ecx, 3
  0006c	8b f4		 mov	 esi, esp
  0006e	51		 push	 ecx
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@MNHDBBDP@?$AAp?$AAo?$AAs?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@STB_TEXTED:

; 3207 : 
; 3208 :     const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);

  00089	8b 45 14	 mov	 eax, DWORD PTR _new_text_len$[ebp]
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR _new_text$[ebp]
  0008f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00092	52		 push	 edx
  00093	8b 45 10	 mov	 eax, DWORD PTR _new_text$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z ; ImTextCountUtf8BytesFromStr
  0009c	83 c4 08	 add	 esp, 8
  0009f	89 45 e0	 mov	 DWORD PTR _new_text_len_utf8$[ebp], eax

; 3209 :     if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))

  000a2	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_resizable$[ebp]
  000a6	85 c0		 test	 eax, eax
  000a8	75 1c		 jne	 SHORT $LN2@STB_TEXTED
  000aa	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  000ad	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b0	8b 55 e0	 mov	 edx, DWORD PTR _new_text_len_utf8$[ebp]
  000b3	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  000ba	3b 41 34	 cmp	 eax, DWORD PTR [ecx+52]
  000bd	7e 07		 jle	 SHORT $LN2@STB_TEXTED

; 3210 :         return false;

  000bf	32 c0		 xor	 al, al
  000c1	e9 17 01 00 00	 jmp	 $LN1@STB_TEXTED
$LN2@STB_TEXTED:

; 3211 : 
; 3212 :     // Grow internal buffer if needed
; 3213 :     if (new_text_len + text_len + 1 > obj->TextW.Size)

  000c6	8b 45 ec	 mov	 eax, DWORD PTR _text_len$[ebp]
  000c9	8b 4d 14	 mov	 ecx, DWORD PTR _new_text_len$[ebp]
  000cc	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  000d0	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  000d3	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  000d6	7e 76		 jle	 SHORT $LN3@STB_TEXTED

; 3214 :     {
; 3215 :         if (!is_resizable)

  000d8	0f b6 45 fb	 movzx	 eax, BYTE PTR _is_resizable$[ebp]
  000dc	85 c0		 test	 eax, eax
  000de	75 07		 jne	 SHORT $LN4@STB_TEXTED

; 3216 :             return false;

  000e0	32 c0		 xor	 al, al
  000e2	e9 f6 00 00 00	 jmp	 $LN1@STB_TEXTED
$LN4@STB_TEXTED:

; 3217 :         IM_ASSERT(text_len < obj->TextW.Size);

  000e7	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  000ea	8b 4d ec	 mov	 ecx, DWORD PTR _text_len$[ebp]
  000ed	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000f0	7c 26		 jl	 SHORT $LN10@STB_TEXTED
  000f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z@4JA
  000f8	83 c2 0e	 add	 edx, 14			; 0000000eH
  000fb	8b f4		 mov	 esi, esp
  000fd	52		 push	 edx
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@IEAPMEMO@?$AAt?$AAe?$AAx?$AAt?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAo?$AAb?$AAj?$AA?9@
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	3b f4		 cmp	 esi, esp
  00113	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@STB_TEXTED:

; 3218 :         obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);

  00118	8b 45 14	 mov	 eax, DWORD PTR _new_text_len$[ebp]
  0011b	50		 push	 eax
  0011c	68 00 01 00 00	 push	 256			; 00000100H
  00121	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  00126	83 c4 08	 add	 esp, 8
  00129	50		 push	 eax
  0012a	6a 20		 push	 32			; 00000020H
  0012c	8b 4d 14	 mov	 ecx, DWORD PTR _new_text_len$[ebp]
  0012f	c1 e1 02	 shl	 ecx, 2
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	8b 55 ec	 mov	 edx, DWORD PTR _text_len$[ebp]
  0013e	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]
  00142	50		 push	 eax
  00143	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00146	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00149	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize
$LN3@STB_TEXTED:

; 3219 :     }
; 3220 : 
; 3221 :     ImWchar* text = obj->TextW.Data;

  0014e	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00151	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00154	89 4d d4	 mov	 DWORD PTR _text$[ebp], ecx

; 3222 :     if (pos != text_len)

  00157	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0015a	3b 45 ec	 cmp	 eax, DWORD PTR _text_len$[ebp]
  0015d	74 2b		 je	 SHORT $LN5@STB_TEXTED

; 3223 :         memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));

  0015f	8b 45 ec	 mov	 eax, DWORD PTR _text_len$[ebp]
  00162	2b 45 0c	 sub	 eax, DWORD PTR _pos$[ebp]
  00165	d1 e0		 shl	 eax, 1
  00167	50		 push	 eax
  00168	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  0016b	8b 55 d4	 mov	 edx, DWORD PTR _text$[ebp]
  0016e	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00171	50		 push	 eax
  00172	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  00175	8b 55 d4	 mov	 edx, DWORD PTR _text$[ebp]
  00178	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0017b	8b 4d 14	 mov	 ecx, DWORD PTR _new_text_len$[ebp]
  0017e	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 _memmove
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@STB_TEXTED:

; 3224 :     memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

  0018a	8b 45 14	 mov	 eax, DWORD PTR _new_text_len$[ebp]
  0018d	d1 e0		 shl	 eax, 1
  0018f	50		 push	 eax
  00190	8b 4d 10	 mov	 ecx, DWORD PTR _new_text$[ebp]
  00193	51		 push	 ecx
  00194	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
  00197	8b 45 d4	 mov	 eax, DWORD PTR _text$[ebp]
  0019a	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0019d	51		 push	 ecx
  0019e	e8 00 00 00 00	 call	 _memcpy
  001a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3225 : 
; 3226 :     obj->CurLenW += new_text_len;

  001a6	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  001a9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ac	03 4d 14	 add	 ecx, DWORD PTR _new_text_len$[ebp]
  001af	8b 55 08	 mov	 edx, DWORD PTR _obj$[ebp]
  001b2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3227 :     obj->CurLenA += new_text_len_utf8;

  001b5	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  001b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001bb	03 4d e0	 add	 ecx, DWORD PTR _new_text_len_utf8$[ebp]
  001be	8b 55 08	 mov	 edx, DWORD PTR _obj$[ebp]
  001c1	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 3228 :     obj->TextW[obj->CurLenW] = '\0';

  001c4	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  001c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ca	51		 push	 ecx
  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  001ce	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001d1	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  001d6	33 d2		 xor	 edx, edx
  001d8	66 89 10	 mov	 WORD PTR [eax], dx

; 3229 : 
; 3230 :     return true;

  001db	b0 01		 mov	 al, 1
$LN1@STB_TEXTED:

; 3231 : }

  001dd	5f		 pop	 edi
  001de	5e		 pop	 esi
  001df	5b		 pop	 ebx
  001e0	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  001e6	3b ec		 cmp	 ebp, esp
  001e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c3		 ret	 0
?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPAUImGuiInputTextState@@HPBGH@Z ENDP ; ImStb::STB_TEXTEDIT_INSERTCHARS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPAUImGuiInputTextState@@HH@Z
_TEXT	SEGMENT
_c$1 = -32						; size = 2
_src$ = -20						; size = 4
_dst$ = -8						; size = 4
_obj$ = 8						; size = 4
_pos$ = 12						; size = 4
_n$ = 16						; size = 4
?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPAUImGuiInputTextState@@HH@Z PROC ; ImStb::STB_TEXTEDIT_DELETECHARS, COMDAT

; 3188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3189 :     ImWchar* dst = obj->TextW.Data + pos;

  00028	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  0002b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
  00031	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00034	89 45 f8	 mov	 DWORD PTR _dst$[ebp], eax

; 3190 : 
; 3191 :     // We maintain our buffer length in both UTF-8 and wchar formats
; 3192 :     obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);

  00037	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _dst$[ebp]
  0003d	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00040	52		 push	 edx
  00041	8b 45 f8	 mov	 eax, DWORD PTR _dst$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z ; ImTextCountUtf8BytesFromStr
  0004a	83 c4 08	 add	 esp, 8
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00050	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00053	2b d0		 sub	 edx, eax
  00055	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00058	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 3193 :     obj->CurLenW -= n;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	2b 4d 10	 sub	 ecx, DWORD PTR _n$[ebp]
  00064	8b 55 08	 mov	 edx, DWORD PTR _obj$[ebp]
  00067	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3194 : 
; 3195 :     // Offset remaining text (FIXME-OPT: Use memmove)
; 3196 :     const ImWchar* src = obj->TextW.Data + pos + n;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  0006d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00070	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp]
  00073	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00076	8b 4d 10	 mov	 ecx, DWORD PTR _n$[ebp]
  00079	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0007c	89 55 ec	 mov	 DWORD PTR _src$[ebp], edx
$LN2@STB_TEXTED:

; 3197 :     while (ImWchar c = *src++)

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _src$[ebp]
  00082	66 8b 08	 mov	 cx, WORD PTR [eax]
  00085	66 89 4d e0	 mov	 WORD PTR _c$1[ebp], cx
  00089	8b 55 ec	 mov	 edx, DWORD PTR _src$[ebp]
  0008c	83 c2 02	 add	 edx, 2
  0008f	89 55 ec	 mov	 DWORD PTR _src$[ebp], edx
  00092	0f b7 45 e0	 movzx	 eax, WORD PTR _c$1[ebp]
  00096	85 c0		 test	 eax, eax
  00098	74 15		 je	 SHORT $LN3@STB_TEXTED

; 3198 :         *dst++ = c;

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _dst$[ebp]
  0009d	66 8b 4d e0	 mov	 cx, WORD PTR _c$1[ebp]
  000a1	66 89 08	 mov	 WORD PTR [eax], cx
  000a4	8b 55 f8	 mov	 edx, DWORD PTR _dst$[ebp]
  000a7	83 c2 02	 add	 edx, 2
  000aa	89 55 f8	 mov	 DWORD PTR _dst$[ebp], edx
  000ad	eb d0		 jmp	 SHORT $LN2@STB_TEXTED
$LN3@STB_TEXTED:

; 3199 :     *dst = '\0';

  000af	33 c0		 xor	 eax, eax
  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _dst$[ebp]
  000b4	66 89 01	 mov	 WORD PTR [ecx], ax

; 3200 : }

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000c0	3b ec		 cmp	 ebp, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPAUImGuiInputTextState@@HH@Z ENDP ; ImStb::STB_TEXTEDIT_DELETECHARS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
tv73 = -208						; size = 4
_len$ = -8						; size = 4
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL, COMDAT

; 3182 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 0c	 mov	 DWORD PTR _idx$[ebp], eax
  00031	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00037	89 4d f8	 mov	 DWORD PTR _len$[ebp], ecx
$LN2@STB_TEXTED:
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  0003d	3b 45 f8	 cmp	 eax, DWORD PTR _len$[ebp]
  00040	7d 1f		 jge	 SHORT $LN3@STB_TEXTED
  00042	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?is_word_boundary_from_right@ImStb@@YAHPAUImGuiInputTextState@@H@Z ; ImStb::is_word_boundary_from_right
  0004f	83 c4 08	 add	 esp, 8
  00052	85 c0		 test	 eax, eax
  00054	75 0b		 jne	 SHORT $LN3@STB_TEXTED
  00056	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00059	83 c0 01	 add	 eax, 1
  0005c	89 45 0c	 mov	 DWORD PTR _idx$[ebp], eax
  0005f	eb d9		 jmp	 SHORT $LN2@STB_TEXTED
$LN3@STB_TEXTED:
  00061	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00064	3b 45 f8	 cmp	 eax, DWORD PTR _len$[ebp]
  00067	7e 0b		 jle	 SHORT $LN5@STB_TEXTED
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0006c	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  00072	eb 09		 jmp	 SHORT $LN6@STB_TEXTED
$LN5@STB_TEXTED:
  00074	8b 55 0c	 mov	 edx, DWORD PTR _idx$[ebp]
  00077	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], edx
$LN6@STB_TEXTED:
  0007d	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
tv72 = -196						; size = 4
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL, COMDAT

; 3177 : static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  0002b	83 e8 01	 sub	 eax, 1
  0002e	89 45 0c	 mov	 DWORD PTR _idx$[ebp], eax
$LN2@STB_TEXTED:
  00031	83 7d 0c 00	 cmp	 DWORD PTR _idx$[ebp], 0
  00035	7c 1f		 jl	 SHORT $LN3@STB_TEXTED
  00037	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?is_word_boundary_from_right@ImStb@@YAHPAUImGuiInputTextState@@H@Z ; ImStb::is_word_boundary_from_right
  00044	83 c4 08	 add	 esp, 8
  00047	85 c0		 test	 eax, eax
  00049	75 0b		 jne	 SHORT $LN3@STB_TEXTED
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  0004e	83 e8 01	 sub	 eax, 1
  00051	89 45 0c	 mov	 DWORD PTR _idx$[ebp], eax
  00054	eb db		 jmp	 SHORT $LN2@STB_TEXTED
$LN3@STB_TEXTED:
  00056	83 7d 0c 00	 cmp	 DWORD PTR _idx$[ebp], 0
  0005a	7d 0c		 jge	 SHORT $LN5@STB_TEXTED
  0005c	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
  00066	eb 09		 jmp	 SHORT $LN6@STB_TEXTED
$LN5@STB_TEXTED:
  00068	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  0006b	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN6@STB_TEXTED:
  00071	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?is_word_boundary_from_right@ImStb@@YAHPAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
tv85 = -200						; size = 4
tv84 = -196						; size = 4
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?is_word_boundary_from_right@ImStb@@YAHPAUImGuiInputTextState@@H@Z PROC ; ImStb::is_word_boundary_from_right, COMDAT

; 3176 : static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 0c 00	 cmp	 DWORD PTR _idx$[ebp], 0
  0002c	7e 6b		 jle	 SHORT $LN5@is_word_bo
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00031	83 e8 01	 sub	 eax, 1
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00038	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003b	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  00040	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ?is_separator@ImStb@@YA_NI@Z ; ImStb::is_separator
  00049	83 c4 04	 add	 esp, 4
  0004c	0f b6 d0	 movzx	 edx, al
  0004f	85 d2		 test	 edx, edx
  00051	74 2e		 je	 SHORT $LN3@is_word_bo
  00053	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  0005a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005d	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  00062	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?is_separator@ImStb@@YA_NI@Z ; ImStb::is_separator
  0006b	83 c4 04	 add	 esp, 4
  0006e	0f b6 d0	 movzx	 edx, al
  00071	85 d2		 test	 edx, edx
  00073	75 0c		 jne	 SHORT $LN3@is_word_bo
  00075	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv84[ebp], 1
  0007f	eb 0a		 jmp	 SHORT $LN4@is_word_bo
$LN3@is_word_bo:
  00081	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN4@is_word_bo:
  0008b	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
  00091	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  00097	eb 0a		 jmp	 SHORT $LN6@is_word_bo
$LN5@is_word_bo:
  00099	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv85[ebp], 1
$LN6@is_word_bo:
  000a3	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv85[ebp]
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?is_word_boundary_from_right@ImStb@@YAHPAUImGuiInputTextState@@H@Z ENDP ; ImStb::is_word_boundary_from_right
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?is_separator@ImStb@@YA_NI@Z
_TEXT	SEGMENT
tv77 = -196						; size = 4
_c$ = 8							; size = 4
?is_separator@ImStb@@YA_NI@Z PROC			; ImStb::is_separator, COMDAT

; 3175 : static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?ImCharIsBlankW@@YA_NI@Z ; ImCharIsBlankW
  00031	83 c4 04	 add	 esp, 4
  00034	0f b6 c8	 movzx	 ecx, al
  00037	85 c9		 test	 ecx, ecx
  00039	75 42		 jne	 SHORT $LN3@is_separat
  0003b	83 7d 08 2c	 cmp	 DWORD PTR _c$[ebp], 44	; 0000002cH
  0003f	74 3c		 je	 SHORT $LN3@is_separat
  00041	83 7d 08 3b	 cmp	 DWORD PTR _c$[ebp], 59	; 0000003bH
  00045	74 36		 je	 SHORT $LN3@is_separat
  00047	83 7d 08 28	 cmp	 DWORD PTR _c$[ebp], 40	; 00000028H
  0004b	74 30		 je	 SHORT $LN3@is_separat
  0004d	83 7d 08 29	 cmp	 DWORD PTR _c$[ebp], 41	; 00000029H
  00051	74 2a		 je	 SHORT $LN3@is_separat
  00053	83 7d 08 7b	 cmp	 DWORD PTR _c$[ebp], 123	; 0000007bH
  00057	74 24		 je	 SHORT $LN3@is_separat
  00059	83 7d 08 7d	 cmp	 DWORD PTR _c$[ebp], 125	; 0000007dH
  0005d	74 1e		 je	 SHORT $LN3@is_separat
  0005f	83 7d 08 5b	 cmp	 DWORD PTR _c$[ebp], 91	; 0000005bH
  00063	74 18		 je	 SHORT $LN3@is_separat
  00065	83 7d 08 5d	 cmp	 DWORD PTR _c$[ebp], 93	; 0000005dH
  00069	74 12		 je	 SHORT $LN3@is_separat
  0006b	83 7d 08 7c	 cmp	 DWORD PTR _c$[ebp], 124	; 0000007cH
  0006f	74 0c		 je	 SHORT $LN3@is_separat
  00071	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
  0007b	eb 0a		 jmp	 SHORT $LN4@is_separat
$LN3@is_separat:
  0007d	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv77[ebp], 1
$LN4@is_separat:
  00087	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv77[ebp]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00096	3b ec		 cmp	 ebp, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?is_separator@ImStb@@YA_NI@Z ENDP			; ImStb::is_separator
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
_size$ = -40						; size = 8
_text_remaining$ = -24					; size = 4
_text$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_r$ = 8							; size = 4
_obj$ = 12						; size = 4
_line_start_idx$ = 16					; size = 4
?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_LAYOUTROW, COMDAT

; 3163 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3164 :     const ImWchar* text = obj->TextW.Data;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _obj$[ebp]
  00035	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00038	89 4d f4	 mov	 DWORD PTR _text$[ebp], ecx

; 3165 :     const ImWchar* text_remaining = NULL;

  0003b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _text_remaining$[ebp], 0

; 3166 :     const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);

  00042	6a 01		 push	 1
  00044	6a 00		 push	 0
  00046	8d 45 e8	 lea	 eax, DWORD PTR _text_remaining$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _obj$[ebp]
  0004d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00050	8b 45 f4	 mov	 eax, DWORD PTR _text$[ebp]
  00053	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00056	51		 push	 ecx
  00057	8b 55 10	 mov	 edx, DWORD PTR _line_start_idx$[ebp]
  0005a	8b 45 f4	 mov	 eax, DWORD PTR _text$[ebp]
  0005d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00060	51		 push	 ecx
  00061	8d 55 d8	 lea	 edx, DWORD PTR _size$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW
  0006a	83 c4 18	 add	 esp, 24			; 00000018H

; 3167 :     r->x0 = 0.0f;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 3168 :     r->x1 = size.x;

  00077	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0007a	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _size$[ebp]
  0007f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 3169 :     r->baseline_y_delta = size.y;

  00084	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00087	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  0008c	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 3170 :     r->ymin = 0.0f;

  00091	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00094	0f 57 c0	 xorps	 xmm0, xmm0
  00097	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 3171 :     r->ymax = size.y;

  0009c	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  0009f	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  000a4	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 3172 :     r->num_chars = (int)(text_remaining - (text + line_start_idx));

  000a9	8b 45 10	 mov	 eax, DWORD PTR _line_start_idx$[ebp]
  000ac	8b 4d f4	 mov	 ecx, DWORD PTR _text$[ebp]
  000af	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000b2	8b 45 e8	 mov	 eax, DWORD PTR _text_remaining$[ebp]
  000b5	2b c2		 sub	 eax, edx
  000b7	d1 f8		 sar	 eax, 1
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  000bc	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 3173 : }

  000bf	52		 push	 edx
  000c0	8b cd		 mov	 ecx, ebp
  000c2	50		 push	 eax
  000c3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@STB_TEXTED
  000c9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ce	58		 pop	 eax
  000cf	5a		 pop	 edx
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  000e3	3b ec		 cmp	 ebp, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
  000ee	66 90		 npad	 2
$LN6@STB_TEXTED:
  000f0	02 00 00 00	 DD	 2
  000f4	00 00 00 00	 DD	 $LN5@STB_TEXTED
$LN5@STB_TEXTED:
  000f8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000fc	04 00 00 00	 DD	 4
  00100	00 00 00 00	 DD	 $LN3@STB_TEXTED
  00104	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00108	08 00 00 00	 DD	 8
  0010c	00 00 00 00	 DD	 $LN4@STB_TEXTED
$LN4@STB_TEXTED:
  00110	73		 DB	 115			; 00000073H
  00111	69		 DB	 105			; 00000069H
  00112	7a		 DB	 122			; 0000007aH
  00113	65		 DB	 101			; 00000065H
  00114	00		 DB	 0
$LN3@STB_TEXTED:
  00115	74		 DB	 116			; 00000074H
  00116	65		 DB	 101			; 00000065H
  00117	78		 DB	 120			; 00000078H
  00118	74		 DB	 116			; 00000074H
  00119	5f		 DB	 95			; 0000005fH
  0011a	72		 DB	 114			; 00000072H
  0011b	65		 DB	 101			; 00000065H
  0011c	6d		 DB	 109			; 0000006dH
  0011d	61		 DB	 97			; 00000061H
  0011e	69		 DB	 105			; 00000069H
  0011f	6e		 DB	 110			; 0000006eH
  00120	69		 DB	 105			; 00000069H
  00121	6e		 DB	 110			; 0000006eH
  00122	67		 DB	 103			; 00000067H
  00123	00		 DB	 0
?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPAUStbTexteditRow@1@PAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_LAYOUTROW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_KEYTOTEXT@ImStb@@YAHH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_key$ = 8						; size = 4
?STB_TEXTEDIT_KEYTOTEXT@ImStb@@YAHH@Z PROC		; ImStb::STB_TEXTEDIT_KEYTOTEXT, COMDAT

; 3160 : static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x200000 ? 0 : key; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	81 7d 08 00 00
	20 00		 cmp	 DWORD PTR _key$[ebp], 2097152 ; 00200000H
  0002f	7c 0c		 jl	 SHORT $LN3@STB_TEXTED
  00031	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@STB_TEXTED
$LN3@STB_TEXTED:
  0003d	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00040	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
$LN4@STB_TEXTED:
  00046	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?STB_TEXTEDIT_KEYTOTEXT@ImStb@@YAHH@Z ENDP		; ImStb::STB_TEXTEDIT_KEYTOTEXT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPAUImGuiInputTextState@@HH@Z
_TEXT	SEGMENT
tv132 = -224						; size = 4
tv95 = -220						; size = 4
_g$ = -20						; size = 4
_c$ = -8						; size = 2
_obj$ = 8						; size = 4
_line_start_idx$ = 12					; size = 4
_char_idx$ = 16						; size = 4
?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPAUImGuiInputTextState@@HH@Z PROC ; ImStb::STB_TEXTEDIT_GETWIDTH, COMDAT

; 3159 : static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *GImGui; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _line_start_idx$[ebp]
  0002b	03 45 10	 add	 eax, DWORD PTR _char_idx$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00032	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00035	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  0003a	66 8b 08	 mov	 cx, WORD PTR [eax]
  0003d	66 89 4d f8	 mov	 WORD PTR _c$[ebp], cx
  00041	0f b7 45 f8	 movzx	 eax, WORD PTR _c$[ebp]
  00045	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00048	75 08		 jne	 SHORT $LN2@STB_TEXTED
  0004a	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@bf800000
  00050	eb 54		 jmp	 SHORT $LN1@STB_TEXTED
$LN2@STB_TEXTED:
  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00057	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax
  0005a	0f b7 45 f8	 movzx	 eax, WORD PTR _c$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  00062	8b 89 c0 18 00
	00		 mov	 ecx, DWORD PTR [ecx+6336]
  00068	e8 00 00 00 00	 call	 ?GetCharAdvance@ImFont@@QBEMG@Z ; ImFont::GetCharAdvance
  0006d	d9 9d 24 ff ff
	ff		 fstp	 DWORD PTR tv95[ebp]
  00073	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv95[ebp]
  0007b	8b 55 ec	 mov	 edx, DWORD PTR _g$[ebp]
  0007e	8b 82 c0 18 00
	00		 mov	 eax, DWORD PTR [edx+6336]
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  00087	f3 0f 10 89 c4
	18 00 00	 movss	 xmm1, DWORD PTR [ecx+6340]
  0008f	f3 0f 5e 48 10	 divss	 xmm1, DWORD PTR [eax+16]
  00094	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00098	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR tv132[ebp], xmm0
  000a0	d9 85 20 ff ff
	ff		 fld	 DWORD PTR tv132[ebp]
$LN1@STB_TEXTED:
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPAUImGuiInputTextState@@HH@Z ENDP ; ImStb::STB_TEXTEDIT_GETWIDTH
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_GETCHAR, COMDAT

; 3158 : static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  0002f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00032	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QBEABGH@Z ; ImVector<unsigned short>::operator[]
  00037	66 8b 00	 mov	 ax, WORD PTR [eax]
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPBUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_GETCHAR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z PROC ; ImStb::STB_TEXTEDIT_STRINGLEN, COMDAT

; 3157 : static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPBUImGuiInputTextState@@@Z ENDP ; ImStb::STB_TEXTEDIT_STRINGLEN
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$ImAtoi@H@@YAPBDPBDPAH@Z
_TEXT	SEGMENT
tv81 = -220						; size = 4
_v$ = -20						; size = 4
_negative$ = -8						; size = 4
_src$ = 8						; size = 4
_output$ = 12						; size = 4
??$ImAtoi@H@@YAPBDPBDPAH@Z PROC				; ImAtoi<int>, COMDAT

; 1870 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1871 :     int negative = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 0

; 1872 :     if (*src == '-') { negative = 1; src++; }

  0002f	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00038	75 10		 jne	 SHORT $LN4@ImAtoi
  0003a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _negative$[ebp], 1
  00041	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN4@ImAtoi:

; 1873 :     if (*src == '+') { src++; }

  0004a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0004d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00050	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00053	75 09		 jne	 SHORT $LN5@ImAtoi
  00055	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
$LN5@ImAtoi:

; 1874 :     TYPE v = 0;

  0005e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0
$LN2@ImAtoi:

; 1875 :     while (*src >= '0' && *src <= '9')

  00065	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00068	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006b	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0006e	7c 27		 jl	 SHORT $LN3@ImAtoi
  00070	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00073	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00076	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00079	7f 1c		 jg	 SHORT $LN3@ImAtoi

; 1876 :         v = (v * 10) + (*src++ - '0');

  0007b	6b 45 ec 0a	 imul	 eax, DWORD PTR _v$[ebp], 10
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00082	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00085	8d 44 10 d0	 lea	 eax, DWORD PTR [eax+edx-48]
  00089	89 45 ec	 mov	 DWORD PTR _v$[ebp], eax
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0008f	83 c1 01	 add	 ecx, 1
  00092	89 4d 08	 mov	 DWORD PTR _src$[ebp], ecx
  00095	eb ce		 jmp	 SHORT $LN2@ImAtoi
$LN3@ImAtoi:

; 1877 :     *output = negative ? -v : v;

  00097	83 7d f8 00	 cmp	 DWORD PTR _negative$[ebp], 0
  0009b	74 0d		 je	 SHORT $LN7@ImAtoi
  0009d	8b 45 ec	 mov	 eax, DWORD PTR _v$[ebp]
  000a0	f7 d8		 neg	 eax
  000a2	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  000a8	eb 09		 jmp	 SHORT $LN8@ImAtoi
$LN7@ImAtoi:
  000aa	8b 4d ec	 mov	 ecx, DWORD PTR _v$[ebp]
  000ad	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
$LN8@ImAtoi:
  000b3	8b 55 0c	 mov	 edx, DWORD PTR _output$[ebp]
  000b6	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  000bc	89 02		 mov	 DWORD PTR [edx], eax

; 1878 :     return src;

  000be	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]

; 1879 : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000ca	3b ec		 cmp	 ebp, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
??$ImAtoi@H@@YAPBDPBDPAH@Z ENDP				; ImAtoi<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMin@I@@YAIII@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMin@I@@YAIII@Z PROC				; ImMin<unsigned int>, COMDAT

; 314  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _rhs$[ebp]
  0002e	73 0b		 jae	 SHORT $LN3@ImMin
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00033	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00039	eb 09		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _rhs$[ebp]
  0003e	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
$LN4@ImMin:
  00044	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImMin@I@@YAIII@Z ENDP				; ImMin<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@NNN@ImGui@@YA_NABUImRect@@IHPANNNPBDMHPAU1@@Z
_TEXT	SEGMENT
tv469 = -672						; size = 4
tv775 = -668						; size = 4
tv170 = -668						; size = 8
tv162 = -668						; size = 8
tv89 = -668						; size = 8
tv633 = -664						; size = 4
tv502 = -664						; size = 4
tv495 = -664						; size = 4
tv464 = -664						; size = 4
tv280 = -664						; size = 4
tv263 = -664						; size = 4
tv212 = -664						; size = 4
tv200 = -664						; size = 4
tv177 = -664						; size = 4
tv67 = -664						; size = 4
tv74 = -661						; size = 1
tv70 = -661						; size = 1
$T1 = -656						; size = 16
$T2 = -632						; size = 16
$T3 = -608						; size = 16
_grab_pos$4 = -392					; size = 4
_grab_t$5 = -380					; size = 4
_v_new_off_round$6 = -368				; size = 8
_v_new_off_floor$7 = -352				; size = 8
_v_new_off_f$8 = -336					; size = 8
_a$9 = -320						; size = 4
_a$10 = -308						; size = 4
_v_new$11 = -296					; size = 8
_decimal_precision$12 = -280				; size = 4
_delta$13 = -268					; size = 4
_delta2$14 = -256					; size = 8
_mouse_abs_pos$15 = -240				; size = 4
_clicked_t$16 = -228					; size = 4
_set_new_value$17 = -213				; size = 1
_value_changed$ = -201					; size = 1
_linear_dist_max_to_0$18 = -192				; size = 8
_linear_dist_min_to_0$19 = -176				; size = 8
_linear_zero_pos$ = -160				; size = 4
_slider_usable_pos_max$ = -148				; size = 4
_slider_usable_pos_min$ = -136				; size = 4
_slider_usable_sz$ = -124				; size = 4
_v_range$ = -112					; size = 8
_grab_sz$ = -96						; size = 4
_slider_sz$ = -84					; size = 4
_grab_padding$ = -72					; size = 4
_is_power$ = -57					; size = 1
_is_decimal$ = -45					; size = 1
_axis$ = -36						; size = 4
_style$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_data_type$ = 16					; size = 4
_v$ = 20						; size = 4
_v_min$ = 24						; size = 8
_v_max$ = 32						; size = 8
_format$ = 40						; size = 4
_power$ = 44						; size = 4
_flags$ = 48						; size = 4
_out_grab_bb$ = 52					; size = 4
??$SliderBehaviorT@NNN@ImGui@@YA_NABUImRect@@IHPANNNPBDMHPAU1@@Z PROC ; ImGui::SliderBehaviorT<double,double,double>, COMDAT

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 02 00
	00		 sub	 esp, 672		; 000002a0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 60 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-672]
  00012	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2310 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2311 :     const ImGuiStyle& style = g.Style;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00042	89 45 e8	 mov	 DWORD PTR _style$[ebp], eax

; 2312 : 
; 2313 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00045	8b 45 30	 mov	 eax, DWORD PTR _flags$[ebp]
  00048	83 e0 01	 and	 eax, 1
  0004b	74 0c		 je	 SHORT $LN46@SliderBeha
  0004d	c7 85 68 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00057	eb 0a		 jmp	 SHORT $LN47@SliderBeha
$LN46@SliderBeha:
  00059	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN47@SliderBeha:
  00063	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  00069	89 4d dc	 mov	 DWORD PTR _axis$[ebp], ecx

; 2314 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  0006c	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00070	74 0f		 je	 SHORT $LN48@SliderBeha
  00072	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00076	74 09		 je	 SHORT $LN48@SliderBeha
  00078	c6 85 6b fd ff
	ff 00		 mov	 BYTE PTR tv70[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN49@SliderBeha
$LN48@SliderBeha:
  00081	c6 85 6b fd ff
	ff 01		 mov	 BYTE PTR tv70[ebp], 1
$LN49@SliderBeha:
  00088	8a 85 6b fd ff
	ff		 mov	 al, BYTE PTR tv70[ebp]
  0008e	88 45 d3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 2315 :     const bool is_power = (power != 1.0f) && is_decimal;

  00091	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00096	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0009d	9f		 lahf
  0009e	f6 c4 44	 test	 ah, 68			; 00000044H
  000a1	7b 11		 jnp	 SHORT $LN50@SliderBeha
  000a3	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN50@SliderBeha
  000ab	c6 85 6b fd ff
	ff 01		 mov	 BYTE PTR tv74[ebp], 1
  000b2	eb 07		 jmp	 SHORT $LN51@SliderBeha
$LN50@SliderBeha:
  000b4	c6 85 6b fd ff
	ff 00		 mov	 BYTE PTR tv74[ebp], 0
$LN51@SliderBeha:
  000bb	8a 8d 6b fd ff
	ff		 mov	 cl, BYTE PTR tv74[ebp]
  000c1	88 4d c7	 mov	 BYTE PTR _is_power$[ebp], cl

; 2316 : 
; 2317 :     const float grab_padding = 2.0f;

  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000cc	f3 0f 11 45 b8	 movss	 DWORD PTR _grab_padding$[ebp], xmm0

; 2318 :     const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

  000d1	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000d8	83 c1 08	 add	 ecx, 8
  000db	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  000e0	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv464[ebp]
  000e6	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv464[ebp]
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _axis$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000f5	f3 0f 11 85 64
	fd ff ff	 movss	 DWORD PTR tv775[ebp], xmm0
  000fd	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00102	d9 9d 60 fd ff
	ff		 fstp	 DWORD PTR tv469[ebp]
  00108	f3 0f 10 85 64
	fd ff ff	 movss	 xmm0, DWORD PTR tv775[ebp]
  00110	f3 0f 5c 85 60
	fd ff ff	 subss	 xmm0, DWORD PTR tv469[ebp]
  00118	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00120	f3 0f 11 45 ac	 movss	 DWORD PTR _slider_sz$[ebp], xmm0

; 2319 :     float grab_sz = style.GrabMinSize;

  00125	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  00128	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  0012d	f3 0f 11 45 a0	 movss	 DWORD PTR _grab_sz$[ebp], xmm0

; 2320 :     SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

  00132	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00137	66 0f 2f 45 18	 comisd	 xmm0, QWORD PTR _v_min$[ebp]
  0013c	76 14		 jbe	 SHORT $LN52@SliderBeha
  0013e	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00143	f2 0f 5c 45 18	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  00148	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv89[ebp], xmm0
  00150	eb 12		 jmp	 SHORT $LN53@SliderBeha
$LN52@SliderBeha:
  00152	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  00157	f2 0f 5c 45 20	 subsd	 xmm0, QWORD PTR _v_max$[ebp]
  0015c	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv89[ebp], xmm0
$LN53@SliderBeha:
  00164	f2 0f 10 85 64
	fd ff ff	 movsd	 xmm0, QWORD PTR tv89[ebp]
  0016c	f2 0f 11 45 90	 movsd	 QWORD PTR _v_range$[ebp], xmm0

; 2321 :     if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

  00171	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00175	85 c0		 test	 eax, eax
  00177	75 48		 jne	 SHORT $LN2@SliderBeha
  00179	f2 0f 10 45 90	 movsd	 xmm0, QWORD PTR _v_range$[ebp]
  0017e	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00186	72 39		 jb	 SHORT $LN2@SliderBeha

; 2322 :         grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

  00188	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  0018b	51		 push	 ecx
  0018c	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  00191	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00196	f3 0f 5a 45 ac	 cvtss2sd xmm0, DWORD PTR _slider_sz$[ebp]
  0019b	f2 0f 10 4d 90	 movsd	 xmm1, QWORD PTR _v_range$[ebp]
  001a0	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@3ff0000000000000
  001a8	f2 0f 5e c1	 divsd	 xmm0, xmm1
  001ac	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001b0	51		 push	 ecx
  001b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b6	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001bb	83 c4 08	 add	 esp, 8
  001be	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]
$LN2@SliderBeha:

; 2323 :     grab_sz = ImMin(grab_sz, slider_sz);

  001c1	51		 push	 ecx
  001c2	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001cc	51		 push	 ecx
  001cd	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d7	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001dc	83 c4 08	 add	 esp, 8
  001df	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]

; 2324 :     const float slider_usable_sz = slider_sz - grab_sz;

  001e2	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001e7	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001ec	f3 0f 11 45 84	 movss	 DWORD PTR _slider_usable_sz$[ebp], xmm0

; 2325 :     const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

  001f1	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  001f4	50		 push	 eax
  001f5	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  001f8	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  001fd	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv495[ebp]
  00203	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv495[ebp]
  0020b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00213	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00218	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  00220	f3 0f 58 c1	 addss	 xmm0, xmm1
  00224	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_min$[ebp], xmm0

; 2326 :     const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

  0022c	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  0022f	50		 push	 eax
  00230	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00233	83 c1 08	 add	 ecx, 8
  00236	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  0023b	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv502[ebp]
  00241	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv502[ebp]
  00249	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00251	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00256	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0025e	f3 0f 5c c1	 subss	 xmm0, xmm1
  00262	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_max$[ebp], xmm0

; 2327 : 
; 2328 :     // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2329 :     float linear_zero_pos;   // 0.0->1.0f
; 2330 :     if (is_power && v_min * v_max < 0.0f)

  0026a	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0026e	85 c0		 test	 eax, eax
  00270	0f 84 13 01 00
	00		 je	 $LN3@SliderBeha
  00276	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  0027b	f2 0f 59 45 20	 mulsd	 xmm0, QWORD PTR _v_max$[ebp]
  00280	0f 57 c9	 xorps	 xmm1, xmm1
  00283	66 0f 2f c8	 comisd	 xmm1, xmm0
  00287	0f 86 fc 00 00
	00		 jbe	 $LN3@SliderBeha

; 2331 :     {
; 2332 :         // Different sign
; 2333 :         const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

  0028d	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  00292	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0029a	72 0f		 jb	 SHORT $LN54@SliderBeha
  0029c	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  002a1	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv162[ebp], xmm0
  002a9	eb 14		 jmp	 SHORT $LN55@SliderBeha
$LN54@SliderBeha:
  002ab	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  002b0	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  002b7	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv162[ebp], xmm0
$LN55@SliderBeha:
  002bf	f3 0f 5a 45 2c	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  002c4	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  002cc	f2 0f 5e c8	 divsd	 xmm1, xmm0
  002d0	83 ec 08	 sub	 esp, 8
  002d3	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  002d8	83 ec 08	 sub	 esp, 8
  002db	f2 0f 10 85 64
	fd ff ff	 movsd	 xmm0, QWORD PTR tv162[ebp]
  002e3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002e8	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  002ed	83 c4 10	 add	 esp, 16			; 00000010H
  002f0	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _linear_dist_min_to_0$19[ebp]

; 2334 :         const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

  002f6	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  002fb	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00303	72 0f		 jb	 SHORT $LN56@SliderBeha
  00305	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  0030a	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv170[ebp], xmm0
  00312	eb 14		 jmp	 SHORT $LN57@SliderBeha
$LN56@SliderBeha:
  00314	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00319	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  00320	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv170[ebp], xmm0
$LN57@SliderBeha:
  00328	f3 0f 5a 45 2c	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  0032d	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00335	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00339	83 ec 08	 sub	 esp, 8
  0033c	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00341	83 ec 08	 sub	 esp, 8
  00344	f2 0f 10 85 64
	fd ff ff	 movsd	 xmm0, QWORD PTR tv170[ebp]
  0034c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00351	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00356	83 c4 10	 add	 esp, 16			; 00000010H
  00359	dd 9d 40 ff ff
	ff		 fstp	 QWORD PTR _linear_dist_max_to_0$18[ebp]

; 2335 :         linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

  0035f	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR _linear_dist_min_to_0$19[ebp]
  00367	f2 0f 58 85 40
	ff ff ff	 addsd	 xmm0, QWORD PTR _linear_dist_max_to_0$18[ebp]
  0036f	f2 0f 10 8d 50
	ff ff ff	 movsd	 xmm1, QWORD PTR _linear_dist_min_to_0$19[ebp]
  00377	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0037b	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  0037f	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0

; 2336 :     }

  00387	eb 37		 jmp	 SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2337 :     else
; 2338 :     {
; 2339 :         // Same sign
; 2340 :         linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

  00389	0f 57 c0	 xorps	 xmm0, xmm0
  0038c	66 0f 2f 45 18	 comisd	 xmm0, QWORD PTR _v_min$[ebp]
  00391	76 12		 jbe	 SHORT $LN58@SliderBeha
  00393	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0039b	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv177[ebp], xmm0
  003a3	eb 0b		 jmp	 SHORT $LN59@SliderBeha
$LN58@SliderBeha:
  003a5	0f 57 c0	 xorps	 xmm0, xmm0
  003a8	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv177[ebp], xmm0
$LN59@SliderBeha:
  003b0	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv177[ebp]
  003b8	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0
$LN4@SliderBeha:

; 2341 :     }
; 2342 : 
; 2343 :     // Process interacting with the slider
; 2344 :     bool value_changed = false;

  003c0	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 2345 :     if (g.ActiveId == id)

  003c7	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  003ca	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  003d0	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  003d3	0f 85 7e 06 00
	00		 jne	 $LN39@SliderBeha

; 2346 :     {
; 2347 :         bool set_new_value = false;

  003d9	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0

; 2348 :         float clicked_t = 0.0f;

  003e0	0f 57 c0	 xorps	 xmm0, xmm0
  003e3	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2349 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

  003eb	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  003ee	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  003f5	0f 85 d4 00 00
	00		 jne	 $LN6@SliderBeha

; 2350 :         {
; 2351 :             if (!g.IO.MouseDown[0])

  003fb	b8 01 00 00 00	 mov	 eax, 1
  00400	6b c8 00	 imul	 ecx, eax, 0
  00403	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00406	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  0040e	85 c0		 test	 eax, eax
  00410	75 0a		 jne	 SHORT $LN8@SliderBeha

; 2352 :             {
; 2353 :                 ClearActiveID();

  00412	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2354 :             }

  00417	e9 ae 00 00 00	 jmp	 $LN9@SliderBeha
$LN8@SliderBeha:

; 2355 :             else
; 2356 :             {
; 2357 :                 const float mouse_abs_pos = g.IO.MousePos[axis];

  0041c	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  0041f	50		 push	 eax
  00420	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00423	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  00429	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  0042e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00432	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _mouse_abs_pos$15[ebp], xmm0

; 2358 :                 clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

  0043a	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  0043f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00446	76 42		 jbe	 SHORT $LN60@SliderBeha
  00448	51		 push	 ecx
  00449	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00451	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00456	51		 push	 ecx
  00457	0f 57 c0	 xorps	 xmm0, xmm0
  0045a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0045f	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_abs_pos$15[ebp]
  00467	f3 0f 5c 85 78
	ff ff ff	 subss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  0046f	f3 0f 5e 45 84	 divss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  00474	51		 push	 ecx
  00475	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0047a	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  0047f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00482	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv200[ebp]
  00488	eb 0b		 jmp	 SHORT $LN61@SliderBeha
$LN60@SliderBeha:
  0048a	0f 57 c0	 xorps	 xmm0, xmm0
  0048d	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv200[ebp], xmm0
$LN61@SliderBeha:
  00495	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv200[ebp]
  0049d	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2359 :                 if (axis == ImGuiAxis_Y)

  004a5	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  004a9	75 18		 jne	 SHORT $LN10@SliderBeha

; 2360 :                     clicked_t = 1.0f - clicked_t;

  004ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004b3	f3 0f 5c 85 1c
	ff ff ff	 subss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  004bb	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0
$LN10@SliderBeha:

; 2361 :                 set_new_value = true;

  004c3	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1
$LN9@SliderBeha:

; 2362 :             }
; 2363 :         }

  004ca	e9 b9 02 00 00	 jmp	 $LN25@SliderBeha
$LN6@SliderBeha:

; 2364 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  004cf	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  004d2	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  004d9	0f 85 a9 02 00
	00		 jne	 $LN25@SliderBeha

; 2365 :         {
; 2366 :             const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

  004df	51		 push	 ecx
  004e0	0f 57 c0	 xorps	 xmm0, xmm0
  004e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e8	51		 push	 ecx
  004e9	0f 57 c0	 xorps	 xmm0, xmm0
  004ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004f1	6a 05		 push	 5
  004f3	6a 03		 push	 3
  004f5	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _delta2$14[ebp]
  004fb	50		 push	 eax
  004fc	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  00501	83 c4 14	 add	 esp, 20			; 00000014H

; 2367 :             float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

  00504	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00508	75 12		 jne	 SHORT $LN62@SliderBeha
  0050a	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp]
  00512	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv212[ebp], xmm0
  0051a	eb 17		 jmp	 SHORT $LN63@SliderBeha
$LN62@SliderBeha:
  0051c	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp+4]
  00524	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0052b	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv212[ebp], xmm0
$LN63@SliderBeha:
  00533	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv212[ebp]
  0053b	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2368 :             if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

  00543	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00546	8b 88 e0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6880]
  0054c	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0054f	75 18		 jne	 SHORT $LN12@SliderBeha
  00551	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00554	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  0055b	85 c9		 test	 ecx, ecx
  0055d	75 0a		 jne	 SHORT $LN12@SliderBeha

; 2369 :             {
; 2370 :                 ClearActiveID();

  0055f	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2371 :             }

  00564	e9 1f 02 00 00	 jmp	 $LN25@SliderBeha
$LN12@SliderBeha:

; 2372 :             else if (delta != 0.0f)

  00569	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00571	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00578	9f		 lahf
  00579	f6 c4 44	 test	 ah, 68			; 00000044H
  0057c	0f 8b 06 02 00
	00		 jnp	 $LN25@SliderBeha

; 2373 :             {
; 2374 :                 clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  00582	51		 push	 ecx
  00583	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0058b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00590	51		 push	 ecx
  00591	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00596	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0059b	83 ec 08	 sub	 esp, 8
  0059e	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  005a3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005a8	83 ec 08	 sub	 esp, 8
  005ab	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  005b0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005b5	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  005b8	83 ec 08	 sub	 esp, 8
  005bb	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  005bf	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005c4	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  005c7	51		 push	 ecx
  005c8	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ; ImGui::SliderCalcRatioFromValueT<double,double>
  005cd	83 c4 24	 add	 esp, 36			; 00000024H
  005d0	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]

; 2375 :                 const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  005d6	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  005da	85 c0		 test	 eax, eax
  005dc	74 16		 je	 SHORT $LN64@SliderBeha
  005de	6a 03		 push	 3
  005e0	8b 4d 28	 mov	 ecx, DWORD PTR _format$[ebp]
  005e3	51		 push	 ecx
  005e4	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  005e9	83 c4 08	 add	 esp, 8
  005ec	89 85 68 fd ff
	ff		 mov	 DWORD PTR tv263[ebp], eax
  005f2	eb 0a		 jmp	 SHORT $LN65@SliderBeha
$LN64@SliderBeha:
  005f4	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv263[ebp], 0
$LN65@SliderBeha:
  005fe	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR tv263[ebp]
  00604	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _decimal_precision$12[ebp], edx

; 2376 :                 if ((decimal_precision > 0) || is_power)

  0060a	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _decimal_precision$12[ebp], 0
  00611	7f 08		 jg	 SHORT $LN17@SliderBeha
  00613	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00617	85 c0		 test	 eax, eax
  00619	74 46		 je	 SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2377 :                 {
; 2378 :                     delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

  0061b	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00623	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0062b	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2379 :                     if (IsNavInputDown(ImGuiNavInput_TweakSlow))

  00633	6a 0e		 push	 14			; 0000000eH
  00635	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  0063a	83 c4 04	 add	 esp, 4
  0063d	0f b6 c0	 movzx	 eax, al
  00640	85 c0		 test	 eax, eax
  00642	74 18		 je	 SHORT $LN18@SliderBeha

; 2380 :                         delta /= 10.0f;

  00644	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0064c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00654	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN18@SliderBeha:

; 2381 :                 }

  0065c	e9 90 00 00 00	 jmp	 $LN20@SliderBeha
$LN15@SliderBeha:

; 2382 :                 else
; 2383 :                 {
; 2384 :                     if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

  00661	f2 0f 10 45 90	 movsd	 xmm0, QWORD PTR _v_range$[ebp]
  00666	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@c059000000000000
  0066e	72 0f		 jb	 SHORT $LN22@SliderBeha
  00670	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4059000000000000
  00678	66 0f 2f 45 90	 comisd	 xmm0, QWORD PTR _v_range$[ebp]
  0067d	73 11		 jae	 SHORT $LN21@SliderBeha
$LN22@SliderBeha:
  0067f	6a 0e		 push	 14			; 0000000eH
  00681	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00686	83 c4 04	 add	 esp, 4
  00689	0f b6 c0	 movzx	 eax, al
  0068c	85 c0		 test	 eax, eax
  0068e	74 49		 je	 SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2385 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

  00690	0f 57 c0	 xorps	 xmm0, xmm0
  00693	0f 2f 85 f4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  0069a	76 12		 jbe	 SHORT $LN66@SliderBeha
  0069c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  006a4	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv280[ebp], xmm0
  006ac	eb 10		 jmp	 SHORT $LN67@SliderBeha
$LN66@SliderBeha:
  006ae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006b6	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv280[ebp], xmm0
$LN67@SliderBeha:
  006be	f2 0f 5a 45 90	 cvtsd2ss xmm0, QWORD PTR _v_range$[ebp]
  006c3	f3 0f 10 8d 68
	fd ff ff	 movss	 xmm1, DWORD PTR tv280[ebp]
  006cb	f3 0f 5e c8	 divss	 xmm1, xmm0
  006cf	f3 0f 11 8d f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm1
  006d7	eb 18		 jmp	 SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2386 :                     else
; 2387 :                         delta /= 100.0f;

  006d9	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  006e1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  006e9	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN20@SliderBeha:

; 2388 :                 }
; 2389 :                 if (IsNavInputDown(ImGuiNavInput_TweakFast))

  006f1	6a 0f		 push	 15			; 0000000fH
  006f3	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  006f8	83 c4 04	 add	 esp, 4
  006fb	0f b6 c0	 movzx	 eax, al
  006fe	85 c0		 test	 eax, eax
  00700	74 18		 je	 SHORT $LN23@SliderBeha

; 2390 :                     delta *= 10.0f;

  00702	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0070a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00712	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN23@SliderBeha:

; 2391 :                 set_new_value = true;

  0071a	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1

; 2392 :                 if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

  00721	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00729	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00730	72 11		 jb	 SHORT $LN27@SliderBeha
  00732	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0073a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00741	77 18		 ja	 SHORT $LN26@SliderBeha
$LN27@SliderBeha:
  00743	0f 57 c0	 xorps	 xmm0, xmm0
  00746	0f 2f 85 1c ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0074d	72 15		 jb	 SHORT $LN24@SliderBeha
  0074f	0f 57 c0	 xorps	 xmm0, xmm0
  00752	0f 2f 85 f4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  00759	76 09		 jbe	 SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2393 :                     set_new_value = false;

  0075b	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0
  00762	eb 24		 jmp	 SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2394 :                 else
; 2395 :                     clicked_t = ImSaturate(clicked_t + delta);

  00764	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0076c	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _delta$13[ebp]
  00774	51		 push	 ecx
  00775	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0077a	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0077f	83 c4 04	 add	 esp, 4
  00782	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]
$LN25@SliderBeha:

; 2396 :             }
; 2397 :         }
; 2398 : 
; 2399 :         if (set_new_value)

  00788	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _set_new_value$17[ebp]
  0078f	85 c0		 test	 eax, eax
  00791	0f 84 c0 02 00
	00		 je	 $LN39@SliderBeha

; 2400 :         {
; 2401 :             TYPE v_new;
; 2402 :             if (is_power)

  00797	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0079b	85 c0		 test	 eax, eax
  0079d	0f 84 9c 01 00
	00		 je	 $LN29@SliderBeha

; 2403 :             {
; 2404 :                 // Account for power curve scale on both sides of the zero
; 2405 :                 if (clicked_t < linear_zero_pos)

  007a3	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  007ab	0f 2f 85 1c ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007b2	0f 86 9c 00 00
	00		 jbe	 $LN31@SliderBeha

; 2406 :                 {
; 2407 :                     // Negative: rescale to the negative range before powering
; 2408 :                     float a = 1.0f - (clicked_t / linear_zero_pos);

  007b8	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007c0	f3 0f 5e 85 60
	ff ff ff	 divss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  007c8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  007d0	f3 0f 5c c8	 subss	 xmm1, xmm0
  007d4	f3 0f 11 8d cc
	fe ff ff	 movss	 DWORD PTR _a$10[ebp], xmm1

; 2409 :                     a = ImPow(a, power);

  007dc	51		 push	 ecx
  007dd	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  007e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007e7	51		 push	 ecx
  007e8	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  007f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007f5	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  007fa	83 c4 08	 add	 esp, 8
  007fd	d9 9d cc fe ff
	ff		 fstp	 DWORD PTR _a$10[ebp]

; 2410 :                     v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

  00803	51		 push	 ecx
  00804	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  0080c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00811	83 ec 08	 sub	 esp, 8
  00814	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  00819	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0081e	83 ec 08	 sub	 esp, 8
  00821	0f 57 c0	 xorps	 xmm0, xmm0
  00824	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00829	83 ec 08	 sub	 esp, 8
  0082c	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00831	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00836	e8 00 00 00 00	 call	 ??$ImMin@N@@YANNN@Z	; ImMin<double>
  0083b	83 c4 08	 add	 esp, 8
  0083e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00841	e8 00 00 00 00	 call	 ??$ImLerp@N@@YANNNM@Z	; ImLerp<double>
  00846	83 c4 14	 add	 esp, 20			; 00000014H
  00849	dd 9d d8 fe ff
	ff		 fstp	 QWORD PTR _v_new$11[ebp]

; 2411 :                 }

  0084f	e9 e6 00 00 00	 jmp	 $LN32@SliderBeha
$LN31@SliderBeha:

; 2412 :                 else
; 2413 :                 {
; 2414 :                     // Positive: rescale to the positive range before powering
; 2415 :                     float a;
; 2416 :                     if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

  00854	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0085c	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00864	51		 push	 ecx
  00865	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0086a	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  0086f	83 c4 04	 add	 esp, 4
  00872	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv633[ebp]
  00878	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv633[ebp]
  00880	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@358637bd
  00887	76 2e		 jbe	 SHORT $LN33@SliderBeha

; 2417 :                         a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

  00889	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00891	f3 0f 5c 85 60
	ff ff ff	 subss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00899	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  008a1	f3 0f 5c 8d 60
	ff ff ff	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  008a9	f3 0f 5e c1	 divss	 xmm0, xmm1
  008ad	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
  008b5	eb 10		 jmp	 SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2418 :                     else
; 2419 :                         a = clicked_t;

  008b7	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  008bf	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
$LN34@SliderBeha:

; 2420 :                     a = ImPow(a, power);

  008c7	51		 push	 ecx
  008c8	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  008cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d2	51		 push	 ecx
  008d3	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  008db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008e0	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  008e5	83 c4 08	 add	 esp, 8
  008e8	d9 9d c0 fe ff
	ff		 fstp	 DWORD PTR _a$9[ebp]

; 2421 :                     v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

  008ee	51		 push	 ecx
  008ef	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  008f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008fc	83 ec 08	 sub	 esp, 8
  008ff	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00904	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00909	83 ec 08	 sub	 esp, 8
  0090c	0f 57 c0	 xorps	 xmm0, xmm0
  0090f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00914	83 ec 08	 sub	 esp, 8
  00917	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  0091c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00921	e8 00 00 00 00	 call	 ??$ImMax@N@@YANNN@Z	; ImMax<double>
  00926	83 c4 08	 add	 esp, 8
  00929	dd 1c 24	 fstp	 QWORD PTR [esp]
  0092c	e8 00 00 00 00	 call	 ??$ImLerp@N@@YANNNM@Z	; ImLerp<double>
  00931	83 c4 14	 add	 esp, 20			; 00000014H
  00934	dd 9d d8 fe ff
	ff		 fstp	 QWORD PTR _v_new$11[ebp]
$LN32@SliderBeha:

; 2422 :                 }
; 2423 :             }

  0093a	e9 c7 00 00 00	 jmp	 $LN38@SliderBeha
$LN29@SliderBeha:

; 2424 :             else
; 2425 :             {
; 2426 :                 // Linear slider
; 2427 :                 if (is_decimal)

  0093f	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00943	85 c0		 test	 eax, eax
  00945	74 3b		 je	 SHORT $LN35@SliderBeha

; 2428 :                 {
; 2429 :                     v_new = ImLerp(v_min, v_max, clicked_t);

  00947	51		 push	 ecx
  00948	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00950	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00955	83 ec 08	 sub	 esp, 8
  00958	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  0095d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00962	83 ec 08	 sub	 esp, 8
  00965	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  0096a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0096f	e8 00 00 00 00	 call	 ??$ImLerp@N@@YANNNM@Z	; ImLerp<double>
  00974	83 c4 14	 add	 esp, 20			; 00000014H
  00977	dd 9d d8 fe ff
	ff		 fstp	 QWORD PTR _v_new$11[ebp]

; 2430 :                 }

  0097d	e9 84 00 00 00	 jmp	 $LN38@SliderBeha
$LN35@SliderBeha:

; 2431 :                 else
; 2432 :                 {
; 2433 :                     // For integer values we want the clicking position to match the grab box so we round above
; 2434 :                     // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2435 :                     FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

  00982	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00987	f2 0f 5c 45 18	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  0098c	f3 0f 5a 8d 1c
	ff ff ff	 cvtss2sd xmm1, DWORD PTR _clicked_t$16[ebp]
  00994	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00998	f2 0f 11 85 b0
	fe ff ff	 movsd	 QWORD PTR _v_new_off_f$8[ebp], xmm0

; 2436 :                     TYPE v_new_off_floor = (TYPE)(v_new_off_f);

  009a0	f2 0f 10 85 b0
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new_off_f$8[ebp]
  009a8	f2 0f 11 85 a0
	fe ff ff	 movsd	 QWORD PTR _v_new_off_floor$7[ebp], xmm0

; 2437 :                     TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

  009b0	f2 0f 10 85 b0
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new_off_f$8[ebp]
  009b8	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  009c0	f2 0f 11 85 90
	fe ff ff	 movsd	 QWORD PTR _v_new_off_round$6[ebp], xmm0

; 2438 :                     if (v_new_off_floor < v_new_off_round)

  009c8	f2 0f 10 85 90
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new_off_round$6[ebp]
  009d0	66 0f 2f 85 a0
	fe ff ff	 comisd	 xmm0, QWORD PTR _v_new_off_floor$7[ebp]
  009d8	76 17		 jbe	 SHORT $LN37@SliderBeha

; 2439 :                         v_new = v_min + v_new_off_round;

  009da	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  009df	f2 0f 58 85 90
	fe ff ff	 addsd	 xmm0, QWORD PTR _v_new_off_round$6[ebp]
  009e7	f2 0f 11 85 d8
	fe ff ff	 movsd	 QWORD PTR _v_new$11[ebp], xmm0
  009ef	eb 15		 jmp	 SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2440 :                     else
; 2441 :                         v_new = v_min + v_new_off_floor;

  009f1	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  009f6	f2 0f 58 85 a0
	fe ff ff	 addsd	 xmm0, QWORD PTR _v_new_off_floor$7[ebp]
  009fe	f2 0f 11 85 d8
	fe ff ff	 movsd	 QWORD PTR _v_new$11[ebp], xmm0
$LN38@SliderBeha:

; 2442 :                 }
; 2443 :             }
; 2444 : 
; 2445 :             // Round to user desired precision based on format string
; 2446 :             v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

  00a06	83 ec 08	 sub	 esp, 8
  00a09	f2 0f 10 85 d8
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new$11[ebp]
  00a11	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00a16	8b 45 10	 mov	 eax, DWORD PTR _data_type$[ebp]
  00a19	50		 push	 eax
  00a1a	8b 4d 28	 mov	 ecx, DWORD PTR _format$[ebp]
  00a1d	51		 push	 ecx
  00a1e	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@NN@ImGui@@YANPBDHN@Z ; ImGui::RoundScalarWithFormatT<double,double>
  00a23	83 c4 10	 add	 esp, 16			; 00000010H
  00a26	dd 9d d8 fe ff
	ff		 fstp	 QWORD PTR _v_new$11[ebp]

; 2447 : 
; 2448 :             // Apply result
; 2449 :             if (*v != v_new)

  00a2c	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00a2f	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00a33	66 0f 2e 85 d8
	fe ff ff	 ucomisd xmm0, QWORD PTR _v_new$11[ebp]
  00a3b	9f		 lahf
  00a3c	f6 c4 44	 test	 ah, 68			; 00000044H
  00a3f	7b 16		 jnp	 SHORT $LN39@SliderBeha

; 2450 :             {
; 2451 :                 *v = v_new;

  00a41	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00a44	f2 0f 10 85 d8
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new$11[ebp]
  00a4c	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 2452 :                 value_changed = true;

  00a50	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN39@SliderBeha:

; 2453 :             }
; 2454 :         }
; 2455 :     }
; 2456 : 
; 2457 :     if (slider_sz < 1.0f)

  00a57	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a5f	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00a63	76 31		 jbe	 SHORT $LN40@SliderBeha

; 2458 :     {
; 2459 :         *out_grab_bb = ImRect(bb.Min, bb.Min);

  00a65	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00a68	50		 push	 eax
  00a69	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00a6c	51		 push	 ecx
  00a6d	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00a73	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
  00a78	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00a7b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a7d	89 0a		 mov	 DWORD PTR [edx], ecx
  00a7f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a82	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00a85	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a88	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00a8b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00a8e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2460 :     }

  00a91	e9 cc 01 00 00	 jmp	 $LN44@SliderBeha
$LN40@SliderBeha:

; 2461 :     else
; 2462 :     {
; 2463 :         // Output grab position so it can be displayed by the caller
; 2464 :         float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  00a96	51		 push	 ecx
  00a97	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00a9f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aa4	51		 push	 ecx
  00aa5	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00aaa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aaf	83 ec 08	 sub	 esp, 8
  00ab2	f2 0f 10 45 20	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00ab7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00abc	83 ec 08	 sub	 esp, 8
  00abf	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  00ac4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00ac9	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00acc	83 ec 08	 sub	 esp, 8
  00acf	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00ad3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00ad8	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00adb	51		 push	 ecx
  00adc	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@NN@ImGui@@YAMHNNNMM@Z ; ImGui::SliderCalcRatioFromValueT<double,double>
  00ae1	83 c4 24	 add	 esp, 36			; 00000024H
  00ae4	d9 9d 84 fe ff
	ff		 fstp	 DWORD PTR _grab_t$5[ebp]

; 2465 :         if (axis == ImGuiAxis_Y)

  00aea	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00aee	75 18		 jne	 SHORT $LN42@SliderBeha

; 2466 :             grab_t = 1.0f - grab_t;

  00af0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00af8	f3 0f 5c 85 84
	fe ff ff	 subss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00b00	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR _grab_t$5[ebp], xmm0
$LN42@SliderBeha:

; 2467 :         const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

  00b08	51		 push	 ecx
  00b09	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00b11	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b16	51		 push	 ecx
  00b17	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_max$[ebp]
  00b1f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b24	51		 push	 ecx
  00b25	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00b2d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b32	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00b37	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b3a	d9 9d 78 fe ff
	ff		 fstp	 DWORD PTR _grab_pos$4[ebp]

; 2468 :         if (axis == ImGuiAxis_X)

  00b40	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00b44	0f 85 8f 00 00
	00		 jne	 $LN43@SliderBeha

; 2469 :             *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

  00b4a	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00b4d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00b52	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00b5a	51		 push	 ecx
  00b5b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b60	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00b65	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00b6d	f3 0f 58 85 78
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00b75	51		 push	 ecx
  00b76	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b7b	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00b7e	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00b83	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00b8b	51		 push	 ecx
  00b8c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b91	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00b96	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00b9e	f3 0f 10 8d 78
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00ba6	f3 0f 5c c8	 subss	 xmm1, xmm0
  00baa	51		 push	 ecx
  00bab	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00bb0	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00bb6	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00bbb	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00bbe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bc0	89 0a		 mov	 DWORD PTR [edx], ecx
  00bc2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bc5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00bc8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00bcb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00bce	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00bd1	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00bd4	e9 89 00 00 00	 jmp	 $LN44@SliderBeha
$LN43@SliderBeha:

; 2470 :         else
; 2471 :             *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

  00bd9	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00bde	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00be6	f3 0f 58 85 78
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00bee	51		 push	 ecx
  00bef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bf4	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00bf7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00bfc	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00c04	51		 push	 ecx
  00c05	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c0a	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c0f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00c17	f3 0f 10 8d 78
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00c1f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00c23	51		 push	 ecx
  00c24	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00c29	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00c2c	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00c30	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00c38	51		 push	 ecx
  00c39	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c3e	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00c44	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00c49	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00c4c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c4e	89 0a		 mov	 DWORD PTR [edx], ecx
  00c50	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c53	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c56	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c59	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c5c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c5f	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN44@SliderBeha:

; 2472 :     }
; 2473 : 
; 2474 :     return value_changed;

  00c62	8a 85 37 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]

; 2475 : }

  00c68	52		 push	 edx
  00c69	8b cd		 mov	 ecx, ebp
  00c6b	50		 push	 eax
  00c6c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN70@SliderBeha
  00c72	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00c77	58		 pop	 eax
  00c78	5a		 pop	 edx
  00c79	5f		 pop	 edi
  00c7a	5e		 pop	 esi
  00c7b	5b		 pop	 ebx
  00c7c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c7f	33 cd		 xor	 ecx, ebp
  00c81	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c86	81 c4 a0 02 00
	00		 add	 esp, 672		; 000002a0H
  00c8c	3b ec		 cmp	 ebp, esp
  00c8e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c93	8b e5		 mov	 esp, ebp
  00c95	5d		 pop	 ebp
  00c96	c3		 ret	 0
  00c97	90		 npad	 1
$LN70@SliderBeha:
  00c98	01 00 00 00	 DD	 1
  00c9c	00 00 00 00	 DD	 $LN69@SliderBeha
$LN69@SliderBeha:
  00ca0	00 ff ff ff	 DD	 -256			; ffffff00H
  00ca4	08 00 00 00	 DD	 8
  00ca8	00 00 00 00	 DD	 $LN68@SliderBeha
$LN68@SliderBeha:
  00cac	64		 DB	 100			; 00000064H
  00cad	65		 DB	 101			; 00000065H
  00cae	6c		 DB	 108			; 0000006cH
  00caf	74		 DB	 116			; 00000074H
  00cb0	61		 DB	 97			; 00000061H
  00cb1	32		 DB	 50			; 00000032H
  00cb2	00		 DB	 0
??$SliderBehaviorT@NNN@ImGui@@YA_NABUImRect@@IHPANNNPBDMHPAU1@@Z ENDP ; ImGui::SliderBehaviorT<double,double,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@MMM@ImGui@@YA_NABUImRect@@IHPAMMMPBDMHPAU1@@Z
_TEXT	SEGMENT
tv462 = -644						; size = 4
tv769 = -640						; size = 4
tv627 = -636						; size = 4
tv496 = -636						; size = 4
tv489 = -636						; size = 4
tv457 = -636						; size = 4
tv275 = -636						; size = 4
tv258 = -636						; size = 4
tv207 = -636						; size = 4
tv195 = -636						; size = 4
tv172 = -636						; size = 4
tv166 = -636						; size = 4
tv159 = -636						; size = 4
tv89 = -636						; size = 4
tv67 = -636						; size = 4
tv74 = -633						; size = 1
tv70 = -633						; size = 1
$T1 = -628						; size = 16
$T2 = -604						; size = 16
$T3 = -580						; size = 16
_grab_pos$4 = -364					; size = 4
_grab_t$5 = -352					; size = 4
_v_new_off_round$6 = -340				; size = 4
_v_new_off_floor$7 = -328				; size = 4
_v_new_off_f$8 = -316					; size = 4
_a$9 = -304						; size = 4
_a$10 = -292						; size = 4
_v_new$11 = -280					; size = 4
_decimal_precision$12 = -268				; size = 4
_delta$13 = -256					; size = 4
_delta2$14 = -244					; size = 8
_mouse_abs_pos$15 = -228				; size = 4
_clicked_t$16 = -216					; size = 4
_set_new_value$17 = -201				; size = 1
_value_changed$ = -189					; size = 1
_linear_dist_max_to_0$18 = -180				; size = 4
_linear_dist_min_to_0$19 = -168				; size = 4
_linear_zero_pos$ = -156				; size = 4
_slider_usable_pos_max$ = -144				; size = 4
_slider_usable_pos_min$ = -132				; size = 4
_slider_usable_sz$ = -120				; size = 4
_v_range$ = -108					; size = 4
_grab_sz$ = -96						; size = 4
_slider_sz$ = -84					; size = 4
_grab_padding$ = -72					; size = 4
_is_power$ = -57					; size = 1
_is_decimal$ = -45					; size = 1
_axis$ = -36						; size = 4
_style$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_data_type$ = 16					; size = 4
_v$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
_flags$ = 40						; size = 4
_out_grab_bb$ = 44					; size = 4
??$SliderBehaviorT@MMM@ImGui@@YA_NABUImRect@@IHPAMMMPBDMHPAU1@@Z PROC ; ImGui::SliderBehaviorT<float,float,float>, COMDAT

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 7c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-644]
  00012	b9 a1 00 00 00	 mov	 ecx, 161		; 000000a1H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2310 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2311 :     const ImGuiStyle& style = g.Style;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00042	89 45 e8	 mov	 DWORD PTR _style$[ebp], eax

; 2312 : 
; 2313 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00045	8b 45 28	 mov	 eax, DWORD PTR _flags$[ebp]
  00048	83 e0 01	 and	 eax, 1
  0004b	74 0c		 je	 SHORT $LN46@SliderBeha
  0004d	c7 85 84 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00057	eb 0a		 jmp	 SHORT $LN47@SliderBeha
$LN46@SliderBeha:
  00059	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN47@SliderBeha:
  00063	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  00069	89 4d dc	 mov	 DWORD PTR _axis$[ebp], ecx

; 2314 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  0006c	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00070	74 0f		 je	 SHORT $LN48@SliderBeha
  00072	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00076	74 09		 je	 SHORT $LN48@SliderBeha
  00078	c6 85 87 fd ff
	ff 00		 mov	 BYTE PTR tv70[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN49@SliderBeha
$LN48@SliderBeha:
  00081	c6 85 87 fd ff
	ff 01		 mov	 BYTE PTR tv70[ebp], 1
$LN49@SliderBeha:
  00088	8a 85 87 fd ff
	ff		 mov	 al, BYTE PTR tv70[ebp]
  0008e	88 45 d3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 2315 :     const bool is_power = (power != 1.0f) && is_decimal;

  00091	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00096	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0009d	9f		 lahf
  0009e	f6 c4 44	 test	 ah, 68			; 00000044H
  000a1	7b 11		 jnp	 SHORT $LN50@SliderBeha
  000a3	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN50@SliderBeha
  000ab	c6 85 87 fd ff
	ff 01		 mov	 BYTE PTR tv74[ebp], 1
  000b2	eb 07		 jmp	 SHORT $LN51@SliderBeha
$LN50@SliderBeha:
  000b4	c6 85 87 fd ff
	ff 00		 mov	 BYTE PTR tv74[ebp], 0
$LN51@SliderBeha:
  000bb	8a 8d 87 fd ff
	ff		 mov	 cl, BYTE PTR tv74[ebp]
  000c1	88 4d c7	 mov	 BYTE PTR _is_power$[ebp], cl

; 2316 : 
; 2317 :     const float grab_padding = 2.0f;

  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000cc	f3 0f 11 45 b8	 movss	 DWORD PTR _grab_padding$[ebp], xmm0

; 2318 :     const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

  000d1	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000d8	83 c1 08	 add	 ecx, 8
  000db	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  000e0	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv457[ebp]
  000e6	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv457[ebp]
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _axis$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000f5	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv769[ebp], xmm0
  000fd	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00102	d9 9d 7c fd ff
	ff		 fstp	 DWORD PTR tv462[ebp]
  00108	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv769[ebp]
  00110	f3 0f 5c 85 7c
	fd ff ff	 subss	 xmm0, DWORD PTR tv462[ebp]
  00118	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00120	f3 0f 11 45 ac	 movss	 DWORD PTR _slider_sz$[ebp], xmm0

; 2319 :     float grab_sz = style.GrabMinSize;

  00125	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  00128	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  0012d	f3 0f 11 45 a0	 movss	 DWORD PTR _grab_sz$[ebp], xmm0

; 2320 :     SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

  00132	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00137	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _v_min$[ebp]
  0013b	76 14		 jbe	 SHORT $LN52@SliderBeha
  0013d	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00142	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  00147	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv89[ebp], xmm0
  0014f	eb 12		 jmp	 SHORT $LN53@SliderBeha
$LN52@SliderBeha:
  00151	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00156	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _v_max$[ebp]
  0015b	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv89[ebp], xmm0
$LN53@SliderBeha:
  00163	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv89[ebp]
  0016b	f3 0f 11 45 94	 movss	 DWORD PTR _v_range$[ebp], xmm0

; 2321 :     if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

  00170	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00174	85 c0		 test	 eax, eax
  00176	75 43		 jne	 SHORT $LN2@SliderBeha
  00178	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _v_range$[ebp]
  0017d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00184	72 35		 jb	 SHORT $LN2@SliderBeha

; 2322 :         grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

  00186	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  00189	51		 push	 ecx
  0018a	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  0018f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00194	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _v_range$[ebp]
  00199	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  001a1	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _slider_sz$[ebp]
  001a6	f3 0f 5e c8	 divss	 xmm1, xmm0
  001aa	51		 push	 ecx
  001ab	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001b0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001b5	83 c4 08	 add	 esp, 8
  001b8	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]
$LN2@SliderBeha:

; 2323 :     grab_sz = ImMin(grab_sz, slider_sz);

  001bb	51		 push	 ecx
  001bc	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c6	51		 push	 ecx
  001c7	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d1	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001d6	83 c4 08	 add	 esp, 8
  001d9	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]

; 2324 :     const float slider_usable_sz = slider_sz - grab_sz;

  001dc	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001e1	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001e6	f3 0f 11 45 88	 movss	 DWORD PTR _slider_usable_sz$[ebp], xmm0

; 2325 :     const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

  001eb	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  001ee	50		 push	 eax
  001ef	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  001f2	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  001f7	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv489[ebp]
  001fd	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv489[ebp]
  00205	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0020d	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00212	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0021a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0021e	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_min$[ebp], xmm0

; 2326 :     const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

  00226	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  00229	50		 push	 eax
  0022a	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  0022d	83 c1 08	 add	 ecx, 8
  00230	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00235	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv496[ebp]
  0023b	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv496[ebp]
  00243	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  0024b	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00250	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  00258	f3 0f 5c c1	 subss	 xmm0, xmm1
  0025c	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_max$[ebp], xmm0

; 2327 : 
; 2328 :     // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2329 :     float linear_zero_pos;   // 0.0->1.0f
; 2330 :     if (is_power && v_min * v_max < 0.0f)

  00264	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00268	85 c0		 test	 eax, eax
  0026a	0f 84 fc 00 00
	00		 je	 $LN3@SliderBeha
  00270	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00275	f3 0f 59 45 1c	 mulss	 xmm0, DWORD PTR _v_max$[ebp]
  0027a	0f 57 c9	 xorps	 xmm1, xmm1
  0027d	0f 2f c8	 comiss	 xmm1, xmm0
  00280	0f 86 e6 00 00
	00		 jbe	 $LN3@SliderBeha

; 2331 :     {
; 2332 :         // Different sign
; 2333 :         const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

  00286	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  0028b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00292	72 0f		 jb	 SHORT $LN54@SliderBeha
  00294	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00299	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
  002a1	eb 14		 jmp	 SHORT $LN55@SliderBeha
$LN54@SliderBeha:
  002a3	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  002a8	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002af	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
$LN55@SliderBeha:
  002b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002bf	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  002c4	51		 push	 ecx
  002c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ca	51		 push	 ecx
  002cb	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv159[ebp]
  002d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d8	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  002dd	83 c4 08	 add	 esp, 8
  002e0	d9 9d 58 ff ff
	ff		 fstp	 DWORD PTR _linear_dist_min_to_0$19[ebp]

; 2334 :         const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

  002e6	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  002eb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002f2	72 0f		 jb	 SHORT $LN56@SliderBeha
  002f4	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  002f9	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv166[ebp], xmm0
  00301	eb 14		 jmp	 SHORT $LN57@SliderBeha
$LN56@SliderBeha:
  00303	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00308	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0030f	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv166[ebp], xmm0
$LN57@SliderBeha:
  00317	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0031f	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00324	51		 push	 ecx
  00325	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032a	51		 push	 ecx
  0032b	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv166[ebp]
  00333	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00338	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0033d	83 c4 08	 add	 esp, 8
  00340	d9 9d 4c ff ff
	ff		 fstp	 DWORD PTR _linear_dist_max_to_0$18[ebp]

; 2335 :         linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

  00346	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_dist_min_to_0$19[ebp]
  0034e	f3 0f 58 85 4c
	ff ff ff	 addss	 xmm0, DWORD PTR _linear_dist_max_to_0$18[ebp]
  00356	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _linear_dist_min_to_0$19[ebp]
  0035e	f3 0f 5e c8	 divss	 xmm1, xmm0
  00362	f3 0f 11 8d 64
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm1

; 2336 :     }

  0036a	eb 36		 jmp	 SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2337 :     else
; 2338 :     {
; 2339 :         // Same sign
; 2340 :         linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

  0036c	0f 57 c0	 xorps	 xmm0, xmm0
  0036f	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _v_min$[ebp]
  00373	76 12		 jbe	 SHORT $LN58@SliderBeha
  00375	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0037d	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
  00385	eb 0b		 jmp	 SHORT $LN59@SliderBeha
$LN58@SliderBeha:
  00387	0f 57 c0	 xorps	 xmm0, xmm0
  0038a	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
$LN59@SliderBeha:
  00392	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv172[ebp]
  0039a	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0
$LN4@SliderBeha:

; 2341 :     }
; 2342 : 
; 2343 :     // Process interacting with the slider
; 2344 :     bool value_changed = false;

  003a2	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 2345 :     if (g.ActiveId == id)

  003a9	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  003ac	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  003b2	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  003b5	0f 85 57 06 00
	00		 jne	 $LN39@SliderBeha

; 2346 :     {
; 2347 :         bool set_new_value = false;

  003bb	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0

; 2348 :         float clicked_t = 0.0f;

  003c2	0f 57 c0	 xorps	 xmm0, xmm0
  003c5	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2349 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

  003cd	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  003d0	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  003d7	0f 85 d4 00 00
	00		 jne	 $LN6@SliderBeha

; 2350 :         {
; 2351 :             if (!g.IO.MouseDown[0])

  003dd	b8 01 00 00 00	 mov	 eax, 1
  003e2	6b c8 00	 imul	 ecx, eax, 0
  003e5	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  003e8	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  003f0	85 c0		 test	 eax, eax
  003f2	75 0a		 jne	 SHORT $LN8@SliderBeha

; 2352 :             {
; 2353 :                 ClearActiveID();

  003f4	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2354 :             }

  003f9	e9 ae 00 00 00	 jmp	 $LN9@SliderBeha
$LN8@SliderBeha:

; 2355 :             else
; 2356 :             {
; 2357 :                 const float mouse_abs_pos = g.IO.MousePos[axis];

  003fe	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  00401	50		 push	 eax
  00402	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00405	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  0040b	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  00410	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00414	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _mouse_abs_pos$15[ebp], xmm0

; 2358 :                 clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

  0041c	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  00421	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00428	76 42		 jbe	 SHORT $LN60@SliderBeha
  0042a	51		 push	 ecx
  0042b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00433	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00438	51		 push	 ecx
  00439	0f 57 c0	 xorps	 xmm0, xmm0
  0043c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00441	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_abs_pos$15[ebp]
  00449	f3 0f 5c 85 7c
	ff ff ff	 subss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00451	f3 0f 5e 45 88	 divss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  00456	51		 push	 ecx
  00457	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0045c	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  00461	83 c4 0c	 add	 esp, 12			; 0000000cH
  00464	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv195[ebp]
  0046a	eb 0b		 jmp	 SHORT $LN61@SliderBeha
$LN60@SliderBeha:
  0046c	0f 57 c0	 xorps	 xmm0, xmm0
  0046f	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv195[ebp], xmm0
$LN61@SliderBeha:
  00477	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv195[ebp]
  0047f	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2359 :                 if (axis == ImGuiAxis_Y)

  00487	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  0048b	75 18		 jne	 SHORT $LN10@SliderBeha

; 2360 :                     clicked_t = 1.0f - clicked_t;

  0048d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00495	f3 0f 5c 85 28
	ff ff ff	 subss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0049d	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0
$LN10@SliderBeha:

; 2361 :                 set_new_value = true;

  004a5	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1
$LN9@SliderBeha:

; 2362 :             }
; 2363 :         }

  004ac	e9 ad 02 00 00	 jmp	 $LN25@SliderBeha
$LN6@SliderBeha:

; 2364 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  004b1	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  004b4	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  004bb	0f 85 9d 02 00
	00		 jne	 $LN25@SliderBeha

; 2365 :         {
; 2366 :             const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

  004c1	51		 push	 ecx
  004c2	0f 57 c0	 xorps	 xmm0, xmm0
  004c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ca	51		 push	 ecx
  004cb	0f 57 c0	 xorps	 xmm0, xmm0
  004ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d3	6a 05		 push	 5
  004d5	6a 03		 push	 3
  004d7	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _delta2$14[ebp]
  004dd	50		 push	 eax
  004de	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  004e3	83 c4 14	 add	 esp, 20			; 00000014H

; 2367 :             float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

  004e6	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  004ea	75 12		 jne	 SHORT $LN62@SliderBeha
  004ec	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp]
  004f4	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv207[ebp], xmm0
  004fc	eb 17		 jmp	 SHORT $LN63@SliderBeha
$LN62@SliderBeha:
  004fe	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp+4]
  00506	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0050d	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv207[ebp], xmm0
$LN63@SliderBeha:
  00515	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv207[ebp]
  0051d	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2368 :             if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

  00525	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00528	8b 88 e0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6880]
  0052e	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00531	75 18		 jne	 SHORT $LN12@SliderBeha
  00533	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00536	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  0053d	85 c9		 test	 ecx, ecx
  0053f	75 0a		 jne	 SHORT $LN12@SliderBeha

; 2369 :             {
; 2370 :                 ClearActiveID();

  00541	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2371 :             }

  00546	e9 13 02 00 00	 jmp	 $LN25@SliderBeha
$LN12@SliderBeha:

; 2372 :             else if (delta != 0.0f)

  0054b	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00553	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0055a	9f		 lahf
  0055b	f6 c4 44	 test	 ah, 68			; 00000044H
  0055e	0f 8b fa 01 00
	00		 jnp	 $LN25@SliderBeha

; 2373 :             {
; 2374 :                 clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  00564	51		 push	 ecx
  00565	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0056d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00572	51		 push	 ecx
  00573	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00578	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0057d	51		 push	 ecx
  0057e	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00583	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00588	51		 push	 ecx
  00589	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  0058e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00593	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00596	51		 push	 ecx
  00597	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0059b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a0	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  005a3	51		 push	 ecx
  005a4	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ; ImGui::SliderCalcRatioFromValueT<float,float>
  005a9	83 c4 18	 add	 esp, 24			; 00000018H
  005ac	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]

; 2375 :                 const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  005b2	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  005b6	85 c0		 test	 eax, eax
  005b8	74 16		 je	 SHORT $LN64@SliderBeha
  005ba	6a 03		 push	 3
  005bc	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  005bf	51		 push	 ecx
  005c0	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  005c5	83 c4 08	 add	 esp, 8
  005c8	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv258[ebp], eax
  005ce	eb 0a		 jmp	 SHORT $LN65@SliderBeha
$LN64@SliderBeha:
  005d0	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv258[ebp], 0
$LN65@SliderBeha:
  005da	8b 95 84 fd ff
	ff		 mov	 edx, DWORD PTR tv258[ebp]
  005e0	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _decimal_precision$12[ebp], edx

; 2376 :                 if ((decimal_precision > 0) || is_power)

  005e6	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _decimal_precision$12[ebp], 0
  005ed	7f 08		 jg	 SHORT $LN17@SliderBeha
  005ef	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  005f3	85 c0		 test	 eax, eax
  005f5	74 46		 je	 SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2377 :                 {
; 2378 :                     delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

  005f7	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  005ff	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00607	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2379 :                     if (IsNavInputDown(ImGuiNavInput_TweakSlow))

  0060f	6a 0e		 push	 14			; 0000000eH
  00611	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00616	83 c4 04	 add	 esp, 4
  00619	0f b6 c0	 movzx	 eax, al
  0061c	85 c0		 test	 eax, eax
  0061e	74 18		 je	 SHORT $LN18@SliderBeha

; 2380 :                         delta /= 10.0f;

  00620	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00628	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00630	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN18@SliderBeha:

; 2381 :                 }

  00638	e9 8a 00 00 00	 jmp	 $LN20@SliderBeha
$LN15@SliderBeha:

; 2382 :                 else
; 2383 :                 {
; 2384 :                     if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

  0063d	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _v_range$[ebp]
  00642	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@c2c80000
  00649	72 0e		 jb	 SHORT $LN22@SliderBeha
  0064b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00653	0f 2f 45 94	 comiss	 xmm0, DWORD PTR _v_range$[ebp]
  00657	73 11		 jae	 SHORT $LN21@SliderBeha
$LN22@SliderBeha:
  00659	6a 0e		 push	 14			; 0000000eH
  0065b	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00660	83 c4 04	 add	 esp, 4
  00663	0f b6 c0	 movzx	 eax, al
  00666	85 c0		 test	 eax, eax
  00668	74 45		 je	 SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2385 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

  0066a	0f 57 c0	 xorps	 xmm0, xmm0
  0066d	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  00674	76 12		 jbe	 SHORT $LN66@SliderBeha
  00676	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0067e	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv275[ebp], xmm0
  00686	eb 10		 jmp	 SHORT $LN67@SliderBeha
$LN66@SliderBeha:
  00688	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00690	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv275[ebp], xmm0
$LN67@SliderBeha:
  00698	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv275[ebp]
  006a0	f3 0f 5e 45 94	 divss	 xmm0, DWORD PTR _v_range$[ebp]
  006a5	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
  006ad	eb 18		 jmp	 SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2386 :                     else
; 2387 :                         delta /= 100.0f;

  006af	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  006b7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  006bf	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN20@SliderBeha:

; 2388 :                 }
; 2389 :                 if (IsNavInputDown(ImGuiNavInput_TweakFast))

  006c7	6a 0f		 push	 15			; 0000000fH
  006c9	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  006ce	83 c4 04	 add	 esp, 4
  006d1	0f b6 c0	 movzx	 eax, al
  006d4	85 c0		 test	 eax, eax
  006d6	74 18		 je	 SHORT $LN23@SliderBeha

; 2390 :                     delta *= 10.0f;

  006d8	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  006e0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  006e8	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN23@SliderBeha:

; 2391 :                 set_new_value = true;

  006f0	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1

; 2392 :                 if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

  006f7	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  006ff	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00706	72 11		 jb	 SHORT $LN27@SliderBeha
  00708	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00710	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00717	77 18		 ja	 SHORT $LN26@SliderBeha
$LN27@SliderBeha:
  00719	0f 57 c0	 xorps	 xmm0, xmm0
  0071c	0f 2f 85 28 ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00723	72 15		 jb	 SHORT $LN24@SliderBeha
  00725	0f 57 c0	 xorps	 xmm0, xmm0
  00728	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  0072f	76 09		 jbe	 SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2393 :                     set_new_value = false;

  00731	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0
  00738	eb 24		 jmp	 SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2394 :                 else
; 2395 :                     clicked_t = ImSaturate(clicked_t + delta);

  0073a	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00742	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _delta$13[ebp]
  0074a	51		 push	 ecx
  0074b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00750	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00755	83 c4 04	 add	 esp, 4
  00758	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]
$LN25@SliderBeha:

; 2396 :             }
; 2397 :         }
; 2398 : 
; 2399 :         if (set_new_value)

  0075e	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _set_new_value$17[ebp]
  00765	85 c0		 test	 eax, eax
  00767	0f 84 a5 02 00
	00		 je	 $LN39@SliderBeha

; 2400 :         {
; 2401 :             TYPE v_new;
; 2402 :             if (is_power)

  0076d	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00771	85 c0		 test	 eax, eax
  00773	0f 84 90 01 00
	00		 je	 $LN29@SliderBeha

; 2403 :             {
; 2404 :                 // Account for power curve scale on both sides of the zero
; 2405 :                 if (clicked_t < linear_zero_pos)

  00779	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00781	0f 2f 85 28 ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00788	0f 86 96 00 00
	00		 jbe	 $LN31@SliderBeha

; 2406 :                 {
; 2407 :                     // Negative: rescale to the negative range before powering
; 2408 :                     float a = 1.0f - (clicked_t / linear_zero_pos);

  0078e	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00796	f3 0f 5e 85 64
	ff ff ff	 divss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0079e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  007a6	f3 0f 5c c8	 subss	 xmm1, xmm0
  007aa	f3 0f 11 8d dc
	fe ff ff	 movss	 DWORD PTR _a$10[ebp], xmm1

; 2409 :                     a = ImPow(a, power);

  007b2	51		 push	 ecx
  007b3	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  007b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007bd	51		 push	 ecx
  007be	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  007c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007cb	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  007d0	83 c4 08	 add	 esp, 8
  007d3	d9 9d dc fe ff
	ff		 fstp	 DWORD PTR _a$10[ebp]

; 2410 :                     v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

  007d9	51		 push	 ecx
  007da	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  007e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007e7	51		 push	 ecx
  007e8	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  007ed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007f2	51		 push	 ecx
  007f3	0f 57 c0	 xorps	 xmm0, xmm0
  007f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007fb	51		 push	 ecx
  007fc	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00801	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00806	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0080b	83 c4 04	 add	 esp, 4
  0080e	d9 1c 24	 fstp	 DWORD PTR [esp]
  00811	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00816	83 c4 0c	 add	 esp, 12			; 0000000cH
  00819	d9 9d e8 fe ff
	ff		 fstp	 DWORD PTR _v_new$11[ebp]

; 2411 :                 }

  0081f	e9 e0 00 00 00	 jmp	 $LN32@SliderBeha
$LN31@SliderBeha:

; 2412 :                 else
; 2413 :                 {
; 2414 :                     // Positive: rescale to the positive range before powering
; 2415 :                     float a;
; 2416 :                     if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

  00824	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0082c	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00834	51		 push	 ecx
  00835	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0083a	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  0083f	83 c4 04	 add	 esp, 4
  00842	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv627[ebp]
  00848	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv627[ebp]
  00850	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@358637bd
  00857	76 2e		 jbe	 SHORT $LN33@SliderBeha

; 2417 :                         a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

  00859	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00861	f3 0f 5c 85 64
	ff ff ff	 subss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00869	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00871	f3 0f 5c 8d 64
	ff ff ff	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  00879	f3 0f 5e c1	 divss	 xmm0, xmm1
  0087d	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
  00885	eb 10		 jmp	 SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2418 :                     else
; 2419 :                         a = clicked_t;

  00887	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0088f	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
$LN34@SliderBeha:

; 2420 :                     a = ImPow(a, power);

  00897	51		 push	 ecx
  00898	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0089d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008a2	51		 push	 ecx
  008a3	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  008ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008b0	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  008b5	83 c4 08	 add	 esp, 8
  008b8	d9 9d d0 fe ff
	ff		 fstp	 DWORD PTR _a$9[ebp]

; 2421 :                     v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

  008be	51		 push	 ecx
  008bf	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  008c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008cc	51		 push	 ecx
  008cd	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  008d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d7	51		 push	 ecx
  008d8	0f 57 c0	 xorps	 xmm0, xmm0
  008db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008e0	51		 push	 ecx
  008e1	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  008e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008eb	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  008f0	83 c4 04	 add	 esp, 4
  008f3	d9 1c 24	 fstp	 DWORD PTR [esp]
  008f6	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  008fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  008fe	d9 9d e8 fe ff
	ff		 fstp	 DWORD PTR _v_new$11[ebp]
$LN32@SliderBeha:

; 2422 :                 }
; 2423 :             }

  00904	e9 bb 00 00 00	 jmp	 $LN38@SliderBeha
$LN29@SliderBeha:

; 2424 :             else
; 2425 :             {
; 2426 :                 // Linear slider
; 2427 :                 if (is_decimal)

  00909	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0090d	85 c0		 test	 eax, eax
  0090f	74 34		 je	 SHORT $LN35@SliderBeha

; 2428 :                 {
; 2429 :                     v_new = ImLerp(v_min, v_max, clicked_t);

  00911	51		 push	 ecx
  00912	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0091a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0091f	51		 push	 ecx
  00920	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00925	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0092a	51		 push	 ecx
  0092b	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00930	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00935	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  0093a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0093d	d9 9d e8 fe ff
	ff		 fstp	 DWORD PTR _v_new$11[ebp]

; 2430 :                 }

  00943	eb 7f		 jmp	 SHORT $LN38@SliderBeha
$LN35@SliderBeha:

; 2431 :                 else
; 2432 :                 {
; 2433 :                     // For integer values we want the clicking position to match the grab box so we round above
; 2434 :                     // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2435 :                     FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

  00945	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  0094a	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  0094f	f3 0f 59 85 28
	ff ff ff	 mulss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00957	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _v_new_off_f$8[ebp], xmm0

; 2436 :                     TYPE v_new_off_floor = (TYPE)(v_new_off_f);

  0095f	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new_off_f$8[ebp]
  00967	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR _v_new_off_floor$7[ebp], xmm0

; 2437 :                     TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

  0096f	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new_off_f$8[ebp]
  00977	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0097f	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR _v_new_off_round$6[ebp], xmm0

; 2438 :                     if (v_new_off_floor < v_new_off_round)

  00987	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new_off_round$6[ebp]
  0098f	0f 2f 85 b8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _v_new_off_floor$7[ebp]
  00996	76 17		 jbe	 SHORT $LN37@SliderBeha

; 2439 :                         v_new = v_min + v_new_off_round;

  00998	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  0099d	f3 0f 58 85 ac
	fe ff ff	 addss	 xmm0, DWORD PTR _v_new_off_round$6[ebp]
  009a5	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _v_new$11[ebp], xmm0
  009ad	eb 15		 jmp	 SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2440 :                     else
; 2441 :                         v_new = v_min + v_new_off_floor;

  009af	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  009b4	f3 0f 58 85 b8
	fe ff ff	 addss	 xmm0, DWORD PTR _v_new_off_floor$7[ebp]
  009bc	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _v_new$11[ebp], xmm0
$LN38@SliderBeha:

; 2442 :                 }
; 2443 :             }
; 2444 : 
; 2445 :             // Round to user desired precision based on format string
; 2446 :             v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

  009c4	51		 push	 ecx
  009c5	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new$11[ebp]
  009cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009d2	8b 45 10	 mov	 eax, DWORD PTR _data_type$[ebp]
  009d5	50		 push	 eax
  009d6	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  009d9	51		 push	 ecx
  009da	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@MM@ImGui@@YAMPBDHM@Z ; ImGui::RoundScalarWithFormatT<float,float>
  009df	83 c4 0c	 add	 esp, 12			; 0000000cH
  009e2	d9 9d e8 fe ff
	ff		 fstp	 DWORD PTR _v_new$11[ebp]

; 2447 : 
; 2448 :             // Apply result
; 2449 :             if (*v != v_new)

  009e8	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  009eb	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  009ef	0f 2e 85 e8 fe
	ff ff		 ucomiss xmm0, DWORD PTR _v_new$11[ebp]
  009f6	9f		 lahf
  009f7	f6 c4 44	 test	 ah, 68			; 00000044H
  009fa	7b 16		 jnp	 SHORT $LN39@SliderBeha

; 2450 :             {
; 2451 :                 *v = v_new;

  009fc	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  009ff	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new$11[ebp]
  00a07	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 2452 :                 value_changed = true;

  00a0b	c6 85 43 ff ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN39@SliderBeha:

; 2453 :             }
; 2454 :         }
; 2455 :     }
; 2456 : 
; 2457 :     if (slider_sz < 1.0f)

  00a12	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a1a	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00a1e	76 31		 jbe	 SHORT $LN40@SliderBeha

; 2458 :     {
; 2459 :         *out_grab_bb = ImRect(bb.Min, bb.Min);

  00a20	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00a23	50		 push	 eax
  00a24	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00a27	51		 push	 ecx
  00a28	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00a2e	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
  00a33	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00a36	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a38	89 0a		 mov	 DWORD PTR [edx], ecx
  00a3a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a3d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00a40	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a43	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00a46	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00a49	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2460 :     }

  00a4c	e9 c6 01 00 00	 jmp	 $LN44@SliderBeha
$LN40@SliderBeha:

; 2461 :     else
; 2462 :     {
; 2463 :         // Output grab position so it can be displayed by the caller
; 2464 :         float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  00a51	51		 push	 ecx
  00a52	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00a5a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a5f	51		 push	 ecx
  00a60	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00a65	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a6a	51		 push	 ecx
  00a6b	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00a70	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a75	51		 push	 ecx
  00a76	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00a7b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a80	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00a83	51		 push	 ecx
  00a84	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00a88	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a8d	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00a90	51		 push	 ecx
  00a91	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@MM@ImGui@@YAMHMMMMM@Z ; ImGui::SliderCalcRatioFromValueT<float,float>
  00a96	83 c4 18	 add	 esp, 24			; 00000018H
  00a99	d9 9d a0 fe ff
	ff		 fstp	 DWORD PTR _grab_t$5[ebp]

; 2465 :         if (axis == ImGuiAxis_Y)

  00a9f	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00aa3	75 18		 jne	 SHORT $LN42@SliderBeha

; 2466 :             grab_t = 1.0f - grab_t;

  00aa5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00aad	f3 0f 5c 85 a0
	fe ff ff	 subss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00ab5	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _grab_t$5[ebp], xmm0
$LN42@SliderBeha:

; 2467 :         const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

  00abd	51		 push	 ecx
  00abe	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00ac6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00acb	51		 push	 ecx
  00acc	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_max$[ebp]
  00ad4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ad9	51		 push	 ecx
  00ada	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00ae2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ae7	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00aec	83 c4 0c	 add	 esp, 12			; 0000000cH
  00aef	d9 9d 94 fe ff
	ff		 fstp	 DWORD PTR _grab_pos$4[ebp]

; 2468 :         if (axis == ImGuiAxis_X)

  00af5	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00af9	0f 85 8f 00 00
	00		 jne	 $LN43@SliderBeha

; 2469 :             *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

  00aff	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00b02	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00b07	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00b0f	51		 push	 ecx
  00b10	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b15	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00b1a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00b22	f3 0f 58 85 94
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00b2a	51		 push	 ecx
  00b2b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b30	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00b33	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00b38	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00b40	51		 push	 ecx
  00b41	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b46	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00b4b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00b53	f3 0f 10 8d 94
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00b5b	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b5f	51		 push	 ecx
  00b60	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00b65	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00b6b	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00b70	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00b73	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b75	89 0a		 mov	 DWORD PTR [edx], ecx
  00b77	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b7a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b7d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b80	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b83	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b86	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00b89	e9 89 00 00 00	 jmp	 $LN44@SliderBeha
$LN43@SliderBeha:

; 2470 :         else
; 2471 :             *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

  00b8e	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00b93	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00b9b	f3 0f 58 85 94
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00ba3	51		 push	 ecx
  00ba4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ba9	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00bac	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00bb1	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00bb9	51		 push	 ecx
  00bba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bbf	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00bc4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00bcc	f3 0f 10 8d 94
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00bd4	f3 0f 5c c8	 subss	 xmm1, xmm0
  00bd8	51		 push	 ecx
  00bd9	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00bde	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00be1	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00be5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00bed	51		 push	 ecx
  00bee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bf3	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00bf9	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00bfe	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00c01	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c03	89 0a		 mov	 DWORD PTR [edx], ecx
  00c05	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c08	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c0b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c0e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c11	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c14	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN44@SliderBeha:

; 2472 :     }
; 2473 : 
; 2474 :     return value_changed;

  00c17	8a 85 43 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]

; 2475 : }

  00c1d	52		 push	 edx
  00c1e	8b cd		 mov	 ecx, ebp
  00c20	50		 push	 eax
  00c21	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN70@SliderBeha
  00c27	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00c2c	58		 pop	 eax
  00c2d	5a		 pop	 edx
  00c2e	5f		 pop	 edi
  00c2f	5e		 pop	 esi
  00c30	5b		 pop	 ebx
  00c31	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c34	33 cd		 xor	 ecx, ebp
  00c36	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c3b	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  00c41	3b ec		 cmp	 ebp, esp
  00c43	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c48	8b e5		 mov	 esp, ebp
  00c4a	5d		 pop	 ebp
  00c4b	c3		 ret	 0
$LN70@SliderBeha:
  00c4c	01 00 00 00	 DD	 1
  00c50	00 00 00 00	 DD	 $LN69@SliderBeha
$LN69@SliderBeha:
  00c54	0c ff ff ff	 DD	 -244			; ffffff0cH
  00c58	08 00 00 00	 DD	 8
  00c5c	00 00 00 00	 DD	 $LN68@SliderBeha
$LN68@SliderBeha:
  00c60	64		 DB	 100			; 00000064H
  00c61	65		 DB	 101			; 00000065H
  00c62	6c		 DB	 108			; 0000006cH
  00c63	74		 DB	 116			; 00000074H
  00c64	61		 DB	 97			; 00000061H
  00c65	32		 DB	 50			; 00000032H
  00c66	00		 DB	 0
??$SliderBehaviorT@MMM@ImGui@@YA_NABUImRect@@IHPAMMMPBDMHPAU1@@Z ENDP ; ImGui::SliderBehaviorT<float,float,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@_K_JN@ImGui@@YA_NABUImRect@@IHPA_K_K2PBDMHPAU1@@Z
_TEXT	SEGMENT
tv446 = -672						; size = 4
tv932 = -668						; size = 4
tv174 = -668						; size = 8
tv164 = -668						; size = 8
tv89 = -668						; size = 8
tv824 = -664						; size = 4
tv724 = -664						; size = 4
tv535 = -664						; size = 4
tv528 = -664						; size = 4
tv441 = -664						; size = 4
tv287 = -664						; size = 4
tv268 = -664						; size = 4
tv217 = -664						; size = 4
tv205 = -664						; size = 4
tv182 = -664						; size = 4
tv67 = -664						; size = 4
tv74 = -661						; size = 1
tv70 = -661						; size = 1
$T1 = -656						; size = 16
$T2 = -632						; size = 16
$T3 = -608						; size = 16
_grab_pos$4 = -392					; size = 4
_grab_t$5 = -380					; size = 4
_v_new_off_round$6 = -368				; size = 8
_v_new_off_floor$7 = -352				; size = 8
_v_new_off_f$8 = -336					; size = 8
_a$9 = -320						; size = 4
_a$10 = -308						; size = 4
_v_new$11 = -296					; size = 8
_decimal_precision$12 = -280				; size = 4
_delta$13 = -268					; size = 4
_delta2$14 = -256					; size = 8
_mouse_abs_pos$15 = -240				; size = 4
_clicked_t$16 = -228					; size = 4
_set_new_value$17 = -213				; size = 1
_value_changed$ = -201					; size = 1
_linear_dist_max_to_0$18 = -192				; size = 8
_linear_dist_min_to_0$19 = -176				; size = 8
_linear_zero_pos$ = -160				; size = 4
_slider_usable_pos_max$ = -148				; size = 4
_slider_usable_pos_min$ = -136				; size = 4
_slider_usable_sz$ = -124				; size = 4
_v_range$ = -112					; size = 8
_grab_sz$ = -96						; size = 4
_slider_sz$ = -84					; size = 4
_grab_padding$ = -72					; size = 4
_is_power$ = -57					; size = 1
_is_decimal$ = -45					; size = 1
_axis$ = -36						; size = 4
_style$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_data_type$ = 16					; size = 4
_v$ = 20						; size = 4
_v_min$ = 24						; size = 8
_v_max$ = 32						; size = 8
_format$ = 40						; size = 4
_power$ = 44						; size = 4
_flags$ = 48						; size = 4
_out_grab_bb$ = 52					; size = 4
??$SliderBehaviorT@_K_JN@ImGui@@YA_NABUImRect@@IHPA_K_K2PBDMHPAU1@@Z PROC ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>, COMDAT

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 02 00
	00		 sub	 esp, 672		; 000002a0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 60 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-672]
  00012	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2310 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2311 :     const ImGuiStyle& style = g.Style;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00042	89 45 e8	 mov	 DWORD PTR _style$[ebp], eax

; 2312 : 
; 2313 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00045	8b 45 30	 mov	 eax, DWORD PTR _flags$[ebp]
  00048	83 e0 01	 and	 eax, 1
  0004b	74 0c		 je	 SHORT $LN46@SliderBeha
  0004d	c7 85 68 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00057	eb 0a		 jmp	 SHORT $LN47@SliderBeha
$LN46@SliderBeha:
  00059	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN47@SliderBeha:
  00063	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  00069	89 4d dc	 mov	 DWORD PTR _axis$[ebp], ecx

; 2314 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  0006c	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00070	74 0f		 je	 SHORT $LN48@SliderBeha
  00072	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00076	74 09		 je	 SHORT $LN48@SliderBeha
  00078	c6 85 6b fd ff
	ff 00		 mov	 BYTE PTR tv70[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN49@SliderBeha
$LN48@SliderBeha:
  00081	c6 85 6b fd ff
	ff 01		 mov	 BYTE PTR tv70[ebp], 1
$LN49@SliderBeha:
  00088	8a 85 6b fd ff
	ff		 mov	 al, BYTE PTR tv70[ebp]
  0008e	88 45 d3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 2315 :     const bool is_power = (power != 1.0f) && is_decimal;

  00091	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00096	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0009d	9f		 lahf
  0009e	f6 c4 44	 test	 ah, 68			; 00000044H
  000a1	7b 11		 jnp	 SHORT $LN50@SliderBeha
  000a3	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN50@SliderBeha
  000ab	c6 85 6b fd ff
	ff 01		 mov	 BYTE PTR tv74[ebp], 1
  000b2	eb 07		 jmp	 SHORT $LN51@SliderBeha
$LN50@SliderBeha:
  000b4	c6 85 6b fd ff
	ff 00		 mov	 BYTE PTR tv74[ebp], 0
$LN51@SliderBeha:
  000bb	8a 8d 6b fd ff
	ff		 mov	 cl, BYTE PTR tv74[ebp]
  000c1	88 4d c7	 mov	 BYTE PTR _is_power$[ebp], cl

; 2316 : 
; 2317 :     const float grab_padding = 2.0f;

  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000cc	f3 0f 11 45 b8	 movss	 DWORD PTR _grab_padding$[ebp], xmm0

; 2318 :     const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

  000d1	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000d8	83 c1 08	 add	 ecx, 8
  000db	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  000e0	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv441[ebp]
  000e6	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv441[ebp]
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _axis$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000f5	f3 0f 11 85 64
	fd ff ff	 movss	 DWORD PTR tv932[ebp], xmm0
  000fd	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00102	d9 9d 60 fd ff
	ff		 fstp	 DWORD PTR tv446[ebp]
  00108	f3 0f 10 85 64
	fd ff ff	 movss	 xmm0, DWORD PTR tv932[ebp]
  00110	f3 0f 5c 85 60
	fd ff ff	 subss	 xmm0, DWORD PTR tv446[ebp]
  00118	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00120	f3 0f 11 45 ac	 movss	 DWORD PTR _slider_sz$[ebp], xmm0

; 2319 :     float grab_sz = style.GrabMinSize;

  00125	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  00128	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  0012d	f3 0f 11 45 a0	 movss	 DWORD PTR _grab_sz$[ebp], xmm0

; 2320 :     SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

  00132	8b 45 1c	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00135	3b 45 24	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  00138	77 24		 ja	 SHORT $LN52@SliderBeha
  0013a	72 08		 jb	 SHORT $LN68@SliderBeha
  0013c	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  0013f	3b 4d 20	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  00142	73 1a		 jae	 SHORT $LN52@SliderBeha
$LN68@SliderBeha:
  00144	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp]
  00147	2b 55 18	 sub	 edx, DWORD PTR _v_min$[ebp]
  0014a	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  0014d	1b 45 1c	 sbb	 eax, DWORD PTR _v_min$[ebp+4]
  00150	89 95 64 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], edx
  00156	89 85 68 fd ff
	ff		 mov	 DWORD PTR tv89[ebp+4], eax
  0015c	eb 18		 jmp	 SHORT $LN53@SliderBeha
$LN52@SliderBeha:
  0015e	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00161	2b 4d 20	 sub	 ecx, DWORD PTR _v_max$[ebp]
  00164	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  00167	1b 55 24	 sbb	 edx, DWORD PTR _v_max$[ebp+4]
  0016a	89 8d 64 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], ecx
  00170	89 95 68 fd ff
	ff		 mov	 DWORD PTR tv89[ebp+4], edx
$LN53@SliderBeha:
  00176	8b 85 64 fd ff
	ff		 mov	 eax, DWORD PTR tv89[ebp]
  0017c	89 45 90	 mov	 DWORD PTR _v_range$[ebp], eax
  0017f	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR tv89[ebp+4]
  00185	89 4d 94	 mov	 DWORD PTR _v_range$[ebp+4], ecx

; 2321 :     if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

  00188	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0018c	85 c0		 test	 eax, eax
  0018e	75 4b		 jne	 SHORT $LN2@SliderBeha
  00190	83 7d 94 00	 cmp	 DWORD PTR _v_range$[ebp+4], 0
  00194	7c 45		 jl	 SHORT $LN2@SliderBeha
  00196	7f 06		 jg	 SHORT $LN69@SliderBeha
  00198	83 7d 90 00	 cmp	 DWORD PTR _v_range$[ebp], 0
  0019c	72 3d		 jb	 SHORT $LN2@SliderBeha
$LN69@SliderBeha:

; 2322 :         grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

  0019e	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  001a1	51		 push	 ecx
  001a2	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  001a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ac	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  001af	83 c1 01	 add	 ecx, 1
  001b2	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  001b5	83 d2 00	 adc	 edx, 0
  001b8	e8 00 00 00 00	 call	 __ltod3
  001bd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001c1	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _slider_sz$[ebp]
  001c6	f3 0f 5e c8	 divss	 xmm1, xmm0
  001ca	51		 push	 ecx
  001cb	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001d0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001d5	83 c4 08	 add	 esp, 8
  001d8	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]
$LN2@SliderBeha:

; 2323 :     grab_sz = ImMin(grab_sz, slider_sz);

  001db	51		 push	 ecx
  001dc	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e6	51		 push	 ecx
  001e7	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f1	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001f6	83 c4 08	 add	 esp, 8
  001f9	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]

; 2324 :     const float slider_usable_sz = slider_sz - grab_sz;

  001fc	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00201	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00206	f3 0f 11 45 84	 movss	 DWORD PTR _slider_usable_sz$[ebp], xmm0

; 2325 :     const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

  0020b	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  0020e	50		 push	 eax
  0020f	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00212	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00217	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv528[ebp]
  0021d	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv528[ebp]
  00225	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0022d	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00232	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0023a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0023e	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_min$[ebp], xmm0

; 2326 :     const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

  00246	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  00249	50		 push	 eax
  0024a	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  0024d	83 c1 08	 add	 ecx, 8
  00250	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00255	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv535[ebp]
  0025b	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv535[ebp]
  00263	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  0026b	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00270	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  00278	f3 0f 5c c1	 subss	 xmm0, xmm1
  0027c	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_max$[ebp], xmm0

; 2327 : 
; 2328 :     // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2329 :     float linear_zero_pos;   // 0.0->1.0f
; 2330 :     if (is_power && v_min * v_max < 0.0f)

  00284	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00288	85 c0		 test	 eax, eax
  0028a	0f 84 3a 01 00
	00		 je	 $LN3@SliderBeha
  00290	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  00293	50		 push	 eax
  00294	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00297	51		 push	 ecx
  00298	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  0029b	52		 push	 edx
  0029c	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 __allmul
  002a5	8b c8		 mov	 ecx, eax
  002a7	e8 00 00 00 00	 call	 __ultod3
  002ac	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002b0	0f 57 c9	 xorps	 xmm1, xmm1
  002b3	0f 2f c8	 comiss	 xmm1, xmm0
  002b6	0f 86 0e 01 00
	00		 jbe	 $LN3@SliderBeha

; 2331 :     {
; 2332 :         // Different sign
; 2333 :         const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

  002bc	83 7d 1c 00	 cmp	 DWORD PTR _v_min$[ebp+4], 0
  002c0	77 06		 ja	 SHORT $LN70@SliderBeha
  002c2	83 7d 18 00	 cmp	 DWORD PTR _v_min$[ebp], 0
  002c6	72 15		 jb	 SHORT $LN54@SliderBeha
$LN70@SliderBeha:
  002c8	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  002cb	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  002ce	e8 00 00 00 00	 call	 __ultod3
  002d3	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv164[ebp], xmm0
  002db	eb 1a		 jmp	 SHORT $LN55@SliderBeha
$LN54@SliderBeha:
  002dd	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  002e0	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  002e3	e8 00 00 00 00	 call	 __ultod3
  002e8	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  002ef	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv164[ebp], xmm0
$LN55@SliderBeha:
  002f7	f3 0f 5a 45 2c	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  002fc	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00304	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00308	83 ec 08	 sub	 esp, 8
  0030b	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00310	83 ec 08	 sub	 esp, 8
  00313	f2 0f 10 85 64
	fd ff ff	 movsd	 xmm0, QWORD PTR tv164[ebp]
  0031b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00320	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00325	83 c4 10	 add	 esp, 16			; 00000010H
  00328	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _linear_dist_min_to_0$19[ebp]

; 2334 :         const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

  0032e	83 7d 24 00	 cmp	 DWORD PTR _v_max$[ebp+4], 0
  00332	77 06		 ja	 SHORT $LN71@SliderBeha
  00334	83 7d 20 00	 cmp	 DWORD PTR _v_max$[ebp], 0
  00338	72 15		 jb	 SHORT $LN56@SliderBeha
$LN71@SliderBeha:
  0033a	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  0033d	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00340	e8 00 00 00 00	 call	 __ultod3
  00345	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv174[ebp], xmm0
  0034d	eb 1a		 jmp	 SHORT $LN57@SliderBeha
$LN56@SliderBeha:
  0034f	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00352	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00355	e8 00 00 00 00	 call	 __ultod3
  0035a	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  00361	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv174[ebp], xmm0
$LN57@SliderBeha:
  00369	f3 0f 5a 45 2c	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  0036e	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00376	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0037a	83 ec 08	 sub	 esp, 8
  0037d	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00382	83 ec 08	 sub	 esp, 8
  00385	f2 0f 10 85 64
	fd ff ff	 movsd	 xmm0, QWORD PTR tv174[ebp]
  0038d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00392	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00397	83 c4 10	 add	 esp, 16			; 00000010H
  0039a	dd 9d 40 ff ff
	ff		 fstp	 QWORD PTR _linear_dist_max_to_0$18[ebp]

; 2335 :         linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

  003a0	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR _linear_dist_min_to_0$19[ebp]
  003a8	f2 0f 58 85 40
	ff ff ff	 addsd	 xmm0, QWORD PTR _linear_dist_max_to_0$18[ebp]
  003b0	f2 0f 10 8d 50
	ff ff ff	 movsd	 xmm1, QWORD PTR _linear_dist_min_to_0$19[ebp]
  003b8	f2 0f 5e c8	 divsd	 xmm1, xmm0
  003bc	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  003c0	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0

; 2336 :     }

  003c8	eb 44		 jmp	 SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2337 :     else
; 2338 :     {
; 2339 :         // Same sign
; 2340 :         linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

  003ca	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  003cd	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  003d0	e8 00 00 00 00	 call	 __ultod3
  003d5	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003d9	0f 57 c9	 xorps	 xmm1, xmm1
  003dc	0f 2f c8	 comiss	 xmm1, xmm0
  003df	76 12		 jbe	 SHORT $LN58@SliderBeha
  003e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003e9	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv182[ebp], xmm0
  003f1	eb 0b		 jmp	 SHORT $LN59@SliderBeha
$LN58@SliderBeha:
  003f3	0f 57 c0	 xorps	 xmm0, xmm0
  003f6	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv182[ebp], xmm0
$LN59@SliderBeha:
  003fe	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv182[ebp]
  00406	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0
$LN4@SliderBeha:

; 2341 :     }
; 2342 : 
; 2343 :     // Process interacting with the slider
; 2344 :     bool value_changed = false;

  0040e	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 2345 :     if (g.ActiveId == id)

  00415	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00418	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0041e	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00421	0f 85 cc 06 00
	00		 jne	 $LN39@SliderBeha

; 2346 :     {
; 2347 :         bool set_new_value = false;

  00427	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0

; 2348 :         float clicked_t = 0.0f;

  0042e	0f 57 c0	 xorps	 xmm0, xmm0
  00431	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2349 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

  00439	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0043c	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  00443	0f 85 d4 00 00
	00		 jne	 $LN6@SliderBeha

; 2350 :         {
; 2351 :             if (!g.IO.MouseDown[0])

  00449	b8 01 00 00 00	 mov	 eax, 1
  0044e	6b c8 00	 imul	 ecx, eax, 0
  00451	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00454	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  0045c	85 c0		 test	 eax, eax
  0045e	75 0a		 jne	 SHORT $LN8@SliderBeha

; 2352 :             {
; 2353 :                 ClearActiveID();

  00460	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2354 :             }

  00465	e9 ae 00 00 00	 jmp	 $LN9@SliderBeha
$LN8@SliderBeha:

; 2355 :             else
; 2356 :             {
; 2357 :                 const float mouse_abs_pos = g.IO.MousePos[axis];

  0046a	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  0046d	50		 push	 eax
  0046e	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00471	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  00477	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  0047c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00480	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _mouse_abs_pos$15[ebp], xmm0

; 2358 :                 clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

  00488	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  0048d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00494	76 42		 jbe	 SHORT $LN60@SliderBeha
  00496	51		 push	 ecx
  00497	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0049f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a4	51		 push	 ecx
  004a5	0f 57 c0	 xorps	 xmm0, xmm0
  004a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ad	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_abs_pos$15[ebp]
  004b5	f3 0f 5c 85 78
	ff ff ff	 subss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  004bd	f3 0f 5e 45 84	 divss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  004c2	51		 push	 ecx
  004c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c8	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  004cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d0	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv205[ebp]
  004d6	eb 0b		 jmp	 SHORT $LN61@SliderBeha
$LN60@SliderBeha:
  004d8	0f 57 c0	 xorps	 xmm0, xmm0
  004db	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv205[ebp], xmm0
$LN61@SliderBeha:
  004e3	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv205[ebp]
  004eb	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2359 :                 if (axis == ImGuiAxis_Y)

  004f3	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  004f7	75 18		 jne	 SHORT $LN10@SliderBeha

; 2360 :                     clicked_t = 1.0f - clicked_t;

  004f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00501	f3 0f 5c 85 1c
	ff ff ff	 subss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00509	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0
$LN10@SliderBeha:

; 2361 :                 set_new_value = true;

  00511	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1
$LN9@SliderBeha:

; 2362 :             }
; 2363 :         }

  00518	e9 ca 02 00 00	 jmp	 $LN25@SliderBeha
$LN6@SliderBeha:

; 2364 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  0051d	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00520	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  00527	0f 85 ba 02 00
	00		 jne	 $LN25@SliderBeha

; 2365 :         {
; 2366 :             const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

  0052d	51		 push	 ecx
  0052e	0f 57 c0	 xorps	 xmm0, xmm0
  00531	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00536	51		 push	 ecx
  00537	0f 57 c0	 xorps	 xmm0, xmm0
  0053a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0053f	6a 05		 push	 5
  00541	6a 03		 push	 3
  00543	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _delta2$14[ebp]
  00549	50		 push	 eax
  0054a	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  0054f	83 c4 14	 add	 esp, 20			; 00000014H

; 2367 :             float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

  00552	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00556	75 12		 jne	 SHORT $LN62@SliderBeha
  00558	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp]
  00560	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv217[ebp], xmm0
  00568	eb 17		 jmp	 SHORT $LN63@SliderBeha
$LN62@SliderBeha:
  0056a	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp+4]
  00572	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00579	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv217[ebp], xmm0
$LN63@SliderBeha:
  00581	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv217[ebp]
  00589	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2368 :             if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

  00591	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00594	8b 88 e0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6880]
  0059a	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0059d	75 18		 jne	 SHORT $LN12@SliderBeha
  0059f	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  005a2	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  005a9	85 c9		 test	 ecx, ecx
  005ab	75 0a		 jne	 SHORT $LN12@SliderBeha

; 2369 :             {
; 2370 :                 ClearActiveID();

  005ad	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2371 :             }

  005b2	e9 30 02 00 00	 jmp	 $LN25@SliderBeha
$LN12@SliderBeha:

; 2372 :             else if (delta != 0.0f)

  005b7	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  005bf	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  005c6	9f		 lahf
  005c7	f6 c4 44	 test	 ah, 68			; 00000044H
  005ca	0f 8b 17 02 00
	00		 jnp	 $LN25@SliderBeha

; 2373 :             {
; 2374 :                 clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  005d0	51		 push	 ecx
  005d1	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  005d9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005de	51		 push	 ecx
  005df	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  005e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005e9	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  005ec	50		 push	 eax
  005ed	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  005f0	51		 push	 ecx
  005f1	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  005f4	52		 push	 edx
  005f5	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  005f8	50		 push	 eax
  005f9	8b 4d 14	 mov	 ecx, DWORD PTR _v$[ebp]
  005fc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  005ff	52		 push	 edx
  00600	8b 01		 mov	 eax, DWORD PTR [ecx]
  00602	50		 push	 eax
  00603	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00606	51		 push	 ecx
  00607	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
  0060c	83 c4 24	 add	 esp, 36			; 00000024H
  0060f	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]

; 2375 :                 const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00615	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00619	85 c0		 test	 eax, eax
  0061b	74 16		 je	 SHORT $LN64@SliderBeha
  0061d	6a 03		 push	 3
  0061f	8b 4d 28	 mov	 ecx, DWORD PTR _format$[ebp]
  00622	51		 push	 ecx
  00623	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00628	83 c4 08	 add	 esp, 8
  0062b	89 85 68 fd ff
	ff		 mov	 DWORD PTR tv268[ebp], eax
  00631	eb 0a		 jmp	 SHORT $LN65@SliderBeha
$LN64@SliderBeha:
  00633	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv268[ebp], 0
$LN65@SliderBeha:
  0063d	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR tv268[ebp]
  00643	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _decimal_precision$12[ebp], edx

; 2376 :                 if ((decimal_precision > 0) || is_power)

  00649	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _decimal_precision$12[ebp], 0
  00650	7f 08		 jg	 SHORT $LN17@SliderBeha
  00652	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00656	85 c0		 test	 eax, eax
  00658	74 46		 je	 SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2377 :                 {
; 2378 :                     delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

  0065a	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00662	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0066a	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2379 :                     if (IsNavInputDown(ImGuiNavInput_TweakSlow))

  00672	6a 0e		 push	 14			; 0000000eH
  00674	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00679	83 c4 04	 add	 esp, 4
  0067c	0f b6 c0	 movzx	 eax, al
  0067f	85 c0		 test	 eax, eax
  00681	74 18		 je	 SHORT $LN18@SliderBeha

; 2380 :                         delta /= 10.0f;

  00683	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0068b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00693	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN18@SliderBeha:

; 2381 :                 }

  0069b	e9 b0 00 00 00	 jmp	 $LN20@SliderBeha
$LN15@SliderBeha:

; 2382 :                 else
; 2383 :                 {
; 2384 :                     if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

  006a0	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  006a3	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  006a6	e8 00 00 00 00	 call	 __ltod3
  006ab	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006af	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@c2c80000
  006b6	72 1c		 jb	 SHORT $LN22@SliderBeha
  006b8	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  006bb	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  006be	e8 00 00 00 00	 call	 __ltod3
  006c3	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006c7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@42c80000
  006cf	0f 2f c8	 comiss	 xmm1, xmm0
  006d2	73 11		 jae	 SHORT $LN21@SliderBeha
$LN22@SliderBeha:
  006d4	6a 0e		 push	 14			; 0000000eH
  006d6	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  006db	83 c4 04	 add	 esp, 4
  006de	0f b6 c0	 movzx	 eax, al
  006e1	85 c0		 test	 eax, eax
  006e3	74 53		 je	 SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2385 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

  006e5	0f 57 c0	 xorps	 xmm0, xmm0
  006e8	0f 2f 85 f4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  006ef	76 12		 jbe	 SHORT $LN66@SliderBeha
  006f1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  006f9	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv287[ebp], xmm0
  00701	eb 10		 jmp	 SHORT $LN67@SliderBeha
$LN66@SliderBeha:
  00703	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0070b	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv287[ebp], xmm0
$LN67@SliderBeha:
  00713	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  00716	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  00719	e8 00 00 00 00	 call	 __ltod3
  0071e	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00722	f3 0f 10 8d 68
	fd ff ff	 movss	 xmm1, DWORD PTR tv287[ebp]
  0072a	f3 0f 5e c8	 divss	 xmm1, xmm0
  0072e	f3 0f 11 8d f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm1
  00736	eb 18		 jmp	 SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2386 :                     else
; 2387 :                         delta /= 100.0f;

  00738	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00740	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00748	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN20@SliderBeha:

; 2388 :                 }
; 2389 :                 if (IsNavInputDown(ImGuiNavInput_TweakFast))

  00750	6a 0f		 push	 15			; 0000000fH
  00752	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00757	83 c4 04	 add	 esp, 4
  0075a	0f b6 c0	 movzx	 eax, al
  0075d	85 c0		 test	 eax, eax
  0075f	74 18		 je	 SHORT $LN23@SliderBeha

; 2390 :                     delta *= 10.0f;

  00761	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00769	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00771	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN23@SliderBeha:

; 2391 :                 set_new_value = true;

  00779	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1

; 2392 :                 if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

  00780	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00788	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0078f	72 11		 jb	 SHORT $LN27@SliderBeha
  00791	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00799	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  007a0	77 18		 ja	 SHORT $LN26@SliderBeha
$LN27@SliderBeha:
  007a2	0f 57 c0	 xorps	 xmm0, xmm0
  007a5	0f 2f 85 1c ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007ac	72 15		 jb	 SHORT $LN24@SliderBeha
  007ae	0f 57 c0	 xorps	 xmm0, xmm0
  007b1	0f 2f 85 f4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  007b8	76 09		 jbe	 SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2393 :                     set_new_value = false;

  007ba	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0
  007c1	eb 24		 jmp	 SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2394 :                 else
; 2395 :                     clicked_t = ImSaturate(clicked_t + delta);

  007c3	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007cb	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _delta$13[ebp]
  007d3	51		 push	 ecx
  007d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007d9	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  007de	83 c4 04	 add	 esp, 4
  007e1	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]
$LN25@SliderBeha:

; 2396 :             }
; 2397 :         }
; 2398 : 
; 2399 :         if (set_new_value)

  007e7	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _set_new_value$17[ebp]
  007ee	85 c0		 test	 eax, eax
  007f0	0f 84 fd 02 00
	00		 je	 $LN39@SliderBeha

; 2400 :         {
; 2401 :             TYPE v_new;
; 2402 :             if (is_power)

  007f6	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  007fa	85 c0		 test	 eax, eax
  007fc	0f 84 84 01 00
	00		 je	 $LN29@SliderBeha

; 2403 :             {
; 2404 :                 // Account for power curve scale on both sides of the zero
; 2405 :                 if (clicked_t < linear_zero_pos)

  00802	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0080a	0f 2f 85 1c ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00811	0f 86 90 00 00
	00		 jbe	 $LN31@SliderBeha

; 2406 :                 {
; 2407 :                     // Negative: rescale to the negative range before powering
; 2408 :                     float a = 1.0f - (clicked_t / linear_zero_pos);

  00817	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0081f	f3 0f 5e 85 60
	ff ff ff	 divss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00827	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0082f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00833	f3 0f 11 8d cc
	fe ff ff	 movss	 DWORD PTR _a$10[ebp], xmm1

; 2409 :                     a = ImPow(a, power);

  0083b	51		 push	 ecx
  0083c	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00841	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00846	51		 push	 ecx
  00847	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  0084f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00854	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00859	83 c4 08	 add	 esp, 8
  0085c	d9 9d cc fe ff
	ff		 fstp	 DWORD PTR _a$10[ebp]

; 2410 :                     v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

  00862	51		 push	 ecx
  00863	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  0086b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00870	8b 45 1c	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00873	50		 push	 eax
  00874	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00877	51		 push	 ecx
  00878	6a 00		 push	 0
  0087a	6a 00		 push	 0
  0087c	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  0087f	52		 push	 edx
  00880	8b 45 20	 mov	 eax, DWORD PTR _v_max$[ebp]
  00883	50		 push	 eax
  00884	e8 00 00 00 00	 call	 ??$ImMin@_K@@YA_K_K0@Z	; ImMin<unsigned __int64>
  00889	83 c4 10	 add	 esp, 16			; 00000010H
  0088c	52		 push	 edx
  0088d	50		 push	 eax
  0088e	e8 00 00 00 00	 call	 ??$ImLerp@_K@@YA_K_K0M@Z ; ImLerp<unsigned __int64>
  00893	83 c4 14	 add	 esp, 20			; 00000014H
  00896	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  0089c	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx

; 2411 :                 }

  008a2	e9 da 00 00 00	 jmp	 $LN32@SliderBeha
$LN31@SliderBeha:

; 2412 :                 else
; 2413 :                 {
; 2414 :                     // Positive: rescale to the positive range before powering
; 2415 :                     float a;
; 2416 :                     if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

  008a7	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  008af	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  008b7	51		 push	 ecx
  008b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008bd	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  008c2	83 c4 04	 add	 esp, 4
  008c5	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv724[ebp]
  008cb	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv724[ebp]
  008d3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@358637bd
  008da	76 2e		 jbe	 SHORT $LN33@SliderBeha

; 2417 :                         a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

  008dc	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  008e4	f3 0f 5c 85 60
	ff ff ff	 subss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  008ec	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  008f4	f3 0f 5c 8d 60
	ff ff ff	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  008fc	f3 0f 5e c1	 divss	 xmm0, xmm1
  00900	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
  00908	eb 10		 jmp	 SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2418 :                     else
; 2419 :                         a = clicked_t;

  0090a	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00912	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
$LN34@SliderBeha:

; 2420 :                     a = ImPow(a, power);

  0091a	51		 push	 ecx
  0091b	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00920	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00925	51		 push	 ecx
  00926	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  0092e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00933	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00938	83 c4 08	 add	 esp, 8
  0093b	d9 9d c0 fe ff
	ff		 fstp	 DWORD PTR _a$9[ebp]

; 2421 :                     v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

  00941	51		 push	 ecx
  00942	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  0094a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0094f	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  00952	50		 push	 eax
  00953	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00956	51		 push	 ecx
  00957	6a 00		 push	 0
  00959	6a 00		 push	 0
  0095b	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  0095e	52		 push	 edx
  0095f	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00962	50		 push	 eax
  00963	e8 00 00 00 00	 call	 ??$ImMax@_K@@YA_K_K0@Z	; ImMax<unsigned __int64>
  00968	83 c4 10	 add	 esp, 16			; 00000010H
  0096b	52		 push	 edx
  0096c	50		 push	 eax
  0096d	e8 00 00 00 00	 call	 ??$ImLerp@_K@@YA_K_K0M@Z ; ImLerp<unsigned __int64>
  00972	83 c4 14	 add	 esp, 20			; 00000014H
  00975	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  0097b	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx
$LN32@SliderBeha:

; 2422 :                 }
; 2423 :             }

  00981	e9 fe 00 00 00	 jmp	 $LN38@SliderBeha
$LN29@SliderBeha:

; 2424 :             else
; 2425 :             {
; 2426 :                 // Linear slider
; 2427 :                 if (is_decimal)

  00986	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0098a	85 c0		 test	 eax, eax
  0098c	74 37		 je	 SHORT $LN35@SliderBeha

; 2428 :                 {
; 2429 :                     v_new = ImLerp(v_min, v_max, clicked_t);

  0098e	51		 push	 ecx
  0098f	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00997	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0099c	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  0099f	50		 push	 eax
  009a0	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  009a3	51		 push	 ecx
  009a4	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  009a7	52		 push	 edx
  009a8	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  009ab	50		 push	 eax
  009ac	e8 00 00 00 00	 call	 ??$ImLerp@_K@@YA_K_K0M@Z ; ImLerp<unsigned __int64>
  009b1	83 c4 14	 add	 esp, 20			; 00000014H
  009b4	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  009ba	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx

; 2430 :                 }

  009c0	e9 bf 00 00 00	 jmp	 $LN38@SliderBeha
$LN35@SliderBeha:

; 2431 :                 else
; 2432 :                 {
; 2433 :                     // For integer values we want the clicking position to match the grab box so we round above
; 2434 :                     // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2435 :                     FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

  009c5	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  009c8	2b 4d 18	 sub	 ecx, DWORD PTR _v_min$[ebp]
  009cb	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  009ce	1b 55 1c	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  009d1	e8 00 00 00 00	 call	 __ultod3
  009d6	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  009da	f3 0f 59 85 1c
	ff ff ff	 mulss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  009e2	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  009e6	f2 0f 11 85 b0
	fe ff ff	 movsd	 QWORD PTR _v_new_off_f$8[ebp], xmm0

; 2436 :                     TYPE v_new_off_floor = (TYPE)(v_new_off_f);

  009ee	f2 0f 10 85 b0
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new_off_f$8[ebp]
  009f6	e8 00 00 00 00	 call	 __dtoul3
  009fb	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _v_new_off_floor$7[ebp], eax
  00a01	89 95 a4 fe ff
	ff		 mov	 DWORD PTR _v_new_off_floor$7[ebp+4], edx

; 2437 :                     TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

  00a07	f2 0f 10 85 b0
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new_off_f$8[ebp]
  00a0f	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00a17	e8 00 00 00 00	 call	 __dtoul3
  00a1c	89 85 90 fe ff
	ff		 mov	 DWORD PTR _v_new_off_round$6[ebp], eax
  00a22	89 95 94 fe ff
	ff		 mov	 DWORD PTR _v_new_off_round$6[ebp+4], edx

; 2438 :                     if (v_new_off_floor < v_new_off_round)

  00a28	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _v_new_off_floor$7[ebp+4]
  00a2e	3b 85 94 fe ff
	ff		 cmp	 eax, DWORD PTR _v_new_off_round$6[ebp+4]
  00a34	77 30		 ja	 SHORT $LN37@SliderBeha
  00a36	72 0e		 jb	 SHORT $LN72@SliderBeha
  00a38	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new_off_floor$7[ebp]
  00a3e	3b 8d 90 fe ff
	ff		 cmp	 ecx, DWORD PTR _v_new_off_round$6[ebp]
  00a44	73 20		 jae	 SHORT $LN37@SliderBeha
$LN72@SliderBeha:

; 2439 :                         v_new = v_min + v_new_off_round;

  00a46	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00a49	03 85 90 fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_round$6[ebp]
  00a4f	8b 4d 1c	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00a52	13 8d 94 fe ff
	ff		 adc	 ecx, DWORD PTR _v_new_off_round$6[ebp+4]
  00a58	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  00a5e	89 8d dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], ecx
  00a64	eb 1e		 jmp	 SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2440 :                     else
; 2441 :                         v_new = v_min + v_new_off_floor;

  00a66	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00a69	03 85 a0 fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_floor$7[ebp]
  00a6f	8b 4d 1c	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00a72	13 8d a4 fe ff
	ff		 adc	 ecx, DWORD PTR _v_new_off_floor$7[ebp+4]
  00a78	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  00a7e	89 8d dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], ecx
$LN38@SliderBeha:

; 2442 :                 }
; 2443 :             }
; 2444 : 
; 2445 :             // Round to user desired precision based on format string
; 2446 :             v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

  00a84	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _v_new$11[ebp+4]
  00a8a	50		 push	 eax
  00a8b	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new$11[ebp]
  00a91	51		 push	 ecx
  00a92	8b 55 10	 mov	 edx, DWORD PTR _data_type$[ebp]
  00a95	52		 push	 edx
  00a96	8b 45 28	 mov	 eax, DWORD PTR _format$[ebp]
  00a99	50		 push	 eax
  00a9a	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
  00a9f	83 c4 10	 add	 esp, 16			; 00000010H
  00aa2	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  00aa8	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx

; 2447 : 
; 2448 :             // Apply result
; 2449 :             if (*v != v_new)

  00aae	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00ab1	89 85 68 fd ff
	ff		 mov	 DWORD PTR tv824[ebp], eax
  00ab7	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR tv824[ebp]
  00abd	8b 11		 mov	 edx, DWORD PTR [ecx]
  00abf	3b 95 d8 fe ff
	ff		 cmp	 edx, DWORD PTR _v_new$11[ebp]
  00ac5	75 11		 jne	 SHORT $LN73@SliderBeha
  00ac7	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR tv824[ebp]
  00acd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ad0	3b 8d dc fe ff
	ff		 cmp	 ecx, DWORD PTR _v_new$11[ebp+4]
  00ad6	74 1b		 je	 SHORT $LN39@SliderBeha
$LN73@SliderBeha:

; 2450 :             {
; 2451 :                 *v = v_new;

  00ad8	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00adb	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new$11[ebp]
  00ae1	89 08		 mov	 DWORD PTR [eax], ecx
  00ae3	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _v_new$11[ebp+4]
  00ae9	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2452 :                 value_changed = true;

  00aec	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN39@SliderBeha:

; 2453 :             }
; 2454 :         }
; 2455 :     }
; 2456 : 
; 2457 :     if (slider_sz < 1.0f)

  00af3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00afb	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00aff	76 31		 jbe	 SHORT $LN40@SliderBeha

; 2458 :     {
; 2459 :         *out_grab_bb = ImRect(bb.Min, bb.Min);

  00b01	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00b04	50		 push	 eax
  00b05	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00b08	51		 push	 ecx
  00b09	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00b0f	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
  00b14	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00b17	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b19	89 0a		 mov	 DWORD PTR [edx], ecx
  00b1b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b1e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b21	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b24	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b27	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b2a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2460 :     }

  00b2d	e9 bd 01 00 00	 jmp	 $LN44@SliderBeha
$LN40@SliderBeha:

; 2461 :     else
; 2462 :     {
; 2463 :         // Output grab position so it can be displayed by the caller
; 2464 :         float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  00b32	51		 push	 ecx
  00b33	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00b3b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b40	51		 push	 ecx
  00b41	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00b46	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b4b	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  00b4e	50		 push	 eax
  00b4f	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00b52	51		 push	 ecx
  00b53	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  00b56	52		 push	 edx
  00b57	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00b5a	50		 push	 eax
  00b5b	8b 4d 14	 mov	 ecx, DWORD PTR _v$[ebp]
  00b5e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00b61	52		 push	 edx
  00b62	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b64	50		 push	 eax
  00b65	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00b68	51		 push	 ecx
  00b69	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@_KN@ImGui@@YAMH_K00MM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned __int64,double>
  00b6e	83 c4 24	 add	 esp, 36			; 00000024H
  00b71	d9 9d 84 fe ff
	ff		 fstp	 DWORD PTR _grab_t$5[ebp]

; 2465 :         if (axis == ImGuiAxis_Y)

  00b77	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00b7b	75 18		 jne	 SHORT $LN42@SliderBeha

; 2466 :             grab_t = 1.0f - grab_t;

  00b7d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b85	f3 0f 5c 85 84
	fe ff ff	 subss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00b8d	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR _grab_t$5[ebp], xmm0
$LN42@SliderBeha:

; 2467 :         const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

  00b95	51		 push	 ecx
  00b96	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00b9e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ba3	51		 push	 ecx
  00ba4	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_max$[ebp]
  00bac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bb1	51		 push	 ecx
  00bb2	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00bba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bbf	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00bc4	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bc7	d9 9d 78 fe ff
	ff		 fstp	 DWORD PTR _grab_pos$4[ebp]

; 2468 :         if (axis == ImGuiAxis_X)

  00bcd	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00bd1	0f 85 8f 00 00
	00		 jne	 $LN43@SliderBeha

; 2469 :             *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

  00bd7	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00bda	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00bdf	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00be7	51		 push	 ecx
  00be8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bed	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00bf2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00bfa	f3 0f 58 85 78
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00c02	51		 push	 ecx
  00c03	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c08	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00c0b	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00c10	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00c18	51		 push	 ecx
  00c19	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c1e	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c23	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00c2b	f3 0f 10 8d 78
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00c33	f3 0f 5c c8	 subss	 xmm1, xmm0
  00c37	51		 push	 ecx
  00c38	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00c3d	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00c43	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00c48	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00c4b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c4d	89 0a		 mov	 DWORD PTR [edx], ecx
  00c4f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c52	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c55	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c58	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c5b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c5e	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00c61	e9 89 00 00 00	 jmp	 $LN44@SliderBeha
$LN43@SliderBeha:

; 2470 :         else
; 2471 :             *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

  00c66	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c6b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00c73	f3 0f 58 85 78
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00c7b	51		 push	 ecx
  00c7c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c81	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00c84	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00c89	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00c91	51		 push	 ecx
  00c92	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c97	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c9c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00ca4	f3 0f 10 8d 78
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00cac	f3 0f 5c c8	 subss	 xmm1, xmm0
  00cb0	51		 push	 ecx
  00cb1	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00cb6	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00cb9	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00cbd	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00cc5	51		 push	 ecx
  00cc6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ccb	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00cd1	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00cd6	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00cd9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cdb	89 0a		 mov	 DWORD PTR [edx], ecx
  00cdd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ce0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ce3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ce6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00ce9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00cec	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN44@SliderBeha:

; 2472 :     }
; 2473 : 
; 2474 :     return value_changed;

  00cef	8a 85 37 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]

; 2475 : }

  00cf5	52		 push	 edx
  00cf6	8b cd		 mov	 ecx, ebp
  00cf8	50		 push	 eax
  00cf9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN76@SliderBeha
  00cff	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00d04	58		 pop	 eax
  00d05	5a		 pop	 edx
  00d06	5f		 pop	 edi
  00d07	5e		 pop	 esi
  00d08	5b		 pop	 ebx
  00d09	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d0c	33 cd		 xor	 ecx, ebp
  00d0e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d13	81 c4 a0 02 00
	00		 add	 esp, 672		; 000002a0H
  00d19	3b ec		 cmp	 ebp, esp
  00d1b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d20	8b e5		 mov	 esp, ebp
  00d22	5d		 pop	 ebp
  00d23	c3		 ret	 0
$LN76@SliderBeha:
  00d24	01 00 00 00	 DD	 1
  00d28	00 00 00 00	 DD	 $LN75@SliderBeha
$LN75@SliderBeha:
  00d2c	00 ff ff ff	 DD	 -256			; ffffff00H
  00d30	08 00 00 00	 DD	 8
  00d34	00 00 00 00	 DD	 $LN74@SliderBeha
$LN74@SliderBeha:
  00d38	64		 DB	 100			; 00000064H
  00d39	65		 DB	 101			; 00000065H
  00d3a	6c		 DB	 108			; 0000006cH
  00d3b	74		 DB	 116			; 00000074H
  00d3c	61		 DB	 97			; 00000061H
  00d3d	32		 DB	 50			; 00000032H
  00d3e	00		 DB	 0
??$SliderBehaviorT@_K_JN@ImGui@@YA_NABUImRect@@IHPA_K_K2PBDMHPAU1@@Z ENDP ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@_J_JN@ImGui@@YA_NABUImRect@@IHPA_J_J2PBDMHPAU1@@Z
_TEXT	SEGMENT
tv446 = -672						; size = 4
tv934 = -668						; size = 4
tv174 = -668						; size = 8
tv164 = -668						; size = 8
tv89 = -668						; size = 8
tv826 = -664						; size = 4
tv726 = -664						; size = 4
tv535 = -664						; size = 4
tv528 = -664						; size = 4
tv441 = -664						; size = 4
tv287 = -664						; size = 4
tv268 = -664						; size = 4
tv217 = -664						; size = 4
tv205 = -664						; size = 4
tv182 = -664						; size = 4
tv67 = -664						; size = 4
tv74 = -661						; size = 1
tv70 = -661						; size = 1
$T1 = -656						; size = 16
$T2 = -632						; size = 16
$T3 = -608						; size = 16
_grab_pos$4 = -392					; size = 4
_grab_t$5 = -380					; size = 4
_v_new_off_round$6 = -368				; size = 8
_v_new_off_floor$7 = -352				; size = 8
_v_new_off_f$8 = -336					; size = 8
_a$9 = -320						; size = 4
_a$10 = -308						; size = 4
_v_new$11 = -296					; size = 8
_decimal_precision$12 = -280				; size = 4
_delta$13 = -268					; size = 4
_delta2$14 = -256					; size = 8
_mouse_abs_pos$15 = -240				; size = 4
_clicked_t$16 = -228					; size = 4
_set_new_value$17 = -213				; size = 1
_value_changed$ = -201					; size = 1
_linear_dist_max_to_0$18 = -192				; size = 8
_linear_dist_min_to_0$19 = -176				; size = 8
_linear_zero_pos$ = -160				; size = 4
_slider_usable_pos_max$ = -148				; size = 4
_slider_usable_pos_min$ = -136				; size = 4
_slider_usable_sz$ = -124				; size = 4
_v_range$ = -112					; size = 8
_grab_sz$ = -96						; size = 4
_slider_sz$ = -84					; size = 4
_grab_padding$ = -72					; size = 4
_is_power$ = -57					; size = 1
_is_decimal$ = -45					; size = 1
_axis$ = -36						; size = 4
_style$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_data_type$ = 16					; size = 4
_v$ = 20						; size = 4
_v_min$ = 24						; size = 8
_v_max$ = 32						; size = 8
_format$ = 40						; size = 4
_power$ = 44						; size = 4
_flags$ = 48						; size = 4
_out_grab_bb$ = 52					; size = 4
??$SliderBehaviorT@_J_JN@ImGui@@YA_NABUImRect@@IHPA_J_J2PBDMHPAU1@@Z PROC ; ImGui::SliderBehaviorT<__int64,__int64,double>, COMDAT

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 02 00
	00		 sub	 esp, 672		; 000002a0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 60 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-672]
  00012	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2310 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2311 :     const ImGuiStyle& style = g.Style;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00042	89 45 e8	 mov	 DWORD PTR _style$[ebp], eax

; 2312 : 
; 2313 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00045	8b 45 30	 mov	 eax, DWORD PTR _flags$[ebp]
  00048	83 e0 01	 and	 eax, 1
  0004b	74 0c		 je	 SHORT $LN46@SliderBeha
  0004d	c7 85 68 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00057	eb 0a		 jmp	 SHORT $LN47@SliderBeha
$LN46@SliderBeha:
  00059	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN47@SliderBeha:
  00063	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  00069	89 4d dc	 mov	 DWORD PTR _axis$[ebp], ecx

; 2314 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  0006c	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00070	74 0f		 je	 SHORT $LN48@SliderBeha
  00072	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00076	74 09		 je	 SHORT $LN48@SliderBeha
  00078	c6 85 6b fd ff
	ff 00		 mov	 BYTE PTR tv70[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN49@SliderBeha
$LN48@SliderBeha:
  00081	c6 85 6b fd ff
	ff 01		 mov	 BYTE PTR tv70[ebp], 1
$LN49@SliderBeha:
  00088	8a 85 6b fd ff
	ff		 mov	 al, BYTE PTR tv70[ebp]
  0008e	88 45 d3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 2315 :     const bool is_power = (power != 1.0f) && is_decimal;

  00091	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00096	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0009d	9f		 lahf
  0009e	f6 c4 44	 test	 ah, 68			; 00000044H
  000a1	7b 11		 jnp	 SHORT $LN50@SliderBeha
  000a3	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN50@SliderBeha
  000ab	c6 85 6b fd ff
	ff 01		 mov	 BYTE PTR tv74[ebp], 1
  000b2	eb 07		 jmp	 SHORT $LN51@SliderBeha
$LN50@SliderBeha:
  000b4	c6 85 6b fd ff
	ff 00		 mov	 BYTE PTR tv74[ebp], 0
$LN51@SliderBeha:
  000bb	8a 8d 6b fd ff
	ff		 mov	 cl, BYTE PTR tv74[ebp]
  000c1	88 4d c7	 mov	 BYTE PTR _is_power$[ebp], cl

; 2316 : 
; 2317 :     const float grab_padding = 2.0f;

  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000cc	f3 0f 11 45 b8	 movss	 DWORD PTR _grab_padding$[ebp], xmm0

; 2318 :     const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

  000d1	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000d8	83 c1 08	 add	 ecx, 8
  000db	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  000e0	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv441[ebp]
  000e6	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv441[ebp]
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _axis$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000f5	f3 0f 11 85 64
	fd ff ff	 movss	 DWORD PTR tv934[ebp], xmm0
  000fd	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00102	d9 9d 60 fd ff
	ff		 fstp	 DWORD PTR tv446[ebp]
  00108	f3 0f 10 85 64
	fd ff ff	 movss	 xmm0, DWORD PTR tv934[ebp]
  00110	f3 0f 5c 85 60
	fd ff ff	 subss	 xmm0, DWORD PTR tv446[ebp]
  00118	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00120	f3 0f 11 45 ac	 movss	 DWORD PTR _slider_sz$[ebp], xmm0

; 2319 :     float grab_sz = style.GrabMinSize;

  00125	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  00128	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  0012d	f3 0f 11 45 a0	 movss	 DWORD PTR _grab_sz$[ebp], xmm0

; 2320 :     SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

  00132	8b 45 1c	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00135	3b 45 24	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  00138	7f 24		 jg	 SHORT $LN52@SliderBeha
  0013a	7c 08		 jl	 SHORT $LN68@SliderBeha
  0013c	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  0013f	3b 4d 20	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  00142	73 1a		 jae	 SHORT $LN52@SliderBeha
$LN68@SliderBeha:
  00144	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp]
  00147	2b 55 18	 sub	 edx, DWORD PTR _v_min$[ebp]
  0014a	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  0014d	1b 45 1c	 sbb	 eax, DWORD PTR _v_min$[ebp+4]
  00150	89 95 64 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], edx
  00156	89 85 68 fd ff
	ff		 mov	 DWORD PTR tv89[ebp+4], eax
  0015c	eb 18		 jmp	 SHORT $LN53@SliderBeha
$LN52@SliderBeha:
  0015e	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00161	2b 4d 20	 sub	 ecx, DWORD PTR _v_max$[ebp]
  00164	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  00167	1b 55 24	 sbb	 edx, DWORD PTR _v_max$[ebp+4]
  0016a	89 8d 64 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], ecx
  00170	89 95 68 fd ff
	ff		 mov	 DWORD PTR tv89[ebp+4], edx
$LN53@SliderBeha:
  00176	8b 85 64 fd ff
	ff		 mov	 eax, DWORD PTR tv89[ebp]
  0017c	89 45 90	 mov	 DWORD PTR _v_range$[ebp], eax
  0017f	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR tv89[ebp+4]
  00185	89 4d 94	 mov	 DWORD PTR _v_range$[ebp+4], ecx

; 2321 :     if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

  00188	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0018c	85 c0		 test	 eax, eax
  0018e	75 4b		 jne	 SHORT $LN2@SliderBeha
  00190	83 7d 94 00	 cmp	 DWORD PTR _v_range$[ebp+4], 0
  00194	7c 45		 jl	 SHORT $LN2@SliderBeha
  00196	7f 06		 jg	 SHORT $LN69@SliderBeha
  00198	83 7d 90 00	 cmp	 DWORD PTR _v_range$[ebp], 0
  0019c	72 3d		 jb	 SHORT $LN2@SliderBeha
$LN69@SliderBeha:

; 2322 :         grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

  0019e	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  001a1	51		 push	 ecx
  001a2	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  001a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ac	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  001af	83 c1 01	 add	 ecx, 1
  001b2	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  001b5	83 d2 00	 adc	 edx, 0
  001b8	e8 00 00 00 00	 call	 __ltod3
  001bd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001c1	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _slider_sz$[ebp]
  001c6	f3 0f 5e c8	 divss	 xmm1, xmm0
  001ca	51		 push	 ecx
  001cb	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001d0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001d5	83 c4 08	 add	 esp, 8
  001d8	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]
$LN2@SliderBeha:

; 2323 :     grab_sz = ImMin(grab_sz, slider_sz);

  001db	51		 push	 ecx
  001dc	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e6	51		 push	 ecx
  001e7	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f1	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001f6	83 c4 08	 add	 esp, 8
  001f9	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]

; 2324 :     const float slider_usable_sz = slider_sz - grab_sz;

  001fc	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00201	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00206	f3 0f 11 45 84	 movss	 DWORD PTR _slider_usable_sz$[ebp], xmm0

; 2325 :     const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

  0020b	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  0020e	50		 push	 eax
  0020f	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00212	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00217	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv528[ebp]
  0021d	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv528[ebp]
  00225	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0022d	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00232	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0023a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0023e	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_min$[ebp], xmm0

; 2326 :     const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

  00246	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  00249	50		 push	 eax
  0024a	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  0024d	83 c1 08	 add	 ecx, 8
  00250	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00255	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv535[ebp]
  0025b	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv535[ebp]
  00263	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  0026b	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00270	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  00278	f3 0f 5c c1	 subss	 xmm0, xmm1
  0027c	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_max$[ebp], xmm0

; 2327 : 
; 2328 :     // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2329 :     float linear_zero_pos;   // 0.0->1.0f
; 2330 :     if (is_power && v_min * v_max < 0.0f)

  00284	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00288	85 c0		 test	 eax, eax
  0028a	0f 84 3e 01 00
	00		 je	 $LN3@SliderBeha
  00290	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  00293	50		 push	 eax
  00294	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00297	51		 push	 ecx
  00298	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  0029b	52		 push	 edx
  0029c	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 __allmul
  002a5	8b c8		 mov	 ecx, eax
  002a7	e8 00 00 00 00	 call	 __ltod3
  002ac	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002b0	0f 57 c9	 xorps	 xmm1, xmm1
  002b3	0f 2f c8	 comiss	 xmm1, xmm0
  002b6	0f 86 12 01 00
	00		 jbe	 $LN3@SliderBeha

; 2331 :     {
; 2332 :         // Different sign
; 2333 :         const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

  002bc	83 7d 1c 00	 cmp	 DWORD PTR _v_min$[ebp+4], 0
  002c0	7c 1d		 jl	 SHORT $LN54@SliderBeha
  002c2	7f 06		 jg	 SHORT $LN70@SliderBeha
  002c4	83 7d 18 00	 cmp	 DWORD PTR _v_min$[ebp], 0
  002c8	72 15		 jb	 SHORT $LN54@SliderBeha
$LN70@SliderBeha:
  002ca	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  002cd	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  002d0	e8 00 00 00 00	 call	 __ltod3
  002d5	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv164[ebp], xmm0
  002dd	eb 1a		 jmp	 SHORT $LN55@SliderBeha
$LN54@SliderBeha:
  002df	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  002e2	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  002e5	e8 00 00 00 00	 call	 __ltod3
  002ea	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  002f1	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv164[ebp], xmm0
$LN55@SliderBeha:
  002f9	f3 0f 5a 45 2c	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  002fe	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00306	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0030a	83 ec 08	 sub	 esp, 8
  0030d	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00312	83 ec 08	 sub	 esp, 8
  00315	f2 0f 10 85 64
	fd ff ff	 movsd	 xmm0, QWORD PTR tv164[ebp]
  0031d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00322	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00327	83 c4 10	 add	 esp, 16			; 00000010H
  0032a	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _linear_dist_min_to_0$19[ebp]

; 2334 :         const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

  00330	83 7d 24 00	 cmp	 DWORD PTR _v_max$[ebp+4], 0
  00334	7c 1d		 jl	 SHORT $LN56@SliderBeha
  00336	7f 06		 jg	 SHORT $LN71@SliderBeha
  00338	83 7d 20 00	 cmp	 DWORD PTR _v_max$[ebp], 0
  0033c	72 15		 jb	 SHORT $LN56@SliderBeha
$LN71@SliderBeha:
  0033e	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00341	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00344	e8 00 00 00 00	 call	 __ltod3
  00349	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv174[ebp], xmm0
  00351	eb 1a		 jmp	 SHORT $LN57@SliderBeha
$LN56@SliderBeha:
  00353	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00356	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00359	e8 00 00 00 00	 call	 __ltod3
  0035e	0f 57 05 00 00
	00 00		 xorps	 xmm0, QWORD PTR __xmm@80000000000000008000000000000000
  00365	f2 0f 11 85 64
	fd ff ff	 movsd	 QWORD PTR tv174[ebp], xmm0
$LN57@SliderBeha:
  0036d	f3 0f 5a 45 2c	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  00372	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0037a	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0037e	83 ec 08	 sub	 esp, 8
  00381	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00386	83 ec 08	 sub	 esp, 8
  00389	f2 0f 10 85 64
	fd ff ff	 movsd	 xmm0, QWORD PTR tv174[ebp]
  00391	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00396	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  0039b	83 c4 10	 add	 esp, 16			; 00000010H
  0039e	dd 9d 40 ff ff
	ff		 fstp	 QWORD PTR _linear_dist_max_to_0$18[ebp]

; 2335 :         linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

  003a4	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR _linear_dist_min_to_0$19[ebp]
  003ac	f2 0f 58 85 40
	ff ff ff	 addsd	 xmm0, QWORD PTR _linear_dist_max_to_0$18[ebp]
  003b4	f2 0f 10 8d 50
	ff ff ff	 movsd	 xmm1, QWORD PTR _linear_dist_min_to_0$19[ebp]
  003bc	f2 0f 5e c8	 divsd	 xmm1, xmm0
  003c0	f2 0f 5a c1	 cvtsd2ss xmm0, xmm1
  003c4	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0

; 2336 :     }

  003cc	eb 44		 jmp	 SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2337 :     else
; 2338 :     {
; 2339 :         // Same sign
; 2340 :         linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

  003ce	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  003d1	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  003d4	e8 00 00 00 00	 call	 __ltod3
  003d9	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003dd	0f 57 c9	 xorps	 xmm1, xmm1
  003e0	0f 2f c8	 comiss	 xmm1, xmm0
  003e3	76 12		 jbe	 SHORT $LN58@SliderBeha
  003e5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003ed	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv182[ebp], xmm0
  003f5	eb 0b		 jmp	 SHORT $LN59@SliderBeha
$LN58@SliderBeha:
  003f7	0f 57 c0	 xorps	 xmm0, xmm0
  003fa	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv182[ebp], xmm0
$LN59@SliderBeha:
  00402	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv182[ebp]
  0040a	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0
$LN4@SliderBeha:

; 2341 :     }
; 2342 : 
; 2343 :     // Process interacting with the slider
; 2344 :     bool value_changed = false;

  00412	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 2345 :     if (g.ActiveId == id)

  00419	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0041c	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00422	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00425	0f 85 cc 06 00
	00		 jne	 $LN39@SliderBeha

; 2346 :     {
; 2347 :         bool set_new_value = false;

  0042b	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0

; 2348 :         float clicked_t = 0.0f;

  00432	0f 57 c0	 xorps	 xmm0, xmm0
  00435	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2349 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

  0043d	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00440	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  00447	0f 85 d4 00 00
	00		 jne	 $LN6@SliderBeha

; 2350 :         {
; 2351 :             if (!g.IO.MouseDown[0])

  0044d	b8 01 00 00 00	 mov	 eax, 1
  00452	6b c8 00	 imul	 ecx, eax, 0
  00455	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00458	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  00460	85 c0		 test	 eax, eax
  00462	75 0a		 jne	 SHORT $LN8@SliderBeha

; 2352 :             {
; 2353 :                 ClearActiveID();

  00464	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2354 :             }

  00469	e9 ae 00 00 00	 jmp	 $LN9@SliderBeha
$LN8@SliderBeha:

; 2355 :             else
; 2356 :             {
; 2357 :                 const float mouse_abs_pos = g.IO.MousePos[axis];

  0046e	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  00471	50		 push	 eax
  00472	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00475	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  0047b	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  00480	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00484	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _mouse_abs_pos$15[ebp], xmm0

; 2358 :                 clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

  0048c	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  00491	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00498	76 42		 jbe	 SHORT $LN60@SliderBeha
  0049a	51		 push	 ecx
  0049b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a8	51		 push	 ecx
  004a9	0f 57 c0	 xorps	 xmm0, xmm0
  004ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b1	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_abs_pos$15[ebp]
  004b9	f3 0f 5c 85 78
	ff ff ff	 subss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  004c1	f3 0f 5e 45 84	 divss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  004c6	51		 push	 ecx
  004c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004cc	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  004d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d4	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv205[ebp]
  004da	eb 0b		 jmp	 SHORT $LN61@SliderBeha
$LN60@SliderBeha:
  004dc	0f 57 c0	 xorps	 xmm0, xmm0
  004df	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv205[ebp], xmm0
$LN61@SliderBeha:
  004e7	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv205[ebp]
  004ef	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2359 :                 if (axis == ImGuiAxis_Y)

  004f7	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  004fb	75 18		 jne	 SHORT $LN10@SliderBeha

; 2360 :                     clicked_t = 1.0f - clicked_t;

  004fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00505	f3 0f 5c 85 1c
	ff ff ff	 subss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0050d	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0
$LN10@SliderBeha:

; 2361 :                 set_new_value = true;

  00515	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1
$LN9@SliderBeha:

; 2362 :             }
; 2363 :         }

  0051c	e9 ca 02 00 00	 jmp	 $LN25@SliderBeha
$LN6@SliderBeha:

; 2364 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  00521	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00524	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  0052b	0f 85 ba 02 00
	00		 jne	 $LN25@SliderBeha

; 2365 :         {
; 2366 :             const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

  00531	51		 push	 ecx
  00532	0f 57 c0	 xorps	 xmm0, xmm0
  00535	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0053a	51		 push	 ecx
  0053b	0f 57 c0	 xorps	 xmm0, xmm0
  0053e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00543	6a 05		 push	 5
  00545	6a 03		 push	 3
  00547	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _delta2$14[ebp]
  0054d	50		 push	 eax
  0054e	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  00553	83 c4 14	 add	 esp, 20			; 00000014H

; 2367 :             float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

  00556	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  0055a	75 12		 jne	 SHORT $LN62@SliderBeha
  0055c	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp]
  00564	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv217[ebp], xmm0
  0056c	eb 17		 jmp	 SHORT $LN63@SliderBeha
$LN62@SliderBeha:
  0056e	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp+4]
  00576	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0057d	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv217[ebp], xmm0
$LN63@SliderBeha:
  00585	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv217[ebp]
  0058d	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2368 :             if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

  00595	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00598	8b 88 e0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6880]
  0059e	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  005a1	75 18		 jne	 SHORT $LN12@SliderBeha
  005a3	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  005a6	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  005ad	85 c9		 test	 ecx, ecx
  005af	75 0a		 jne	 SHORT $LN12@SliderBeha

; 2369 :             {
; 2370 :                 ClearActiveID();

  005b1	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2371 :             }

  005b6	e9 30 02 00 00	 jmp	 $LN25@SliderBeha
$LN12@SliderBeha:

; 2372 :             else if (delta != 0.0f)

  005bb	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  005c3	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  005ca	9f		 lahf
  005cb	f6 c4 44	 test	 ah, 68			; 00000044H
  005ce	0f 8b 17 02 00
	00		 jnp	 $LN25@SliderBeha

; 2373 :             {
; 2374 :                 clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  005d4	51		 push	 ecx
  005d5	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  005dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005e2	51		 push	 ecx
  005e3	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  005e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005ed	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  005f0	50		 push	 eax
  005f1	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  005f4	51		 push	 ecx
  005f5	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  005f8	52		 push	 edx
  005f9	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  005fc	50		 push	 eax
  005fd	8b 4d 14	 mov	 ecx, DWORD PTR _v$[ebp]
  00600	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00603	52		 push	 edx
  00604	8b 01		 mov	 eax, DWORD PTR [ecx]
  00606	50		 push	 eax
  00607	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  0060a	51		 push	 ecx
  0060b	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ; ImGui::SliderCalcRatioFromValueT<__int64,double>
  00610	83 c4 24	 add	 esp, 36			; 00000024H
  00613	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]

; 2375 :                 const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00619	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0061d	85 c0		 test	 eax, eax
  0061f	74 16		 je	 SHORT $LN64@SliderBeha
  00621	6a 03		 push	 3
  00623	8b 4d 28	 mov	 ecx, DWORD PTR _format$[ebp]
  00626	51		 push	 ecx
  00627	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  0062c	83 c4 08	 add	 esp, 8
  0062f	89 85 68 fd ff
	ff		 mov	 DWORD PTR tv268[ebp], eax
  00635	eb 0a		 jmp	 SHORT $LN65@SliderBeha
$LN64@SliderBeha:
  00637	c7 85 68 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv268[ebp], 0
$LN65@SliderBeha:
  00641	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR tv268[ebp]
  00647	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _decimal_precision$12[ebp], edx

; 2376 :                 if ((decimal_precision > 0) || is_power)

  0064d	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _decimal_precision$12[ebp], 0
  00654	7f 08		 jg	 SHORT $LN17@SliderBeha
  00656	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0065a	85 c0		 test	 eax, eax
  0065c	74 46		 je	 SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2377 :                 {
; 2378 :                     delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

  0065e	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00666	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0066e	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2379 :                     if (IsNavInputDown(ImGuiNavInput_TweakSlow))

  00676	6a 0e		 push	 14			; 0000000eH
  00678	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  0067d	83 c4 04	 add	 esp, 4
  00680	0f b6 c0	 movzx	 eax, al
  00683	85 c0		 test	 eax, eax
  00685	74 18		 je	 SHORT $LN18@SliderBeha

; 2380 :                         delta /= 10.0f;

  00687	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0068f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00697	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN18@SliderBeha:

; 2381 :                 }

  0069f	e9 b0 00 00 00	 jmp	 $LN20@SliderBeha
$LN15@SliderBeha:

; 2382 :                 else
; 2383 :                 {
; 2384 :                     if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

  006a4	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  006a7	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  006aa	e8 00 00 00 00	 call	 __ltod3
  006af	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006b3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@c2c80000
  006ba	72 1c		 jb	 SHORT $LN22@SliderBeha
  006bc	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  006bf	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  006c2	e8 00 00 00 00	 call	 __ltod3
  006c7	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006cb	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@42c80000
  006d3	0f 2f c8	 comiss	 xmm1, xmm0
  006d6	73 11		 jae	 SHORT $LN21@SliderBeha
$LN22@SliderBeha:
  006d8	6a 0e		 push	 14			; 0000000eH
  006da	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  006df	83 c4 04	 add	 esp, 4
  006e2	0f b6 c0	 movzx	 eax, al
  006e5	85 c0		 test	 eax, eax
  006e7	74 53		 je	 SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2385 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

  006e9	0f 57 c0	 xorps	 xmm0, xmm0
  006ec	0f 2f 85 f4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  006f3	76 12		 jbe	 SHORT $LN66@SliderBeha
  006f5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  006fd	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv287[ebp], xmm0
  00705	eb 10		 jmp	 SHORT $LN67@SliderBeha
$LN66@SliderBeha:
  00707	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0070f	f3 0f 11 85 68
	fd ff ff	 movss	 DWORD PTR tv287[ebp], xmm0
$LN67@SliderBeha:
  00717	8b 55 94	 mov	 edx, DWORD PTR _v_range$[ebp+4]
  0071a	8b 4d 90	 mov	 ecx, DWORD PTR _v_range$[ebp]
  0071d	e8 00 00 00 00	 call	 __ltod3
  00722	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00726	f3 0f 10 8d 68
	fd ff ff	 movss	 xmm1, DWORD PTR tv287[ebp]
  0072e	f3 0f 5e c8	 divss	 xmm1, xmm0
  00732	f3 0f 11 8d f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm1
  0073a	eb 18		 jmp	 SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2386 :                     else
; 2387 :                         delta /= 100.0f;

  0073c	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00744	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0074c	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN20@SliderBeha:

; 2388 :                 }
; 2389 :                 if (IsNavInputDown(ImGuiNavInput_TweakFast))

  00754	6a 0f		 push	 15			; 0000000fH
  00756	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  0075b	83 c4 04	 add	 esp, 4
  0075e	0f b6 c0	 movzx	 eax, al
  00761	85 c0		 test	 eax, eax
  00763	74 18		 je	 SHORT $LN23@SliderBeha

; 2390 :                     delta *= 10.0f;

  00765	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0076d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00775	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN23@SliderBeha:

; 2391 :                 set_new_value = true;

  0077d	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1

; 2392 :                 if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

  00784	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0078c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00793	72 11		 jb	 SHORT $LN27@SliderBeha
  00795	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0079d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  007a4	77 18		 ja	 SHORT $LN26@SliderBeha
$LN27@SliderBeha:
  007a6	0f 57 c0	 xorps	 xmm0, xmm0
  007a9	0f 2f 85 1c ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007b0	72 15		 jb	 SHORT $LN24@SliderBeha
  007b2	0f 57 c0	 xorps	 xmm0, xmm0
  007b5	0f 2f 85 f4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  007bc	76 09		 jbe	 SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2393 :                     set_new_value = false;

  007be	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0
  007c5	eb 24		 jmp	 SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2394 :                 else
; 2395 :                     clicked_t = ImSaturate(clicked_t + delta);

  007c7	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007cf	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _delta$13[ebp]
  007d7	51		 push	 ecx
  007d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007dd	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  007e2	83 c4 04	 add	 esp, 4
  007e5	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]
$LN25@SliderBeha:

; 2396 :             }
; 2397 :         }
; 2398 : 
; 2399 :         if (set_new_value)

  007eb	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _set_new_value$17[ebp]
  007f2	85 c0		 test	 eax, eax
  007f4	0f 84 fd 02 00
	00		 je	 $LN39@SliderBeha

; 2400 :         {
; 2401 :             TYPE v_new;
; 2402 :             if (is_power)

  007fa	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  007fe	85 c0		 test	 eax, eax
  00800	0f 84 84 01 00
	00		 je	 $LN29@SliderBeha

; 2403 :             {
; 2404 :                 // Account for power curve scale on both sides of the zero
; 2405 :                 if (clicked_t < linear_zero_pos)

  00806	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0080e	0f 2f 85 1c ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00815	0f 86 90 00 00
	00		 jbe	 $LN31@SliderBeha

; 2406 :                 {
; 2407 :                     // Negative: rescale to the negative range before powering
; 2408 :                     float a = 1.0f - (clicked_t / linear_zero_pos);

  0081b	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00823	f3 0f 5e 85 60
	ff ff ff	 divss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0082b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00833	f3 0f 5c c8	 subss	 xmm1, xmm0
  00837	f3 0f 11 8d cc
	fe ff ff	 movss	 DWORD PTR _a$10[ebp], xmm1

; 2409 :                     a = ImPow(a, power);

  0083f	51		 push	 ecx
  00840	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00845	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0084a	51		 push	 ecx
  0084b	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  00853	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00858	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0085d	83 c4 08	 add	 esp, 8
  00860	d9 9d cc fe ff
	ff		 fstp	 DWORD PTR _a$10[ebp]

; 2410 :                     v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

  00866	51		 push	 ecx
  00867	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  0086f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00874	8b 45 1c	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00877	50		 push	 eax
  00878	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  0087b	51		 push	 ecx
  0087c	6a 00		 push	 0
  0087e	6a 00		 push	 0
  00880	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00883	52		 push	 edx
  00884	8b 45 20	 mov	 eax, DWORD PTR _v_max$[ebp]
  00887	50		 push	 eax
  00888	e8 00 00 00 00	 call	 ??$ImMin@_J@@YA_J_J0@Z	; ImMin<__int64>
  0088d	83 c4 10	 add	 esp, 16			; 00000010H
  00890	52		 push	 edx
  00891	50		 push	 eax
  00892	e8 00 00 00 00	 call	 ??$ImLerp@_J@@YA_J_J0M@Z ; ImLerp<__int64>
  00897	83 c4 14	 add	 esp, 20			; 00000014H
  0089a	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  008a0	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx

; 2411 :                 }

  008a6	e9 da 00 00 00	 jmp	 $LN32@SliderBeha
$LN31@SliderBeha:

; 2412 :                 else
; 2413 :                 {
; 2414 :                     // Positive: rescale to the positive range before powering
; 2415 :                     float a;
; 2416 :                     if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

  008ab	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  008b3	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  008bb	51		 push	 ecx
  008bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c1	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  008c6	83 c4 04	 add	 esp, 4
  008c9	d9 9d 68 fd ff
	ff		 fstp	 DWORD PTR tv726[ebp]
  008cf	f3 0f 10 85 68
	fd ff ff	 movss	 xmm0, DWORD PTR tv726[ebp]
  008d7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@358637bd
  008de	76 2e		 jbe	 SHORT $LN33@SliderBeha

; 2417 :                         a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

  008e0	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  008e8	f3 0f 5c 85 60
	ff ff ff	 subss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  008f0	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  008f8	f3 0f 5c 8d 60
	ff ff ff	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  00900	f3 0f 5e c1	 divss	 xmm0, xmm1
  00904	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
  0090c	eb 10		 jmp	 SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2418 :                     else
; 2419 :                         a = clicked_t;

  0090e	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00916	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
$LN34@SliderBeha:

; 2420 :                     a = ImPow(a, power);

  0091e	51		 push	 ecx
  0091f	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00924	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00929	51		 push	 ecx
  0092a	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  00932	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00937	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0093c	83 c4 08	 add	 esp, 8
  0093f	d9 9d c0 fe ff
	ff		 fstp	 DWORD PTR _a$9[ebp]

; 2421 :                     v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

  00945	51		 push	 ecx
  00946	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  0094e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00953	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  00956	50		 push	 eax
  00957	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0095a	51		 push	 ecx
  0095b	6a 00		 push	 0
  0095d	6a 00		 push	 0
  0095f	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  00962	52		 push	 edx
  00963	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00966	50		 push	 eax
  00967	e8 00 00 00 00	 call	 ??$ImMax@_J@@YA_J_J0@Z	; ImMax<__int64>
  0096c	83 c4 10	 add	 esp, 16			; 00000010H
  0096f	52		 push	 edx
  00970	50		 push	 eax
  00971	e8 00 00 00 00	 call	 ??$ImLerp@_J@@YA_J_J0M@Z ; ImLerp<__int64>
  00976	83 c4 14	 add	 esp, 20			; 00000014H
  00979	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  0097f	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx
$LN32@SliderBeha:

; 2422 :                 }
; 2423 :             }

  00985	e9 fe 00 00 00	 jmp	 $LN38@SliderBeha
$LN29@SliderBeha:

; 2424 :             else
; 2425 :             {
; 2426 :                 // Linear slider
; 2427 :                 if (is_decimal)

  0098a	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0098e	85 c0		 test	 eax, eax
  00990	74 37		 je	 SHORT $LN35@SliderBeha

; 2428 :                 {
; 2429 :                     v_new = ImLerp(v_min, v_max, clicked_t);

  00992	51		 push	 ecx
  00993	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0099b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009a0	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  009a3	50		 push	 eax
  009a4	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  009a7	51		 push	 ecx
  009a8	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  009ab	52		 push	 edx
  009ac	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  009af	50		 push	 eax
  009b0	e8 00 00 00 00	 call	 ??$ImLerp@_J@@YA_J_J0M@Z ; ImLerp<__int64>
  009b5	83 c4 14	 add	 esp, 20			; 00000014H
  009b8	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  009be	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx

; 2430 :                 }

  009c4	e9 bf 00 00 00	 jmp	 $LN38@SliderBeha
$LN35@SliderBeha:

; 2431 :                 else
; 2432 :                 {
; 2433 :                     // For integer values we want the clicking position to match the grab box so we round above
; 2434 :                     // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2435 :                     FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

  009c9	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  009cc	2b 4d 18	 sub	 ecx, DWORD PTR _v_min$[ebp]
  009cf	8b 55 24	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  009d2	1b 55 1c	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  009d5	e8 00 00 00 00	 call	 __ltod3
  009da	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  009de	f3 0f 59 85 1c
	ff ff ff	 mulss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  009e6	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  009ea	f2 0f 11 85 b0
	fe ff ff	 movsd	 QWORD PTR _v_new_off_f$8[ebp], xmm0

; 2436 :                     TYPE v_new_off_floor = (TYPE)(v_new_off_f);

  009f2	f2 0f 10 85 b0
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new_off_f$8[ebp]
  009fa	e8 00 00 00 00	 call	 __dtol3
  009ff	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _v_new_off_floor$7[ebp], eax
  00a05	89 95 a4 fe ff
	ff		 mov	 DWORD PTR _v_new_off_floor$7[ebp+4], edx

; 2437 :                     TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

  00a0b	f2 0f 10 85 b0
	fe ff ff	 movsd	 xmm0, QWORD PTR _v_new_off_f$8[ebp]
  00a13	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00a1b	e8 00 00 00 00	 call	 __dtol3
  00a20	89 85 90 fe ff
	ff		 mov	 DWORD PTR _v_new_off_round$6[ebp], eax
  00a26	89 95 94 fe ff
	ff		 mov	 DWORD PTR _v_new_off_round$6[ebp+4], edx

; 2438 :                     if (v_new_off_floor < v_new_off_round)

  00a2c	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _v_new_off_floor$7[ebp+4]
  00a32	3b 85 94 fe ff
	ff		 cmp	 eax, DWORD PTR _v_new_off_round$6[ebp+4]
  00a38	7f 30		 jg	 SHORT $LN37@SliderBeha
  00a3a	7c 0e		 jl	 SHORT $LN72@SliderBeha
  00a3c	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new_off_floor$7[ebp]
  00a42	3b 8d 90 fe ff
	ff		 cmp	 ecx, DWORD PTR _v_new_off_round$6[ebp]
  00a48	73 20		 jae	 SHORT $LN37@SliderBeha
$LN72@SliderBeha:

; 2439 :                         v_new = v_min + v_new_off_round;

  00a4a	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00a4d	03 85 90 fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_round$6[ebp]
  00a53	8b 4d 1c	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00a56	13 8d 94 fe ff
	ff		 adc	 ecx, DWORD PTR _v_new_off_round$6[ebp+4]
  00a5c	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  00a62	89 8d dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], ecx
  00a68	eb 1e		 jmp	 SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2440 :                     else
; 2441 :                         v_new = v_min + v_new_off_floor;

  00a6a	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00a6d	03 85 a0 fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_floor$7[ebp]
  00a73	8b 4d 1c	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  00a76	13 8d a4 fe ff
	ff		 adc	 ecx, DWORD PTR _v_new_off_floor$7[ebp+4]
  00a7c	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  00a82	89 8d dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], ecx
$LN38@SliderBeha:

; 2442 :                 }
; 2443 :             }
; 2444 : 
; 2445 :             // Round to user desired precision based on format string
; 2446 :             v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

  00a88	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _v_new$11[ebp+4]
  00a8e	50		 push	 eax
  00a8f	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new$11[ebp]
  00a95	51		 push	 ecx
  00a96	8b 55 10	 mov	 edx, DWORD PTR _data_type$[ebp]
  00a99	52		 push	 edx
  00a9a	8b 45 28	 mov	 eax, DWORD PTR _format$[ebp]
  00a9d	50		 push	 eax
  00a9e	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64,__int64>
  00aa3	83 c4 10	 add	 esp, 16			; 00000010H
  00aa6	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  00aac	89 95 dc fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp+4], edx

; 2447 : 
; 2448 :             // Apply result
; 2449 :             if (*v != v_new)

  00ab2	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00ab5	89 85 68 fd ff
	ff		 mov	 DWORD PTR tv826[ebp], eax
  00abb	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR tv826[ebp]
  00ac1	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ac3	3b 95 d8 fe ff
	ff		 cmp	 edx, DWORD PTR _v_new$11[ebp]
  00ac9	75 11		 jne	 SHORT $LN73@SliderBeha
  00acb	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR tv826[ebp]
  00ad1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ad4	3b 8d dc fe ff
	ff		 cmp	 ecx, DWORD PTR _v_new$11[ebp+4]
  00ada	74 1b		 je	 SHORT $LN39@SliderBeha
$LN73@SliderBeha:

; 2450 :             {
; 2451 :                 *v = v_new;

  00adc	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00adf	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new$11[ebp]
  00ae5	89 08		 mov	 DWORD PTR [eax], ecx
  00ae7	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _v_new$11[ebp+4]
  00aed	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2452 :                 value_changed = true;

  00af0	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN39@SliderBeha:

; 2453 :             }
; 2454 :         }
; 2455 :     }
; 2456 : 
; 2457 :     if (slider_sz < 1.0f)

  00af7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00aff	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00b03	76 31		 jbe	 SHORT $LN40@SliderBeha

; 2458 :     {
; 2459 :         *out_grab_bb = ImRect(bb.Min, bb.Min);

  00b05	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00b08	50		 push	 eax
  00b09	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00b0c	51		 push	 ecx
  00b0d	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00b13	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
  00b18	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00b1b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b1d	89 0a		 mov	 DWORD PTR [edx], ecx
  00b1f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b22	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b25	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b28	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b2b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b2e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2460 :     }

  00b31	e9 bd 01 00 00	 jmp	 $LN44@SliderBeha
$LN40@SliderBeha:

; 2461 :     else
; 2462 :     {
; 2463 :         // Output grab position so it can be displayed by the caller
; 2464 :         float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  00b36	51		 push	 ecx
  00b37	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00b3f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b44	51		 push	 ecx
  00b45	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _power$[ebp]
  00b4a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b4f	8b 45 24	 mov	 eax, DWORD PTR _v_max$[ebp+4]
  00b52	50		 push	 eax
  00b53	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00b56	51		 push	 ecx
  00b57	8b 55 1c	 mov	 edx, DWORD PTR _v_min$[ebp+4]
  00b5a	52		 push	 edx
  00b5b	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00b5e	50		 push	 eax
  00b5f	8b 4d 14	 mov	 ecx, DWORD PTR _v$[ebp]
  00b62	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00b65	52		 push	 edx
  00b66	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b68	50		 push	 eax
  00b69	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00b6c	51		 push	 ecx
  00b6d	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@_JN@ImGui@@YAMH_J00MM@Z ; ImGui::SliderCalcRatioFromValueT<__int64,double>
  00b72	83 c4 24	 add	 esp, 36			; 00000024H
  00b75	d9 9d 84 fe ff
	ff		 fstp	 DWORD PTR _grab_t$5[ebp]

; 2465 :         if (axis == ImGuiAxis_Y)

  00b7b	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00b7f	75 18		 jne	 SHORT $LN42@SliderBeha

; 2466 :             grab_t = 1.0f - grab_t;

  00b81	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b89	f3 0f 5c 85 84
	fe ff ff	 subss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00b91	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR _grab_t$5[ebp], xmm0
$LN42@SliderBeha:

; 2467 :         const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

  00b99	51		 push	 ecx
  00b9a	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00ba2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ba7	51		 push	 ecx
  00ba8	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_max$[ebp]
  00bb0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bb5	51		 push	 ecx
  00bb6	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00bbe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bc3	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00bc8	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bcb	d9 9d 78 fe ff
	ff		 fstp	 DWORD PTR _grab_pos$4[ebp]

; 2468 :         if (axis == ImGuiAxis_X)

  00bd1	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00bd5	0f 85 8f 00 00
	00		 jne	 $LN43@SliderBeha

; 2469 :             *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

  00bdb	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00bde	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00be3	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00beb	51		 push	 ecx
  00bec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bf1	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00bf6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00bfe	f3 0f 58 85 78
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00c06	51		 push	 ecx
  00c07	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c0c	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00c0f	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00c14	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00c1c	51		 push	 ecx
  00c1d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c22	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c27	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00c2f	f3 0f 10 8d 78
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00c37	f3 0f 5c c8	 subss	 xmm1, xmm0
  00c3b	51		 push	 ecx
  00c3c	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00c41	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00c47	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00c4c	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00c4f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c51	89 0a		 mov	 DWORD PTR [edx], ecx
  00c53	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c56	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c59	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c5c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c5f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c62	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00c65	e9 89 00 00 00	 jmp	 $LN44@SliderBeha
$LN43@SliderBeha:

; 2470 :         else
; 2471 :             *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

  00c6a	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c6f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00c77	f3 0f 58 85 78
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00c7f	51		 push	 ecx
  00c80	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c85	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00c88	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00c8d	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00c95	51		 push	 ecx
  00c96	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c9b	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00ca0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00ca8	f3 0f 10 8d 78
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00cb0	f3 0f 5c c8	 subss	 xmm1, xmm0
  00cb4	51		 push	 ecx
  00cb5	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00cba	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00cbd	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00cc1	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00cc9	51		 push	 ecx
  00cca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ccf	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00cd5	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00cda	8b 55 34	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00cdd	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cdf	89 0a		 mov	 DWORD PTR [edx], ecx
  00ce1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ce4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ce7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00cea	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00ced	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00cf0	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN44@SliderBeha:

; 2472 :     }
; 2473 : 
; 2474 :     return value_changed;

  00cf3	8a 85 37 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]

; 2475 : }

  00cf9	52		 push	 edx
  00cfa	8b cd		 mov	 ecx, ebp
  00cfc	50		 push	 eax
  00cfd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN76@SliderBeha
  00d03	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00d08	58		 pop	 eax
  00d09	5a		 pop	 edx
  00d0a	5f		 pop	 edi
  00d0b	5e		 pop	 esi
  00d0c	5b		 pop	 ebx
  00d0d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d10	33 cd		 xor	 ecx, ebp
  00d12	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d17	81 c4 a0 02 00
	00		 add	 esp, 672		; 000002a0H
  00d1d	3b ec		 cmp	 ebp, esp
  00d1f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d24	8b e5		 mov	 esp, ebp
  00d26	5d		 pop	 ebp
  00d27	c3		 ret	 0
$LN76@SliderBeha:
  00d28	01 00 00 00	 DD	 1
  00d2c	00 00 00 00	 DD	 $LN75@SliderBeha
$LN75@SliderBeha:
  00d30	00 ff ff ff	 DD	 -256			; ffffff00H
  00d34	08 00 00 00	 DD	 8
  00d38	00 00 00 00	 DD	 $LN74@SliderBeha
$LN74@SliderBeha:
  00d3c	64		 DB	 100			; 00000064H
  00d3d	65		 DB	 101			; 00000065H
  00d3e	6c		 DB	 108			; 0000006cH
  00d3f	74		 DB	 116			; 00000074H
  00d40	61		 DB	 97			; 00000061H
  00d41	32		 DB	 50			; 00000032H
  00d42	00		 DB	 0
??$SliderBehaviorT@_J_JN@ImGui@@YA_NABUImRect@@IHPA_J_J2PBDMHPAU1@@Z ENDP ; ImGui::SliderBehaviorT<__int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@IHM@ImGui@@YA_NABUImRect@@IHPAIIIPBDMHPAU1@@Z
_TEXT	SEGMENT
tv557 = -660						; size = 8
tv533 = -660						; size = 8
tv553 = -652						; size = 4
tv529 = -652						; size = 4
tv179 = -648						; size = 4
tv172 = -648						; size = 4
tv163 = -648						; size = 4
tv699 = -644						; size = 8
tv574 = -644						; size = 8
tv548 = -644						; size = 8
tv524 = -644						; size = 8
tv514 = -644						; size = 8
tv442 = -644						; size = 4
tv810 = -640						; size = 4
tv696 = -636						; size = 4
tv673 = -636						; size = 4
tv570 = -636						; size = 4
tv544 = -636						; size = 4
tv520 = -636						; size = 4
tv511 = -636						; size = 4
tv507 = -636						; size = 4
tv500 = -636						; size = 4
tv437 = -636						; size = 4
tv284 = -636						; size = 4
tv265 = -636						; size = 4
tv214 = -636						; size = 4
tv202 = -636						; size = 4
tv89 = -636						; size = 4
tv67 = -636						; size = 4
tv74 = -633						; size = 1
tv70 = -633						; size = 1
$T1 = -628						; size = 16
$T2 = -604						; size = 16
$T3 = -580						; size = 16
_grab_pos$4 = -364					; size = 4
_grab_t$5 = -352					; size = 4
_v_new_off_round$6 = -340				; size = 4
_v_new_off_floor$7 = -328				; size = 4
_v_new_off_f$8 = -316					; size = 4
_a$9 = -304						; size = 4
_a$10 = -292						; size = 4
_v_new$11 = -280					; size = 4
_decimal_precision$12 = -268				; size = 4
_delta$13 = -256					; size = 4
_delta2$14 = -244					; size = 8
_mouse_abs_pos$15 = -228				; size = 4
_clicked_t$16 = -216					; size = 4
_set_new_value$17 = -201				; size = 1
_value_changed$ = -189					; size = 1
_linear_dist_max_to_0$18 = -180				; size = 4
_linear_dist_min_to_0$19 = -168				; size = 4
_linear_zero_pos$ = -156				; size = 4
_slider_usable_pos_max$ = -144				; size = 4
_slider_usable_pos_min$ = -132				; size = 4
_slider_usable_sz$ = -120				; size = 4
_v_range$ = -108					; size = 4
_grab_sz$ = -96						; size = 4
_slider_sz$ = -84					; size = 4
_grab_padding$ = -72					; size = 4
_is_power$ = -57					; size = 1
_is_decimal$ = -45					; size = 1
_axis$ = -36						; size = 4
_style$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_data_type$ = 16					; size = 4
_v$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
_flags$ = 40						; size = 4
_out_grab_bb$ = 44					; size = 4
??$SliderBehaviorT@IHM@ImGui@@YA_NABUImRect@@IHPAIIIPBDMHPAU1@@Z PROC ; ImGui::SliderBehaviorT<unsigned int,int,float>, COMDAT

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 02 00
	00		 sub	 esp, 660		; 00000294H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-660]
  00012	b9 a5 00 00 00	 mov	 ecx, 165		; 000000a5H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2310 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2311 :     const ImGuiStyle& style = g.Style;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00042	89 45 e8	 mov	 DWORD PTR _style$[ebp], eax

; 2312 : 
; 2313 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00045	8b 45 28	 mov	 eax, DWORD PTR _flags$[ebp]
  00048	83 e0 01	 and	 eax, 1
  0004b	74 0c		 je	 SHORT $LN46@SliderBeha
  0004d	c7 85 84 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00057	eb 0a		 jmp	 SHORT $LN47@SliderBeha
$LN46@SliderBeha:
  00059	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN47@SliderBeha:
  00063	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  00069	89 4d dc	 mov	 DWORD PTR _axis$[ebp], ecx

; 2314 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  0006c	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00070	74 0f		 je	 SHORT $LN48@SliderBeha
  00072	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00076	74 09		 je	 SHORT $LN48@SliderBeha
  00078	c6 85 87 fd ff
	ff 00		 mov	 BYTE PTR tv70[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN49@SliderBeha
$LN48@SliderBeha:
  00081	c6 85 87 fd ff
	ff 01		 mov	 BYTE PTR tv70[ebp], 1
$LN49@SliderBeha:
  00088	8a 85 87 fd ff
	ff		 mov	 al, BYTE PTR tv70[ebp]
  0008e	88 45 d3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 2315 :     const bool is_power = (power != 1.0f) && is_decimal;

  00091	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00096	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0009d	9f		 lahf
  0009e	f6 c4 44	 test	 ah, 68			; 00000044H
  000a1	7b 11		 jnp	 SHORT $LN50@SliderBeha
  000a3	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN50@SliderBeha
  000ab	c6 85 87 fd ff
	ff 01		 mov	 BYTE PTR tv74[ebp], 1
  000b2	eb 07		 jmp	 SHORT $LN51@SliderBeha
$LN50@SliderBeha:
  000b4	c6 85 87 fd ff
	ff 00		 mov	 BYTE PTR tv74[ebp], 0
$LN51@SliderBeha:
  000bb	8a 8d 87 fd ff
	ff		 mov	 cl, BYTE PTR tv74[ebp]
  000c1	88 4d c7	 mov	 BYTE PTR _is_power$[ebp], cl

; 2316 : 
; 2317 :     const float grab_padding = 2.0f;

  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000cc	f3 0f 11 45 b8	 movss	 DWORD PTR _grab_padding$[ebp], xmm0

; 2318 :     const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

  000d1	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000d8	83 c1 08	 add	 ecx, 8
  000db	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  000e0	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv437[ebp]
  000e6	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv437[ebp]
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _axis$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000f5	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv810[ebp], xmm0
  000fd	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00102	d9 9d 7c fd ff
	ff		 fstp	 DWORD PTR tv442[ebp]
  00108	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv810[ebp]
  00110	f3 0f 5c 85 7c
	fd ff ff	 subss	 xmm0, DWORD PTR tv442[ebp]
  00118	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00120	f3 0f 11 45 ac	 movss	 DWORD PTR _slider_sz$[ebp], xmm0

; 2319 :     float grab_sz = style.GrabMinSize;

  00125	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  00128	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  0012d	f3 0f 11 45 a0	 movss	 DWORD PTR _grab_sz$[ebp], xmm0

; 2320 :     SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

  00132	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00135	3b 45 1c	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00138	73 0e		 jae	 SHORT $LN52@SliderBeha
  0013a	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0013d	2b 4d 18	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00140	89 8d 84 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], ecx
  00146	eb 0c		 jmp	 SHORT $LN53@SliderBeha
$LN52@SliderBeha:
  00148	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp]
  0014b	2b 55 1c	 sub	 edx, DWORD PTR _v_max$[ebp]
  0014e	89 95 84 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], edx
$LN53@SliderBeha:
  00154	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR tv89[ebp]
  0015a	89 45 94	 mov	 DWORD PTR _v_range$[ebp], eax

; 2321 :     if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

  0015d	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00161	85 c0		 test	 eax, eax
  00163	75 38		 jne	 SHORT $LN2@SliderBeha
  00165	83 7d 94 00	 cmp	 DWORD PTR _v_range$[ebp], 0
  00169	7c 32		 jl	 SHORT $LN2@SliderBeha

; 2322 :         grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

  0016b	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  0016e	51		 push	 ecx
  0016f	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	8b 4d 94	 mov	 ecx, DWORD PTR _v_range$[ebp]
  0017c	83 c1 01	 add	 ecx, 1
  0017f	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00183	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _slider_sz$[ebp]
  00188	f3 0f 5e c8	 divss	 xmm1, xmm0
  0018c	51		 push	 ecx
  0018d	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00192	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00197	83 c4 08	 add	 esp, 8
  0019a	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]
$LN2@SliderBeha:

; 2323 :     grab_sz = ImMin(grab_sz, slider_sz);

  0019d	51		 push	 ecx
  0019e	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a8	51		 push	 ecx
  001a9	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b3	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001b8	83 c4 08	 add	 esp, 8
  001bb	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]

; 2324 :     const float slider_usable_sz = slider_sz - grab_sz;

  001be	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001c3	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001c8	f3 0f 11 45 88	 movss	 DWORD PTR _slider_usable_sz$[ebp], xmm0

; 2325 :     const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

  001cd	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  001d0	50		 push	 eax
  001d1	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  001d4	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  001d9	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv500[ebp]
  001df	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv500[ebp]
  001e7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  001ef	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  001f4	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  001fc	f3 0f 58 c1	 addss	 xmm0, xmm1
  00200	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_min$[ebp], xmm0

; 2326 :     const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

  00208	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  0020b	50		 push	 eax
  0020c	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  0020f	83 c1 08	 add	 ecx, 8
  00212	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00217	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv507[ebp]
  0021d	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv507[ebp]
  00225	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  0022d	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00232	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0023a	f3 0f 5c c1	 subss	 xmm0, xmm1
  0023e	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_max$[ebp], xmm0

; 2327 : 
; 2328 :     // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2329 :     float linear_zero_pos;   // 0.0->1.0f
; 2330 :     if (is_power && v_min * v_max < 0.0f)

  00246	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0024a	85 c0		 test	 eax, eax
  0024c	0f 84 d1 01 00
	00		 je	 $LN3@SliderBeha
  00252	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00255	0f af 45 1c	 imul	 eax, DWORD PTR _v_max$[ebp]
  00259	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv511[ebp], eax
  0025f	f2 0f 2a 85 84
	fd ff ff	 cvtsi2sd xmm0, DWORD PTR tv511[ebp]
  00267	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv511[ebp]
  0026d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00270	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00279	f2 0f 11 85 7c
	fd ff ff	 movsd	 QWORD PTR tv514[ebp], xmm0
  00281	f2 0f 5a 85 7c
	fd ff ff	 cvtsd2ss xmm0, QWORD PTR tv514[ebp]
  00289	0f 57 c9	 xorps	 xmm1, xmm1
  0028c	0f 2f c8	 comiss	 xmm1, xmm0
  0028f	0f 86 8e 01 00
	00		 jbe	 $LN3@SliderBeha

; 2331 :     {
; 2332 :         // Different sign
; 2333 :         const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

  00295	83 7d 18 00	 cmp	 DWORD PTR _v_min$[ebp], 0
  00299	72 3d		 jb	 SHORT $LN54@SliderBeha
  0029b	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  0029e	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv520[ebp], eax
  002a4	f2 0f 2a 85 84
	fd ff ff	 cvtsi2sd xmm0, DWORD PTR tv520[ebp]
  002ac	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv520[ebp]
  002b2	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  002b5	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  002be	f2 0f 11 85 7c
	fd ff ff	 movsd	 QWORD PTR tv524[ebp], xmm0
  002c6	f2 0f 5a 85 7c
	fd ff ff	 cvtsd2ss xmm0, QWORD PTR tv524[ebp]
  002ce	f3 0f 11 85 78
	fd ff ff	 movss	 DWORD PTR tv163[ebp], xmm0
  002d6	eb 42		 jmp	 SHORT $LN55@SliderBeha
$LN54@SliderBeha:
  002d8	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp]
  002db	89 95 74 fd ff
	ff		 mov	 DWORD PTR tv529[ebp], edx
  002e1	f2 0f 2a 85 74
	fd ff ff	 cvtsi2sd xmm0, DWORD PTR tv529[ebp]
  002e9	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR tv529[ebp]
  002ef	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002f2	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  002fb	f2 0f 11 85 6c
	fd ff ff	 movsd	 QWORD PTR tv533[ebp], xmm0
  00303	f2 0f 5a 85 6c
	fd ff ff	 cvtsd2ss xmm0, QWORD PTR tv533[ebp]
  0030b	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00312	f3 0f 11 85 78
	fd ff ff	 movss	 DWORD PTR tv163[ebp], xmm0
$LN55@SliderBeha:
  0031a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00322	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  00327	51		 push	 ecx
  00328	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032d	51		 push	 ecx
  0032e	f3 0f 10 85 78
	fd ff ff	 movss	 xmm0, DWORD PTR tv163[ebp]
  00336	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0033b	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00340	83 c4 08	 add	 esp, 8
  00343	d9 9d 58 ff ff
	ff		 fstp	 DWORD PTR _linear_dist_min_to_0$19[ebp]

; 2334 :         const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

  00349	83 7d 1c 00	 cmp	 DWORD PTR _v_max$[ebp], 0
  0034d	72 3d		 jb	 SHORT $LN56@SliderBeha
  0034f	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  00352	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv544[ebp], eax
  00358	f2 0f 2a 85 84
	fd ff ff	 cvtsi2sd xmm0, DWORD PTR tv544[ebp]
  00360	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv544[ebp]
  00366	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00369	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00372	f2 0f 11 85 7c
	fd ff ff	 movsd	 QWORD PTR tv548[ebp], xmm0
  0037a	f2 0f 5a 85 7c
	fd ff ff	 cvtsd2ss xmm0, QWORD PTR tv548[ebp]
  00382	f3 0f 11 85 78
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
  0038a	eb 42		 jmp	 SHORT $LN57@SliderBeha
$LN56@SliderBeha:
  0038c	8b 55 1c	 mov	 edx, DWORD PTR _v_max$[ebp]
  0038f	89 95 74 fd ff
	ff		 mov	 DWORD PTR tv553[ebp], edx
  00395	f2 0f 2a 85 74
	fd ff ff	 cvtsi2sd xmm0, DWORD PTR tv553[ebp]
  0039d	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR tv553[ebp]
  003a3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003a6	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  003af	f2 0f 11 85 6c
	fd ff ff	 movsd	 QWORD PTR tv557[ebp], xmm0
  003b7	f2 0f 5a 85 6c
	fd ff ff	 cvtsd2ss xmm0, QWORD PTR tv557[ebp]
  003bf	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003c6	f3 0f 11 85 78
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
$LN57@SliderBeha:
  003ce	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003d6	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  003db	51		 push	 ecx
  003dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003e1	51		 push	 ecx
  003e2	f3 0f 10 85 78
	fd ff ff	 movss	 xmm0, DWORD PTR tv172[ebp]
  003ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ef	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  003f4	83 c4 08	 add	 esp, 8
  003f7	d9 9d 4c ff ff
	ff		 fstp	 DWORD PTR _linear_dist_max_to_0$18[ebp]

; 2335 :         linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

  003fd	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_dist_min_to_0$19[ebp]
  00405	f3 0f 58 85 4c
	ff ff ff	 addss	 xmm0, DWORD PTR _linear_dist_max_to_0$18[ebp]
  0040d	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _linear_dist_min_to_0$19[ebp]
  00415	f3 0f 5e c8	 divss	 xmm1, xmm0
  00419	f3 0f 11 8d 64
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm1

; 2336 :     }

  00421	eb 68		 jmp	 SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2337 :     else
; 2338 :     {
; 2339 :         // Same sign
; 2340 :         linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

  00423	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00426	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv570[ebp], eax
  0042c	f2 0f 2a 85 84
	fd ff ff	 cvtsi2sd xmm0, DWORD PTR tv570[ebp]
  00434	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv570[ebp]
  0043a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0043d	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00446	f2 0f 11 85 7c
	fd ff ff	 movsd	 QWORD PTR tv574[ebp], xmm0
  0044e	f2 0f 5a 85 7c
	fd ff ff	 cvtsd2ss xmm0, QWORD PTR tv574[ebp]
  00456	0f 57 c9	 xorps	 xmm1, xmm1
  00459	0f 2f c8	 comiss	 xmm1, xmm0
  0045c	76 12		 jbe	 SHORT $LN58@SliderBeha
  0045e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00466	f3 0f 11 85 78
	fd ff ff	 movss	 DWORD PTR tv179[ebp], xmm0
  0046e	eb 0b		 jmp	 SHORT $LN59@SliderBeha
$LN58@SliderBeha:
  00470	0f 57 c0	 xorps	 xmm0, xmm0
  00473	f3 0f 11 85 78
	fd ff ff	 movss	 DWORD PTR tv179[ebp], xmm0
$LN59@SliderBeha:
  0047b	f3 0f 10 85 78
	fd ff ff	 movss	 xmm0, DWORD PTR tv179[ebp]
  00483	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0
$LN4@SliderBeha:

; 2341 :     }
; 2342 : 
; 2343 :     // Process interacting with the slider
; 2344 :     bool value_changed = false;

  0048b	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 2345 :     if (g.ActiveId == id)

  00492	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00495	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0049b	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0049e	0f 85 1e 06 00
	00		 jne	 $LN39@SliderBeha

; 2346 :     {
; 2347 :         bool set_new_value = false;

  004a4	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0

; 2348 :         float clicked_t = 0.0f;

  004ab	0f 57 c0	 xorps	 xmm0, xmm0
  004ae	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2349 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

  004b6	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  004b9	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  004c0	0f 85 d4 00 00
	00		 jne	 $LN6@SliderBeha

; 2350 :         {
; 2351 :             if (!g.IO.MouseDown[0])

  004c6	b8 01 00 00 00	 mov	 eax, 1
  004cb	6b c8 00	 imul	 ecx, eax, 0
  004ce	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  004d1	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  004d9	85 c0		 test	 eax, eax
  004db	75 0a		 jne	 SHORT $LN8@SliderBeha

; 2352 :             {
; 2353 :                 ClearActiveID();

  004dd	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2354 :             }

  004e2	e9 ae 00 00 00	 jmp	 $LN9@SliderBeha
$LN8@SliderBeha:

; 2355 :             else
; 2356 :             {
; 2357 :                 const float mouse_abs_pos = g.IO.MousePos[axis];

  004e7	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  004ea	50		 push	 eax
  004eb	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  004ee	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  004f4	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  004f9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004fd	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _mouse_abs_pos$15[ebp], xmm0

; 2358 :                 clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

  00505	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  0050a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00511	76 42		 jbe	 SHORT $LN60@SliderBeha
  00513	51		 push	 ecx
  00514	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0051c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00521	51		 push	 ecx
  00522	0f 57 c0	 xorps	 xmm0, xmm0
  00525	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0052a	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_abs_pos$15[ebp]
  00532	f3 0f 5c 85 7c
	ff ff ff	 subss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  0053a	f3 0f 5e 45 88	 divss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  0053f	51		 push	 ecx
  00540	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00545	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  0054a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0054d	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv202[ebp]
  00553	eb 0b		 jmp	 SHORT $LN61@SliderBeha
$LN60@SliderBeha:
  00555	0f 57 c0	 xorps	 xmm0, xmm0
  00558	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv202[ebp], xmm0
$LN61@SliderBeha:
  00560	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv202[ebp]
  00568	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2359 :                 if (axis == ImGuiAxis_Y)

  00570	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00574	75 18		 jne	 SHORT $LN10@SliderBeha

; 2360 :                     clicked_t = 1.0f - clicked_t;

  00576	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0057e	f3 0f 5c 85 28
	ff ff ff	 subss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00586	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0
$LN10@SliderBeha:

; 2361 :                 set_new_value = true;

  0058e	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1
$LN9@SliderBeha:

; 2362 :             }
; 2363 :         }

  00595	e9 a0 02 00 00	 jmp	 $LN25@SliderBeha
$LN6@SliderBeha:

; 2364 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  0059a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0059d	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  005a4	0f 85 90 02 00
	00		 jne	 $LN25@SliderBeha

; 2365 :         {
; 2366 :             const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

  005aa	51		 push	 ecx
  005ab	0f 57 c0	 xorps	 xmm0, xmm0
  005ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b3	51		 push	 ecx
  005b4	0f 57 c0	 xorps	 xmm0, xmm0
  005b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005bc	6a 05		 push	 5
  005be	6a 03		 push	 3
  005c0	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _delta2$14[ebp]
  005c6	50		 push	 eax
  005c7	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  005cc	83 c4 14	 add	 esp, 20			; 00000014H

; 2367 :             float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

  005cf	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  005d3	75 12		 jne	 SHORT $LN62@SliderBeha
  005d5	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp]
  005dd	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv214[ebp], xmm0
  005e5	eb 17		 jmp	 SHORT $LN63@SliderBeha
$LN62@SliderBeha:
  005e7	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp+4]
  005ef	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  005f6	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv214[ebp], xmm0
$LN63@SliderBeha:
  005fe	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv214[ebp]
  00606	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2368 :             if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

  0060e	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00611	8b 88 e0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6880]
  00617	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0061a	75 18		 jne	 SHORT $LN12@SliderBeha
  0061c	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0061f	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  00626	85 c9		 test	 ecx, ecx
  00628	75 0a		 jne	 SHORT $LN12@SliderBeha

; 2369 :             {
; 2370 :                 ClearActiveID();

  0062a	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2371 :             }

  0062f	e9 06 02 00 00	 jmp	 $LN25@SliderBeha
$LN12@SliderBeha:

; 2372 :             else if (delta != 0.0f)

  00634	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0063c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00643	9f		 lahf
  00644	f6 c4 44	 test	 ah, 68			; 00000044H
  00647	0f 8b ed 01 00
	00		 jnp	 $LN25@SliderBeha

; 2373 :             {
; 2374 :                 clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  0064d	51		 push	 ecx
  0064e	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00656	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0065b	51		 push	 ecx
  0065c	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00661	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00666	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  00669	50		 push	 eax
  0066a	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  0066d	51		 push	 ecx
  0066e	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp]
  00671	8b 02		 mov	 eax, DWORD PTR [edx]
  00673	50		 push	 eax
  00674	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00677	51		 push	 ecx
  00678	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
  0067d	83 c4 18	 add	 esp, 24			; 00000018H
  00680	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]

; 2375 :                 const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00686	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0068a	85 c0		 test	 eax, eax
  0068c	74 16		 je	 SHORT $LN64@SliderBeha
  0068e	6a 03		 push	 3
  00690	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  00693	51		 push	 ecx
  00694	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00699	83 c4 08	 add	 esp, 8
  0069c	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv265[ebp], eax
  006a2	eb 0a		 jmp	 SHORT $LN65@SliderBeha
$LN64@SliderBeha:
  006a4	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv265[ebp], 0
$LN65@SliderBeha:
  006ae	8b 95 84 fd ff
	ff		 mov	 edx, DWORD PTR tv265[ebp]
  006b4	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _decimal_precision$12[ebp], edx

; 2376 :                 if ((decimal_precision > 0) || is_power)

  006ba	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _decimal_precision$12[ebp], 0
  006c1	7f 08		 jg	 SHORT $LN17@SliderBeha
  006c3	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  006c7	85 c0		 test	 eax, eax
  006c9	74 46		 je	 SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2377 :                 {
; 2378 :                     delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

  006cb	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  006d3	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  006db	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2379 :                     if (IsNavInputDown(ImGuiNavInput_TweakSlow))

  006e3	6a 0e		 push	 14			; 0000000eH
  006e5	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  006ea	83 c4 04	 add	 esp, 4
  006ed	0f b6 c0	 movzx	 eax, al
  006f0	85 c0		 test	 eax, eax
  006f2	74 18		 je	 SHORT $LN18@SliderBeha

; 2380 :                         delta /= 10.0f;

  006f4	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  006fc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00704	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN18@SliderBeha:

; 2381 :                 }

  0070c	e9 92 00 00 00	 jmp	 $LN20@SliderBeha
$LN15@SliderBeha:

; 2382 :                 else
; 2383 :                 {
; 2384 :                     if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

  00711	f3 0f 2a 45 94	 cvtsi2ss xmm0, DWORD PTR _v_range$[ebp]
  00716	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@c2c80000
  0071d	72 12		 jb	 SHORT $LN22@SliderBeha
  0071f	f3 0f 2a 45 94	 cvtsi2ss xmm0, DWORD PTR _v_range$[ebp]
  00724	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@42c80000
  0072c	0f 2f c8	 comiss	 xmm1, xmm0
  0072f	73 11		 jae	 SHORT $LN21@SliderBeha
$LN22@SliderBeha:
  00731	6a 0e		 push	 14			; 0000000eH
  00733	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00738	83 c4 04	 add	 esp, 4
  0073b	0f b6 c0	 movzx	 eax, al
  0073e	85 c0		 test	 eax, eax
  00740	74 49		 je	 SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2385 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

  00742	0f 57 c0	 xorps	 xmm0, xmm0
  00745	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  0074c	76 12		 jbe	 SHORT $LN66@SliderBeha
  0074e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00756	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv284[ebp], xmm0
  0075e	eb 10		 jmp	 SHORT $LN67@SliderBeha
$LN66@SliderBeha:
  00760	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00768	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv284[ebp], xmm0
$LN67@SliderBeha:
  00770	f3 0f 2a 45 94	 cvtsi2ss xmm0, DWORD PTR _v_range$[ebp]
  00775	f3 0f 10 8d 84
	fd ff ff	 movss	 xmm1, DWORD PTR tv284[ebp]
  0077d	f3 0f 5e c8	 divss	 xmm1, xmm0
  00781	f3 0f 11 8d 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm1
  00789	eb 18		 jmp	 SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2386 :                     else
; 2387 :                         delta /= 100.0f;

  0078b	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00793	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0079b	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN20@SliderBeha:

; 2388 :                 }
; 2389 :                 if (IsNavInputDown(ImGuiNavInput_TweakFast))

  007a3	6a 0f		 push	 15			; 0000000fH
  007a5	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  007aa	83 c4 04	 add	 esp, 4
  007ad	0f b6 c0	 movzx	 eax, al
  007b0	85 c0		 test	 eax, eax
  007b2	74 18		 je	 SHORT $LN23@SliderBeha

; 2390 :                     delta *= 10.0f;

  007b4	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  007bc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  007c4	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN23@SliderBeha:

; 2391 :                 set_new_value = true;

  007cc	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1

; 2392 :                 if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

  007d3	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007db	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  007e2	72 11		 jb	 SHORT $LN27@SliderBeha
  007e4	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  007ec	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  007f3	77 18		 ja	 SHORT $LN26@SliderBeha
$LN27@SliderBeha:
  007f5	0f 57 c0	 xorps	 xmm0, xmm0
  007f8	0f 2f 85 28 ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  007ff	72 15		 jb	 SHORT $LN24@SliderBeha
  00801	0f 57 c0	 xorps	 xmm0, xmm0
  00804	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  0080b	76 09		 jbe	 SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2393 :                     set_new_value = false;

  0080d	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0
  00814	eb 24		 jmp	 SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2394 :                 else
; 2395 :                     clicked_t = ImSaturate(clicked_t + delta);

  00816	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0081e	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _delta$13[ebp]
  00826	51		 push	 ecx
  00827	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0082c	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00831	83 c4 04	 add	 esp, 4
  00834	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]
$LN25@SliderBeha:

; 2396 :             }
; 2397 :         }
; 2398 : 
; 2399 :         if (set_new_value)

  0083a	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _set_new_value$17[ebp]
  00841	85 c0		 test	 eax, eax
  00843	0f 84 79 02 00
	00		 je	 $LN39@SliderBeha

; 2400 :         {
; 2401 :             TYPE v_new;
; 2402 :             if (is_power)

  00849	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0084d	85 c0		 test	 eax, eax
  0084f	0f 84 5e 01 00
	00		 je	 $LN29@SliderBeha

; 2403 :             {
; 2404 :                 // Account for power curve scale on both sides of the zero
; 2405 :                 if (clicked_t < linear_zero_pos)

  00855	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0085d	0f 2f 85 28 ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00864	76 7f		 jbe	 SHORT $LN31@SliderBeha

; 2406 :                 {
; 2407 :                     // Negative: rescale to the negative range before powering
; 2408 :                     float a = 1.0f - (clicked_t / linear_zero_pos);

  00866	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0086e	f3 0f 5e 85 64
	ff ff ff	 divss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00876	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0087e	f3 0f 5c c8	 subss	 xmm1, xmm0
  00882	f3 0f 11 8d dc
	fe ff ff	 movss	 DWORD PTR _a$10[ebp], xmm1

; 2409 :                     a = ImPow(a, power);

  0088a	51		 push	 ecx
  0088b	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00890	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00895	51		 push	 ecx
  00896	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  0089e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008a3	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  008a8	83 c4 08	 add	 esp, 8
  008ab	d9 9d dc fe ff
	ff		 fstp	 DWORD PTR _a$10[ebp]

; 2410 :                     v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

  008b1	51		 push	 ecx
  008b2	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  008ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008bf	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  008c2	50		 push	 eax
  008c3	6a 00		 push	 0
  008c5	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  008c8	51		 push	 ecx
  008c9	e8 00 00 00 00	 call	 ??$ImMin@I@@YAIII@Z	; ImMin<unsigned int>
  008ce	83 c4 08	 add	 esp, 8
  008d1	50		 push	 eax
  008d2	e8 00 00 00 00	 call	 ??$ImLerp@I@@YAIIIM@Z	; ImLerp<unsigned int>
  008d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  008da	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax

; 2411 :                 }

  008e0	e9 c9 00 00 00	 jmp	 $LN32@SliderBeha
$LN31@SliderBeha:

; 2412 :                 else
; 2413 :                 {
; 2414 :                     // Positive: rescale to the positive range before powering
; 2415 :                     float a;
; 2416 :                     if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

  008e5	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  008ed	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  008f5	51		 push	 ecx
  008f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008fb	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  00900	83 c4 04	 add	 esp, 4
  00903	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv673[ebp]
  00909	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv673[ebp]
  00911	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@358637bd
  00918	76 2e		 jbe	 SHORT $LN33@SliderBeha

; 2417 :                         a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

  0091a	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00922	f3 0f 5c 85 64
	ff ff ff	 subss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0092a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00932	f3 0f 5c 8d 64
	ff ff ff	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  0093a	f3 0f 5e c1	 divss	 xmm0, xmm1
  0093e	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
  00946	eb 10		 jmp	 SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2418 :                     else
; 2419 :                         a = clicked_t;

  00948	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00950	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
$LN34@SliderBeha:

; 2420 :                     a = ImPow(a, power);

  00958	51		 push	 ecx
  00959	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0095e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00963	51		 push	 ecx
  00964	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  0096c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00971	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00976	83 c4 08	 add	 esp, 8
  00979	d9 9d d0 fe ff
	ff		 fstp	 DWORD PTR _a$9[ebp]

; 2421 :                     v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

  0097f	51		 push	 ecx
  00980	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  00988	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0098d	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  00990	50		 push	 eax
  00991	6a 00		 push	 0
  00993	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00996	51		 push	 ecx
  00997	e8 00 00 00 00	 call	 ??$ImMax@I@@YAIII@Z	; ImMax<unsigned int>
  0099c	83 c4 08	 add	 esp, 8
  0099f	50		 push	 eax
  009a0	e8 00 00 00 00	 call	 ??$ImLerp@I@@YAIIIM@Z	; ImLerp<unsigned int>
  009a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  009a8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
$LN32@SliderBeha:

; 2422 :                 }
; 2423 :             }

  009ae	e9 d3 00 00 00	 jmp	 $LN38@SliderBeha
$LN29@SliderBeha:

; 2424 :             else
; 2425 :             {
; 2426 :                 // Linear slider
; 2427 :                 if (is_decimal)

  009b3	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  009b7	85 c0		 test	 eax, eax
  009b9	74 29		 je	 SHORT $LN35@SliderBeha

; 2428 :                 {
; 2429 :                     v_new = ImLerp(v_min, v_max, clicked_t);

  009bb	51		 push	 ecx
  009bc	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  009c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009c9	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  009cc	50		 push	 eax
  009cd	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  009d0	51		 push	 ecx
  009d1	e8 00 00 00 00	 call	 ??$ImLerp@I@@YAIIIM@Z	; ImLerp<unsigned int>
  009d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  009d9	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax

; 2430 :                 }

  009df	e9 a2 00 00 00	 jmp	 $LN38@SliderBeha
$LN35@SliderBeha:

; 2431 :                 else
; 2432 :                 {
; 2433 :                     // For integer values we want the clicking position to match the grab box so we round above
; 2434 :                     // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2435 :                     FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

  009e4	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  009e7	2b 45 18	 sub	 eax, DWORD PTR _v_min$[ebp]
  009ea	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv696[ebp], eax
  009f0	f2 0f 2a 85 84
	fd ff ff	 cvtsi2sd xmm0, DWORD PTR tv696[ebp]
  009f8	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv696[ebp]
  009fe	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00a01	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00a0a	f2 0f 11 85 7c
	fd ff ff	 movsd	 QWORD PTR tv699[ebp], xmm0
  00a12	f2 0f 5a 85 7c
	fd ff ff	 cvtsd2ss xmm0, QWORD PTR tv699[ebp]
  00a1a	f3 0f 59 85 28
	ff ff ff	 mulss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00a22	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _v_new_off_f$8[ebp], xmm0

; 2436 :                     TYPE v_new_off_floor = (TYPE)(v_new_off_f);

  00a2a	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new_off_f$8[ebp]
  00a32	e8 00 00 00 00	 call	 __ftoui3
  00a37	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _v_new_off_floor$7[ebp], eax

; 2437 :                     TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

  00a3d	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new_off_f$8[ebp]
  00a45	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00a4d	e8 00 00 00 00	 call	 __ftoui3
  00a52	89 85 ac fe ff
	ff		 mov	 DWORD PTR _v_new_off_round$6[ebp], eax

; 2438 :                     if (v_new_off_floor < v_new_off_round)

  00a58	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _v_new_off_floor$7[ebp]
  00a5e	3b 85 ac fe ff
	ff		 cmp	 eax, DWORD PTR _v_new_off_round$6[ebp]
  00a64	73 11		 jae	 SHORT $LN37@SliderBeha

; 2439 :                         v_new = v_min + v_new_off_round;

  00a66	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00a69	03 85 ac fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_round$6[ebp]
  00a6f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  00a75	eb 0f		 jmp	 SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2440 :                     else
; 2441 :                         v_new = v_min + v_new_off_floor;

  00a77	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00a7a	03 85 b8 fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_floor$7[ebp]
  00a80	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
$LN38@SliderBeha:

; 2442 :                 }
; 2443 :             }
; 2444 : 
; 2445 :             // Round to user desired precision based on format string
; 2446 :             v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

  00a86	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _v_new$11[ebp]
  00a8c	50		 push	 eax
  00a8d	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00a90	51		 push	 ecx
  00a91	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00a94	52		 push	 edx
  00a95	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@IH@ImGui@@YAIPBDHI@Z ; ImGui::RoundScalarWithFormatT<unsigned int,int>
  00a9a	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a9d	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax

; 2447 : 
; 2448 :             // Apply result
; 2449 :             if (*v != v_new)

  00aa3	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00aa6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00aa8	3b 8d e8 fe ff
	ff		 cmp	 ecx, DWORD PTR _v_new$11[ebp]
  00aae	74 12		 je	 SHORT $LN39@SliderBeha

; 2450 :             {
; 2451 :                 *v = v_new;

  00ab0	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  00ab3	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new$11[ebp]
  00ab9	89 08		 mov	 DWORD PTR [eax], ecx

; 2452 :                 value_changed = true;

  00abb	c6 85 43 ff ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN39@SliderBeha:

; 2453 :             }
; 2454 :         }
; 2455 :     }
; 2456 : 
; 2457 :     if (slider_sz < 1.0f)

  00ac2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00aca	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00ace	76 31		 jbe	 SHORT $LN40@SliderBeha

; 2458 :     {
; 2459 :         *out_grab_bb = ImRect(bb.Min, bb.Min);

  00ad0	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00ad3	50		 push	 eax
  00ad4	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00ad7	51		 push	 ecx
  00ad8	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00ade	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
  00ae3	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00ae6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ae8	89 0a		 mov	 DWORD PTR [edx], ecx
  00aea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00aed	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00af0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00af3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00af6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00af9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2460 :     }

  00afc	e9 b1 01 00 00	 jmp	 $LN44@SliderBeha
$LN40@SliderBeha:

; 2461 :     else
; 2462 :     {
; 2463 :         // Output grab position so it can be displayed by the caller
; 2464 :         float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  00b01	51		 push	 ecx
  00b02	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00b0a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b0f	51		 push	 ecx
  00b10	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00b15	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b1a	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  00b1d	50		 push	 eax
  00b1e	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00b21	51		 push	 ecx
  00b22	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp]
  00b25	8b 02		 mov	 eax, DWORD PTR [edx]
  00b27	50		 push	 eax
  00b28	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00b2b	51		 push	 ecx
  00b2c	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@IM@ImGui@@YAMHIIIMM@Z ; ImGui::SliderCalcRatioFromValueT<unsigned int,float>
  00b31	83 c4 18	 add	 esp, 24			; 00000018H
  00b34	d9 9d a0 fe ff
	ff		 fstp	 DWORD PTR _grab_t$5[ebp]

; 2465 :         if (axis == ImGuiAxis_Y)

  00b3a	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00b3e	75 18		 jne	 SHORT $LN42@SliderBeha

; 2466 :             grab_t = 1.0f - grab_t;

  00b40	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b48	f3 0f 5c 85 a0
	fe ff ff	 subss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00b50	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _grab_t$5[ebp], xmm0
$LN42@SliderBeha:

; 2467 :         const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

  00b58	51		 push	 ecx
  00b59	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00b61	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b66	51		 push	 ecx
  00b67	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_max$[ebp]
  00b6f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b74	51		 push	 ecx
  00b75	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00b7d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b82	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00b87	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b8a	d9 9d 94 fe ff
	ff		 fstp	 DWORD PTR _grab_pos$4[ebp]

; 2468 :         if (axis == ImGuiAxis_X)

  00b90	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00b94	0f 85 8f 00 00
	00		 jne	 $LN43@SliderBeha

; 2469 :             *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

  00b9a	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00b9d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00ba2	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00baa	51		 push	 ecx
  00bab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bb0	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00bb5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00bbd	f3 0f 58 85 94
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00bc5	51		 push	 ecx
  00bc6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bcb	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00bce	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00bd3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00bdb	51		 push	 ecx
  00bdc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00be1	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00be6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00bee	f3 0f 10 8d 94
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00bf6	f3 0f 5c c8	 subss	 xmm1, xmm0
  00bfa	51		 push	 ecx
  00bfb	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00c00	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00c06	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00c0b	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00c0e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c10	89 0a		 mov	 DWORD PTR [edx], ecx
  00c12	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c15	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c18	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c1b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c1e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c21	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00c24	e9 89 00 00 00	 jmp	 $LN44@SliderBeha
$LN43@SliderBeha:

; 2470 :         else
; 2471 :             *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

  00c29	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c2e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00c36	f3 0f 58 85 94
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00c3e	51		 push	 ecx
  00c3f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c44	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00c47	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00c4c	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00c54	51		 push	 ecx
  00c55	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c5a	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00c5f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00c67	f3 0f 10 8d 94
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00c6f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00c73	51		 push	 ecx
  00c74	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00c79	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00c7c	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00c80	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00c88	51		 push	 ecx
  00c89	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c8e	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00c94	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00c99	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00c9c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c9e	89 0a		 mov	 DWORD PTR [edx], ecx
  00ca0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ca3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ca6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ca9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00cac	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00caf	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN44@SliderBeha:

; 2472 :     }
; 2473 : 
; 2474 :     return value_changed;

  00cb2	8a 85 43 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]

; 2475 : }

  00cb8	52		 push	 edx
  00cb9	8b cd		 mov	 ecx, ebp
  00cbb	50		 push	 eax
  00cbc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN70@SliderBeha
  00cc2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00cc7	58		 pop	 eax
  00cc8	5a		 pop	 edx
  00cc9	5f		 pop	 edi
  00cca	5e		 pop	 esi
  00ccb	5b		 pop	 ebx
  00ccc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ccf	33 cd		 xor	 ecx, ebp
  00cd1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cd6	81 c4 94 02 00
	00		 add	 esp, 660		; 00000294H
  00cdc	3b ec		 cmp	 ebp, esp
  00cde	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ce3	8b e5		 mov	 esp, ebp
  00ce5	5d		 pop	 ebp
  00ce6	c3		 ret	 0
  00ce7	90		 npad	 1
$LN70@SliderBeha:
  00ce8	01 00 00 00	 DD	 1
  00cec	00 00 00 00	 DD	 $LN69@SliderBeha
$LN69@SliderBeha:
  00cf0	0c ff ff ff	 DD	 -244			; ffffff0cH
  00cf4	08 00 00 00	 DD	 8
  00cf8	00 00 00 00	 DD	 $LN68@SliderBeha
$LN68@SliderBeha:
  00cfc	64		 DB	 100			; 00000064H
  00cfd	65		 DB	 101			; 00000065H
  00cfe	6c		 DB	 108			; 0000006cH
  00cff	74		 DB	 116			; 00000074H
  00d00	61		 DB	 97			; 00000061H
  00d01	32		 DB	 50			; 00000032H
  00d02	00		 DB	 0
??$SliderBehaviorT@IHM@ImGui@@YA_NABUImRect@@IHPAIIIPBDMHPAU1@@Z ENDP ; ImGui::SliderBehaviorT<unsigned int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$SliderBehaviorT@HHM@ImGui@@YA_NABUImRect@@IHPAHHHPBDMHPAU1@@Z
_TEXT	SEGMENT
tv442 = -644						; size = 4
tv743 = -640						; size = 4
tv620 = -636						; size = 4
tv507 = -636						; size = 4
tv500 = -636						; size = 4
tv437 = -636						; size = 4
tv284 = -636						; size = 4
tv265 = -636						; size = 4
tv214 = -636						; size = 4
tv202 = -636						; size = 4
tv179 = -636						; size = 4
tv172 = -636						; size = 4
tv163 = -636						; size = 4
tv89 = -636						; size = 4
tv67 = -636						; size = 4
tv74 = -633						; size = 1
tv70 = -633						; size = 1
$T1 = -628						; size = 16
$T2 = -604						; size = 16
$T3 = -580						; size = 16
_grab_pos$4 = -364					; size = 4
_grab_t$5 = -352					; size = 4
_v_new_off_round$6 = -340				; size = 4
_v_new_off_floor$7 = -328				; size = 4
_v_new_off_f$8 = -316					; size = 4
_a$9 = -304						; size = 4
_a$10 = -292						; size = 4
_v_new$11 = -280					; size = 4
_decimal_precision$12 = -268				; size = 4
_delta$13 = -256					; size = 4
_delta2$14 = -244					; size = 8
_mouse_abs_pos$15 = -228				; size = 4
_clicked_t$16 = -216					; size = 4
_set_new_value$17 = -201				; size = 1
_value_changed$ = -189					; size = 1
_linear_dist_max_to_0$18 = -180				; size = 4
_linear_dist_min_to_0$19 = -168				; size = 4
_linear_zero_pos$ = -156				; size = 4
_slider_usable_pos_max$ = -144				; size = 4
_slider_usable_pos_min$ = -132				; size = 4
_slider_usable_sz$ = -120				; size = 4
_v_range$ = -108					; size = 4
_grab_sz$ = -96						; size = 4
_slider_sz$ = -84					; size = 4
_grab_padding$ = -72					; size = 4
_is_power$ = -57					; size = 1
_is_decimal$ = -45					; size = 1
_axis$ = -36						; size = 4
_style$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_data_type$ = 16					; size = 4
_v$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
_flags$ = 40						; size = 4
_out_grab_bb$ = 44					; size = 4
??$SliderBehaviorT@HHM@ImGui@@YA_NABUImRect@@IHPAHHHPBDMHPAU1@@Z PROC ; ImGui::SliderBehaviorT<int,int,float>, COMDAT

; 2309 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 7c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-644]
  00012	b9 a1 00 00 00	 mov	 ecx, 161		; 000000a1H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2310 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2311 :     const ImGuiStyle& style = g.Style;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00042	89 45 e8	 mov	 DWORD PTR _style$[ebp], eax

; 2312 : 
; 2313 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00045	8b 45 28	 mov	 eax, DWORD PTR _flags$[ebp]
  00048	83 e0 01	 and	 eax, 1
  0004b	74 0c		 je	 SHORT $LN46@SliderBeha
  0004d	c7 85 84 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00057	eb 0a		 jmp	 SHORT $LN47@SliderBeha
$LN46@SliderBeha:
  00059	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN47@SliderBeha:
  00063	8b 8d 84 fd ff
	ff		 mov	 ecx, DWORD PTR tv67[ebp]
  00069	89 4d dc	 mov	 DWORD PTR _axis$[ebp], ecx

; 2314 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  0006c	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00070	74 0f		 je	 SHORT $LN48@SliderBeha
  00072	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00076	74 09		 je	 SHORT $LN48@SliderBeha
  00078	c6 85 87 fd ff
	ff 00		 mov	 BYTE PTR tv70[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN49@SliderBeha
$LN48@SliderBeha:
  00081	c6 85 87 fd ff
	ff 01		 mov	 BYTE PTR tv70[ebp], 1
$LN49@SliderBeha:
  00088	8a 85 87 fd ff
	ff		 mov	 al, BYTE PTR tv70[ebp]
  0008e	88 45 d3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 2315 :     const bool is_power = (power != 1.0f) && is_decimal;

  00091	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00096	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  0009d	9f		 lahf
  0009e	f6 c4 44	 test	 ah, 68			; 00000044H
  000a1	7b 11		 jnp	 SHORT $LN50@SliderBeha
  000a3	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 09		 je	 SHORT $LN50@SliderBeha
  000ab	c6 85 87 fd ff
	ff 01		 mov	 BYTE PTR tv74[ebp], 1
  000b2	eb 07		 jmp	 SHORT $LN51@SliderBeha
$LN50@SliderBeha:
  000b4	c6 85 87 fd ff
	ff 00		 mov	 BYTE PTR tv74[ebp], 0
$LN51@SliderBeha:
  000bb	8a 8d 87 fd ff
	ff		 mov	 cl, BYTE PTR tv74[ebp]
  000c1	88 4d c7	 mov	 BYTE PTR _is_power$[ebp], cl

; 2316 : 
; 2317 :     const float grab_padding = 2.0f;

  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000cc	f3 0f 11 45 b8	 movss	 DWORD PTR _grab_padding$[ebp], xmm0

; 2318 :     const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;

  000d1	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000d8	83 c1 08	 add	 ecx, 8
  000db	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  000e0	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv437[ebp]
  000e6	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv437[ebp]
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _axis$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000f5	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR tv743[ebp], xmm0
  000fd	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00102	d9 9d 7c fd ff
	ff		 fstp	 DWORD PTR tv442[ebp]
  00108	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR tv743[ebp]
  00110	f3 0f 5c 85 7c
	fd ff ff	 subss	 xmm0, DWORD PTR tv442[ebp]
  00118	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00120	f3 0f 11 45 ac	 movss	 DWORD PTR _slider_sz$[ebp], xmm0

; 2319 :     float grab_sz = style.GrabMinSize;

  00125	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  00128	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  0012d	f3 0f 11 45 a0	 movss	 DWORD PTR _grab_sz$[ebp], xmm0

; 2320 :     SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);

  00132	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00135	3b 45 1c	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00138	7d 0e		 jge	 SHORT $LN52@SliderBeha
  0013a	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0013d	2b 4d 18	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00140	89 8d 84 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], ecx
  00146	eb 0c		 jmp	 SHORT $LN53@SliderBeha
$LN52@SliderBeha:
  00148	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp]
  0014b	2b 55 1c	 sub	 edx, DWORD PTR _v_max$[ebp]
  0014e	89 95 84 fd ff
	ff		 mov	 DWORD PTR tv89[ebp], edx
$LN53@SliderBeha:
  00154	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR tv89[ebp]
  0015a	89 45 94	 mov	 DWORD PTR _v_range$[ebp], eax

; 2321 :     if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows

  0015d	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00161	85 c0		 test	 eax, eax
  00163	75 38		 jne	 SHORT $LN2@SliderBeha
  00165	83 7d 94 00	 cmp	 DWORD PTR _v_range$[ebp], 0
  00169	7c 32		 jl	 SHORT $LN2@SliderBeha

; 2322 :         grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit

  0016b	8b 45 e8	 mov	 eax, DWORD PTR _style$[ebp]
  0016e	51		 push	 ecx
  0016f	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	8b 4d 94	 mov	 ecx, DWORD PTR _v_range$[ebp]
  0017c	83 c1 01	 add	 ecx, 1
  0017f	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00183	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _slider_sz$[ebp]
  00188	f3 0f 5e c8	 divss	 xmm1, xmm0
  0018c	51		 push	 ecx
  0018d	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00192	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00197	83 c4 08	 add	 esp, 8
  0019a	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]
$LN2@SliderBeha:

; 2323 :     grab_sz = ImMin(grab_sz, slider_sz);

  0019d	51		 push	 ecx
  0019e	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a8	51		 push	 ecx
  001a9	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b3	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001b8	83 c4 08	 add	 esp, 8
  001bb	d9 5d a0	 fstp	 DWORD PTR _grab_sz$[ebp]

; 2324 :     const float slider_usable_sz = slider_sz - grab_sz;

  001be	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _slider_sz$[ebp]
  001c3	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _grab_sz$[ebp]
  001c8	f3 0f 11 45 88	 movss	 DWORD PTR _slider_usable_sz$[ebp], xmm0

; 2325 :     const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;

  001cd	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  001d0	50		 push	 eax
  001d1	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  001d4	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  001d9	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv500[ebp]
  001df	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv500[ebp]
  001e7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  001ef	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  001f4	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  001fc	f3 0f 58 c1	 addss	 xmm0, xmm1
  00200	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_min$[ebp], xmm0

; 2326 :     const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;

  00208	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  0020b	50		 push	 eax
  0020c	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  0020f	83 c1 08	 add	 ecx, 8
  00212	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00217	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv507[ebp]
  0021d	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv507[ebp]
  00225	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  0022d	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR _grab_sz$[ebp]
  00232	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0023a	f3 0f 5c c1	 subss	 xmm0, xmm1
  0023e	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _slider_usable_pos_max$[ebp], xmm0

; 2327 : 
; 2328 :     // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
; 2329 :     float linear_zero_pos;   // 0.0->1.0f
; 2330 :     if (is_power && v_min * v_max < 0.0f)

  00246	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0024a	85 c0		 test	 eax, eax
  0024c	0f 84 ed 00 00
	00		 je	 $LN3@SliderBeha
  00252	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00255	0f af 45 1c	 imul	 eax, DWORD PTR _v_max$[ebp]
  00259	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0025d	0f 57 c9	 xorps	 xmm1, xmm1
  00260	0f 2f c8	 comiss	 xmm1, xmm0
  00263	0f 86 d6 00 00
	00		 jbe	 $LN3@SliderBeha

; 2331 :     {
; 2332 :         // Different sign
; 2333 :         const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);

  00269	83 7d 18 00	 cmp	 DWORD PTR _v_min$[ebp], 0
  0026d	7c 0f		 jl	 SHORT $LN54@SliderBeha
  0026f	f3 0f 2a 45 18	 cvtsi2ss xmm0, DWORD PTR _v_min$[ebp]
  00274	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv163[ebp], xmm0
  0027c	eb 14		 jmp	 SHORT $LN55@SliderBeha
$LN54@SliderBeha:
  0027e	f3 0f 2a 45 18	 cvtsi2ss xmm0, DWORD PTR _v_min$[ebp]
  00283	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0028a	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv163[ebp], xmm0
$LN55@SliderBeha:
  00292	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0029a	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  0029f	51		 push	 ecx
  002a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a5	51		 push	 ecx
  002a6	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv163[ebp]
  002ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b3	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  002b8	83 c4 08	 add	 esp, 8
  002bb	d9 9d 58 ff ff
	ff		 fstp	 DWORD PTR _linear_dist_min_to_0$19[ebp]

; 2334 :         const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);

  002c1	83 7d 1c 00	 cmp	 DWORD PTR _v_max$[ebp], 0
  002c5	7c 0f		 jl	 SHORT $LN56@SliderBeha
  002c7	f3 0f 2a 45 1c	 cvtsi2ss xmm0, DWORD PTR _v_max$[ebp]
  002cc	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
  002d4	eb 14		 jmp	 SHORT $LN57@SliderBeha
$LN56@SliderBeha:
  002d6	f3 0f 2a 45 1c	 cvtsi2ss xmm0, DWORD PTR _v_max$[ebp]
  002db	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002e2	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
$LN57@SliderBeha:
  002ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002f2	f3 0f 5e 45 24	 divss	 xmm0, DWORD PTR _power$[ebp]
  002f7	51		 push	 ecx
  002f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fd	51		 push	 ecx
  002fe	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv172[ebp]
  00306	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030b	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00310	83 c4 08	 add	 esp, 8
  00313	d9 9d 4c ff ff
	ff		 fstp	 DWORD PTR _linear_dist_max_to_0$18[ebp]

; 2335 :         linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));

  00319	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_dist_min_to_0$19[ebp]
  00321	f3 0f 58 85 4c
	ff ff ff	 addss	 xmm0, DWORD PTR _linear_dist_max_to_0$18[ebp]
  00329	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _linear_dist_min_to_0$19[ebp]
  00331	f3 0f 5e c8	 divss	 xmm1, xmm0
  00335	f3 0f 11 8d 64
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm1

; 2336 :     }

  0033d	eb 3a		 jmp	 SHORT $LN4@SliderBeha
$LN3@SliderBeha:

; 2337 :     else
; 2338 :     {
; 2339 :         // Same sign
; 2340 :         linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

  0033f	f3 0f 2a 45 18	 cvtsi2ss xmm0, DWORD PTR _v_min$[ebp]
  00344	0f 57 c9	 xorps	 xmm1, xmm1
  00347	0f 2f c8	 comiss	 xmm1, xmm0
  0034a	76 12		 jbe	 SHORT $LN58@SliderBeha
  0034c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00354	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv179[ebp], xmm0
  0035c	eb 0b		 jmp	 SHORT $LN59@SliderBeha
$LN58@SliderBeha:
  0035e	0f 57 c0	 xorps	 xmm0, xmm0
  00361	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv179[ebp], xmm0
$LN59@SliderBeha:
  00369	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv179[ebp]
  00371	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _linear_zero_pos$[ebp], xmm0
$LN4@SliderBeha:

; 2341 :     }
; 2342 : 
; 2343 :     // Process interacting with the slider
; 2344 :     bool value_changed = false;

  00379	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 2345 :     if (g.ActiveId == id)

  00380	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00383	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00389	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0038c	0f 85 e9 05 00
	00		 jne	 $LN39@SliderBeha

; 2346 :     {
; 2347 :         bool set_new_value = false;

  00392	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0

; 2348 :         float clicked_t = 0.0f;

  00399	0f 57 c0	 xorps	 xmm0, xmm0
  0039c	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2349 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

  003a4	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  003a7	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  003ae	0f 85 d4 00 00
	00		 jne	 $LN6@SliderBeha

; 2350 :         {
; 2351 :             if (!g.IO.MouseDown[0])

  003b4	b8 01 00 00 00	 mov	 eax, 1
  003b9	6b c8 00	 imul	 ecx, eax, 0
  003bc	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  003bf	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  003c7	85 c0		 test	 eax, eax
  003c9	75 0a		 jne	 SHORT $LN8@SliderBeha

; 2352 :             {
; 2353 :                 ClearActiveID();

  003cb	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2354 :             }

  003d0	e9 ae 00 00 00	 jmp	 $LN9@SliderBeha
$LN8@SliderBeha:

; 2355 :             else
; 2356 :             {
; 2357 :                 const float mouse_abs_pos = g.IO.MousePos[axis];

  003d5	8b 45 dc	 mov	 eax, DWORD PTR _axis$[ebp]
  003d8	50		 push	 eax
  003d9	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  003dc	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  003e2	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  003e7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003eb	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _mouse_abs_pos$15[ebp], xmm0

; 2358 :                 clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

  003f3	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  003f8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003ff	76 42		 jbe	 SHORT $LN60@SliderBeha
  00401	51		 push	 ecx
  00402	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0040a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0040f	51		 push	 ecx
  00410	0f 57 c0	 xorps	 xmm0, xmm0
  00413	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00418	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_abs_pos$15[ebp]
  00420	f3 0f 5c 85 7c
	ff ff ff	 subss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00428	f3 0f 5e 45 88	 divss	 xmm0, DWORD PTR _slider_usable_sz$[ebp]
  0042d	51		 push	 ecx
  0042e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00433	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  00438	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043b	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv202[ebp]
  00441	eb 0b		 jmp	 SHORT $LN61@SliderBeha
$LN60@SliderBeha:
  00443	0f 57 c0	 xorps	 xmm0, xmm0
  00446	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv202[ebp], xmm0
$LN61@SliderBeha:
  0044e	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv202[ebp]
  00456	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0

; 2359 :                 if (axis == ImGuiAxis_Y)

  0045e	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00462	75 18		 jne	 SHORT $LN10@SliderBeha

; 2360 :                     clicked_t = 1.0f - clicked_t;

  00464	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0046c	f3 0f 5c 85 28
	ff ff ff	 subss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00474	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _clicked_t$16[ebp], xmm0
$LN10@SliderBeha:

; 2361 :                 set_new_value = true;

  0047c	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1
$LN9@SliderBeha:

; 2362 :             }
; 2363 :         }

  00483	e9 a0 02 00 00	 jmp	 $LN25@SliderBeha
$LN6@SliderBeha:

; 2364 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  00488	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0048b	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  00492	0f 85 90 02 00
	00		 jne	 $LN25@SliderBeha

; 2365 :         {
; 2366 :             const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);

  00498	51		 push	 ecx
  00499	0f 57 c0	 xorps	 xmm0, xmm0
  0049c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a1	51		 push	 ecx
  004a2	0f 57 c0	 xorps	 xmm0, xmm0
  004a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004aa	6a 05		 push	 5
  004ac	6a 03		 push	 3
  004ae	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _delta2$14[ebp]
  004b4	50		 push	 eax
  004b5	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  004ba	83 c4 14	 add	 esp, 20			; 00000014H

; 2367 :             float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;

  004bd	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  004c1	75 12		 jne	 SHORT $LN62@SliderBeha
  004c3	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp]
  004cb	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv214[ebp], xmm0
  004d3	eb 17		 jmp	 SHORT $LN63@SliderBeha
$LN62@SliderBeha:
  004d5	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _delta2$14[ebp+4]
  004dd	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  004e4	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv214[ebp], xmm0
$LN63@SliderBeha:
  004ec	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv214[ebp]
  004f4	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2368 :             if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

  004fc	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  004ff	8b 88 e0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6880]
  00505	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00508	75 18		 jne	 SHORT $LN12@SliderBeha
  0050a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0050d	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  00514	85 c9		 test	 ecx, ecx
  00516	75 0a		 jne	 SHORT $LN12@SliderBeha

; 2369 :             {
; 2370 :                 ClearActiveID();

  00518	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID

; 2371 :             }

  0051d	e9 06 02 00 00	 jmp	 $LN25@SliderBeha
$LN12@SliderBeha:

; 2372 :             else if (delta != 0.0f)

  00522	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  0052a	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00531	9f		 lahf
  00532	f6 c4 44	 test	 ah, 68			; 00000044H
  00535	0f 8b ed 01 00
	00		 jnp	 $LN25@SliderBeha

; 2373 :             {
; 2374 :                 clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  0053b	51		 push	 ecx
  0053c	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00544	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00549	51		 push	 ecx
  0054a	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0054f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00554	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  00557	50		 push	 eax
  00558	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  0055b	51		 push	 ecx
  0055c	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp]
  0055f	8b 02		 mov	 eax, DWORD PTR [edx]
  00561	50		 push	 eax
  00562	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00565	51		 push	 ecx
  00566	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ; ImGui::SliderCalcRatioFromValueT<int,float>
  0056b	83 c4 18	 add	 esp, 24			; 00000018H
  0056e	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]

; 2375 :                 const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00574	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00578	85 c0		 test	 eax, eax
  0057a	74 16		 je	 SHORT $LN64@SliderBeha
  0057c	6a 03		 push	 3
  0057e	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  00581	51		 push	 ecx
  00582	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00587	83 c4 08	 add	 esp, 8
  0058a	89 85 84 fd ff
	ff		 mov	 DWORD PTR tv265[ebp], eax
  00590	eb 0a		 jmp	 SHORT $LN65@SliderBeha
$LN64@SliderBeha:
  00592	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv265[ebp], 0
$LN65@SliderBeha:
  0059c	8b 95 84 fd ff
	ff		 mov	 edx, DWORD PTR tv265[ebp]
  005a2	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _decimal_precision$12[ebp], edx

; 2376 :                 if ((decimal_precision > 0) || is_power)

  005a8	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _decimal_precision$12[ebp], 0
  005af	7f 08		 jg	 SHORT $LN17@SliderBeha
  005b1	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  005b5	85 c0		 test	 eax, eax
  005b7	74 46		 je	 SHORT $LN15@SliderBeha
$LN17@SliderBeha:

; 2377 :                 {
; 2378 :                     delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

  005b9	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  005c1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  005c9	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0

; 2379 :                     if (IsNavInputDown(ImGuiNavInput_TweakSlow))

  005d1	6a 0e		 push	 14			; 0000000eH
  005d3	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  005d8	83 c4 04	 add	 esp, 4
  005db	0f b6 c0	 movzx	 eax, al
  005de	85 c0		 test	 eax, eax
  005e0	74 18		 je	 SHORT $LN18@SliderBeha

; 2380 :                         delta /= 10.0f;

  005e2	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  005ea	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  005f2	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN18@SliderBeha:

; 2381 :                 }

  005fa	e9 92 00 00 00	 jmp	 $LN20@SliderBeha
$LN15@SliderBeha:

; 2382 :                 else
; 2383 :                 {
; 2384 :                     if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))

  005ff	f3 0f 2a 45 94	 cvtsi2ss xmm0, DWORD PTR _v_range$[ebp]
  00604	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@c2c80000
  0060b	72 12		 jb	 SHORT $LN22@SliderBeha
  0060d	f3 0f 2a 45 94	 cvtsi2ss xmm0, DWORD PTR _v_range$[ebp]
  00612	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@42c80000
  0061a	0f 2f c8	 comiss	 xmm1, xmm0
  0061d	73 11		 jae	 SHORT $LN21@SliderBeha
$LN22@SliderBeha:
  0061f	6a 0e		 push	 14			; 0000000eH
  00621	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00626	83 c4 04	 add	 esp, 4
  00629	0f b6 c0	 movzx	 eax, al
  0062c	85 c0		 test	 eax, eax
  0062e	74 49		 je	 SHORT $LN19@SliderBeha
$LN21@SliderBeha:

; 2385 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps

  00630	0f 57 c0	 xorps	 xmm0, xmm0
  00633	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  0063a	76 12		 jbe	 SHORT $LN66@SliderBeha
  0063c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00644	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv284[ebp], xmm0
  0064c	eb 10		 jmp	 SHORT $LN67@SliderBeha
$LN66@SliderBeha:
  0064e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00656	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR tv284[ebp], xmm0
$LN67@SliderBeha:
  0065e	f3 0f 2a 45 94	 cvtsi2ss xmm0, DWORD PTR _v_range$[ebp]
  00663	f3 0f 10 8d 84
	fd ff ff	 movss	 xmm1, DWORD PTR tv284[ebp]
  0066b	f3 0f 5e c8	 divss	 xmm1, xmm0
  0066f	f3 0f 11 8d 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm1
  00677	eb 18		 jmp	 SHORT $LN20@SliderBeha
$LN19@SliderBeha:

; 2386 :                     else
; 2387 :                         delta /= 100.0f;

  00679	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  00681	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00689	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN20@SliderBeha:

; 2388 :                 }
; 2389 :                 if (IsNavInputDown(ImGuiNavInput_TweakFast))

  00691	6a 0f		 push	 15			; 0000000fH
  00693	e8 00 00 00 00	 call	 ?IsNavInputDown@ImGui@@YA_NH@Z ; ImGui::IsNavInputDown
  00698	83 c4 04	 add	 esp, 4
  0069b	0f b6 c0	 movzx	 eax, al
  0069e	85 c0		 test	 eax, eax
  006a0	74 18		 je	 SHORT $LN23@SliderBeha

; 2390 :                     delta *= 10.0f;

  006a2	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  006aa	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  006b2	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _delta$13[ebp], xmm0
$LN23@SliderBeha:

; 2391 :                 set_new_value = true;

  006ba	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _set_new_value$17[ebp], 1

; 2392 :                 if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits

  006c1	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  006c9	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  006d0	72 11		 jb	 SHORT $LN27@SliderBeha
  006d2	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _delta$13[ebp]
  006da	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  006e1	77 18		 ja	 SHORT $LN26@SliderBeha
$LN27@SliderBeha:
  006e3	0f 57 c0	 xorps	 xmm0, xmm0
  006e6	0f 2f 85 28 ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  006ed	72 15		 jb	 SHORT $LN24@SliderBeha
  006ef	0f 57 c0	 xorps	 xmm0, xmm0
  006f2	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR _delta$13[ebp]
  006f9	76 09		 jbe	 SHORT $LN24@SliderBeha
$LN26@SliderBeha:

; 2393 :                     set_new_value = false;

  006fb	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _set_new_value$17[ebp], 0
  00702	eb 24		 jmp	 SHORT $LN25@SliderBeha
$LN24@SliderBeha:

; 2394 :                 else
; 2395 :                     clicked_t = ImSaturate(clicked_t + delta);

  00704	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0070c	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _delta$13[ebp]
  00714	51		 push	 ecx
  00715	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0071a	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0071f	83 c4 04	 add	 esp, 4
  00722	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _clicked_t$16[ebp]
$LN25@SliderBeha:

; 2396 :             }
; 2397 :         }
; 2398 : 
; 2399 :         if (set_new_value)

  00728	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _set_new_value$17[ebp]
  0072f	85 c0		 test	 eax, eax
  00731	0f 84 44 02 00
	00		 je	 $LN39@SliderBeha

; 2400 :         {
; 2401 :             TYPE v_new;
; 2402 :             if (is_power)

  00737	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0073b	85 c0		 test	 eax, eax
  0073d	0f 84 5e 01 00
	00		 je	 $LN29@SliderBeha

; 2403 :             {
; 2404 :                 // Account for power curve scale on both sides of the zero
; 2405 :                 if (clicked_t < linear_zero_pos)

  00743	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  0074b	0f 2f 85 28 ff
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00752	76 7f		 jbe	 SHORT $LN31@SliderBeha

; 2406 :                 {
; 2407 :                     // Negative: rescale to the negative range before powering
; 2408 :                     float a = 1.0f - (clicked_t / linear_zero_pos);

  00754	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0075c	f3 0f 5e 85 64
	ff ff ff	 divss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00764	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0076c	f3 0f 5c c8	 subss	 xmm1, xmm0
  00770	f3 0f 11 8d dc
	fe ff ff	 movss	 DWORD PTR _a$10[ebp], xmm1

; 2409 :                     a = ImPow(a, power);

  00778	51		 push	 ecx
  00779	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0077e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00783	51		 push	 ecx
  00784	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  0078c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00791	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00796	83 c4 08	 add	 esp, 8
  00799	d9 9d dc fe ff
	ff		 fstp	 DWORD PTR _a$10[ebp]

; 2410 :                     v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);

  0079f	51		 push	 ecx
  007a0	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _a$10[ebp]
  007a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007ad	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  007b0	50		 push	 eax
  007b1	6a 00		 push	 0
  007b3	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  007b6	51		 push	 ecx
  007b7	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  007bc	83 c4 08	 add	 esp, 8
  007bf	50		 push	 eax
  007c0	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  007c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  007c8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax

; 2411 :                 }

  007ce	e9 c9 00 00 00	 jmp	 $LN32@SliderBeha
$LN31@SliderBeha:

; 2412 :                 else
; 2413 :                 {
; 2414 :                     // Positive: rescale to the positive range before powering
; 2415 :                     float a;
; 2416 :                     if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)

  007d3	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  007db	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  007e3	51		 push	 ecx
  007e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007e9	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  007ee	83 c4 04	 add	 esp, 4
  007f1	d9 9d 84 fd ff
	ff		 fstp	 DWORD PTR tv620[ebp]
  007f7	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR tv620[ebp]
  007ff	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@358637bd
  00806	76 2e		 jbe	 SHORT $LN33@SliderBeha

; 2417 :                         a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

  00808	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  00810	f3 0f 5c 85 64
	ff ff ff	 subss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  00818	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00820	f3 0f 5c 8d 64
	ff ff ff	 subss	 xmm1, DWORD PTR _linear_zero_pos$[ebp]
  00828	f3 0f 5e c1	 divss	 xmm0, xmm1
  0082c	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
  00834	eb 10		 jmp	 SHORT $LN34@SliderBeha
$LN33@SliderBeha:

; 2418 :                     else
; 2419 :                         a = clicked_t;

  00836	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  0083e	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _a$9[ebp], xmm0
$LN34@SliderBeha:

; 2420 :                     a = ImPow(a, power);

  00846	51		 push	 ecx
  00847	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0084c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00851	51		 push	 ecx
  00852	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  0085a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0085f	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00864	83 c4 08	 add	 esp, 8
  00867	d9 9d d0 fe ff
	ff		 fstp	 DWORD PTR _a$9[ebp]

; 2421 :                     v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);

  0086d	51		 push	 ecx
  0086e	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _a$9[ebp]
  00876	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0087b	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  0087e	50		 push	 eax
  0087f	6a 00		 push	 0
  00881	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00884	51		 push	 ecx
  00885	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  0088a	83 c4 08	 add	 esp, 8
  0088d	50		 push	 eax
  0088e	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  00893	83 c4 0c	 add	 esp, 12			; 0000000cH
  00896	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
$LN32@SliderBeha:

; 2422 :                 }
; 2423 :             }

  0089c	e9 9e 00 00 00	 jmp	 $LN38@SliderBeha
$LN29@SliderBeha:

; 2424 :             else
; 2425 :             {
; 2426 :                 // Linear slider
; 2427 :                 if (is_decimal)

  008a1	0f b6 45 d3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  008a5	85 c0		 test	 eax, eax
  008a7	74 26		 je	 SHORT $LN35@SliderBeha

; 2428 :                 {
; 2429 :                     v_new = ImLerp(v_min, v_max, clicked_t);

  008a9	51		 push	 ecx
  008aa	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  008b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008b7	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  008ba	50		 push	 eax
  008bb	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  008be	51		 push	 ecx
  008bf	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  008c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  008c7	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax

; 2430 :                 }

  008cd	eb 70		 jmp	 SHORT $LN38@SliderBeha
$LN35@SliderBeha:

; 2431 :                 else
; 2432 :                 {
; 2433 :                     // For integer values we want the clicking position to match the grab box so we round above
; 2434 :                     // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2435 :                     FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;

  008cf	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  008d2	2b 45 18	 sub	 eax, DWORD PTR _v_min$[ebp]
  008d5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  008d9	f3 0f 59 85 28
	ff ff ff	 mulss	 xmm0, DWORD PTR _clicked_t$16[ebp]
  008e1	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _v_new_off_f$8[ebp], xmm0

; 2436 :                     TYPE v_new_off_floor = (TYPE)(v_new_off_f);

  008e9	f3 0f 2c 85 c4
	fe ff ff	 cvttss2si eax, DWORD PTR _v_new_off_f$8[ebp]
  008f1	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _v_new_off_floor$7[ebp], eax

; 2437 :                     TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);

  008f7	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR _v_new_off_f$8[ebp]
  008ff	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00907	f3 0f 2c c0	 cvttss2si eax, xmm0
  0090b	89 85 ac fe ff
	ff		 mov	 DWORD PTR _v_new_off_round$6[ebp], eax

; 2438 :                     if (v_new_off_floor < v_new_off_round)

  00911	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _v_new_off_floor$7[ebp]
  00917	3b 85 ac fe ff
	ff		 cmp	 eax, DWORD PTR _v_new_off_round$6[ebp]
  0091d	7d 11		 jge	 SHORT $LN37@SliderBeha

; 2439 :                         v_new = v_min + v_new_off_round;

  0091f	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00922	03 85 ac fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_round$6[ebp]
  00928	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
  0092e	eb 0f		 jmp	 SHORT $LN38@SliderBeha
$LN37@SliderBeha:

; 2440 :                     else
; 2441 :                         v_new = v_min + v_new_off_floor;

  00930	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00933	03 85 b8 fe ff
	ff		 add	 eax, DWORD PTR _v_new_off_floor$7[ebp]
  00939	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax
$LN38@SliderBeha:

; 2442 :                 }
; 2443 :             }
; 2444 : 
; 2445 :             // Round to user desired precision based on format string
; 2446 :             v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);

  0093f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _v_new$11[ebp]
  00945	50		 push	 eax
  00946	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00949	51		 push	 ecx
  0094a	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  0094d	52		 push	 edx
  0094e	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@HH@ImGui@@YAHPBDHH@Z ; ImGui::RoundScalarWithFormatT<int,int>
  00953	83 c4 0c	 add	 esp, 12			; 0000000cH
  00956	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _v_new$11[ebp], eax

; 2447 : 
; 2448 :             // Apply result
; 2449 :             if (*v != v_new)

  0095c	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  0095f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00961	3b 8d e8 fe ff
	ff		 cmp	 ecx, DWORD PTR _v_new$11[ebp]
  00967	74 12		 je	 SHORT $LN39@SliderBeha

; 2450 :             {
; 2451 :                 *v = v_new;

  00969	8b 45 14	 mov	 eax, DWORD PTR _v$[ebp]
  0096c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _v_new$11[ebp]
  00972	89 08		 mov	 DWORD PTR [eax], ecx

; 2452 :                 value_changed = true;

  00974	c6 85 43 ff ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN39@SliderBeha:

; 2453 :             }
; 2454 :         }
; 2455 :     }
; 2456 : 
; 2457 :     if (slider_sz < 1.0f)

  0097b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00983	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _slider_sz$[ebp]
  00987	76 31		 jbe	 SHORT $LN40@SliderBeha

; 2458 :     {
; 2459 :         *out_grab_bb = ImRect(bb.Min, bb.Min);

  00989	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  0098c	50		 push	 eax
  0098d	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00990	51		 push	 ecx
  00991	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00997	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
  0099c	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  0099f	8b 08		 mov	 ecx, DWORD PTR [eax]
  009a1	89 0a		 mov	 DWORD PTR [edx], ecx
  009a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009a6	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  009a9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  009ac	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  009af	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  009b2	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2460 :     }

  009b5	e9 b1 01 00 00	 jmp	 $LN44@SliderBeha
$LN40@SliderBeha:

; 2461 :     else
; 2462 :     {
; 2463 :         // Output grab position so it can be displayed by the caller
; 2464 :         float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);

  009ba	51		 push	 ecx
  009bb	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _linear_zero_pos$[ebp]
  009c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009c8	51		 push	 ecx
  009c9	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  009ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009d3	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  009d6	50		 push	 eax
  009d7	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  009da	51		 push	 ecx
  009db	8b 55 14	 mov	 edx, DWORD PTR _v$[ebp]
  009de	8b 02		 mov	 eax, DWORD PTR [edx]
  009e0	50		 push	 eax
  009e1	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  009e4	51		 push	 ecx
  009e5	e8 00 00 00 00	 call	 ??$SliderCalcRatioFromValueT@HM@ImGui@@YAMHHHHMM@Z ; ImGui::SliderCalcRatioFromValueT<int,float>
  009ea	83 c4 18	 add	 esp, 24			; 00000018H
  009ed	d9 9d a0 fe ff
	ff		 fstp	 DWORD PTR _grab_t$5[ebp]

; 2465 :         if (axis == ImGuiAxis_Y)

  009f3	83 7d dc 01	 cmp	 DWORD PTR _axis$[ebp], 1
  009f7	75 18		 jne	 SHORT $LN42@SliderBeha

; 2466 :             grab_t = 1.0f - grab_t;

  009f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a01	f3 0f 5c 85 a0
	fe ff ff	 subss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00a09	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _grab_t$5[ebp], xmm0
$LN42@SliderBeha:

; 2467 :         const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);

  00a11	51		 push	 ecx
  00a12	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR _grab_t$5[ebp]
  00a1a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a1f	51		 push	 ecx
  00a20	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_max$[ebp]
  00a28	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a2d	51		 push	 ecx
  00a2e	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _slider_usable_pos_min$[ebp]
  00a36	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a3b	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00a40	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a43	d9 9d 94 fe ff
	ff		 fstp	 DWORD PTR _grab_pos$4[ebp]

; 2468 :         if (axis == ImGuiAxis_X)

  00a49	83 7d dc 00	 cmp	 DWORD PTR _axis$[ebp], 0
  00a4d	0f 85 8f 00 00
	00		 jne	 $LN43@SliderBeha

; 2469 :             *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);

  00a53	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00a56	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00a5b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00a63	51		 push	 ecx
  00a64	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a69	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00a6e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00a76	f3 0f 58 85 94
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00a7e	51		 push	 ecx
  00a7f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a84	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00a87	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00a8c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00a94	51		 push	 ecx
  00a95	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a9a	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00a9f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00aa7	f3 0f 10 8d 94
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00aaf	f3 0f 5c c8	 subss	 xmm1, xmm0
  00ab3	51		 push	 ecx
  00ab4	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00ab9	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00abf	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00ac4	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00ac7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ac9	89 0a		 mov	 DWORD PTR [edx], ecx
  00acb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ace	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ad1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ad4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00ad7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00ada	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00add	e9 89 00 00 00	 jmp	 $LN44@SliderBeha
$LN43@SliderBeha:

; 2470 :         else
; 2471 :             *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);

  00ae2	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00ae7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00aef	f3 0f 58 85 94
	fe ff ff	 addss	 xmm0, DWORD PTR _grab_pos$4[ebp]
  00af7	51		 push	 ecx
  00af8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00afd	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00b00	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00b05	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00b0d	51		 push	 ecx
  00b0e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b13	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _grab_sz$[ebp]
  00b18	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00b20	f3 0f 10 8d 94
	fe ff ff	 movss	 xmm1, DWORD PTR _grab_pos$4[ebp]
  00b28	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b2c	51		 push	 ecx
  00b2d	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00b32	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00b35	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00b39	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00b41	51		 push	 ecx
  00b42	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b47	8d 8d 8c fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00b4d	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  00b52	8b 55 2c	 mov	 edx, DWORD PTR _out_grab_bb$[ebp]
  00b55	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b57	89 0a		 mov	 DWORD PTR [edx], ecx
  00b59	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b5c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b5f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b62	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b65	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b68	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN44@SliderBeha:

; 2472 :     }
; 2473 : 
; 2474 :     return value_changed;

  00b6b	8a 85 43 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]

; 2475 : }

  00b71	52		 push	 edx
  00b72	8b cd		 mov	 ecx, ebp
  00b74	50		 push	 eax
  00b75	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN70@SliderBeha
  00b7b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00b80	58		 pop	 eax
  00b81	5a		 pop	 edx
  00b82	5f		 pop	 edi
  00b83	5e		 pop	 esi
  00b84	5b		 pop	 ebx
  00b85	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b88	33 cd		 xor	 ecx, ebp
  00b8a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b8f	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  00b95	3b ec		 cmp	 ebp, esp
  00b97	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b9c	8b e5		 mov	 esp, ebp
  00b9e	5d		 pop	 ebp
  00b9f	c3		 ret	 0
$LN70@SliderBeha:
  00ba0	01 00 00 00	 DD	 1
  00ba4	00 00 00 00	 DD	 $LN69@SliderBeha
$LN69@SliderBeha:
  00ba8	0c ff ff ff	 DD	 -244			; ffffff0cH
  00bac	08 00 00 00	 DD	 8
  00bb0	00 00 00 00	 DD	 $LN68@SliderBeha
$LN68@SliderBeha:
  00bb4	64		 DB	 100			; 00000064H
  00bb5	65		 DB	 101			; 00000065H
  00bb6	6c		 DB	 108			; 0000006cH
  00bb7	74		 DB	 116			; 00000074H
  00bb8	61		 DB	 97			; 00000061H
  00bb9	32		 DB	 50			; 00000032H
  00bba	00		 DB	 0
??$SliderBehaviorT@HHM@ImGui@@YA_NABUImRect@@IHPAHHHPBDMHPAU1@@Z ENDP ; ImGui::SliderBehaviorT<int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@H@@YAHHH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMax@H@@YAHHH@Z PROC				; ImMax<int>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _rhs$[ebp]
  0002e	7c 0b		 jl	 SHORT $LN3@ImMax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00033	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00039	eb 09		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _rhs$[ebp]
  0003e	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
$LN4@ImMax:
  00044	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImMax@H@@YAHHH@Z ENDP				; ImMax<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@NNN@ImGui@@YA_NHPANMNNPBDMH@Z
_TEXT	SEGMENT
tv432 = -428						; size = 8
tv195 = -424						; size = 4
tv185 = -424						; size = 4
tv160 = -424						; size = 4
tv66 = -424						; size = 4
tv81 = -421						; size = 1
tv79 = -421						; size = 1
tv71 = -421						; size = 1
tv69 = -421						; size = 1
$T1 = -416						; size = 8
_v_cur_norm_curved$2 = -208				; size = 8
_v_new_norm_curved$3 = -192				; size = 8
_v_old_norm_curved$4 = -176				; size = 8
_v_old_ref_for_accum_remainder$ = -160			; size = 8
_v_cur$ = -144						; size = 8
_is_drag_direction_change_with_power$ = -125		; size = 1
_is_already_past_limits_and_pushing_outward$ = -113	; size = 1
_is_just_activated$ = -101				; size = 1
_decimal_precision$5 = -92				; size = 4
_adjust_delta$ = -80					; size = 4
_is_locked$ = -65					; size = 1
_is_power$ = -53					; size = 1
_is_clamped$ = -41					; size = 1
_is_decimal$ = -29					; size = 1
_axis$ = -20						; size = 4
_g$ = -8						; size = 4
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 8
_v_max$ = 28						; size = 8
_format$ = 36						; size = 4
_power$ = 40						; size = 4
_flags$ = 44						; size = 4
??$DragBehaviorT@NNN@ImGui@@YA_NHPANMNNPBDMH@Z PROC	; ImGui::DragBehaviorT<double,double,double>, COMDAT

; 1921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 54 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-428]
  00012	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1922 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1923 :     const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00030	8b 45 2c	 mov	 eax, DWORD PTR _flags$[ebp]
  00033	83 e0 01	 and	 eax, 1
  00036	74 0c		 je	 SHORT $LN27@DragBehavi
  00038	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00042	eb 0a		 jmp	 SHORT $LN28@DragBehavi
$LN27@DragBehavi:
  00044	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN28@DragBehavi:
  0004e	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00054	89 4d ec	 mov	 DWORD PTR _axis$[ebp], ecx

; 1924 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  00057	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0005b	74 0f		 je	 SHORT $LN29@DragBehavi
  0005d	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00061	74 09		 je	 SHORT $LN29@DragBehavi
  00063	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv69[ebp], 0
  0006a	eb 07		 jmp	 SHORT $LN30@DragBehavi
$LN29@DragBehavi:
  0006c	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv69[ebp], 1
$LN30@DragBehavi:
  00073	8a 85 5b fe ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00079	88 45 e3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 1925 :     const bool is_clamped = (v_min < v_max);

  0007c	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00081	66 0f 2f 45 14	 comisd	 xmm0, QWORD PTR _v_min$[ebp]
  00086	76 09		 jbe	 SHORT $LN31@DragBehavi
  00088	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv71[ebp], 1
  0008f	eb 07		 jmp	 SHORT $LN32@DragBehavi
$LN31@DragBehavi:
  00091	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv71[ebp], 0
$LN32@DragBehavi:
  00098	8a 85 5b fe ff
	ff		 mov	 al, BYTE PTR tv71[ebp]
  0009e	88 45 d7	 mov	 BYTE PTR _is_clamped$[ebp], al

; 1926 :     const bool is_power = (power != 1.0f && is_decimal && is_clamped && (v_max - v_min < FLT_MAX));

  000a1	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  000a6	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  000ad	9f		 lahf
  000ae	f6 c4 44	 test	 ah, 68			; 00000044H
  000b1	7b 31		 jnp	 SHORT $LN33@DragBehavi
  000b3	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000b7	85 c0		 test	 eax, eax
  000b9	74 29		 je	 SHORT $LN33@DragBehavi
  000bb	0f b6 4d d7	 movzx	 ecx, BYTE PTR _is_clamped$[ebp]
  000bf	85 c9		 test	 ecx, ecx
  000c1	74 21		 je	 SHORT $LN33@DragBehavi
  000c3	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  000c8	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  000cd	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@47efffffe0000000
  000d5	66 0f 2f c8	 comisd	 xmm1, xmm0
  000d9	76 09		 jbe	 SHORT $LN33@DragBehavi
  000db	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv79[ebp], 1
  000e2	eb 07		 jmp	 SHORT $LN34@DragBehavi
$LN33@DragBehavi:
  000e4	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv79[ebp], 0
$LN34@DragBehavi:
  000eb	8a 95 5b fe ff
	ff		 mov	 dl, BYTE PTR tv79[ebp]
  000f1	88 55 cb	 mov	 BYTE PTR _is_power$[ebp], dl

; 1927 :     const bool is_locked = (v_min > v_max);

  000f4	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  000f9	66 0f 2f 45 1c	 comisd	 xmm0, QWORD PTR _v_max$[ebp]
  000fe	76 09		 jbe	 SHORT $LN35@DragBehavi
  00100	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv81[ebp], 1
  00107	eb 07		 jmp	 SHORT $LN36@DragBehavi
$LN35@DragBehavi:
  00109	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv81[ebp], 0
$LN36@DragBehavi:
  00110	8a 85 5b fe ff
	ff		 mov	 al, BYTE PTR tv81[ebp]
  00116	88 45 bf	 mov	 BYTE PTR _is_locked$[ebp], al

; 1928 :     if (is_locked)

  00119	0f b6 45 bf	 movzx	 eax, BYTE PTR _is_locked$[ebp]
  0011d	85 c0		 test	 eax, eax
  0011f	74 07		 je	 SHORT $LN2@DragBehavi

; 1929 :         return false;

  00121	32 c0		 xor	 al, al
  00123	e9 f3 05 00 00	 jmp	 $LN1@DragBehavi
$LN2@DragBehavi:

; 1930 : 
; 1931 :     // Default tweak speed
; 1932 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

  00128	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  0012d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00134	9f		 lahf
  00135	f6 c4 44	 test	 ah, 68			; 00000044H
  00138	7a 42		 jp	 SHORT $LN3@DragBehavi
  0013a	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  0013e	85 c0		 test	 eax, eax
  00140	74 3a		 je	 SHORT $LN3@DragBehavi
  00142	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  00147	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  0014c	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@47efffffe0000000
  00154	66 0f 2f c8	 comisd	 xmm1, xmm0
  00158	76 22		 jbe	 SHORT $LN3@DragBehavi

; 1933 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

  0015a	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  0015f	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  00164	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00167	f3 0f 5a 88 00
	2d 00 00	 cvtss2sd xmm1, DWORD PTR [eax+11520]
  0016f	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00173	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00177	f3 0f 11 45 10	 movss	 DWORD PTR _v_speed$[ebp], xmm0
$LN3@DragBehavi:

; 1934 : 
; 1935 :     // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 1936 :     float adjust_delta = 0.0f;

  0017c	0f 57 c0	 xorps	 xmm0, xmm0
  0017f	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1937 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)

  00184	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00187	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  0018e	0f 85 8e 00 00
	00		 jne	 $LN4@DragBehavi
  00194	6a 00		 push	 0
  00196	e8 00 00 00 00	 call	 ?IsMousePosValid@ImGui@@YA_NPBUImVec2@@@Z ; ImGui::IsMousePosValid
  0019b	83 c4 04	 add	 esp, 4
  0019e	0f b6 c0	 movzx	 eax, al
  001a1	85 c0		 test	 eax, eax
  001a3	74 7d		 je	 SHORT $LN4@DragBehavi
  001a5	b8 04 00 00 00	 mov	 eax, 4
  001aa	6b c8 00	 imul	 ecx, eax, 0
  001ad	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  001b0	f3 0f 10 84 0a
	44 04 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1092]
  001b9	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001c0	76 60		 jbe	 SHORT $LN4@DragBehavi

; 1938 :     {
; 1939 :         adjust_delta = g.IO.MouseDelta[axis];

  001c2	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  001c5	50		 push	 eax
  001c6	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  001c9	81 c1 78 03 00
	00		 add	 ecx, 888		; 00000378H
  001cf	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  001d4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001d8	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1940 :         if (g.IO.KeyAlt)

  001dd	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001e0	0f b6 88 02 01
	00 00		 movzx	 ecx, BYTE PTR [eax+258]
  001e7	85 c9		 test	 ecx, ecx
  001e9	74 12		 je	 SHORT $LN6@DragBehavi

; 1941 :             adjust_delta *= 1.0f / 100.0f;

  001eb	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  001f0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  001f8	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN6@DragBehavi:

; 1942 :         if (g.IO.KeyShift)

  001fd	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00200	0f b6 88 01 01
	00 00		 movzx	 ecx, BYTE PTR [eax+257]
  00207	85 c9		 test	 ecx, ecx
  00209	74 12		 je	 SHORT $LN7@DragBehavi

; 1943 :             adjust_delta *= 10.0f;

  0020b	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00210	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00218	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN7@DragBehavi:

; 1944 :     }

  0021d	e9 a6 00 00 00	 jmp	 $LN8@DragBehavi
$LN4@DragBehavi:

; 1945 :     else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  00222	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00225	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  0022c	0f 85 96 00 00
	00		 jne	 $LN8@DragBehavi

; 1946 :     {
; 1947 :         int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00232	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00236	85 c0		 test	 eax, eax
  00238	74 16		 je	 SHORT $LN37@DragBehavi
  0023a	6a 03		 push	 3
  0023c	8b 4d 24	 mov	 ecx, DWORD PTR _format$[ebp]
  0023f	51		 push	 ecx
  00240	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00245	83 c4 08	 add	 esp, 8
  00248	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv160[ebp], eax
  0024e	eb 0a		 jmp	 SHORT $LN38@DragBehavi
$LN37@DragBehavi:
  00250	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
$LN38@DragBehavi:
  0025a	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv160[ebp]
  00260	89 55 a4	 mov	 DWORD PTR _decimal_precision$5[ebp], edx

; 1948 :         adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

  00263	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  00266	50		 push	 eax
  00267	51		 push	 ecx
  00268	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00270	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00275	51		 push	 ecx
  00276	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  0027e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00283	6a 05		 push	 5
  00285	6a 03		 push	 3
  00287	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0028d	51		 push	 ecx
  0028e	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  00293	83 c4 14	 add	 esp, 20			; 00000014H
  00296	8b c8		 mov	 ecx, eax
  00298	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  0029d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002a1	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1949 :         v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

  002a6	8b 45 a4	 mov	 eax, DWORD PTR _decimal_precision$5[ebp]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 ?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
  002af	d9 1c 24	 fstp	 DWORD PTR [esp]
  002b2	51		 push	 ecx
  002b3	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  002b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bd	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002c2	83 c4 08	 add	 esp, 8
  002c5	d9 5d 10	 fstp	 DWORD PTR _v_speed$[ebp]
$LN8@DragBehavi:

; 1950 :     }
; 1951 :     adjust_delta *= v_speed;

  002c8	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002cd	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _v_speed$[ebp]
  002d2	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1952 : 
; 1953 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 1954 :     if (axis == ImGuiAxis_Y)

  002d7	83 7d ec 01	 cmp	 DWORD PTR _axis$[ebp], 1
  002db	75 11		 jne	 SHORT $LN9@DragBehavi

; 1955 :         adjust_delta = -adjust_delta;

  002dd	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002e2	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002e9	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN9@DragBehavi:

; 1956 : 
; 1957 :     // Clear current value on activation
; 1958 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 1959 :     bool is_just_activated = g.ActiveIdIsJustActivated;

  002ee	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  002f1	8a 88 f0 19 00
	00		 mov	 cl, BYTE PTR [eax+6640]
  002f7	88 4d 9b	 mov	 BYTE PTR _is_just_activated$[ebp], cl

; 1960 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

  002fa	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  002fe	85 c0		 test	 eax, eax
  00300	74 3f		 je	 SHORT $LN42@DragBehavi
  00302	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  00305	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00309	66 0f 2f 45 1c	 comisd	 xmm0, QWORD PTR _v_max$[ebp]
  0030e	72 0e		 jb	 SHORT $LN39@DragBehavi
  00310	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00315	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0031c	77 17		 ja	 SHORT $LN41@DragBehavi
$LN39@DragBehavi:
  0031e	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00321	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  00326	66 0f 2f 02	 comisd	 xmm0, QWORD PTR [edx]
  0032a	72 15		 jb	 SHORT $LN42@DragBehavi
  0032c	0f 57 c0	 xorps	 xmm0, xmm0
  0032f	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00333	76 0c		 jbe	 SHORT $LN42@DragBehavi
$LN41@DragBehavi:
  00335	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv185[ebp], 1
  0033f	eb 0a		 jmp	 SHORT $LN43@DragBehavi
$LN42@DragBehavi:
  00341	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv185[ebp], 0
$LN43@DragBehavi:
  0034b	8a 85 58 fe ff
	ff		 mov	 al, BYTE PTR tv185[ebp]
  00351	88 45 8f	 mov	 BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp], al

; 1961 :     bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

  00354	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00358	85 c0		 test	 eax, eax
  0035a	74 46		 je	 SHORT $LN47@DragBehavi
  0035c	0f 57 c0	 xorps	 xmm0, xmm0
  0035f	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00363	76 14		 jbe	 SHORT $LN44@DragBehavi
  00365	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00368	f3 0f 10 81 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [ecx+11516]
  00370	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00377	77 1d		 ja	 SHORT $LN46@DragBehavi
$LN44@DragBehavi:
  00379	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0037e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00385	76 1b		 jbe	 SHORT $LN47@DragBehavi
  00387	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  0038a	0f 57 c0	 xorps	 xmm0, xmm0
  0038d	0f 2f 82 fc 2c
	00 00		 comiss	 xmm0, DWORD PTR [edx+11516]
  00394	76 0c		 jbe	 SHORT $LN47@DragBehavi
$LN46@DragBehavi:
  00396	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv195[ebp], 1
  003a0	eb 0a		 jmp	 SHORT $LN48@DragBehavi
$LN47@DragBehavi:
  003a2	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv195[ebp], 0
$LN48@DragBehavi:
  003ac	8a 85 58 fe ff
	ff		 mov	 al, BYTE PTR tv195[ebp]
  003b2	88 45 83	 mov	 BYTE PTR _is_drag_direction_change_with_power$[ebp], al

; 1962 :     if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

  003b5	0f b6 45 9b	 movzx	 eax, BYTE PTR _is_just_activated$[ebp]
  003b9	85 c0		 test	 eax, eax
  003bb	75 10		 jne	 SHORT $LN12@DragBehavi
  003bd	0f b6 45 8f	 movzx	 eax, BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp]
  003c1	85 c0		 test	 eax, eax
  003c3	75 08		 jne	 SHORT $LN12@DragBehavi
  003c5	0f b6 45 83	 movzx	 eax, BYTE PTR _is_drag_direction_change_with_power$[ebp]
  003c9	85 c0		 test	 eax, eax
  003cb	74 1a		 je	 SHORT $LN10@DragBehavi
$LN12@DragBehavi:

; 1963 :     {
; 1964 :         g.DragCurrentAccum = 0.0f;

  003cd	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003d0	0f 57 c0	 xorps	 xmm0, xmm0
  003d3	f3 0f 11 80 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm0

; 1965 :         g.DragCurrentAccumDirty = false;

  003db	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003de	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1966 :     }

  003e5	eb 37		 jmp	 SHORT $LN13@DragBehavi
$LN10@DragBehavi:

; 1967 :     else if (adjust_delta != 0.0f)

  003e7	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003ec	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  003f3	9f		 lahf
  003f4	f6 c4 44	 test	 ah, 68			; 00000044H
  003f7	7b 25		 jnp	 SHORT $LN13@DragBehavi

; 1968 :     {
; 1969 :         g.DragCurrentAccum += adjust_delta;

  003f9	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003fc	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  00404	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00409	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0040c	f3 0f 11 81 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm0

; 1970 :         g.DragCurrentAccumDirty = true;

  00414	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00417	c6 80 f8 2c 00
	00 01		 mov	 BYTE PTR [eax+11512], 1
$LN13@DragBehavi:

; 1971 :     }
; 1972 : 
; 1973 :     if (!g.DragCurrentAccumDirty)

  0041e	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00421	0f b6 88 f8 2c
	00 00		 movzx	 ecx, BYTE PTR [eax+11512]
  00428	85 c9		 test	 ecx, ecx
  0042a	75 07		 jne	 SHORT $LN14@DragBehavi

; 1974 :         return false;

  0042c	32 c0		 xor	 al, al
  0042e	e9 e8 02 00 00	 jmp	 $LN1@DragBehavi
$LN14@DragBehavi:

; 1975 : 
; 1976 :     TYPE v_cur = *v;

  00433	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00436	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  0043a	f2 0f 11 85 70
	ff ff ff	 movsd	 QWORD PTR _v_cur$[ebp], xmm0

; 1977 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

  00442	0f 57 c0	 xorps	 xmm0, xmm0
  00445	f2 0f 11 85 60
	ff ff ff	 movsd	 QWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1978 : 
; 1979 :     if (is_power)

  0044d	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00451	85 c0		 test	 eax, eax
  00453	0f 84 d7 00 00
	00		 je	 $LN15@DragBehavi

; 1980 :     {
; 1981 :         // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 1982 :         FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  00459	f3 0f 5a 45 28	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  0045e	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00466	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0046a	83 ec 08	 sub	 esp, 8
  0046d	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00472	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  0047a	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  0047f	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR _v_max$[ebp]
  00484	f2 0f 5c 4d 14	 subsd	 xmm1, QWORD PTR _v_min$[ebp]
  00489	f2 0f 5e c1	 divsd	 xmm0, xmm1
  0048d	83 ec 08	 sub	 esp, 8
  00490	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00495	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  0049a	83 c4 10	 add	 esp, 16			; 00000010H
  0049d	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _v_old_norm_curved$4[ebp]

; 1983 :         FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

  004a3	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  004a6	f3 0f 5a 80 fc
	2c 00 00	 cvtss2sd xmm0, DWORD PTR [eax+11516]
  004ae	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR _v_max$[ebp]
  004b3	f2 0f 5c 4d 14	 subsd	 xmm1, QWORD PTR _v_min$[ebp]
  004b8	f2 0f 5e c1	 divsd	 xmm0, xmm1
  004bc	f2 0f 58 85 50
	ff ff ff	 addsd	 xmm0, QWORD PTR _v_old_norm_curved$4[ebp]
  004c4	f2 0f 11 85 40
	ff ff ff	 movsd	 QWORD PTR _v_new_norm_curved$3[ebp], xmm0

; 1984 :         v_cur = v_min + (SIGNEDTYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

  004cc	51		 push	 ecx
  004cd	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  004d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d7	f2 0f 5a 85 40
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR _v_new_norm_curved$3[ebp]
  004df	51		 push	 ecx
  004e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e5	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  004ea	d9 1c 24	 fstp	 DWORD PTR [esp]
  004ed	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  004f2	83 c4 08	 add	 esp, 8
  004f5	dd 9d 54 fe ff
	ff		 fstp	 QWORD PTR tv432[ebp]
  004fb	f2 0f 10 85 54
	fe ff ff	 movsd	 xmm0, QWORD PTR tv432[ebp]
  00503	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR _v_max$[ebp]
  00508	f2 0f 5c 4d 14	 subsd	 xmm1, QWORD PTR _v_min$[ebp]
  0050d	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00511	f2 0f 58 45 14	 addsd	 xmm0, QWORD PTR _v_min$[ebp]
  00516	f2 0f 11 85 70
	ff ff ff	 movsd	 QWORD PTR _v_cur$[ebp], xmm0

; 1985 :         v_old_ref_for_accum_remainder = v_old_norm_curved;

  0051e	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_old_norm_curved$4[ebp]
  00526	f2 0f 11 85 60
	ff ff ff	 movsd	 QWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1986 :     }

  0052e	eb 1b		 jmp	 SHORT $LN16@DragBehavi
$LN15@DragBehavi:

; 1987 :     else
; 1988 :     {
; 1989 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

  00530	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00533	f3 0f 5a 80 fc
	2c 00 00	 cvtss2sd xmm0, DWORD PTR [eax+11516]
  0053b	f2 0f 58 85 70
	ff ff ff	 addsd	 xmm0, QWORD PTR _v_cur$[ebp]
  00543	f2 0f 11 85 70
	ff ff ff	 movsd	 QWORD PTR _v_cur$[ebp], xmm0
$LN16@DragBehavi:

; 1990 :     }
; 1991 : 
; 1992 :     // Round to user desired precision based on format string
; 1993 :     v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

  0054b	83 ec 08	 sub	 esp, 8
  0054e	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  00556	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0055b	8b 45 08	 mov	 eax, DWORD PTR _data_type$[ebp]
  0055e	50		 push	 eax
  0055f	8b 4d 24	 mov	 ecx, DWORD PTR _format$[ebp]
  00562	51		 push	 ecx
  00563	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@NN@ImGui@@YANPBDHN@Z ; ImGui::RoundScalarWithFormatT<double,double>
  00568	83 c4 10	 add	 esp, 16			; 00000010H
  0056b	dd 9d 70 ff ff
	ff		 fstp	 QWORD PTR _v_cur$[ebp]

; 1994 : 
; 1995 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 1996 :     g.DragCurrentAccumDirty = false;

  00571	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00574	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1997 :     if (is_power)

  0057b	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0057f	85 c0		 test	 eax, eax
  00581	74 7a		 je	 SHORT $LN17@DragBehavi

; 1998 :     {
; 1999 :         FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  00583	f3 0f 5a 45 28	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  00588	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00590	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00594	83 ec 08	 sub	 esp, 8
  00597	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0059c	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  005a4	f2 0f 5c 45 14	 subsd	 xmm0, QWORD PTR _v_min$[ebp]
  005a9	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR _v_max$[ebp]
  005ae	f2 0f 5c 4d 14	 subsd	 xmm1, QWORD PTR _v_min$[ebp]
  005b3	f2 0f 5e c1	 divsd	 xmm0, xmm1
  005b7	83 ec 08	 sub	 esp, 8
  005ba	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005bf	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  005c4	83 c4 10	 add	 esp, 16			; 00000010H
  005c7	dd 9d 30 ff ff
	ff		 fstp	 QWORD PTR _v_cur_norm_curved$2[ebp]

; 2000 :         g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

  005cd	f2 0f 10 85 30
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur_norm_curved$2[ebp]
  005d5	f2 0f 5c 85 60
	ff ff ff	 subsd	 xmm0, QWORD PTR _v_old_ref_for_accum_remainder$[ebp]
  005dd	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  005e1	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005e4	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  005ec	f3 0f 5c c8	 subss	 xmm1, xmm0
  005f0	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  005f3	f3 0f 11 89 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm1

; 2001 :     }

  005fb	eb 2d		 jmp	 SHORT $LN18@DragBehavi
$LN17@DragBehavi:

; 2002 :     else
; 2003 :     {
; 2004 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

  005fd	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00600	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  00608	f2 0f 5c 00	 subsd	 xmm0, QWORD PTR [eax]
  0060c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00610	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00613	f3 0f 10 89 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [ecx+11516]
  0061b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0061f	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00622	f3 0f 11 8a fc
	2c 00 00	 movss	 DWORD PTR [edx+11516], xmm1
$LN18@DragBehavi:

; 2005 :     }
; 2006 : 
; 2007 :     // Lose zero sign for float/double
; 2008 :     if (v_cur == (TYPE)-0)

  0062a	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  00632	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0063a	9f		 lahf
  0063b	f6 c4 44	 test	 ah, 68			; 00000044H
  0063e	7a 0b		 jp	 SHORT $LN19@DragBehavi

; 2009 :         v_cur = (TYPE)0;

  00640	0f 57 c0	 xorps	 xmm0, xmm0
  00643	f2 0f 11 85 70
	ff ff ff	 movsd	 QWORD PTR _v_cur$[ebp], xmm0
$LN19@DragBehavi:

; 2010 : 
; 2011 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2012 :     if (*v != v_cur && is_clamped)

  0064b	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0064e	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00652	66 0f 2e 85 70
	ff ff ff	 ucomisd xmm0, QWORD PTR _v_cur$[ebp]
  0065a	9f		 lahf
  0065b	f6 c4 44	 test	 ah, 68			; 00000044H
  0065e	0f 8b 8d 00 00
	00		 jnp	 $LN23@DragBehavi
  00664	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00668	85 c0		 test	 eax, eax
  0066a	0f 84 81 00 00
	00		 je	 $LN23@DragBehavi

; 2013 :     {
; 2014 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

  00670	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  00675	66 0f 2f 85 70
	ff ff ff	 comisd	 xmm0, QWORD PTR _v_cur$[ebp]
  0067d	77 22		 ja	 SHORT $LN22@DragBehavi
  0067f	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00682	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  0068a	66 0f 2f 00	 comisd	 xmm0, QWORD PTR [eax]
  0068e	76 1e		 jbe	 SHORT $LN21@DragBehavi
  00690	0f 57 c0	 xorps	 xmm0, xmm0
  00693	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00697	76 15		 jbe	 SHORT $LN21@DragBehavi
  00699	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0069d	85 c0		 test	 eax, eax
  0069f	75 0d		 jne	 SHORT $LN21@DragBehavi
$LN22@DragBehavi:

; 2015 :             v_cur = v_min;

  006a1	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _v_min$[ebp]
  006a6	f2 0f 11 85 70
	ff ff ff	 movsd	 QWORD PTR _v_cur$[ebp], xmm0
$LN21@DragBehavi:

; 2016 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

  006ae	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  006b6	66 0f 2f 45 1c	 comisd	 xmm0, QWORD PTR _v_max$[ebp]
  006bb	77 27		 ja	 SHORT $LN24@DragBehavi
  006bd	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  006c0	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  006c4	66 0f 2f 85 70
	ff ff ff	 comisd	 xmm0, QWORD PTR _v_cur$[ebp]
  006cc	76 23		 jbe	 SHORT $LN23@DragBehavi
  006ce	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  006d3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  006da	76 15		 jbe	 SHORT $LN23@DragBehavi
  006dc	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  006e0	85 c0		 test	 eax, eax
  006e2	75 0d		 jne	 SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2017 :             v_cur = v_max;

  006e4	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR _v_max$[ebp]
  006e9	f2 0f 11 85 70
	ff ff ff	 movsd	 QWORD PTR _v_cur$[ebp], xmm0
$LN23@DragBehavi:

; 2018 :     }
; 2019 : 
; 2020 :     // Apply result
; 2021 :     if (*v == v_cur)

  006f1	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  006f4	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  006f8	66 0f 2e 85 70
	ff ff ff	 ucomisd xmm0, QWORD PTR _v_cur$[ebp]
  00700	9f		 lahf
  00701	f6 c4 44	 test	 ah, 68			; 00000044H
  00704	7a 04		 jp	 SHORT $LN25@DragBehavi

; 2022 :         return false;

  00706	32 c0		 xor	 al, al
  00708	eb 11		 jmp	 SHORT $LN1@DragBehavi
$LN25@DragBehavi:

; 2023 :     *v = v_cur;

  0070a	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0070d	f2 0f 10 85 70
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur$[ebp]
  00715	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 2024 :     return true;

  00719	b0 01		 mov	 al, 1
$LN1@DragBehavi:

; 2025 : }

  0071b	5f		 pop	 edi
  0071c	5e		 pop	 esi
  0071d	5b		 pop	 ebx
  0071e	81 c4 ac 01 00
	00		 add	 esp, 428		; 000001acH
  00724	3b ec		 cmp	 ebp, esp
  00726	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0072b	8b e5		 mov	 esp, ebp
  0072d	5d		 pop	 ebp
  0072e	c3		 ret	 0
??$DragBehaviorT@NNN@ImGui@@YA_NHPANMNNPBDMH@Z ENDP	; ImGui::DragBehaviorT<double,double,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@MMM@ImGui@@YA_NHPAMMMMPBDMH@Z
_TEXT	SEGMENT
tv423 = -404						; size = 4
tv193 = -404						; size = 4
tv183 = -404						; size = 4
tv158 = -404						; size = 4
tv66 = -404						; size = 4
tv81 = -401						; size = 1
tv79 = -401						; size = 1
tv71 = -401						; size = 1
tv69 = -401						; size = 1
$T1 = -396						; size = 8
_v_cur_norm_curved$2 = -188				; size = 4
_v_new_norm_curved$3 = -176				; size = 4
_v_old_norm_curved$4 = -164				; size = 4
_v_old_ref_for_accum_remainder$ = -152			; size = 4
_v_cur$ = -140						; size = 4
_is_drag_direction_change_with_power$ = -125		; size = 1
_is_already_past_limits_and_pushing_outward$ = -113	; size = 1
_is_just_activated$ = -101				; size = 1
_decimal_precision$5 = -92				; size = 4
_adjust_delta$ = -80					; size = 4
_is_locked$ = -65					; size = 1
_is_power$ = -53					; size = 1
_is_clamped$ = -41					; size = 1
_is_decimal$ = -29					; size = 1
_axis$ = -20						; size = 4
_g$ = -8						; size = 4
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
_flags$ = 36						; size = 4
??$DragBehaviorT@MMM@ImGui@@YA_NHPAMMMMPBDMH@Z PROC	; ImGui::DragBehaviorT<float,float,float>, COMDAT

; 1921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00012	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1922 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1923 :     const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00030	8b 45 24	 mov	 eax, DWORD PTR _flags$[ebp]
  00033	83 e0 01	 and	 eax, 1
  00036	74 0c		 je	 SHORT $LN27@DragBehavi
  00038	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00042	eb 0a		 jmp	 SHORT $LN28@DragBehavi
$LN27@DragBehavi:
  00044	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN28@DragBehavi:
  0004e	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00054	89 4d ec	 mov	 DWORD PTR _axis$[ebp], ecx

; 1924 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  00057	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0005b	74 0f		 je	 SHORT $LN29@DragBehavi
  0005d	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00061	74 09		 je	 SHORT $LN29@DragBehavi
  00063	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv69[ebp], 0
  0006a	eb 07		 jmp	 SHORT $LN30@DragBehavi
$LN29@DragBehavi:
  0006c	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv69[ebp], 1
$LN30@DragBehavi:
  00073	8a 85 6f fe ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00079	88 45 e3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 1925 :     const bool is_clamped = (v_min < v_max);

  0007c	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00081	0f 2f 45 14	 comiss	 xmm0, DWORD PTR _v_min$[ebp]
  00085	76 09		 jbe	 SHORT $LN31@DragBehavi
  00087	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv71[ebp], 1
  0008e	eb 07		 jmp	 SHORT $LN32@DragBehavi
$LN31@DragBehavi:
  00090	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv71[ebp], 0
$LN32@DragBehavi:
  00097	8a 85 6f fe ff
	ff		 mov	 al, BYTE PTR tv71[ebp]
  0009d	88 45 d7	 mov	 BYTE PTR _is_clamped$[ebp], al

; 1926 :     const bool is_power = (power != 1.0f && is_decimal && is_clamped && (v_max - v_min < FLT_MAX));

  000a0	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  000a5	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  000ac	9f		 lahf
  000ad	f6 c4 44	 test	 ah, 68			; 00000044H
  000b0	7b 30		 jnp	 SHORT $LN33@DragBehavi
  000b2	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000b6	85 c0		 test	 eax, eax
  000b8	74 28		 je	 SHORT $LN33@DragBehavi
  000ba	0f b6 4d d7	 movzx	 ecx, BYTE PTR _is_clamped$[ebp]
  000be	85 c9		 test	 ecx, ecx
  000c0	74 20		 je	 SHORT $LN33@DragBehavi
  000c2	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  000c7	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  000cc	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  000d4	0f 2f c8	 comiss	 xmm1, xmm0
  000d7	76 09		 jbe	 SHORT $LN33@DragBehavi
  000d9	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv79[ebp], 1
  000e0	eb 07		 jmp	 SHORT $LN34@DragBehavi
$LN33@DragBehavi:
  000e2	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv79[ebp], 0
$LN34@DragBehavi:
  000e9	8a 95 6f fe ff
	ff		 mov	 dl, BYTE PTR tv79[ebp]
  000ef	88 55 cb	 mov	 BYTE PTR _is_power$[ebp], dl

; 1927 :     const bool is_locked = (v_min > v_max);

  000f2	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  000f7	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _v_max$[ebp]
  000fb	76 09		 jbe	 SHORT $LN35@DragBehavi
  000fd	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv81[ebp], 1
  00104	eb 07		 jmp	 SHORT $LN36@DragBehavi
$LN35@DragBehavi:
  00106	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv81[ebp], 0
$LN36@DragBehavi:
  0010d	8a 85 6f fe ff
	ff		 mov	 al, BYTE PTR tv81[ebp]
  00113	88 45 bf	 mov	 BYTE PTR _is_locked$[ebp], al

; 1928 :     if (is_locked)

  00116	0f b6 45 bf	 movzx	 eax, BYTE PTR _is_locked$[ebp]
  0011a	85 c0		 test	 eax, eax
  0011c	74 07		 je	 SHORT $LN2@DragBehavi

; 1929 :         return false;

  0011e	32 c0		 xor	 al, al
  00120	e9 c3 05 00 00	 jmp	 $LN1@DragBehavi
$LN2@DragBehavi:

; 1930 : 
; 1931 :     // Default tweak speed
; 1932 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

  00125	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  0012a	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00131	9f		 lahf
  00132	f6 c4 44	 test	 ah, 68			; 00000044H
  00135	7a 39		 jp	 SHORT $LN3@DragBehavi
  00137	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  0013b	85 c0		 test	 eax, eax
  0013d	74 31		 je	 SHORT $LN3@DragBehavi
  0013f	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00144	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  00149	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  00151	0f 2f c8	 comiss	 xmm1, xmm0
  00154	76 1a		 jbe	 SHORT $LN3@DragBehavi

; 1933 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

  00156	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  0015b	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  00160	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00163	f3 0f 59 80 00
	2d 00 00	 mulss	 xmm0, DWORD PTR [eax+11520]
  0016b	f3 0f 11 45 10	 movss	 DWORD PTR _v_speed$[ebp], xmm0
$LN3@DragBehavi:

; 1934 : 
; 1935 :     // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 1936 :     float adjust_delta = 0.0f;

  00170	0f 57 c0	 xorps	 xmm0, xmm0
  00173	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1937 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)

  00178	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0017b	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  00182	0f 85 8e 00 00
	00		 jne	 $LN4@DragBehavi
  00188	6a 00		 push	 0
  0018a	e8 00 00 00 00	 call	 ?IsMousePosValid@ImGui@@YA_NPBUImVec2@@@Z ; ImGui::IsMousePosValid
  0018f	83 c4 04	 add	 esp, 4
  00192	0f b6 c0	 movzx	 eax, al
  00195	85 c0		 test	 eax, eax
  00197	74 7d		 je	 SHORT $LN4@DragBehavi
  00199	b8 04 00 00 00	 mov	 eax, 4
  0019e	6b c8 00	 imul	 ecx, eax, 0
  001a1	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  001a4	f3 0f 10 84 0a
	44 04 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1092]
  001ad	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001b4	76 60		 jbe	 SHORT $LN4@DragBehavi

; 1938 :     {
; 1939 :         adjust_delta = g.IO.MouseDelta[axis];

  001b6	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  001b9	50		 push	 eax
  001ba	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  001bd	81 c1 78 03 00
	00		 add	 ecx, 888		; 00000378H
  001c3	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  001c8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001cc	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1940 :         if (g.IO.KeyAlt)

  001d1	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001d4	0f b6 88 02 01
	00 00		 movzx	 ecx, BYTE PTR [eax+258]
  001db	85 c9		 test	 ecx, ecx
  001dd	74 12		 je	 SHORT $LN6@DragBehavi

; 1941 :             adjust_delta *= 1.0f / 100.0f;

  001df	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  001e4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  001ec	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN6@DragBehavi:

; 1942 :         if (g.IO.KeyShift)

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001f4	0f b6 88 01 01
	00 00		 movzx	 ecx, BYTE PTR [eax+257]
  001fb	85 c9		 test	 ecx, ecx
  001fd	74 12		 je	 SHORT $LN7@DragBehavi

; 1943 :             adjust_delta *= 10.0f;

  001ff	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00204	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  0020c	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN7@DragBehavi:

; 1944 :     }

  00211	e9 a6 00 00 00	 jmp	 $LN8@DragBehavi
$LN4@DragBehavi:

; 1945 :     else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  00216	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00219	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  00220	0f 85 96 00 00
	00		 jne	 $LN8@DragBehavi

; 1946 :     {
; 1947 :         int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00226	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0022a	85 c0		 test	 eax, eax
  0022c	74 16		 je	 SHORT $LN37@DragBehavi
  0022e	6a 03		 push	 3
  00230	8b 4d 1c	 mov	 ecx, DWORD PTR _format$[ebp]
  00233	51		 push	 ecx
  00234	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00239	83 c4 08	 add	 esp, 8
  0023c	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv158[ebp], eax
  00242	eb 0a		 jmp	 SHORT $LN38@DragBehavi
$LN37@DragBehavi:
  00244	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv158[ebp], 0
$LN38@DragBehavi:
  0024e	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR tv158[ebp]
  00254	89 55 a4	 mov	 DWORD PTR _decimal_precision$5[ebp], edx

; 1948 :         adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

  00257	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  0025a	50		 push	 eax
  0025b	51		 push	 ecx
  0025c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00264	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00269	51		 push	 ecx
  0026a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00272	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00277	6a 05		 push	 5
  00279	6a 03		 push	 3
  0027b	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00281	51		 push	 ecx
  00282	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  00287	83 c4 14	 add	 esp, 20			; 00000014H
  0028a	8b c8		 mov	 ecx, eax
  0028c	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  00291	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00295	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1949 :         v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

  0029a	8b 45 a4	 mov	 eax, DWORD PTR _decimal_precision$5[ebp]
  0029d	50		 push	 eax
  0029e	e8 00 00 00 00	 call	 ?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
  002a3	d9 1c 24	 fstp	 DWORD PTR [esp]
  002a6	51		 push	 ecx
  002a7	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  002ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b1	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002b6	83 c4 08	 add	 esp, 8
  002b9	d9 5d 10	 fstp	 DWORD PTR _v_speed$[ebp]
$LN8@DragBehavi:

; 1950 :     }
; 1951 :     adjust_delta *= v_speed;

  002bc	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002c1	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _v_speed$[ebp]
  002c6	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1952 : 
; 1953 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 1954 :     if (axis == ImGuiAxis_Y)

  002cb	83 7d ec 01	 cmp	 DWORD PTR _axis$[ebp], 1
  002cf	75 11		 jne	 SHORT $LN9@DragBehavi

; 1955 :         adjust_delta = -adjust_delta;

  002d1	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002d6	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002dd	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN9@DragBehavi:

; 1956 : 
; 1957 :     // Clear current value on activation
; 1958 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 1959 :     bool is_just_activated = g.ActiveIdIsJustActivated;

  002e2	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  002e5	8a 88 f0 19 00
	00		 mov	 cl, BYTE PTR [eax+6640]
  002eb	88 4d 9b	 mov	 BYTE PTR _is_just_activated$[ebp], cl

; 1960 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

  002ee	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  002f2	85 c0		 test	 eax, eax
  002f4	74 3d		 je	 SHORT $LN42@DragBehavi
  002f6	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  002f9	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  002fd	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _v_max$[ebp]
  00301	72 0e		 jb	 SHORT $LN39@DragBehavi
  00303	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00308	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0030f	77 16		 ja	 SHORT $LN41@DragBehavi
$LN39@DragBehavi:
  00311	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00314	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00319	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  0031c	72 15		 jb	 SHORT $LN42@DragBehavi
  0031e	0f 57 c0	 xorps	 xmm0, xmm0
  00321	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00325	76 0c		 jbe	 SHORT $LN42@DragBehavi
$LN41@DragBehavi:
  00327	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv183[ebp], 1
  00331	eb 0a		 jmp	 SHORT $LN43@DragBehavi
$LN42@DragBehavi:
  00333	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv183[ebp], 0
$LN43@DragBehavi:
  0033d	8a 85 6c fe ff
	ff		 mov	 al, BYTE PTR tv183[ebp]
  00343	88 45 8f	 mov	 BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp], al

; 1961 :     bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

  00346	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0034a	85 c0		 test	 eax, eax
  0034c	74 46		 je	 SHORT $LN47@DragBehavi
  0034e	0f 57 c0	 xorps	 xmm0, xmm0
  00351	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00355	76 14		 jbe	 SHORT $LN44@DragBehavi
  00357	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0035a	f3 0f 10 81 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [ecx+11516]
  00362	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00369	77 1d		 ja	 SHORT $LN46@DragBehavi
$LN44@DragBehavi:
  0036b	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00370	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00377	76 1b		 jbe	 SHORT $LN47@DragBehavi
  00379	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  0037c	0f 57 c0	 xorps	 xmm0, xmm0
  0037f	0f 2f 82 fc 2c
	00 00		 comiss	 xmm0, DWORD PTR [edx+11516]
  00386	76 0c		 jbe	 SHORT $LN47@DragBehavi
$LN46@DragBehavi:
  00388	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv193[ebp], 1
  00392	eb 0a		 jmp	 SHORT $LN48@DragBehavi
$LN47@DragBehavi:
  00394	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv193[ebp], 0
$LN48@DragBehavi:
  0039e	8a 85 6c fe ff
	ff		 mov	 al, BYTE PTR tv193[ebp]
  003a4	88 45 83	 mov	 BYTE PTR _is_drag_direction_change_with_power$[ebp], al

; 1962 :     if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

  003a7	0f b6 45 9b	 movzx	 eax, BYTE PTR _is_just_activated$[ebp]
  003ab	85 c0		 test	 eax, eax
  003ad	75 10		 jne	 SHORT $LN12@DragBehavi
  003af	0f b6 45 8f	 movzx	 eax, BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp]
  003b3	85 c0		 test	 eax, eax
  003b5	75 08		 jne	 SHORT $LN12@DragBehavi
  003b7	0f b6 45 83	 movzx	 eax, BYTE PTR _is_drag_direction_change_with_power$[ebp]
  003bb	85 c0		 test	 eax, eax
  003bd	74 1a		 je	 SHORT $LN10@DragBehavi
$LN12@DragBehavi:

; 1963 :     {
; 1964 :         g.DragCurrentAccum = 0.0f;

  003bf	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003c2	0f 57 c0	 xorps	 xmm0, xmm0
  003c5	f3 0f 11 80 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm0

; 1965 :         g.DragCurrentAccumDirty = false;

  003cd	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003d0	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1966 :     }

  003d7	eb 37		 jmp	 SHORT $LN13@DragBehavi
$LN10@DragBehavi:

; 1967 :     else if (adjust_delta != 0.0f)

  003d9	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003de	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  003e5	9f		 lahf
  003e6	f6 c4 44	 test	 ah, 68			; 00000044H
  003e9	7b 25		 jnp	 SHORT $LN13@DragBehavi

; 1968 :     {
; 1969 :         g.DragCurrentAccum += adjust_delta;

  003eb	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003ee	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  003f6	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003fb	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  003fe	f3 0f 11 81 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm0

; 1970 :         g.DragCurrentAccumDirty = true;

  00406	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00409	c6 80 f8 2c 00
	00 01		 mov	 BYTE PTR [eax+11512], 1
$LN13@DragBehavi:

; 1971 :     }
; 1972 : 
; 1973 :     if (!g.DragCurrentAccumDirty)

  00410	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00413	0f b6 88 f8 2c
	00 00		 movzx	 ecx, BYTE PTR [eax+11512]
  0041a	85 c9		 test	 ecx, ecx
  0041c	75 07		 jne	 SHORT $LN14@DragBehavi

; 1974 :         return false;

  0041e	32 c0		 xor	 al, al
  00420	e9 c3 02 00 00	 jmp	 $LN1@DragBehavi
$LN14@DragBehavi:

; 1975 : 
; 1976 :     TYPE v_cur = *v;

  00425	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00428	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0042c	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _v_cur$[ebp], xmm0

; 1977 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

  00434	0f 57 c0	 xorps	 xmm0, xmm0
  00437	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1978 : 
; 1979 :     if (is_power)

  0043f	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00443	85 c0		 test	 eax, eax
  00445	0f 84 cf 00 00
	00		 je	 $LN15@DragBehavi

; 1980 :     {
; 1981 :         // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 1982 :         FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  0044b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00453	f3 0f 5e 45 20	 divss	 xmm0, DWORD PTR _power$[ebp]
  00458	51		 push	 ecx
  00459	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0045e	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  00466	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  0046b	f3 0f 10 4d 18	 movss	 xmm1, DWORD PTR _v_max$[ebp]
  00470	f3 0f 5c 4d 14	 subss	 xmm1, DWORD PTR _v_min$[ebp]
  00475	f3 0f 5e c1	 divss	 xmm0, xmm1
  00479	51		 push	 ecx
  0047a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0047f	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00484	83 c4 08	 add	 esp, 8
  00487	d9 9d 5c ff ff
	ff		 fstp	 DWORD PTR _v_old_norm_curved$4[ebp]

; 1983 :         FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

  0048d	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00492	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  00497	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0049a	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  004a2	f3 0f 5e c8	 divss	 xmm1, xmm0
  004a6	f3 0f 58 8d 5c
	ff ff ff	 addss	 xmm1, DWORD PTR _v_old_norm_curved$4[ebp]
  004ae	f3 0f 11 8d 50
	ff ff ff	 movss	 DWORD PTR _v_new_norm_curved$3[ebp], xmm1

; 1984 :         v_cur = v_min + (SIGNEDTYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

  004b6	51		 push	 ecx
  004b7	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  004bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c1	51		 push	 ecx
  004c2	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _v_new_norm_curved$3[ebp]
  004ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004cf	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  004d4	d9 1c 24	 fstp	 DWORD PTR [esp]
  004d7	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  004dc	83 c4 08	 add	 esp, 8
  004df	d9 9d 6c fe ff
	ff		 fstp	 DWORD PTR tv423[ebp]
  004e5	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR tv423[ebp]
  004ed	f3 0f 10 4d 18	 movss	 xmm1, DWORD PTR _v_max$[ebp]
  004f2	f3 0f 5c 4d 14	 subss	 xmm1, DWORD PTR _v_min$[ebp]
  004f7	f3 0f 59 c1	 mulss	 xmm0, xmm1
  004fb	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _v_min$[ebp]
  00500	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _v_cur$[ebp], xmm0

; 1985 :         v_old_ref_for_accum_remainder = v_old_norm_curved;

  00508	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _v_old_norm_curved$4[ebp]
  00510	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1986 :     }

  00518	eb 1b		 jmp	 SHORT $LN16@DragBehavi
$LN15@DragBehavi:

; 1987 :     else
; 1988 :     {
; 1989 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

  0051a	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0051d	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  00525	f3 0f 58 80 fc
	2c 00 00	 addss	 xmm0, DWORD PTR [eax+11516]
  0052d	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _v_cur$[ebp], xmm0
$LN16@DragBehavi:

; 1990 :     }
; 1991 : 
; 1992 :     // Round to user desired precision based on format string
; 1993 :     v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

  00535	51		 push	 ecx
  00536	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  0053e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00543	8b 45 08	 mov	 eax, DWORD PTR _data_type$[ebp]
  00546	50		 push	 eax
  00547	8b 4d 1c	 mov	 ecx, DWORD PTR _format$[ebp]
  0054a	51		 push	 ecx
  0054b	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@MM@ImGui@@YAMPBDHM@Z ; ImGui::RoundScalarWithFormatT<float,float>
  00550	83 c4 0c	 add	 esp, 12			; 0000000cH
  00553	d9 9d 74 ff ff
	ff		 fstp	 DWORD PTR _v_cur$[ebp]

; 1994 : 
; 1995 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 1996 :     g.DragCurrentAccumDirty = false;

  00559	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0055c	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1997 :     if (is_power)

  00563	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00567	85 c0		 test	 eax, eax
  00569	74 6e		 je	 SHORT $LN17@DragBehavi

; 1998 :     {
; 1999 :         FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  0056b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00573	f3 0f 5e 45 20	 divss	 xmm0, DWORD PTR _power$[ebp]
  00578	51		 push	 ecx
  00579	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0057e	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  00586	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _v_min$[ebp]
  0058b	f3 0f 10 4d 18	 movss	 xmm1, DWORD PTR _v_max$[ebp]
  00590	f3 0f 5c 4d 14	 subss	 xmm1, DWORD PTR _v_min$[ebp]
  00595	f3 0f 5e c1	 divss	 xmm0, xmm1
  00599	51		 push	 ecx
  0059a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0059f	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  005a4	83 c4 08	 add	 esp, 8
  005a7	d9 9d 44 ff ff
	ff		 fstp	 DWORD PTR _v_cur_norm_curved$2[ebp]

; 2000 :         g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

  005ad	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur_norm_curved$2[ebp]
  005b5	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _v_old_ref_for_accum_remainder$[ebp]
  005bd	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005c0	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  005c8	f3 0f 5c c8	 subss	 xmm1, xmm0
  005cc	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  005cf	f3 0f 11 89 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm1

; 2001 :     }

  005d7	eb 29		 jmp	 SHORT $LN18@DragBehavi
$LN17@DragBehavi:

; 2002 :     else
; 2003 :     {
; 2004 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

  005d9	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  005dc	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  005e4	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  005e8	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  005eb	f3 0f 10 89 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [ecx+11516]
  005f3	f3 0f 5c c8	 subss	 xmm1, xmm0
  005f7	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  005fa	f3 0f 11 8a fc
	2c 00 00	 movss	 DWORD PTR [edx+11516], xmm1
$LN18@DragBehavi:

; 2005 :     }
; 2006 : 
; 2007 :     // Lose zero sign for float/double
; 2008 :     if (v_cur == (TYPE)-0)

  00602	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  0060a	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00611	9f		 lahf
  00612	f6 c4 44	 test	 ah, 68			; 00000044H
  00615	7a 0b		 jp	 SHORT $LN19@DragBehavi

; 2009 :         v_cur = (TYPE)0;

  00617	0f 57 c0	 xorps	 xmm0, xmm0
  0061a	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _v_cur$[ebp], xmm0
$LN19@DragBehavi:

; 2010 : 
; 2011 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2012 :     if (*v != v_cur && is_clamped)

  00622	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00625	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00629	0f 2e 85 74 ff
	ff ff		 ucomiss xmm0, DWORD PTR _v_cur$[ebp]
  00630	9f		 lahf
  00631	f6 c4 44	 test	 ah, 68			; 00000044H
  00634	0f 8b 85 00 00
	00		 jnp	 $LN23@DragBehavi
  0063a	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  0063e	85 c0		 test	 eax, eax
  00640	74 7d		 je	 SHORT $LN23@DragBehavi

; 2013 :     {
; 2014 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

  00642	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00647	0f 2f 85 74 ff
	ff ff		 comiss	 xmm0, DWORD PTR _v_cur$[ebp]
  0064e	77 21		 ja	 SHORT $LN22@DragBehavi
  00650	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00653	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  0065b	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0065e	76 1e		 jbe	 SHORT $LN21@DragBehavi
  00660	0f 57 c0	 xorps	 xmm0, xmm0
  00663	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00667	76 15		 jbe	 SHORT $LN21@DragBehavi
  00669	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0066d	85 c0		 test	 eax, eax
  0066f	75 0d		 jne	 SHORT $LN21@DragBehavi
$LN22@DragBehavi:

; 2015 :             v_cur = v_min;

  00671	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00676	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _v_cur$[ebp], xmm0
$LN21@DragBehavi:

; 2016 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

  0067e	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  00686	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _v_max$[ebp]
  0068a	77 26		 ja	 SHORT $LN24@DragBehavi
  0068c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0068f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00693	0f 2f 85 74 ff
	ff ff		 comiss	 xmm0, DWORD PTR _v_cur$[ebp]
  0069a	76 23		 jbe	 SHORT $LN23@DragBehavi
  0069c	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  006a1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  006a8	76 15		 jbe	 SHORT $LN23@DragBehavi
  006aa	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  006ae	85 c0		 test	 eax, eax
  006b0	75 0d		 jne	 SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2017 :             v_cur = v_max;

  006b2	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  006b7	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _v_cur$[ebp], xmm0
$LN23@DragBehavi:

; 2018 :     }
; 2019 : 
; 2020 :     // Apply result
; 2021 :     if (*v == v_cur)

  006bf	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  006c2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006c6	0f 2e 85 74 ff
	ff ff		 ucomiss xmm0, DWORD PTR _v_cur$[ebp]
  006cd	9f		 lahf
  006ce	f6 c4 44	 test	 ah, 68			; 00000044H
  006d1	7a 04		 jp	 SHORT $LN25@DragBehavi

; 2022 :         return false;

  006d3	32 c0		 xor	 al, al
  006d5	eb 11		 jmp	 SHORT $LN1@DragBehavi
$LN25@DragBehavi:

; 2023 :     *v = v_cur;

  006d7	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  006da	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur$[ebp]
  006e2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 2024 :     return true;

  006e6	b0 01		 mov	 al, 1
$LN1@DragBehavi:

; 2025 : }

  006e8	5f		 pop	 edi
  006e9	5e		 pop	 esi
  006ea	5b		 pop	 ebx
  006eb	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  006f1	3b ec		 cmp	 ebp, esp
  006f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006f8	8b e5		 mov	 esp, ebp
  006fa	5d		 pop	 ebp
  006fb	c3		 ret	 0
??$DragBehaviorT@MMM@ImGui@@YA_NHPAMMMMPBDMH@Z ENDP	; ImGui::DragBehaviorT<float,float,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@_K_JN@ImGui@@YA_NHPA_KM_K1PBDMH@Z
_TEXT	SEGMENT
tv186 = -432						; size = 4
tv646 = -428						; size = 8
tv644 = -428						; size = 8
tv424 = -428						; size = 4
tv632 = -424						; size = 4
tv621 = -424						; size = 4
tv606 = -424						; size = 4
tv595 = -424						; size = 4
tv499 = -424						; size = 4
tv415 = -424						; size = 4
tv196 = -424						; size = 4
tv161 = -424						; size = 4
tv66 = -424						; size = 4
tv82 = -421						; size = 1
tv80 = -421						; size = 1
tv71 = -421						; size = 1
tv69 = -421						; size = 1
$T1 = -416						; size = 8
_v_cur_norm_curved$2 = -208				; size = 8
_v_new_norm_curved$3 = -192				; size = 8
_v_old_norm_curved$4 = -176				; size = 8
_v_old_ref_for_accum_remainder$ = -160			; size = 8
_v_cur$ = -144						; size = 8
_is_drag_direction_change_with_power$ = -125		; size = 1
_is_already_past_limits_and_pushing_outward$ = -113	; size = 1
_is_just_activated$ = -101				; size = 1
_decimal_precision$5 = -92				; size = 4
_adjust_delta$ = -80					; size = 4
_is_locked$ = -65					; size = 1
_is_power$ = -53					; size = 1
_is_clamped$ = -41					; size = 1
_is_decimal$ = -29					; size = 1
_axis$ = -20						; size = 4
_g$ = -8						; size = 4
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 8
_v_max$ = 28						; size = 8
_format$ = 36						; size = 4
_power$ = 40						; size = 4
_flags$ = 44						; size = 4
??$DragBehaviorT@_K_JN@ImGui@@YA_NHPA_KM_K1PBDMH@Z PROC	; ImGui::DragBehaviorT<unsigned __int64,__int64,double>, COMDAT

; 1921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 01 00
	00		 sub	 esp, 432		; 000001b0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 50 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-432]
  00012	b9 6c 00 00 00	 mov	 ecx, 108		; 0000006cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1922 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1923 :     const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00030	8b 45 2c	 mov	 eax, DWORD PTR _flags$[ebp]
  00033	83 e0 01	 and	 eax, 1
  00036	74 0c		 je	 SHORT $LN27@DragBehavi
  00038	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00042	eb 0a		 jmp	 SHORT $LN28@DragBehavi
$LN27@DragBehavi:
  00044	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN28@DragBehavi:
  0004e	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00054	89 4d ec	 mov	 DWORD PTR _axis$[ebp], ecx

; 1924 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  00057	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0005b	74 0f		 je	 SHORT $LN29@DragBehavi
  0005d	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00061	74 09		 je	 SHORT $LN29@DragBehavi
  00063	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv69[ebp], 0
  0006a	eb 07		 jmp	 SHORT $LN30@DragBehavi
$LN29@DragBehavi:
  0006c	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv69[ebp], 1
$LN30@DragBehavi:
  00073	8a 85 5b fe ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00079	88 45 e3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 1925 :     const bool is_clamped = (v_min < v_max);

  0007c	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  0007f	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  00082	77 13		 ja	 SHORT $LN31@DragBehavi
  00084	72 08		 jb	 SHORT $LN49@DragBehavi
  00086	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00089	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  0008c	73 09		 jae	 SHORT $LN31@DragBehavi
$LN49@DragBehavi:
  0008e	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv71[ebp], 1
  00095	eb 07		 jmp	 SHORT $LN32@DragBehavi
$LN31@DragBehavi:
  00097	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv71[ebp], 0
$LN32@DragBehavi:
  0009e	8a 95 5b fe ff
	ff		 mov	 dl, BYTE PTR tv71[ebp]
  000a4	88 55 d7	 mov	 BYTE PTR _is_clamped$[ebp], dl

; 1926 :     const bool is_power = (power != 1.0f && is_decimal && is_clamped && (v_max - v_min < FLT_MAX));

  000a7	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  000ac	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  000b3	9f		 lahf
  000b4	f6 c4 44	 test	 ah, 68			; 00000044H
  000b7	7b 3b		 jnp	 SHORT $LN33@DragBehavi
  000b9	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000bd	85 c0		 test	 eax, eax
  000bf	74 33		 je	 SHORT $LN33@DragBehavi
  000c1	0f b6 4d d7	 movzx	 ecx, BYTE PTR _is_clamped$[ebp]
  000c5	85 c9		 test	 ecx, ecx
  000c7	74 2b		 je	 SHORT $LN33@DragBehavi
  000c9	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  000cc	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  000cf	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  000d2	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  000d5	e8 00 00 00 00	 call	 __ultod3
  000da	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000de	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  000e6	0f 2f c8	 comiss	 xmm1, xmm0
  000e9	76 09		 jbe	 SHORT $LN33@DragBehavi
  000eb	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
  000f2	eb 07		 jmp	 SHORT $LN34@DragBehavi
$LN33@DragBehavi:
  000f4	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
$LN34@DragBehavi:
  000fb	8a 95 5b fe ff
	ff		 mov	 dl, BYTE PTR tv80[ebp]
  00101	88 55 cb	 mov	 BYTE PTR _is_power$[ebp], dl

; 1927 :     const bool is_locked = (v_min > v_max);

  00104	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00107	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  0010a	72 13		 jb	 SHORT $LN35@DragBehavi
  0010c	77 08		 ja	 SHORT $LN50@DragBehavi
  0010e	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00111	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  00114	76 09		 jbe	 SHORT $LN35@DragBehavi
$LN50@DragBehavi:
  00116	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv82[ebp], 1
  0011d	eb 07		 jmp	 SHORT $LN36@DragBehavi
$LN35@DragBehavi:
  0011f	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv82[ebp], 0
$LN36@DragBehavi:
  00126	8a 95 5b fe ff
	ff		 mov	 dl, BYTE PTR tv82[ebp]
  0012c	88 55 bf	 mov	 BYTE PTR _is_locked$[ebp], dl

; 1928 :     if (is_locked)

  0012f	0f b6 45 bf	 movzx	 eax, BYTE PTR _is_locked$[ebp]
  00133	85 c0		 test	 eax, eax
  00135	74 07		 je	 SHORT $LN2@DragBehavi

; 1929 :         return false;

  00137	32 c0		 xor	 al, al
  00139	e9 2f 07 00 00	 jmp	 $LN1@DragBehavi
$LN2@DragBehavi:

; 1930 : 
; 1931 :     // Default tweak speed
; 1932 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

  0013e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00143	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0014a	9f		 lahf
  0014b	f6 c4 44	 test	 ah, 68			; 00000044H
  0014e	7a 4f		 jp	 SHORT $LN3@DragBehavi
  00150	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00154	85 c0		 test	 eax, eax
  00156	74 47		 je	 SHORT $LN3@DragBehavi
  00158	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0015b	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  0015e	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00161	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00164	e8 00 00 00 00	 call	 __ultod3
  00169	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0016d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  00175	0f 2f c8	 comiss	 xmm1, xmm0
  00178	76 25		 jbe	 SHORT $LN3@DragBehavi

; 1933 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

  0017a	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0017d	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00180	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00183	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00186	e8 00 00 00 00	 call	 __ultod3
  0018b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0018f	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00192	f3 0f 59 80 00
	2d 00 00	 mulss	 xmm0, DWORD PTR [eax+11520]
  0019a	f3 0f 11 45 10	 movss	 DWORD PTR _v_speed$[ebp], xmm0
$LN3@DragBehavi:

; 1934 : 
; 1935 :     // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 1936 :     float adjust_delta = 0.0f;

  0019f	0f 57 c0	 xorps	 xmm0, xmm0
  001a2	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1937 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)

  001a7	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001aa	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  001b1	0f 85 8e 00 00
	00		 jne	 $LN4@DragBehavi
  001b7	6a 00		 push	 0
  001b9	e8 00 00 00 00	 call	 ?IsMousePosValid@ImGui@@YA_NPBUImVec2@@@Z ; ImGui::IsMousePosValid
  001be	83 c4 04	 add	 esp, 4
  001c1	0f b6 c0	 movzx	 eax, al
  001c4	85 c0		 test	 eax, eax
  001c6	74 7d		 je	 SHORT $LN4@DragBehavi
  001c8	b8 04 00 00 00	 mov	 eax, 4
  001cd	6b c8 00	 imul	 ecx, eax, 0
  001d0	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  001d3	f3 0f 10 84 0a
	44 04 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1092]
  001dc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001e3	76 60		 jbe	 SHORT $LN4@DragBehavi

; 1938 :     {
; 1939 :         adjust_delta = g.IO.MouseDelta[axis];

  001e5	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  001ec	81 c1 78 03 00
	00		 add	 ecx, 888		; 00000378H
  001f2	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  001f7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001fb	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1940 :         if (g.IO.KeyAlt)

  00200	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00203	0f b6 88 02 01
	00 00		 movzx	 ecx, BYTE PTR [eax+258]
  0020a	85 c9		 test	 ecx, ecx
  0020c	74 12		 je	 SHORT $LN6@DragBehavi

; 1941 :             adjust_delta *= 1.0f / 100.0f;

  0020e	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00213	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  0021b	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN6@DragBehavi:

; 1942 :         if (g.IO.KeyShift)

  00220	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00223	0f b6 88 01 01
	00 00		 movzx	 ecx, BYTE PTR [eax+257]
  0022a	85 c9		 test	 ecx, ecx
  0022c	74 12		 je	 SHORT $LN7@DragBehavi

; 1943 :             adjust_delta *= 10.0f;

  0022e	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00233	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  0023b	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN7@DragBehavi:

; 1944 :     }

  00240	e9 a6 00 00 00	 jmp	 $LN8@DragBehavi
$LN4@DragBehavi:

; 1945 :     else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  00245	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00248	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  0024f	0f 85 96 00 00
	00		 jne	 $LN8@DragBehavi

; 1946 :     {
; 1947 :         int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00255	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00259	85 c0		 test	 eax, eax
  0025b	74 16		 je	 SHORT $LN37@DragBehavi
  0025d	6a 03		 push	 3
  0025f	8b 4d 24	 mov	 ecx, DWORD PTR _format$[ebp]
  00262	51		 push	 ecx
  00263	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00268	83 c4 08	 add	 esp, 8
  0026b	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv161[ebp], eax
  00271	eb 0a		 jmp	 SHORT $LN38@DragBehavi
$LN37@DragBehavi:
  00273	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN38@DragBehavi:
  0027d	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  00283	89 55 a4	 mov	 DWORD PTR _decimal_precision$5[ebp], edx

; 1948 :         adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

  00286	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  00289	50		 push	 eax
  0028a	51		 push	 ecx
  0028b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00293	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00298	51		 push	 ecx
  00299	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  002a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a6	6a 05		 push	 5
  002a8	6a 03		 push	 3
  002aa	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002b0	51		 push	 ecx
  002b1	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  002b6	83 c4 14	 add	 esp, 20			; 00000014H
  002b9	8b c8		 mov	 ecx, eax
  002bb	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  002c0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002c4	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1949 :         v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

  002c9	8b 45 a4	 mov	 eax, DWORD PTR _decimal_precision$5[ebp]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 ?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
  002d2	d9 1c 24	 fstp	 DWORD PTR [esp]
  002d5	51		 push	 ecx
  002d6	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  002db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002e5	83 c4 08	 add	 esp, 8
  002e8	d9 5d 10	 fstp	 DWORD PTR _v_speed$[ebp]
$LN8@DragBehavi:

; 1950 :     }
; 1951 :     adjust_delta *= v_speed;

  002eb	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002f0	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _v_speed$[ebp]
  002f5	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1952 : 
; 1953 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 1954 :     if (axis == ImGuiAxis_Y)

  002fa	83 7d ec 01	 cmp	 DWORD PTR _axis$[ebp], 1
  002fe	75 11		 jne	 SHORT $LN9@DragBehavi

; 1955 :         adjust_delta = -adjust_delta;

  00300	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00305	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0030c	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN9@DragBehavi:

; 1956 : 
; 1957 :     // Clear current value on activation
; 1958 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 1959 :     bool is_just_activated = g.ActiveIdIsJustActivated;

  00311	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00314	8a 88 f0 19 00
	00		 mov	 cl, BYTE PTR [eax+6640]
  0031a	88 4d 9b	 mov	 BYTE PTR _is_just_activated$[ebp], cl

; 1960 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

  0031d	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00321	85 c0		 test	 eax, eax
  00323	74 6f		 je	 SHORT $LN42@DragBehavi
  00325	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  00328	89 8d 58 fe ff
	ff		 mov	 DWORD PTR tv415[ebp], ecx
  0032e	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv415[ebp]
  00334	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00337	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  0033a	72 1d		 jb	 SHORT $LN39@DragBehavi
  0033c	77 0d		 ja	 SHORT $LN51@DragBehavi
  0033e	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv415[ebp]
  00344	8b 11		 mov	 edx, DWORD PTR [ecx]
  00346	3b 55 1c	 cmp	 edx, DWORD PTR _v_max$[ebp]
  00349	72 0e		 jb	 SHORT $LN39@DragBehavi
$LN51@DragBehavi:
  0034b	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00350	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00357	77 2f		 ja	 SHORT $LN41@DragBehavi
$LN39@DragBehavi:
  00359	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0035c	89 85 54 fe ff
	ff		 mov	 DWORD PTR tv424[ebp], eax
  00362	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv424[ebp]
  00368	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0036b	3b 55 18	 cmp	 edx, DWORD PTR _v_min$[ebp+4]
  0036e	77 24		 ja	 SHORT $LN42@DragBehavi
  00370	72 0d		 jb	 SHORT $LN52@DragBehavi
  00372	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv424[ebp]
  00378	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037a	3b 4d 14	 cmp	 ecx, DWORD PTR _v_min$[ebp]
  0037d	77 15		 ja	 SHORT $LN42@DragBehavi
$LN52@DragBehavi:
  0037f	0f 57 c0	 xorps	 xmm0, xmm0
  00382	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00386	76 0c		 jbe	 SHORT $LN42@DragBehavi
$LN41@DragBehavi:
  00388	c7 85 50 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv186[ebp], 1
  00392	eb 0a		 jmp	 SHORT $LN43@DragBehavi
$LN42@DragBehavi:
  00394	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv186[ebp], 0
$LN43@DragBehavi:
  0039e	8a 95 50 fe ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  003a4	88 55 8f	 mov	 BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp], dl

; 1961 :     bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

  003a7	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  003ab	85 c0		 test	 eax, eax
  003ad	74 46		 je	 SHORT $LN47@DragBehavi
  003af	0f 57 c0	 xorps	 xmm0, xmm0
  003b2	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003b6	76 14		 jbe	 SHORT $LN44@DragBehavi
  003b8	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  003bb	f3 0f 10 81 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [ecx+11516]
  003c3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003ca	77 1d		 ja	 SHORT $LN46@DragBehavi
$LN44@DragBehavi:
  003cc	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003d1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003d8	76 1b		 jbe	 SHORT $LN47@DragBehavi
  003da	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  003dd	0f 57 c0	 xorps	 xmm0, xmm0
  003e0	0f 2f 82 fc 2c
	00 00		 comiss	 xmm0, DWORD PTR [edx+11516]
  003e7	76 0c		 jbe	 SHORT $LN47@DragBehavi
$LN46@DragBehavi:
  003e9	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv196[ebp], 1
  003f3	eb 0a		 jmp	 SHORT $LN48@DragBehavi
$LN47@DragBehavi:
  003f5	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
$LN48@DragBehavi:
  003ff	8a 85 58 fe ff
	ff		 mov	 al, BYTE PTR tv196[ebp]
  00405	88 45 83	 mov	 BYTE PTR _is_drag_direction_change_with_power$[ebp], al

; 1962 :     if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

  00408	0f b6 45 9b	 movzx	 eax, BYTE PTR _is_just_activated$[ebp]
  0040c	85 c0		 test	 eax, eax
  0040e	75 10		 jne	 SHORT $LN12@DragBehavi
  00410	0f b6 45 8f	 movzx	 eax, BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp]
  00414	85 c0		 test	 eax, eax
  00416	75 08		 jne	 SHORT $LN12@DragBehavi
  00418	0f b6 45 83	 movzx	 eax, BYTE PTR _is_drag_direction_change_with_power$[ebp]
  0041c	85 c0		 test	 eax, eax
  0041e	74 1a		 je	 SHORT $LN10@DragBehavi
$LN12@DragBehavi:

; 1963 :     {
; 1964 :         g.DragCurrentAccum = 0.0f;

  00420	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00423	0f 57 c0	 xorps	 xmm0, xmm0
  00426	f3 0f 11 80 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm0

; 1965 :         g.DragCurrentAccumDirty = false;

  0042e	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00431	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1966 :     }

  00438	eb 37		 jmp	 SHORT $LN13@DragBehavi
$LN10@DragBehavi:

; 1967 :     else if (adjust_delta != 0.0f)

  0043a	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0043f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00446	9f		 lahf
  00447	f6 c4 44	 test	 ah, 68			; 00000044H
  0044a	7b 25		 jnp	 SHORT $LN13@DragBehavi

; 1968 :     {
; 1969 :         g.DragCurrentAccum += adjust_delta;

  0044c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0044f	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  00457	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0045c	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0045f	f3 0f 11 81 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm0

; 1970 :         g.DragCurrentAccumDirty = true;

  00467	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0046a	c6 80 f8 2c 00
	00 01		 mov	 BYTE PTR [eax+11512], 1
$LN13@DragBehavi:

; 1971 :     }
; 1972 : 
; 1973 :     if (!g.DragCurrentAccumDirty)

  00471	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00474	0f b6 88 f8 2c
	00 00		 movzx	 ecx, BYTE PTR [eax+11512]
  0047b	85 c9		 test	 ecx, ecx
  0047d	75 07		 jne	 SHORT $LN14@DragBehavi

; 1974 :         return false;

  0047f	32 c0		 xor	 al, al
  00481	e9 e7 03 00 00	 jmp	 $LN1@DragBehavi
$LN14@DragBehavi:

; 1975 : 
; 1976 :     TYPE v_cur = *v;

  00486	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00489	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048b	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], ecx
  00491	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00494	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx

; 1977 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

  0049a	0f 57 c0	 xorps	 xmm0, xmm0
  0049d	f2 0f 11 85 60
	ff ff ff	 movsd	 QWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1978 : 
; 1979 :     if (is_power)

  004a5	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  004a9	85 c0		 test	 eax, eax
  004ab	0f 84 18 01 00
	00		 je	 $LN15@DragBehavi

; 1980 :     {
; 1981 :         // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 1982 :         FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  004b1	f3 0f 5a 45 28	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  004b6	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  004be	f2 0f 5e c8	 divsd	 xmm1, xmm0
  004c2	83 ec 08	 sub	 esp, 8
  004c5	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  004ca	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  004d0	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  004d3	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  004d9	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  004dc	e8 00 00 00 00	 call	 __ultod3
  004e1	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  004e4	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  004e7	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  004ea	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  004ed	f2 0f 11 85 54
	fe ff ff	 movsd	 QWORD PTR tv644[ebp], xmm0
  004f5	e8 00 00 00 00	 call	 __ultod3
  004fa	f2 0f 10 8d 54
	fe ff ff	 movsd	 xmm1, QWORD PTR tv644[ebp]
  00502	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00506	83 ec 08	 sub	 esp, 8
  00509	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0050e	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00513	83 c4 10	 add	 esp, 16			; 00000010H
  00516	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _v_old_norm_curved$4[ebp]

; 1983 :         FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

  0051c	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0051f	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00522	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00525	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00528	e8 00 00 00 00	 call	 __ultod3
  0052d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00531	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00534	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  0053c	f3 0f 5e c8	 divss	 xmm1, xmm0
  00540	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00544	f2 0f 58 85 50
	ff ff ff	 addsd	 xmm0, QWORD PTR _v_old_norm_curved$4[ebp]
  0054c	f2 0f 11 85 40
	ff ff ff	 movsd	 QWORD PTR _v_new_norm_curved$3[ebp], xmm0

; 1984 :         v_cur = v_min + (SIGNEDTYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

  00554	51		 push	 ecx
  00555	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  0055a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055f	f2 0f 5a 85 40
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR _v_new_norm_curved$3[ebp]
  00567	51		 push	 ecx
  00568	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0056d	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00572	d9 1c 24	 fstp	 DWORD PTR [esp]
  00575	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0057a	83 c4 08	 add	 esp, 8
  0057d	d9 9d 58 fe ff
	ff		 fstp	 DWORD PTR tv499[ebp]
  00583	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR tv499[ebp]
  0058b	e8 00 00 00 00	 call	 __ftol3
  00590	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00593	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00596	8b 75 20	 mov	 esi, DWORD PTR _v_max$[ebp+4]
  00599	1b 75 18	 sbb	 esi, DWORD PTR _v_min$[ebp+4]
  0059c	56		 push	 esi
  0059d	51		 push	 ecx
  0059e	52		 push	 edx
  0059f	50		 push	 eax
  005a0	e8 00 00 00 00	 call	 __allmul
  005a5	03 45 14	 add	 eax, DWORD PTR _v_min$[ebp]
  005a8	13 55 18	 adc	 edx, DWORD PTR _v_min$[ebp+4]
  005ab	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  005b1	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx

; 1985 :         v_old_ref_for_accum_remainder = v_old_norm_curved;

  005b7	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_old_norm_curved$4[ebp]
  005bf	f2 0f 11 85 60
	ff ff ff	 movsd	 QWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1986 :     }

  005c7	eb 28		 jmp	 SHORT $LN16@DragBehavi
$LN15@DragBehavi:

; 1987 :     else
; 1988 :     {
; 1989 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

  005c9	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005cc	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  005d4	e8 00 00 00 00	 call	 __ftol3
  005d9	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _v_cur$[ebp]
  005df	13 95 74 ff ff
	ff		 adc	 edx, DWORD PTR _v_cur$[ebp+4]
  005e5	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  005eb	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx
$LN16@DragBehavi:

; 1990 :     }
; 1991 : 
; 1992 :     // Round to user desired precision based on format string
; 1993 :     v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

  005f1	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp+4]
  005f7	50		 push	 eax
  005f8	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  005fe	51		 push	 ecx
  005ff	8b 55 08	 mov	 edx, DWORD PTR _data_type$[ebp]
  00602	52		 push	 edx
  00603	8b 45 24	 mov	 eax, DWORD PTR _format$[ebp]
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@_K_J@ImGui@@YA_KPBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64,__int64>
  0060c	83 c4 10	 add	 esp, 16			; 00000010H
  0060f	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  00615	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx

; 1994 : 
; 1995 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 1996 :     g.DragCurrentAccumDirty = false;

  0061b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0061e	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1997 :     if (is_power)

  00625	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00629	85 c0		 test	 eax, eax
  0062b	0f 84 9b 00 00
	00		 je	 $LN17@DragBehavi

; 1998 :     {
; 1999 :         FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  00631	f3 0f 5a 45 28	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  00636	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0063e	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00642	83 ec 08	 sub	 esp, 8
  00645	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0064a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00650	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00653	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  00659	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0065c	e8 00 00 00 00	 call	 __ultod3
  00661	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00664	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00667	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  0066a	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0066d	f2 0f 11 85 54
	fe ff ff	 movsd	 QWORD PTR tv646[ebp], xmm0
  00675	e8 00 00 00 00	 call	 __ultod3
  0067a	f2 0f 10 8d 54
	fe ff ff	 movsd	 xmm1, QWORD PTR tv646[ebp]
  00682	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00686	83 ec 08	 sub	 esp, 8
  00689	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0068e	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00693	83 c4 10	 add	 esp, 16			; 00000010H
  00696	dd 9d 30 ff ff
	ff		 fstp	 QWORD PTR _v_cur_norm_curved$2[ebp]

; 2000 :         g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

  0069c	f2 0f 10 85 30
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur_norm_curved$2[ebp]
  006a4	f2 0f 5c 85 60
	ff ff ff	 subsd	 xmm0, QWORD PTR _v_old_ref_for_accum_remainder$[ebp]
  006ac	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006b0	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  006b3	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  006bb	f3 0f 5c c8	 subss	 xmm1, xmm0
  006bf	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  006c2	f3 0f 11 89 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm1

; 2001 :     }

  006ca	eb 37		 jmp	 SHORT $LN18@DragBehavi
$LN17@DragBehavi:

; 2002 :     else
; 2003 :     {
; 2004 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

  006cc	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  006cf	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  006d5	2b 08		 sub	 ecx, DWORD PTR [eax]
  006d7	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  006dd	1b 50 04	 sbb	 edx, DWORD PTR [eax+4]
  006e0	e8 00 00 00 00	 call	 __ltod3
  006e5	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006e9	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  006ec	f3 0f 10 89 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [ecx+11516]
  006f4	f3 0f 5c c8	 subss	 xmm1, xmm0
  006f8	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  006fb	f3 0f 11 8a fc
	2c 00 00	 movss	 DWORD PTR [edx+11516], xmm1
$LN18@DragBehavi:

; 2005 :     }
; 2006 : 
; 2007 :     // Lose zero sign for float/double
; 2008 :     if (v_cur == (TYPE)-0)

  00703	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00709	0b 85 74 ff ff
	ff		 or	 eax, DWORD PTR _v_cur$[ebp+4]
  0070f	75 0b		 jne	 SHORT $LN19@DragBehavi

; 2009 :         v_cur = (TYPE)0;

  00711	0f 57 c0	 xorps	 xmm0, xmm0
  00714	66 0f 13 85 70
	ff ff ff	 movlpd	 QWORD PTR _v_cur$[ebp], xmm0
$LN19@DragBehavi:

; 2010 : 
; 2011 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2012 :     if (*v != v_cur && is_clamped)

  0071c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0071f	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv595[ebp], eax
  00725	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv595[ebp]
  0072b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0072d	3b 95 70 ff ff
	ff		 cmp	 edx, DWORD PTR _v_cur$[ebp]
  00733	75 15		 jne	 SHORT $LN53@DragBehavi
  00735	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv595[ebp]
  0073b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0073e	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp+4]
  00744	0f 84 df 00 00
	00		 je	 $LN23@DragBehavi
$LN53@DragBehavi:
  0074a	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  0074e	85 c0		 test	 eax, eax
  00750	0f 84 d3 00 00
	00		 je	 $LN23@DragBehavi

; 2013 :     {
; 2014 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

  00756	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp+4]
  0075c	3b 45 18	 cmp	 eax, DWORD PTR _v_min$[ebp+4]
  0075f	72 4a		 jb	 SHORT $LN22@DragBehavi
  00761	77 0b		 ja	 SHORT $LN54@DragBehavi
  00763	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00769	3b 4d 14	 cmp	 ecx, DWORD PTR _v_min$[ebp]
  0076c	72 3d		 jb	 SHORT $LN22@DragBehavi
$LN54@DragBehavi:
  0076e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00771	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv606[ebp], eax
  00777	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv606[ebp]
  0077d	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  00783	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00786	72 35		 jb	 SHORT $LN21@DragBehavi
  00788	77 10		 ja	 SHORT $LN55@DragBehavi
  0078a	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv606[ebp]
  00790	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00796	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00798	76 23		 jbe	 SHORT $LN21@DragBehavi
$LN55@DragBehavi:
  0079a	0f 57 c0	 xorps	 xmm0, xmm0
  0079d	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  007a1	76 1a		 jbe	 SHORT $LN21@DragBehavi
  007a3	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  007a7	85 c0		 test	 eax, eax
  007a9	75 12		 jne	 SHORT $LN21@DragBehavi
$LN22@DragBehavi:

; 2015 :             v_cur = v_min;

  007ab	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  007ae	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  007b4	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  007b7	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], ecx
$LN21@DragBehavi:

; 2016 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

  007bd	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp+4]
  007c3	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  007c6	77 4f		 ja	 SHORT $LN24@DragBehavi
  007c8	72 0b		 jb	 SHORT $LN56@DragBehavi
  007ca	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  007d0	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  007d3	77 42		 ja	 SHORT $LN24@DragBehavi
$LN56@DragBehavi:
  007d5	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  007d8	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv621[ebp], eax
  007de	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv621[ebp]
  007e4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  007ea	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  007ed	77 3a		 ja	 SHORT $LN23@DragBehavi
  007ef	72 10		 jb	 SHORT $LN57@DragBehavi
  007f1	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv621[ebp]
  007f7	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  007fd	3b 08		 cmp	 ecx, DWORD PTR [eax]
  007ff	73 28		 jae	 SHORT $LN23@DragBehavi
$LN57@DragBehavi:
  00801	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00806	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0080d	76 1a		 jbe	 SHORT $LN23@DragBehavi
  0080f	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00813	85 c0		 test	 eax, eax
  00815	75 12		 jne	 SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2017 :             v_cur = v_max;

  00817	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  0081a	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  00820	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp+4]
  00823	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], ecx
$LN23@DragBehavi:

; 2018 :     }
; 2019 : 
; 2020 :     // Apply result
; 2021 :     if (*v == v_cur)

  00829	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0082c	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv632[ebp], eax
  00832	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv632[ebp]
  00838	8b 11		 mov	 edx, DWORD PTR [ecx]
  0083a	3b 95 70 ff ff
	ff		 cmp	 edx, DWORD PTR _v_cur$[ebp]
  00840	75 15		 jne	 SHORT $LN25@DragBehavi
  00842	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv632[ebp]
  00848	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0084b	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp+4]
  00851	75 04		 jne	 SHORT $LN25@DragBehavi

; 2022 :         return false;

  00853	32 c0		 xor	 al, al
  00855	eb 16		 jmp	 SHORT $LN1@DragBehavi
$LN25@DragBehavi:

; 2023 :     *v = v_cur;

  00857	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0085a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00860	89 08		 mov	 DWORD PTR [eax], ecx
  00862	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  00868	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2024 :     return true;

  0086b	b0 01		 mov	 al, 1
$LN1@DragBehavi:

; 2025 : }

  0086d	5f		 pop	 edi
  0086e	5e		 pop	 esi
  0086f	5b		 pop	 ebx
  00870	81 c4 b0 01 00
	00		 add	 esp, 432		; 000001b0H
  00876	3b ec		 cmp	 ebp, esp
  00878	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0087d	8b e5		 mov	 esp, ebp
  0087f	5d		 pop	 ebp
  00880	c3		 ret	 0
??$DragBehaviorT@_K_JN@ImGui@@YA_NHPA_KM_K1PBDMH@Z ENDP	; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@_J_JN@ImGui@@YA_NHPA_JM_J1PBDMH@Z
_TEXT	SEGMENT
tv186 = -432						; size = 4
tv646 = -428						; size = 8
tv644 = -428						; size = 8
tv424 = -428						; size = 4
tv632 = -424						; size = 4
tv621 = -424						; size = 4
tv606 = -424						; size = 4
tv595 = -424						; size = 4
tv499 = -424						; size = 4
tv415 = -424						; size = 4
tv196 = -424						; size = 4
tv161 = -424						; size = 4
tv66 = -424						; size = 4
tv82 = -421						; size = 1
tv80 = -421						; size = 1
tv71 = -421						; size = 1
tv69 = -421						; size = 1
$T1 = -416						; size = 8
_v_cur_norm_curved$2 = -208				; size = 8
_v_new_norm_curved$3 = -192				; size = 8
_v_old_norm_curved$4 = -176				; size = 8
_v_old_ref_for_accum_remainder$ = -160			; size = 8
_v_cur$ = -144						; size = 8
_is_drag_direction_change_with_power$ = -125		; size = 1
_is_already_past_limits_and_pushing_outward$ = -113	; size = 1
_is_just_activated$ = -101				; size = 1
_decimal_precision$5 = -92				; size = 4
_adjust_delta$ = -80					; size = 4
_is_locked$ = -65					; size = 1
_is_power$ = -53					; size = 1
_is_clamped$ = -41					; size = 1
_is_decimal$ = -29					; size = 1
_axis$ = -20						; size = 4
_g$ = -8						; size = 4
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 8
_v_max$ = 28						; size = 8
_format$ = 36						; size = 4
_power$ = 40						; size = 4
_flags$ = 44						; size = 4
??$DragBehaviorT@_J_JN@ImGui@@YA_NHPA_JM_J1PBDMH@Z PROC	; ImGui::DragBehaviorT<__int64,__int64,double>, COMDAT

; 1921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 01 00
	00		 sub	 esp, 432		; 000001b0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 50 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-432]
  00012	b9 6c 00 00 00	 mov	 ecx, 108		; 0000006cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1922 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1923 :     const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00030	8b 45 2c	 mov	 eax, DWORD PTR _flags$[ebp]
  00033	83 e0 01	 and	 eax, 1
  00036	74 0c		 je	 SHORT $LN27@DragBehavi
  00038	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00042	eb 0a		 jmp	 SHORT $LN28@DragBehavi
$LN27@DragBehavi:
  00044	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN28@DragBehavi:
  0004e	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00054	89 4d ec	 mov	 DWORD PTR _axis$[ebp], ecx

; 1924 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  00057	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0005b	74 0f		 je	 SHORT $LN29@DragBehavi
  0005d	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00061	74 09		 je	 SHORT $LN29@DragBehavi
  00063	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv69[ebp], 0
  0006a	eb 07		 jmp	 SHORT $LN30@DragBehavi
$LN29@DragBehavi:
  0006c	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv69[ebp], 1
$LN30@DragBehavi:
  00073	8a 85 5b fe ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00079	88 45 e3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 1925 :     const bool is_clamped = (v_min < v_max);

  0007c	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  0007f	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  00082	7f 13		 jg	 SHORT $LN31@DragBehavi
  00084	7c 08		 jl	 SHORT $LN49@DragBehavi
  00086	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00089	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  0008c	73 09		 jae	 SHORT $LN31@DragBehavi
$LN49@DragBehavi:
  0008e	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv71[ebp], 1
  00095	eb 07		 jmp	 SHORT $LN32@DragBehavi
$LN31@DragBehavi:
  00097	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv71[ebp], 0
$LN32@DragBehavi:
  0009e	8a 95 5b fe ff
	ff		 mov	 dl, BYTE PTR tv71[ebp]
  000a4	88 55 d7	 mov	 BYTE PTR _is_clamped$[ebp], dl

; 1926 :     const bool is_power = (power != 1.0f && is_decimal && is_clamped && (v_max - v_min < FLT_MAX));

  000a7	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  000ac	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  000b3	9f		 lahf
  000b4	f6 c4 44	 test	 ah, 68			; 00000044H
  000b7	7b 3b		 jnp	 SHORT $LN33@DragBehavi
  000b9	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000bd	85 c0		 test	 eax, eax
  000bf	74 33		 je	 SHORT $LN33@DragBehavi
  000c1	0f b6 4d d7	 movzx	 ecx, BYTE PTR _is_clamped$[ebp]
  000c5	85 c9		 test	 ecx, ecx
  000c7	74 2b		 je	 SHORT $LN33@DragBehavi
  000c9	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  000cc	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  000cf	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  000d2	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  000d5	e8 00 00 00 00	 call	 __ltod3
  000da	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  000de	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  000e6	0f 2f c8	 comiss	 xmm1, xmm0
  000e9	76 09		 jbe	 SHORT $LN33@DragBehavi
  000eb	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
  000f2	eb 07		 jmp	 SHORT $LN34@DragBehavi
$LN33@DragBehavi:
  000f4	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
$LN34@DragBehavi:
  000fb	8a 95 5b fe ff
	ff		 mov	 dl, BYTE PTR tv80[ebp]
  00101	88 55 cb	 mov	 BYTE PTR _is_power$[ebp], dl

; 1927 :     const bool is_locked = (v_min > v_max);

  00104	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp+4]
  00107	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  0010a	7c 13		 jl	 SHORT $LN35@DragBehavi
  0010c	7f 08		 jg	 SHORT $LN50@DragBehavi
  0010e	8b 4d 14	 mov	 ecx, DWORD PTR _v_min$[ebp]
  00111	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  00114	76 09		 jbe	 SHORT $LN35@DragBehavi
$LN50@DragBehavi:
  00116	c6 85 5b fe ff
	ff 01		 mov	 BYTE PTR tv82[ebp], 1
  0011d	eb 07		 jmp	 SHORT $LN36@DragBehavi
$LN35@DragBehavi:
  0011f	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR tv82[ebp], 0
$LN36@DragBehavi:
  00126	8a 95 5b fe ff
	ff		 mov	 dl, BYTE PTR tv82[ebp]
  0012c	88 55 bf	 mov	 BYTE PTR _is_locked$[ebp], dl

; 1928 :     if (is_locked)

  0012f	0f b6 45 bf	 movzx	 eax, BYTE PTR _is_locked$[ebp]
  00133	85 c0		 test	 eax, eax
  00135	74 07		 je	 SHORT $LN2@DragBehavi

; 1929 :         return false;

  00137	32 c0		 xor	 al, al
  00139	e9 2f 07 00 00	 jmp	 $LN1@DragBehavi
$LN2@DragBehavi:

; 1930 : 
; 1931 :     // Default tweak speed
; 1932 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

  0013e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00143	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0014a	9f		 lahf
  0014b	f6 c4 44	 test	 ah, 68			; 00000044H
  0014e	7a 4f		 jp	 SHORT $LN3@DragBehavi
  00150	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00154	85 c0		 test	 eax, eax
  00156	74 47		 je	 SHORT $LN3@DragBehavi
  00158	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0015b	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  0015e	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00161	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00164	e8 00 00 00 00	 call	 __ltod3
  00169	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0016d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  00175	0f 2f c8	 comiss	 xmm1, xmm0
  00178	76 25		 jbe	 SHORT $LN3@DragBehavi

; 1933 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

  0017a	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0017d	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00180	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00183	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00186	e8 00 00 00 00	 call	 __ltod3
  0018b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0018f	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00192	f3 0f 59 80 00
	2d 00 00	 mulss	 xmm0, DWORD PTR [eax+11520]
  0019a	f3 0f 11 45 10	 movss	 DWORD PTR _v_speed$[ebp], xmm0
$LN3@DragBehavi:

; 1934 : 
; 1935 :     // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 1936 :     float adjust_delta = 0.0f;

  0019f	0f 57 c0	 xorps	 xmm0, xmm0
  001a2	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1937 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)

  001a7	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001aa	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  001b1	0f 85 8e 00 00
	00		 jne	 $LN4@DragBehavi
  001b7	6a 00		 push	 0
  001b9	e8 00 00 00 00	 call	 ?IsMousePosValid@ImGui@@YA_NPBUImVec2@@@Z ; ImGui::IsMousePosValid
  001be	83 c4 04	 add	 esp, 4
  001c1	0f b6 c0	 movzx	 eax, al
  001c4	85 c0		 test	 eax, eax
  001c6	74 7d		 je	 SHORT $LN4@DragBehavi
  001c8	b8 04 00 00 00	 mov	 eax, 4
  001cd	6b c8 00	 imul	 ecx, eax, 0
  001d0	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  001d3	f3 0f 10 84 0a
	44 04 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1092]
  001dc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001e3	76 60		 jbe	 SHORT $LN4@DragBehavi

; 1938 :     {
; 1939 :         adjust_delta = g.IO.MouseDelta[axis];

  001e5	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  001e8	50		 push	 eax
  001e9	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  001ec	81 c1 78 03 00
	00		 add	 ecx, 888		; 00000378H
  001f2	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  001f7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001fb	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1940 :         if (g.IO.KeyAlt)

  00200	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00203	0f b6 88 02 01
	00 00		 movzx	 ecx, BYTE PTR [eax+258]
  0020a	85 c9		 test	 ecx, ecx
  0020c	74 12		 je	 SHORT $LN6@DragBehavi

; 1941 :             adjust_delta *= 1.0f / 100.0f;

  0020e	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00213	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  0021b	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN6@DragBehavi:

; 1942 :         if (g.IO.KeyShift)

  00220	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00223	0f b6 88 01 01
	00 00		 movzx	 ecx, BYTE PTR [eax+257]
  0022a	85 c9		 test	 ecx, ecx
  0022c	74 12		 je	 SHORT $LN7@DragBehavi

; 1943 :             adjust_delta *= 10.0f;

  0022e	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00233	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  0023b	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN7@DragBehavi:

; 1944 :     }

  00240	e9 a6 00 00 00	 jmp	 $LN8@DragBehavi
$LN4@DragBehavi:

; 1945 :     else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  00245	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00248	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  0024f	0f 85 96 00 00
	00		 jne	 $LN8@DragBehavi

; 1946 :     {
; 1947 :         int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00255	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00259	85 c0		 test	 eax, eax
  0025b	74 16		 je	 SHORT $LN37@DragBehavi
  0025d	6a 03		 push	 3
  0025f	8b 4d 24	 mov	 ecx, DWORD PTR _format$[ebp]
  00262	51		 push	 ecx
  00263	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00268	83 c4 08	 add	 esp, 8
  0026b	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv161[ebp], eax
  00271	eb 0a		 jmp	 SHORT $LN38@DragBehavi
$LN37@DragBehavi:
  00273	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN38@DragBehavi:
  0027d	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  00283	89 55 a4	 mov	 DWORD PTR _decimal_precision$5[ebp], edx

; 1948 :         adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

  00286	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  00289	50		 push	 eax
  0028a	51		 push	 ecx
  0028b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00293	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00298	51		 push	 ecx
  00299	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  002a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a6	6a 05		 push	 5
  002a8	6a 03		 push	 3
  002aa	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002b0	51		 push	 ecx
  002b1	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  002b6	83 c4 14	 add	 esp, 20			; 00000014H
  002b9	8b c8		 mov	 ecx, eax
  002bb	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  002c0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002c4	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1949 :         v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

  002c9	8b 45 a4	 mov	 eax, DWORD PTR _decimal_precision$5[ebp]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 ?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
  002d2	d9 1c 24	 fstp	 DWORD PTR [esp]
  002d5	51		 push	 ecx
  002d6	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  002db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002e5	83 c4 08	 add	 esp, 8
  002e8	d9 5d 10	 fstp	 DWORD PTR _v_speed$[ebp]
$LN8@DragBehavi:

; 1950 :     }
; 1951 :     adjust_delta *= v_speed;

  002eb	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002f0	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _v_speed$[ebp]
  002f5	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1952 : 
; 1953 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 1954 :     if (axis == ImGuiAxis_Y)

  002fa	83 7d ec 01	 cmp	 DWORD PTR _axis$[ebp], 1
  002fe	75 11		 jne	 SHORT $LN9@DragBehavi

; 1955 :         adjust_delta = -adjust_delta;

  00300	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00305	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0030c	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN9@DragBehavi:

; 1956 : 
; 1957 :     // Clear current value on activation
; 1958 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 1959 :     bool is_just_activated = g.ActiveIdIsJustActivated;

  00311	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00314	8a 88 f0 19 00
	00		 mov	 cl, BYTE PTR [eax+6640]
  0031a	88 4d 9b	 mov	 BYTE PTR _is_just_activated$[ebp], cl

; 1960 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

  0031d	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00321	85 c0		 test	 eax, eax
  00323	74 6f		 je	 SHORT $LN42@DragBehavi
  00325	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  00328	89 8d 58 fe ff
	ff		 mov	 DWORD PTR tv415[ebp], ecx
  0032e	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv415[ebp]
  00334	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00337	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  0033a	7c 1d		 jl	 SHORT $LN39@DragBehavi
  0033c	7f 0d		 jg	 SHORT $LN51@DragBehavi
  0033e	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv415[ebp]
  00344	8b 11		 mov	 edx, DWORD PTR [ecx]
  00346	3b 55 1c	 cmp	 edx, DWORD PTR _v_max$[ebp]
  00349	72 0e		 jb	 SHORT $LN39@DragBehavi
$LN51@DragBehavi:
  0034b	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00350	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00357	77 2f		 ja	 SHORT $LN41@DragBehavi
$LN39@DragBehavi:
  00359	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0035c	89 85 54 fe ff
	ff		 mov	 DWORD PTR tv424[ebp], eax
  00362	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv424[ebp]
  00368	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0036b	3b 55 18	 cmp	 edx, DWORD PTR _v_min$[ebp+4]
  0036e	7f 24		 jg	 SHORT $LN42@DragBehavi
  00370	7c 0d		 jl	 SHORT $LN52@DragBehavi
  00372	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv424[ebp]
  00378	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037a	3b 4d 14	 cmp	 ecx, DWORD PTR _v_min$[ebp]
  0037d	77 15		 ja	 SHORT $LN42@DragBehavi
$LN52@DragBehavi:
  0037f	0f 57 c0	 xorps	 xmm0, xmm0
  00382	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00386	76 0c		 jbe	 SHORT $LN42@DragBehavi
$LN41@DragBehavi:
  00388	c7 85 50 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv186[ebp], 1
  00392	eb 0a		 jmp	 SHORT $LN43@DragBehavi
$LN42@DragBehavi:
  00394	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv186[ebp], 0
$LN43@DragBehavi:
  0039e	8a 95 50 fe ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  003a4	88 55 8f	 mov	 BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp], dl

; 1961 :     bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

  003a7	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  003ab	85 c0		 test	 eax, eax
  003ad	74 46		 je	 SHORT $LN47@DragBehavi
  003af	0f 57 c0	 xorps	 xmm0, xmm0
  003b2	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003b6	76 14		 jbe	 SHORT $LN44@DragBehavi
  003b8	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  003bb	f3 0f 10 81 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [ecx+11516]
  003c3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003ca	77 1d		 ja	 SHORT $LN46@DragBehavi
$LN44@DragBehavi:
  003cc	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003d1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003d8	76 1b		 jbe	 SHORT $LN47@DragBehavi
  003da	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  003dd	0f 57 c0	 xorps	 xmm0, xmm0
  003e0	0f 2f 82 fc 2c
	00 00		 comiss	 xmm0, DWORD PTR [edx+11516]
  003e7	76 0c		 jbe	 SHORT $LN47@DragBehavi
$LN46@DragBehavi:
  003e9	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv196[ebp], 1
  003f3	eb 0a		 jmp	 SHORT $LN48@DragBehavi
$LN47@DragBehavi:
  003f5	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
$LN48@DragBehavi:
  003ff	8a 85 58 fe ff
	ff		 mov	 al, BYTE PTR tv196[ebp]
  00405	88 45 83	 mov	 BYTE PTR _is_drag_direction_change_with_power$[ebp], al

; 1962 :     if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

  00408	0f b6 45 9b	 movzx	 eax, BYTE PTR _is_just_activated$[ebp]
  0040c	85 c0		 test	 eax, eax
  0040e	75 10		 jne	 SHORT $LN12@DragBehavi
  00410	0f b6 45 8f	 movzx	 eax, BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp]
  00414	85 c0		 test	 eax, eax
  00416	75 08		 jne	 SHORT $LN12@DragBehavi
  00418	0f b6 45 83	 movzx	 eax, BYTE PTR _is_drag_direction_change_with_power$[ebp]
  0041c	85 c0		 test	 eax, eax
  0041e	74 1a		 je	 SHORT $LN10@DragBehavi
$LN12@DragBehavi:

; 1963 :     {
; 1964 :         g.DragCurrentAccum = 0.0f;

  00420	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00423	0f 57 c0	 xorps	 xmm0, xmm0
  00426	f3 0f 11 80 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm0

; 1965 :         g.DragCurrentAccumDirty = false;

  0042e	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00431	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1966 :     }

  00438	eb 37		 jmp	 SHORT $LN13@DragBehavi
$LN10@DragBehavi:

; 1967 :     else if (adjust_delta != 0.0f)

  0043a	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0043f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00446	9f		 lahf
  00447	f6 c4 44	 test	 ah, 68			; 00000044H
  0044a	7b 25		 jnp	 SHORT $LN13@DragBehavi

; 1968 :     {
; 1969 :         g.DragCurrentAccum += adjust_delta;

  0044c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0044f	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  00457	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0045c	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0045f	f3 0f 11 81 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm0

; 1970 :         g.DragCurrentAccumDirty = true;

  00467	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0046a	c6 80 f8 2c 00
	00 01		 mov	 BYTE PTR [eax+11512], 1
$LN13@DragBehavi:

; 1971 :     }
; 1972 : 
; 1973 :     if (!g.DragCurrentAccumDirty)

  00471	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00474	0f b6 88 f8 2c
	00 00		 movzx	 ecx, BYTE PTR [eax+11512]
  0047b	85 c9		 test	 ecx, ecx
  0047d	75 07		 jne	 SHORT $LN14@DragBehavi

; 1974 :         return false;

  0047f	32 c0		 xor	 al, al
  00481	e9 e7 03 00 00	 jmp	 $LN1@DragBehavi
$LN14@DragBehavi:

; 1975 : 
; 1976 :     TYPE v_cur = *v;

  00486	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00489	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048b	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], ecx
  00491	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00494	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx

; 1977 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

  0049a	0f 57 c0	 xorps	 xmm0, xmm0
  0049d	f2 0f 11 85 60
	ff ff ff	 movsd	 QWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1978 : 
; 1979 :     if (is_power)

  004a5	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  004a9	85 c0		 test	 eax, eax
  004ab	0f 84 18 01 00
	00		 je	 $LN15@DragBehavi

; 1980 :     {
; 1981 :         // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 1982 :         FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  004b1	f3 0f 5a 45 28	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  004b6	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  004be	f2 0f 5e c8	 divsd	 xmm1, xmm0
  004c2	83 ec 08	 sub	 esp, 8
  004c5	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  004ca	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  004d0	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  004d3	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  004d9	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  004dc	e8 00 00 00 00	 call	 __ltod3
  004e1	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  004e4	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  004e7	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  004ea	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  004ed	f2 0f 11 85 54
	fe ff ff	 movsd	 QWORD PTR tv644[ebp], xmm0
  004f5	e8 00 00 00 00	 call	 __ltod3
  004fa	f2 0f 10 8d 54
	fe ff ff	 movsd	 xmm1, QWORD PTR tv644[ebp]
  00502	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00506	83 ec 08	 sub	 esp, 8
  00509	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0050e	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00513	83 c4 10	 add	 esp, 16			; 00000010H
  00516	dd 9d 50 ff ff
	ff		 fstp	 QWORD PTR _v_old_norm_curved$4[ebp]

; 1983 :         FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

  0051c	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0051f	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00522	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  00525	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  00528	e8 00 00 00 00	 call	 __ltod3
  0052d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00531	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00534	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  0053c	f3 0f 5e c8	 divss	 xmm1, xmm0
  00540	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00544	f2 0f 58 85 50
	ff ff ff	 addsd	 xmm0, QWORD PTR _v_old_norm_curved$4[ebp]
  0054c	f2 0f 11 85 40
	ff ff ff	 movsd	 QWORD PTR _v_new_norm_curved$3[ebp], xmm0

; 1984 :         v_cur = v_min + (SIGNEDTYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

  00554	51		 push	 ecx
  00555	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  0055a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055f	f2 0f 5a 85 40
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR _v_new_norm_curved$3[ebp]
  00567	51		 push	 ecx
  00568	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0056d	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00572	d9 1c 24	 fstp	 DWORD PTR [esp]
  00575	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  0057a	83 c4 08	 add	 esp, 8
  0057d	d9 9d 58 fe ff
	ff		 fstp	 DWORD PTR tv499[ebp]
  00583	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR tv499[ebp]
  0058b	e8 00 00 00 00	 call	 __ftol3
  00590	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00593	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00596	8b 75 20	 mov	 esi, DWORD PTR _v_max$[ebp+4]
  00599	1b 75 18	 sbb	 esi, DWORD PTR _v_min$[ebp+4]
  0059c	56		 push	 esi
  0059d	51		 push	 ecx
  0059e	52		 push	 edx
  0059f	50		 push	 eax
  005a0	e8 00 00 00 00	 call	 __allmul
  005a5	03 45 14	 add	 eax, DWORD PTR _v_min$[ebp]
  005a8	13 55 18	 adc	 edx, DWORD PTR _v_min$[ebp+4]
  005ab	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  005b1	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx

; 1985 :         v_old_ref_for_accum_remainder = v_old_norm_curved;

  005b7	f2 0f 10 85 50
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_old_norm_curved$4[ebp]
  005bf	f2 0f 11 85 60
	ff ff ff	 movsd	 QWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1986 :     }

  005c7	eb 28		 jmp	 SHORT $LN16@DragBehavi
$LN15@DragBehavi:

; 1987 :     else
; 1988 :     {
; 1989 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

  005c9	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005cc	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  005d4	e8 00 00 00 00	 call	 __ftol3
  005d9	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR _v_cur$[ebp]
  005df	13 95 74 ff ff
	ff		 adc	 edx, DWORD PTR _v_cur$[ebp+4]
  005e5	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  005eb	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx
$LN16@DragBehavi:

; 1990 :     }
; 1991 : 
; 1992 :     // Round to user desired precision based on format string
; 1993 :     v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

  005f1	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp+4]
  005f7	50		 push	 eax
  005f8	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  005fe	51		 push	 ecx
  005ff	8b 55 08	 mov	 edx, DWORD PTR _data_type$[ebp]
  00602	52		 push	 edx
  00603	8b 45 24	 mov	 eax, DWORD PTR _format$[ebp]
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@_J_J@ImGui@@YA_JPBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64,__int64>
  0060c	83 c4 10	 add	 esp, 16			; 00000010H
  0060f	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  00615	89 95 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], edx

; 1994 : 
; 1995 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 1996 :     g.DragCurrentAccumDirty = false;

  0061b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0061e	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1997 :     if (is_power)

  00625	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00629	85 c0		 test	 eax, eax
  0062b	0f 84 9b 00 00
	00		 je	 $LN17@DragBehavi

; 1998 :     {
; 1999 :         FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  00631	f3 0f 5a 45 28	 cvtss2sd xmm0, DWORD PTR _power$[ebp]
  00636	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0063e	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00642	83 ec 08	 sub	 esp, 8
  00645	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0064a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00650	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00653	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  00659	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0065c	e8 00 00 00 00	 call	 __ltod3
  00661	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  00664	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00667	8b 55 20	 mov	 edx, DWORD PTR _v_max$[ebp+4]
  0066a	1b 55 18	 sbb	 edx, DWORD PTR _v_min$[ebp+4]
  0066d	f2 0f 11 85 54
	fe ff ff	 movsd	 QWORD PTR tv646[ebp], xmm0
  00675	e8 00 00 00 00	 call	 __ltod3
  0067a	f2 0f 10 8d 54
	fe ff ff	 movsd	 xmm1, QWORD PTR tv646[ebp]
  00682	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00686	83 ec 08	 sub	 esp, 8
  00689	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  0068e	e8 00 00 00 00	 call	 ?ImPow@@YANNN@Z		; ImPow
  00693	83 c4 10	 add	 esp, 16			; 00000010H
  00696	dd 9d 30 ff ff
	ff		 fstp	 QWORD PTR _v_cur_norm_curved$2[ebp]

; 2000 :         g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

  0069c	f2 0f 10 85 30
	ff ff ff	 movsd	 xmm0, QWORD PTR _v_cur_norm_curved$2[ebp]
  006a4	f2 0f 5c 85 60
	ff ff ff	 subsd	 xmm0, QWORD PTR _v_old_ref_for_accum_remainder$[ebp]
  006ac	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006b0	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  006b3	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  006bb	f3 0f 5c c8	 subss	 xmm1, xmm0
  006bf	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  006c2	f3 0f 11 89 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm1

; 2001 :     }

  006ca	eb 37		 jmp	 SHORT $LN18@DragBehavi
$LN17@DragBehavi:

; 2002 :     else
; 2003 :     {
; 2004 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

  006cc	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  006cf	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  006d5	2b 08		 sub	 ecx, DWORD PTR [eax]
  006d7	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  006dd	1b 50 04	 sbb	 edx, DWORD PTR [eax+4]
  006e0	e8 00 00 00 00	 call	 __ltod3
  006e5	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006e9	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  006ec	f3 0f 10 89 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [ecx+11516]
  006f4	f3 0f 5c c8	 subss	 xmm1, xmm0
  006f8	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  006fb	f3 0f 11 8a fc
	2c 00 00	 movss	 DWORD PTR [edx+11516], xmm1
$LN18@DragBehavi:

; 2005 :     }
; 2006 : 
; 2007 :     // Lose zero sign for float/double
; 2008 :     if (v_cur == (TYPE)-0)

  00703	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00709	0b 85 74 ff ff
	ff		 or	 eax, DWORD PTR _v_cur$[ebp+4]
  0070f	75 0b		 jne	 SHORT $LN19@DragBehavi

; 2009 :         v_cur = (TYPE)0;

  00711	0f 57 c0	 xorps	 xmm0, xmm0
  00714	66 0f 13 85 70
	ff ff ff	 movlpd	 QWORD PTR _v_cur$[ebp], xmm0
$LN19@DragBehavi:

; 2010 : 
; 2011 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2012 :     if (*v != v_cur && is_clamped)

  0071c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0071f	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv595[ebp], eax
  00725	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv595[ebp]
  0072b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0072d	3b 95 70 ff ff
	ff		 cmp	 edx, DWORD PTR _v_cur$[ebp]
  00733	75 15		 jne	 SHORT $LN53@DragBehavi
  00735	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv595[ebp]
  0073b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0073e	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp+4]
  00744	0f 84 df 00 00
	00		 je	 $LN23@DragBehavi
$LN53@DragBehavi:
  0074a	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  0074e	85 c0		 test	 eax, eax
  00750	0f 84 d3 00 00
	00		 je	 $LN23@DragBehavi

; 2013 :     {
; 2014 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

  00756	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp+4]
  0075c	3b 45 18	 cmp	 eax, DWORD PTR _v_min$[ebp+4]
  0075f	7c 4a		 jl	 SHORT $LN22@DragBehavi
  00761	7f 0b		 jg	 SHORT $LN54@DragBehavi
  00763	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00769	3b 4d 14	 cmp	 ecx, DWORD PTR _v_min$[ebp]
  0076c	72 3d		 jb	 SHORT $LN22@DragBehavi
$LN54@DragBehavi:
  0076e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00771	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv606[ebp], eax
  00777	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv606[ebp]
  0077d	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  00783	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00786	7c 35		 jl	 SHORT $LN21@DragBehavi
  00788	7f 10		 jg	 SHORT $LN55@DragBehavi
  0078a	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv606[ebp]
  00790	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00796	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00798	76 23		 jbe	 SHORT $LN21@DragBehavi
$LN55@DragBehavi:
  0079a	0f 57 c0	 xorps	 xmm0, xmm0
  0079d	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  007a1	76 1a		 jbe	 SHORT $LN21@DragBehavi
  007a3	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  007a7	85 c0		 test	 eax, eax
  007a9	75 12		 jne	 SHORT $LN21@DragBehavi
$LN22@DragBehavi:

; 2015 :             v_cur = v_min;

  007ab	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  007ae	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  007b4	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp+4]
  007b7	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], ecx
$LN21@DragBehavi:

; 2016 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

  007bd	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp+4]
  007c3	3b 45 20	 cmp	 eax, DWORD PTR _v_max$[ebp+4]
  007c6	7f 4f		 jg	 SHORT $LN24@DragBehavi
  007c8	7c 0b		 jl	 SHORT $LN56@DragBehavi
  007ca	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  007d0	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  007d3	77 42		 ja	 SHORT $LN24@DragBehavi
$LN56@DragBehavi:
  007d5	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  007d8	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv621[ebp], eax
  007de	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv621[ebp]
  007e4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  007ea	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  007ed	7f 3a		 jg	 SHORT $LN23@DragBehavi
  007ef	7c 10		 jl	 SHORT $LN57@DragBehavi
  007f1	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv621[ebp]
  007f7	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  007fd	3b 08		 cmp	 ecx, DWORD PTR [eax]
  007ff	73 28		 jae	 SHORT $LN23@DragBehavi
$LN57@DragBehavi:
  00801	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00806	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0080d	76 1a		 jbe	 SHORT $LN23@DragBehavi
  0080f	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00813	85 c0		 test	 eax, eax
  00815	75 12		 jne	 SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2017 :             v_cur = v_max;

  00817	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  0081a	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
  00820	8b 4d 20	 mov	 ecx, DWORD PTR _v_max$[ebp+4]
  00823	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp+4], ecx
$LN23@DragBehavi:

; 2018 :     }
; 2019 : 
; 2020 :     // Apply result
; 2021 :     if (*v == v_cur)

  00829	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0082c	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv632[ebp], eax
  00832	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv632[ebp]
  00838	8b 11		 mov	 edx, DWORD PTR [ecx]
  0083a	3b 95 70 ff ff
	ff		 cmp	 edx, DWORD PTR _v_cur$[ebp]
  00840	75 15		 jne	 SHORT $LN25@DragBehavi
  00842	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv632[ebp]
  00848	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0084b	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp+4]
  00851	75 04		 jne	 SHORT $LN25@DragBehavi

; 2022 :         return false;

  00853	32 c0		 xor	 al, al
  00855	eb 16		 jmp	 SHORT $LN1@DragBehavi
$LN25@DragBehavi:

; 2023 :     *v = v_cur;

  00857	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0085a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00860	89 08		 mov	 DWORD PTR [eax], ecx
  00862	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _v_cur$[ebp+4]
  00868	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2024 :     return true;

  0086b	b0 01		 mov	 al, 1
$LN1@DragBehavi:

; 2025 : }

  0086d	5f		 pop	 edi
  0086e	5e		 pop	 esi
  0086f	5b		 pop	 ebx
  00870	81 c4 b0 01 00
	00		 add	 esp, 432		; 000001b0H
  00876	3b ec		 cmp	 ebp, esp
  00878	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0087d	8b e5		 mov	 esp, ebp
  0087f	5d		 pop	 ebp
  00880	c3		 ret	 0
??$DragBehaviorT@_J_JN@ImGui@@YA_NHPA_JM_J1PBDMH@Z ENDP	; ImGui::DragBehaviorT<__int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@IHM@ImGui@@YA_NHPAIMIIPBDMH@Z
_TEXT	SEGMENT
tv501 = -424						; size = 8
tv446 = -424						; size = 8
tv498 = -416						; size = 4
tv443 = -416						; size = 4
tv80 = -413						; size = 1
tv492 = -412						; size = 8
tv459 = -412						; size = 8
tv437 = -412						; size = 8
tv357 = -412						; size = 8
tv347 = -412						; size = 8
tv330 = -412						; size = 8
tv489 = -404						; size = 4
tv477 = -404						; size = 4
tv456 = -404						; size = 4
tv434 = -404						; size = 4
tv354 = -404						; size = 4
tv344 = -404						; size = 4
tv327 = -404						; size = 4
tv196 = -404						; size = 4
tv186 = -404						; size = 4
tv161 = -404						; size = 4
tv66 = -404						; size = 4
tv82 = -401						; size = 1
tv71 = -401						; size = 1
tv69 = -401						; size = 1
$T1 = -396						; size = 8
_v_cur_norm_curved$2 = -188				; size = 4
_v_new_norm_curved$3 = -176				; size = 4
_v_old_norm_curved$4 = -164				; size = 4
_v_old_ref_for_accum_remainder$ = -152			; size = 4
_v_cur$ = -140						; size = 4
_is_drag_direction_change_with_power$ = -125		; size = 1
_is_already_past_limits_and_pushing_outward$ = -113	; size = 1
_is_just_activated$ = -101				; size = 1
_decimal_precision$5 = -92				; size = 4
_adjust_delta$ = -80					; size = 4
_is_locked$ = -65					; size = 1
_is_power$ = -53					; size = 1
_is_clamped$ = -41					; size = 1
_is_decimal$ = -29					; size = 1
_axis$ = -20						; size = 4
_g$ = -8						; size = 4
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
_flags$ = 36						; size = 4
??$DragBehaviorT@IHM@ImGui@@YA_NHPAIMIIPBDMH@Z PROC	; ImGui::DragBehaviorT<unsigned int,int,float>, COMDAT

; 1921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 58 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-424]
  00012	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1922 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1923 :     const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00030	8b 45 24	 mov	 eax, DWORD PTR _flags$[ebp]
  00033	83 e0 01	 and	 eax, 1
  00036	74 0c		 je	 SHORT $LN27@DragBehavi
  00038	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00042	eb 0a		 jmp	 SHORT $LN28@DragBehavi
$LN27@DragBehavi:
  00044	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN28@DragBehavi:
  0004e	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00054	89 4d ec	 mov	 DWORD PTR _axis$[ebp], ecx

; 1924 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  00057	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0005b	74 0f		 je	 SHORT $LN29@DragBehavi
  0005d	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00061	74 09		 je	 SHORT $LN29@DragBehavi
  00063	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv69[ebp], 0
  0006a	eb 07		 jmp	 SHORT $LN30@DragBehavi
$LN29@DragBehavi:
  0006c	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv69[ebp], 1
$LN30@DragBehavi:
  00073	8a 85 6f fe ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00079	88 45 e3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 1925 :     const bool is_clamped = (v_min < v_max);

  0007c	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  0007f	3b 45 18	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00082	73 09		 jae	 SHORT $LN31@DragBehavi
  00084	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv71[ebp], 1
  0008b	eb 07		 jmp	 SHORT $LN32@DragBehavi
$LN31@DragBehavi:
  0008d	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv71[ebp], 0
$LN32@DragBehavi:
  00094	8a 8d 6f fe ff
	ff		 mov	 cl, BYTE PTR tv71[ebp]
  0009a	88 4d d7	 mov	 BYTE PTR _is_clamped$[ebp], cl

; 1926 :     const bool is_power = (power != 1.0f && is_decimal && is_clamped && (v_max - v_min < FLT_MAX));

  0009d	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  000a2	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  000a9	9f		 lahf
  000aa	f6 c4 44	 test	 ah, 68			; 00000044H
  000ad	7b 5c		 jnp	 SHORT $LN33@DragBehavi
  000af	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000b3	85 c0		 test	 eax, eax
  000b5	74 54		 je	 SHORT $LN33@DragBehavi
  000b7	0f b6 4d d7	 movzx	 ecx, BYTE PTR _is_clamped$[ebp]
  000bb	85 c9		 test	 ecx, ecx
  000bd	74 4c		 je	 SHORT $LN33@DragBehavi
  000bf	8b 55 18	 mov	 edx, DWORD PTR _v_max$[ebp]
  000c2	2b 55 14	 sub	 edx, DWORD PTR _v_min$[ebp]
  000c5	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv327[ebp], edx
  000cb	f2 0f 2a 85 6c
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv327[ebp]
  000d3	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv327[ebp]
  000d9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000dc	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000e5	f2 0f 11 85 64
	fe ff ff	 movsd	 QWORD PTR tv330[ebp], xmm0
  000ed	f2 0f 5a 85 64
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv330[ebp]
  000f5	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  000fd	0f 2f c8	 comiss	 xmm1, xmm0
  00100	76 09		 jbe	 SHORT $LN33@DragBehavi
  00102	c6 85 63 fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
  00109	eb 07		 jmp	 SHORT $LN34@DragBehavi
$LN33@DragBehavi:
  0010b	c6 85 63 fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
$LN34@DragBehavi:
  00112	8a 8d 63 fe ff
	ff		 mov	 cl, BYTE PTR tv80[ebp]
  00118	88 4d cb	 mov	 BYTE PTR _is_power$[ebp], cl

; 1927 :     const bool is_locked = (v_min > v_max);

  0011b	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  0011e	3b 45 18	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00121	76 09		 jbe	 SHORT $LN35@DragBehavi
  00123	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv82[ebp], 1
  0012a	eb 07		 jmp	 SHORT $LN36@DragBehavi
$LN35@DragBehavi:
  0012c	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv82[ebp], 0
$LN36@DragBehavi:
  00133	8a 8d 6f fe ff
	ff		 mov	 cl, BYTE PTR tv82[ebp]
  00139	88 4d bf	 mov	 BYTE PTR _is_locked$[ebp], cl

; 1928 :     if (is_locked)

  0013c	0f b6 45 bf	 movzx	 eax, BYTE PTR _is_locked$[ebp]
  00140	85 c0		 test	 eax, eax
  00142	74 07		 je	 SHORT $LN2@DragBehavi

; 1929 :         return false;

  00144	32 c0		 xor	 al, al
  00146	e9 b2 06 00 00	 jmp	 $LN1@DragBehavi
$LN2@DragBehavi:

; 1930 : 
; 1931 :     // Default tweak speed
; 1932 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

  0014b	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00150	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00157	9f		 lahf
  00158	f6 c4 44	 test	 ah, 68			; 00000044H
  0015b	0f 8a 95 00 00
	00		 jp	 $LN3@DragBehavi
  00161	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00165	85 c0		 test	 eax, eax
  00167	0f 84 89 00 00
	00		 je	 $LN3@DragBehavi
  0016d	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  00170	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  00173	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv344[ebp], eax
  00179	f2 0f 2a 85 6c
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv344[ebp]
  00181	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv344[ebp]
  00187	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0018a	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00193	f2 0f 11 85 64
	fe ff ff	 movsd	 QWORD PTR tv347[ebp], xmm0
  0019b	f2 0f 5a 85 64
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv347[ebp]
  001a3	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  001ab	0f 2f c8	 comiss	 xmm1, xmm0
  001ae	76 46		 jbe	 SHORT $LN3@DragBehavi

; 1933 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

  001b0	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  001b3	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  001b6	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv354[ebp], eax
  001bc	f2 0f 2a 85 6c
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv354[ebp]
  001c4	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv354[ebp]
  001ca	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001cd	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  001d6	f2 0f 11 85 64
	fe ff ff	 movsd	 QWORD PTR tv357[ebp], xmm0
  001de	f2 0f 5a 85 64
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv357[ebp]
  001e6	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  001e9	f3 0f 59 82 00
	2d 00 00	 mulss	 xmm0, DWORD PTR [edx+11520]
  001f1	f3 0f 11 45 10	 movss	 DWORD PTR _v_speed$[ebp], xmm0
$LN3@DragBehavi:

; 1934 : 
; 1935 :     // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 1936 :     float adjust_delta = 0.0f;

  001f6	0f 57 c0	 xorps	 xmm0, xmm0
  001f9	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1937 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)

  001fe	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00201	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  00208	0f 85 8e 00 00
	00		 jne	 $LN4@DragBehavi
  0020e	6a 00		 push	 0
  00210	e8 00 00 00 00	 call	 ?IsMousePosValid@ImGui@@YA_NPBUImVec2@@@Z ; ImGui::IsMousePosValid
  00215	83 c4 04	 add	 esp, 4
  00218	0f b6 c0	 movzx	 eax, al
  0021b	85 c0		 test	 eax, eax
  0021d	74 7d		 je	 SHORT $LN4@DragBehavi
  0021f	b8 04 00 00 00	 mov	 eax, 4
  00224	6b c8 00	 imul	 ecx, eax, 0
  00227	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  0022a	f3 0f 10 84 0a
	44 04 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1092]
  00233	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0023a	76 60		 jbe	 SHORT $LN4@DragBehavi

; 1938 :     {
; 1939 :         adjust_delta = g.IO.MouseDelta[axis];

  0023c	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  0023f	50		 push	 eax
  00240	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00243	81 c1 78 03 00
	00		 add	 ecx, 888		; 00000378H
  00249	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  0024e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00252	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1940 :         if (g.IO.KeyAlt)

  00257	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0025a	0f b6 88 02 01
	00 00		 movzx	 ecx, BYTE PTR [eax+258]
  00261	85 c9		 test	 ecx, ecx
  00263	74 12		 je	 SHORT $LN6@DragBehavi

; 1941 :             adjust_delta *= 1.0f / 100.0f;

  00265	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0026a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  00272	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN6@DragBehavi:

; 1942 :         if (g.IO.KeyShift)

  00277	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0027a	0f b6 88 01 01
	00 00		 movzx	 ecx, BYTE PTR [eax+257]
  00281	85 c9		 test	 ecx, ecx
  00283	74 12		 je	 SHORT $LN7@DragBehavi

; 1943 :             adjust_delta *= 10.0f;

  00285	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0028a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00292	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN7@DragBehavi:

; 1944 :     }

  00297	e9 a6 00 00 00	 jmp	 $LN8@DragBehavi
$LN4@DragBehavi:

; 1945 :     else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  0029c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0029f	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  002a6	0f 85 96 00 00
	00		 jne	 $LN8@DragBehavi

; 1946 :     {
; 1947 :         int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  002ac	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  002b0	85 c0		 test	 eax, eax
  002b2	74 16		 je	 SHORT $LN37@DragBehavi
  002b4	6a 03		 push	 3
  002b6	8b 4d 1c	 mov	 ecx, DWORD PTR _format$[ebp]
  002b9	51		 push	 ecx
  002ba	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  002bf	83 c4 08	 add	 esp, 8
  002c2	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv161[ebp], eax
  002c8	eb 0a		 jmp	 SHORT $LN38@DragBehavi
$LN37@DragBehavi:
  002ca	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN38@DragBehavi:
  002d4	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  002da	89 55 a4	 mov	 DWORD PTR _decimal_precision$5[ebp], edx

; 1948 :         adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

  002dd	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  002e0	50		 push	 eax
  002e1	51		 push	 ecx
  002e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  002ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ef	51		 push	 ecx
  002f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  002f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fd	6a 05		 push	 5
  002ff	6a 03		 push	 3
  00301	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00307	51		 push	 ecx
  00308	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  0030d	83 c4 14	 add	 esp, 20			; 00000014H
  00310	8b c8		 mov	 ecx, eax
  00312	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  00317	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0031b	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1949 :         v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

  00320	8b 45 a4	 mov	 eax, DWORD PTR _decimal_precision$5[ebp]
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 ?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
  00329	d9 1c 24	 fstp	 DWORD PTR [esp]
  0032c	51		 push	 ecx
  0032d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00332	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00337	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0033c	83 c4 08	 add	 esp, 8
  0033f	d9 5d 10	 fstp	 DWORD PTR _v_speed$[ebp]
$LN8@DragBehavi:

; 1950 :     }
; 1951 :     adjust_delta *= v_speed;

  00342	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00347	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _v_speed$[ebp]
  0034c	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1952 : 
; 1953 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 1954 :     if (axis == ImGuiAxis_Y)

  00351	83 7d ec 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00355	75 11		 jne	 SHORT $LN9@DragBehavi

; 1955 :         adjust_delta = -adjust_delta;

  00357	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0035c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00363	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN9@DragBehavi:

; 1956 : 
; 1957 :     // Clear current value on activation
; 1958 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 1959 :     bool is_just_activated = g.ActiveIdIsJustActivated;

  00368	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0036b	8a 88 f0 19 00
	00		 mov	 cl, BYTE PTR [eax+6640]
  00371	88 4d 9b	 mov	 BYTE PTR _is_just_activated$[ebp], cl

; 1960 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

  00374	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00378	85 c0		 test	 eax, eax
  0037a	74 37		 je	 SHORT $LN42@DragBehavi
  0037c	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0037f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00381	3b 55 18	 cmp	 edx, DWORD PTR _v_max$[ebp]
  00384	72 0e		 jb	 SHORT $LN39@DragBehavi
  00386	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0038b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00392	77 13		 ja	 SHORT $LN41@DragBehavi
$LN39@DragBehavi:
  00394	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00397	8b 08		 mov	 ecx, DWORD PTR [eax]
  00399	3b 4d 14	 cmp	 ecx, DWORD PTR _v_min$[ebp]
  0039c	77 15		 ja	 SHORT $LN42@DragBehavi
  0039e	0f 57 c0	 xorps	 xmm0, xmm0
  003a1	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003a5	76 0c		 jbe	 SHORT $LN42@DragBehavi
$LN41@DragBehavi:
  003a7	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv186[ebp], 1
  003b1	eb 0a		 jmp	 SHORT $LN43@DragBehavi
$LN42@DragBehavi:
  003b3	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv186[ebp], 0
$LN43@DragBehavi:
  003bd	8a 95 6c fe ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  003c3	88 55 8f	 mov	 BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp], dl

; 1961 :     bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

  003c6	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  003ca	85 c0		 test	 eax, eax
  003cc	74 46		 je	 SHORT $LN47@DragBehavi
  003ce	0f 57 c0	 xorps	 xmm0, xmm0
  003d1	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003d5	76 14		 jbe	 SHORT $LN44@DragBehavi
  003d7	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  003da	f3 0f 10 81 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [ecx+11516]
  003e2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003e9	77 1d		 ja	 SHORT $LN46@DragBehavi
$LN44@DragBehavi:
  003eb	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003f0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003f7	76 1b		 jbe	 SHORT $LN47@DragBehavi
  003f9	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  003fc	0f 57 c0	 xorps	 xmm0, xmm0
  003ff	0f 2f 82 fc 2c
	00 00		 comiss	 xmm0, DWORD PTR [edx+11516]
  00406	76 0c		 jbe	 SHORT $LN47@DragBehavi
$LN46@DragBehavi:
  00408	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv196[ebp], 1
  00412	eb 0a		 jmp	 SHORT $LN48@DragBehavi
$LN47@DragBehavi:
  00414	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
$LN48@DragBehavi:
  0041e	8a 85 6c fe ff
	ff		 mov	 al, BYTE PTR tv196[ebp]
  00424	88 45 83	 mov	 BYTE PTR _is_drag_direction_change_with_power$[ebp], al

; 1962 :     if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

  00427	0f b6 45 9b	 movzx	 eax, BYTE PTR _is_just_activated$[ebp]
  0042b	85 c0		 test	 eax, eax
  0042d	75 10		 jne	 SHORT $LN12@DragBehavi
  0042f	0f b6 45 8f	 movzx	 eax, BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp]
  00433	85 c0		 test	 eax, eax
  00435	75 08		 jne	 SHORT $LN12@DragBehavi
  00437	0f b6 45 83	 movzx	 eax, BYTE PTR _is_drag_direction_change_with_power$[ebp]
  0043b	85 c0		 test	 eax, eax
  0043d	74 1a		 je	 SHORT $LN10@DragBehavi
$LN12@DragBehavi:

; 1963 :     {
; 1964 :         g.DragCurrentAccum = 0.0f;

  0043f	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00442	0f 57 c0	 xorps	 xmm0, xmm0
  00445	f3 0f 11 80 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm0

; 1965 :         g.DragCurrentAccumDirty = false;

  0044d	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00450	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1966 :     }

  00457	eb 37		 jmp	 SHORT $LN13@DragBehavi
$LN10@DragBehavi:

; 1967 :     else if (adjust_delta != 0.0f)

  00459	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0045e	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00465	9f		 lahf
  00466	f6 c4 44	 test	 ah, 68			; 00000044H
  00469	7b 25		 jnp	 SHORT $LN13@DragBehavi

; 1968 :     {
; 1969 :         g.DragCurrentAccum += adjust_delta;

  0046b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0046e	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  00476	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  0047b	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0047e	f3 0f 11 81 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm0

; 1970 :         g.DragCurrentAccumDirty = true;

  00486	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00489	c6 80 f8 2c 00
	00 01		 mov	 BYTE PTR [eax+11512], 1
$LN13@DragBehavi:

; 1971 :     }
; 1972 : 
; 1973 :     if (!g.DragCurrentAccumDirty)

  00490	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00493	0f b6 88 f8 2c
	00 00		 movzx	 ecx, BYTE PTR [eax+11512]
  0049a	85 c9		 test	 ecx, ecx
  0049c	75 07		 jne	 SHORT $LN14@DragBehavi

; 1974 :         return false;

  0049e	32 c0		 xor	 al, al
  004a0	e9 58 03 00 00	 jmp	 $LN1@DragBehavi
$LN14@DragBehavi:

; 1975 : 
; 1976 :     TYPE v_cur = *v;

  004a5	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  004a8	8b 08		 mov	 ecx, DWORD PTR [eax]
  004aa	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], ecx

; 1977 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

  004b0	0f 57 c0	 xorps	 xmm0, xmm0
  004b3	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1978 : 
; 1979 :     if (is_power)

  004bb	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  004bf	85 c0		 test	 eax, eax
  004c1	0f 84 4e 01 00
	00		 je	 $LN15@DragBehavi

; 1980 :     {
; 1981 :         // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 1982 :         FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  004c7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004cf	f3 0f 5e 45 20	 divss	 xmm0, DWORD PTR _power$[ebp]
  004d4	51		 push	 ecx
  004d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004da	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  004e0	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  004e3	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv434[ebp], eax
  004e9	f2 0f 2a 85 6c
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv434[ebp]
  004f1	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv434[ebp]
  004f7	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  004fa	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00503	f2 0f 11 85 64
	fe ff ff	 movsd	 QWORD PTR tv437[ebp], xmm0
  0050b	f2 0f 5a 85 64
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv437[ebp]
  00513	8b 55 18	 mov	 edx, DWORD PTR _v_max$[ebp]
  00516	2b 55 14	 sub	 edx, DWORD PTR _v_min$[ebp]
  00519	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv443[ebp], edx
  0051f	f2 0f 2a 8d 60
	fe ff ff	 cvtsi2sd xmm1, DWORD PTR tv443[ebp]
  00527	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv443[ebp]
  0052d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00530	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00539	f2 0f 11 8d 58
	fe ff ff	 movsd	 QWORD PTR tv446[ebp], xmm1
  00541	f2 0f 5a 8d 58
	fe ff ff	 cvtsd2ss xmm1, QWORD PTR tv446[ebp]
  00549	f3 0f 5e c1	 divss	 xmm0, xmm1
  0054d	51		 push	 ecx
  0054e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00553	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00558	83 c4 08	 add	 esp, 8
  0055b	d9 9d 5c ff ff
	ff		 fstp	 DWORD PTR _v_old_norm_curved$4[ebp]

; 1983 :         FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

  00561	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  00564	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  00567	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv456[ebp], eax
  0056d	f2 0f 2a 85 6c
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv456[ebp]
  00575	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv456[ebp]
  0057b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0057e	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00587	f2 0f 11 85 64
	fe ff ff	 movsd	 QWORD PTR tv459[ebp], xmm0
  0058f	f2 0f 5a 85 64
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv459[ebp]
  00597	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  0059a	f3 0f 10 8a fc
	2c 00 00	 movss	 xmm1, DWORD PTR [edx+11516]
  005a2	f3 0f 5e c8	 divss	 xmm1, xmm0
  005a6	f3 0f 58 8d 5c
	ff ff ff	 addss	 xmm1, DWORD PTR _v_old_norm_curved$4[ebp]
  005ae	f3 0f 11 8d 50
	ff ff ff	 movss	 DWORD PTR _v_new_norm_curved$3[ebp], xmm1

; 1984 :         v_cur = v_min + (SIGNEDTYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

  005b6	51		 push	 ecx
  005b7	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  005bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c1	51		 push	 ecx
  005c2	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _v_new_norm_curved$3[ebp]
  005ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005cf	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  005d4	d9 1c 24	 fstp	 DWORD PTR [esp]
  005d7	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  005dc	83 c4 08	 add	 esp, 8
  005df	d9 9d 6c fe ff
	ff		 fstp	 DWORD PTR tv477[ebp]
  005e5	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR tv477[ebp]
  005ed	f3 0f 2c c0	 cvttss2si eax, xmm0
  005f1	8b 4d 18	 mov	 ecx, DWORD PTR _v_max$[ebp]
  005f4	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  005f7	0f af c1	 imul	 eax, ecx
  005fa	03 45 14	 add	 eax, DWORD PTR _v_min$[ebp]
  005fd	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax

; 1985 :         v_old_ref_for_accum_remainder = v_old_norm_curved;

  00603	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _v_old_norm_curved$4[ebp]
  0060b	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1986 :     }

  00613	eb 17		 jmp	 SHORT $LN16@DragBehavi
$LN15@DragBehavi:

; 1987 :     else
; 1988 :     {
; 1989 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

  00615	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00618	f3 0f 2c 88 fc
	2c 00 00	 cvttss2si ecx, DWORD PTR [eax+11516]
  00620	03 8d 74 ff ff
	ff		 add	 ecx, DWORD PTR _v_cur$[ebp]
  00626	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], ecx
$LN16@DragBehavi:

; 1990 :     }
; 1991 : 
; 1992 :     // Round to user desired precision based on format string
; 1993 :     v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

  0062c	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00632	50		 push	 eax
  00633	8b 4d 08	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00636	51		 push	 ecx
  00637	8b 55 1c	 mov	 edx, DWORD PTR _format$[ebp]
  0063a	52		 push	 edx
  0063b	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@IH@ImGui@@YAIPBDHI@Z ; ImGui::RoundScalarWithFormatT<unsigned int,int>
  00640	83 c4 0c	 add	 esp, 12			; 0000000cH
  00643	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax

; 1994 : 
; 1995 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 1996 :     g.DragCurrentAccumDirty = false;

  00649	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0064c	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1997 :     if (is_power)

  00653	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00657	85 c0		 test	 eax, eax
  00659	0f 84 c6 00 00
	00		 je	 $LN17@DragBehavi

; 1998 :     {
; 1999 :         FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  0065f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00667	f3 0f 5e 45 20	 divss	 xmm0, DWORD PTR _power$[ebp]
  0066c	51		 push	 ecx
  0066d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00672	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00678	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  0067b	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv489[ebp], eax
  00681	f2 0f 2a 85 6c
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv489[ebp]
  00689	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv489[ebp]
  0068f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00692	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  0069b	f2 0f 11 85 64
	fe ff ff	 movsd	 QWORD PTR tv492[ebp], xmm0
  006a3	f2 0f 5a 85 64
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv492[ebp]
  006ab	8b 55 18	 mov	 edx, DWORD PTR _v_max$[ebp]
  006ae	2b 55 14	 sub	 edx, DWORD PTR _v_min$[ebp]
  006b1	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv498[ebp], edx
  006b7	f2 0f 2a 8d 60
	fe ff ff	 cvtsi2sd xmm1, DWORD PTR tv498[ebp]
  006bf	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv498[ebp]
  006c5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  006c8	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  006d1	f2 0f 11 8d 58
	fe ff ff	 movsd	 QWORD PTR tv501[ebp], xmm1
  006d9	f2 0f 5a 8d 58
	fe ff ff	 cvtsd2ss xmm1, QWORD PTR tv501[ebp]
  006e1	f3 0f 5e c1	 divss	 xmm0, xmm1
  006e5	51		 push	 ecx
  006e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006eb	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  006f0	83 c4 08	 add	 esp, 8
  006f3	d9 9d 44 ff ff
	ff		 fstp	 DWORD PTR _v_cur_norm_curved$2[ebp]

; 2000 :         g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

  006f9	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur_norm_curved$2[ebp]
  00701	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _v_old_ref_for_accum_remainder$[ebp]
  00709	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0070c	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  00714	f3 0f 5c c8	 subss	 xmm1, xmm0
  00718	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0071b	f3 0f 11 89 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm1

; 2001 :     }

  00723	eb 29		 jmp	 SHORT $LN18@DragBehavi
$LN17@DragBehavi:

; 2002 :     else
; 2003 :     {
; 2004 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

  00725	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00728	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  0072e	2b 08		 sub	 ecx, DWORD PTR [eax]
  00730	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00734	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00737	f3 0f 10 8a fc
	2c 00 00	 movss	 xmm1, DWORD PTR [edx+11516]
  0073f	f3 0f 5c c8	 subss	 xmm1, xmm0
  00743	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00746	f3 0f 11 88 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm1
$LN18@DragBehavi:

; 2005 :     }
; 2006 : 
; 2007 :     // Lose zero sign for float/double
; 2008 :     if (v_cur == (TYPE)-0)

  0074e	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _v_cur$[ebp], 0
  00755	75 0a		 jne	 SHORT $LN19@DragBehavi

; 2009 :         v_cur = (TYPE)0;

  00757	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _v_cur$[ebp], 0
$LN19@DragBehavi:

; 2010 : 
; 2011 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2012 :     if (*v != v_cur && is_clamped)

  00761	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00764	8b 08		 mov	 ecx, DWORD PTR [eax]
  00766	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp]
  0076c	74 71		 je	 SHORT $LN23@DragBehavi
  0076e	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00772	85 c0		 test	 eax, eax
  00774	74 69		 je	 SHORT $LN23@DragBehavi

; 2013 :     {
; 2014 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

  00776	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  0077c	3b 45 14	 cmp	 eax, DWORD PTR _v_min$[ebp]
  0077f	72 1e		 jb	 SHORT $LN22@DragBehavi
  00781	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00784	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  0078a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0078c	76 1a		 jbe	 SHORT $LN21@DragBehavi
  0078e	0f 57 c0	 xorps	 xmm0, xmm0
  00791	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00795	76 11		 jbe	 SHORT $LN21@DragBehavi
  00797	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0079b	85 c0		 test	 eax, eax
  0079d	75 09		 jne	 SHORT $LN21@DragBehavi
$LN22@DragBehavi:

; 2015 :             v_cur = v_min;

  0079f	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  007a2	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
$LN21@DragBehavi:

; 2016 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

  007a8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  007ae	3b 45 18	 cmp	 eax, DWORD PTR _v_max$[ebp]
  007b1	77 23		 ja	 SHORT $LN24@DragBehavi
  007b3	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  007b6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  007bc	3b 08		 cmp	 ecx, DWORD PTR [eax]
  007be	73 1f		 jae	 SHORT $LN23@DragBehavi
  007c0	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  007c5	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  007cc	76 11		 jbe	 SHORT $LN23@DragBehavi
  007ce	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  007d2	85 c0		 test	 eax, eax
  007d4	75 09		 jne	 SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2017 :             v_cur = v_max;

  007d6	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  007d9	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
$LN23@DragBehavi:

; 2018 :     }
; 2019 : 
; 2020 :     // Apply result
; 2021 :     if (*v == v_cur)

  007df	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  007e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  007e4	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp]
  007ea	75 04		 jne	 SHORT $LN25@DragBehavi

; 2022 :         return false;

  007ec	32 c0		 xor	 al, al
  007ee	eb 0d		 jmp	 SHORT $LN1@DragBehavi
$LN25@DragBehavi:

; 2023 :     *v = v_cur;

  007f0	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  007f3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  007f9	89 08		 mov	 DWORD PTR [eax], ecx

; 2024 :     return true;

  007fb	b0 01		 mov	 al, 1
$LN1@DragBehavi:

; 2025 : }

  007fd	5f		 pop	 edi
  007fe	5e		 pop	 esi
  007ff	5b		 pop	 ebx
  00800	81 c4 a8 01 00
	00		 add	 esp, 424		; 000001a8H
  00806	3b ec		 cmp	 ebp, esp
  00808	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0080d	8b e5		 mov	 esp, ebp
  0080f	5d		 pop	 ebp
  00810	c3		 ret	 0
??$DragBehaviorT@IHM@ImGui@@YA_NHPAIMIIPBDMH@Z ENDP	; ImGui::DragBehaviorT<unsigned int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@HHM@ImGui@@YA_NHPAHMHHPBDMH@Z
_TEXT	SEGMENT
tv429 = -404						; size = 4
tv196 = -404						; size = 4
tv186 = -404						; size = 4
tv161 = -404						; size = 4
tv66 = -404						; size = 4
tv82 = -401						; size = 1
tv80 = -401						; size = 1
tv71 = -401						; size = 1
tv69 = -401						; size = 1
$T1 = -396						; size = 8
_v_cur_norm_curved$2 = -188				; size = 4
_v_new_norm_curved$3 = -176				; size = 4
_v_old_norm_curved$4 = -164				; size = 4
_v_old_ref_for_accum_remainder$ = -152			; size = 4
_v_cur$ = -140						; size = 4
_is_drag_direction_change_with_power$ = -125		; size = 1
_is_already_past_limits_and_pushing_outward$ = -113	; size = 1
_is_just_activated$ = -101				; size = 1
_decimal_precision$5 = -92				; size = 4
_adjust_delta$ = -80					; size = 4
_is_locked$ = -65					; size = 1
_is_power$ = -53					; size = 1
_is_clamped$ = -41					; size = 1
_is_decimal$ = -29					; size = 1
_axis$ = -20						; size = 4
_g$ = -8						; size = 4
_data_type$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
_flags$ = 36						; size = 4
??$DragBehaviorT@HHM@ImGui@@YA_NHPAHMHHPBDMH@Z PROC	; ImGui::DragBehaviorT<int,int,float>, COMDAT

; 1921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00012	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1922 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1923 :     const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;

  00030	8b 45 24	 mov	 eax, DWORD PTR _flags$[ebp]
  00033	83 e0 01	 and	 eax, 1
  00036	74 0c		 je	 SHORT $LN27@DragBehavi
  00038	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00042	eb 0a		 jmp	 SHORT $LN28@DragBehavi
$LN27@DragBehavi:
  00044	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN28@DragBehavi:
  0004e	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00054	89 4d ec	 mov	 DWORD PTR _axis$[ebp], ecx

; 1924 :     const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

  00057	83 7d 08 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  0005b	74 0f		 je	 SHORT $LN29@DragBehavi
  0005d	83 7d 08 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  00061	74 09		 je	 SHORT $LN29@DragBehavi
  00063	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv69[ebp], 0
  0006a	eb 07		 jmp	 SHORT $LN30@DragBehavi
$LN29@DragBehavi:
  0006c	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv69[ebp], 1
$LN30@DragBehavi:
  00073	8a 85 6f fe ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00079	88 45 e3	 mov	 BYTE PTR _is_decimal$[ebp], al

; 1925 :     const bool is_clamped = (v_min < v_max);

  0007c	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  0007f	3b 45 18	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00082	7d 09		 jge	 SHORT $LN31@DragBehavi
  00084	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv71[ebp], 1
  0008b	eb 07		 jmp	 SHORT $LN32@DragBehavi
$LN31@DragBehavi:
  0008d	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv71[ebp], 0
$LN32@DragBehavi:
  00094	8a 8d 6f fe ff
	ff		 mov	 cl, BYTE PTR tv71[ebp]
  0009a	88 4d d7	 mov	 BYTE PTR _is_clamped$[ebp], cl

; 1926 :     const bool is_power = (power != 1.0f && is_decimal && is_clamped && (v_max - v_min < FLT_MAX));

  0009d	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  000a2	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  000a9	9f		 lahf
  000aa	f6 c4 44	 test	 ah, 68			; 00000044H
  000ad	7b 30		 jnp	 SHORT $LN33@DragBehavi
  000af	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  000b3	85 c0		 test	 eax, eax
  000b5	74 28		 je	 SHORT $LN33@DragBehavi
  000b7	0f b6 4d d7	 movzx	 ecx, BYTE PTR _is_clamped$[ebp]
  000bb	85 c9		 test	 ecx, ecx
  000bd	74 20		 je	 SHORT $LN33@DragBehavi
  000bf	8b 55 18	 mov	 edx, DWORD PTR _v_max$[ebp]
  000c2	2b 55 14	 sub	 edx, DWORD PTR _v_min$[ebp]
  000c5	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000c9	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  000d1	0f 2f c8	 comiss	 xmm1, xmm0
  000d4	76 09		 jbe	 SHORT $LN33@DragBehavi
  000d6	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
  000dd	eb 07		 jmp	 SHORT $LN34@DragBehavi
$LN33@DragBehavi:
  000df	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
$LN34@DragBehavi:
  000e6	8a 85 6f fe ff
	ff		 mov	 al, BYTE PTR tv80[ebp]
  000ec	88 45 cb	 mov	 BYTE PTR _is_power$[ebp], al

; 1927 :     const bool is_locked = (v_min > v_max);

  000ef	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  000f2	3b 45 18	 cmp	 eax, DWORD PTR _v_max$[ebp]
  000f5	7e 09		 jle	 SHORT $LN35@DragBehavi
  000f7	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR tv82[ebp], 1
  000fe	eb 07		 jmp	 SHORT $LN36@DragBehavi
$LN35@DragBehavi:
  00100	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR tv82[ebp], 0
$LN36@DragBehavi:
  00107	8a 8d 6f fe ff
	ff		 mov	 cl, BYTE PTR tv82[ebp]
  0010d	88 4d bf	 mov	 BYTE PTR _is_locked$[ebp], cl

; 1928 :     if (is_locked)

  00110	0f b6 45 bf	 movzx	 eax, BYTE PTR _is_locked$[ebp]
  00114	85 c0		 test	 eax, eax
  00116	74 07		 je	 SHORT $LN2@DragBehavi

; 1929 :         return false;

  00118	32 c0		 xor	 al, al
  0011a	e9 72 05 00 00	 jmp	 $LN1@DragBehavi
$LN2@DragBehavi:

; 1930 : 
; 1931 :     // Default tweak speed
; 1932 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

  0011f	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00124	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0012b	9f		 lahf
  0012c	f6 c4 44	 test	 ah, 68			; 00000044H
  0012f	7a 39		 jp	 SHORT $LN3@DragBehavi
  00131	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00135	85 c0		 test	 eax, eax
  00137	74 31		 je	 SHORT $LN3@DragBehavi
  00139	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  0013c	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  0013f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00143	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@7f7fffff
  0014b	0f 2f c8	 comiss	 xmm1, xmm0
  0014e	76 1a		 jbe	 SHORT $LN3@DragBehavi

; 1933 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

  00150	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  00153	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  00156	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0015a	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0015d	f3 0f 59 81 00
	2d 00 00	 mulss	 xmm0, DWORD PTR [ecx+11520]
  00165	f3 0f 11 45 10	 movss	 DWORD PTR _v_speed$[ebp], xmm0
$LN3@DragBehavi:

; 1934 : 
; 1935 :     // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
; 1936 :     float adjust_delta = 0.0f;

  0016a	0f 57 c0	 xorps	 xmm0, xmm0
  0016d	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1937 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)

  00172	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00175	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  0017c	0f 85 8e 00 00
	00		 jne	 $LN4@DragBehavi
  00182	6a 00		 push	 0
  00184	e8 00 00 00 00	 call	 ?IsMousePosValid@ImGui@@YA_NPBUImVec2@@@Z ; ImGui::IsMousePosValid
  00189	83 c4 04	 add	 esp, 4
  0018c	0f b6 c0	 movzx	 eax, al
  0018f	85 c0		 test	 eax, eax
  00191	74 7d		 je	 SHORT $LN4@DragBehavi
  00193	b8 04 00 00 00	 mov	 eax, 4
  00198	6b c8 00	 imul	 ecx, eax, 0
  0019b	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  0019e	f3 0f 10 84 0a
	44 04 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1092]
  001a7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001ae	76 60		 jbe	 SHORT $LN4@DragBehavi

; 1938 :     {
; 1939 :         adjust_delta = g.IO.MouseDelta[axis];

  001b0	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  001b7	81 c1 78 03 00
	00		 add	 ecx, 888		; 00000378H
  001bd	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  001c2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001c6	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1940 :         if (g.IO.KeyAlt)

  001cb	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001ce	0f b6 88 02 01
	00 00		 movzx	 ecx, BYTE PTR [eax+258]
  001d5	85 c9		 test	 ecx, ecx
  001d7	74 12		 je	 SHORT $LN6@DragBehavi

; 1941 :             adjust_delta *= 1.0f / 100.0f;

  001d9	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  001de	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  001e6	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN6@DragBehavi:

; 1942 :         if (g.IO.KeyShift)

  001eb	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001ee	0f b6 88 01 01
	00 00		 movzx	 ecx, BYTE PTR [eax+257]
  001f5	85 c9		 test	 ecx, ecx
  001f7	74 12		 je	 SHORT $LN7@DragBehavi

; 1943 :             adjust_delta *= 10.0f;

  001f9	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  001fe	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00206	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN7@DragBehavi:

; 1944 :     }

  0020b	e9 a6 00 00 00	 jmp	 $LN8@DragBehavi
$LN4@DragBehavi:

; 1945 :     else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  00210	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00213	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  0021a	0f 85 96 00 00
	00		 jne	 $LN8@DragBehavi

; 1946 :     {
; 1947 :         int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;

  00220	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00224	85 c0		 test	 eax, eax
  00226	74 16		 je	 SHORT $LN37@DragBehavi
  00228	6a 03		 push	 3
  0022a	8b 4d 1c	 mov	 ecx, DWORD PTR _format$[ebp]
  0022d	51		 push	 ecx
  0022e	e8 00 00 00 00	 call	 ?ImParseFormatPrecision@@YAHPBDH@Z ; ImParseFormatPrecision
  00233	83 c4 08	 add	 esp, 8
  00236	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv161[ebp], eax
  0023c	eb 0a		 jmp	 SHORT $LN38@DragBehavi
$LN37@DragBehavi:
  0023e	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN38@DragBehavi:
  00248	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  0024e	89 55 a4	 mov	 DWORD PTR _decimal_precision$5[ebp], edx

; 1948 :         adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];

  00251	8b 45 ec	 mov	 eax, DWORD PTR _axis$[ebp]
  00254	50		 push	 eax
  00255	51		 push	 ecx
  00256	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  0025e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00263	51		 push	 ecx
  00264	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  0026c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00271	6a 05		 push	 5
  00273	6a 03		 push	 3
  00275	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0027b	51		 push	 ecx
  0027c	e8 00 00 00 00	 call	 ?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z ; ImGui::GetNavInputAmount2d
  00281	83 c4 14	 add	 esp, 20			; 00000014H
  00284	8b c8		 mov	 ecx, eax
  00286	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  0028b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0028f	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1949 :         v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

  00294	8b 45 a4	 mov	 eax, DWORD PTR _decimal_precision$5[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
  0029d	d9 1c 24	 fstp	 DWORD PTR [esp]
  002a0	51		 push	 ecx
  002a1	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  002a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ab	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002b0	83 c4 08	 add	 esp, 8
  002b3	d9 5d 10	 fstp	 DWORD PTR _v_speed$[ebp]
$LN8@DragBehavi:

; 1950 :     }
; 1951 :     adjust_delta *= v_speed;

  002b6	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002bb	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _v_speed$[ebp]
  002c0	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0

; 1952 : 
; 1953 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 1954 :     if (axis == ImGuiAxis_Y)

  002c5	83 7d ec 01	 cmp	 DWORD PTR _axis$[ebp], 1
  002c9	75 11		 jne	 SHORT $LN9@DragBehavi

; 1955 :         adjust_delta = -adjust_delta;

  002cb	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002d0	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002d7	f3 0f 11 45 b0	 movss	 DWORD PTR _adjust_delta$[ebp], xmm0
$LN9@DragBehavi:

; 1956 : 
; 1957 :     // Clear current value on activation
; 1958 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 1959 :     bool is_just_activated = g.ActiveIdIsJustActivated;

  002dc	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  002df	8a 88 f0 19 00
	00		 mov	 cl, BYTE PTR [eax+6640]
  002e5	88 4d 9b	 mov	 BYTE PTR _is_just_activated$[ebp], cl

; 1960 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

  002e8	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  002ec	85 c0		 test	 eax, eax
  002ee	74 37		 je	 SHORT $LN42@DragBehavi
  002f0	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  002f3	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f5	3b 55 18	 cmp	 edx, DWORD PTR _v_max$[ebp]
  002f8	7c 0e		 jl	 SHORT $LN39@DragBehavi
  002fa	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  002ff	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00306	77 13		 ja	 SHORT $LN41@DragBehavi
$LN39@DragBehavi:
  00308	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0030b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030d	3b 4d 14	 cmp	 ecx, DWORD PTR _v_min$[ebp]
  00310	7f 15		 jg	 SHORT $LN42@DragBehavi
  00312	0f 57 c0	 xorps	 xmm0, xmm0
  00315	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00319	76 0c		 jbe	 SHORT $LN42@DragBehavi
$LN41@DragBehavi:
  0031b	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv186[ebp], 1
  00325	eb 0a		 jmp	 SHORT $LN43@DragBehavi
$LN42@DragBehavi:
  00327	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv186[ebp], 0
$LN43@DragBehavi:
  00331	8a 95 6c fe ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  00337	88 55 8f	 mov	 BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp], dl

; 1961 :     bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));

  0033a	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  0033e	85 c0		 test	 eax, eax
  00340	74 46		 je	 SHORT $LN47@DragBehavi
  00342	0f 57 c0	 xorps	 xmm0, xmm0
  00345	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00349	76 14		 jbe	 SHORT $LN44@DragBehavi
  0034b	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0034e	f3 0f 10 81 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [ecx+11516]
  00356	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0035d	77 1d		 ja	 SHORT $LN46@DragBehavi
$LN44@DragBehavi:
  0035f	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00364	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0036b	76 1b		 jbe	 SHORT $LN47@DragBehavi
  0036d	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00370	0f 57 c0	 xorps	 xmm0, xmm0
  00373	0f 2f 82 fc 2c
	00 00		 comiss	 xmm0, DWORD PTR [edx+11516]
  0037a	76 0c		 jbe	 SHORT $LN47@DragBehavi
$LN46@DragBehavi:
  0037c	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv196[ebp], 1
  00386	eb 0a		 jmp	 SHORT $LN48@DragBehavi
$LN47@DragBehavi:
  00388	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
$LN48@DragBehavi:
  00392	8a 85 6c fe ff
	ff		 mov	 al, BYTE PTR tv196[ebp]
  00398	88 45 83	 mov	 BYTE PTR _is_drag_direction_change_with_power$[ebp], al

; 1962 :     if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)

  0039b	0f b6 45 9b	 movzx	 eax, BYTE PTR _is_just_activated$[ebp]
  0039f	85 c0		 test	 eax, eax
  003a1	75 10		 jne	 SHORT $LN12@DragBehavi
  003a3	0f b6 45 8f	 movzx	 eax, BYTE PTR _is_already_past_limits_and_pushing_outward$[ebp]
  003a7	85 c0		 test	 eax, eax
  003a9	75 08		 jne	 SHORT $LN12@DragBehavi
  003ab	0f b6 45 83	 movzx	 eax, BYTE PTR _is_drag_direction_change_with_power$[ebp]
  003af	85 c0		 test	 eax, eax
  003b1	74 1a		 je	 SHORT $LN10@DragBehavi
$LN12@DragBehavi:

; 1963 :     {
; 1964 :         g.DragCurrentAccum = 0.0f;

  003b3	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003b6	0f 57 c0	 xorps	 xmm0, xmm0
  003b9	f3 0f 11 80 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm0

; 1965 :         g.DragCurrentAccumDirty = false;

  003c1	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003c4	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1966 :     }

  003cb	eb 37		 jmp	 SHORT $LN13@DragBehavi
$LN10@DragBehavi:

; 1967 :     else if (adjust_delta != 0.0f)

  003cd	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003d2	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  003d9	9f		 lahf
  003da	f6 c4 44	 test	 ah, 68			; 00000044H
  003dd	7b 25		 jnp	 SHORT $LN13@DragBehavi

; 1968 :     {
; 1969 :         g.DragCurrentAccum += adjust_delta;

  003df	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003e2	f3 0f 10 80 fc
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11516]
  003ea	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  003ef	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  003f2	f3 0f 11 81 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm0

; 1970 :         g.DragCurrentAccumDirty = true;

  003fa	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003fd	c6 80 f8 2c 00
	00 01		 mov	 BYTE PTR [eax+11512], 1
$LN13@DragBehavi:

; 1971 :     }
; 1972 : 
; 1973 :     if (!g.DragCurrentAccumDirty)

  00404	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00407	0f b6 88 f8 2c
	00 00		 movzx	 ecx, BYTE PTR [eax+11512]
  0040e	85 c9		 test	 ecx, ecx
  00410	75 07		 jne	 SHORT $LN14@DragBehavi

; 1974 :         return false;

  00412	32 c0		 xor	 al, al
  00414	e9 78 02 00 00	 jmp	 $LN1@DragBehavi
$LN14@DragBehavi:

; 1975 : 
; 1976 :     TYPE v_cur = *v;

  00419	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0041c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0041e	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], ecx

; 1977 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

  00424	0f 57 c0	 xorps	 xmm0, xmm0
  00427	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1978 : 
; 1979 :     if (is_power)

  0042f	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00433	85 c0		 test	 eax, eax
  00435	0f 84 ca 00 00
	00		 je	 $LN15@DragBehavi

; 1980 :     {
; 1981 :         // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
; 1982 :         FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  0043b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00443	f3 0f 5e 45 20	 divss	 xmm0, DWORD PTR _power$[ebp]
  00448	51		 push	 ecx
  00449	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0044e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00454	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  00457	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0045b	8b 4d 18	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0045e	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00461	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00465	f3 0f 5e c1	 divss	 xmm0, xmm1
  00469	51		 push	 ecx
  0046a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0046f	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00474	83 c4 08	 add	 esp, 8
  00477	d9 9d 5c ff ff
	ff		 fstp	 DWORD PTR _v_old_norm_curved$4[ebp]

; 1983 :         FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));

  0047d	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  00480	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  00483	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00487	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0048a	f3 0f 10 89 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [ecx+11516]
  00492	f3 0f 5e c8	 divss	 xmm1, xmm0
  00496	f3 0f 58 8d 5c
	ff ff ff	 addss	 xmm1, DWORD PTR _v_old_norm_curved$4[ebp]
  0049e	f3 0f 11 8d 50
	ff ff ff	 movss	 DWORD PTR _v_new_norm_curved$3[ebp], xmm1

; 1984 :         v_cur = v_min + (SIGNEDTYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);

  004a6	51		 push	 ecx
  004a7	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  004ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b1	51		 push	 ecx
  004b2	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _v_new_norm_curved$3[ebp]
  004ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004bf	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  004c4	d9 1c 24	 fstp	 DWORD PTR [esp]
  004c7	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  004cc	83 c4 08	 add	 esp, 8
  004cf	d9 9d 6c fe ff
	ff		 fstp	 DWORD PTR tv429[ebp]
  004d5	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR tv429[ebp]
  004dd	f3 0f 2c c0	 cvttss2si eax, xmm0
  004e1	8b 4d 18	 mov	 ecx, DWORD PTR _v_max$[ebp]
  004e4	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  004e7	0f af c1	 imul	 eax, ecx
  004ea	03 45 14	 add	 eax, DWORD PTR _v_min$[ebp]
  004ed	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax

; 1985 :         v_old_ref_for_accum_remainder = v_old_norm_curved;

  004f3	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _v_old_norm_curved$4[ebp]
  004fb	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v_old_ref_for_accum_remainder$[ebp], xmm0

; 1986 :     }

  00503	eb 17		 jmp	 SHORT $LN16@DragBehavi
$LN15@DragBehavi:

; 1987 :     else
; 1988 :     {
; 1989 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

  00505	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00508	f3 0f 2c 88 fc
	2c 00 00	 cvttss2si ecx, DWORD PTR [eax+11516]
  00510	03 8d 74 ff ff
	ff		 add	 ecx, DWORD PTR _v_cur$[ebp]
  00516	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], ecx
$LN16@DragBehavi:

; 1990 :     }
; 1991 : 
; 1992 :     // Round to user desired precision based on format string
; 1993 :     v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

  0051c	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00522	50		 push	 eax
  00523	8b 4d 08	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00526	51		 push	 ecx
  00527	8b 55 1c	 mov	 edx, DWORD PTR _format$[ebp]
  0052a	52		 push	 edx
  0052b	e8 00 00 00 00	 call	 ??$RoundScalarWithFormatT@HH@ImGui@@YAHPBDHH@Z ; ImGui::RoundScalarWithFormatT<int,int>
  00530	83 c4 0c	 add	 esp, 12			; 0000000cH
  00533	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax

; 1994 : 
; 1995 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 1996 :     g.DragCurrentAccumDirty = false;

  00539	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0053c	c6 80 f8 2c 00
	00 00		 mov	 BYTE PTR [eax+11512], 0

; 1997 :     if (is_power)

  00543	0f b6 45 cb	 movzx	 eax, BYTE PTR _is_power$[ebp]
  00547	85 c0		 test	 eax, eax
  00549	74 6e		 je	 SHORT $LN17@DragBehavi

; 1998 :     {
; 1999 :         FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);

  0054b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00553	f3 0f 5e 45 20	 divss	 xmm0, DWORD PTR _power$[ebp]
  00558	51		 push	 ecx
  00559	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00564	2b 45 14	 sub	 eax, DWORD PTR _v_min$[ebp]
  00567	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0056b	8b 4d 18	 mov	 ecx, DWORD PTR _v_max$[ebp]
  0056e	2b 4d 14	 sub	 ecx, DWORD PTR _v_min$[ebp]
  00571	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00575	f3 0f 5e c1	 divss	 xmm0, xmm1
  00579	51		 push	 ecx
  0057a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0057f	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00584	83 c4 08	 add	 esp, 8
  00587	d9 9d 44 ff ff
	ff		 fstp	 DWORD PTR _v_cur_norm_curved$2[ebp]

; 2000 :         g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);

  0058d	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _v_cur_norm_curved$2[ebp]
  00595	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _v_old_ref_for_accum_remainder$[ebp]
  0059d	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005a0	f3 0f 10 88 fc
	2c 00 00	 movss	 xmm1, DWORD PTR [eax+11516]
  005a8	f3 0f 5c c8	 subss	 xmm1, xmm0
  005ac	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  005af	f3 0f 11 89 fc
	2c 00 00	 movss	 DWORD PTR [ecx+11516], xmm1

; 2001 :     }

  005b7	eb 29		 jmp	 SHORT $LN18@DragBehavi
$LN17@DragBehavi:

; 2002 :     else
; 2003 :     {
; 2004 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

  005b9	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  005bc	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  005c2	2b 08		 sub	 ecx, DWORD PTR [eax]
  005c4	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  005c8	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  005cb	f3 0f 10 8a fc
	2c 00 00	 movss	 xmm1, DWORD PTR [edx+11516]
  005d3	f3 0f 5c c8	 subss	 xmm1, xmm0
  005d7	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005da	f3 0f 11 88 fc
	2c 00 00	 movss	 DWORD PTR [eax+11516], xmm1
$LN18@DragBehavi:

; 2005 :     }
; 2006 : 
; 2007 :     // Lose zero sign for float/double
; 2008 :     if (v_cur == (TYPE)-0)

  005e2	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _v_cur$[ebp], 0
  005e9	75 0a		 jne	 SHORT $LN19@DragBehavi

; 2009 :         v_cur = (TYPE)0;

  005eb	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _v_cur$[ebp], 0
$LN19@DragBehavi:

; 2010 : 
; 2011 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2012 :     if (*v != v_cur && is_clamped)

  005f5	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  005f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  005fa	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp]
  00600	74 71		 je	 SHORT $LN23@DragBehavi
  00602	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_clamped$[ebp]
  00606	85 c0		 test	 eax, eax
  00608	74 69		 je	 SHORT $LN23@DragBehavi

; 2013 :     {
; 2014 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))

  0060a	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00610	3b 45 14	 cmp	 eax, DWORD PTR _v_min$[ebp]
  00613	7c 1e		 jl	 SHORT $LN22@DragBehavi
  00615	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00618	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  0061e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00620	7e 1a		 jle	 SHORT $LN21@DragBehavi
  00622	0f 57 c0	 xorps	 xmm0, xmm0
  00625	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00629	76 11		 jbe	 SHORT $LN21@DragBehavi
  0062b	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  0062f	85 c0		 test	 eax, eax
  00631	75 09		 jne	 SHORT $LN21@DragBehavi
$LN22@DragBehavi:

; 2015 :             v_cur = v_min;

  00633	8b 45 14	 mov	 eax, DWORD PTR _v_min$[ebp]
  00636	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
$LN21@DragBehavi:

; 2016 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))

  0063c	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v_cur$[ebp]
  00642	3b 45 18	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00645	7f 23		 jg	 SHORT $LN24@DragBehavi
  00647	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0064a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  00650	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00652	7d 1f		 jge	 SHORT $LN23@DragBehavi
  00654	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _adjust_delta$[ebp]
  00659	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00660	76 11		 jbe	 SHORT $LN23@DragBehavi
  00662	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_decimal$[ebp]
  00666	85 c0		 test	 eax, eax
  00668	75 09		 jne	 SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2017 :             v_cur = v_max;

  0066a	8b 45 18	 mov	 eax, DWORD PTR _v_max$[ebp]
  0066d	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v_cur$[ebp], eax
$LN23@DragBehavi:

; 2018 :     }
; 2019 : 
; 2020 :     // Apply result
; 2021 :     if (*v == v_cur)

  00673	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00676	8b 08		 mov	 ecx, DWORD PTR [eax]
  00678	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _v_cur$[ebp]
  0067e	75 04		 jne	 SHORT $LN25@DragBehavi

; 2022 :         return false;

  00680	32 c0		 xor	 al, al
  00682	eb 0d		 jmp	 SHORT $LN1@DragBehavi
$LN25@DragBehavi:

; 2023 :     *v = v_cur;

  00684	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00687	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _v_cur$[ebp]
  0068d	89 08		 mov	 DWORD PTR [eax], ecx

; 2024 :     return true;

  0068f	b0 01		 mov	 al, 1
$LN1@DragBehavi:

; 2025 : }

  00691	5f		 pop	 edi
  00692	5e		 pop	 esi
  00693	5b		 pop	 ebx
  00694	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  0069a	3b ec		 cmp	 ebp, esp
  0069c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006a1	8b e5		 mov	 esp, ebp
  006a3	5d		 pop	 ebp
  006a4	c3		 ret	 0
??$DragBehaviorT@HHM@ImGui@@YA_NHPAHMHHPBDMH@Z ENDP	; ImGui::DragBehaviorT<int,int,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetMinimumStepAtDecimalPrecision@@YAMH@Z
_TEXT	SEGMENT
tv73 = -196						; size = 4
_decimal_precision$ = 8					; size = 4
?GetMinimumStepAtDecimalPrecision@@YAMH@Z PROC		; GetMinimumStepAtDecimalPrecision, COMDAT

; 1861 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1862 :     static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
; 1863 :     if (decimal_precision < 0)

  00028	83 7d 08 00	 cmp	 DWORD PTR _decimal_precision$[ebp], 0
  0002c	7d 08		 jge	 SHORT $LN2@GetMinimum

; 1864 :         return FLT_MIN;

  0002e	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@00800000
  00034	eb 4d		 jmp	 SHORT $LN1@GetMinimum
$LN2@GetMinimum:

; 1865 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

  00036	83 7d 08 0a	 cmp	 DWORD PTR _decimal_precision$[ebp], 10 ; 0000000aH
  0003a	7d 16		 jge	 SHORT $LN4@GetMinimum
  0003c	8b 45 08	 mov	 eax, DWORD PTR _decimal_precision$[ebp]
  0003f	f3 0f 10 04 85
	00 00 00 00	 movss	 xmm0, DWORD PTR ?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB[eax*4]
  00048	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv73[ebp], xmm0
  00050	eb 2b		 jmp	 SHORT $LN5@GetMinimum
$LN4@GetMinimum:
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _decimal_precision$[ebp]
  00055	f7 d9		 neg	 ecx
  00057	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0005b	51		 push	 ecx
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	51		 push	 ecx
  00062	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  0006a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006f	e8 00 00 00 00	 call	 ?ImPow@@YAMMM@Z		; ImPow
  00074	83 c4 08	 add	 esp, 8
  00077	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv73[ebp]
$LN5@GetMinimum:
  0007d	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv73[ebp]
$LN1@GetMinimum:

; 1866 : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?GetMinimumStepAtDecimalPrecision@@YAMH@Z ENDP		; GetMinimumStepAtDecimalPrecision
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@H@@YAHHHH@Z
_TEXT	SEGMENT
tv66 = -200						; size = 4
tv67 = -196						; size = 4
_v$ = 8							; size = 4
_mn$ = 12						; size = 4
_mx$ = 16						; size = 4
??$ImClamp@H@@YAHHHH@Z PROC				; ImClamp<int>, COMDAT

; 316  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _mn$[ebp]
  0002e	7d 0b		 jge	 SHORT $LN5@ImClamp
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _mn$[ebp]
  00033	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp], ecx
  00039	eb 28		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  0003b	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0003e	3b 55 10	 cmp	 edx, DWORD PTR _mx$[ebp]
  00041	7e 0b		 jle	 SHORT $LN3@ImClamp
  00043	8b 45 10	 mov	 eax, DWORD PTR _mx$[ebp]
  00046	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  0004c	eb 09		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00051	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], ecx
$LN4@ImClamp:
  00057	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv66[ebp]
  0005d	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp], edx
$LN6@ImClamp:
  00063	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv67[ebp]
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
??$ImClamp@H@@YAHHHH@Z ENDP				; ImClamp<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@_K@@YA_K_K000@Z
_TEXT	SEGMENT
tv94 = -200						; size = 8
tv78 = -200						; size = 8
_a$ = 8							; size = 8
_b$ = 16						; size = 8
_mn$ = 24						; size = 8
_mx$ = 32						; size = 8
??$ImSubClampOverflow@_K@@YA_K_K000@Z PROC		; ImSubClampOverflow<unsigned __int64>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  0002c	77 06		 ja	 SHORT $LN5@ImSubClamp
  0002e	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  00032	76 38		 jbe	 SHORT $LN2@ImSubClamp
$LN5@ImSubClamp:
  00034	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00037	03 45 10	 add	 eax, DWORD PTR _b$[ebp]
  0003a	8b 4d 1c	 mov	 ecx, DWORD PTR _mn$[ebp+4]
  0003d	13 4d 14	 adc	 ecx, DWORD PTR _b$[ebp+4]
  00040	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00046	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv78[ebp+4], ecx
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  0004f	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv78[ebp+4]
  00055	77 15		 ja	 SHORT $LN2@ImSubClamp
  00057	72 0b		 jb	 SHORT $LN6@ImSubClamp
  00059	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0005c	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv78[ebp]
  00062	73 08		 jae	 SHORT $LN2@ImSubClamp
$LN6@ImSubClamp:
  00064	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00067	8b 55 1c	 mov	 edx, DWORD PTR _mn$[ebp+4]
  0006a	eb 52		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  0006c	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  00070	77 40		 ja	 SHORT $LN3@ImSubClamp
  00072	72 06		 jb	 SHORT $LN7@ImSubClamp
  00074	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  00078	73 38		 jae	 SHORT $LN3@ImSubClamp
$LN7@ImSubClamp:
  0007a	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  0007d	03 45 10	 add	 eax, DWORD PTR _b$[ebp]
  00080	8b 4d 24	 mov	 ecx, DWORD PTR _mx$[ebp+4]
  00083	13 4d 14	 adc	 ecx, DWORD PTR _b$[ebp+4]
  00086	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv94[ebp], eax
  0008c	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv94[ebp+4], ecx
  00092	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  00095	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv94[ebp+4]
  0009b	72 15		 jb	 SHORT $LN3@ImSubClamp
  0009d	77 0b		 ja	 SHORT $LN8@ImSubClamp
  0009f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a2	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv94[ebp]
  000a8	76 08		 jbe	 SHORT $LN3@ImSubClamp
$LN8@ImSubClamp:
  000aa	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  000ad	8b 55 24	 mov	 edx, DWORD PTR _mx$[ebp+4]
  000b0	eb 0c		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  000b2	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000b5	2b 45 10	 sub	 eax, DWORD PTR _b$[ebp]
  000b8	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  000bb	1b 55 14	 sbb	 edx, DWORD PTR _b$[ebp+4]
$LN1@ImSubClamp:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000c7	3b ec		 cmp	 ebp, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
??$ImSubClampOverflow@_K@@YA_K_K000@Z ENDP		; ImSubClampOverflow<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@_K@@YA_K_K000@Z
_TEXT	SEGMENT
tv94 = -200						; size = 8
tv79 = -200						; size = 8
_a$ = 8							; size = 8
_b$ = 16						; size = 8
_mn$ = 24						; size = 8
_mx$ = 32						; size = 8
??$ImAddClampOverflow@_K@@YA_K_K000@Z PROC		; ImAddClampOverflow<unsigned __int64>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  0002c	77 40		 ja	 SHORT $LN2@ImAddClamp
  0002e	72 06		 jb	 SHORT $LN5@ImAddClamp
  00030	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  00034	73 38		 jae	 SHORT $LN2@ImAddClamp
$LN5@ImAddClamp:
  00036	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00039	2b 45 10	 sub	 eax, DWORD PTR _b$[ebp]
  0003c	8b 4d 1c	 mov	 ecx, DWORD PTR _mn$[ebp+4]
  0003f	1b 4d 14	 sbb	 ecx, DWORD PTR _b$[ebp+4]
  00042	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  00048	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv79[ebp+4], ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  00051	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv79[ebp+4]
  00057	77 15		 ja	 SHORT $LN2@ImAddClamp
  00059	72 0b		 jb	 SHORT $LN6@ImAddClamp
  0005b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0005e	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv79[ebp]
  00064	73 08		 jae	 SHORT $LN2@ImAddClamp
$LN6@ImAddClamp:
  00066	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00069	8b 55 1c	 mov	 edx, DWORD PTR _mn$[ebp+4]
  0006c	eb 50		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  0006e	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  00072	77 06		 ja	 SHORT $LN7@ImAddClamp
  00074	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  00078	76 38		 jbe	 SHORT $LN3@ImAddClamp
$LN7@ImAddClamp:
  0007a	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  0007d	2b 45 10	 sub	 eax, DWORD PTR _b$[ebp]
  00080	8b 4d 24	 mov	 ecx, DWORD PTR _mx$[ebp+4]
  00083	1b 4d 14	 sbb	 ecx, DWORD PTR _b$[ebp+4]
  00086	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv94[ebp], eax
  0008c	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv94[ebp+4], ecx
  00092	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  00095	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv94[ebp+4]
  0009b	72 15		 jb	 SHORT $LN3@ImAddClamp
  0009d	77 0b		 ja	 SHORT $LN8@ImAddClamp
  0009f	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a2	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv94[ebp]
  000a8	76 08		 jbe	 SHORT $LN3@ImAddClamp
$LN8@ImAddClamp:
  000aa	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  000ad	8b 55 24	 mov	 edx, DWORD PTR _mx$[ebp+4]
  000b0	eb 0c		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  000b2	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000b5	03 45 10	 add	 eax, DWORD PTR _b$[ebp]
  000b8	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  000bb	13 55 14	 adc	 edx, DWORD PTR _b$[ebp+4]
$LN1@ImAddClamp:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000c7	3b ec		 cmp	 ebp, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
??$ImAddClampOverflow@_K@@YA_K_K000@Z ENDP		; ImAddClampOverflow<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@_J@@YA_J_J000@Z
_TEXT	SEGMENT
tv95 = -200						; size = 8
tv79 = -200						; size = 8
_a$ = 8							; size = 8
_b$ = 16						; size = 8
_mn$ = 24						; size = 8
_mx$ = 32						; size = 8
??$ImSubClampOverflow@_J@@YA_J_J000@Z PROC		; ImSubClampOverflow<__int64>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  0002c	7c 40		 jl	 SHORT $LN2@ImSubClamp
  0002e	7f 06		 jg	 SHORT $LN5@ImSubClamp
  00030	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  00034	76 38		 jbe	 SHORT $LN2@ImSubClamp
$LN5@ImSubClamp:
  00036	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00039	03 45 10	 add	 eax, DWORD PTR _b$[ebp]
  0003c	8b 4d 1c	 mov	 ecx, DWORD PTR _mn$[ebp+4]
  0003f	13 4d 14	 adc	 ecx, DWORD PTR _b$[ebp+4]
  00042	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  00048	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv79[ebp+4], ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  00051	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv79[ebp+4]
  00057	7f 15		 jg	 SHORT $LN2@ImSubClamp
  00059	7c 0b		 jl	 SHORT $LN6@ImSubClamp
  0005b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0005e	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv79[ebp]
  00064	73 08		 jae	 SHORT $LN2@ImSubClamp
$LN6@ImSubClamp:
  00066	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00069	8b 55 1c	 mov	 edx, DWORD PTR _mn$[ebp+4]
  0006c	eb 52		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  0006e	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  00072	7f 40		 jg	 SHORT $LN3@ImSubClamp
  00074	7c 06		 jl	 SHORT $LN7@ImSubClamp
  00076	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  0007a	73 38		 jae	 SHORT $LN3@ImSubClamp
$LN7@ImSubClamp:
  0007c	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  0007f	03 45 10	 add	 eax, DWORD PTR _b$[ebp]
  00082	8b 4d 24	 mov	 ecx, DWORD PTR _mx$[ebp+4]
  00085	13 4d 14	 adc	 ecx, DWORD PTR _b$[ebp+4]
  00088	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], eax
  0008e	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv95[ebp+4], ecx
  00094	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  00097	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv95[ebp+4]
  0009d	7c 15		 jl	 SHORT $LN3@ImSubClamp
  0009f	7f 0b		 jg	 SHORT $LN8@ImSubClamp
  000a1	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a4	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv95[ebp]
  000aa	76 08		 jbe	 SHORT $LN3@ImSubClamp
$LN8@ImSubClamp:
  000ac	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  000af	8b 55 24	 mov	 edx, DWORD PTR _mx$[ebp+4]
  000b2	eb 0c		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  000b4	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000b7	2b 45 10	 sub	 eax, DWORD PTR _b$[ebp]
  000ba	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  000bd	1b 55 14	 sbb	 edx, DWORD PTR _b$[ebp+4]
$LN1@ImSubClamp:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
??$ImSubClampOverflow@_J@@YA_J_J000@Z ENDP		; ImSubClampOverflow<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@_J@@YA_J_J000@Z
_TEXT	SEGMENT
tv95 = -200						; size = 8
tv79 = -200						; size = 8
_a$ = 8							; size = 8
_b$ = 16						; size = 8
_mn$ = 24						; size = 8
_mx$ = 32						; size = 8
??$ImAddClampOverflow@_J@@YA_J_J000@Z PROC		; ImAddClampOverflow<__int64>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  0002c	7f 40		 jg	 SHORT $LN2@ImAddClamp
  0002e	7c 06		 jl	 SHORT $LN5@ImAddClamp
  00030	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  00034	73 38		 jae	 SHORT $LN2@ImAddClamp
$LN5@ImAddClamp:
  00036	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00039	2b 45 10	 sub	 eax, DWORD PTR _b$[ebp]
  0003c	8b 4d 1c	 mov	 ecx, DWORD PTR _mn$[ebp+4]
  0003f	1b 4d 14	 sbb	 ecx, DWORD PTR _b$[ebp+4]
  00042	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  00048	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv79[ebp+4], ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  00051	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv79[ebp+4]
  00057	7f 15		 jg	 SHORT $LN2@ImAddClamp
  00059	7c 0b		 jl	 SHORT $LN6@ImAddClamp
  0005b	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0005e	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv79[ebp]
  00064	73 08		 jae	 SHORT $LN2@ImAddClamp
$LN6@ImAddClamp:
  00066	8b 45 18	 mov	 eax, DWORD PTR _mn$[ebp]
  00069	8b 55 1c	 mov	 edx, DWORD PTR _mn$[ebp+4]
  0006c	eb 52		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  0006e	83 7d 14 00	 cmp	 DWORD PTR _b$[ebp+4], 0
  00072	7c 40		 jl	 SHORT $LN3@ImAddClamp
  00074	7f 06		 jg	 SHORT $LN7@ImAddClamp
  00076	83 7d 10 00	 cmp	 DWORD PTR _b$[ebp], 0
  0007a	76 38		 jbe	 SHORT $LN3@ImAddClamp
$LN7@ImAddClamp:
  0007c	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  0007f	2b 45 10	 sub	 eax, DWORD PTR _b$[ebp]
  00082	8b 4d 24	 mov	 ecx, DWORD PTR _mx$[ebp+4]
  00085	1b 4d 14	 sbb	 ecx, DWORD PTR _b$[ebp+4]
  00088	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], eax
  0008e	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv95[ebp+4], ecx
  00094	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  00097	3b 95 3c ff ff
	ff		 cmp	 edx, DWORD PTR tv95[ebp+4]
  0009d	7c 15		 jl	 SHORT $LN3@ImAddClamp
  0009f	7f 0b		 jg	 SHORT $LN8@ImAddClamp
  000a1	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000a4	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR tv95[ebp]
  000aa	76 08		 jbe	 SHORT $LN3@ImAddClamp
$LN8@ImAddClamp:
  000ac	8b 45 20	 mov	 eax, DWORD PTR _mx$[ebp]
  000af	8b 55 24	 mov	 edx, DWORD PTR _mx$[ebp+4]
  000b2	eb 0c		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  000b4	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000b7	03 45 10	 add	 eax, DWORD PTR _b$[ebp]
  000ba	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp+4]
  000bd	13 55 14	 adc	 edx, DWORD PTR _b$[ebp+4]
$LN1@ImAddClamp:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
??$ImAddClampOverflow@_J@@YA_J_J000@Z ENDP		; ImAddClampOverflow<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@I@@YAIIIII@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_mn$ = 16						; size = 4
_mx$ = 20						; size = 4
??$ImSubClampOverflow@I@@YAIIIII@Z PROC			; ImSubClampOverflow<unsigned int>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  0002c	76 10		 jbe	 SHORT $LN2@ImSubClamp
  0002e	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  00031	03 45 0c	 add	 eax, DWORD PTR _b$[ebp]
  00034	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  00037	73 05		 jae	 SHORT $LN2@ImSubClamp
  00039	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  0003c	eb 1c		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  0003e	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  00042	73 10		 jae	 SHORT $LN3@ImSubClamp
  00044	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00047	03 45 0c	 add	 eax, DWORD PTR _b$[ebp]
  0004a	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  0004d	76 05		 jbe	 SHORT $LN3@ImSubClamp
  0004f	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00052	eb 06		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  00054	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00057	2b 45 0c	 sub	 eax, DWORD PTR _b$[ebp]
$LN1@ImSubClamp:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??$ImSubClampOverflow@I@@YAIIIII@Z ENDP			; ImSubClampOverflow<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@I@@YAIIIII@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_mn$ = 16						; size = 4
_mx$ = 20						; size = 4
??$ImAddClampOverflow@I@@YAIIIII@Z PROC			; ImAddClampOverflow<unsigned int>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  0002c	73 10		 jae	 SHORT $LN2@ImAddClamp
  0002e	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  00031	2b 45 0c	 sub	 eax, DWORD PTR _b$[ebp]
  00034	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  00037	73 05		 jae	 SHORT $LN2@ImAddClamp
  00039	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  0003c	eb 1c		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  0003e	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  00042	76 10		 jbe	 SHORT $LN3@ImAddClamp
  00044	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00047	2b 45 0c	 sub	 eax, DWORD PTR _b$[ebp]
  0004a	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  0004d	76 05		 jbe	 SHORT $LN3@ImAddClamp
  0004f	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00052	eb 06		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  00054	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00057	03 45 0c	 add	 eax, DWORD PTR _b$[ebp]
$LN1@ImAddClamp:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??$ImAddClampOverflow@I@@YAIIIII@Z ENDP			; ImAddClampOverflow<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@H@@YAHHHHH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_mn$ = 16						; size = 4
_mx$ = 20						; size = 4
??$ImSubClampOverflow@H@@YAHHHHH@Z PROC			; ImSubClampOverflow<int>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  0002c	7e 10		 jle	 SHORT $LN2@ImSubClamp
  0002e	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  00031	03 45 0c	 add	 eax, DWORD PTR _b$[ebp]
  00034	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  00037	7d 05		 jge	 SHORT $LN2@ImSubClamp
  00039	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  0003c	eb 1c		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  0003e	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  00042	7d 10		 jge	 SHORT $LN3@ImSubClamp
  00044	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00047	03 45 0c	 add	 eax, DWORD PTR _b$[ebp]
  0004a	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  0004d	7e 05		 jle	 SHORT $LN3@ImSubClamp
  0004f	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00052	eb 06		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  00054	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00057	2b 45 0c	 sub	 eax, DWORD PTR _b$[ebp]
$LN1@ImSubClamp:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??$ImSubClampOverflow@H@@YAHHHHH@Z ENDP			; ImSubClampOverflow<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@H@@YAHHHHH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_mn$ = 16						; size = 4
_mx$ = 20						; size = 4
??$ImAddClampOverflow@H@@YAHHHHH@Z PROC			; ImAddClampOverflow<int>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  0002c	7d 10		 jge	 SHORT $LN2@ImAddClamp
  0002e	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  00031	2b 45 0c	 sub	 eax, DWORD PTR _b$[ebp]
  00034	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  00037	7d 05		 jge	 SHORT $LN2@ImAddClamp
  00039	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  0003c	eb 1c		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  0003e	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  00042	7e 10		 jle	 SHORT $LN3@ImAddClamp
  00044	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00047	2b 45 0c	 sub	 eax, DWORD PTR _b$[ebp]
  0004a	39 45 08	 cmp	 DWORD PTR _a$[ebp], eax
  0004d	7e 05		 jle	 SHORT $LN3@ImAddClamp
  0004f	8b 45 14	 mov	 eax, DWORD PTR _mx$[ebp]
  00052	eb 06		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  00054	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00057	03 45 0c	 add	 eax, DWORD PTR _b$[ebp]
$LN1@ImAddClamp:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??$ImAddClampOverflow@H@@YAHHHHH@Z ENDP			; ImAddClampOverflow<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@G@@YAGGGGG@Z
_TEXT	SEGMENT
_a$ = 8							; size = 2
_b$ = 12						; size = 2
_mn$ = 16						; size = 2
_mx$ = 20						; size = 2
??$ImSubClampOverflow@G@@YAGGGGG@Z PROC			; ImSubClampOverflow<unsigned short>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f b7 45 0c	 movzx	 eax, WORD PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7e 18		 jle	 SHORT $LN2@ImSubClamp
  00030	0f b7 45 08	 movzx	 eax, WORD PTR _a$[ebp]
  00034	0f b7 4d 10	 movzx	 ecx, WORD PTR _mn$[ebp]
  00038	0f b7 55 0c	 movzx	 edx, WORD PTR _b$[ebp]
  0003c	03 ca		 add	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 06		 jge	 SHORT $LN2@ImSubClamp
  00042	66 8b 45 10	 mov	 ax, WORD PTR _mn$[ebp]
  00046	eb 2a		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  00048	0f b7 45 0c	 movzx	 eax, WORD PTR _b$[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	7d 18		 jge	 SHORT $LN3@ImSubClamp
  00050	0f b7 45 08	 movzx	 eax, WORD PTR _a$[ebp]
  00054	0f b7 4d 14	 movzx	 ecx, WORD PTR _mx$[ebp]
  00058	0f b7 55 0c	 movzx	 edx, WORD PTR _b$[ebp]
  0005c	03 ca		 add	 ecx, edx
  0005e	3b c1		 cmp	 eax, ecx
  00060	7e 06		 jle	 SHORT $LN3@ImSubClamp
  00062	66 8b 45 14	 mov	 ax, WORD PTR _mx$[ebp]
  00066	eb 0a		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  00068	0f b7 45 08	 movzx	 eax, WORD PTR _a$[ebp]
  0006c	0f b7 4d 0c	 movzx	 ecx, WORD PTR _b$[ebp]
  00070	2b c1		 sub	 eax, ecx
$LN1@ImSubClamp:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$ImSubClampOverflow@G@@YAGGGGG@Z ENDP			; ImSubClampOverflow<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@G@@YAGGGGG@Z
_TEXT	SEGMENT
_a$ = 8							; size = 2
_b$ = 12						; size = 2
_mn$ = 16						; size = 2
_mx$ = 20						; size = 2
??$ImAddClampOverflow@G@@YAGGGGG@Z PROC			; ImAddClampOverflow<unsigned short>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f b7 45 0c	 movzx	 eax, WORD PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7d 18		 jge	 SHORT $LN2@ImAddClamp
  00030	0f b7 45 08	 movzx	 eax, WORD PTR _a$[ebp]
  00034	0f b7 4d 10	 movzx	 ecx, WORD PTR _mn$[ebp]
  00038	0f b7 55 0c	 movzx	 edx, WORD PTR _b$[ebp]
  0003c	2b ca		 sub	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 06		 jge	 SHORT $LN2@ImAddClamp
  00042	66 8b 45 10	 mov	 ax, WORD PTR _mn$[ebp]
  00046	eb 2a		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  00048	0f b7 45 0c	 movzx	 eax, WORD PTR _b$[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	7e 18		 jle	 SHORT $LN3@ImAddClamp
  00050	0f b7 45 08	 movzx	 eax, WORD PTR _a$[ebp]
  00054	0f b7 4d 14	 movzx	 ecx, WORD PTR _mx$[ebp]
  00058	0f b7 55 0c	 movzx	 edx, WORD PTR _b$[ebp]
  0005c	2b ca		 sub	 ecx, edx
  0005e	3b c1		 cmp	 eax, ecx
  00060	7e 06		 jle	 SHORT $LN3@ImAddClamp
  00062	66 8b 45 14	 mov	 ax, WORD PTR _mx$[ebp]
  00066	eb 0a		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  00068	0f b7 45 08	 movzx	 eax, WORD PTR _a$[ebp]
  0006c	0f b7 4d 0c	 movzx	 ecx, WORD PTR _b$[ebp]
  00070	03 c1		 add	 eax, ecx
$LN1@ImAddClamp:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$ImAddClampOverflow@G@@YAGGGGG@Z ENDP			; ImAddClampOverflow<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@F@@YAFFFFF@Z
_TEXT	SEGMENT
_a$ = 8							; size = 2
_b$ = 12						; size = 2
_mn$ = 16						; size = 2
_mx$ = 20						; size = 2
??$ImSubClampOverflow@F@@YAFFFFF@Z PROC			; ImSubClampOverflow<short>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f bf 45 0c	 movsx	 eax, WORD PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7e 18		 jle	 SHORT $LN2@ImSubClamp
  00030	0f bf 45 08	 movsx	 eax, WORD PTR _a$[ebp]
  00034	0f bf 4d 10	 movsx	 ecx, WORD PTR _mn$[ebp]
  00038	0f bf 55 0c	 movsx	 edx, WORD PTR _b$[ebp]
  0003c	03 ca		 add	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 06		 jge	 SHORT $LN2@ImSubClamp
  00042	66 8b 45 10	 mov	 ax, WORD PTR _mn$[ebp]
  00046	eb 2a		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  00048	0f bf 45 0c	 movsx	 eax, WORD PTR _b$[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	7d 18		 jge	 SHORT $LN3@ImSubClamp
  00050	0f bf 45 08	 movsx	 eax, WORD PTR _a$[ebp]
  00054	0f bf 4d 14	 movsx	 ecx, WORD PTR _mx$[ebp]
  00058	0f bf 55 0c	 movsx	 edx, WORD PTR _b$[ebp]
  0005c	03 ca		 add	 ecx, edx
  0005e	3b c1		 cmp	 eax, ecx
  00060	7e 06		 jle	 SHORT $LN3@ImSubClamp
  00062	66 8b 45 14	 mov	 ax, WORD PTR _mx$[ebp]
  00066	eb 0a		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  00068	0f bf 45 08	 movsx	 eax, WORD PTR _a$[ebp]
  0006c	0f bf 4d 0c	 movsx	 ecx, WORD PTR _b$[ebp]
  00070	2b c1		 sub	 eax, ecx
$LN1@ImSubClamp:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$ImSubClampOverflow@F@@YAFFFFF@Z ENDP			; ImSubClampOverflow<short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@F@@YAFFFFF@Z
_TEXT	SEGMENT
_a$ = 8							; size = 2
_b$ = 12						; size = 2
_mn$ = 16						; size = 2
_mx$ = 20						; size = 2
??$ImAddClampOverflow@F@@YAFFFFF@Z PROC			; ImAddClampOverflow<short>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f bf 45 0c	 movsx	 eax, WORD PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7d 18		 jge	 SHORT $LN2@ImAddClamp
  00030	0f bf 45 08	 movsx	 eax, WORD PTR _a$[ebp]
  00034	0f bf 4d 10	 movsx	 ecx, WORD PTR _mn$[ebp]
  00038	0f bf 55 0c	 movsx	 edx, WORD PTR _b$[ebp]
  0003c	2b ca		 sub	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 06		 jge	 SHORT $LN2@ImAddClamp
  00042	66 8b 45 10	 mov	 ax, WORD PTR _mn$[ebp]
  00046	eb 2a		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  00048	0f bf 45 0c	 movsx	 eax, WORD PTR _b$[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	7e 18		 jle	 SHORT $LN3@ImAddClamp
  00050	0f bf 45 08	 movsx	 eax, WORD PTR _a$[ebp]
  00054	0f bf 4d 14	 movsx	 ecx, WORD PTR _mx$[ebp]
  00058	0f bf 55 0c	 movsx	 edx, WORD PTR _b$[ebp]
  0005c	2b ca		 sub	 ecx, edx
  0005e	3b c1		 cmp	 eax, ecx
  00060	7e 06		 jle	 SHORT $LN3@ImAddClamp
  00062	66 8b 45 14	 mov	 ax, WORD PTR _mx$[ebp]
  00066	eb 0a		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  00068	0f bf 45 08	 movsx	 eax, WORD PTR _a$[ebp]
  0006c	0f bf 4d 0c	 movsx	 ecx, WORD PTR _b$[ebp]
  00070	03 c1		 add	 eax, ecx
$LN1@ImAddClamp:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$ImAddClampOverflow@F@@YAFFFFF@Z ENDP			; ImAddClampOverflow<short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@E@@YAEEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_mn$ = 16						; size = 1
_mx$ = 20						; size = 1
??$ImSubClampOverflow@E@@YAEEEEE@Z PROC			; ImSubClampOverflow<unsigned char>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f b6 45 0c	 movzx	 eax, BYTE PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7e 17		 jle	 SHORT $LN2@ImSubClamp
  00030	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00034	0f b6 4d 10	 movzx	 ecx, BYTE PTR _mn$[ebp]
  00038	0f b6 55 0c	 movzx	 edx, BYTE PTR _b$[ebp]
  0003c	03 ca		 add	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 05		 jge	 SHORT $LN2@ImSubClamp
  00042	8a 45 10	 mov	 al, BYTE PTR _mn$[ebp]
  00045	eb 29		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  00047	0f b6 45 0c	 movzx	 eax, BYTE PTR _b$[ebp]
  0004b	85 c0		 test	 eax, eax
  0004d	7d 17		 jge	 SHORT $LN3@ImSubClamp
  0004f	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00053	0f b6 4d 14	 movzx	 ecx, BYTE PTR _mx$[ebp]
  00057	0f b6 55 0c	 movzx	 edx, BYTE PTR _b$[ebp]
  0005b	03 ca		 add	 ecx, edx
  0005d	3b c1		 cmp	 eax, ecx
  0005f	7e 05		 jle	 SHORT $LN3@ImSubClamp
  00061	8a 45 14	 mov	 al, BYTE PTR _mx$[ebp]
  00064	eb 0a		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  00066	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0006a	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _b$[ebp]
  0006e	2b c1		 sub	 eax, ecx
$LN1@ImSubClamp:
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
??$ImSubClampOverflow@E@@YAEEEEE@Z ENDP			; ImSubClampOverflow<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@E@@YAEEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_mn$ = 16						; size = 1
_mx$ = 20						; size = 1
??$ImAddClampOverflow@E@@YAEEEEE@Z PROC			; ImAddClampOverflow<unsigned char>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f b6 45 0c	 movzx	 eax, BYTE PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7d 17		 jge	 SHORT $LN2@ImAddClamp
  00030	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00034	0f b6 4d 10	 movzx	 ecx, BYTE PTR _mn$[ebp]
  00038	0f b6 55 0c	 movzx	 edx, BYTE PTR _b$[ebp]
  0003c	2b ca		 sub	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 05		 jge	 SHORT $LN2@ImAddClamp
  00042	8a 45 10	 mov	 al, BYTE PTR _mn$[ebp]
  00045	eb 29		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  00047	0f b6 45 0c	 movzx	 eax, BYTE PTR _b$[ebp]
  0004b	85 c0		 test	 eax, eax
  0004d	7e 17		 jle	 SHORT $LN3@ImAddClamp
  0004f	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00053	0f b6 4d 14	 movzx	 ecx, BYTE PTR _mx$[ebp]
  00057	0f b6 55 0c	 movzx	 edx, BYTE PTR _b$[ebp]
  0005b	2b ca		 sub	 ecx, edx
  0005d	3b c1		 cmp	 eax, ecx
  0005f	7e 05		 jle	 SHORT $LN3@ImAddClamp
  00061	8a 45 14	 mov	 al, BYTE PTR _mx$[ebp]
  00064	eb 0a		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  00066	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0006a	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _b$[ebp]
  0006e	03 c1		 add	 eax, ecx
$LN1@ImAddClamp:
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
??$ImAddClampOverflow@E@@YAEEEEE@Z ENDP			; ImAddClampOverflow<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@C@@YACCCCC@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_mn$ = 16						; size = 1
_mx$ = 20						; size = 1
??$ImSubClampOverflow@C@@YACCCCC@Z PROC			; ImSubClampOverflow<signed char>, COMDAT

; 320  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f be 45 0c	 movsx	 eax, BYTE PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7e 17		 jle	 SHORT $LN2@ImSubClamp
  00030	0f be 45 08	 movsx	 eax, BYTE PTR _a$[ebp]
  00034	0f be 4d 10	 movsx	 ecx, BYTE PTR _mn$[ebp]
  00038	0f be 55 0c	 movsx	 edx, BYTE PTR _b$[ebp]
  0003c	03 ca		 add	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 05		 jge	 SHORT $LN2@ImSubClamp
  00042	8a 45 10	 mov	 al, BYTE PTR _mn$[ebp]
  00045	eb 29		 jmp	 SHORT $LN1@ImSubClamp
$LN2@ImSubClamp:
  00047	0f be 45 0c	 movsx	 eax, BYTE PTR _b$[ebp]
  0004b	85 c0		 test	 eax, eax
  0004d	7d 17		 jge	 SHORT $LN3@ImSubClamp
  0004f	0f be 45 08	 movsx	 eax, BYTE PTR _a$[ebp]
  00053	0f be 4d 14	 movsx	 ecx, BYTE PTR _mx$[ebp]
  00057	0f be 55 0c	 movsx	 edx, BYTE PTR _b$[ebp]
  0005b	03 ca		 add	 ecx, edx
  0005d	3b c1		 cmp	 eax, ecx
  0005f	7e 05		 jle	 SHORT $LN3@ImSubClamp
  00061	8a 45 14	 mov	 al, BYTE PTR _mx$[ebp]
  00064	eb 0a		 jmp	 SHORT $LN1@ImSubClamp
$LN3@ImSubClamp:
  00066	0f be 45 08	 movsx	 eax, BYTE PTR _a$[ebp]
  0006a	0f be 4d 0c	 movsx	 ecx, BYTE PTR _b$[ebp]
  0006e	2b c1		 sub	 eax, ecx
$LN1@ImSubClamp:
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
??$ImSubClampOverflow@C@@YACCCCC@Z ENDP			; ImSubClampOverflow<signed char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@C@@YACCCCC@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_mn$ = 16						; size = 1
_mx$ = 20						; size = 1
??$ImAddClampOverflow@C@@YACCCCC@Z PROC			; ImAddClampOverflow<signed char>, COMDAT

; 319  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f be 45 0c	 movsx	 eax, BYTE PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	7d 17		 jge	 SHORT $LN2@ImAddClamp
  00030	0f be 45 08	 movsx	 eax, BYTE PTR _a$[ebp]
  00034	0f be 4d 10	 movsx	 ecx, BYTE PTR _mn$[ebp]
  00038	0f be 55 0c	 movsx	 edx, BYTE PTR _b$[ebp]
  0003c	2b ca		 sub	 ecx, edx
  0003e	3b c1		 cmp	 eax, ecx
  00040	7d 05		 jge	 SHORT $LN2@ImAddClamp
  00042	8a 45 10	 mov	 al, BYTE PTR _mn$[ebp]
  00045	eb 29		 jmp	 SHORT $LN1@ImAddClamp
$LN2@ImAddClamp:
  00047	0f be 45 0c	 movsx	 eax, BYTE PTR _b$[ebp]
  0004b	85 c0		 test	 eax, eax
  0004d	7e 17		 jle	 SHORT $LN3@ImAddClamp
  0004f	0f be 45 08	 movsx	 eax, BYTE PTR _a$[ebp]
  00053	0f be 4d 14	 movsx	 ecx, BYTE PTR _mx$[ebp]
  00057	0f be 55 0c	 movsx	 edx, BYTE PTR _b$[ebp]
  0005b	2b ca		 sub	 ecx, edx
  0005d	3b c1		 cmp	 eax, ecx
  0005f	7e 05		 jle	 SHORT $LN3@ImAddClamp
  00061	8a 45 14	 mov	 al, BYTE PTR _mx$[ebp]
  00064	eb 0a		 jmp	 SHORT $LN1@ImAddClamp
$LN3@ImAddClamp:
  00066	0f be 45 08	 movsx	 eax, BYTE PTR _a$[ebp]
  0006a	0f be 4d 0c	 movsx	 ecx, BYTE PTR _b$[ebp]
  0006e	03 c1		 add	 eax, ecx
$LN1@ImAddClamp:
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
??$ImAddClampOverflow@C@@YACCCCC@Z ENDP			; ImAddClampOverflow<signed char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PatchFormatStringFloatToInt@@YAPBDPBD@Z
_TEXT	SEGMENT
_g$1 = -32						; size = 4
_fmt_end$ = -20						; size = 4
_fmt_start$ = -8					; size = 4
_fmt$ = 8						; size = 4
?PatchFormatStringFloatToInt@@YAPBDPBD@Z PROC		; PatchFormatStringFloatToInt, COMDAT

; 1658 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1659 :     if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  00033	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00037	83 f8 25	 cmp	 eax, 37			; 00000025H
  0003a	75 58		 jne	 SHORT $LN2@PatchForma
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	c1 e0 00	 shl	 eax, 0
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00047	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0004b	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  0004e	75 44		 jne	 SHORT $LN2@PatchForma
  00050	b8 01 00 00 00	 mov	 eax, 1
  00055	d1 e0		 shl	 eax, 1
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0005a	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  0005e	83 fa 30	 cmp	 edx, 48			; 00000030H
  00061	75 31		 jne	 SHORT $LN2@PatchForma
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	6b c8 03	 imul	 ecx, eax, 3
  0006b	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  0006e	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00072	83 f8 66	 cmp	 eax, 102		; 00000066H
  00075	75 1d		 jne	 SHORT $LN2@PatchForma
  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	c1 e0 02	 shl	 eax, 2
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00082	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00086	85 d2		 test	 edx, edx
  00088	75 0a		 jne	 SHORT $LN2@PatchForma

; 1660 :         return "%d";

  0008a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0008f	e9 9b 00 00 00	 jmp	 $LN1@PatchForma
$LN2@PatchForma:

; 1661 :     const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)

  00094	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0009d	83 c4 04	 add	 esp, 4
  000a0	89 45 f8	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 1662 :     const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).

  000a3	8b 45 f8	 mov	 eax, DWORD PTR _fmt_start$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?ImParseFormatFindEnd@@YAPBDPBD@Z ; ImParseFormatFindEnd
  000ac	83 c4 04	 add	 esp, 4
  000af	89 45 ec	 mov	 DWORD PTR _fmt_end$[ebp], eax

; 1663 :     if (fmt_end > fmt_start && fmt_end[-1] == 'f')

  000b2	8b 45 ec	 mov	 eax, DWORD PTR _fmt_end$[ebp]
  000b5	3b 45 f8	 cmp	 eax, DWORD PTR _fmt_start$[ebp]
  000b8	76 72		 jbe	 SHORT $LN3@PatchForma
  000ba	b8 01 00 00 00	 mov	 eax, 1
  000bf	6b c8 ff	 imul	 ecx, eax, -1
  000c2	8b 55 ec	 mov	 edx, DWORD PTR _fmt_end$[ebp]
  000c5	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000c9	83 f8 66	 cmp	 eax, 102		; 00000066H
  000cc	75 5e		 jne	 SHORT $LN3@PatchForma

; 1664 :     {
; 1665 : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 1666 :         if (fmt_start == fmt && fmt_end[0] == 0)

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _fmt_start$[ebp]
  000d1	3b 45 08	 cmp	 eax, DWORD PTR _fmt$[ebp]
  000d4	75 1a		 jne	 SHORT $LN4@PatchForma
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	6b c8 00	 imul	 ecx, eax, 0
  000de	8b 55 ec	 mov	 edx, DWORD PTR _fmt_end$[ebp]
  000e1	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000e5	85 c0		 test	 eax, eax
  000e7	75 07		 jne	 SHORT $LN4@PatchForma

; 1667 :             return "%d";

  000e9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000ee	eb 3f		 jmp	 SHORT $LN1@PatchForma
$LN4@PatchForma:

; 1668 :         ImGuiContext& g = *GImGui;

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  000f5	89 45 e0	 mov	 DWORD PTR _g$1[ebp], eax

; 1669 :         ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.

  000f8	8b 45 ec	 mov	 eax, DWORD PTR _fmt_end$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  000ff	51		 push	 ecx
  00100	8b 55 f8	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  00103	2b 55 08	 sub	 edx, DWORD PTR _fmt$[ebp]
  00106	52		 push	 edx
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_09JKJEEIJP@?$CF?4?$CKs?$CF?$CFd?$CFs@
  0010c	68 01 0c 00 00	 push	 3073			; 00000c01H
  00111	8b 45 e0	 mov	 eax, DWORD PTR _g$1[ebp]
  00114	05 80 2f 00 00	 add	 eax, 12160		; 00002f80H
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0011f	83 c4 18	 add	 esp, 24			; 00000018H

; 1670 :         return g.TempBuffer;

  00122	8b 45 e0	 mov	 eax, DWORD PTR _g$1[ebp]
  00125	05 80 2f 00 00	 add	 eax, 12160		; 00002f80H
  0012a	eb 03		 jmp	 SHORT $LN1@PatchForma
$LN3@PatchForma:

; 1671 : #else
; 1672 :         IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
; 1673 : #endif
; 1674 :     }
; 1675 :     return fmt;

  0012c	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
$LN1@PatchForma:

; 1676 : }

  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00138	3b ec		 cmp	 ebp, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
?PatchFormatStringFloatToInt@@YAPBDPBD@Z ENDP		; PatchFormatStringFloatToInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Items_SingleStringGetter@@YA_NPAXHPAPBD@Z
_TEXT	SEGMENT
_p$ = -32						; size = 4
_items_count$ = -20					; size = 4
_items_separated_by_zeros$ = -8				; size = 4
_data$ = 8						; size = 4
_idx$ = 12						; size = 4
_out_text$ = 16						; size = 4
?Items_SingleStringGetter@@YA_NPAXHPAPBD@Z PROC		; Items_SingleStringGetter, COMDAT

; 1541 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1542 :     // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
; 1543 :     const char* items_separated_by_zeros = (const char*)data;

  00028	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _items_separated_by_zeros$[ebp], eax

; 1544 :     int items_count = 0;

  0002e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _items_count$[ebp], 0

; 1545 :     const char* p = items_separated_by_zeros;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _items_separated_by_zeros$[ebp]
  00038	89 45 e0	 mov	 DWORD PTR _p$[ebp], eax
$LN2@Items_Sing:

; 1546 :     while (*p)

  0003b	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  0003e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00041	85 c9		 test	 ecx, ecx
  00043	74 2b		 je	 SHORT $LN3@Items_Sing

; 1547 :     {
; 1548 :         if (idx == items_count)

  00045	8b 45 0c	 mov	 eax, DWORD PTR _idx$[ebp]
  00048	3b 45 ec	 cmp	 eax, DWORD PTR _items_count$[ebp]
  0004b	75 02		 jne	 SHORT $LN4@Items_Sing

; 1549 :             break;

  0004d	eb 21		 jmp	 SHORT $LN3@Items_Sing
$LN4@Items_Sing:

; 1550 :         p += strlen(p) + 1;

  0004f	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _strlen
  00058	83 c4 04	 add	 esp, 4
  0005b	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  0005e	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00062	89 55 e0	 mov	 DWORD PTR _p$[ebp], edx

; 1551 :         items_count++;

  00065	8b 45 ec	 mov	 eax, DWORD PTR _items_count$[ebp]
  00068	83 c0 01	 add	 eax, 1
  0006b	89 45 ec	 mov	 DWORD PTR _items_count$[ebp], eax

; 1552 :     }

  0006e	eb cb		 jmp	 SHORT $LN2@Items_Sing
$LN3@Items_Sing:

; 1553 :     if (!*p)

  00070	8b 45 e0	 mov	 eax, DWORD PTR _p$[ebp]
  00073	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00076	85 c9		 test	 ecx, ecx
  00078	75 04		 jne	 SHORT $LN5@Items_Sing

; 1554 :         return false;

  0007a	32 c0		 xor	 al, al
  0007c	eb 10		 jmp	 SHORT $LN1@Items_Sing
$LN5@Items_Sing:

; 1555 :     if (out_text)

  0007e	83 7d 10 00	 cmp	 DWORD PTR _out_text$[ebp], 0
  00082	74 08		 je	 SHORT $LN6@Items_Sing

; 1556 :         *out_text = p;

  00084	8b 45 10	 mov	 eax, DWORD PTR _out_text$[ebp]
  00087	8b 4d e0	 mov	 ecx, DWORD PTR _p$[ebp]
  0008a	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@Items_Sing:

; 1557 :     return true;

  0008c	b0 01		 mov	 al, 1
$LN1@Items_Sing:

; 1558 : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?Items_SingleStringGetter@@YA_NPAXHPAPBD@Z ENDP		; Items_SingleStringGetter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Items_ArrayGetter@@YA_NPAXHPAPBD@Z
_TEXT	SEGMENT
_items$ = -8						; size = 4
_data$ = 8						; size = 4
_idx$ = 12						; size = 4
_out_text$ = 16						; size = 4
?Items_ArrayGetter@@YA_NPAXHPAPBD@Z PROC		; Items_ArrayGetter, COMDAT

; 1532 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1533 :     const char* const* items = (const char* const*)data;

  00028	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _items$[ebp], eax

; 1534 :     if (out_text)

  0002e	83 7d 10 00	 cmp	 DWORD PTR _out_text$[ebp], 0
  00032	74 0e		 je	 SHORT $LN2@Items_Arra

; 1535 :         *out_text = items[idx];

  00034	8b 45 10	 mov	 eax, DWORD PTR _out_text$[ebp]
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _idx$[ebp]
  0003a	8b 55 f8	 mov	 edx, DWORD PTR _items$[ebp]
  0003d	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00040	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@Items_Arra:

; 1536 :     return true;

  00042	b0 01		 mov	 al, 1

; 1537 : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?Items_ArrayGetter@@YA_NPAXHPAPBD@Z ENDP		; Items_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?CalcMaxPopupHeightFromItemCount@@YAMH@Z
_TEXT	SEGMENT
tv91 = -208						; size = 4
_g$ = -8						; size = 4
_items_count$ = 8					; size = 4
?CalcMaxPopupHeightFromItemCount@@YAMH@Z PROC		; CalcMaxPopupHeightFromItemCount, COMDAT

; 1410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1411 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1412 :     if (items_count <= 0)

  00030	83 7d 08 00	 cmp	 DWORD PTR _items_count$[ebp], 0
  00034	7f 08		 jg	 SHORT $LN2@CalcMaxPop

; 1413 :         return FLT_MAX;

  00036	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@7f7fffff
  0003c	eb 4f		 jmp	 SHORT $LN1@CalcMaxPop
$LN2@CalcMaxPop:

; 1414 :     return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00044	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  0004c	f3 0f 58 81 5c
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5468]
  00054	f3 0f 2a 4d 08	 cvtsi2ss xmm1, DWORD PTR _items_count$[ebp]
  00059	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0005d	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00060	f3 0f 5c 82 5c
	15 00 00	 subss	 xmm0, DWORD PTR [edx+5468]
  00068	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0006b	f3 0f 10 88 18
	15 00 00	 movss	 xmm1, DWORD PTR [eax+5400]
  00073	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  0007b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0007f	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv91[ebp], xmm0
  00087	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv91[ebp]
$LN1@CalcMaxPop:

; 1415 : }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00096	3b ec		 cmp	 ebp, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?CalcMaxPopupHeightFromItemCount@@YAMH@Z ENDP		; CalcMaxPopupHeightFromItemCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ShrinkWidthItemComparer@@YAHPBX0@Z
_TEXT	SEGMENT
_d$1 = -32						; size = 4
_b$ = -20						; size = 4
_a$ = -8						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ShrinkWidthItemComparer@@YAHPBX0@Z PROC		; ShrinkWidthItemComparer, COMDAT

; 1357 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1358 :     const ImGuiShrinkWidthItem* a = (const ImGuiShrinkWidthItem*)lhs;

  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _a$[ebp], eax

; 1359 :     const ImGuiShrinkWidthItem* b = (const ImGuiShrinkWidthItem*)rhs;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00031	89 45 ec	 mov	 DWORD PTR _b$[ebp], eax

; 1360 :     if (int d = (int)(b->Width - a->Width))

  00034	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _a$[ebp]
  0003a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0003f	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00044	f3 0f 2c d0	 cvttss2si edx, xmm0
  00048	89 55 e0	 mov	 DWORD PTR _d$1[ebp], edx
  0004b	83 7d e0 00	 cmp	 DWORD PTR _d$1[ebp], 0
  0004f	74 05		 je	 SHORT $LN2@ShrinkWidt

; 1361 :         return d;

  00051	8b 45 e0	 mov	 eax, DWORD PTR _d$1[ebp]
  00054	eb 0a		 jmp	 SHORT $LN1@ShrinkWidt
$LN2@ShrinkWidt:

; 1362 :     return (b->Index - a->Index);

  00056	8b 45 ec	 mov	 eax, DWORD PTR _b$[ebp]
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _a$[ebp]
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
  0005e	2b 01		 sub	 eax, DWORD PTR [ecx]
$LN1@ShrinkWidt:

; 1363 : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?ShrinkWidthItemComparer@@YAHPBX0@Z ENDP		; ShrinkWidthItemComparer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@M@@YAMMMM@Z
_TEXT	SEGMENT
tv72 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_t$ = 16						; size = 4
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  0002d	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _a$[ebp]
  00032	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _t$[ebp]
  00037	f3 0f 58 45 08	 addss	 xmm0, DWORD PTR _a$[ebp]
  0003c	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv72[ebp], xmm0
  00044	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@M@@YAMMMM@Z
_TEXT	SEGMENT
tv66 = -200						; size = 4
tv67 = -196						; size = 4
_v$ = 8							; size = 4
_mn$ = 12						; size = 4
_mx$ = 16						; size = 4
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>, COMDAT

; 316  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _mn$[ebp]
  0002d	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _v$[ebp]
  00031	76 0f		 jbe	 SHORT $LN5@ImClamp
  00033	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _mn$[ebp]
  00038	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv67[ebp], xmm0
  00040	eb 37		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  00042	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _v$[ebp]
  00047	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _mx$[ebp]
  0004b	76 0f		 jbe	 SHORT $LN3@ImClamp
  0004d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _mx$[ebp]
  00052	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
  0005a	eb 0d		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  0005c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _v$[ebp]
  00061	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
$LN4@ImClamp:
  00069	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv66[ebp]
  00071	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv67[ebp], xmm0
$LN6@ImClamp:
  00079	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv67[ebp]
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z
_TEXT	SEGMENT
tv161 = -328						; size = 4
$T1 = -320						; size = 8
_char_width$2 = -112					; size = 4
_c$3 = -100						; size = 4
_s$ = -88						; size = 4
_line_width$ = -76					; size = 4
_text_size$ = -64					; size = 8
_scale$ = -48						; size = 4
_line_height$ = -36					; size = 4
_font$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_text_begin$ = 12					; size = 4
_text_end$ = 16						; size = 4
_remaining$ = 20					; size = 4
_out_offset$ = 24					; size = 4
_stop_on_new_line$ = 28					; size = 1
?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z PROC ; InputTextCalcTextSizeW, COMDAT

; 3109 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00012	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3110 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 3111 :     ImFont* font = g.Font;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00043	89 4d e8	 mov	 DWORD PTR _font$[ebp], ecx

; 3112 :     const float line_height = g.FontSize;

  00046	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00049	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00051	f3 0f 11 45 dc	 movss	 DWORD PTR _line_height$[ebp], xmm0

; 3113 :     const float scale = line_height / font->FontSize;

  00056	8b 45 e8	 mov	 eax, DWORD PTR _font$[ebp]
  00059	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _line_height$[ebp]
  0005e	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  00063	f3 0f 11 45 d0	 movss	 DWORD PTR _scale$[ebp], xmm0

; 3114 : 
; 3115 :     ImVec2 text_size = ImVec2(0,0);

  00068	51		 push	 ecx
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00071	51		 push	 ecx
  00072	0f 57 c0	 xorps	 xmm0, xmm0
  00075	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007a	8d 4d c0	 lea	 ecx, DWORD PTR _text_size$[ebp]
  0007d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 3116 :     float line_width = 0.0f;

  00082	0f 57 c0	 xorps	 xmm0, xmm0
  00085	f3 0f 11 45 b4	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 3117 : 
; 3118 :     const ImWchar* s = text_begin;

  0008a	8b 45 0c	 mov	 eax, DWORD PTR _text_begin$[ebp]
  0008d	89 45 a8	 mov	 DWORD PTR _s$[ebp], eax
$LN14@InputTextC:

; 3119 :     while (s < text_end)

  00090	8b 45 a8	 mov	 eax, DWORD PTR _s$[ebp]
  00093	3b 45 10	 cmp	 eax, DWORD PTR _text_end$[ebp]
  00096	0f 83 9d 00 00
	00		 jae	 $LN3@InputTextC

; 3120 :     {
; 3121 :         unsigned int c = (unsigned int)(*s++);

  0009c	8b 45 a8	 mov	 eax, DWORD PTR _s$[ebp]
  0009f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000a2	89 4d 9c	 mov	 DWORD PTR _c$3[ebp], ecx
  000a5	8b 55 a8	 mov	 edx, DWORD PTR _s$[ebp]
  000a8	83 c2 02	 add	 edx, 2
  000ab	89 55 a8	 mov	 DWORD PTR _s$[ebp], edx

; 3122 :         if (c == '\n')

  000ae	83 7d 9c 0a	 cmp	 DWORD PTR _c$3[ebp], 10	; 0000000aH
  000b2	75 44		 jne	 SHORT $LN4@InputTextC

; 3123 :         {
; 3124 :             text_size.x = ImMax(text_size.x, line_width);

  000b4	51		 push	 ecx
  000b5	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  000ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bf	51		 push	 ecx
  000c0	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _text_size$[ebp]
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000cf	83 c4 08	 add	 esp, 8
  000d2	d9 5d c0	 fstp	 DWORD PTR _text_size$[ebp]

; 3125 :             text_size.y += line_height;

  000d5	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  000da	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  000df	f3 0f 11 45 c4	 movss	 DWORD PTR _text_size$[ebp+4], xmm0

; 3126 :             line_width = 0.0f;

  000e4	0f 57 c0	 xorps	 xmm0, xmm0
  000e7	f3 0f 11 45 b4	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 3127 :             if (stop_on_new_line)

  000ec	0f b6 45 1c	 movzx	 eax, BYTE PTR _stop_on_new_line$[ebp]
  000f0	85 c0		 test	 eax, eax
  000f2	74 02		 je	 SHORT $LN5@InputTextC

; 3128 :                 break;

  000f4	eb 43		 jmp	 SHORT $LN3@InputTextC
$LN5@InputTextC:

; 3129 :             continue;

  000f6	eb 98		 jmp	 SHORT $LN14@InputTextC
$LN4@InputTextC:

; 3130 :         }
; 3131 :         if (c == '\r')

  000f8	83 7d 9c 0d	 cmp	 DWORD PTR _c$3[ebp], 13	; 0000000dH
  000fc	75 02		 jne	 SHORT $LN6@InputTextC

; 3132 :             continue;

  000fe	eb 90		 jmp	 SHORT $LN14@InputTextC
$LN6@InputTextC:

; 3133 : 
; 3134 :         const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

  00100	0f b7 45 9c	 movzx	 eax, WORD PTR _c$3[ebp]
  00104	50		 push	 eax
  00105	8b 4d e8	 mov	 ecx, DWORD PTR _font$[ebp]
  00108	e8 00 00 00 00	 call	 ?GetCharAdvance@ImFont@@QBEMG@Z ; ImFont::GetCharAdvance
  0010d	d9 9d b8 fe ff
	ff		 fstp	 DWORD PTR tv161[ebp]
  00113	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR tv161[ebp]
  0011b	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  00120	f3 0f 11 45 90	 movss	 DWORD PTR _char_width$2[ebp], xmm0

; 3135 :         line_width += char_width;

  00125	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  0012a	f3 0f 58 45 90	 addss	 xmm0, DWORD PTR _char_width$2[ebp]
  0012f	f3 0f 11 45 b4	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 3136 :     }

  00134	e9 57 ff ff ff	 jmp	 $LN14@InputTextC
$LN3@InputTextC:

; 3137 : 
; 3138 :     if (text_size.x < line_width)

  00139	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  0013e	0f 2f 45 c0	 comiss	 xmm0, DWORD PTR _text_size$[ebp]
  00142	76 0a		 jbe	 SHORT $LN7@InputTextC

; 3139 :         text_size.x = line_width;

  00144	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  00149	f3 0f 11 45 c0	 movss	 DWORD PTR _text_size$[ebp], xmm0
$LN7@InputTextC:

; 3140 : 
; 3141 :     if (out_offset)

  0014e	83 7d 18 00	 cmp	 DWORD PTR _out_offset$[ebp], 0
  00152	74 33		 je	 SHORT $LN8@InputTextC

; 3142 :         *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

  00154	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  00159	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  0015e	51		 push	 ecx
  0015f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00164	51		 push	 ecx
  00165	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  0016a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016f	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00175	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0017a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0017f	8b 45 18	 mov	 eax, DWORD PTR _out_offset$[ebp]
  00182	89 08		 mov	 DWORD PTR [eax], ecx
  00184	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN8@InputTextC:

; 3143 : 
; 3144 :     if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n

  00187	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  0018c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00193	77 12		 ja	 SHORT $LN10@InputTextC
  00195	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  0019a	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  001a1	9f		 lahf
  001a2	f6 c4 44	 test	 ah, 68			; 00000044H
  001a5	7a 0f		 jp	 SHORT $LN9@InputTextC
$LN10@InputTextC:

; 3145 :         text_size.y += line_height;

  001a7	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  001ac	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  001b1	f3 0f 11 45 c4	 movss	 DWORD PTR _text_size$[ebp+4], xmm0
$LN9@InputTextC:

; 3146 : 
; 3147 :     if (remaining)

  001b6	83 7d 14 00	 cmp	 DWORD PTR _remaining$[ebp], 0
  001ba	74 08		 je	 SHORT $LN11@InputTextC

; 3148 :         *remaining = s;

  001bc	8b 45 14	 mov	 eax, DWORD PTR _remaining$[ebp]
  001bf	8b 4d a8	 mov	 ecx, DWORD PTR _s$[ebp]
  001c2	89 08		 mov	 DWORD PTR [eax], ecx
$LN11@InputTextC:

; 3149 : 
; 3150 :     return text_size;

  001c4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001c7	8b 4d c0	 mov	 ecx, DWORD PTR _text_size$[ebp]
  001ca	89 08		 mov	 DWORD PTR [eax], ecx
  001cc	8b 55 c4	 mov	 edx, DWORD PTR _text_size$[ebp+4]
  001cf	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001d2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3151 : }

  001d5	52		 push	 edx
  001d6	8b cd		 mov	 ecx, ebp
  001d8	50		 push	 eax
  001d9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@InputTextC
  001df	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001e4	58		 pop	 eax
  001e5	5a		 pop	 edx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  001f9	3b ec		 cmp	 ebp, esp
  001fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
$LN17@InputTextC:
  00204	01 00 00 00	 DD	 1
  00208	00 00 00 00	 DD	 $LN16@InputTextC
$LN16@InputTextC:
  0020c	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00210	08 00 00 00	 DD	 8
  00214	00 00 00 00	 DD	 $LN15@InputTextC
$LN15@InputTextC:
  00218	74		 DB	 116			; 00000074H
  00219	65		 DB	 101			; 00000065H
  0021a	78		 DB	 120			; 00000078H
  0021b	74		 DB	 116			; 00000074H
  0021c	5f		 DB	 95			; 0000005fH
  0021d	73		 DB	 115			; 00000073H
  0021e	69		 DB	 105			; 00000069H
  0021f	7a		 DB	 122			; 0000007aH
  00220	65		 DB	 101			; 00000065H
  00221	00		 DB	 0
?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ENDP ; InputTextCalcTextSizeW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextCalcTextLenAndLineCount@@YAHPBDPAPBD@Z
_TEXT	SEGMENT
_c$1 = -29						; size = 1
_s$ = -20						; size = 4
_line_count$ = -8					; size = 4
_text_begin$ = 8					; size = 4
_out_text_end$ = 12					; size = 4
?InputTextCalcTextLenAndLineCount@@YAHPBDPAPBD@Z PROC	; InputTextCalcTextLenAndLineCount, COMDAT

; 3095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3096 :     int line_count = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _line_count$[ebp], 0

; 3097 :     const char* s = text_begin;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _text_begin$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR _s$[ebp], eax
$LN2@InputTextC:

; 3098 :     while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding

  00035	8b 45 ec	 mov	 eax, DWORD PTR _s$[ebp]
  00038	8a 08		 mov	 cl, BYTE PTR [eax]
  0003a	88 4d e3	 mov	 BYTE PTR _c$1[ebp], cl
  0003d	8b 55 ec	 mov	 edx, DWORD PTR _s$[ebp]
  00040	83 c2 01	 add	 edx, 1
  00043	89 55 ec	 mov	 DWORD PTR _s$[ebp], edx
  00046	0f be 45 e3	 movsx	 eax, BYTE PTR _c$1[ebp]
  0004a	85 c0		 test	 eax, eax
  0004c	74 14		 je	 SHORT $LN3@InputTextC

; 3099 :         if (c == '\n')

  0004e	0f be 45 e3	 movsx	 eax, BYTE PTR _c$1[ebp]
  00052	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00055	75 09		 jne	 SHORT $LN4@InputTextC

; 3100 :             line_count++;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _line_count$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 f8	 mov	 DWORD PTR _line_count$[ebp], eax
$LN4@InputTextC:
  00060	eb d3		 jmp	 SHORT $LN2@InputTextC
$LN3@InputTextC:

; 3101 :     s--;

  00062	8b 45 ec	 mov	 eax, DWORD PTR _s$[ebp]
  00065	83 e8 01	 sub	 eax, 1
  00068	89 45 ec	 mov	 DWORD PTR _s$[ebp], eax

; 3102 :     if (s[0] != '\n' && s[0] != '\r')

  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	6b c8 00	 imul	 ecx, eax, 0
  00073	8b 55 ec	 mov	 edx, DWORD PTR _s$[ebp]
  00076	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0007a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0007d	74 1d		 je	 SHORT $LN5@InputTextC
  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	6b c8 00	 imul	 ecx, eax, 0
  00087	8b 55 ec	 mov	 edx, DWORD PTR _s$[ebp]
  0008a	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0008e	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00091	74 09		 je	 SHORT $LN5@InputTextC

; 3103 :         line_count++;

  00093	8b 45 f8	 mov	 eax, DWORD PTR _line_count$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 f8	 mov	 DWORD PTR _line_count$[ebp], eax
$LN5@InputTextC:

; 3104 :     *out_text_end = s;

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _out_text_end$[ebp]
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _s$[ebp]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx

; 3105 :     return line_count;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _line_count$[ebp]

; 3106 : }

  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000b0	3b ec		 cmp	 ebp, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?InputTextCalcTextLenAndLineCount@@YAHPBDPAPBD@Z ENDP	; InputTextCalcTextLenAndLineCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z
_TEXT	SEGMENT
tv76 = -280						; size = 4
tv69 = -280						; size = 4
_callback_data$1 = -80					; size = 48
_pass$2 = -21						; size = 1
_c$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p_char$ = 8						; size = 4
_flags$ = 12						; size = 4
_callback$ = 16						; size = 4
_user_data$ = 20					; size = 4
?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z PROC ; InputTextFilterCharacter, COMDAT

; 3322 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3323 :     unsigned int c = *p_char;

  00032	8b 45 08	 mov	 eax, DWORD PTR _p_char$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 4d f4	 mov	 DWORD PTR _c$[ebp], ecx

; 3324 : 
; 3325 :     // Filter non-printable (NB: isprint is unreliable! see #2467)
; 3326 :     if (c < 0x20)

  0003a	83 7d f4 20	 cmp	 DWORD PTR _c$[ebp], 32	; 00000020H
  0003e	73 79		 jae	 SHORT $LN2@InputTextF

; 3327 :     {
; 3328 :         bool pass = false;

  00040	c6 45 eb 00	 mov	 BYTE PTR _pass$2[ebp], 0

; 3329 :         pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));

  00044	83 7d f4 0a	 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  00048	75 16		 jne	 SHORT $LN27@InputTextF
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0004d	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00052	74 0c		 je	 SHORT $LN27@InputTextF
  00054	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  0005e	eb 0a		 jmp	 SHORT $LN28@InputTextF
$LN27@InputTextF:
  00060	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN28@InputTextF:
  0006a	0f b6 4d eb	 movzx	 ecx, BYTE PTR _pass$2[ebp]
  0006e	0b 8d e8 fe ff
	ff		 or	 ecx, DWORD PTR tv69[ebp]
  00074	88 4d eb	 mov	 BYTE PTR _pass$2[ebp], cl

; 3330 :         pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));

  00077	83 7d f4 09	 cmp	 DWORD PTR _c$[ebp], 9
  0007b	75 16		 jne	 SHORT $LN29@InputTextF
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00080	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00085	74 0c		 je	 SHORT $LN29@InputTextF
  00087	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv76[ebp], 1
  00091	eb 0a		 jmp	 SHORT $LN30@InputTextF
$LN29@InputTextF:
  00093	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN30@InputTextF:
  0009d	0f b6 4d eb	 movzx	 ecx, BYTE PTR _pass$2[ebp]
  000a1	0b 8d e8 fe ff
	ff		 or	 ecx, DWORD PTR tv76[ebp]
  000a7	88 4d eb	 mov	 BYTE PTR _pass$2[ebp], cl

; 3331 :         if (!pass)

  000aa	0f b6 45 eb	 movzx	 eax, BYTE PTR _pass$2[ebp]
  000ae	85 c0		 test	 eax, eax
  000b0	75 07		 jne	 SHORT $LN2@InputTextF

; 3332 :             return false;

  000b2	32 c0		 xor	 al, al
  000b4	e9 aa 01 00 00	 jmp	 $LN1@InputTextF
$LN2@InputTextF:

; 3333 :     }
; 3334 : 
; 3335 :     // We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)
; 3336 :     if (c == 127)

  000b9	83 7d f4 7f	 cmp	 DWORD PTR _c$[ebp], 127	; 0000007fH
  000bd	75 07		 jne	 SHORT $LN4@InputTextF

; 3337 :         return false;

  000bf	32 c0		 xor	 al, al
  000c1	e9 9d 01 00 00	 jmp	 $LN1@InputTextF
$LN4@InputTextF:

; 3338 : 
; 3339 :     // Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
; 3340 :     if (c >= 0xE000 && c <= 0xF8FF)

  000c6	81 7d f4 00 e0
	00 00		 cmp	 DWORD PTR _c$[ebp], 57344 ; 0000e000H
  000cd	72 10		 jb	 SHORT $LN5@InputTextF
  000cf	81 7d f4 ff f8
	00 00		 cmp	 DWORD PTR _c$[ebp], 63743 ; 0000f8ffH
  000d6	77 07		 ja	 SHORT $LN5@InputTextF

; 3341 :         return false;

  000d8	32 c0		 xor	 al, al
  000da	e9 84 01 00 00	 jmp	 $LN1@InputTextF
$LN5@InputTextF:

; 3342 : 
; 3343 :     // Filter Unicode ranges we are not handling in this build.
; 3344 :     if (c > IM_UNICODE_CODEPOINT_MAX)

  000df	81 7d f4 ff ff
	00 00		 cmp	 DWORD PTR _c$[ebp], 65535 ; 0000ffffH
  000e6	76 07		 jbe	 SHORT $LN6@InputTextF

; 3345 :         return false;

  000e8	32 c0		 xor	 al, al
  000ea	e9 74 01 00 00	 jmp	 $LN1@InputTextF
$LN6@InputTextF:

; 3346 : 
; 3347 :     // Generic named filters
; 3348 :     if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))

  000ef	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  000f2	25 0f 00 02 00	 and	 eax, 131087		; 0002000fH
  000f7	0f 84 f7 00 00
	00		 je	 $LN7@InputTextF

; 3349 :     {
; 3350 :         if (flags & ImGuiInputTextFlags_CharsDecimal)

  000fd	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00100	83 e0 01	 and	 eax, 1
  00103	74 31		 je	 SHORT $LN8@InputTextF

; 3351 :             if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))

  00105	83 7d f4 30	 cmp	 DWORD PTR _c$[ebp], 48	; 00000030H
  00109	72 06		 jb	 SHORT $LN10@InputTextF
  0010b	83 7d f4 39	 cmp	 DWORD PTR _c$[ebp], 57	; 00000039H
  0010f	76 25		 jbe	 SHORT $LN8@InputTextF
$LN10@InputTextF:
  00111	83 7d f4 2e	 cmp	 DWORD PTR _c$[ebp], 46	; 0000002eH
  00115	74 1f		 je	 SHORT $LN8@InputTextF
  00117	83 7d f4 2d	 cmp	 DWORD PTR _c$[ebp], 45	; 0000002dH
  0011b	74 19		 je	 SHORT $LN8@InputTextF
  0011d	83 7d f4 2b	 cmp	 DWORD PTR _c$[ebp], 43	; 0000002bH
  00121	74 13		 je	 SHORT $LN8@InputTextF
  00123	83 7d f4 2a	 cmp	 DWORD PTR _c$[ebp], 42	; 0000002aH
  00127	74 0d		 je	 SHORT $LN8@InputTextF
  00129	83 7d f4 2f	 cmp	 DWORD PTR _c$[ebp], 47	; 0000002fH
  0012d	74 07		 je	 SHORT $LN8@InputTextF

; 3352 :                 return false;

  0012f	32 c0		 xor	 al, al
  00131	e9 2d 01 00 00	 jmp	 $LN1@InputTextF
$LN8@InputTextF:

; 3353 : 
; 3354 :         if (flags & ImGuiInputTextFlags_CharsScientific)

  00136	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00139	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  0013e	74 3d		 je	 SHORT $LN11@InputTextF

; 3355 :             if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))

  00140	83 7d f4 30	 cmp	 DWORD PTR _c$[ebp], 48	; 00000030H
  00144	72 06		 jb	 SHORT $LN13@InputTextF
  00146	83 7d f4 39	 cmp	 DWORD PTR _c$[ebp], 57	; 00000039H
  0014a	76 31		 jbe	 SHORT $LN11@InputTextF
$LN13@InputTextF:
  0014c	83 7d f4 2e	 cmp	 DWORD PTR _c$[ebp], 46	; 0000002eH
  00150	74 2b		 je	 SHORT $LN11@InputTextF
  00152	83 7d f4 2d	 cmp	 DWORD PTR _c$[ebp], 45	; 0000002dH
  00156	74 25		 je	 SHORT $LN11@InputTextF
  00158	83 7d f4 2b	 cmp	 DWORD PTR _c$[ebp], 43	; 0000002bH
  0015c	74 1f		 je	 SHORT $LN11@InputTextF
  0015e	83 7d f4 2a	 cmp	 DWORD PTR _c$[ebp], 42	; 0000002aH
  00162	74 19		 je	 SHORT $LN11@InputTextF
  00164	83 7d f4 2f	 cmp	 DWORD PTR _c$[ebp], 47	; 0000002fH
  00168	74 13		 je	 SHORT $LN11@InputTextF
  0016a	83 7d f4 65	 cmp	 DWORD PTR _c$[ebp], 101	; 00000065H
  0016e	74 0d		 je	 SHORT $LN11@InputTextF
  00170	83 7d f4 45	 cmp	 DWORD PTR _c$[ebp], 69	; 00000045H
  00174	74 07		 je	 SHORT $LN11@InputTextF

; 3356 :                 return false;

  00176	32 c0		 xor	 al, al
  00178	e9 e6 00 00 00	 jmp	 $LN1@InputTextF
$LN11@InputTextF:

; 3357 : 
; 3358 :         if (flags & ImGuiInputTextFlags_CharsHexadecimal)

  0017d	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00180	83 e0 02	 and	 eax, 2
  00183	74 2b		 je	 SHORT $LN14@InputTextF

; 3359 :             if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))

  00185	83 7d f4 30	 cmp	 DWORD PTR _c$[ebp], 48	; 00000030H
  00189	72 06		 jb	 SHORT $LN16@InputTextF
  0018b	83 7d f4 39	 cmp	 DWORD PTR _c$[ebp], 57	; 00000039H
  0018f	76 1f		 jbe	 SHORT $LN14@InputTextF
$LN16@InputTextF:
  00191	83 7d f4 61	 cmp	 DWORD PTR _c$[ebp], 97	; 00000061H
  00195	72 06		 jb	 SHORT $LN17@InputTextF
  00197	83 7d f4 66	 cmp	 DWORD PTR _c$[ebp], 102	; 00000066H
  0019b	76 13		 jbe	 SHORT $LN14@InputTextF
$LN17@InputTextF:
  0019d	83 7d f4 41	 cmp	 DWORD PTR _c$[ebp], 65	; 00000041H
  001a1	72 06		 jb	 SHORT $LN18@InputTextF
  001a3	83 7d f4 46	 cmp	 DWORD PTR _c$[ebp], 70	; 00000046H
  001a7	76 07		 jbe	 SHORT $LN14@InputTextF
$LN18@InputTextF:

; 3360 :                 return false;

  001a9	32 c0		 xor	 al, al
  001ab	e9 b3 00 00 00	 jmp	 $LN1@InputTextF
$LN14@InputTextF:

; 3361 : 
; 3362 :         if (flags & ImGuiInputTextFlags_CharsUppercase)

  001b0	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  001b3	83 e0 04	 and	 eax, 4
  001b6	74 1d		 je	 SHORT $LN19@InputTextF

; 3363 :             if (c >= 'a' && c <= 'z')

  001b8	83 7d f4 61	 cmp	 DWORD PTR _c$[ebp], 97	; 00000061H
  001bc	72 17		 jb	 SHORT $LN19@InputTextF
  001be	83 7d f4 7a	 cmp	 DWORD PTR _c$[ebp], 122	; 0000007aH
  001c2	77 11		 ja	 SHORT $LN19@InputTextF

; 3364 :                 *p_char = (c += (unsigned int)('A'-'a'));

  001c4	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  001c7	83 e8 20	 sub	 eax, 32			; 00000020H
  001ca	89 45 f4	 mov	 DWORD PTR _c$[ebp], eax
  001cd	8b 4d 08	 mov	 ecx, DWORD PTR _p_char$[ebp]
  001d0	8b 55 f4	 mov	 edx, DWORD PTR _c$[ebp]
  001d3	89 11		 mov	 DWORD PTR [ecx], edx
$LN19@InputTextF:

; 3365 : 
; 3366 :         if (flags & ImGuiInputTextFlags_CharsNoBlank)

  001d5	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  001d8	83 e0 08	 and	 eax, 8
  001db	74 17		 je	 SHORT $LN7@InputTextF

; 3367 :             if (ImCharIsBlankW(c))

  001dd	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 ?ImCharIsBlankW@@YA_NI@Z ; ImCharIsBlankW
  001e6	83 c4 04	 add	 esp, 4
  001e9	0f b6 c8	 movzx	 ecx, al
  001ec	85 c9		 test	 ecx, ecx
  001ee	74 04		 je	 SHORT $LN7@InputTextF

; 3368 :                 return false;

  001f0	32 c0		 xor	 al, al
  001f2	eb 6f		 jmp	 SHORT $LN1@InputTextF
$LN7@InputTextF:

; 3369 :     }
; 3370 : 
; 3371 :     // Custom callback filter
; 3372 :     if (flags & ImGuiInputTextFlags_CallbackCharFilter)

  001f4	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  001f7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  001fc	74 63		 je	 SHORT $LN23@InputTextF

; 3373 :     {
; 3374 :         ImGuiInputTextCallbackData callback_data;

  001fe	8d 4d b0	 lea	 ecx, DWORD PTR _callback_data$1[ebp]
  00201	e8 00 00 00 00	 call	 ??0ImGuiInputTextCallbackData@@QAE@XZ ; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData

; 3375 :         memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));

  00206	6a 30		 push	 48			; 00000030H
  00208	6a 00		 push	 0
  0020a	8d 45 b0	 lea	 eax, DWORD PTR _callback_data$1[ebp]
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 _memset
  00213	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3376 :         callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;

  00216	c7 45 b0 00 02
	00 00		 mov	 DWORD PTR _callback_data$1[ebp], 512 ; 00000200H

; 3377 :         callback_data.EventChar = (ImWchar)c;

  0021d	66 8b 45 f4	 mov	 ax, WORD PTR _c$[ebp]
  00221	66 89 45 bc	 mov	 WORD PTR _callback_data$1[ebp+12], ax

; 3378 :         callback_data.Flags = flags;

  00225	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00228	89 45 b4	 mov	 DWORD PTR _callback_data$1[ebp+4], eax

; 3379 :         callback_data.UserData = user_data;

  0022b	8b 45 14	 mov	 eax, DWORD PTR _user_data$[ebp]
  0022e	89 45 b8	 mov	 DWORD PTR _callback_data$1[ebp+8], eax

; 3380 :         if (callback(&callback_data) != 0)

  00231	8b f4		 mov	 esi, esp
  00233	8d 45 b0	 lea	 eax, DWORD PTR _callback_data$1[ebp]
  00236	50		 push	 eax
  00237	ff 55 10	 call	 DWORD PTR _callback$[ebp]
  0023a	83 c4 04	 add	 esp, 4
  0023d	3b f4		 cmp	 esi, esp
  0023f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00244	85 c0		 test	 eax, eax
  00246	74 04		 je	 SHORT $LN24@InputTextF

; 3381 :             return false;

  00248	32 c0		 xor	 al, al
  0024a	eb 17		 jmp	 SHORT $LN1@InputTextF
$LN24@InputTextF:

; 3382 :         *p_char = callback_data.EventChar;

  0024c	0f b7 45 bc	 movzx	 eax, WORD PTR _callback_data$1[ebp+12]
  00250	8b 4d 08	 mov	 ecx, DWORD PTR _p_char$[ebp]
  00253	89 01		 mov	 DWORD PTR [ecx], eax

; 3383 :         if (!callback_data.EventChar)

  00255	0f b7 45 bc	 movzx	 eax, WORD PTR _callback_data$1[ebp+12]
  00259	85 c0		 test	 eax, eax
  0025b	75 04		 jne	 SHORT $LN23@InputTextF

; 3384 :             return false;

  0025d	32 c0		 xor	 al, al
  0025f	eb 02		 jmp	 SHORT $LN1@InputTextF
$LN23@InputTextF:

; 3385 :     }
; 3386 : 
; 3387 :     return true;

  00261	b0 01		 mov	 al, 1
$LN1@InputTextF:

; 3388 : }

  00263	52		 push	 edx
  00264	8b cd		 mov	 ecx, ebp
  00266	50		 push	 eax
  00267	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN33@InputTextF
  0026d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00272	58		 pop	 eax
  00273	5a		 pop	 edx
  00274	5f		 pop	 edi
  00275	5e		 pop	 esi
  00276	5b		 pop	 ebx
  00277	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027a	33 cd		 xor	 ecx, ebp
  0027c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00281	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00287	3b ec		 cmp	 ebp, esp
  00289	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
  00292	66 90		 npad	 2
$LN33@InputTextF:
  00294	01 00 00 00	 DD	 1
  00298	00 00 00 00	 DD	 $LN32@InputTextF
$LN32@InputTextF:
  0029c	b0 ff ff ff	 DD	 -80			; ffffffb0H
  002a0	30 00 00 00	 DD	 48			; 00000030H
  002a4	00 00 00 00	 DD	 $LN31@InputTextF
$LN31@InputTextF:
  002a8	63		 DB	 99			; 00000063H
  002a9	61		 DB	 97			; 00000061H
  002aa	6c		 DB	 108			; 0000006cH
  002ab	6c		 DB	 108			; 0000006cH
  002ac	62		 DB	 98			; 00000062H
  002ad	61		 DB	 97			; 00000061H
  002ae	63		 DB	 99			; 00000063H
  002af	6b		 DB	 107			; 0000006bH
  002b0	5f		 DB	 95			; 0000005fH
  002b1	64		 DB	 100			; 00000064H
  002b2	61		 DB	 97			; 00000061H
  002b3	74		 DB	 116			; 00000074H
  002b4	61		 DB	 97			; 00000061H
  002b5	00		 DB	 0
?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ENDP ; InputTextFilterCharacter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z
_TEXT	SEGMENT
tv320 = -1056						; size = 4
tv728 = -1052						; size = 4
tv682 = -1052						; size = 4
tv425 = -1052						; size = 4
tv380 = -1052						; size = 4
tv371 = -1052						; size = 4
tv330 = -1052						; size = 4
tv325 = -1052						; size = 4
tv321 = -1052						; size = 4
tv301 = -1052						; size = 4
tv238 = -1052						; size = 4
tv235 = -1052						; size = 4
tv228 = -1052						; size = 4
tv151 = -1052						; size = 4
$T1 = -1044						; size = 8
$T2 = -1028						; size = 8
$T3 = -1012						; size = 8
$T4 = -996						; size = 8
$T5 = -980						; size = 8
$T6 = -964						; size = 4
$T7 = -952						; size = 8
$T8 = -936						; size = 8
$T9 = -920						; size = 8
$T10 = -904						; size = 8
$T11 = -888						; size = 8
_pos1$12 = -488						; size = 8
_pos0$13 = -472						; size = 8
_tp1$14 = -456						; size = 8
_v1$15 = -440						; size = 4
_v1_idx$16 = -428					; size = 4
_t1$17 = -416						; size = 4
_n$18 = -404						; size = 4
_col_hovered$19 = -392					; size = 4
_col_base$20 = -380					; size = 4
_histogram_zero_line_t$21 = -368			; size = 4
_tp0$22 = -356						; size = 8
_t0$23 = -340						; size = 4
_v0$24 = -328						; size = 4
_inv_scale$25 = -316					; size = 4
_t_step$26 = -304					; size = 4
_v1$27 = -292						; size = 4
_v0$28 = -280						; size = 4
_v_idx$29 = -268					; size = 4
_t$30 = -256						; size = 4
_v_hovered$31 = -244					; size = 4
_item_count$32 = -232					; size = 4
_res_w$33 = -220					; size = 4
_values_count_min$ = -208				; size = 4
_v$34 = -196						; size = 4
_i$35 = -184						; size = 4
_v_max$36 = -172					; size = 4
_v_min$37 = -160					; size = 4
_hovered$ = -145					; size = 1
_total_bb$ = -136					; size = 16
_inner_bb$ = -112					; size = 16
_frame_bb$ = -88					; size = 16
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_plot_type$ = 8						; size = 4
_label$ = 12						; size = 4
_values_getter$ = 16					; size = 4
_data$ = 20						; size = 4
_values_count$ = 24					; size = 4
_values_offset$ = 28					; size = 4
_overlay_text$ = 32					; size = 4
_scale_min$ = 36					; size = 4
_scale_max$ = 40					; size = 4
_frame_size$ = 44					; size = 8
?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z PROC ; ImGui::PlotEx, COMDAT

; 5770 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1056]
  00012	b9 08 01 00 00	 mov	 ecx, 264		; 00000108H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5771 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 5772 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN8@PlotEx

; 5773 :         return;

  00045	e9 00 0b 00 00	 jmp	 $LN1@PlotEx
$LN8@PlotEx:

; 5774 : 
; 5775 :     ImGuiContext& g = *GImGui;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004f	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 5776 :     const ImGuiStyle& style = g.Style;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00055	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005a	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 5777 :     const ImGuiID id = window->GetID(label);

  0005d	6a 00		 push	 0
  0005f	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00066	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0006b	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 5778 : 
; 5779 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  0006e	51		 push	 ecx
  0006f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	6a 01		 push	 1
  0007e	6a 00		 push	 0
  00080	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  00083	50		 push	 eax
  00084	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0008d	83 c4 14	 add	 esp, 20			; 00000014H

; 5780 :     if (frame_size.x == 0.0f)

  00090	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _frame_size$[ebp]
  00095	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0009c	9f		 lahf
  0009d	f6 c4 44	 test	 ah, 68			; 00000044H
  000a0	7a 08		 jp	 SHORT $LN9@PlotEx

; 5781 :         frame_size.x = CalcItemWidth();

  000a2	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  000a7	d9 5d 2c	 fstp	 DWORD PTR _frame_size$[ebp]
$LN9@PlotEx:

; 5782 :     if (frame_size.y == 0.0f)

  000aa	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _frame_size$[ebp+4]
  000af	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000b6	9f		 lahf
  000b7	f6 c4 44	 test	 ah, 68			; 00000044H
  000ba	7a 1a		 jp	 SHORT $LN10@PlotEx

; 5783 :         frame_size.y = label_size.y + (style.FramePadding.y * 2);

  000bc	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000bf	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  000c4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000cc	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000d1	f3 0f 11 45 30	 movss	 DWORD PTR _frame_size$[ebp+4], xmm0
$LN10@PlotEx:

; 5784 : 
; 5785 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);

  000d6	8d 45 2c	 lea	 eax, DWORD PTR _frame_size$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000dd	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  000e3	51		 push	 ecx
  000e4	8d 95 88 fc ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f3	50		 push	 eax
  000f4	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000f7	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000fc	50		 push	 eax
  000fd	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00100	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 5786 :     const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);

  00105	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00108	83 c0 38	 add	 eax, 56			; 00000038H
  0010b	50		 push	 eax
  0010c	8d 4d b0	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  0010f	51		 push	 ecx
  00110	8d 95 78 fc ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	50		 push	 eax
  00120	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00123	83 c0 38	 add	 eax, 56			; 00000038H
  00126	50		 push	 eax
  00127	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  0012a	51		 push	 ecx
  0012b	8d 95 68 fc ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013a	50		 push	 eax
  0013b	8d 4d 90	 lea	 ecx, DWORD PTR _inner_bb$[ebp]
  0013e	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 5787 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));

  00143	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00148	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0014f	76 17		 jbe	 SHORT $LN29@PlotEx
  00151	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00154	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00159	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  0015e	f3 0f 11 85 e4
	fb ff ff	 movss	 DWORD PTR tv151[ebp], xmm0
  00166	eb 0b		 jmp	 SHORT $LN30@PlotEx
$LN29@PlotEx:
  00168	0f 57 c0	 xorps	 xmm0, xmm0
  0016b	f3 0f 11 85 e4
	fb ff ff	 movss	 DWORD PTR tv151[ebp], xmm0
$LN30@PlotEx:
  00173	51		 push	 ecx
  00174	0f 57 c0	 xorps	 xmm0, xmm0
  00177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017c	51		 push	 ecx
  0017d	f3 0f 10 85 e4
	fb ff ff	 movss	 xmm0, DWORD PTR tv151[ebp]
  00185	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018a	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00190	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00195	50		 push	 eax
  00196	8d 4d b0	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  00199	51		 push	 ecx
  0019a	8d 95 48 fc ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  001a0	52		 push	 edx
  001a1	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a9	50		 push	 eax
  001aa	8d 45 a8	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  001ad	50		 push	 eax
  001ae	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  001b4	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 5788 :     ItemSize(total_bb, style.FramePadding.y);

  001b9	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  001bc	51		 push	 ecx
  001bd	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  001c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c7	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  001cd	51		 push	 ecx
  001ce	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  001d3	83 c4 08	 add	 esp, 8

; 5789 :     if (!ItemAdd(total_bb, 0, &frame_bb))

  001d6	8d 45 a8	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  001d9	50		 push	 eax
  001da	6a 00		 push	 0
  001dc	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001eb	0f b6 d0	 movzx	 edx, al
  001ee	85 d2		 test	 edx, edx
  001f0	75 05		 jne	 SHORT $LN11@PlotEx

; 5790 :         return;

  001f2	e9 53 09 00 00	 jmp	 $LN1@PlotEx
$LN11@PlotEx:

; 5791 :     const bool hovered = ItemHoverable(frame_bb, id);

  001f7	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  001fa	50		 push	 eax
  001fb	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  001fe	51		 push	 ecx
  001ff	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z ; ImGui::ItemHoverable
  00204	83 c4 08	 add	 esp, 8
  00207	88 85 6f ff ff
	ff		 mov	 BYTE PTR _hovered$[ebp], al

; 5792 : 
; 5793 :     // Determine scale from values if not specified
; 5794 :     if (scale_min == FLT_MAX || scale_max == FLT_MAX)

  0020d	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  00212	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  00219	9f		 lahf
  0021a	f6 c4 44	 test	 ah, 68			; 00000044H
  0021d	7b 16		 jnp	 SHORT $LN13@PlotEx
  0021f	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _scale_max$[ebp]
  00224	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  0022b	9f		 lahf
  0022c	f6 c4 44	 test	 ah, 68			; 00000044H
  0022f	0f 8a 18 01 00
	00		 jp	 $LN16@PlotEx
$LN13@PlotEx:

; 5795 :     {
; 5796 :         float v_min = FLT_MAX;

  00235	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  0023d	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _v_min$37[ebp], xmm0

; 5797 :         float v_max = -FLT_MAX;

  00245	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  0024d	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _v_max$36[ebp], xmm0

; 5798 :         for (int i = 0; i < values_count; i++)

  00255	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$35[ebp], 0
  0025f	eb 0f		 jmp	 SHORT $LN4@PlotEx
$LN2@PlotEx:
  00261	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  00267	83 c0 01	 add	 eax, 1
  0026a	89 85 48 ff ff
	ff		 mov	 DWORD PTR _i$35[ebp], eax
$LN4@PlotEx:
  00270	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  00276	3b 45 18	 cmp	 eax, DWORD PTR _values_count$[ebp]
  00279	0f 8d 90 00 00
	00		 jge	 $LN3@PlotEx

; 5799 :         {
; 5800 :             const float v = values_getter(data, i);

  0027f	8b f4		 mov	 esi, esp
  00281	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  00287	50		 push	 eax
  00288	8b 4d 14	 mov	 ecx, DWORD PTR _data$[ebp]
  0028b	51		 push	 ecx
  0028c	ff 55 10	 call	 DWORD PTR _values_getter$[ebp]
  0028f	83 c4 08	 add	 esp, 8
  00292	3b f4		 cmp	 esi, esp
  00294	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00299	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR _v$34[ebp]

; 5801 :             if (v != v) // Ignore NaN values

  0029f	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _v$34[ebp]
  002a7	0f 2e 85 3c ff
	ff ff		 ucomiss xmm0, DWORD PTR _v$34[ebp]
  002ae	9f		 lahf
  002af	f6 c4 44	 test	 ah, 68			; 00000044H
  002b2	7b 02		 jnp	 SHORT $LN14@PlotEx

; 5802 :                 continue;

  002b4	eb ab		 jmp	 SHORT $LN2@PlotEx
$LN14@PlotEx:

; 5803 :             v_min = ImMin(v_min, v);

  002b6	51		 push	 ecx
  002b7	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _v$34[ebp]
  002bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c4	51		 push	 ecx
  002c5	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _v_min$37[ebp]
  002cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d2	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  002d7	83 c4 08	 add	 esp, 8
  002da	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR _v_min$37[ebp]

; 5804 :             v_max = ImMax(v_max, v);

  002e0	51		 push	 ecx
  002e1	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _v$34[ebp]
  002e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ee	51		 push	 ecx
  002ef	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _v_max$36[ebp]
  002f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fc	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00301	83 c4 08	 add	 esp, 8
  00304	d9 9d 54 ff ff
	ff		 fstp	 DWORD PTR _v_max$36[ebp]

; 5805 :         }

  0030a	e9 52 ff ff ff	 jmp	 $LN2@PlotEx
$LN3@PlotEx:

; 5806 :         if (scale_min == FLT_MAX)

  0030f	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  00314	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  0031b	9f		 lahf
  0031c	f6 c4 44	 test	 ah, 68			; 00000044H
  0031f	7a 0d		 jp	 SHORT $LN15@PlotEx

; 5807 :             scale_min = v_min;

  00321	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _v_min$37[ebp]
  00329	f3 0f 11 45 24	 movss	 DWORD PTR _scale_min$[ebp], xmm0
$LN15@PlotEx:

; 5808 :         if (scale_max == FLT_MAX)

  0032e	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _scale_max$[ebp]
  00333	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@7f7fffff
  0033a	9f		 lahf
  0033b	f6 c4 44	 test	 ah, 68			; 00000044H
  0033e	7a 0d		 jp	 SHORT $LN16@PlotEx

; 5809 :             scale_max = v_max;

  00340	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _v_max$36[ebp]
  00348	f3 0f 11 45 28	 movss	 DWORD PTR _scale_max$[ebp], xmm0
$LN16@PlotEx:

; 5810 :     }
; 5811 : 
; 5812 :     RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

  0034d	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00350	51		 push	 ecx
  00351	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00356	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035b	6a 01		 push	 1
  0035d	51		 push	 ecx
  0035e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00366	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036b	6a 07		 push	 7
  0036d	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00372	83 c4 08	 add	 esp, 8
  00375	50		 push	 eax
  00376	8b 4d b4	 mov	 ecx, DWORD PTR _frame_bb$[ebp+12]
  00379	51		 push	 ecx
  0037a	8b 55 b0	 mov	 edx, DWORD PTR _frame_bb$[ebp+8]
  0037d	52		 push	 edx
  0037e	8b 45 ac	 mov	 eax, DWORD PTR _frame_bb$[ebp+4]
  00381	50		 push	 eax
  00382	8b 4d a8	 mov	 ecx, DWORD PTR _frame_bb$[ebp]
  00385	51		 push	 ecx
  00386	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  0038b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5813 : 
; 5814 :     const int values_count_min = (plot_type == ImGuiPlotType_Lines) ? 2 : 1;

  0038e	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  00392	75 0c		 jne	 SHORT $LN31@PlotEx
  00394	c7 85 e4 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR tv228[ebp], 2
  0039e	eb 0a		 jmp	 SHORT $LN32@PlotEx
$LN31@PlotEx:
  003a0	c7 85 e4 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv228[ebp], 1
$LN32@PlotEx:
  003aa	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR tv228[ebp]
  003b0	89 85 30 ff ff
	ff		 mov	 DWORD PTR _values_count_min$[ebp], eax

; 5815 :     if (values_count >= values_count_min)

  003b6	8b 45 18	 mov	 eax, DWORD PTR _values_count$[ebp]
  003b9	3b 85 30 ff ff
	ff		 cmp	 eax, DWORD PTR _values_count_min$[ebp]
  003bf	0f 8c ce 06 00
	00		 jl	 $LN6@PlotEx

; 5816 :     {
; 5817 :         int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

  003c5	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  003c9	75 0c		 jne	 SHORT $LN33@PlotEx
  003cb	c7 85 e4 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR tv235[ebp], -1
  003d5	eb 0a		 jmp	 SHORT $LN34@PlotEx
$LN33@PlotEx:
  003d7	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
$LN34@PlotEx:
  003e1	8b 45 18	 mov	 eax, DWORD PTR _values_count$[ebp]
  003e4	50		 push	 eax
  003e5	f3 0f 2c 4d 2c	 cvttss2si ecx, DWORD PTR _frame_size$[ebp]
  003ea	51		 push	 ecx
  003eb	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  003f0	83 c4 08	 add	 esp, 8
  003f3	03 85 e4 fb ff
	ff		 add	 eax, DWORD PTR tv235[ebp]
  003f9	89 85 24 ff ff
	ff		 mov	 DWORD PTR _res_w$33[ebp], eax

; 5818 :         int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

  003ff	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  00403	75 0c		 jne	 SHORT $LN35@PlotEx
  00405	c7 85 e4 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR tv238[ebp], -1
  0040f	eb 0a		 jmp	 SHORT $LN36@PlotEx
$LN35@PlotEx:
  00411	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv238[ebp], 0
$LN36@PlotEx:
  0041b	8b 45 18	 mov	 eax, DWORD PTR _values_count$[ebp]
  0041e	03 85 e4 fb ff
	ff		 add	 eax, DWORD PTR tv238[ebp]
  00424	89 85 18 ff ff
	ff		 mov	 DWORD PTR _item_count$32[ebp], eax

; 5819 : 
; 5820 :         // Tooltip on hover
; 5821 :         int v_hovered = -1;

  0042a	c7 85 0c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _v_hovered$31[ebp], -1

; 5822 :         if (hovered && inner_bb.Contains(g.IO.MousePos))

  00434	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  0043b	85 c0		 test	 eax, eax
  0043d	0f 84 87 01 00
	00		 je	 $LN18@PlotEx
  00443	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00446	05 e8 00 00 00	 add	 eax, 232		; 000000e8H
  0044b	50		 push	 eax
  0044c	8d 4d 90	 lea	 ecx, DWORD PTR _inner_bb$[ebp]
  0044f	e8 00 00 00 00	 call	 ?Contains@ImRect@@QBE_NABUImVec2@@@Z ; ImRect::Contains
  00454	0f b6 c8	 movzx	 ecx, al
  00457	85 c9		 test	 ecx, ecx
  00459	0f 84 6b 01 00
	00		 je	 $LN18@PlotEx

; 5823 :         {
; 5824 :             const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);

  0045f	51		 push	 ecx
  00460	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ff972
  00468	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0046d	51		 push	 ecx
  0046e	0f 57 c0	 xorps	 xmm0, xmm0
  00471	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00476	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00479	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+232]
  00481	f3 0f 5c 45 90	 subss	 xmm0, DWORD PTR _inner_bb$[ebp]
  00486	f3 0f 10 4d 98	 movss	 xmm1, DWORD PTR _inner_bb$[ebp+8]
  0048b	f3 0f 5c 4d 90	 subss	 xmm1, DWORD PTR _inner_bb$[ebp]
  00490	f3 0f 5e c1	 divss	 xmm0, xmm1
  00494	51		 push	 ecx
  00495	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0049a	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  0049f	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a2	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR _t$30[ebp]

; 5825 :             const int v_idx = (int)(t * item_count);

  004a8	f3 0f 2a 85 18
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _item_count$32[ebp]
  004b0	f3 0f 59 85 00
	ff ff ff	 mulss	 xmm0, DWORD PTR _t$30[ebp]
  004b8	f3 0f 2c c0	 cvttss2si eax, xmm0
  004bc	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _v_idx$29[ebp], eax

; 5826 :             IM_ASSERT(v_idx >= 0 && v_idx < values_count);

  004c2	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _v_idx$29[ebp], 0
  004c9	7c 0b		 jl	 SHORT $LN37@PlotEx
  004cb	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _v_idx$29[ebp]
  004d1	3b 45 18	 cmp	 eax, DWORD PTR _values_count$[ebp]
  004d4	7c 26		 jl	 SHORT $LN38@PlotEx
$LN37@PlotEx:
  004d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z@4JA
  004dc	83 c1 38	 add	 ecx, 56			; 00000038H
  004df	8b f4		 mov	 esi, esp
  004e1	51		 push	 ecx
  004e2	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  004e7	68 00 00 00 00	 push	 OFFSET ??_C@_1EG@HCGMCBDC@?$AAv?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAv@
  004ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  004f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004f5	3b f4		 cmp	 esi, esp
  004f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN38@PlotEx:

; 5827 : 
; 5828 :             const float v0 = values_getter(data, (v_idx + values_offset) % values_count);

  004fc	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _v_idx$29[ebp]
  00502	03 45 1c	 add	 eax, DWORD PTR _values_offset$[ebp]
  00505	99		 cdq
  00506	f7 7d 18	 idiv	 DWORD PTR _values_count$[ebp]
  00509	8b f4		 mov	 esi, esp
  0050b	52		 push	 edx
  0050c	8b 45 14	 mov	 eax, DWORD PTR _data$[ebp]
  0050f	50		 push	 eax
  00510	ff 55 10	 call	 DWORD PTR _values_getter$[ebp]
  00513	83 c4 08	 add	 esp, 8
  00516	3b f4		 cmp	 esi, esp
  00518	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0051d	d9 9d e8 fe ff
	ff		 fstp	 DWORD PTR _v0$28[ebp]

; 5829 :             const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);

  00523	8b 45 1c	 mov	 eax, DWORD PTR _values_offset$[ebp]
  00526	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _v_idx$29[ebp]
  0052c	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00530	99		 cdq
  00531	f7 7d 18	 idiv	 DWORD PTR _values_count$[ebp]
  00534	8b f4		 mov	 esi, esp
  00536	52		 push	 edx
  00537	8b 55 14	 mov	 edx, DWORD PTR _data$[ebp]
  0053a	52		 push	 edx
  0053b	ff 55 10	 call	 DWORD PTR _values_getter$[ebp]
  0053e	83 c4 08	 add	 esp, 8
  00541	3b f4		 cmp	 esi, esp
  00543	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00548	d9 9d dc fe ff
	ff		 fstp	 DWORD PTR _v1$27[ebp]

; 5830 :             if (plot_type == ImGuiPlotType_Lines)

  0054e	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  00552	75 40		 jne	 SHORT $LN19@PlotEx

; 5831 :                 SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);

  00554	f3 0f 5a 85 dc
	fe ff ff	 cvtss2sd xmm0, DWORD PTR _v1$27[ebp]
  0055c	83 ec 08	 sub	 esp, 8
  0055f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00564	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _v_idx$29[ebp]
  0056a	83 c0 01	 add	 eax, 1
  0056d	50		 push	 eax
  0056e	f3 0f 5a 85 e8
	fe ff ff	 cvtss2sd xmm0, DWORD PTR _v0$28[ebp]
  00576	83 ec 08	 sub	 esp, 8
  00579	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0057e	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _v_idx$29[ebp]
  00584	51		 push	 ecx
  00585	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@
  0058a	e8 00 00 00 00	 call	 ?SetTooltip@ImGui@@YAXPBDZZ ; ImGui::SetTooltip
  0058f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00592	eb 2a		 jmp	 SHORT $LN21@PlotEx
$LN19@PlotEx:

; 5832 :             else if (plot_type == ImGuiPlotType_Histogram)

  00594	83 7d 08 01	 cmp	 DWORD PTR _plot_type$[ebp], 1
  00598	75 24		 jne	 SHORT $LN21@PlotEx

; 5833 :                 SetTooltip("%d: %8.4g", v_idx, v0);

  0059a	f3 0f 5a 85 e8
	fe ff ff	 cvtss2sd xmm0, DWORD PTR _v0$28[ebp]
  005a2	83 ec 08	 sub	 esp, 8
  005a5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  005aa	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _v_idx$29[ebp]
  005b0	50		 push	 eax
  005b1	68 00 00 00 00	 push	 OFFSET ??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@
  005b6	e8 00 00 00 00	 call	 ?SetTooltip@ImGui@@YAXPBDZZ ; ImGui::SetTooltip
  005bb	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@PlotEx:

; 5834 :             v_hovered = v_idx;

  005be	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _v_idx$29[ebp]
  005c4	89 85 0c ff ff
	ff		 mov	 DWORD PTR _v_hovered$31[ebp], eax
$LN18@PlotEx:

; 5835 :         }
; 5836 : 
; 5837 :         const float t_step = 1.0f / (float)res_w;

  005ca	f3 0f 2a 85 24
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _res_w$33[ebp]
  005d2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  005da	f3 0f 5e c8	 divss	 xmm1, xmm0
  005de	f3 0f 11 8d d0
	fe ff ff	 movss	 DWORD PTR _t_step$26[ebp], xmm1

; 5838 :         const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

  005e6	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  005eb	0f 2e 45 28	 ucomiss xmm0, DWORD PTR _scale_max$[ebp]
  005ef	9f		 lahf
  005f0	f6 c4 44	 test	 ah, 68			; 00000044H
  005f3	7a 0d		 jp	 SHORT $LN39@PlotEx
  005f5	0f 57 c0	 xorps	 xmm0, xmm0
  005f8	f3 0f 11 85 e4
	fb ff ff	 movss	 DWORD PTR tv301[ebp], xmm0
  00600	eb 1e		 jmp	 SHORT $LN40@PlotEx
$LN39@PlotEx:
  00602	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _scale_max$[ebp]
  00607	f3 0f 5c 45 24	 subss	 xmm0, DWORD PTR _scale_min$[ebp]
  0060c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00614	f3 0f 5e c8	 divss	 xmm1, xmm0
  00618	f3 0f 11 8d e4
	fb ff ff	 movss	 DWORD PTR tv301[ebp], xmm1
$LN40@PlotEx:
  00620	f3 0f 10 85 e4
	fb ff ff	 movss	 xmm0, DWORD PTR tv301[ebp]
  00628	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _inv_scale$25[ebp], xmm0

; 5839 : 
; 5840 :         float v0 = values_getter(data, (0 + values_offset) % values_count);

  00630	8b 45 1c	 mov	 eax, DWORD PTR _values_offset$[ebp]
  00633	99		 cdq
  00634	f7 7d 18	 idiv	 DWORD PTR _values_count$[ebp]
  00637	8b f4		 mov	 esi, esp
  00639	52		 push	 edx
  0063a	8b 45 14	 mov	 eax, DWORD PTR _data$[ebp]
  0063d	50		 push	 eax
  0063e	ff 55 10	 call	 DWORD PTR _values_getter$[ebp]
  00641	83 c4 08	 add	 esp, 8
  00644	3b f4		 cmp	 esi, esp
  00646	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0064b	d9 9d b8 fe ff
	ff		 fstp	 DWORD PTR _v0$24[ebp]

; 5841 :         float t0 = 0.0f;

  00651	0f 57 c0	 xorps	 xmm0, xmm0
  00654	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR _t0$23[ebp], xmm0

; 5842 :         ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle

  0065c	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _v0$24[ebp]
  00664	f3 0f 5c 45 24	 subss	 xmm0, DWORD PTR _scale_min$[ebp]
  00669	f3 0f 59 85 c4
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_scale$25[ebp]
  00671	51		 push	 ecx
  00672	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00677	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0067c	83 c4 04	 add	 esp, 4
  0067f	d9 9d e4 fb ff
	ff		 fstp	 DWORD PTR tv682[ebp]
  00685	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0068d	f3 0f 5c 85 e4
	fb ff ff	 subss	 xmm0, DWORD PTR tv682[ebp]
  00695	51		 push	 ecx
  00696	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0069b	51		 push	 ecx
  0069c	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _t0$23[ebp]
  006a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006a9	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR _tp0$22[ebp]
  006af	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 5843 :         float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands

  006b4	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  006b9	f3 0f 59 45 28	 mulss	 xmm0, DWORD PTR _scale_max$[ebp]
  006be	0f 57 c9	 xorps	 xmm1, xmm1
  006c1	0f 2f c8	 comiss	 xmm1, xmm0
  006c4	76 1e		 jbe	 SHORT $LN43@PlotEx
  006c6	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  006cb	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  006d2	f3 0f 59 85 c4
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_scale$25[ebp]
  006da	f3 0f 11 85 e4
	fb ff ff	 movss	 DWORD PTR tv321[ebp], xmm0
  006e2	eb 36		 jmp	 SHORT $LN44@PlotEx
$LN43@PlotEx:
  006e4	0f 57 c0	 xorps	 xmm0, xmm0
  006e7	0f 2f 45 24	 comiss	 xmm0, DWORD PTR _scale_min$[ebp]
  006eb	76 0d		 jbe	 SHORT $LN41@PlotEx
  006ed	0f 57 c0	 xorps	 xmm0, xmm0
  006f0	f3 0f 11 85 e0
	fb ff ff	 movss	 DWORD PTR tv320[ebp], xmm0
  006f8	eb 10		 jmp	 SHORT $LN42@PlotEx
$LN41@PlotEx:
  006fa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00702	f3 0f 11 85 e0
	fb ff ff	 movss	 DWORD PTR tv320[ebp], xmm0
$LN42@PlotEx:
  0070a	f3 0f 10 85 e0
	fb ff ff	 movss	 xmm0, DWORD PTR tv320[ebp]
  00712	f3 0f 11 85 e4
	fb ff ff	 movss	 DWORD PTR tv321[ebp], xmm0
$LN44@PlotEx:
  0071a	f3 0f 10 85 e4
	fb ff ff	 movss	 xmm0, DWORD PTR tv321[ebp]
  00722	f3 0f 11 85 90
	fe ff ff	 movss	 DWORD PTR _histogram_zero_line_t$21[ebp], xmm0

; 5844 : 
; 5845 :         const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);

  0072a	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  0072e	75 0c		 jne	 SHORT $LN45@PlotEx
  00730	c7 85 e4 fb ff
	ff 26 00 00 00	 mov	 DWORD PTR tv325[ebp], 38 ; 00000026H
  0073a	eb 0a		 jmp	 SHORT $LN46@PlotEx
$LN45@PlotEx:
  0073c	c7 85 e4 fb ff
	ff 28 00 00 00	 mov	 DWORD PTR tv325[ebp], 40 ; 00000028H
$LN46@PlotEx:
  00746	51		 push	 ecx
  00747	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0074f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00754	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR tv325[ebp]
  0075a	50		 push	 eax
  0075b	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00760	83 c4 08	 add	 esp, 8
  00763	89 85 84 fe ff
	ff		 mov	 DWORD PTR _col_base$20[ebp], eax

; 5846 :         const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

  00769	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  0076d	75 0c		 jne	 SHORT $LN47@PlotEx
  0076f	c7 85 e4 fb ff
	ff 27 00 00 00	 mov	 DWORD PTR tv330[ebp], 39 ; 00000027H
  00779	eb 0a		 jmp	 SHORT $LN48@PlotEx
$LN47@PlotEx:
  0077b	c7 85 e4 fb ff
	ff 29 00 00 00	 mov	 DWORD PTR tv330[ebp], 41 ; 00000029H
$LN48@PlotEx:
  00785	51		 push	 ecx
  00786	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0078e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00793	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR tv330[ebp]
  00799	50		 push	 eax
  0079a	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0079f	83 c4 08	 add	 esp, 8
  007a2	89 85 78 fe ff
	ff		 mov	 DWORD PTR _col_hovered$19[ebp], eax

; 5847 : 
; 5848 :         for (int n = 0; n < res_w; n++)

  007a8	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$18[ebp], 0
  007b2	eb 0f		 jmp	 SHORT $LN7@PlotEx
$LN5@PlotEx:
  007b4	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR _n$18[ebp]
  007ba	83 c0 01	 add	 eax, 1
  007bd	89 85 6c fe ff
	ff		 mov	 DWORD PTR _n$18[ebp], eax
$LN7@PlotEx:
  007c3	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR _n$18[ebp]
  007c9	3b 85 24 ff ff
	ff		 cmp	 eax, DWORD PTR _res_w$33[ebp]
  007cf	0f 8d be 02 00
	00		 jge	 $LN6@PlotEx

; 5849 :         {
; 5850 :             const float t1 = t0 + t_step;

  007d5	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _t0$23[ebp]
  007dd	f3 0f 58 85 d0
	fe ff ff	 addss	 xmm0, DWORD PTR _t_step$26[ebp]
  007e5	f3 0f 11 85 60
	fe ff ff	 movss	 DWORD PTR _t1$17[ebp], xmm0

; 5851 :             const int v1_idx = (int)(t0 * item_count + 0.5f);

  007ed	f3 0f 2a 85 18
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _item_count$32[ebp]
  007f5	f3 0f 59 85 ac
	fe ff ff	 mulss	 xmm0, DWORD PTR _t0$23[ebp]
  007fd	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00805	f3 0f 2c c0	 cvttss2si eax, xmm0
  00809	89 85 54 fe ff
	ff		 mov	 DWORD PTR _v1_idx$16[ebp], eax

; 5852 :             IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);

  0080f	83 bd 54 fe ff
	ff 00		 cmp	 DWORD PTR _v1_idx$16[ebp], 0
  00816	7c 0b		 jl	 SHORT $LN49@PlotEx
  00818	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _v1_idx$16[ebp]
  0081e	3b 45 18	 cmp	 eax, DWORD PTR _values_count$[ebp]
  00821	7c 26		 jl	 SHORT $LN50@PlotEx
$LN49@PlotEx:
  00823	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z@4JA
  00829	83 c1 52	 add	 ecx, 82			; 00000052H
  0082c	8b f4		 mov	 esi, esp
  0082e	51		 push	 ecx
  0082f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00834	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@JIGPMMPH@?$AAv?$AA1?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  00839	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0083f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00842	3b f4		 cmp	 esi, esp
  00844	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN50@PlotEx:

; 5853 :             const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);

  00849	8b 45 1c	 mov	 eax, DWORD PTR _values_offset$[ebp]
  0084c	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _v1_idx$16[ebp]
  00852	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00856	99		 cdq
  00857	f7 7d 18	 idiv	 DWORD PTR _values_count$[ebp]
  0085a	8b f4		 mov	 esi, esp
  0085c	52		 push	 edx
  0085d	8b 55 14	 mov	 edx, DWORD PTR _data$[ebp]
  00860	52		 push	 edx
  00861	ff 55 10	 call	 DWORD PTR _values_getter$[ebp]
  00864	83 c4 08	 add	 esp, 8
  00867	3b f4		 cmp	 esi, esp
  00869	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0086e	d9 9d 48 fe ff
	ff		 fstp	 DWORD PTR _v1$15[ebp]

; 5854 :             const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );

  00874	f3 0f 10 85 48
	fe ff ff	 movss	 xmm0, DWORD PTR _v1$15[ebp]
  0087c	f3 0f 5c 45 24	 subss	 xmm0, DWORD PTR _scale_min$[ebp]
  00881	f3 0f 59 85 c4
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_scale$25[ebp]
  00889	51		 push	 ecx
  0088a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0088f	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00894	83 c4 04	 add	 esp, 4
  00897	d9 9d e4 fb ff
	ff		 fstp	 DWORD PTR tv728[ebp]
  0089d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008a5	f3 0f 5c 85 e4
	fb ff ff	 subss	 xmm0, DWORD PTR tv728[ebp]
  008ad	51		 push	 ecx
  008ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008b3	51		 push	 ecx
  008b4	f3 0f 10 85 60
	fe ff ff	 movss	 xmm0, DWORD PTR _t1$17[ebp]
  008bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c1	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR _tp1$14[ebp]
  008c7	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 5855 : 
; 5856 :             // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
; 5857 :             ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);

  008cc	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _tp0$22[ebp]
  008d2	50		 push	 eax
  008d3	8d 4d 98	 lea	 ecx, DWORD PTR _inner_bb$[ebp+8]
  008d6	51		 push	 ecx
  008d7	8d 55 90	 lea	 edx, DWORD PTR _inner_bb$[ebp]
  008da	52		 push	 edx
  008db	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _pos0$13[ebp]
  008e1	50		 push	 eax
  008e2	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec2@@ABU1@00@Z ; ImLerp
  008e7	83 c4 10	 add	 esp, 16			; 00000010H

; 5858 :             ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));

  008ea	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  008ee	75 26		 jne	 SHORT $LN51@PlotEx
  008f0	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _tp1$14[ebp]
  008f6	89 85 2c fc ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  008fc	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR _tp1$14[ebp+4]
  00902	89 8d 30 fc ff
	ff		 mov	 DWORD PTR $T5[ebp+4], ecx
  00908	8d 95 2c fc ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0090e	89 95 e4 fb ff
	ff		 mov	 DWORD PTR tv371[ebp], edx
  00914	eb 2d		 jmp	 SHORT $LN52@PlotEx
$LN51@PlotEx:
  00916	51		 push	 ecx
  00917	f3 0f 10 85 90
	fe ff ff	 movss	 xmm0, DWORD PTR _histogram_zero_line_t$21[ebp]
  0091f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00924	51		 push	 ecx
  00925	f3 0f 10 85 38
	fe ff ff	 movss	 xmm0, DWORD PTR _tp1$14[ebp]
  0092d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00932	8d 8d 1c fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00938	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0093d	89 85 e4 fb ff
	ff		 mov	 DWORD PTR tv371[ebp], eax
$LN52@PlotEx:
  00943	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR tv371[ebp]
  00949	89 85 3c fc ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  0094f	8b 8d 3c fc ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  00955	51		 push	 ecx
  00956	8d 55 98	 lea	 edx, DWORD PTR _inner_bb$[ebp+8]
  00959	52		 push	 edx
  0095a	8d 45 90	 lea	 eax, DWORD PTR _inner_bb$[ebp]
  0095d	50		 push	 eax
  0095e	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _pos1$12[ebp]
  00964	51		 push	 ecx
  00965	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec2@@ABU1@00@Z ; ImLerp
  0096a	83 c4 10	 add	 esp, 16			; 00000010H

; 5859 :             if (plot_type == ImGuiPlotType_Lines)

  0096d	83 7d 08 00	 cmp	 DWORD PTR _plot_type$[ebp], 0
  00971	75 5e		 jne	 SHORT $LN22@PlotEx

; 5860 :             {
; 5861 :                 window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);

  00973	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _v_hovered$31[ebp]
  00979	3b 85 54 fe ff
	ff		 cmp	 eax, DWORD PTR _v1_idx$16[ebp]
  0097f	75 0e		 jne	 SHORT $LN53@PlotEx
  00981	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _col_hovered$19[ebp]
  00987	89 8d e4 fb ff
	ff		 mov	 DWORD PTR tv380[ebp], ecx
  0098d	eb 0c		 jmp	 SHORT $LN54@PlotEx
$LN53@PlotEx:
  0098f	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _col_base$20[ebp]
  00995	89 95 e4 fb ff
	ff		 mov	 DWORD PTR tv380[ebp], edx
$LN54@PlotEx:
  0099b	51		 push	 ecx
  0099c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009a9	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR tv380[ebp]
  009af	50		 push	 eax
  009b0	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _pos1$12[ebp]
  009b6	51		 push	 ecx
  009b7	8d 95 28 fe ff
	ff		 lea	 edx, DWORD PTR _pos0$13[ebp]
  009bd	52		 push	 edx
  009be	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  009c1	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  009c7	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 5862 :             }

  009cc	e9 95 00 00 00	 jmp	 $LN24@PlotEx
$LN22@PlotEx:

; 5863 :             else if (plot_type == ImGuiPlotType_Histogram)

  009d1	83 7d 08 01	 cmp	 DWORD PTR _plot_type$[ebp], 1
  009d5	0f 85 8b 00 00
	00		 jne	 $LN24@PlotEx

; 5864 :             {
; 5865 :                 if (pos1.x >= pos0.x + 2.0f)

  009db	f3 0f 10 85 28
	fe ff ff	 movss	 xmm0, DWORD PTR _pos0$13[ebp]
  009e3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  009eb	f3 0f 10 8d 18
	fe ff ff	 movss	 xmm1, DWORD PTR _pos1$12[ebp]
  009f3	0f 2f c8	 comiss	 xmm1, xmm0
  009f6	72 18		 jb	 SHORT $LN25@PlotEx

; 5866 :                     pos1.x -= 1.0f;

  009f8	f3 0f 10 85 18
	fe ff ff	 movss	 xmm0, DWORD PTR _pos1$12[ebp]
  00a00	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00a08	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR _pos1$12[ebp], xmm0
$LN25@PlotEx:

; 5867 :                 window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);

  00a10	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _v_hovered$31[ebp]
  00a16	3b 85 54 fe ff
	ff		 cmp	 eax, DWORD PTR _v1_idx$16[ebp]
  00a1c	75 0e		 jne	 SHORT $LN55@PlotEx
  00a1e	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _col_hovered$19[ebp]
  00a24	89 8d e4 fb ff
	ff		 mov	 DWORD PTR tv425[ebp], ecx
  00a2a	eb 0c		 jmp	 SHORT $LN56@PlotEx
$LN55@PlotEx:
  00a2c	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _col_base$20[ebp]
  00a32	89 95 e4 fb ff
	ff		 mov	 DWORD PTR tv425[ebp], edx
$LN56@PlotEx:
  00a38	6a 0f		 push	 15			; 0000000fH
  00a3a	51		 push	 ecx
  00a3b	0f 57 c0	 xorps	 xmm0, xmm0
  00a3e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a43	8b 85 e4 fb ff
	ff		 mov	 eax, DWORD PTR tv425[ebp]
  00a49	50		 push	 eax
  00a4a	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _pos1$12[ebp]
  00a50	51		 push	 ecx
  00a51	8d 95 28 fe ff
	ff		 lea	 edx, DWORD PTR _pos0$13[ebp]
  00a57	52		 push	 edx
  00a58	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00a5b	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00a61	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN24@PlotEx:

; 5868 :             }
; 5869 : 
; 5870 :             t0 = t1;

  00a66	f3 0f 10 85 60
	fe ff ff	 movss	 xmm0, DWORD PTR _t1$17[ebp]
  00a6e	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR _t0$23[ebp], xmm0

; 5871 :             tp0 = tp1;

  00a76	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR _tp1$14[ebp]
  00a7c	89 85 9c fe ff
	ff		 mov	 DWORD PTR _tp0$22[ebp], eax
  00a82	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR _tp1$14[ebp+4]
  00a88	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _tp0$22[ebp+4], ecx

; 5872 :         }

  00a8e	e9 21 fd ff ff	 jmp	 $LN5@PlotEx
$LN6@PlotEx:

; 5873 :     }
; 5874 : 
; 5875 :     // Text overlay
; 5876 :     if (overlay_text)

  00a93	83 7d 20 00	 cmp	 DWORD PTR _overlay_text$[ebp], 0
  00a97	74 63		 je	 SHORT $LN26@PlotEx

; 5877 :         RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

  00a99	6a 00		 push	 0
  00a9b	51		 push	 ecx
  00a9c	0f 57 c0	 xorps	 xmm0, xmm0
  00a9f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aa4	51		 push	 ecx
  00aa5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00aad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ab2	8d 8d 0c fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00ab8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00abd	50		 push	 eax
  00abe	6a 00		 push	 0
  00ac0	6a 00		 push	 0
  00ac2	8b 45 20	 mov	 eax, DWORD PTR _overlay_text$[ebp]
  00ac5	50		 push	 eax
  00ac6	8d 4d b0	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  00ac9	51		 push	 ecx
  00aca	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  00acd	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  00ad2	f3 0f 58 42 3c	 addss	 xmm0, DWORD PTR [edx+60]
  00ad7	51		 push	 ecx
  00ad8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00add	51		 push	 ecx
  00ade	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _frame_bb$[ebp]
  00ae3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ae8	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00aee	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00af3	50		 push	 eax
  00af4	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00af9	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN26@PlotEx:

; 5878 : 
; 5879 :     if (label_size.x > 0.0f)

  00afc	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00b01	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00b08	76 40		 jbe	 SHORT $LN27@PlotEx

; 5880 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

  00b0a	6a 01		 push	 1
  00b0c	6a 00		 push	 0
  00b0e	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  00b11	50		 push	 eax
  00b12	51		 push	 ecx
  00b13	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _inner_bb$[ebp+4]
  00b18	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b1d	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00b20	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  00b25	f3 0f 58 41 50	 addss	 xmm0, DWORD PTR [ecx+80]
  00b2a	51		 push	 ecx
  00b2b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b30	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00b36	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00b3b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00b3e	52		 push	 edx
  00b3f	8b 00		 mov	 eax, DWORD PTR [eax]
  00b41	50		 push	 eax
  00b42	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  00b47	83 c4 14	 add	 esp, 20			; 00000014H
$LN27@PlotEx:
$LN1@PlotEx:

; 5881 : }

  00b4a	52		 push	 edx
  00b4b	8b cd		 mov	 ecx, ebp
  00b4d	50		 push	 eax
  00b4e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN66@PlotEx
  00b54	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00b59	58		 pop	 eax
  00b5a	5a		 pop	 edx
  00b5b	5f		 pop	 edi
  00b5c	5e		 pop	 esi
  00b5d	5b		 pop	 ebx
  00b5e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b61	33 cd		 xor	 ecx, ebp
  00b63	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b68	81 c4 20 04 00
	00		 add	 esp, 1056		; 00000420H
  00b6e	3b ec		 cmp	 ebp, esp
  00b70	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b75	8b e5		 mov	 esp, ebp
  00b77	5d		 pop	 ebp
  00b78	c3		 ret	 0
  00b79	0f 1f 00	 npad	 3
$LN66@PlotEx:
  00b7c	08 00 00 00	 DD	 8
  00b80	00 00 00 00	 DD	 $LN65@PlotEx
$LN65@PlotEx:
  00b84	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00b88	08 00 00 00	 DD	 8
  00b8c	00 00 00 00	 DD	 $LN57@PlotEx
  00b90	a8 ff ff ff	 DD	 -88			; ffffffa8H
  00b94	10 00 00 00	 DD	 16			; 00000010H
  00b98	00 00 00 00	 DD	 $LN58@PlotEx
  00b9c	90 ff ff ff	 DD	 -112			; ffffff90H
  00ba0	10 00 00 00	 DD	 16			; 00000010H
  00ba4	00 00 00 00	 DD	 $LN59@PlotEx
  00ba8	78 ff ff ff	 DD	 -136			; ffffff78H
  00bac	10 00 00 00	 DD	 16			; 00000010H
  00bb0	00 00 00 00	 DD	 $LN60@PlotEx
  00bb4	9c fe ff ff	 DD	 -356			; fffffe9cH
  00bb8	08 00 00 00	 DD	 8
  00bbc	00 00 00 00	 DD	 $LN61@PlotEx
  00bc0	38 fe ff ff	 DD	 -456			; fffffe38H
  00bc4	08 00 00 00	 DD	 8
  00bc8	00 00 00 00	 DD	 $LN62@PlotEx
  00bcc	28 fe ff ff	 DD	 -472			; fffffe28H
  00bd0	08 00 00 00	 DD	 8
  00bd4	00 00 00 00	 DD	 $LN63@PlotEx
  00bd8	18 fe ff ff	 DD	 -488			; fffffe18H
  00bdc	08 00 00 00	 DD	 8
  00be0	00 00 00 00	 DD	 $LN64@PlotEx
$LN64@PlotEx:
  00be4	70		 DB	 112			; 00000070H
  00be5	6f		 DB	 111			; 0000006fH
  00be6	73		 DB	 115			; 00000073H
  00be7	31		 DB	 49			; 00000031H
  00be8	00		 DB	 0
$LN63@PlotEx:
  00be9	70		 DB	 112			; 00000070H
  00bea	6f		 DB	 111			; 0000006fH
  00beb	73		 DB	 115			; 00000073H
  00bec	30		 DB	 48			; 00000030H
  00bed	00		 DB	 0
$LN62@PlotEx:
  00bee	74		 DB	 116			; 00000074H
  00bef	70		 DB	 112			; 00000070H
  00bf0	31		 DB	 49			; 00000031H
  00bf1	00		 DB	 0
$LN61@PlotEx:
  00bf2	74		 DB	 116			; 00000074H
  00bf3	70		 DB	 112			; 00000070H
  00bf4	30		 DB	 48			; 00000030H
  00bf5	00		 DB	 0
$LN60@PlotEx:
  00bf6	74		 DB	 116			; 00000074H
  00bf7	6f		 DB	 111			; 0000006fH
  00bf8	74		 DB	 116			; 00000074H
  00bf9	61		 DB	 97			; 00000061H
  00bfa	6c		 DB	 108			; 0000006cH
  00bfb	5f		 DB	 95			; 0000005fH
  00bfc	62		 DB	 98			; 00000062H
  00bfd	62		 DB	 98			; 00000062H
  00bfe	00		 DB	 0
$LN59@PlotEx:
  00bff	69		 DB	 105			; 00000069H
  00c00	6e		 DB	 110			; 0000006eH
  00c01	6e		 DB	 110			; 0000006eH
  00c02	65		 DB	 101			; 00000065H
  00c03	72		 DB	 114			; 00000072H
  00c04	5f		 DB	 95			; 0000005fH
  00c05	62		 DB	 98			; 00000062H
  00c06	62		 DB	 98			; 00000062H
  00c07	00		 DB	 0
$LN58@PlotEx:
  00c08	66		 DB	 102			; 00000066H
  00c09	72		 DB	 114			; 00000072H
  00c0a	61		 DB	 97			; 00000061H
  00c0b	6d		 DB	 109			; 0000006dH
  00c0c	65		 DB	 101			; 00000065H
  00c0d	5f		 DB	 95			; 0000005fH
  00c0e	62		 DB	 98			; 00000062H
  00c0f	62		 DB	 98			; 00000062H
  00c10	00		 DB	 0
$LN57@PlotEx:
  00c11	6c		 DB	 108			; 0000006cH
  00c12	61		 DB	 97			; 00000061H
  00c13	62		 DB	 98			; 00000062H
  00c14	65		 DB	 101			; 00000065H
  00c15	6c		 DB	 108			; 0000006cH
  00c16	5f		 DB	 95			; 0000005fH
  00c17	73		 DB	 115			; 00000073H
  00c18	69		 DB	 105			; 00000069H
  00c19	7a		 DB	 122			; 0000007aH
  00c1a	65		 DB	 101			; 00000065H
  00c1b	00		 DB	 0
?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ENDP ; ImGui::PlotEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorPickerOptionsPopup@ImGui@@YAXPBMH@Z
_TEXT	SEGMENT
tv191 = -320						; size = 4
tv226 = -316						; size = 4
tv162 = -316						; size = 4
tv72 = -316						; size = 4
tv66 = -316						; size = 4
_dummy_ref_col$1 = -116					; size = 16
_backup_pos$2 = -92					; size = 8
_picker_flags$3 = -76					; size = 4
_picker_type$4 = -64					; size = 4
_picker_size$5 = -52					; size = 8
_g$ = -36						; size = 4
_allow_opt_alpha_bar$ = -21				; size = 1
_allow_opt_picker$ = -9					; size = 1
__$ArrayPad$ = -4					; size = 4
_ref_col$ = 8						; size = 4
_flags$ = 12						; size = 4
?ColorPickerOptionsPopup@ImGui@@YAXPBMH@Z PROC		; ImGui::ColorPickerOptionsPopup, COMDAT

; 5027 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00012	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5028 :     bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00035	25 00 00 00 06	 and	 eax, 100663296		; 06000000H
  0003a	75 0c		 jne	 SHORT $LN16@ColorPicke
  0003c	c7 85 c4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00046	eb 0a		 jmp	 SHORT $LN17@ColorPicke
$LN16@ColorPicke:
  00048	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN17@ColorPicke:
  00052	8a 8d c4 fe ff
	ff		 mov	 cl, BYTE PTR tv66[ebp]
  00058	88 4d f7	 mov	 BYTE PTR _allow_opt_picker$[ebp], cl

; 5029 :     bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0005e	83 e0 02	 and	 eax, 2
  00061	75 17		 jne	 SHORT $LN18@ColorPicke
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00066	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  0006c	75 0c		 jne	 SHORT $LN18@ColorPicke
  0006e	c7 85 c4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv72[ebp], 1
  00078	eb 0a		 jmp	 SHORT $LN19@ColorPicke
$LN18@ColorPicke:
  0007a	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
$LN19@ColorPicke:
  00084	8a 95 c4 fe ff
	ff		 mov	 dl, BYTE PTR tv72[ebp]
  0008a	88 55 eb	 mov	 BYTE PTR _allow_opt_alpha_bar$[ebp], dl

; 5030 :     if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))

  0008d	0f b6 45 f7	 movzx	 eax, BYTE PTR _allow_opt_picker$[ebp]
  00091	85 c0		 test	 eax, eax
  00093	75 08		 jne	 SHORT $LN7@ColorPicke
  00095	0f b6 45 eb	 movzx	 eax, BYTE PTR _allow_opt_alpha_bar$[ebp]
  00099	85 c0		 test	 eax, eax
  0009b	74 16		 je	 SHORT $LN6@ColorPicke
$LN7@ColorPicke:
  0009d	6a 00		 push	 0
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_07JKKCBBMM@context@
  000a4	e8 00 00 00 00	 call	 ?BeginPopup@ImGui@@YA_NPBDH@Z ; ImGui::BeginPopup
  000a9	83 c4 08	 add	 esp, 8
  000ac	0f b6 c0	 movzx	 eax, al
  000af	85 c0		 test	 eax, eax
  000b1	75 05		 jne	 SHORT $LN5@ColorPicke
$LN6@ColorPicke:

; 5031 :         return;

  000b3	e9 01 02 00 00	 jmp	 $LN1@ColorPicke
$LN5@ColorPicke:

; 5032 :     ImGuiContext& g = *GImGui;

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  000bd	89 45 dc	 mov	 DWORD PTR _g$[ebp], eax

; 5033 :     if (allow_opt_picker)

  000c0	0f b6 45 f7	 movzx	 eax, BYTE PTR _allow_opt_picker$[ebp]
  000c4	85 c0		 test	 eax, eax
  000c6	0f 84 b8 01 00
	00		 je	 $LN8@ColorPicke

; 5034 :     {
; 5035 :         ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function

  000cc	51		 push	 ecx
  000cd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000da	8b 45 dc	 mov	 eax, DWORD PTR _g$[ebp]
  000dd	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  000e5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41000000
  000ed	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR tv226[ebp], xmm0
  000f5	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  000fa	d9 9d c0 fe ff
	ff		 fstp	 DWORD PTR tv191[ebp]
  00100	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR tv191[ebp]
  00108	8b 4d dc	 mov	 ecx, DWORD PTR _g$[ebp]
  0010b	f3 0f 58 81 60
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5472]
  00113	f3 0f 10 8d c4
	fe ff ff	 movss	 xmm1, DWORD PTR tv226[ebp]
  0011b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0011f	51		 push	 ecx
  00120	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00125	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0012a	83 c4 04	 add	 esp, 4
  0012d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00130	8b 55 dc	 mov	 edx, DWORD PTR _g$[ebp]
  00133	f3 0f 10 82 c4
	18 00 00	 movss	 xmm0, DWORD PTR [edx+6340]
  0013b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41000000
  00143	51		 push	 ecx
  00144	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00149	8d 4d cc	 lea	 ecx, DWORD PTR _picker_size$5[ebp]
  0014c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 5036 :         PushItemWidth(picker_size.x);

  00151	51		 push	 ecx
  00152	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _picker_size$5[ebp]
  00157	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015c	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth
  00161	83 c4 04	 add	 esp, 4

; 5037 :         for (int picker_type = 0; picker_type < 2; picker_type++)

  00164	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _picker_type$4[ebp], 0
  0016b	eb 09		 jmp	 SHORT $LN4@ColorPicke
$LN2@ColorPicke:
  0016d	8b 45 c0	 mov	 eax, DWORD PTR _picker_type$4[ebp]
  00170	83 c0 01	 add	 eax, 1
  00173	89 45 c0	 mov	 DWORD PTR _picker_type$4[ebp], eax
$LN4@ColorPicke:
  00176	83 7d c0 02	 cmp	 DWORD PTR _picker_type$4[ebp], 2
  0017a	0f 8d ff 00 00
	00		 jge	 $LN3@ColorPicke

; 5038 :         {
; 5039 :             // Draw small/thumbnail version of each picker type (over an invisible button for selection)
; 5040 :             if (picker_type > 0) Separator();

  00180	83 7d c0 00	 cmp	 DWORD PTR _picker_type$4[ebp], 0
  00184	7e 05		 jle	 SHORT $LN9@ColorPicke
  00186	e8 00 00 00 00	 call	 ?Separator@ImGui@@YAXXZ	; ImGui::Separator
$LN9@ColorPicke:

; 5041 :             PushID(picker_type);

  0018b	8b 45 c0	 mov	 eax, DWORD PTR _picker_type$4[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID
  00194	83 c4 04	 add	 esp, 4

; 5042 :             ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);

  00197	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0019a	83 e0 02	 and	 eax, 2
  0019d	0d a8 01 00 00	 or	 eax, 424		; 000001a8H
  001a2	89 45 b4	 mov	 DWORD PTR _picker_flags$3[ebp], eax

; 5043 :             if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;

  001a5	83 7d c0 00	 cmp	 DWORD PTR _picker_type$4[ebp], 0
  001a9	75 0b		 jne	 SHORT $LN10@ColorPicke
  001ab	8b 45 b4	 mov	 eax, DWORD PTR _picker_flags$3[ebp]
  001ae	0d 00 00 00 02	 or	 eax, 33554432		; 02000000H
  001b3	89 45 b4	 mov	 DWORD PTR _picker_flags$3[ebp], eax
$LN10@ColorPicke:

; 5044 :             if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;

  001b6	83 7d c0 01	 cmp	 DWORD PTR _picker_type$4[ebp], 1
  001ba	75 0b		 jne	 SHORT $LN11@ColorPicke
  001bc	8b 45 b4	 mov	 eax, DWORD PTR _picker_flags$3[ebp]
  001bf	0d 00 00 00 04	 or	 eax, 67108864		; 04000000H
  001c4	89 45 b4	 mov	 DWORD PTR _picker_flags$3[ebp], eax
$LN11@ColorPicke:

; 5045 :             ImVec2 backup_pos = GetCursorScreenPos();

  001c7	8d 45 a4	 lea	 eax, DWORD PTR _backup_pos$2[ebp]
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 ?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetCursorScreenPos
  001d0	83 c4 04	 add	 esp, 4

; 5046 :             if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup

  001d3	8d 45 cc	 lea	 eax, DWORD PTR _picker_size$5[ebp]
  001d6	50		 push	 eax
  001d7	6a 00		 push	 0
  001d9	6a 00		 push	 0
  001db	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KFBFGFJL@?$CD?$CDselectable@
  001e0	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  001e5	83 c4 10	 add	 esp, 16			; 00000010H
  001e8	0f b6 c8	 movzx	 ecx, al
  001eb	85 c9		 test	 ecx, ecx
  001ed	74 23		 je	 SHORT $LN12@ColorPicke

; 5047 :                 g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);

  001ef	8b 45 dc	 mov	 eax, DWORD PTR _g$[ebp]
  001f2	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  001f8	81 e1 ff ff ff
	f9		 and	 ecx, -100663297		; f9ffffffH
  001fe	8b 55 b4	 mov	 edx, DWORD PTR _picker_flags$3[ebp]
  00201	81 e2 00 00 00
	06		 and	 edx, 100663296		; 06000000H
  00207	0b ca		 or	 ecx, edx
  00209	8b 45 dc	 mov	 eax, DWORD PTR _g$[ebp]
  0020c	89 88 d4 2c 00
	00		 mov	 DWORD PTR [eax+11476], ecx
$LN12@ColorPicke:

; 5048 :             SetCursorScreenPos(backup_pos);

  00212	8d 45 a4	 lea	 eax, DWORD PTR _backup_pos$2[ebp]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ?SetCursorScreenPos@ImGui@@YAXABUImVec2@@@Z ; ImGui::SetCursorScreenPos
  0021b	83 c4 04	 add	 esp, 4

; 5049 :             ImVec4 dummy_ref_col;

  0021e	8d 4d 8c	 lea	 ecx, DWORD PTR _dummy_ref_col$1[ebp]
  00221	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@XZ	; ImVec4::ImVec4

; 5050 :             memcpy(&dummy_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));

  00226	8b 45 b4	 mov	 eax, DWORD PTR _picker_flags$3[ebp]
  00229	83 e0 02	 and	 eax, 2
  0022c	74 0c		 je	 SHORT $LN20@ColorPicke
  0022e	c7 85 c4 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv162[ebp], 3
  00238	eb 0a		 jmp	 SHORT $LN21@ColorPicke
$LN20@ColorPicke:
  0023a	c7 85 c4 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR tv162[ebp], 4
$LN21@ColorPicke:
  00244	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv162[ebp]
  0024a	c1 e1 02	 shl	 ecx, 2
  0024d	51		 push	 ecx
  0024e	8b 55 08	 mov	 edx, DWORD PTR _ref_col$[ebp]
  00251	52		 push	 edx
  00252	8d 45 8c	 lea	 eax, DWORD PTR _dummy_ref_col$1[ebp]
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 _memcpy
  0025b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5051 :             ColorPicker4("##dummypicker", &dummy_ref_col.x, picker_flags);

  0025e	6a 00		 push	 0
  00260	8b 45 b4	 mov	 eax, DWORD PTR _picker_flags$3[ebp]
  00263	50		 push	 eax
  00264	8d 4d 8c	 lea	 ecx, DWORD PTR _dummy_ref_col$1[ebp]
  00267	51		 push	 ecx
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KNMNNHNH@?$CD?$CDdummypicker@
  0026d	e8 00 00 00 00	 call	 ?ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z ; ImGui::ColorPicker4
  00272	83 c4 10	 add	 esp, 16			; 00000010H

; 5052 :             PopID();

  00275	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 5053 :         }

  0027a	e9 ee fe ff ff	 jmp	 $LN2@ColorPicke
$LN3@ColorPicke:

; 5054 :         PopItemWidth();

  0027f	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth
$LN8@ColorPicke:

; 5055 :     }
; 5056 :     if (allow_opt_alpha_bar)

  00284	0f b6 45 eb	 movzx	 eax, BYTE PTR _allow_opt_alpha_bar$[ebp]
  00288	85 c0		 test	 eax, eax
  0028a	74 28		 je	 SHORT $LN13@ColorPicke

; 5057 :     {
; 5058 :         if (allow_opt_picker) Separator();

  0028c	0f b6 45 f7	 movzx	 eax, BYTE PTR _allow_opt_picker$[ebp]
  00290	85 c0		 test	 eax, eax
  00292	74 05		 je	 SHORT $LN14@ColorPicke
  00294	e8 00 00 00 00	 call	 ?Separator@ImGui@@YAXXZ	; ImGui::Separator
$LN14@ColorPicke:

; 5059 :         CheckboxFlags("Alpha Bar", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);

  00299	68 00 00 01 00	 push	 65536			; 00010000H
  0029e	8b 45 dc	 mov	 eax, DWORD PTR _g$[ebp]
  002a1	05 d4 2c 00 00	 add	 eax, 11476		; 00002cd4H
  002a6	50		 push	 eax
  002a7	68 00 00 00 00	 push	 OFFSET ??_C@_09KEDLMDJL@Alpha?5Bar@
  002ac	e8 00 00 00 00	 call	 ?CheckboxFlags@ImGui@@YA_NPBDPAII@Z ; ImGui::CheckboxFlags
  002b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@ColorPicke:

; 5060 :     }
; 5061 :     EndPopup();

  002b4	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup
$LN1@ColorPicke:

; 5062 : }

  002b9	52		 push	 edx
  002ba	8b cd		 mov	 ecx, ebp
  002bc	50		 push	 eax
  002bd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@ColorPicke
  002c3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002c8	58		 pop	 eax
  002c9	5a		 pop	 edx
  002ca	5f		 pop	 edi
  002cb	5e		 pop	 esi
  002cc	5b		 pop	 ebx
  002cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d0	33 cd		 xor	 ecx, ebp
  002d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d7	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  002dd	3b ec		 cmp	 ebp, esp
  002df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e4	8b e5		 mov	 esp, ebp
  002e6	5d		 pop	 ebp
  002e7	c3		 ret	 0
$LN26@ColorPicke:
  002e8	03 00 00 00	 DD	 3
  002ec	00 00 00 00	 DD	 $LN25@ColorPicke
$LN25@ColorPicke:
  002f0	cc ff ff ff	 DD	 -52			; ffffffccH
  002f4	08 00 00 00	 DD	 8
  002f8	00 00 00 00	 DD	 $LN22@ColorPicke
  002fc	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00300	08 00 00 00	 DD	 8
  00304	00 00 00 00	 DD	 $LN23@ColorPicke
  00308	8c ff ff ff	 DD	 -116			; ffffff8cH
  0030c	10 00 00 00	 DD	 16			; 00000010H
  00310	00 00 00 00	 DD	 $LN24@ColorPicke
$LN24@ColorPicke:
  00314	64		 DB	 100			; 00000064H
  00315	75		 DB	 117			; 00000075H
  00316	6d		 DB	 109			; 0000006dH
  00317	6d		 DB	 109			; 0000006dH
  00318	79		 DB	 121			; 00000079H
  00319	5f		 DB	 95			; 0000005fH
  0031a	72		 DB	 114			; 00000072H
  0031b	65		 DB	 101			; 00000065H
  0031c	66		 DB	 102			; 00000066H
  0031d	5f		 DB	 95			; 0000005fH
  0031e	63		 DB	 99			; 00000063H
  0031f	6f		 DB	 111			; 0000006fH
  00320	6c		 DB	 108			; 0000006cH
  00321	00		 DB	 0
$LN23@ColorPicke:
  00322	62		 DB	 98			; 00000062H
  00323	61		 DB	 97			; 00000061H
  00324	63		 DB	 99			; 00000063H
  00325	6b		 DB	 107			; 0000006bH
  00326	75		 DB	 117			; 00000075H
  00327	70		 DB	 112			; 00000070H
  00328	5f		 DB	 95			; 0000005fH
  00329	70		 DB	 112			; 00000070H
  0032a	6f		 DB	 111			; 0000006fH
  0032b	73		 DB	 115			; 00000073H
  0032c	00		 DB	 0
$LN22@ColorPicke:
  0032d	70		 DB	 112			; 00000070H
  0032e	69		 DB	 105			; 00000069H
  0032f	63		 DB	 99			; 00000063H
  00330	6b		 DB	 107			; 0000006bH
  00331	65		 DB	 101			; 00000065H
  00332	72		 DB	 114			; 00000072H
  00333	5f		 DB	 95			; 0000005fH
  00334	73		 DB	 115			; 00000073H
  00335	69		 DB	 105			; 00000069H
  00336	7a		 DB	 122			; 0000007aH
  00337	65		 DB	 101			; 00000065H
  00338	00		 DB	 0
?ColorPickerOptionsPopup@ImGui@@YAXPBMH@Z ENDP		; ImGui::ColorPickerOptionsPopup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorEditOptionsPopup@ImGui@@YAXPBMH@Z
_TEXT	SEGMENT
tv382 = -436						; size = 4
tv373 = -432						; size = 4
tv365 = -432						; size = 4
tv357 = -432						; size = 4
tv229 = -432						; size = 4
tv223 = -432						; size = 4
tv70 = -432						; size = 4
tv66 = -432						; size = 4
tv163 = -429						; size = 1
tv153 = -429						; size = 1
tv139 = -429						; size = 1
tv129 = -429						; size = 1
tv87 = -429						; size = 1
$T1 = -424						; size = 8
$T2 = -408						; size = 8
$T3 = -392						; size = 8
$T4 = -376						; size = 8
_buf$5 = -168						; size = 64
_ca$6 = -96						; size = 4
_cb$7 = -84						; size = 4
_cg$8 = -72						; size = 4
_cr$9 = -60						; size = 4
_opts$ = -48						; size = 4
_g$ = -36						; size = 4
_allow_opt_datatype$ = -21				; size = 1
_allow_opt_inputs$ = -9					; size = 1
__$ArrayPad$ = -4					; size = 4
_col$ = 8						; size = 4
_flags$ = 12						; size = 4
?ColorEditOptionsPopup@ImGui@@YAXPBMH@Z PROC		; ImGui::ColorEditOptionsPopup, COMDAT

; 4979 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 01 00
	00		 sub	 esp, 436		; 000001b4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 4c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-436]
  00012	b9 6d 00 00 00	 mov	 ecx, 109		; 0000006dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4980 :     bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__DisplayMask);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00035	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  0003a	75 0c		 jne	 SHORT $LN23@ColorEditO
  0003c	c7 85 50 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00046	eb 0a		 jmp	 SHORT $LN24@ColorEditO
$LN23@ColorEditO:
  00048	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN24@ColorEditO:
  00052	8a 8d 50 fe ff
	ff		 mov	 cl, BYTE PTR tv66[ebp]
  00058	88 4d f7	 mov	 BYTE PTR _allow_opt_inputs$[ebp], cl

; 4981 :     bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0005e	25 00 00 80 01	 and	 eax, 25165824		; 01800000H
  00063	75 0c		 jne	 SHORT $LN25@ColorEditO
  00065	c7 85 50 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv70[ebp], 1
  0006f	eb 0a		 jmp	 SHORT $LN26@ColorEditO
$LN25@ColorEditO:
  00071	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN26@ColorEditO:
  0007b	8a 8d 50 fe ff
	ff		 mov	 cl, BYTE PTR tv70[ebp]
  00081	88 4d eb	 mov	 BYTE PTR _allow_opt_datatype$[ebp], cl

; 4982 :     if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))

  00084	0f b6 45 f7	 movzx	 eax, BYTE PTR _allow_opt_inputs$[ebp]
  00088	85 c0		 test	 eax, eax
  0008a	75 08		 jne	 SHORT $LN4@ColorEditO
  0008c	0f b6 45 eb	 movzx	 eax, BYTE PTR _allow_opt_datatype$[ebp]
  00090	85 c0		 test	 eax, eax
  00092	74 16		 je	 SHORT $LN3@ColorEditO
$LN4@ColorEditO:
  00094	6a 00		 push	 0
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_07JKKCBBMM@context@
  0009b	e8 00 00 00 00	 call	 ?BeginPopup@ImGui@@YA_NPBDH@Z ; ImGui::BeginPopup
  000a0	83 c4 08	 add	 esp, 8
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	85 c0		 test	 eax, eax
  000a8	75 05		 jne	 SHORT $LN2@ColorEditO
$LN3@ColorEditO:

; 4983 :         return;

  000aa	e9 37 05 00 00	 jmp	 $LN1@ColorEditO
$LN2@ColorEditO:

; 4984 :     ImGuiContext& g = *GImGui;

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  000b4	89 45 dc	 mov	 DWORD PTR _g$[ebp], eax

; 4985 :     ImGuiColorEditFlags opts = g.ColorEditOptions;

  000b7	8b 45 dc	 mov	 eax, DWORD PTR _g$[ebp]
  000ba	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  000c0	89 4d d0	 mov	 DWORD PTR _opts$[ebp], ecx

; 4986 :     if (allow_opt_inputs)

  000c3	0f b6 45 f7	 movzx	 eax, BYTE PTR _allow_opt_inputs$[ebp]
  000c7	85 c0		 test	 eax, eax
  000c9	0f 84 d2 00 00
	00		 je	 $LN8@ColorEditO

; 4987 :     {
; 4988 :         if (RadioButton("RGB", (opts & ImGuiColorEditFlags_DisplayRGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayRGB;

  000cf	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  000d2	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  000d7	74 09		 je	 SHORT $LN27@ColorEditO
  000d9	c6 85 53 fe ff
	ff 01		 mov	 BYTE PTR tv87[ebp], 1
  000e0	eb 07		 jmp	 SHORT $LN28@ColorEditO
$LN27@ColorEditO:
  000e2	c6 85 53 fe ff
	ff 00		 mov	 BYTE PTR tv87[ebp], 0
$LN28@ColorEditO:
  000e9	0f b6 8d 53 fe
	ff ff		 movzx	 ecx, BYTE PTR tv87[ebp]
  000f0	51		 push	 ecx
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_03ICFFBAI@RGB@
  000f6	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPBD_N@Z ; ImGui::RadioButton
  000fb	83 c4 08	 add	 esp, 8
  000fe	0f b6 d0	 movzx	 edx, al
  00101	85 d2		 test	 edx, edx
  00103	74 10		 je	 SHORT $LN6@ColorEditO
  00105	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  00108	25 ff ff 8f ff	 and	 eax, -7340033		; ff8fffffH
  0010d	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  00112	89 45 d0	 mov	 DWORD PTR _opts$[ebp], eax
$LN6@ColorEditO:

; 4989 :         if (RadioButton("HSV", (opts & ImGuiColorEditFlags_DisplayHSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayHSV;

  00115	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  00118	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0011d	74 09		 je	 SHORT $LN29@ColorEditO
  0011f	c6 85 53 fe ff
	ff 01		 mov	 BYTE PTR tv129[ebp], 1
  00126	eb 07		 jmp	 SHORT $LN30@ColorEditO
$LN29@ColorEditO:
  00128	c6 85 53 fe ff
	ff 00		 mov	 BYTE PTR tv129[ebp], 0
$LN30@ColorEditO:
  0012f	0f b6 8d 53 fe
	ff ff		 movzx	 ecx, BYTE PTR tv129[ebp]
  00136	51		 push	 ecx
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_03CAADKAK@HSV@
  0013c	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPBD_N@Z ; ImGui::RadioButton
  00141	83 c4 08	 add	 esp, 8
  00144	0f b6 d0	 movzx	 edx, al
  00147	85 d2		 test	 edx, edx
  00149	74 10		 je	 SHORT $LN7@ColorEditO
  0014b	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  0014e	25 ff ff 8f ff	 and	 eax, -7340033		; ff8fffffH
  00153	0d 00 00 20 00	 or	 eax, 2097152		; 00200000H
  00158	89 45 d0	 mov	 DWORD PTR _opts$[ebp], eax
$LN7@ColorEditO:

; 4990 :         if (RadioButton("Hex", (opts & ImGuiColorEditFlags_DisplayHex) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayHex;

  0015b	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  0015e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00163	74 09		 je	 SHORT $LN31@ColorEditO
  00165	c6 85 53 fe ff
	ff 01		 mov	 BYTE PTR tv139[ebp], 1
  0016c	eb 07		 jmp	 SHORT $LN32@ColorEditO
$LN31@ColorEditO:
  0016e	c6 85 53 fe ff
	ff 00		 mov	 BYTE PTR tv139[ebp], 0
$LN32@ColorEditO:
  00175	0f b6 8d 53 fe
	ff ff		 movzx	 ecx, BYTE PTR tv139[ebp]
  0017c	51		 push	 ecx
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_03CJOBKKAE@Hex@
  00182	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPBD_N@Z ; ImGui::RadioButton
  00187	83 c4 08	 add	 esp, 8
  0018a	0f b6 d0	 movzx	 edx, al
  0018d	85 d2		 test	 edx, edx
  0018f	74 10		 je	 SHORT $LN8@ColorEditO
  00191	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  00194	25 ff ff 8f ff	 and	 eax, -7340033		; ff8fffffH
  00199	0d 00 00 40 00	 or	 eax, 4194304		; 00400000H
  0019e	89 45 d0	 mov	 DWORD PTR _opts$[ebp], eax
$LN8@ColorEditO:

; 4991 :     }
; 4992 :     if (allow_opt_datatype)

  001a1	0f b6 45 eb	 movzx	 eax, BYTE PTR _allow_opt_datatype$[ebp]
  001a5	85 c0		 test	 eax, eax
  001a7	0f 84 99 00 00
	00		 je	 $LN12@ColorEditO

; 4993 :     {
; 4994 :         if (allow_opt_inputs) Separator();

  001ad	0f b6 45 f7	 movzx	 eax, BYTE PTR _allow_opt_inputs$[ebp]
  001b1	85 c0		 test	 eax, eax
  001b3	74 05		 je	 SHORT $LN10@ColorEditO
  001b5	e8 00 00 00 00	 call	 ?Separator@ImGui@@YAXXZ	; ImGui::Separator
$LN10@ColorEditO:

; 4995 :         if (RadioButton("0..255",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;

  001ba	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  001bd	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  001c2	74 09		 je	 SHORT $LN33@ColorEditO
  001c4	c6 85 53 fe ff
	ff 01		 mov	 BYTE PTR tv153[ebp], 1
  001cb	eb 07		 jmp	 SHORT $LN34@ColorEditO
$LN33@ColorEditO:
  001cd	c6 85 53 fe ff
	ff 00		 mov	 BYTE PTR tv153[ebp], 0
$LN34@ColorEditO:
  001d4	0f b6 8d 53 fe
	ff ff		 movzx	 ecx, BYTE PTR tv153[ebp]
  001db	51		 push	 ecx
  001dc	68 00 00 00 00	 push	 OFFSET ??_C@_06FDBEKFBH@0?4?4255@
  001e1	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPBD_N@Z ; ImGui::RadioButton
  001e6	83 c4 08	 add	 esp, 8
  001e9	0f b6 d0	 movzx	 edx, al
  001ec	85 d2		 test	 edx, edx
  001ee	74 10		 je	 SHORT $LN11@ColorEditO
  001f0	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  001f3	25 ff ff 7f fe	 and	 eax, -25165825		; fe7fffffH
  001f8	0d 00 00 80 00	 or	 eax, 8388608		; 00800000H
  001fd	89 45 d0	 mov	 DWORD PTR _opts$[ebp], eax
$LN11@ColorEditO:

; 4996 :         if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;

  00200	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  00203	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00208	74 09		 je	 SHORT $LN35@ColorEditO
  0020a	c6 85 53 fe ff
	ff 01		 mov	 BYTE PTR tv163[ebp], 1
  00211	eb 07		 jmp	 SHORT $LN36@ColorEditO
$LN35@ColorEditO:
  00213	c6 85 53 fe ff
	ff 00		 mov	 BYTE PTR tv163[ebp], 0
$LN36@ColorEditO:
  0021a	0f b6 8d 53 fe
	ff ff		 movzx	 ecx, BYTE PTR tv163[ebp]
  00221	51		 push	 ecx
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MDNPBJBM@0?400?4?41?400@
  00227	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPBD_N@Z ; ImGui::RadioButton
  0022c	83 c4 08	 add	 esp, 8
  0022f	0f b6 d0	 movzx	 edx, al
  00232	85 d2		 test	 edx, edx
  00234	74 10		 je	 SHORT $LN12@ColorEditO
  00236	8b 45 d0	 mov	 eax, DWORD PTR _opts$[ebp]
  00239	25 ff ff 7f fe	 and	 eax, -25165825		; fe7fffffH
  0023e	0d 00 00 00 01	 or	 eax, 16777216		; 01000000H
  00243	89 45 d0	 mov	 DWORD PTR _opts$[ebp], eax
$LN12@ColorEditO:

; 4997 :     }
; 4998 : 
; 4999 :     if (allow_opt_inputs || allow_opt_datatype)

  00246	0f b6 45 f7	 movzx	 eax, BYTE PTR _allow_opt_inputs$[ebp]
  0024a	85 c0		 test	 eax, eax
  0024c	75 08		 jne	 SHORT $LN14@ColorEditO
  0024e	0f b6 45 eb	 movzx	 eax, BYTE PTR _allow_opt_datatype$[ebp]
  00252	85 c0		 test	 eax, eax
  00254	74 05		 je	 SHORT $LN13@ColorEditO
$LN14@ColorEditO:

; 5000 :         Separator();

  00256	e8 00 00 00 00	 call	 ?Separator@ImGui@@YAXXZ	; ImGui::Separator
$LN13@ColorEditO:

; 5001 :     if (Button("Copy as..", ImVec2(-1,0)))

  0025b	51		 push	 ecx
  0025c	0f 57 c0	 xorps	 xmm0, xmm0
  0025f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00264	51		 push	 ecx
  00265	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0026d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00272	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00278	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0027d	50		 push	 eax
  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_09NMCCFHEI@Copy?5as?4?4@
  00283	e8 00 00 00 00	 call	 ?Button@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::Button
  00288	83 c4 08	 add	 esp, 8
  0028b	0f b6 c0	 movzx	 eax, al
  0028e	85 c0		 test	 eax, eax
  00290	74 0d		 je	 SHORT $LN15@ColorEditO

; 5002 :         OpenPopup("Copy");

  00292	68 00 00 00 00	 push	 OFFSET ??_C@_04OPMHGHMB@Copy@
  00297	e8 00 00 00 00	 call	 ?OpenPopup@ImGui@@YAXPBD@Z ; ImGui::OpenPopup
  0029c	83 c4 04	 add	 esp, 4
$LN15@ColorEditO:

; 5003 :     if (BeginPopup("Copy"))

  0029f	6a 00		 push	 0
  002a1	68 00 00 00 00	 push	 OFFSET ??_C@_04OPMHGHMB@Copy@
  002a6	e8 00 00 00 00	 call	 ?BeginPopup@ImGui@@YA_NPBDH@Z ; ImGui::BeginPopup
  002ab	83 c4 08	 add	 esp, 8
  002ae	0f b6 c0	 movzx	 eax, al
  002b1	85 c0		 test	 eax, eax
  002b3	0f 84 1c 03 00
	00		 je	 $LN16@ColorEditO

; 5004 :     {
; 5005 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

  002b9	b8 04 00 00 00	 mov	 eax, 4
  002be	6b c8 00	 imul	 ecx, eax, 0
  002c1	8b 55 08	 mov	 edx, DWORD PTR _col$[ebp]
  002c4	51		 push	 ecx
  002c5	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  002ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002cf	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  002d4	83 c4 04	 add	 esp, 4
  002d7	d9 9d 50 fe ff
	ff		 fstp	 DWORD PTR tv357[ebp]
  002dd	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR tv357[ebp]
  002e5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  002ed	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  002f5	f3 0f 2c c0	 cvttss2si eax, xmm0
  002f9	89 45 c4	 mov	 DWORD PTR _cr$9[ebp], eax
  002fc	b8 04 00 00 00	 mov	 eax, 4
  00301	c1 e0 00	 shl	 eax, 0
  00304	8b 4d 08	 mov	 ecx, DWORD PTR _col$[ebp]
  00307	51		 push	 ecx
  00308	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0030d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00312	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00317	83 c4 04	 add	 esp, 4
  0031a	d9 9d 50 fe ff
	ff		 fstp	 DWORD PTR tv365[ebp]
  00320	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR tv365[ebp]
  00328	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00330	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00338	f3 0f 2c d0	 cvttss2si edx, xmm0
  0033c	89 55 b8	 mov	 DWORD PTR _cg$8[ebp], edx
  0033f	b8 04 00 00 00	 mov	 eax, 4
  00344	d1 e0		 shl	 eax, 1
  00346	8b 4d 08	 mov	 ecx, DWORD PTR _col$[ebp]
  00349	51		 push	 ecx
  0034a	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0034f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00354	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00359	83 c4 04	 add	 esp, 4
  0035c	d9 9d 50 fe ff
	ff		 fstp	 DWORD PTR tv373[ebp]
  00362	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR tv373[ebp]
  0036a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00372	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0037a	f3 0f 2c d0	 cvttss2si edx, xmm0
  0037e	89 55 ac	 mov	 DWORD PTR _cb$7[ebp], edx
  00381	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00384	83 e0 02	 and	 eax, 2
  00387	74 0c		 je	 SHORT $LN37@ColorEditO
  00389	c7 85 50 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv223[ebp], 255 ; 000000ffH
  00393	eb 46		 jmp	 SHORT $LN38@ColorEditO
$LN37@ColorEditO:
  00395	b9 04 00 00 00	 mov	 ecx, 4
  0039a	6b d1 03	 imul	 edx, ecx, 3
  0039d	8b 45 08	 mov	 eax, DWORD PTR _col$[ebp]
  003a0	51		 push	 ecx
  003a1	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  003a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ab	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  003b0	83 c4 04	 add	 esp, 4
  003b3	d9 9d 4c fe ff
	ff		 fstp	 DWORD PTR tv382[ebp]
  003b9	f3 0f 10 85 4c
	fe ff ff	 movss	 xmm0, DWORD PTR tv382[ebp]
  003c1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  003c9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  003d1	f3 0f 2c c8	 cvttss2si ecx, xmm0
  003d5	89 8d 50 fe ff
	ff		 mov	 DWORD PTR tv223[ebp], ecx
$LN38@ColorEditO:
  003db	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR tv223[ebp]
  003e1	89 55 a0	 mov	 DWORD PTR _ca$6[ebp], edx

; 5006 :         char buf[64];
; 5007 :         ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

  003e4	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  003e7	83 e0 02	 and	 eax, 2
  003ea	74 12		 je	 SHORT $LN39@ColorEditO
  003ec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003f4	f3 0f 11 85 50
	fe ff ff	 movss	 DWORD PTR tv229[ebp], xmm0
  003fc	eb 18		 jmp	 SHORT $LN40@ColorEditO
$LN39@ColorEditO:
  003fe	b9 04 00 00 00	 mov	 ecx, 4
  00403	6b d1 03	 imul	 edx, ecx, 3
  00406	8b 45 08	 mov	 eax, DWORD PTR _col$[ebp]
  00409	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  0040e	f3 0f 11 85 50
	fe ff ff	 movss	 DWORD PTR tv229[ebp], xmm0
$LN40@ColorEditO:
  00416	f3 0f 5a 85 50
	fe ff ff	 cvtss2sd xmm0, DWORD PTR tv229[ebp]
  0041e	83 ec 08	 sub	 esp, 8
  00421	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00426	b9 04 00 00 00	 mov	 ecx, 4
  0042b	d1 e1		 shl	 ecx, 1
  0042d	8b 55 08	 mov	 edx, DWORD PTR _col$[ebp]
  00430	f3 0f 5a 04 0a	 cvtss2sd xmm0, DWORD PTR [edx+ecx]
  00435	83 ec 08	 sub	 esp, 8
  00438	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0043d	b8 04 00 00 00	 mov	 eax, 4
  00442	c1 e0 00	 shl	 eax, 0
  00445	8b 4d 08	 mov	 ecx, DWORD PTR _col$[ebp]
  00448	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  0044d	83 ec 08	 sub	 esp, 8
  00450	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00455	ba 04 00 00 00	 mov	 edx, 4
  0045a	6b c2 00	 imul	 eax, edx, 0
  0045d	8b 4d 08	 mov	 ecx, DWORD PTR _col$[ebp]
  00460	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  00465	83 ec 08	 sub	 esp, 8
  00468	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0046d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@
  00472	6a 40		 push	 64			; 00000040H
  00474	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _buf$5[ebp]
  0047a	52		 push	 edx
  0047b	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00480	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5008 :         if (Selectable(buf))

  00483	51		 push	 ecx
  00484	0f 57 c0	 xorps	 xmm0, xmm0
  00487	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0048c	51		 push	 ecx
  0048d	0f 57 c0	 xorps	 xmm0, xmm0
  00490	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00495	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0049b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  004a0	50		 push	 eax
  004a1	6a 00		 push	 0
  004a3	6a 00		 push	 0
  004a5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  004ab	50		 push	 eax
  004ac	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  004b1	83 c4 10	 add	 esp, 16			; 00000010H
  004b4	0f b6 c8	 movzx	 ecx, al
  004b7	85 c9		 test	 ecx, ecx
  004b9	74 0f		 je	 SHORT $LN17@ColorEditO

; 5009 :             SetClipboardText(buf);

  004bb	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  004c1	50		 push	 eax
  004c2	e8 00 00 00 00	 call	 ?SetClipboardText@ImGui@@YAXPBD@Z ; ImGui::SetClipboardText
  004c7	83 c4 04	 add	 esp, 4
$LN17@ColorEditO:

; 5010 :         ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);

  004ca	8b 45 a0	 mov	 eax, DWORD PTR _ca$6[ebp]
  004cd	50		 push	 eax
  004ce	8b 4d ac	 mov	 ecx, DWORD PTR _cb$7[ebp]
  004d1	51		 push	 ecx
  004d2	8b 55 b8	 mov	 edx, DWORD PTR _cg$8[ebp]
  004d5	52		 push	 edx
  004d6	8b 45 c4	 mov	 eax, DWORD PTR _cr$9[ebp]
  004d9	50		 push	 eax
  004da	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@
  004df	6a 40		 push	 64			; 00000040H
  004e1	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$5[ebp]
  004e7	51		 push	 ecx
  004e8	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  004ed	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5011 :         if (Selectable(buf))

  004f0	51		 push	 ecx
  004f1	0f 57 c0	 xorps	 xmm0, xmm0
  004f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004f9	51		 push	 ecx
  004fa	0f 57 c0	 xorps	 xmm0, xmm0
  004fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00502	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00508	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0050d	50		 push	 eax
  0050e	6a 00		 push	 0
  00510	6a 00		 push	 0
  00512	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  00518	50		 push	 eax
  00519	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  0051e	83 c4 10	 add	 esp, 16			; 00000010H
  00521	0f b6 c8	 movzx	 ecx, al
  00524	85 c9		 test	 ecx, ecx
  00526	74 0f		 je	 SHORT $LN18@ColorEditO

; 5012 :             SetClipboardText(buf);

  00528	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 ?SetClipboardText@ImGui@@YAXPBD@Z ; ImGui::SetClipboardText
  00534	83 c4 04	 add	 esp, 4
$LN18@ColorEditO:

; 5013 :         if (flags & ImGuiColorEditFlags_NoAlpha)

  00537	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0053a	83 e0 02	 and	 eax, 2
  0053d	74 24		 je	 SHORT $LN19@ColorEditO

; 5014 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X", cr, cg, cb);

  0053f	8b 45 ac	 mov	 eax, DWORD PTR _cb$7[ebp]
  00542	50		 push	 eax
  00543	8b 4d b8	 mov	 ecx, DWORD PTR _cg$8[ebp]
  00546	51		 push	 ecx
  00547	8b 55 c4	 mov	 edx, DWORD PTR _cr$9[ebp]
  0054a	52		 push	 edx
  0054b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GDANBODO@0x?$CF02X?$CF02X?$CF02X@
  00550	6a 40		 push	 64			; 00000040H
  00552	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  00558	50		 push	 eax
  00559	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0055e	83 c4 18	 add	 esp, 24			; 00000018H
  00561	eb 26		 jmp	 SHORT $LN20@ColorEditO
$LN19@ColorEditO:

; 5015 :         else
; 5016 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X%02X", cr, cg, cb, ca);

  00563	8b 45 a0	 mov	 eax, DWORD PTR _ca$6[ebp]
  00566	50		 push	 eax
  00567	8b 4d ac	 mov	 ecx, DWORD PTR _cb$7[ebp]
  0056a	51		 push	 ecx
  0056b	8b 55 b8	 mov	 edx, DWORD PTR _cg$8[ebp]
  0056e	52		 push	 edx
  0056f	8b 45 c4	 mov	 eax, DWORD PTR _cr$9[ebp]
  00572	50		 push	 eax
  00573	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MLNOPBDA@0x?$CF02X?$CF02X?$CF02X?$CF02X@
  00578	6a 40		 push	 64			; 00000040H
  0057a	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$5[ebp]
  00580	51		 push	 ecx
  00581	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00586	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN20@ColorEditO:

; 5017 :         if (Selectable(buf))

  00589	51		 push	 ecx
  0058a	0f 57 c0	 xorps	 xmm0, xmm0
  0058d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00592	51		 push	 ecx
  00593	0f 57 c0	 xorps	 xmm0, xmm0
  00596	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0059b	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  005a1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  005a6	50		 push	 eax
  005a7	6a 00		 push	 0
  005a9	6a 00		 push	 0
  005ab	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  005b1	50		 push	 eax
  005b2	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  005b7	83 c4 10	 add	 esp, 16			; 00000010H
  005ba	0f b6 c8	 movzx	 ecx, al
  005bd	85 c9		 test	 ecx, ecx
  005bf	74 0f		 je	 SHORT $LN21@ColorEditO

; 5018 :             SetClipboardText(buf);

  005c1	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  005c7	50		 push	 eax
  005c8	e8 00 00 00 00	 call	 ?SetClipboardText@ImGui@@YAXPBD@Z ; ImGui::SetClipboardText
  005cd	83 c4 04	 add	 esp, 4
$LN21@ColorEditO:

; 5019 :         EndPopup();

  005d0	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup
$LN16@ColorEditO:

; 5020 :     }
; 5021 : 
; 5022 :     g.ColorEditOptions = opts;

  005d5	8b 45 dc	 mov	 eax, DWORD PTR _g$[ebp]
  005d8	8b 4d d0	 mov	 ecx, DWORD PTR _opts$[ebp]
  005db	89 88 d4 2c 00
	00		 mov	 DWORD PTR [eax+11476], ecx

; 5023 :     EndPopup();

  005e1	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup
$LN1@ColorEditO:

; 5024 : }

  005e6	52		 push	 edx
  005e7	8b cd		 mov	 ecx, ebp
  005e9	50		 push	 eax
  005ea	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN43@ColorEditO
  005f0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005f5	58		 pop	 eax
  005f6	5a		 pop	 edx
  005f7	5f		 pop	 edi
  005f8	5e		 pop	 esi
  005f9	5b		 pop	 ebx
  005fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005fd	33 cd		 xor	 ecx, ebp
  005ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00604	81 c4 b4 01 00
	00		 add	 esp, 436		; 000001b4H
  0060a	3b ec		 cmp	 ebp, esp
  0060c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00611	8b e5		 mov	 esp, ebp
  00613	5d		 pop	 ebp
  00614	c3		 ret	 0
  00615	0f 1f 00	 npad	 3
$LN43@ColorEditO:
  00618	01 00 00 00	 DD	 1
  0061c	00 00 00 00	 DD	 $LN42@ColorEditO
$LN42@ColorEditO:
  00620	58 ff ff ff	 DD	 -168			; ffffff58H
  00624	40 00 00 00	 DD	 64			; 00000040H
  00628	00 00 00 00	 DD	 $LN41@ColorEditO
$LN41@ColorEditO:
  0062c	62		 DB	 98			; 00000062H
  0062d	75		 DB	 117			; 00000075H
  0062e	66		 DB	 102			; 00000066H
  0062f	00		 DB	 0
?ColorEditOptionsPopup@ImGui@@YAXPBMH@Z ENDP		; ImGui::ColorEditOptionsPopup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorTooltip@ImGui@@YAXPBDPBMH@Z
_TEXT	SEGMENT
tv341 = -316						; size = 4
tv332 = -312						; size = 4
tv324 = -312						; size = 4
tv316 = -312						; size = 4
tv174 = -312						; size = 4
tv130 = -312						; size = 4
tv70 = -312						; size = 4
_ca$ = -112						; size = 4
_cb$ = -100						; size = 4
_cg$ = -88						; size = 4
_cr$ = -76						; size = 4
_cf$ = -64						; size = 16
_sz$ = -40						; size = 8
_text_end$ = -24					; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_col$ = 12						; size = 4
_flags$ = 16						; size = 4
?ColorTooltip@ImGui@@YAXPBDPBMH@Z PROC			; ImGui::ColorTooltip, COMDAT

; 4945 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-316]
  00012	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4946 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 4947 : 
; 4948 :     BeginTooltipEx(0, true);

  0003a	6a 01		 push	 1
  0003c	6a 00		 push	 0
  0003e	e8 00 00 00 00	 call	 ?BeginTooltipEx@ImGui@@YAXH_N@Z ; ImGui::BeginTooltipEx
  00043	83 c4 08	 add	 esp, 8

; 4949 :     const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;

  00046	83 7d 08 00	 cmp	 DWORD PTR _text$[ebp], 0
  0004a	74 16		 je	 SHORT $LN12@ColorToolt
  0004c	6a 00		 push	 0
  0004e	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  00057	83 c4 08	 add	 esp, 8
  0005a	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  00060	eb 09		 jmp	 SHORT $LN13@ColorToolt
$LN12@ColorToolt:
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _text$[ebp]
  00065	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv70[ebp], ecx
$LN13@ColorToolt:
  0006b	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv70[ebp]
  00071	89 55 e8	 mov	 DWORD PTR _text_end$[ebp], edx

; 4950 :     if (text_end > text)

  00074	8b 45 e8	 mov	 eax, DWORD PTR _text_end$[ebp]
  00077	3b 45 08	 cmp	 eax, DWORD PTR _text$[ebp]
  0007a	76 17		 jbe	 SHORT $LN2@ColorToolt

; 4951 :     {
; 4952 :         TextEx(text, text_end);

  0007c	6a 00		 push	 0
  0007e	8b 45 e8	 mov	 eax, DWORD PTR _text_end$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _text$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4953 :         Separator();

  0008e	e8 00 00 00 00	 call	 ?Separator@ImGui@@YAXXZ	; ImGui::Separator
$LN2@ColorToolt:

; 4954 :     }
; 4955 : 
; 4956 :     ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);

  00093	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00096	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  0009e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  000a6	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  000a9	f3 0f 10 89 4c
	15 00 00	 movss	 xmm1, DWORD PTR [ecx+5452]
  000b1	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  000b9	f3 0f 58 c1	 addss	 xmm0, xmm1
  000bd	51		 push	 ecx
  000be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c3	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  000c6	f3 0f 10 82 c4
	18 00 00	 movss	 xmm0, DWORD PTR [edx+6340]
  000ce	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000d9	f3 0f 10 88 4c
	15 00 00	 movss	 xmm1, DWORD PTR [eax+5452]
  000e1	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  000e9	f3 0f 58 c1	 addss	 xmm0, xmm1
  000ed	51		 push	 ecx
  000ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f3	8d 4d d8	 lea	 ecx, DWORD PTR _sz$[ebp]
  000f6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4957 :     ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

  000fb	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000fe	83 e0 02	 and	 eax, 2
  00101	74 12		 je	 SHORT $LN14@ColorToolt
  00103	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0010b	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR tv130[ebp], xmm0
  00113	eb 18		 jmp	 SHORT $LN15@ColorToolt
$LN14@ColorToolt:
  00115	b9 04 00 00 00	 mov	 ecx, 4
  0011a	6b d1 03	 imul	 edx, ecx, 3
  0011d	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00120	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00125	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR tv130[ebp], xmm0
$LN15@ColorToolt:
  0012d	51		 push	 ecx
  0012e	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR tv130[ebp]
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	b9 04 00 00 00	 mov	 ecx, 4
  00140	d1 e1		 shl	 ecx, 1
  00142	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  00145	51		 push	 ecx
  00146	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  0014b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00150	b8 04 00 00 00	 mov	 eax, 4
  00155	c1 e0 00	 shl	 eax, 0
  00158	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  0015b	51		 push	 ecx
  0015c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00161	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00166	ba 04 00 00 00	 mov	 edx, 4
  0016b	6b c2 00	 imul	 eax, edx, 0
  0016e	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00171	51		 push	 ecx
  00172	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017c	8d 4d c0	 lea	 ecx, DWORD PTR _cf$[ebp]
  0017f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4

; 4958 :     int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

  00184	b8 04 00 00 00	 mov	 eax, 4
  00189	6b c8 00	 imul	 ecx, eax, 0
  0018c	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  0018f	51		 push	 ecx
  00190	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00195	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019a	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0019f	83 c4 04	 add	 esp, 4
  001a2	d9 9d c8 fe ff
	ff		 fstp	 DWORD PTR tv316[ebp]
  001a8	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR tv316[ebp]
  001b0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001b8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001c0	f3 0f 2c c0	 cvttss2si eax, xmm0
  001c4	89 45 b4	 mov	 DWORD PTR _cr$[ebp], eax
  001c7	b8 04 00 00 00	 mov	 eax, 4
  001cc	c1 e0 00	 shl	 eax, 0
  001cf	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  001d2	51		 push	 ecx
  001d3	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001dd	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  001e2	83 c4 04	 add	 esp, 4
  001e5	d9 9d c8 fe ff
	ff		 fstp	 DWORD PTR tv324[ebp]
  001eb	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR tv324[ebp]
  001f3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001fb	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00203	f3 0f 2c d0	 cvttss2si edx, xmm0
  00207	89 55 a8	 mov	 DWORD PTR _cg$[ebp], edx
  0020a	b8 04 00 00 00	 mov	 eax, 4
  0020f	d1 e0		 shl	 eax, 1
  00211	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00214	51		 push	 ecx
  00215	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0021a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021f	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00224	83 c4 04	 add	 esp, 4
  00227	d9 9d c8 fe ff
	ff		 fstp	 DWORD PTR tv332[ebp]
  0022d	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR tv332[ebp]
  00235	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0023d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00245	f3 0f 2c d0	 cvttss2si edx, xmm0
  00249	89 55 9c	 mov	 DWORD PTR _cb$[ebp], edx
  0024c	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0024f	83 e0 02	 and	 eax, 2
  00252	74 0c		 je	 SHORT $LN16@ColorToolt
  00254	c7 85 c8 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv174[ebp], 255 ; 000000ffH
  0025e	eb 46		 jmp	 SHORT $LN17@ColorToolt
$LN16@ColorToolt:
  00260	b9 04 00 00 00	 mov	 ecx, 4
  00265	6b d1 03	 imul	 edx, ecx, 3
  00268	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0026b	51		 push	 ecx
  0026c	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00271	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00276	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0027b	83 c4 04	 add	 esp, 4
  0027e	d9 9d c4 fe ff
	ff		 fstp	 DWORD PTR tv341[ebp]
  00284	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR tv341[ebp]
  0028c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00294	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0029c	f3 0f 2c c8	 cvttss2si ecx, xmm0
  002a0	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv174[ebp], ecx
$LN17@ColorToolt:
  002a6	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv174[ebp]
  002ac	89 55 90	 mov	 DWORD PTR _ca$[ebp], edx

; 4959 :     ColorButton("##preview", cf, (flags & (ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);

  002af	8b 45 dc	 mov	 eax, DWORD PTR _sz$[ebp+4]
  002b2	50		 push	 eax
  002b3	8b 4d d8	 mov	 ecx, DWORD PTR _sz$[ebp]
  002b6	51		 push	 ecx
  002b7	8b 55 10	 mov	 edx, DWORD PTR _flags$[ebp]
  002ba	81 e2 02 00 06
	18		 and	 edx, 403046402		; 18060002H
  002c0	83 ca 40	 or	 edx, 64			; 00000040H
  002c3	52		 push	 edx
  002c4	8d 45 c0	 lea	 eax, DWORD PTR _cf$[ebp]
  002c7	50		 push	 eax
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_09JCCDBEFL@?$CD?$CDpreview@
  002cd	e8 00 00 00 00	 call	 ?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
  002d2	83 c4 14	 add	 esp, 20			; 00000014H

; 4960 :     SameLine();

  002d5	51		 push	 ecx
  002d6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  002de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e3	51		 push	 ecx
  002e4	0f 57 c0	 xorps	 xmm0, xmm0
  002e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ec	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  002f1	83 c4 08	 add	 esp, 8

; 4961 :     if ((flags & ImGuiColorEditFlags_InputRGB) || !(flags & ImGuiColorEditFlags__InputMask))

  002f4	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  002f7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002fc	75 0e		 jne	 SHORT $LN5@ColorToolt
  002fe	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00301	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  00306	0f 85 0a 01 00
	00		 jne	 $LN3@ColorToolt
$LN5@ColorToolt:

; 4962 :     {
; 4963 :         if (flags & ImGuiColorEditFlags_NoAlpha)

  0030c	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0030f	83 e0 02	 and	 eax, 2
  00312	74 71		 je	 SHORT $LN6@ColorToolt

; 4964 :             Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);

  00314	b8 04 00 00 00	 mov	 eax, 4
  00319	d1 e0		 shl	 eax, 1
  0031b	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  0031e	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  00323	83 ec 08	 sub	 esp, 8
  00326	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0032b	ba 04 00 00 00	 mov	 edx, 4
  00330	c1 e2 00	 shl	 edx, 0
  00333	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00336	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  0033b	83 ec 08	 sub	 esp, 8
  0033e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00343	b9 04 00 00 00	 mov	 ecx, 4
  00348	6b d1 00	 imul	 edx, ecx, 0
  0034b	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0034e	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  00353	83 ec 08	 sub	 esp, 8
  00356	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0035b	8b 4d 9c	 mov	 ecx, DWORD PTR _cb$[ebp]
  0035e	51		 push	 ecx
  0035f	8b 55 a8	 mov	 edx, DWORD PTR _cg$[ebp]
  00362	52		 push	 edx
  00363	8b 45 b4	 mov	 eax, DWORD PTR _cr$[ebp]
  00366	50		 push	 eax
  00367	8b 4d 9c	 mov	 ecx, DWORD PTR _cb$[ebp]
  0036a	51		 push	 ecx
  0036b	8b 55 a8	 mov	 edx, DWORD PTR _cg$[ebp]
  0036e	52		 push	 edx
  0036f	8b 45 b4	 mov	 eax, DWORD PTR _cr$[ebp]
  00372	50		 push	 eax
  00373	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@
  00378	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  0037d	83 c4 34	 add	 esp, 52			; 00000034H
  00380	e9 8c 00 00 00	 jmp	 $LN7@ColorToolt
$LN6@ColorToolt:

; 4965 :         else
; 4966 :             Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);

  00385	b8 04 00 00 00	 mov	 eax, 4
  0038a	6b c8 03	 imul	 ecx, eax, 3
  0038d	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  00390	f3 0f 5a 04 0a	 cvtss2sd xmm0, DWORD PTR [edx+ecx]
  00395	83 ec 08	 sub	 esp, 8
  00398	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0039d	b8 04 00 00 00	 mov	 eax, 4
  003a2	d1 e0		 shl	 eax, 1
  003a4	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  003a7	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  003ac	83 ec 08	 sub	 esp, 8
  003af	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003b4	ba 04 00 00 00	 mov	 edx, 4
  003b9	c1 e2 00	 shl	 edx, 0
  003bc	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  003bf	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  003c4	83 ec 08	 sub	 esp, 8
  003c7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003cc	b9 04 00 00 00	 mov	 ecx, 4
  003d1	6b d1 00	 imul	 edx, ecx, 0
  003d4	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  003d7	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  003dc	83 ec 08	 sub	 esp, 8
  003df	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003e4	8b 4d 90	 mov	 ecx, DWORD PTR _ca$[ebp]
  003e7	51		 push	 ecx
  003e8	8b 55 9c	 mov	 edx, DWORD PTR _cb$[ebp]
  003eb	52		 push	 edx
  003ec	8b 45 a8	 mov	 eax, DWORD PTR _cg$[ebp]
  003ef	50		 push	 eax
  003f0	8b 4d b4	 mov	 ecx, DWORD PTR _cr$[ebp]
  003f3	51		 push	 ecx
  003f4	8b 55 90	 mov	 edx, DWORD PTR _ca$[ebp]
  003f7	52		 push	 edx
  003f8	8b 45 9c	 mov	 eax, DWORD PTR _cb$[ebp]
  003fb	50		 push	 eax
  003fc	8b 4d a8	 mov	 ecx, DWORD PTR _cg$[ebp]
  003ff	51		 push	 ecx
  00400	8b 55 b4	 mov	 edx, DWORD PTR _cr$[ebp]
  00403	52		 push	 edx
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@
  00409	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  0040e	83 c4 44	 add	 esp, 68			; 00000044H
$LN7@ColorToolt:

; 4967 :     }

  00411	e9 d8 00 00 00	 jmp	 $LN10@ColorToolt
$LN3@ColorToolt:

; 4968 :     else if (flags & ImGuiColorEditFlags_InputHSV)

  00416	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00419	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0041e	0f 84 ca 00 00
	00		 je	 $LN10@ColorToolt

; 4969 :     {
; 4970 :         if (flags & ImGuiColorEditFlags_NoAlpha)

  00424	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00427	83 e0 02	 and	 eax, 2
  0042a	74 56		 je	 SHORT $LN9@ColorToolt

; 4971 :             Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);

  0042c	b8 04 00 00 00	 mov	 eax, 4
  00431	d1 e0		 shl	 eax, 1
  00433	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00436	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  0043b	83 ec 08	 sub	 esp, 8
  0043e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00443	ba 04 00 00 00	 mov	 edx, 4
  00448	c1 e2 00	 shl	 edx, 0
  0044b	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0044e	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  00453	83 ec 08	 sub	 esp, 8
  00456	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0045b	b9 04 00 00 00	 mov	 ecx, 4
  00460	6b d1 00	 imul	 edx, ecx, 0
  00463	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00466	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  0046b	83 ec 08	 sub	 esp, 8
  0046e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00473	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@
  00478	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  0047d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00480	eb 6c		 jmp	 SHORT $LN10@ColorToolt
$LN9@ColorToolt:

; 4972 :         else
; 4973 :             Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]);

  00482	b8 04 00 00 00	 mov	 eax, 4
  00487	6b c8 03	 imul	 ecx, eax, 3
  0048a	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  0048d	f3 0f 5a 04 0a	 cvtss2sd xmm0, DWORD PTR [edx+ecx]
  00492	83 ec 08	 sub	 esp, 8
  00495	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0049a	b8 04 00 00 00	 mov	 eax, 4
  0049f	d1 e0		 shl	 eax, 1
  004a1	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  004a4	f3 0f 5a 04 01	 cvtss2sd xmm0, DWORD PTR [ecx+eax]
  004a9	83 ec 08	 sub	 esp, 8
  004ac	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004b1	ba 04 00 00 00	 mov	 edx, 4
  004b6	c1 e2 00	 shl	 edx, 0
  004b9	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  004bc	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  004c1	83 ec 08	 sub	 esp, 8
  004c4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004c9	b9 04 00 00 00	 mov	 ecx, 4
  004ce	6b d1 00	 imul	 edx, ecx, 0
  004d1	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  004d4	f3 0f 5a 04 10	 cvtss2sd xmm0, DWORD PTR [eax+edx]
  004d9	83 ec 08	 sub	 esp, 8
  004dc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004e1	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@
  004e6	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  004eb	83 c4 24	 add	 esp, 36			; 00000024H
$LN10@ColorToolt:

; 4974 :     }
; 4975 :     EndTooltip();

  004ee	e8 00 00 00 00	 call	 ?EndTooltip@ImGui@@YAXXZ ; ImGui::EndTooltip

; 4976 : }

  004f3	52		 push	 edx
  004f4	8b cd		 mov	 ecx, ebp
  004f6	50		 push	 eax
  004f7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@ColorToolt
  004fd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00502	58		 pop	 eax
  00503	5a		 pop	 edx
  00504	5f		 pop	 edi
  00505	5e		 pop	 esi
  00506	5b		 pop	 ebx
  00507	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050a	33 cd		 xor	 ecx, ebp
  0050c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00511	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  00517	3b ec		 cmp	 ebp, esp
  00519	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0051e	8b e5		 mov	 esp, ebp
  00520	5d		 pop	 ebp
  00521	c3		 ret	 0
  00522	66 90		 npad	 2
$LN21@ColorToolt:
  00524	02 00 00 00	 DD	 2
  00528	00 00 00 00	 DD	 $LN20@ColorToolt
$LN20@ColorToolt:
  0052c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00530	08 00 00 00	 DD	 8
  00534	00 00 00 00	 DD	 $LN18@ColorToolt
  00538	c0 ff ff ff	 DD	 -64			; ffffffc0H
  0053c	10 00 00 00	 DD	 16			; 00000010H
  00540	00 00 00 00	 DD	 $LN19@ColorToolt
$LN19@ColorToolt:
  00544	63		 DB	 99			; 00000063H
  00545	66		 DB	 102			; 00000066H
  00546	00		 DB	 0
$LN18@ColorToolt:
  00547	73		 DB	 115			; 00000073H
  00548	7a		 DB	 122			; 0000007aH
  00549	00		 DB	 0
?ColorTooltip@ImGui@@YAXPBDPBMH@Z ENDP			; ImGui::ColorTooltip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?TempInputTextIsActive@ImGui@@YA_NI@Z
_TEXT	SEGMENT
tv68 = -208						; size = 4
_g$ = -8						; size = 4
_id$ = 8						; size = 4
?TempInputTextIsActive@ImGui@@YA_NI@Z PROC		; ImGui::TempInputTextIsActive, COMDAT

; 1793 :     inline bool             TempInputTextIsActive(ImGuiID id) { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputTextId == id); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax
  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00039	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  0003c	75 1a		 jne	 SHORT $LN3@TempInputT
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00041	8b 82 d0 2c 00
	00		 mov	 eax, DWORD PTR [edx+11472]
  00047	3b 45 08	 cmp	 eax, DWORD PTR _id$[ebp]
  0004a	75 0c		 jne	 SHORT $LN3@TempInputT
  0004c	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
  00056	eb 0a		 jmp	 SHORT $LN4@TempInputT
$LN3@TempInputT:
  00058	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN4@TempInputT:
  00062	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?TempInputTextIsActive@ImGui@@YA_NI@Z ENDP		; ImGui::TempInputTextIsActive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z
_TEXT	SEGMENT
tv86 = -344						; size = 4
tv66 = -341						; size = 1
$T1 = -336						; size = 8
_value_changed$ = -125					; size = 1
_flags$ = -116						; size = 4
_data_buf$ = -104					; size = 32
_fmt_buf$ = -64						; size = 32
_init$ = -21						; size = 1
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_label$ = 16						; size = 4
_data_type$ = 20					; size = 4
_p_data$ = 24						; size = 4
_format$ = 28						; size = 4
?TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z PROC ; ImGui::TempInputTextScalar, COMDAT

; 2841 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-344]
  00012	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2842 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2843 : 
; 2844 :     // On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
; 2845 :     // We clear ActiveID on the first frame to allow the InputText() taking it back.
; 2846 :     const bool init = (g.TempInputTextId != id);

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 d0 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11472]
  00043	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00046	74 09		 je	 SHORT $LN7@TempInputT
  00048	c6 85 ab fe ff
	ff 01		 mov	 BYTE PTR tv66[ebp], 1
  0004f	eb 07		 jmp	 SHORT $LN8@TempInputT
$LN7@TempInputT:
  00051	c6 85 ab fe ff
	ff 00		 mov	 BYTE PTR tv66[ebp], 0
$LN8@TempInputT:
  00058	8a 95 ab fe ff
	ff		 mov	 dl, BYTE PTR tv66[ebp]
  0005e	88 55 eb	 mov	 BYTE PTR _init$[ebp], dl

; 2847 :     if (init)

  00061	0f b6 45 eb	 movzx	 eax, BYTE PTR _init$[ebp]
  00065	85 c0		 test	 eax, eax
  00067	74 05		 je	 SHORT $LN2@TempInputT

; 2848 :         ClearActiveID();

  00069	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN2@TempInputT:

; 2849 : 
; 2850 :     char fmt_buf[32];
; 2851 :     char data_buf[32];
; 2852 :     format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));

  0006e	6a 20		 push	 32			; 00000020H
  00070	8d 45 c0	 lea	 eax, DWORD PTR _fmt_buf$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 1c	 mov	 ecx, DWORD PTR _format$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?ImParseFormatTrimDecorations@@YAPBDPBDPADI@Z ; ImParseFormatTrimDecorations
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	89 45 1c	 mov	 DWORD PTR _format$[ebp], eax

; 2853 :     DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, p_data, format);

  00083	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 18	 mov	 ecx, DWORD PTR _p_data$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 14	 mov	 edx, DWORD PTR _data_type$[ebp]
  0008e	52		 push	 edx
  0008f	6a 20		 push	 32			; 00000020H
  00091	8d 45 98	 lea	 eax, DWORD PTR _data_buf$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z ; ImGui::DataTypeFormatString
  0009a	83 c4 14	 add	 esp, 20			; 00000014H

; 2854 :     ImStrTrimBlanks(data_buf);

  0009d	8d 45 98	 lea	 eax, DWORD PTR _data_buf$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?ImStrTrimBlanks@@YAXPAD@Z ; ImStrTrimBlanks
  000a6	83 c4 04	 add	 esp, 4

; 2855 : 
; 2856 :     g.CurrentWindow->DC.CursorPos = bb.Min;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  000ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ae	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b1	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000b4	8b 80 b0 19 00
	00		 mov	 eax, DWORD PTR [eax+6576]
  000ba	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  000c0	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 2857 :     ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoMarkEdited;

  000c6	c7 45 8c 10 00
	20 00		 mov	 DWORD PTR _flags$[ebp], 2097168 ; 00200010H

; 2858 :     flags |= ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);

  000cd	83 7d 14 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  000d1	74 12		 je	 SHORT $LN9@TempInputT
  000d3	83 7d 14 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000d7	74 0c		 je	 SHORT $LN9@TempInputT
  000d9	c7 85 a8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv86[ebp], 1
  000e3	eb 0a		 jmp	 SHORT $LN10@TempInputT
$LN9@TempInputT:
  000e5	c7 85 a8 fe ff
	ff 00 00 02 00	 mov	 DWORD PTR tv86[ebp], 131072 ; 00020000H
$LN10@TempInputT:
  000ef	8b 45 8c	 mov	 eax, DWORD PTR _flags$[ebp]
  000f2	0b 85 a8 fe ff
	ff		 or	 eax, DWORD PTR tv86[ebp]
  000f8	89 45 8c	 mov	 DWORD PTR _flags$[ebp], eax

; 2859 :     bool value_changed = InputTextEx(label, NULL, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);

  000fb	6a 00		 push	 0
  000fd	6a 00		 push	 0
  000ff	8b 45 8c	 mov	 eax, DWORD PTR _flags$[ebp]
  00102	50		 push	 eax
  00103	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00109	51		 push	 ecx
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  0010d	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetSize
  00112	50		 push	 eax
  00113	6a 20		 push	 32			; 00000020H
  00115	8d 55 98	 lea	 edx, DWORD PTR _data_buf$[ebp]
  00118	52		 push	 edx
  00119	6a 00		 push	 0
  0011b	8b 45 10	 mov	 eax, DWORD PTR _label$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
  00124	83 c4 20	 add	 esp, 32			; 00000020H
  00127	88 45 83	 mov	 BYTE PTR _value_changed$[ebp], al

; 2860 :     if (init)

  0012a	0f b6 45 eb	 movzx	 eax, BYTE PTR _init$[ebp]
  0012e	85 c0		 test	 eax, eax
  00130	74 46		 je	 SHORT $LN3@TempInputT

; 2861 :     {
; 2862 :         // First frame we started displaying the InputText widget, we expect it to take the active id.
; 2863 :         IM_ASSERT(g.ActiveId == id);

  00132	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00135	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0013b	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0013e	74 26		 je	 SHORT $LN11@TempInputT
  00140	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z@4JA
  00146	83 c2 16	 add	 edx, 22			; 00000016H
  00149	8b f4		 mov	 esi, esp
  0014b	52		 push	 edx
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@LLIJAMKA@?$AAg?$AA?4?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AAI?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi@
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015f	3b f4		 cmp	 esi, esp
  00161	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@TempInputT:

; 2864 :         g.TempInputTextId = g.ActiveId;

  00166	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00169	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0016c	8b 91 e4 19 00
	00		 mov	 edx, DWORD PTR [ecx+6628]
  00172	89 90 d0 2c 00
	00		 mov	 DWORD PTR [eax+11472], edx
$LN3@TempInputT:

; 2865 :     }
; 2866 :     if (value_changed)

  00178	0f b6 45 83	 movzx	 eax, BYTE PTR _value_changed$[ebp]
  0017c	85 c0		 test	 eax, eax
  0017e	74 37		 je	 SHORT $LN4@TempInputT

; 2867 :     {
; 2868 :         value_changed = DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialTextA.Data, data_type, p_data, NULL);

  00180	6a 00		 push	 0
  00182	8b 45 18	 mov	 eax, DWORD PTR _p_data$[ebp]
  00185	50		 push	 eax
  00186	8b 4d 14	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00189	51		 push	 ecx
  0018a	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  0018d	8b 82 2c 1e 00
	00		 mov	 eax, DWORD PTR [edx+7724]
  00193	50		 push	 eax
  00194	8d 4d 98	 lea	 ecx, DWORD PTR _data_buf$[ebp]
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 ?DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z ; ImGui::DataTypeApplyOpFromText
  0019d	83 c4 14	 add	 esp, 20			; 00000014H
  001a0	88 45 83	 mov	 BYTE PTR _value_changed$[ebp], al

; 2869 :         if (value_changed)

  001a3	0f b6 45 83	 movzx	 eax, BYTE PTR _value_changed$[ebp]
  001a7	85 c0		 test	 eax, eax
  001a9	74 0c		 je	 SHORT $LN4@TempInputT

; 2870 :             MarkItemEdited(id);

  001ab	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  001b4	83 c4 04	 add	 esp, 4
$LN4@TempInputT:

; 2871 :     }
; 2872 :     return value_changed;

  001b7	8a 45 83	 mov	 al, BYTE PTR _value_changed$[ebp]

; 2873 : }

  001ba	52		 push	 edx
  001bb	8b cd		 mov	 ecx, ebp
  001bd	50		 push	 eax
  001be	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@TempInputT
  001c4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001c9	58		 pop	 eax
  001ca	5a		 pop	 edx
  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	5b		 pop	 ebx
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d1	33 cd		 xor	 ecx, ebp
  001d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d8	81 c4 58 01 00
	00		 add	 esp, 344		; 00000158H
  001de	3b ec		 cmp	 ebp, esp
  001e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
  001e9	0f 1f 00	 npad	 3
$LN15@TempInputT:
  001ec	02 00 00 00	 DD	 2
  001f0	00 00 00 00	 DD	 $LN14@TempInputT
$LN14@TempInputT:
  001f4	c0 ff ff ff	 DD	 -64			; ffffffc0H
  001f8	20 00 00 00	 DD	 32			; 00000020H
  001fc	00 00 00 00	 DD	 $LN12@TempInputT
  00200	98 ff ff ff	 DD	 -104			; ffffff98H
  00204	20 00 00 00	 DD	 32			; 00000020H
  00208	00 00 00 00	 DD	 $LN13@TempInputT
$LN13@TempInputT:
  0020c	64		 DB	 100			; 00000064H
  0020d	61		 DB	 97			; 00000061H
  0020e	74		 DB	 116			; 00000074H
  0020f	61		 DB	 97			; 00000061H
  00210	5f		 DB	 95			; 0000005fH
  00211	62		 DB	 98			; 00000062H
  00212	75		 DB	 117			; 00000075H
  00213	66		 DB	 102			; 00000066H
  00214	00		 DB	 0
$LN12@TempInputT:
  00215	66		 DB	 102			; 00000066H
  00216	6d		 DB	 109			; 0000006dH
  00217	74		 DB	 116			; 00000074H
  00218	5f		 DB	 95			; 0000005fH
  00219	62		 DB	 98			; 00000062H
  0021a	75		 DB	 117			; 00000075H
  0021b	66		 DB	 102			; 00000066H
  0021c	00		 DB	 0
?TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z ENDP ; ImGui::TempInputTextScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z
_TEXT	SEGMENT
tv873 = -3041						; size = 1
tv861 = -3040						; size = 4
tv2119 = -3036						; size = 4
tv1982 = -3036						; size = 4
tv1050 = -3036						; size = 4
tv1036 = -3036						; size = 4
tv865 = -3036						; size = 4
tv552 = -3033						; size = 1
tv3421 = -3032						; size = 4
tv3352 = -3032						; size = 4
tv3272 = -3032						; size = 4
tv2240 = -3032						; size = 4
tv2234 = -3032						; size = 4
tv2087 = -3032						; size = 4
tv2081 = -3032						; size = 4
tv1981 = -3032						; size = 4
tv1964 = -3032						; size = 4
tv1961 = -3032						; size = 4
tv1956 = -3032						; size = 4
tv1787 = -3032						; size = 4
tv1702 = -3032						; size = 4
tv1693 = -3032						; size = 4
tv1415 = -3032						; size = 4
tv1383 = -3032						; size = 4
tv1265 = -3032						; size = 4
tv1252 = -3032						; size = 4
tv1223 = -3032						; size = 4
tv1186 = -3032						; size = 4
tv1131 = -3032						; size = 4
tv1118 = -3032						; size = 4
tv1104 = -3032						; size = 4
tv1078 = -3032						; size = 4
tv1053 = -3032						; size = 4
tv1039 = -3032						; size = 4
tv862 = -3032						; size = 4
tv847 = -3032						; size = 4
tv682 = -3032						; size = 4
tv624 = -3032						; size = 4
tv547 = -3032						; size = 4
tv496 = -3032						; size = 4
tv404 = -3032						; size = 4
tv341 = -3032						; size = 4
tv175 = -3032						; size = 4
tv159 = -3032						; size = 4
tv1027 = -3029						; size = 1
tv1008 = -3029						; size = 1
tv996 = -3029						; size = 1
tv979 = -3029						; size = 1
tv956 = -3029						; size = 1
tv931 = -3029						; size = 1
tv918 = -3029						; size = 1
tv905 = -3029						; size = 1
tv893 = -3029						; size = 1
tv888 = -3029						; size = 1
tv767 = -3029						; size = 1
tv541 = -3029						; size = 1
tv487 = -3029						; size = 1
tv396 = -3029						; size = 1
tv356 = -3029						; size = 1
tv351 = -3029						; size = 1
tv332 = -3029						; size = 1
tv323 = -3029						; size = 1
tv312 = -3029						; size = 1
tv303 = -3029						; size = 1
tv295 = -3029						; size = 1
tv290 = -3029						; size = 1
tv134 = -3029						; size = 1
tv131 = -3029						; size = 1
tv128 = -3029						; size = 1
tv93 = -3029						; size = 1
tv90 = -3029						; size = 1
$T1 = -3024						; size = 8
$T2 = -3008						; size = 8
$T3 = -2992						; size = 8
$T4 = -2976						; size = 8
$T5 = -2960						; size = 8
$T6 = -2944						; size = 8
$T7 = -2928						; size = 16
$T8 = -2904						; size = 8
$T9 = -2888						; size = 8
$T10 = -2872						; size = 16
$T11 = -2848						; size = 16
$T12 = -2824						; size = 8
$T13 = -2808						; size = 8
$T14 = -2792						; size = 8
$T15 = -2776						; size = 8
$T16 = -2760						; size = 8
$T17 = -2744						; size = 8
$T18 = -2728						; size = 8
$T19 = -2712						; size = 8
$T20 = -2696						; size = 8
$T21 = -2680						; size = 8
$T22 = -2664						; size = 4
$T23 = -2650						; size = 2
$T24 = -2640						; size = 8
$T25 = -2624						; size = 8
$T26 = -2608						; size = 8
_col$27 = -1632						; size = 4
_cursor_screen_rect$28 = -1620				; size = 16
_cursor_screen_pos$29 = -1596				; size = 8
_cursor_is_visible$30 = -1577				; size = 1
_col$31 = -1568						; size = 4
_rect$32 = -1556					; size = 16
_rect_size$33 = -1532					; size = 8
_p$34 = -1516						; size = 4
_rect_pos$35 = -1504					; size = 8
_bg_offy_dn$36 = -1488					; size = 4
_bg_offy_up$37 = -1476					; size = 4
_bg_color$38 = -1464					; size = 4
_text_selected_end$39 = -1452				; size = 4
_text_selected_begin$40 = -1440				; size = 4
_draw_scroll$41 = -1428					; size = 8
_scroll_y$42 = -1412					; size = 4
_scroll_increment_x$43 = -1400				; size = 4
_s$44 = -1388						; size = 4
_line_count$45 = -1376					; size = 4
_searches_remaining$46 = -1364				; size = 4
_searches_result_line_no$47 = -1352			; size = 8
_searches_input_ptr$48 = -1336				; size = 8
_select_start_offset$49 = -1320				; size = 8
_cursor_offset$50 = -1304				; size = 8
_text_begin$51 = -1288					; size = 4
_buf_display_end$ = -1276				; size = 4
_buf_display$ = -1264					; size = 4
_buf_display_max_length$ = -1252			; size = 4
_text_size$ = -1240					; size = 8
_draw_pos$ = -1224					; size = 8
_clip_rect$ = -1208					; size = 16
_callback_data$52 = -1184				; size = 48
_utf8_selection_end$53 = -1128				; size = 4
_utf8_selection_start$54 = -1116			; size = 4
_utf8_cursor_pos$55 = -1104				; size = 4
_text$56 = -1092					; size = 4
_callback_data$57 = -1080				; size = 48
_event_key$58 = -1024					; size = 4
_event_flag$59 = -1012					; size = 4
_apply_edit_back_to_user_buffer$60 = -997		; size = 1
_apply_new_text_length$61 = -988			; size = 4
_apply_new_text$62 = -976				; size = 4
_c$63 = -964						; size = 4
_s$64 = -952						; size = 4
_clipboard_filtered_len$65 = -940			; size = 4
_clipboard_filtered$66 = -928				; size = 4
_clipboard_len$67 = -916				; size = 4
_clipboard$68 = -904					; size = 4
_clipboard_data$69 = -892				; size = 4
_clipboard_data_len$70 = -880				; size = 4
_ie$71 = -868						; size = 4
_ib$72 = -856						; size = 4
_c$73 = -844						; size = 4
_ctrl_enter_for_new_line$74 = -829			; size = 1
_is_redo$75 = -817					; size = 1
_is_undo$76 = -805					; size = 1
_is_paste$77 = -793					; size = 1
_is_copy$78 = -781					; size = 1
_is_cut$79 = -769					; size = 1
_is_shift_key_only$80 = -757				; size = 1
_is_ctrl_key_only$81 = -745				; size = 1
_is_startend_key_down$82 = -733				; size = 1
_is_wordmove_key_down$83 = -721				; size = 1
_is_osx_shift_shortcut$84 = -709			; size = 1
_is_shortcut_key$85 = -697				; size = 1
_is_osx$86 = -685					; size = 1
_k_mask$87 = -676					; size = 4
_cancel_edit$ = -661					; size = 1
_c$88 = -652						; size = 4
_n$89 = -640						; size = 4
_c$90 = -628						; size = 4
_ignore_char_inputs$91 = -613				; size = 1
_is_osx$92 = -601					; size = 1
_mouse_y$93 = -592					; size = 4
_mouse_x$94 = -580					; size = 4
_backup_current_text_length$ = -568			; size = 4
_password_font$95 = -556				; size = 4
_glyph$96 = -544					; size = 4
_is_displaying_hint$ = -529				; size = 1
_buf_display_from_state$ = -517				; size = 1
_buf_end$97 = -508					; size = 4
_enter_pressed$ = -493					; size = 1
_value_changed$ = -481					; size = 1
_render_selection$ = -469				; size = 1
_render_cursor$ = -457					; size = 1
_recycle_state$98 = -445				; size = 1
_buf_end$99 = -436					; size = 4
_buf_len$100 = -424					; size = 4
_init_state$ = -409					; size = 1
_init_make_active$ = -397				; size = 1
_select_all$ = -385					; size = 1
_clear_active_id$ = -373				; size = 1
_user_scroll_active$ = -361				; size = 1
_user_scroll_finish$ = -349				; size = 1
_user_nav_input_start$ = -337				; size = 1
_user_clicked$ = -325					; size = 1
_focus_requested_by_tab$ = -313				; size = 1
_focus_requested_by_code$ = -301			; size = 1
_focus_requested$ = -289				; size = 1
_state$ = -280						; size = 4
_hovered$ = -265					; size = 1
_inner_size$ = -256					; size = 8
_draw_window$ = -240					; size = 4
_total_bb$ = -228					; size = 16
_frame_bb$ = -204					; size = 16
_total_size$ = -180					; size = 8
_frame_size$ = -164					; size = 8
_label_size$ = -148					; size = 8
_id$ = -132						; size = 4
_is_resizable$ = -117					; size = 1
_is_undoable$ = -105					; size = 1
_is_password$ = -93					; size = 1
_is_readonly$ = -81					; size = 1
_is_multiline$ = -69					; size = 1
_RENDER_SELECTION_WHEN_INACTIVE$ = -57			; size = 1
_style$ = -48						; size = 4
_io$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_hint$ = 12						; size = 4
_buf$ = 16						; size = 4
_buf_size$ = 20						; size = 4
_size_arg$ = 24						; size = 4
_flags$ = 28						; size = 4
_callback$ = 32						; size = 4
_callback_user_data$ = 36				; size = 4
?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z PROC ; ImGui::InputTextEx, COMDAT

; 3399 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 0b 00
	00		 sub	 esp, 3044		; 00000be4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c f4 ff
	ff		 lea	 edi, DWORD PTR [ebp-3044]
  00012	b9 f9 02 00 00	 mov	 ecx, 761		; 000002f9H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3400 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 3401 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN19@InputTextE

; 3402 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 42 3b 00 00	 jmp	 $LN193@InputTextE
$LN19@InputTextE:

; 3403 : 
; 3404 :     IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)

  0004c	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0004f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00054	74 31		 je	 SHORT $LN195@InputTextE
  00056	8b 4d 1c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00059	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  0005f	74 26		 je	 SHORT $LN195@InputTextE
  00061	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  00067	83 c2 05	 add	 edx, 5
  0006a	8b f4		 mov	 esi, esp
  0006c	52		 push	 edx
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_1LI@BDNHGOFF@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	3b f4		 cmp	 esi, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN195@InputTextE:

; 3405 :     IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)

  00087	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0008a	83 e0 40	 and	 eax, 64			; 00000040H
  0008d	74 31		 je	 SHORT $LN196@InputTextE
  0008f	8b 4d 1c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00092	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00098	74 26		 je	 SHORT $LN196@InputTextE
  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  000a0	83 c2 06	 add	 edx, 6
  000a3	8b f4		 mov	 esi, esp
  000a5	52		 push	 edx
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@MGOPIKJM@?$AA?$CB?$AA?$CI?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu@
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN196@InputTextE:

; 3406 : 
; 3407 :     ImGuiContext& g = *GImGui;

  000c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  000c5	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 3408 :     ImGuiIO& io = g.IO;

  000c8	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  000cb	83 c0 08	 add	 eax, 8
  000ce	89 45 dc	 mov	 DWORD PTR _io$[ebp], eax

; 3409 :     const ImGuiStyle& style = g.Style;

  000d1	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  000d4	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  000d9	89 45 d0	 mov	 DWORD PTR _style$[ebp], eax

; 3410 : 
; 3411 :     const bool RENDER_SELECTION_WHEN_INACTIVE = false;

  000dc	c6 45 c7 00	 mov	 BYTE PTR _RENDER_SELECTION_WHEN_INACTIVE$[ebp], 0

; 3412 :     const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;

  000e0	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  000e3	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  000e8	74 09		 je	 SHORT $LN197@InputTextE
  000ea	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv90[ebp], 1
  000f1	eb 07		 jmp	 SHORT $LN198@InputTextE
$LN197@InputTextE:
  000f3	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv90[ebp], 0
$LN198@InputTextE:
  000fa	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv90[ebp]
  00100	88 4d bb	 mov	 BYTE PTR _is_multiline$[ebp], cl

; 3413 :     const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;

  00103	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  00106	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0010b	74 09		 je	 SHORT $LN199@InputTextE
  0010d	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv93[ebp], 1
  00114	eb 07		 jmp	 SHORT $LN200@InputTextE
$LN199@InputTextE:
  00116	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv93[ebp], 0
$LN200@InputTextE:
  0011d	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv93[ebp]
  00123	88 4d af	 mov	 BYTE PTR _is_readonly$[ebp], cl

; 3414 :     const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;

  00126	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  00129	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0012e	74 09		 je	 SHORT $LN201@InputTextE
  00130	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv128[ebp], 1
  00137	eb 07		 jmp	 SHORT $LN202@InputTextE
$LN201@InputTextE:
  00139	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv128[ebp], 0
$LN202@InputTextE:
  00140	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv128[ebp]
  00146	88 4d a3	 mov	 BYTE PTR _is_password$[ebp], cl

; 3415 :     const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;

  00149	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0014c	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00151	75 09		 jne	 SHORT $LN203@InputTextE
  00153	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv131[ebp], 1
  0015a	eb 07		 jmp	 SHORT $LN204@InputTextE
$LN203@InputTextE:
  0015c	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv131[ebp], 0
$LN204@InputTextE:
  00163	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv131[ebp]
  00169	88 4d 97	 mov	 BYTE PTR _is_undoable$[ebp], cl

; 3416 :     const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;

  0016c	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0016f	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00174	74 09		 je	 SHORT $LN205@InputTextE
  00176	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv134[ebp], 1
  0017d	eb 07		 jmp	 SHORT $LN206@InputTextE
$LN205@InputTextE:
  0017f	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv134[ebp], 0
$LN206@InputTextE:
  00186	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv134[ebp]
  0018c	88 4d 8b	 mov	 BYTE PTR _is_resizable$[ebp], cl

; 3417 :     if (is_resizable)

  0018f	0f b6 45 8b	 movzx	 eax, BYTE PTR _is_resizable$[ebp]
  00193	85 c0		 test	 eax, eax
  00195	74 2b		 je	 SHORT $LN207@InputTextE

; 3418 :         IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!

  00197	83 7d 20 00	 cmp	 DWORD PTR _callback$[ebp], 0
  0019b	75 25		 jne	 SHORT $LN207@InputTextE
  0019d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  001a2	83 c0 13	 add	 eax, 19			; 00000013H
  001a5	8b f4		 mov	 esi, esp
  001a7	50		 push	 eax
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@CBGPMFEC@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bb	3b f4		 cmp	 esi, esp
  001bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN207@InputTextE:

; 3419 : 
; 3420 :     if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope,

  001c2	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  001c6	85 c0		 test	 eax, eax
  001c8	74 05		 je	 SHORT $LN21@InputTextE

; 3421 :         BeginGroup();

  001ca	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup
$LN21@InputTextE:

; 3422 :     const ImGuiID id = window->GetID(label);

  001cf	6a 00		 push	 0
  001d1	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  001d4	50		 push	 eax
  001d5	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  001d8	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  001dd	89 85 7c ff ff
	ff		 mov	 DWORD PTR _id$[ebp], eax

; 3423 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  001e3	51		 push	 ecx
  001e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f1	6a 01		 push	 1
  001f3	6a 00		 push	 0
  001f5	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  001f8	50		 push	 eax
  001f9	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _label_size$[ebp]
  001ff	51		 push	 ecx
  00200	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00205	83 c4 14	 add	 esp, 20			; 00000014H

; 3424 :     const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? g.FontSize * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line

  00208	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  0020c	85 c0		 test	 eax, eax
  0020e	74 1d		 je	 SHORT $LN208@InputTextE
  00210	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00213	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  0021b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41000000
  00223	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
  0022b	eb 10		 jmp	 SHORT $LN209@InputTextE
$LN208@InputTextE:
  0022d	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _label_size$[ebp+4]
  00235	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
$LN209@InputTextE:
  0023d	8b 55 d0	 mov	 edx, DWORD PTR _style$[ebp]
  00240	f3 0f 10 42 3c	 movss	 xmm0, DWORD PTR [edx+60]
  00245	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0024d	f3 0f 58 85 28
	f4 ff ff	 addss	 xmm0, DWORD PTR tv159[ebp]
  00255	51		 push	 ecx
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00260	51		 push	 ecx
  00261	d9 1c 24	 fstp	 DWORD PTR [esp]
  00264	8b 45 18	 mov	 eax, DWORD PTR _size_arg$[ebp]
  00267	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026a	51		 push	 ecx
  0026b	8b 10		 mov	 edx, DWORD PTR [eax]
  0026d	52		 push	 edx
  0026e	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _frame_size$[ebp]
  00274	50		 push	 eax
  00275	e8 00 00 00 00	 call	 ?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
  0027a	83 c4 14	 add	 esp, 20			; 00000014H

; 3425 :     const ImVec2 total_size = ImVec2(frame_size.x + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), frame_size.y);

  0027d	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00285	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0028c	76 1a		 jbe	 SHORT $LN210@InputTextE
  0028e	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  00291	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00296	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  0029e	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv175[ebp], xmm0
  002a6	eb 0b		 jmp	 SHORT $LN211@InputTextE
$LN210@InputTextE:
  002a8	0f 57 c0	 xorps	 xmm0, xmm0
  002ab	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv175[ebp], xmm0
$LN211@InputTextE:
  002b3	51		 push	 ecx
  002b4	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_size$[ebp+4]
  002bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c1	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_size$[ebp]
  002c9	f3 0f 58 85 28
	f4 ff ff	 addss	 xmm0, DWORD PTR tv175[ebp]
  002d1	51		 push	 ecx
  002d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d7	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _total_size$[ebp]
  002dd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 3426 : 
; 3427 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);

  002e2	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _frame_size$[ebp]
  002e8	50		 push	 eax
  002e9	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  002ec	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  002f2	51		 push	 ecx
  002f3	8d 95 d0 f5 ff
	ff		 lea	 edx, DWORD PTR $T26[ebp]
  002f9	52		 push	 edx
  002fa	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  002ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00302	50		 push	 eax
  00303	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00306	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0030b	50		 push	 eax
  0030c	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00312	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 3428 :     const ImRect total_bb(frame_bb.Min, frame_bb.Min + total_size);

  00317	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _total_size$[ebp]
  0031d	50		 push	 eax
  0031e	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00324	51		 push	 ecx
  00325	8d 95 c0 f5 ff
	ff		 lea	 edx, DWORD PTR $T25[ebp]
  0032b	52		 push	 edx
  0032c	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00331	83 c4 0c	 add	 esp, 12			; 0000000cH
  00334	50		 push	 eax
  00335	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  0033b	50		 push	 eax
  0033c	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00342	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 3429 : 
; 3430 :     ImGuiWindow* draw_window = window;

  00347	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0034a	89 85 10 ff ff
	ff		 mov	 DWORD PTR _draw_window$[ebp], eax

; 3431 :     ImVec2 inner_size = frame_size;

  00350	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _frame_size$[ebp]
  00356	89 85 00 ff ff
	ff		 mov	 DWORD PTR _inner_size$[ebp], eax
  0035c	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _frame_size$[ebp+4]
  00362	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _inner_size$[ebp+4], ecx

; 3432 :     if (is_multiline)

  00368	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  0036c	85 c0		 test	 eax, eax
  0036e	0f 84 d9 00 00
	00		 je	 $LN22@InputTextE

; 3433 :     {
; 3434 :         if (!ItemAdd(total_bb, id, &frame_bb))

  00374	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  0037a	50		 push	 eax
  0037b	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _id$[ebp]
  00381	51		 push	 ecx
  00382	8d 95 1c ff ff
	ff		 lea	 edx, DWORD PTR _total_bb$[ebp]
  00388	52		 push	 edx
  00389	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0038e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00391	0f b6 c0	 movzx	 eax, al
  00394	85 c0		 test	 eax, eax
  00396	75 29		 jne	 SHORT $LN24@InputTextE

; 3435 :         {
; 3436 :             ItemSize(total_bb, style.FramePadding.y);

  00398	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0039b	51		 push	 ecx
  0039c	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  003a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a6	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  003ac	51		 push	 ecx
  003ad	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  003b2	83 c4 08	 add	 esp, 8

; 3437 :             EndGroup();

  003b5	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 3438 :             return false;

  003ba	32 c0		 xor	 al, al
  003bc	e9 cd 37 00 00	 jmp	 $LN193@InputTextE
$LN24@InputTextE:

; 3439 :         }
; 3440 :         if (!BeginChildFrame(id, frame_bb.GetSize()))

  003c1	6a 00		 push	 0
  003c3	8d 85 b0 f5 ff
	ff		 lea	 eax, DWORD PTR $T24[ebp]
  003c9	50		 push	 eax
  003ca	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  003d0	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetSize
  003d5	50		 push	 eax
  003d6	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _id$[ebp]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 ?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z ; ImGui::BeginChildFrame
  003e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e5	0f b6 d0	 movzx	 edx, al
  003e8	85 d2		 test	 edx, edx
  003ea	75 11		 jne	 SHORT $LN25@InputTextE

; 3441 :         {
; 3442 :             EndChildFrame();

  003ec	e8 00 00 00 00	 call	 ?EndChildFrame@ImGui@@YAXXZ ; ImGui::EndChildFrame

; 3443 :             EndGroup();

  003f1	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 3444 :             return false;

  003f6	32 c0		 xor	 al, al
  003f8	e9 91 37 00 00	 jmp	 $LN193@InputTextE
$LN25@InputTextE:

; 3445 :         }
; 3446 :         draw_window = g.CurrentWindow; // Child window

  003fd	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00400	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00406	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _draw_window$[ebp], ecx

; 3447 :         draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight

  0040c	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  00412	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _draw_window$[ebp]
  00418	8b 90 3c 01 00
	00		 mov	 edx, DWORD PTR [eax+316]
  0041e	0b 91 34 01 00
	00		 or	 edx, DWORD PTR [ecx+308]
  00424	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  0042a	89 90 3c 01 00
	00		 mov	 DWORD PTR [eax+316], edx

; 3448 :         inner_size.x -= draw_window->ScrollbarSizes.x;

  00430	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  00436	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _inner_size$[ebp]
  0043e	f3 0f 5c 40 70	 subss	 xmm0, DWORD PTR [eax+112]
  00443	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _inner_size$[ebp], xmm0

; 3449 :     }

  0044b	eb 48		 jmp	 SHORT $LN26@InputTextE
$LN22@InputTextE:

; 3450 :     else
; 3451 :     {
; 3452 :         ItemSize(total_bb, style.FramePadding.y);

  0044d	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  00450	51		 push	 ecx
  00451	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00456	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0045b	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00461	51		 push	 ecx
  00462	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  00467	83 c4 08	 add	 esp, 8

; 3453 :         if (!ItemAdd(total_bb, id, &frame_bb))

  0046a	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00470	50		 push	 eax
  00471	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _id$[ebp]
  00477	51		 push	 ecx
  00478	8d 95 1c ff ff
	ff		 lea	 edx, DWORD PTR _total_bb$[ebp]
  0047e	52		 push	 edx
  0047f	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00484	83 c4 0c	 add	 esp, 12			; 0000000cH
  00487	0f b6 c0	 movzx	 eax, al
  0048a	85 c0		 test	 eax, eax
  0048c	75 07		 jne	 SHORT $LN26@InputTextE

; 3454 :             return false;

  0048e	32 c0		 xor	 al, al
  00490	e9 f9 36 00 00	 jmp	 $LN193@InputTextE
$LN26@InputTextE:

; 3455 :     }
; 3456 :     const bool hovered = ItemHoverable(frame_bb, id);

  00495	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _id$[ebp]
  0049b	50		 push	 eax
  0049c	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  004a2	51		 push	 ecx
  004a3	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z ; ImGui::ItemHoverable
  004a8	83 c4 08	 add	 esp, 8
  004ab	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _hovered$[ebp], al

; 3457 :     if (hovered)

  004b1	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  004b8	85 c0		 test	 eax, eax
  004ba	74 0d		 je	 SHORT $LN27@InputTextE

; 3458 :         g.MouseCursor = ImGuiMouseCursor_TextInput;

  004bc	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  004bf	c7 80 30 1d 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7472], 1
$LN27@InputTextE:

; 3459 : 
; 3460 :     // NB: we are only allowed to access 'edit_state' if we are the active widget.
; 3461 :     ImGuiInputTextState* state = NULL;

  004c9	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _state$[ebp], 0

; 3462 :     if (g.InputTextState.ID == id)

  004d3	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  004d6	8b 88 00 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7680]
  004dc	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  004e2	75 0e		 jne	 SHORT $LN28@InputTextE

; 3463 :         state = &g.InputTextState;

  004e4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  004e7	05 00 1e 00 00	 add	 eax, 7680		; 00001e00H
  004ec	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _state$[ebp], eax
$LN28@InputTextE:

; 3464 : 
; 3465 :     const bool focus_requested = FocusableItemRegister(window, id);

  004f2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _id$[ebp]
  004f8	50		 push	 eax
  004f9	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  004fc	51		 push	 ecx
  004fd	e8 00 00 00 00	 call	 ?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I@Z ; ImGui::FocusableItemRegister
  00502	83 c4 08	 add	 esp, 8
  00505	88 85 df fe ff
	ff		 mov	 BYTE PTR _focus_requested$[ebp], al

; 3466 :     const bool focus_requested_by_code = focus_requested && (g.FocusRequestCurrWindow == window && g.FocusRequestCurrCounterAll == window->DC.FocusCounterAll);

  0050b	0f b6 85 df fe
	ff ff		 movzx	 eax, BYTE PTR _focus_requested$[ebp]
  00512	85 c0		 test	 eax, eax
  00514	74 2b		 je	 SHORT $LN212@InputTextE
  00516	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00519	8b 91 dc 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7132]
  0051f	3b 55 f4	 cmp	 edx, DWORD PTR _window$[ebp]
  00522	75 1d		 jne	 SHORT $LN212@InputTextE
  00524	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00527	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0052a	8b 90 e4 1b 00
	00		 mov	 edx, DWORD PTR [eax+7140]
  00530	3b 91 64 01 00
	00		 cmp	 edx, DWORD PTR [ecx+356]
  00536	75 09		 jne	 SHORT $LN212@InputTextE
  00538	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv290[ebp], 1
  0053f	eb 07		 jmp	 SHORT $LN213@InputTextE
$LN212@InputTextE:
  00541	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv290[ebp], 0
$LN213@InputTextE:
  00548	8a 85 2b f4 ff
	ff		 mov	 al, BYTE PTR tv290[ebp]
  0054e	88 85 d3 fe ff
	ff		 mov	 BYTE PTR _focus_requested_by_code$[ebp], al

; 3467 :     const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

  00554	0f b6 85 df fe
	ff ff		 movzx	 eax, BYTE PTR _focus_requested$[ebp]
  0055b	85 c0		 test	 eax, eax
  0055d	74 14		 je	 SHORT $LN214@InputTextE
  0055f	0f b6 8d d3 fe
	ff ff		 movzx	 ecx, BYTE PTR _focus_requested_by_code$[ebp]
  00566	85 c9		 test	 ecx, ecx
  00568	75 09		 jne	 SHORT $LN214@InputTextE
  0056a	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv295[ebp], 1
  00571	eb 07		 jmp	 SHORT $LN215@InputTextE
$LN214@InputTextE:
  00573	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv295[ebp], 0
$LN215@InputTextE:
  0057a	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv295[ebp]
  00580	88 95 c7 fe ff
	ff		 mov	 BYTE PTR _focus_requested_by_tab$[ebp], dl

; 3468 : 
; 3469 :     const bool user_clicked = hovered && io.MouseClicked[0];

  00586	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  0058d	85 c0		 test	 eax, eax
  0058f	74 20		 je	 SHORT $LN216@InputTextE
  00591	b9 01 00 00 00	 mov	 ecx, 1
  00596	6b d1 00	 imul	 edx, ecx, 0
  00599	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0059c	0f b6 8c 10 d0
	03 00 00	 movzx	 ecx, BYTE PTR [eax+edx+976]
  005a4	85 c9		 test	 ecx, ecx
  005a6	74 09		 je	 SHORT $LN216@InputTextE
  005a8	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv303[ebp], 1
  005af	eb 07		 jmp	 SHORT $LN217@InputTextE
$LN216@InputTextE:
  005b1	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv303[ebp], 0
$LN217@InputTextE:
  005b8	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv303[ebp]
  005be	88 95 bb fe ff
	ff		 mov	 BYTE PTR _user_clicked$[ebp], dl

; 3470 :     const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));

  005c4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005c7	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  005cd	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  005d3	74 37		 je	 SHORT $LN220@InputTextE
  005d5	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  005d8	8b 82 e4 1a 00
	00		 mov	 eax, DWORD PTR [edx+6884]
  005de	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _id$[ebp]
  005e4	74 1d		 je	 SHORT $LN219@InputTextE
  005e6	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  005e9	8b 91 d8 1a 00
	00		 mov	 edx, DWORD PTR [ecx+6872]
  005ef	3b 95 7c ff ff
	ff		 cmp	 edx, DWORD PTR _id$[ebp]
  005f5	75 15		 jne	 SHORT $LN220@InputTextE
  005f7	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005fa	83 b8 f8 1a 00
	00 03		 cmp	 DWORD PTR [eax+6904], 3
  00601	75 09		 jne	 SHORT $LN220@InputTextE
$LN219@InputTextE:
  00603	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv312[ebp], 1
  0060a	eb 07		 jmp	 SHORT $LN221@InputTextE
$LN220@InputTextE:
  0060c	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv312[ebp], 0
$LN221@InputTextE:
  00613	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv312[ebp]
  00619	88 8d af fe ff
	ff		 mov	 BYTE PTR _user_nav_input_start$[ebp], cl

; 3471 :     const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);

  0061f	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  00623	85 c0		 test	 eax, eax
  00625	74 3a		 je	 SHORT $LN222@InputTextE
  00627	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  0062e	74 31		 je	 SHORT $LN222@InputTextE
  00630	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00633	83 b9 e4 19 00
	00 00		 cmp	 DWORD PTR [ecx+6628], 0
  0063a	75 25		 jne	 SHORT $LN222@InputTextE
  0063c	6a 01		 push	 1
  0063e	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _draw_window$[ebp]
  00644	52		 push	 edx
  00645	e8 00 00 00 00	 call	 ?GetWindowScrollbarID@ImGui@@YAIPAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetWindowScrollbarID
  0064a	83 c4 08	 add	 esp, 8
  0064d	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00650	39 81 18 1a 00
	00		 cmp	 DWORD PTR [ecx+6680], eax
  00656	75 09		 jne	 SHORT $LN222@InputTextE
  00658	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv323[ebp], 1
  0065f	eb 07		 jmp	 SHORT $LN223@InputTextE
$LN222@InputTextE:
  00661	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv323[ebp], 0
$LN223@InputTextE:
  00668	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv323[ebp]
  0066e	88 95 a3 fe ff
	ff		 mov	 BYTE PTR _user_scroll_finish$[ebp], dl

; 3472 :     const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);

  00674	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  00678	85 c0		 test	 eax, eax
  0067a	74 2e		 je	 SHORT $LN224@InputTextE
  0067c	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  00683	74 25		 je	 SHORT $LN224@InputTextE
  00685	6a 01		 push	 1
  00687	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _draw_window$[ebp]
  0068d	51		 push	 ecx
  0068e	e8 00 00 00 00	 call	 ?GetWindowScrollbarID@ImGui@@YAIPAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetWindowScrollbarID
  00693	83 c4 08	 add	 esp, 8
  00696	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00699	39 82 e4 19 00
	00		 cmp	 DWORD PTR [edx+6628], eax
  0069f	75 09		 jne	 SHORT $LN224@InputTextE
  006a1	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv332[ebp], 1
  006a8	eb 07		 jmp	 SHORT $LN225@InputTextE
$LN224@InputTextE:
  006aa	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv332[ebp], 0
$LN225@InputTextE:
  006b1	8a 85 2b f4 ff
	ff		 mov	 al, BYTE PTR tv332[ebp]
  006b7	88 85 97 fe ff
	ff		 mov	 BYTE PTR _user_scroll_active$[ebp], al

; 3473 : 
; 3474 :     bool clear_active_id = false;

  006bd	c6 85 8b fe ff
	ff 00		 mov	 BYTE PTR _clear_active_id$[ebp], 0

; 3475 :     bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);

  006c4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  006c7	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  006cd	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  006d3	74 27		 je	 SHORT $LN227@InputTextE
  006d5	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  006d8	83 e2 10	 and	 edx, 16			; 00000010H
  006db	75 0b		 jne	 SHORT $LN226@InputTextE
  006dd	0f b6 85 af fe
	ff ff		 movzx	 eax, BYTE PTR _user_nav_input_start$[ebp]
  006e4	85 c0		 test	 eax, eax
  006e6	74 14		 je	 SHORT $LN227@InputTextE
$LN226@InputTextE:
  006e8	0f b6 4d bb	 movzx	 ecx, BYTE PTR _is_multiline$[ebp]
  006ec	85 c9		 test	 ecx, ecx
  006ee	75 0c		 jne	 SHORT $LN227@InputTextE
  006f0	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv341[ebp], 1
  006fa	eb 0a		 jmp	 SHORT $LN228@InputTextE
$LN227@InputTextE:
  006fc	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv341[ebp], 0
$LN228@InputTextE:
  00706	8a 95 28 f4 ff
	ff		 mov	 dl, BYTE PTR tv341[ebp]
  0070c	88 95 7f fe ff
	ff		 mov	 BYTE PTR _select_all$[ebp], dl

; 3476 : 
; 3477 :     const bool init_make_active = (focus_requested || user_clicked || user_scroll_finish || user_nav_input_start);

  00712	0f b6 85 df fe
	ff ff		 movzx	 eax, BYTE PTR _focus_requested$[ebp]
  00719	85 c0		 test	 eax, eax
  0071b	75 2a		 jne	 SHORT $LN229@InputTextE
  0071d	0f b6 8d bb fe
	ff ff		 movzx	 ecx, BYTE PTR _user_clicked$[ebp]
  00724	85 c9		 test	 ecx, ecx
  00726	75 1f		 jne	 SHORT $LN229@InputTextE
  00728	0f b6 95 a3 fe
	ff ff		 movzx	 edx, BYTE PTR _user_scroll_finish$[ebp]
  0072f	85 d2		 test	 edx, edx
  00731	75 14		 jne	 SHORT $LN229@InputTextE
  00733	0f b6 85 af fe
	ff ff		 movzx	 eax, BYTE PTR _user_nav_input_start$[ebp]
  0073a	85 c0		 test	 eax, eax
  0073c	75 09		 jne	 SHORT $LN229@InputTextE
  0073e	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv351[ebp], 0
  00745	eb 07		 jmp	 SHORT $LN230@InputTextE
$LN229@InputTextE:
  00747	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv351[ebp], 1
$LN230@InputTextE:
  0074e	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv351[ebp]
  00754	88 8d 73 fe ff
	ff		 mov	 BYTE PTR _init_make_active$[ebp], cl

; 3478 :     const bool init_state = (init_make_active || user_scroll_active);

  0075a	0f b6 85 73 fe
	ff ff		 movzx	 eax, BYTE PTR _init_make_active$[ebp]
  00761	85 c0		 test	 eax, eax
  00763	75 14		 jne	 SHORT $LN231@InputTextE
  00765	0f b6 8d 97 fe
	ff ff		 movzx	 ecx, BYTE PTR _user_scroll_active$[ebp]
  0076c	85 c9		 test	 ecx, ecx
  0076e	75 09		 jne	 SHORT $LN231@InputTextE
  00770	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv356[ebp], 0
  00777	eb 07		 jmp	 SHORT $LN232@InputTextE
$LN231@InputTextE:
  00779	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv356[ebp], 1
$LN232@InputTextE:
  00780	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv356[ebp]
  00786	88 95 67 fe ff
	ff		 mov	 BYTE PTR _init_state$[ebp], dl

; 3479 :     if (init_state && g.ActiveId != id)

  0078c	0f b6 85 67 fe
	ff ff		 movzx	 eax, BYTE PTR _init_state$[ebp]
  00793	85 c0		 test	 eax, eax
  00795	0f 84 e7 01 00
	00		 je	 $LN34@InputTextE
  0079b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0079e	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  007a4	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  007aa	0f 84 d2 01 00
	00		 je	 $LN34@InputTextE

; 3480 :     {
; 3481 :         // Access state even if we don't own it yet.
; 3482 :         state = &g.InputTextState;

  007b0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  007b3	05 00 1e 00 00	 add	 eax, 7680		; 00001e00H
  007b8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _state$[ebp], eax

; 3483 :         state->CursorAnimReset();

  007be	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  007c4	e8 00 00 00 00	 call	 ?CursorAnimReset@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::CursorAnimReset

; 3484 : 
; 3485 :         // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
; 3486 :         // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
; 3487 :         const int buf_len = (int)strlen(buf);

  007c9	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  007cc	50		 push	 eax
  007cd	e8 00 00 00 00	 call	 _strlen
  007d2	83 c4 04	 add	 esp, 4
  007d5	89 85 58 fe ff
	ff		 mov	 DWORD PTR _buf_len$100[ebp], eax

; 3488 :         state->InitialTextA.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.

  007db	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _buf_len$100[ebp]
  007e1	83 c0 01	 add	 eax, 1
  007e4	50		 push	 eax
  007e5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  007eb	83 c1 24	 add	 ecx, 36			; 00000024H
  007ee	e8 00 00 00 00	 call	 ?resize@?$ImVector@D@@QAEXH@Z ; ImVector<char>::resize

; 3489 :         memcpy(state->InitialTextA.Data, buf, buf_len + 1);

  007f3	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _buf_len$100[ebp]
  007f9	83 c0 01	 add	 eax, 1
  007fc	50		 push	 eax
  007fd	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  00800	51		 push	 ecx
  00801	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  00807	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0080a	50		 push	 eax
  0080b	e8 00 00 00 00	 call	 _memcpy
  00810	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3490 : 
; 3491 :         // Start edition
; 3492 :         const char* buf_end = NULL;

  00813	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _buf_end$99[ebp], 0

; 3493 :         state->TextW.resize(buf_size + 1);          // wchar count <= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.

  0081d	8b 45 14	 mov	 eax, DWORD PTR _buf_size$[ebp]
  00820	83 c0 01	 add	 eax, 1
  00823	50		 push	 eax
  00824	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0082a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0082d	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize

; 3494 :         state->TextA.resize(0);

  00832	6a 00		 push	 0
  00834	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0083a	83 c1 18	 add	 ecx, 24			; 00000018H
  0083d	e8 00 00 00 00	 call	 ?resize@?$ImVector@D@@QAEXH@Z ; ImVector<char>::resize

; 3495 :         state->TextAIsValid = false;                // TextA is not valid yet (we will display buf until then)

  00842	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00848	c6 40 30 00	 mov	 BYTE PTR [eax+48], 0

; 3496 :         state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, buf_size, buf, NULL, &buf_end);

  0084c	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _buf_end$99[ebp]
  00852	50		 push	 eax
  00853	6a 00		 push	 0
  00855	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  00858	51		 push	 ecx
  00859	8b 55 14	 mov	 edx, DWORD PTR _buf_size$[ebp]
  0085c	52		 push	 edx
  0085d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00863	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00866	51		 push	 ecx
  00867	e8 00 00 00 00	 call	 ?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z ; ImTextStrFromUtf8
  0086c	83 c4 14	 add	 esp, 20			; 00000014H
  0086f	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  00875	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3497 :         state->CurLenA = (int)(buf_end - buf);      // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

  00878	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR _buf_end$99[ebp]
  0087e	2b 45 10	 sub	 eax, DWORD PTR _buf$[ebp]
  00881	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00887	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3498 : 
; 3499 :         // Preserve cursor position and undo/redo stack if we come back to same widget
; 3500 :         // FIXME: For non-readonly widgets we might be able to require that TextAIsValid && TextA == buf ? (untested) and discard undo stack if user buffer has changed.
; 3501 :         const bool recycle_state = (state->ID == id);

  0088a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00890	8b 08		 mov	 ecx, DWORD PTR [eax]
  00892	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  00898	75 09		 jne	 SHORT $LN233@InputTextE
  0089a	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv396[ebp], 1
  008a1	eb 07		 jmp	 SHORT $LN234@InputTextE
$LN233@InputTextE:
  008a3	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv396[ebp], 0
$LN234@InputTextE:
  008aa	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv396[ebp]
  008b0	88 95 43 fe ff
	ff		 mov	 BYTE PTR _recycle_state$98[ebp], dl

; 3502 :         if (recycle_state)

  008b6	0f b6 85 43 fe
	ff ff		 movzx	 eax, BYTE PTR _recycle_state$98[ebp]
  008bd	85 c0		 test	 eax, eax
  008bf	74 0d		 je	 SHORT $LN30@InputTextE

; 3503 :         {
; 3504 :             // Recycle existing cursor/selection/undo stack but clamp position
; 3505 :             // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
; 3506 :             state->CursorClamp();

  008c1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  008c7	e8 00 00 00 00	 call	 ?CursorClamp@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::CursorClamp

; 3507 :         }

  008cc	eb 6d		 jmp	 SHORT $LN32@InputTextE
$LN30@InputTextE:

; 3508 :         else
; 3509 :         {
; 3510 :             state->ID = id;

  008ce	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  008d4	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _id$[ebp]
  008da	89 08		 mov	 DWORD PTR [eax], ecx

; 3511 :             state->ScrollX = 0.0f;

  008dc	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  008e2	0f 57 c0	 xorps	 xmm0, xmm0
  008e5	f3 0f 11 40 38	 movss	 DWORD PTR [eax+56], xmm0

; 3512 :             stb_textedit_initialize_state(&state->Stb, !is_multiline);

  008ea	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  008ee	85 c0		 test	 eax, eax
  008f0	75 0c		 jne	 SHORT $LN235@InputTextE
  008f2	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv404[ebp], 1
  008fc	eb 0a		 jmp	 SHORT $LN236@InputTextE
$LN235@InputTextE:
  008fe	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv404[ebp], 0
$LN236@InputTextE:
  00908	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv404[ebp]
  0090e	51		 push	 ecx
  0090f	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  00915	83 c2 3c	 add	 edx, 60			; 0000003cH
  00918	52		 push	 edx
  00919	e8 00 00 00 00	 call	 ?stb_textedit_initialize_state@ImStb@@YAXPAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_initialize_state
  0091e	83 c4 08	 add	 esp, 8

; 3513 :             if (!is_multiline && focus_requested_by_code)

  00921	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  00925	85 c0		 test	 eax, eax
  00927	75 12		 jne	 SHORT $LN32@InputTextE
  00929	0f b6 85 d3 fe
	ff ff		 movzx	 eax, BYTE PTR _focus_requested_by_code$[ebp]
  00930	85 c0		 test	 eax, eax
  00932	74 07		 je	 SHORT $LN32@InputTextE

; 3514 :                 select_all = true;

  00934	c6 85 7f fe ff
	ff 01		 mov	 BYTE PTR _select_all$[ebp], 1
$LN32@InputTextE:

; 3515 :         }
; 3516 :         if (flags & ImGuiInputTextFlags_AlwaysInsertMode)

  0093b	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0093e	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00943	74 0a		 je	 SHORT $LN33@InputTextE

; 3517 :             state->Stb.insert_mode = 1;

  00945	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0094b	c6 40 48 01	 mov	 BYTE PTR [eax+72], 1
$LN33@InputTextE:

; 3518 :         if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))

  0094f	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  00953	85 c0		 test	 eax, eax
  00955	75 2b		 jne	 SHORT $LN34@InputTextE
  00957	0f b6 85 c7 fe
	ff ff		 movzx	 eax, BYTE PTR _focus_requested_by_tab$[ebp]
  0095e	85 c0		 test	 eax, eax
  00960	75 19		 jne	 SHORT $LN35@InputTextE
  00962	0f b6 85 bb fe
	ff ff		 movzx	 eax, BYTE PTR _user_clicked$[ebp]
  00969	85 c0		 test	 eax, eax
  0096b	74 15		 je	 SHORT $LN34@InputTextE
  0096d	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  00970	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  00977	85 c9		 test	 ecx, ecx
  00979	74 07		 je	 SHORT $LN34@InputTextE
$LN35@InputTextE:

; 3519 :             select_all = true;

  0097b	c6 85 7f fe ff
	ff 01		 mov	 BYTE PTR _select_all$[ebp], 1
$LN34@InputTextE:

; 3520 :     }
; 3521 : 
; 3522 :     if (g.ActiveId != id && init_make_active)

  00982	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00985	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0098b	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  00991	0f 84 49 01 00
	00		 je	 $LN40@InputTextE
  00997	0f b6 85 73 fe
	ff ff		 movzx	 eax, BYTE PTR _init_make_active$[ebp]
  0099e	85 c0		 test	 eax, eax
  009a0	0f 84 3a 01 00
	00		 je	 $LN40@InputTextE

; 3523 :     {
; 3524 :         IM_ASSERT(state && state->ID == id);

  009a6	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  009ad	74 10		 je	 SHORT $LN237@InputTextE
  009af	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  009b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  009b7	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  009bd	74 26		 je	 SHORT $LN238@InputTextE
$LN237@InputTextE:
  009bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  009c5	83 c2 7d	 add	 edx, 125		; 0000007dH
  009c8	8b f4		 mov	 esi, esp
  009ca	52		 push	 edx
  009cb	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  009d0	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@CMKEKNGP@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9@
  009d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  009db	83 c4 0c	 add	 esp, 12			; 0000000cH
  009de	3b f4		 cmp	 esi, esp
  009e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN238@InputTextE:

; 3525 :         SetActiveID(id, window);

  009e5	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  009e8	50		 push	 eax
  009e9	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _id$[ebp]
  009ef	51		 push	 ecx
  009f0	e8 00 00 00 00	 call	 ?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
  009f5	83 c4 08	 add	 esp, 8

; 3526 :         SetFocusID(id, window);

  009f8	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  009fb	50		 push	 eax
  009fc	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _id$[ebp]
  00a02	51		 push	 ecx
  00a03	e8 00 00 00 00	 call	 ?SetFocusID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetFocusID
  00a08	83 c4 08	 add	 esp, 8

; 3527 :         FocusWindow(window);

  00a0b	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00a0e	50		 push	 eax
  00a0f	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  00a14	83 c4 04	 add	 esp, 4

; 3528 : 
; 3529 :         // Declare our inputs
; 3530 :         IM_ASSERT(ImGuiNavInput_COUNT < 32);
; 3531 :         g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);

  00a17	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a1a	8b 88 f8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6648]
  00a20	83 c9 03	 or	 ecx, 3
  00a23	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00a26	89 8a f8 19 00
	00		 mov	 DWORD PTR [edx+6648], ecx

; 3532 :         if (is_multiline || (flags & ImGuiInputTextFlags_CallbackHistory))

  00a2c	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  00a30	85 c0		 test	 eax, eax
  00a32	75 0a		 jne	 SHORT $LN38@InputTextE
  00a34	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  00a37	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00a3c	74 15		 je	 SHORT $LN37@InputTextE
$LN38@InputTextE:

; 3533 :             g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);

  00a3e	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a41	8b 88 f8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6648]
  00a47	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00a4a	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00a4d	89 8a f8 19 00
	00		 mov	 DWORD PTR [edx+6648], ecx
$LN37@InputTextE:

; 3534 :         g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel);

  00a53	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a56	8b 88 fc 19 00
	00		 mov	 ecx, DWORD PTR [eax+6652]
  00a5c	83 c9 02	 or	 ecx, 2
  00a5f	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00a62	89 8a fc 19 00
	00		 mov	 DWORD PTR [edx+6652], ecx

; 3535 :         g.ActiveIdUsingKeyInputMask |= ((ImU64)1 << ImGuiKey_Home) | ((ImU64)1 << ImGuiKey_End);

  00a68	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a6b	8b 88 00 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6656]
  00a71	81 c9 80 01 00
	00		 or	 ecx, 384		; 00000180H
  00a77	8b 90 04 1a 00
	00		 mov	 edx, DWORD PTR [eax+6660]
  00a7d	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a80	89 88 00 1a 00
	00		 mov	 DWORD PTR [eax+6656], ecx
  00a86	89 90 04 1a 00
	00		 mov	 DWORD PTR [eax+6660], edx

; 3536 :         if (is_multiline)

  00a8c	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  00a90	85 c0		 test	 eax, eax
  00a92	74 21		 je	 SHORT $LN39@InputTextE

; 3537 :             g.ActiveIdUsingKeyInputMask |= ((ImU64)1 << ImGuiKey_PageUp) | ((ImU64)1 << ImGuiKey_PageDown); // FIXME-NAV: Page up/down actually not supported yet by widget, but claim them ahead.

  00a94	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a97	8b 88 00 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6656]
  00a9d	83 c9 60	 or	 ecx, 96			; 00000060H
  00aa0	8b 90 04 1a 00
	00		 mov	 edx, DWORD PTR [eax+6660]
  00aa6	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00aa9	89 88 00 1a 00
	00		 mov	 DWORD PTR [eax+6656], ecx
  00aaf	89 90 04 1a 00
	00		 mov	 DWORD PTR [eax+6660], edx
$LN39@InputTextE:

; 3538 :         if (flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput))  // Disable keyboard tabbing out as we will use the \t character.

  00ab5	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  00ab8	25 40 04 00 00	 and	 eax, 1088		; 00000440H
  00abd	74 21		 je	 SHORT $LN40@InputTextE

; 3539 :             g.ActiveIdUsingKeyInputMask |= ((ImU64)1 << ImGuiKey_Tab);

  00abf	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00ac2	8b 88 00 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6656]
  00ac8	83 c9 01	 or	 ecx, 1
  00acb	8b 90 04 1a 00
	00		 mov	 edx, DWORD PTR [eax+6660]
  00ad1	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00ad4	89 88 00 1a 00
	00		 mov	 DWORD PTR [eax+6656], ecx
  00ada	89 90 04 1a 00
	00		 mov	 DWORD PTR [eax+6660], edx
$LN40@InputTextE:

; 3540 :     }
; 3541 : 
; 3542 :     // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
; 3543 :     if (g.ActiveId == id && state == NULL)

  00ae0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00ae3	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00ae9	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  00aef	75 0e		 jne	 SHORT $LN41@InputTextE
  00af1	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  00af8	75 05		 jne	 SHORT $LN41@InputTextE

; 3544 :         ClearActiveID();

  00afa	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN41@InputTextE:

; 3545 : 
; 3546 :     // Release focus when we click outside
; 3547 :     if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560

  00aff	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00b02	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00b08	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  00b0e	75 34		 jne	 SHORT $LN42@InputTextE
  00b10	b8 01 00 00 00	 mov	 eax, 1
  00b15	6b c8 00	 imul	 ecx, eax, 0
  00b18	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  00b1b	0f b6 84 0a d0
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+976]
  00b23	85 c0		 test	 eax, eax
  00b25	74 1d		 je	 SHORT $LN42@InputTextE
  00b27	0f b6 85 67 fe
	ff ff		 movzx	 eax, BYTE PTR _init_state$[ebp]
  00b2e	85 c0		 test	 eax, eax
  00b30	75 12		 jne	 SHORT $LN42@InputTextE
  00b32	0f b6 85 73 fe
	ff ff		 movzx	 eax, BYTE PTR _init_make_active$[ebp]
  00b39	85 c0		 test	 eax, eax
  00b3b	75 07		 jne	 SHORT $LN42@InputTextE

; 3548 :         clear_active_id = true;

  00b3d	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _clear_active_id$[ebp], 1
$LN42@InputTextE:

; 3549 : 
; 3550 :     // Lock the decision of whether we are going to take the path displaying the cursor or selection
; 3551 :     const bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);

  00b44	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00b47	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00b4d	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  00b53	74 1d		 je	 SHORT $LN240@InputTextE
  00b55	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  00b5c	74 0b		 je	 SHORT $LN239@InputTextE
  00b5e	0f b6 95 97 fe
	ff ff		 movzx	 edx, BYTE PTR _user_scroll_active$[ebp]
  00b65	85 d2		 test	 edx, edx
  00b67	75 09		 jne	 SHORT $LN240@InputTextE
$LN239@InputTextE:
  00b69	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv487[ebp], 0
  00b70	eb 07		 jmp	 SHORT $LN241@InputTextE
$LN240@InputTextE:
  00b72	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv487[ebp], 1
$LN241@InputTextE:
  00b79	8a 85 2b f4 ff
	ff		 mov	 al, BYTE PTR tv487[ebp]
  00b7f	88 85 37 fe ff
	ff		 mov	 BYTE PTR _render_cursor$[ebp], al

; 3552 :     bool render_selection = state && state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);

  00b85	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  00b8c	74 2d		 je	 SHORT $LN242@InputTextE
  00b8e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00b94	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  00b99	0f b6 c0	 movzx	 eax, al
  00b9c	85 c0		 test	 eax, eax
  00b9e	74 1b		 je	 SHORT $LN242@InputTextE
  00ba0	33 c9		 xor	 ecx, ecx
  00ba2	75 0b		 jne	 SHORT $LN243@InputTextE
  00ba4	0f b6 95 37 fe
	ff ff		 movzx	 edx, BYTE PTR _render_cursor$[ebp]
  00bab	85 d2		 test	 edx, edx
  00bad	74 0c		 je	 SHORT $LN242@InputTextE
$LN243@InputTextE:
  00baf	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv496[ebp], 1
  00bb9	eb 0a		 jmp	 SHORT $LN244@InputTextE
$LN242@InputTextE:
  00bbb	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv496[ebp], 0
$LN244@InputTextE:
  00bc5	8a 85 28 f4 ff
	ff		 mov	 al, BYTE PTR tv496[ebp]
  00bcb	88 85 2b fe ff
	ff		 mov	 BYTE PTR _render_selection$[ebp], al

; 3553 :     bool value_changed = false;

  00bd1	c6 85 1f fe ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 3554 :     bool enter_pressed = false;

  00bd8	c6 85 13 fe ff
	ff 00		 mov	 BYTE PTR _enter_pressed$[ebp], 0

; 3555 : 
; 3556 :     // When read-only we always use the live data passed to the function
; 3557 :     // FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
; 3558 :     if (is_readonly && state != NULL && (render_cursor || render_selection))

  00bdf	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  00be3	85 c0		 test	 eax, eax
  00be5	0f 84 b2 00 00
	00		 je	 $LN43@InputTextE
  00beb	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  00bf2	0f 84 a5 00 00
	00		 je	 $LN43@InputTextE
  00bf8	0f b6 85 37 fe
	ff ff		 movzx	 eax, BYTE PTR _render_cursor$[ebp]
  00bff	85 c0		 test	 eax, eax
  00c01	75 0f		 jne	 SHORT $LN44@InputTextE
  00c03	0f b6 85 2b fe
	ff ff		 movzx	 eax, BYTE PTR _render_selection$[ebp]
  00c0a	85 c0		 test	 eax, eax
  00c0c	0f 84 8b 00 00
	00		 je	 $LN43@InputTextE
$LN44@InputTextE:

; 3559 :     {
; 3560 :         const char* buf_end = NULL;

  00c12	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _buf_end$97[ebp], 0

; 3561 :         state->TextW.resize(buf_size + 1);

  00c1c	8b 45 14	 mov	 eax, DWORD PTR _buf_size$[ebp]
  00c1f	83 c0 01	 add	 eax, 1
  00c22	50		 push	 eax
  00c23	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00c29	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00c2c	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize

; 3562 :         state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, buf, NULL, &buf_end);

  00c31	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR _buf_end$97[ebp]
  00c37	50		 push	 eax
  00c38	6a 00		 push	 0
  00c3a	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  00c3d	51		 push	 ecx
  00c3e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  00c44	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00c47	50		 push	 eax
  00c48	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00c4e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00c51	52		 push	 edx
  00c52	e8 00 00 00 00	 call	 ?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z ; ImTextStrFromUtf8
  00c57	83 c4 14	 add	 esp, 20			; 00000014H
  00c5a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00c60	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3563 :         state->CurLenA = (int)(buf_end - buf);

  00c63	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR _buf_end$97[ebp]
  00c69	2b 45 10	 sub	 eax, DWORD PTR _buf$[ebp]
  00c6c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00c72	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3564 :         state->CursorClamp();

  00c75	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00c7b	e8 00 00 00 00	 call	 ?CursorClamp@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::CursorClamp

; 3565 :         render_selection &= state->HasSelection();

  00c80	0f b6 9d 2b fe
	ff ff		 movzx	 ebx, BYTE PTR _render_selection$[ebp]
  00c87	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00c8d	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  00c92	0f b6 c0	 movzx	 eax, al
  00c95	23 d8		 and	 ebx, eax
  00c97	88 9d 2b fe ff
	ff		 mov	 BYTE PTR _render_selection$[ebp], bl
$LN43@InputTextE:

; 3566 :     }
; 3567 : 
; 3568 :     // Select the buffer to render.
; 3569 :     const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state && state->TextAIsValid;

  00c9d	0f b6 85 37 fe
	ff ff		 movzx	 eax, BYTE PTR _render_cursor$[ebp]
  00ca4	85 c0		 test	 eax, eax
  00ca6	75 1c		 jne	 SHORT $LN245@InputTextE
  00ca8	0f b6 8d 2b fe
	ff ff		 movzx	 ecx, BYTE PTR _render_selection$[ebp]
  00caf	85 c9		 test	 ecx, ecx
  00cb1	75 11		 jne	 SHORT $LN245@InputTextE
  00cb3	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00cb6	8b 82 e4 19 00
	00		 mov	 eax, DWORD PTR [edx+6628]
  00cbc	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _id$[ebp]
  00cc2	75 28		 jne	 SHORT $LN246@InputTextE
$LN245@InputTextE:
  00cc4	0f b6 4d af	 movzx	 ecx, BYTE PTR _is_readonly$[ebp]
  00cc8	85 c9		 test	 ecx, ecx
  00cca	75 20		 jne	 SHORT $LN246@InputTextE
  00ccc	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  00cd3	74 17		 je	 SHORT $LN246@InputTextE
  00cd5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  00cdb	0f b6 42 30	 movzx	 eax, BYTE PTR [edx+48]
  00cdf	85 c0		 test	 eax, eax
  00ce1	74 09		 je	 SHORT $LN246@InputTextE
  00ce3	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv541[ebp], 1
  00cea	eb 07		 jmp	 SHORT $LN247@InputTextE
$LN246@InputTextE:
  00cec	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv541[ebp], 0
$LN247@InputTextE:
  00cf3	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv541[ebp]
  00cf9	88 8d fb fd ff
	ff		 mov	 BYTE PTR _buf_display_from_state$[ebp], cl

; 3570 :     const bool is_displaying_hint = (hint != NULL && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);

  00cff	83 7d 0c 00	 cmp	 DWORD PTR _hint$[ebp], 0
  00d03	74 44		 je	 SHORT $LN250@InputTextE
  00d05	0f b6 85 fb fd
	ff ff		 movzx	 eax, BYTE PTR _buf_display_from_state$[ebp]
  00d0c	85 c0		 test	 eax, eax
  00d0e	74 11		 je	 SHORT $LN248@InputTextE
  00d10	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  00d16	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00d19	89 95 28 f4 ff
	ff		 mov	 DWORD PTR tv547[ebp], edx
  00d1f	eb 09		 jmp	 SHORT $LN249@InputTextE
$LN248@InputTextE:
  00d21	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  00d24	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv547[ebp], eax
$LN249@InputTextE:
  00d2a	b9 01 00 00 00	 mov	 ecx, 1
  00d2f	6b d1 00	 imul	 edx, ecx, 0
  00d32	8b 85 28 f4 ff
	ff		 mov	 eax, DWORD PTR tv547[ebp]
  00d38	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00d3c	85 c9		 test	 ecx, ecx
  00d3e	75 09		 jne	 SHORT $LN250@InputTextE
  00d40	c6 85 27 f4 ff
	ff 01		 mov	 BYTE PTR tv552[ebp], 1
  00d47	eb 07		 jmp	 SHORT $LN251@InputTextE
$LN250@InputTextE:
  00d49	c6 85 27 f4 ff
	ff 00		 mov	 BYTE PTR tv552[ebp], 0
$LN251@InputTextE:
  00d50	8a 95 27 f4 ff
	ff		 mov	 dl, BYTE PTR tv552[ebp]
  00d56	88 95 ef fd ff
	ff		 mov	 BYTE PTR _is_displaying_hint$[ebp], dl

; 3571 : 
; 3572 :     // Password pushes a temporary font with only a fallback glyph
; 3573 :     if (is_password && !is_displaying_hint)

  00d5c	0f b6 45 a3	 movzx	 eax, BYTE PTR _is_password$[ebp]
  00d60	85 c0		 test	 eax, eax
  00d62	0f 84 4a 01 00
	00		 je	 $LN45@InputTextE
  00d68	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  00d6f	85 c0		 test	 eax, eax
  00d71	0f 85 3b 01 00
	00		 jne	 $LN45@InputTextE

; 3574 :     {
; 3575 :         const ImFontGlyph* glyph = g.Font->FindGlyph('*');

  00d77	6a 2a		 push	 42			; 0000002aH
  00d79	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00d7c	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00d82	e8 00 00 00 00	 call	 ?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyph
  00d87	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _glyph$96[ebp], eax

; 3576 :         ImFont* password_font = &g.InputTextPasswordFont;

  00d8d	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00d90	05 74 2c 00 00	 add	 eax, 11380		; 00002c74H
  00d95	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _password_font$95[ebp], eax

; 3577 :         password_font->FontSize = g.Font->FontSize;

  00d9b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00d9e	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00da4	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _password_font$95[ebp]
  00daa	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00dad	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 3578 :         password_font->Scale = g.Font->Scale;

  00db0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00db3	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00db9	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _password_font$95[ebp]
  00dbf	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  00dc2	89 42 48	 mov	 DWORD PTR [edx+72], eax

; 3579 :         password_font->DisplayOffset = g.Font->DisplayOffset;

  00dc5	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00dc8	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00dce	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00dd1	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00dd4	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _password_font$95[ebp]
  00dda	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00ddd	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 3580 :         password_font->Ascent = g.Font->Ascent;

  00de0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00de3	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00de9	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _password_font$95[ebp]
  00def	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00df2	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 3581 :         password_font->Descent = g.Font->Descent;

  00df5	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00df8	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00dfe	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _password_font$95[ebp]
  00e04	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00e07	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 3582 :         password_font->ContainerAtlas = g.Font->ContainerAtlas;

  00e0a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00e0d	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  00e13	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _password_font$95[ebp]
  00e19	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00e1c	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 3583 :         password_font->FallbackGlyph = glyph;

  00e1f	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _password_font$95[ebp]
  00e25	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _glyph$96[ebp]
  00e2b	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 3584 :         password_font->FallbackAdvanceX = glyph->AdvanceX;

  00e2e	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _password_font$95[ebp]
  00e34	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR _glyph$96[ebp]
  00e3a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00e3d	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 3585 :         IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());

  00e40	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _password_font$95[ebp]
  00e46	83 c1 20	 add	 ecx, 32			; 00000020H
  00e49	e8 00 00 00 00	 call	 ?empty@?$ImVector@UImFontGlyph@@@@QBE_NXZ ; ImVector<ImFontGlyph>::empty
  00e4e	0f b6 c0	 movzx	 eax, al
  00e51	85 c0		 test	 eax, eax
  00e53	74 27		 je	 SHORT $LN252@InputTextE
  00e55	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _password_font$95[ebp]
  00e5b	e8 00 00 00 00	 call	 ?empty@?$ImVector@M@@QBE_NXZ ; ImVector<float>::empty
  00e60	0f b6 c8	 movzx	 ecx, al
  00e63	85 c9		 test	 ecx, ecx
  00e65	74 15		 je	 SHORT $LN252@InputTextE
  00e67	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _password_font$95[ebp]
  00e6d	83 c1 14	 add	 ecx, 20			; 00000014H
  00e70	e8 00 00 00 00	 call	 ?empty@?$ImVector@G@@QBE_NXZ ; ImVector<unsigned short>::empty
  00e75	0f b6 d0	 movzx	 edx, al
  00e78	85 d2		 test	 edx, edx
  00e7a	75 27		 jne	 SHORT $LN253@InputTextE
$LN252@InputTextE:
  00e7c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  00e81	05 ba 00 00 00	 add	 eax, 186		; 000000baH
  00e86	8b f4		 mov	 esi, esp
  00e88	50		 push	 eax
  00e89	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00e8e	68 00 00 00 00	 push	 OFFSET ??_C@_1NI@EFFIGGBI@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AA_?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO@
  00e93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00e99	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e9c	3b f4		 cmp	 esi, esp
  00e9e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN253@InputTextE:

; 3586 :         PushFont(password_font);

  00ea3	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _password_font$95[ebp]
  00ea9	50		 push	 eax
  00eaa	e8 00 00 00 00	 call	 ?PushFont@ImGui@@YAXPAUImFont@@@Z ; ImGui::PushFont
  00eaf	83 c4 04	 add	 esp, 4
$LN45@InputTextE:

; 3587 :     }
; 3588 : 
; 3589 :     // Process mouse inputs and character inputs
; 3590 :     int backup_current_text_length = 0;

  00eb2	c7 85 c8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _backup_current_text_length$[ebp], 0

; 3591 :     if (g.ActiveId == id)

  00ebc	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00ebf	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00ec5	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  00ecb	0f 85 3c 05 00
	00		 jne	 $LN61@InputTextE

; 3592 :     {
; 3593 :         IM_ASSERT(state != NULL);

  00ed1	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  00ed8	75 27		 jne	 SHORT $LN254@InputTextE
  00eda	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  00edf	05 c2 00 00 00	 add	 eax, 194		; 000000c2H
  00ee4	8b f4		 mov	 esi, esp
  00ee6	50		 push	 eax
  00ee7	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00eec	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@FOPGMADN@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  00ef1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00ef7	83 c4 0c	 add	 esp, 12			; 0000000cH
  00efa	3b f4		 cmp	 esi, esp
  00efc	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN254@InputTextE:

; 3594 :         backup_current_text_length = state->CurLenA;

  00f01	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00f07	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f0a	89 8d c8 fd ff
	ff		 mov	 DWORD PTR _backup_current_text_length$[ebp], ecx

; 3595 :         state->BufCapacityA = buf_size;

  00f10	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00f16	8b 4d 14	 mov	 ecx, DWORD PTR _buf_size$[ebp]
  00f19	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 3596 :         state->UserFlags = flags;

  00f1c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00f22	8b 4d 1c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00f25	89 88 68 0e 00
	00		 mov	 DWORD PTR [eax+3688], ecx

; 3597 :         state->UserCallback = callback;

  00f2b	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00f31	8b 4d 20	 mov	 ecx, DWORD PTR _callback$[ebp]
  00f34	89 88 6c 0e 00
	00		 mov	 DWORD PTR [eax+3692], ecx

; 3598 :         state->UserCallbackData = callback_user_data;

  00f3a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  00f40	8b 4d 24	 mov	 ecx, DWORD PTR _callback_user_data$[ebp]
  00f43	89 88 70 0e 00
	00		 mov	 DWORD PTR [eax+3696], ecx

; 3599 : 
; 3600 :         // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
; 3601 :         // Down the line we should have a cleaner library-wide concept of Selected vs Active.
; 3602 :         g.ActiveIdAllowOverlap = !io.MouseDown[0];

  00f49	b8 01 00 00 00	 mov	 eax, 1
  00f4e	6b c8 00	 imul	 ecx, eax, 0
  00f51	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  00f54	0f b6 84 0a e8
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+232]
  00f5c	85 c0		 test	 eax, eax
  00f5e	75 0c		 jne	 SHORT $LN255@InputTextE
  00f60	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv624[ebp], 1
  00f6a	eb 0a		 jmp	 SHORT $LN256@InputTextE
$LN255@InputTextE:
  00f6c	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv624[ebp], 0
$LN256@InputTextE:
  00f76	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00f79	8a 95 28 f4 ff
	ff		 mov	 dl, BYTE PTR tv624[ebp]
  00f7f	88 91 f1 19 00
	00		 mov	 BYTE PTR [ecx+6641], dl

; 3603 :         g.WantTextInputNextFrame = 1;

  00f85	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00f88	c7 80 7c 2f 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+12156], 1

; 3604 : 
; 3605 :         // Edit in progress
; 3606 :         const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->ScrollX;

  00f92	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  00f95	f3 0f 10 80 e0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+224]
  00f9d	f3 0f 5c 85 34
	ff ff ff	 subss	 xmm0, DWORD PTR _frame_bb$[ebp]
  00fa5	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  00fa8	f3 0f 5c 41 38	 subss	 xmm0, DWORD PTR [ecx+56]
  00fad	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  00fb3	f3 0f 58 42 38	 addss	 xmm0, DWORD PTR [edx+56]
  00fb8	f3 0f 11 85 bc
	fd ff ff	 movss	 DWORD PTR _mouse_x$94[ebp], xmm0

; 3607 :         const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));

  00fc0	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  00fc4	85 c0		 test	 eax, eax
  00fc6	74 2b		 je	 SHORT $LN257@InputTextE
  00fc8	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  00fcb	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _draw_window$[ebp]
  00fd1	f3 0f 10 81 e4
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+228]
  00fd9	f3 0f 5c 82 cc
	00 00 00	 subss	 xmm0, DWORD PTR [edx+204]
  00fe1	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  00fe4	f3 0f 5c 40 3c	 subss	 xmm0, DWORD PTR [eax+60]
  00fe9	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv682[ebp], xmm0
  00ff1	eb 1b		 jmp	 SHORT $LN258@InputTextE
$LN257@InputTextE:
  00ff3	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00ff6	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  00ffe	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  01006	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv682[ebp], xmm0
$LN258@InputTextE:
  0100e	f3 0f 10 85 28
	f4 ff ff	 movss	 xmm0, DWORD PTR tv682[ebp]
  01016	f3 0f 11 85 b0
	fd ff ff	 movss	 DWORD PTR _mouse_y$93[ebp], xmm0

; 3608 : 
; 3609 :         const bool is_osx = io.ConfigMacOSXBehaviors;

  0101e	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01021	8a 88 a9 00 00
	00		 mov	 cl, BYTE PTR [eax+169]
  01027	88 8d a7 fd ff
	ff		 mov	 BYTE PTR _is_osx$92[ebp], cl

; 3610 :         if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))

  0102d	0f b6 85 7f fe
	ff ff		 movzx	 eax, BYTE PTR _select_all$[ebp]
  01034	85 c0		 test	 eax, eax
  01036	75 2d		 jne	 SHORT $LN49@InputTextE
  01038	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  0103f	85 c0		 test	 eax, eax
  01041	74 3f		 je	 SHORT $LN47@InputTextE
  01043	0f b6 85 a7 fd
	ff ff		 movzx	 eax, BYTE PTR _is_osx$92[ebp]
  0104a	85 c0		 test	 eax, eax
  0104c	75 34		 jne	 SHORT $LN47@InputTextE
  0104e	b8 01 00 00 00	 mov	 eax, 1
  01053	6b c8 00	 imul	 ecx, eax, 0
  01056	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  01059	0f b6 84 0a d5
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+981]
  01061	85 c0		 test	 eax, eax
  01063	74 1d		 je	 SHORT $LN47@InputTextE
$LN49@InputTextE:

; 3611 :         {
; 3612 :             state->SelectAll();

  01065	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0106b	e8 00 00 00 00	 call	 ?SelectAll@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::SelectAll

; 3613 :             state->SelectedAllMouseLock = true;

  01070	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01076	c6 80 65 0e 00
	00 01		 mov	 BYTE PTR [eax+3685], 1

; 3614 :         }

  0107d	e9 73 01 00 00	 jmp	 $LN55@InputTextE
$LN47@InputTextE:

; 3615 :         else if (hovered && is_osx && io.MouseDoubleClicked[0])

  01082	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  01089	85 c0		 test	 eax, eax
  0108b	74 47		 je	 SHORT $LN50@InputTextE
  0108d	0f b6 85 a7 fd
	ff ff		 movzx	 eax, BYTE PTR _is_osx$92[ebp]
  01094	85 c0		 test	 eax, eax
  01096	74 3c		 je	 SHORT $LN50@InputTextE
  01098	b8 01 00 00 00	 mov	 eax, 1
  0109d	6b c8 00	 imul	 ecx, eax, 0
  010a0	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  010a3	0f b6 84 0a d5
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+981]
  010ab	85 c0		 test	 eax, eax
  010ad	74 25		 je	 SHORT $LN50@InputTextE

; 3616 :         {
; 3617 :             // Double-click select a word only, OS X style (by simulating keystrokes)
; 3618 :             state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);

  010af	68 0c 00 20 00	 push	 2097164			; 0020000cH
  010b4	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  010ba	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed

; 3619 :             state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);

  010bf	68 0d 00 60 00	 push	 6291469			; 0060000dH
  010c4	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  010ca	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed

; 3620 :         }

  010cf	e9 21 01 00 00	 jmp	 $LN55@InputTextE
$LN50@InputTextE:

; 3621 :         else if (io.MouseClicked[0] && !state->SelectedAllMouseLock)

  010d4	b8 01 00 00 00	 mov	 eax, 1
  010d9	6b c8 00	 imul	 ecx, eax, 0
  010dc	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  010df	0f b6 84 0a d0
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+976]
  010e7	85 c0		 test	 eax, eax
  010e9	74 61		 je	 SHORT $LN52@InputTextE
  010eb	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  010f1	0f b6 88 65 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3685]
  010f8	85 c9		 test	 ecx, ecx
  010fa	75 50		 jne	 SHORT $LN52@InputTextE

; 3622 :         {
; 3623 :             if (hovered)

  010fc	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  01103	85 c0		 test	 eax, eax
  01105	74 40		 je	 SHORT $LN54@InputTextE

; 3624 :             {
; 3625 :                 stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);

  01107	51		 push	 ecx
  01108	f3 0f 10 85 b0
	fd ff ff	 movss	 xmm0, DWORD PTR _mouse_y$93[ebp]
  01110	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01115	51		 push	 ecx
  01116	f3 0f 10 85 bc
	fd ff ff	 movss	 xmm0, DWORD PTR _mouse_x$94[ebp]
  0111e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01123	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01129	83 c0 3c	 add	 eax, 60			; 0000003cH
  0112c	50		 push	 eax
  0112d	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01133	51		 push	 ecx
  01134	e8 00 00 00 00	 call	 ?stb_textedit_click@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z ; ImStb::stb_textedit_click
  01139	83 c4 10	 add	 esp, 16			; 00000010H

; 3626 :                 state->CursorAnimReset();

  0113c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01142	e8 00 00 00 00	 call	 ?CursorAnimReset@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::CursorAnimReset
$LN54@InputTextE:

; 3627 :             }
; 3628 :         }

  01147	e9 a9 00 00 00	 jmp	 $LN55@InputTextE
$LN52@InputTextE:

; 3629 :         else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))

  0114c	b8 01 00 00 00	 mov	 eax, 1
  01151	6b c8 00	 imul	 ecx, eax, 0
  01154	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  01157	0f b6 84 0a e8
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+232]
  0115f	85 c0		 test	 eax, eax
  01161	0f 84 8e 00 00
	00		 je	 $LN55@InputTextE
  01167	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0116d	0f b6 88 65 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3685]
  01174	85 c9		 test	 ecx, ecx
  01176	75 7d		 jne	 SHORT $LN55@InputTextE
  01178	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0117b	f3 0f 10 80 70
	03 00 00	 movss	 xmm0, DWORD PTR [eax+880]
  01183	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0118a	9f		 lahf
  0118b	f6 c4 44	 test	 ah, 68			; 00000044H
  0118e	7a 18		 jp	 SHORT $LN56@InputTextE
  01190	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01193	f3 0f 10 80 74
	03 00 00	 movss	 xmm0, DWORD PTR [eax+884]
  0119b	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  011a2	9f		 lahf
  011a3	f6 c4 44	 test	 ah, 68			; 00000044H
  011a6	7b 4d		 jnp	 SHORT $LN55@InputTextE
$LN56@InputTextE:

; 3630 :         {
; 3631 :             stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);

  011a8	51		 push	 ecx
  011a9	f3 0f 10 85 b0
	fd ff ff	 movss	 xmm0, DWORD PTR _mouse_y$93[ebp]
  011b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011b6	51		 push	 ecx
  011b7	f3 0f 10 85 bc
	fd ff ff	 movss	 xmm0, DWORD PTR _mouse_x$94[ebp]
  011bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011c4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  011ca	83 c0 3c	 add	 eax, 60			; 0000003cH
  011cd	50		 push	 eax
  011ce	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  011d4	51		 push	 ecx
  011d5	e8 00 00 00 00	 call	 ?stb_textedit_drag@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@MM@Z ; ImStb::stb_textedit_drag
  011da	83 c4 10	 add	 esp, 16			; 00000010H

; 3632 :             state->CursorAnimReset();

  011dd	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  011e3	e8 00 00 00 00	 call	 ?CursorAnimReset@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::CursorAnimReset

; 3633 :             state->CursorFollow = true;

  011e8	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  011ee	c6 80 64 0e 00
	00 01		 mov	 BYTE PTR [eax+3684], 1
$LN55@InputTextE:

; 3634 :         }
; 3635 :         if (state->SelectedAllMouseLock && !io.MouseDown[0])

  011f5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  011fb	0f b6 88 65 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3685]
  01202	85 c9		 test	 ecx, ecx
  01204	74 24		 je	 SHORT $LN57@InputTextE
  01206	b8 01 00 00 00	 mov	 eax, 1
  0120b	6b c8 00	 imul	 ecx, eax, 0
  0120e	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  01211	0f b6 84 0a e8
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+232]
  01219	85 c0		 test	 eax, eax
  0121b	75 0d		 jne	 SHORT $LN57@InputTextE

; 3636 :             state->SelectedAllMouseLock = false;

  0121d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01223	c6 80 65 0e 00
	00 00		 mov	 BYTE PTR [eax+3685], 0
$LN57@InputTextE:

; 3637 : 
; 3638 :         // It is ill-defined whether the back-end needs to send a \t character when pressing the TAB keys.
; 3639 :         // Win32 and GLFW naturally do it but not SDL.
; 3640 :         const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);

  0122a	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0122d	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01234	85 c9		 test	 ecx, ecx
  01236	74 0e		 je	 SHORT $LN259@InputTextE
  01238	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  0123b	0f b6 82 fa 00
	00 00		 movzx	 eax, BYTE PTR [edx+250]
  01242	85 c0		 test	 eax, eax
  01244	74 22		 je	 SHORT $LN261@InputTextE
$LN259@InputTextE:
  01246	0f b6 8d a7 fd
	ff ff		 movzx	 ecx, BYTE PTR _is_osx$92[ebp]
  0124d	85 c9		 test	 ecx, ecx
  0124f	74 0e		 je	 SHORT $LN260@InputTextE
  01251	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  01254	0f b6 82 fb 00
	00 00		 movzx	 eax, BYTE PTR [edx+251]
  0125b	85 c0		 test	 eax, eax
  0125d	75 09		 jne	 SHORT $LN261@InputTextE
$LN260@InputTextE:
  0125f	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv767[ebp], 0
  01266	eb 07		 jmp	 SHORT $LN262@InputTextE
$LN261@InputTextE:
  01268	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv767[ebp], 1
$LN262@InputTextE:
  0126f	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv767[ebp]
  01275	88 8d 9b fd ff
	ff		 mov	 BYTE PTR _ignore_char_inputs$91[ebp], cl

; 3641 :         if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !ignore_char_inputs && !io.KeyShift && !is_readonly)

  0127b	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0127e	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  01283	0f 84 9e 00 00
	00		 je	 $LN60@InputTextE
  01289	6a 01		 push	 1
  0128b	6a 00		 push	 0
  0128d	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01292	83 c4 08	 add	 esp, 8
  01295	0f b6 c0	 movzx	 eax, al
  01298	85 c0		 test	 eax, eax
  0129a	0f 84 87 00 00
	00		 je	 $LN60@InputTextE
  012a0	0f b6 85 9b fd
	ff ff		 movzx	 eax, BYTE PTR _ignore_char_inputs$91[ebp]
  012a7	85 c0		 test	 eax, eax
  012a9	75 7c		 jne	 SHORT $LN60@InputTextE
  012ab	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  012ae	0f b6 88 f9 00
	00 00		 movzx	 ecx, BYTE PTR [eax+249]
  012b5	85 c9		 test	 ecx, ecx
  012b7	75 6e		 jne	 SHORT $LN60@InputTextE
  012b9	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  012bd	85 c0		 test	 eax, eax
  012bf	75 66		 jne	 SHORT $LN60@InputTextE

; 3642 :             if (!io.InputQueueCharacters.contains('\t'))

  012c1	b8 09 00 00 00	 mov	 eax, 9
  012c6	66 89 85 a6 f5
	ff ff		 mov	 WORD PTR $T23[ebp], ax
  012cd	8d 8d a6 f5 ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  012d3	51		 push	 ecx
  012d4	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  012d7	81 c1 f8 14 00
	00		 add	 ecx, 5368		; 000014f8H
  012dd	e8 00 00 00 00	 call	 ?contains@?$ImVector@G@@QBE_NABG@Z ; ImVector<unsigned short>::contains
  012e2	0f b6 d0	 movzx	 edx, al
  012e5	85 d2		 test	 edx, edx
  012e7	75 3e		 jne	 SHORT $LN60@InputTextE

; 3643 :             {
; 3644 :                 unsigned int c = '\t'; // Insert TAB

  012e9	c7 85 8c fd ff
	ff 09 00 00 00	 mov	 DWORD PTR _c$90[ebp], 9

; 3645 :                 if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))

  012f3	8b 45 24	 mov	 eax, DWORD PTR _callback_user_data$[ebp]
  012f6	50		 push	 eax
  012f7	8b 4d 20	 mov	 ecx, DWORD PTR _callback$[ebp]
  012fa	51		 push	 ecx
  012fb	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  012fe	52		 push	 edx
  012ff	8d 85 8c fd ff
	ff		 lea	 eax, DWORD PTR _c$90[ebp]
  01305	50		 push	 eax
  01306	e8 00 00 00 00	 call	 ?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
  0130b	83 c4 10	 add	 esp, 16			; 00000010H
  0130e	0f b6 c8	 movzx	 ecx, al
  01311	85 c9		 test	 ecx, ecx
  01313	74 12		 je	 SHORT $LN60@InputTextE

; 3646 :                     state->OnKeyPressed((int)c);

  01315	8b 85 8c fd ff
	ff		 mov	 eax, DWORD PTR _c$90[ebp]
  0131b	50		 push	 eax
  0131c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01322	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
$LN60@InputTextE:

; 3647 :             }
; 3648 : 
; 3649 :         // Process regular text input (before we check for Return because using some IME will effectively send a Return?)
; 3650 :         // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
; 3651 :         if (io.InputQueueCharacters.Size > 0)

  01327	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0132a	83 b8 f8 14 00
	00 00		 cmp	 DWORD PTR [eax+5368], 0
  01331	0f 8e d6 00 00
	00		 jle	 $LN61@InputTextE

; 3652 :         {
; 3653 :             if (!ignore_char_inputs && !is_readonly && !user_nav_input_start)

  01337	0f b6 85 9b fd
	ff ff		 movzx	 eax, BYTE PTR _ignore_char_inputs$91[ebp]
  0133e	85 c0		 test	 eax, eax
  01340	0f 85 b7 00 00
	00		 jne	 $LN3@InputTextE
  01346	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  0134a	85 c0		 test	 eax, eax
  0134c	0f 85 ab 00 00
	00		 jne	 $LN3@InputTextE
  01352	0f b6 85 af fe
	ff ff		 movzx	 eax, BYTE PTR _user_nav_input_start$[ebp]
  01359	85 c0		 test	 eax, eax
  0135b	0f 85 9c 00 00
	00		 jne	 $LN3@InputTextE

; 3654 :                 for (int n = 0; n < io.InputQueueCharacters.Size; n++)

  01361	c7 85 80 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$89[ebp], 0
  0136b	eb 0f		 jmp	 SHORT $LN4@InputTextE
$LN2@InputTextE:
  0136d	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _n$89[ebp]
  01373	83 c0 01	 add	 eax, 1
  01376	89 85 80 fd ff
	ff		 mov	 DWORD PTR _n$89[ebp], eax
$LN4@InputTextE:
  0137c	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0137f	8b 8d 80 fd ff
	ff		 mov	 ecx, DWORD PTR _n$89[ebp]
  01385	3b 88 f8 14 00
	00		 cmp	 ecx, DWORD PTR [eax+5368]
  0138b	7d 70		 jge	 SHORT $LN3@InputTextE

; 3655 :                 {
; 3656 :                     // Insert character if they pass filtering
; 3657 :                     unsigned int c = (unsigned int)io.InputQueueCharacters[n];

  0138d	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _n$89[ebp]
  01393	50		 push	 eax
  01394	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  01397	81 c1 f8 14 00
	00		 add	 ecx, 5368		; 000014f8H
  0139d	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  013a2	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  013a5	89 8d 74 fd ff
	ff		 mov	 DWORD PTR _c$88[ebp], ecx

; 3658 :                     if (c == '\t' && io.KeyShift)

  013ab	83 bd 74 fd ff
	ff 09		 cmp	 DWORD PTR _c$88[ebp], 9
  013b2	75 10		 jne	 SHORT $LN63@InputTextE
  013b4	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  013b7	0f b6 88 f9 00
	00 00		 movzx	 ecx, BYTE PTR [eax+249]
  013be	85 c9		 test	 ecx, ecx
  013c0	74 02		 je	 SHORT $LN63@InputTextE

; 3659 :                         continue;

  013c2	eb a9		 jmp	 SHORT $LN2@InputTextE
$LN63@InputTextE:

; 3660 :                     if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))

  013c4	8b 45 24	 mov	 eax, DWORD PTR _callback_user_data$[ebp]
  013c7	50		 push	 eax
  013c8	8b 4d 20	 mov	 ecx, DWORD PTR _callback$[ebp]
  013cb	51		 push	 ecx
  013cc	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  013cf	52		 push	 edx
  013d0	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR _c$88[ebp]
  013d6	50		 push	 eax
  013d7	e8 00 00 00 00	 call	 ?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
  013dc	83 c4 10	 add	 esp, 16			; 00000010H
  013df	0f b6 c8	 movzx	 ecx, al
  013e2	85 c9		 test	 ecx, ecx
  013e4	74 12		 je	 SHORT $LN64@InputTextE

; 3661 :                         state->OnKeyPressed((int)c);

  013e6	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _c$88[ebp]
  013ec	50		 push	 eax
  013ed	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  013f3	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
$LN64@InputTextE:

; 3662 :                 }

  013f8	e9 70 ff ff ff	 jmp	 $LN2@InputTextE
$LN3@InputTextE:

; 3663 : 
; 3664 :             // Consume characters
; 3665 :             io.InputQueueCharacters.resize(0);

  013fd	6a 00		 push	 0
  013ff	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  01402	81 c1 f8 14 00
	00		 add	 ecx, 5368		; 000014f8H
  01408	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize
$LN61@InputTextE:

; 3666 :         }
; 3667 :     }
; 3668 : 
; 3669 :     // Process other shortcuts/key-presses
; 3670 :     bool cancel_edit = false;

  0140d	c6 85 6b fd ff
	ff 00		 mov	 BYTE PTR _cancel_edit$[ebp], 0

; 3671 :     if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)

  01414	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  01417	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0141d	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  01423	0f 85 f0 0d 00
	00		 jne	 $LN65@InputTextE
  01429	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0142c	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  01433	85 c9		 test	 ecx, ecx
  01435	0f 85 de 0d 00
	00		 jne	 $LN65@InputTextE
  0143b	0f b6 85 8b fe
	ff ff		 movzx	 eax, BYTE PTR _clear_active_id$[ebp]
  01442	85 c0		 test	 eax, eax
  01444	0f 85 cf 0d 00
	00		 jne	 $LN65@InputTextE

; 3672 :     {
; 3673 :         IM_ASSERT(state != NULL);

  0144a	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  01451	75 27		 jne	 SHORT $LN263@InputTextE
  01453	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  01458	05 12 01 00 00	 add	 eax, 274		; 00000112H
  0145d	8b f4		 mov	 esi, esp
  0145f	50		 push	 eax
  01460	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  01465	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@FOPGMADN@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  0146a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  01470	83 c4 0c	 add	 esp, 12			; 0000000cH
  01473	3b f4		 cmp	 esi, esp
  01475	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN263@InputTextE:

; 3674 :         const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);

  0147a	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0147d	0f b6 88 f9 00
	00 00		 movzx	 ecx, BYTE PTR [eax+249]
  01484	85 c9		 test	 ecx, ecx
  01486	74 0c		 je	 SHORT $LN264@InputTextE
  01488	c7 85 28 f4 ff
	ff 00 00 40 00	 mov	 DWORD PTR tv847[ebp], 4194304 ; 00400000H
  01492	eb 0a		 jmp	 SHORT $LN265@InputTextE
$LN264@InputTextE:
  01494	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv847[ebp], 0
$LN265@InputTextE:
  0149e	8b 95 28 f4 ff
	ff		 mov	 edx, DWORD PTR tv847[ebp]
  014a4	89 95 5c fd ff
	ff		 mov	 DWORD PTR _k_mask$87[ebp], edx

; 3675 :         const bool is_osx = io.ConfigMacOSXBehaviors;

  014aa	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  014ad	8a 88 a9 00 00
	00		 mov	 cl, BYTE PTR [eax+169]
  014b3	88 8d 53 fd ff
	ff		 mov	 BYTE PTR _is_osx$86[ebp], cl

; 3676 :         const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl

  014b9	0f b6 85 53 fd
	ff ff		 movzx	 eax, BYTE PTR _is_osx$86[ebp]
  014c0	85 c0		 test	 eax, eax
  014c2	74 40		 je	 SHORT $LN270@InputTextE
  014c4	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  014c7	0f b6 91 fb 00
	00 00		 movzx	 edx, BYTE PTR [ecx+251]
  014ce	85 d2		 test	 edx, edx
  014d0	74 1a		 je	 SHORT $LN266@InputTextE
  014d2	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  014d5	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  014dc	85 c9		 test	 ecx, ecx
  014de	75 0c		 jne	 SHORT $LN266@InputTextE
  014e0	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv862[ebp], 1
  014ea	eb 0a		 jmp	 SHORT $LN269@InputTextE
$LN266@InputTextE:
  014ec	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv862[ebp], 0
$LN269@InputTextE:
  014f6	8b 95 28 f4 ff
	ff		 mov	 edx, DWORD PTR tv862[ebp]
  014fc	89 95 24 f4 ff
	ff		 mov	 DWORD PTR tv865[ebp], edx
  01502	eb 3e		 jmp	 SHORT $LN271@InputTextE
$LN270@InputTextE:
  01504	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01507	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  0150e	85 c9		 test	 ecx, ecx
  01510	74 1a		 je	 SHORT $LN267@InputTextE
  01512	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  01515	0f b6 82 fb 00
	00 00		 movzx	 eax, BYTE PTR [edx+251]
  0151c	85 c0		 test	 eax, eax
  0151e	75 0c		 jne	 SHORT $LN267@InputTextE
  01520	c7 85 20 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv861[ebp], 1
  0152a	eb 0a		 jmp	 SHORT $LN268@InputTextE
$LN267@InputTextE:
  0152c	c7 85 20 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv861[ebp], 0
$LN268@InputTextE:
  01536	8b 8d 20 f4 ff
	ff		 mov	 ecx, DWORD PTR tv861[ebp]
  0153c	89 8d 24 f4 ff
	ff		 mov	 DWORD PTR tv865[ebp], ecx
$LN271@InputTextE:
  01542	83 bd 24 f4 ff
	ff 00		 cmp	 DWORD PTR tv865[ebp], 0
  01549	74 25		 je	 SHORT $LN272@InputTextE
  0154b	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  0154e	0f b6 82 fa 00
	00 00		 movzx	 eax, BYTE PTR [edx+250]
  01555	85 c0		 test	 eax, eax
  01557	75 17		 jne	 SHORT $LN272@InputTextE
  01559	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  0155c	0f b6 91 f9 00
	00 00		 movzx	 edx, BYTE PTR [ecx+249]
  01563	85 d2		 test	 edx, edx
  01565	75 09		 jne	 SHORT $LN272@InputTextE
  01567	c6 85 1f f4 ff
	ff 01		 mov	 BYTE PTR tv873[ebp], 1
  0156e	eb 07		 jmp	 SHORT $LN273@InputTextE
$LN272@InputTextE:
  01570	c6 85 1f f4 ff
	ff 00		 mov	 BYTE PTR tv873[ebp], 0
$LN273@InputTextE:
  01577	8a 85 1f f4 ff
	ff		 mov	 al, BYTE PTR tv873[ebp]
  0157d	88 85 47 fd ff
	ff		 mov	 BYTE PTR _is_shortcut_key$85[ebp], al

; 3677 :         const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;

  01583	0f b6 85 53 fd
	ff ff		 movzx	 eax, BYTE PTR _is_osx$86[ebp]
  0158a	85 c0		 test	 eax, eax
  0158c	74 41		 je	 SHORT $LN274@InputTextE
  0158e	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  01591	0f b6 91 fb 00
	00 00		 movzx	 edx, BYTE PTR [ecx+251]
  01598	85 d2		 test	 edx, edx
  0159a	74 33		 je	 SHORT $LN274@InputTextE
  0159c	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0159f	0f b6 88 f9 00
	00 00		 movzx	 ecx, BYTE PTR [eax+249]
  015a6	85 c9		 test	 ecx, ecx
  015a8	74 25		 je	 SHORT $LN274@InputTextE
  015aa	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  015ad	0f b6 82 f8 00
	00 00		 movzx	 eax, BYTE PTR [edx+248]
  015b4	85 c0		 test	 eax, eax
  015b6	75 17		 jne	 SHORT $LN274@InputTextE
  015b8	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  015bb	0f b6 91 fa 00
	00 00		 movzx	 edx, BYTE PTR [ecx+250]
  015c2	85 d2		 test	 edx, edx
  015c4	75 09		 jne	 SHORT $LN274@InputTextE
  015c6	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv888[ebp], 1
  015cd	eb 07		 jmp	 SHORT $LN275@InputTextE
$LN274@InputTextE:
  015cf	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv888[ebp], 0
$LN275@InputTextE:
  015d6	8a 85 2b f4 ff
	ff		 mov	 al, BYTE PTR tv888[ebp]
  015dc	88 85 3b fd ff
	ff		 mov	 BYTE PTR _is_osx_shift_shortcut$84[ebp], al

; 3678 :         const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl

  015e2	0f b6 85 53 fd
	ff ff		 movzx	 eax, BYTE PTR _is_osx$86[ebp]
  015e9	85 c0		 test	 eax, eax
  015eb	74 11		 je	 SHORT $LN276@InputTextE
  015ed	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  015f0	8a 91 fa 00 00
	00		 mov	 dl, BYTE PTR [ecx+250]
  015f6	88 95 2b f4 ff
	ff		 mov	 BYTE PTR tv893[ebp], dl
  015fc	eb 0f		 jmp	 SHORT $LN277@InputTextE
$LN276@InputTextE:
  015fe	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01601	8a 88 f8 00 00
	00		 mov	 cl, BYTE PTR [eax+248]
  01607	88 8d 2b f4 ff
	ff		 mov	 BYTE PTR tv893[ebp], cl
$LN277@InputTextE:
  0160d	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv893[ebp]
  01613	88 95 2f fd ff
	ff		 mov	 BYTE PTR _is_wordmove_key_down$83[ebp], dl

; 3679 :         const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End

  01619	0f b6 85 53 fd
	ff ff		 movzx	 eax, BYTE PTR _is_osx$86[ebp]
  01620	85 c0		 test	 eax, eax
  01622	74 33		 je	 SHORT $LN278@InputTextE
  01624	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  01627	0f b6 91 fb 00
	00 00		 movzx	 edx, BYTE PTR [ecx+251]
  0162e	85 d2		 test	 edx, edx
  01630	74 25		 je	 SHORT $LN278@InputTextE
  01632	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01635	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  0163c	85 c9		 test	 ecx, ecx
  0163e	75 17		 jne	 SHORT $LN278@InputTextE
  01640	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  01643	0f b6 82 fa 00
	00 00		 movzx	 eax, BYTE PTR [edx+250]
  0164a	85 c0		 test	 eax, eax
  0164c	75 09		 jne	 SHORT $LN278@InputTextE
  0164e	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv905[ebp], 1
  01655	eb 07		 jmp	 SHORT $LN279@InputTextE
$LN278@InputTextE:
  01657	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv905[ebp], 0
$LN279@InputTextE:
  0165e	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv905[ebp]
  01664	88 8d 23 fd ff
	ff		 mov	 BYTE PTR _is_startend_key_down$82[ebp], cl

; 3680 :         const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;

  0166a	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  0166d	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01674	85 c9		 test	 ecx, ecx
  01676	74 33		 je	 SHORT $LN280@InputTextE
  01678	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  0167b	0f b6 82 f9 00
	00 00		 movzx	 eax, BYTE PTR [edx+249]
  01682	85 c0		 test	 eax, eax
  01684	75 25		 jne	 SHORT $LN280@InputTextE
  01686	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  01689	0f b6 91 fa 00
	00 00		 movzx	 edx, BYTE PTR [ecx+250]
  01690	85 d2		 test	 edx, edx
  01692	75 17		 jne	 SHORT $LN280@InputTextE
  01694	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01697	0f b6 88 fb 00
	00 00		 movzx	 ecx, BYTE PTR [eax+251]
  0169e	85 c9		 test	 ecx, ecx
  016a0	75 09		 jne	 SHORT $LN280@InputTextE
  016a2	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv918[ebp], 1
  016a9	eb 07		 jmp	 SHORT $LN281@InputTextE
$LN280@InputTextE:
  016ab	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv918[ebp], 0
$LN281@InputTextE:
  016b2	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv918[ebp]
  016b8	88 95 17 fd ff
	ff		 mov	 BYTE PTR _is_ctrl_key_only$81[ebp], dl

; 3681 :         const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

  016be	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  016c1	0f b6 88 f9 00
	00 00		 movzx	 ecx, BYTE PTR [eax+249]
  016c8	85 c9		 test	 ecx, ecx
  016ca	74 33		 je	 SHORT $LN282@InputTextE
  016cc	8b 55 dc	 mov	 edx, DWORD PTR _io$[ebp]
  016cf	0f b6 82 f8 00
	00 00		 movzx	 eax, BYTE PTR [edx+248]
  016d6	85 c0		 test	 eax, eax
  016d8	75 25		 jne	 SHORT $LN282@InputTextE
  016da	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  016dd	0f b6 91 fa 00
	00 00		 movzx	 edx, BYTE PTR [ecx+250]
  016e4	85 d2		 test	 edx, edx
  016e6	75 17		 jne	 SHORT $LN282@InputTextE
  016e8	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  016eb	0f b6 88 fb 00
	00 00		 movzx	 ecx, BYTE PTR [eax+251]
  016f2	85 c9		 test	 ecx, ecx
  016f4	75 09		 jne	 SHORT $LN282@InputTextE
  016f6	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv931[ebp], 1
  016fd	eb 07		 jmp	 SHORT $LN283@InputTextE
$LN282@InputTextE:
  016ff	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv931[ebp], 0
$LN283@InputTextE:
  01706	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv931[ebp]
  0170c	88 95 0b fd ff
	ff		 mov	 BYTE PTR _is_shift_key_only$80[ebp], dl

; 3682 : 
; 3683 :         const bool is_cut   = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());

  01712	0f b6 85 47 fd
	ff ff		 movzx	 eax, BYTE PTR _is_shortcut_key$85[ebp]
  01719	85 c0		 test	 eax, eax
  0171b	74 13		 je	 SHORT $LN284@InputTextE
  0171d	6a 01		 push	 1
  0171f	6a 13		 push	 19			; 00000013H
  01721	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01726	83 c4 08	 add	 esp, 8
  01729	0f b6 c8	 movzx	 ecx, al
  0172c	85 c9		 test	 ecx, ecx
  0172e	75 1e		 jne	 SHORT $LN286@InputTextE
$LN284@InputTextE:
  01730	0f b6 95 0b fd
	ff ff		 movzx	 edx, BYTE PTR _is_shift_key_only$80[ebp]
  01737	85 d2		 test	 edx, edx
  01739	74 46		 je	 SHORT $LN285@InputTextE
  0173b	6a 01		 push	 1
  0173d	6a 0a		 push	 10			; 0000000aH
  0173f	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01744	83 c4 08	 add	 esp, 8
  01747	0f b6 c0	 movzx	 eax, al
  0174a	85 c0		 test	 eax, eax
  0174c	74 33		 je	 SHORT $LN285@InputTextE
$LN286@InputTextE:
  0174e	0f b6 4d af	 movzx	 ecx, BYTE PTR _is_readonly$[ebp]
  01752	85 c9		 test	 ecx, ecx
  01754	75 2b		 jne	 SHORT $LN285@InputTextE
  01756	0f b6 55 a3	 movzx	 edx, BYTE PTR _is_password$[ebp]
  0175a	85 d2		 test	 edx, edx
  0175c	75 23		 jne	 SHORT $LN285@InputTextE
  0175e	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  01762	85 c0		 test	 eax, eax
  01764	74 12		 je	 SHORT $LN287@InputTextE
  01766	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0176c	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  01771	0f b6 c8	 movzx	 ecx, al
  01774	85 c9		 test	 ecx, ecx
  01776	74 09		 je	 SHORT $LN285@InputTextE
$LN287@InputTextE:
  01778	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv956[ebp], 1
  0177f	eb 07		 jmp	 SHORT $LN288@InputTextE
$LN285@InputTextE:
  01781	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv956[ebp], 0
$LN288@InputTextE:
  01788	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv956[ebp]
  0178e	88 95 ff fc ff
	ff		 mov	 BYTE PTR _is_cut$79[ebp], dl

; 3684 :         const bool is_copy  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || state->HasSelection());

  01794	0f b6 85 47 fd
	ff ff		 movzx	 eax, BYTE PTR _is_shortcut_key$85[ebp]
  0179b	85 c0		 test	 eax, eax
  0179d	74 13		 je	 SHORT $LN289@InputTextE
  0179f	6a 01		 push	 1
  017a1	6a 11		 push	 17			; 00000011H
  017a3	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  017a8	83 c4 08	 add	 esp, 8
  017ab	0f b6 c8	 movzx	 ecx, al
  017ae	85 c9		 test	 ecx, ecx
  017b0	75 1e		 jne	 SHORT $LN291@InputTextE
$LN289@InputTextE:
  017b2	0f b6 95 17 fd
	ff ff		 movzx	 edx, BYTE PTR _is_ctrl_key_only$81[ebp]
  017b9	85 d2		 test	 edx, edx
  017bb	74 3e		 je	 SHORT $LN290@InputTextE
  017bd	6a 01		 push	 1
  017bf	6a 09		 push	 9
  017c1	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  017c6	83 c4 08	 add	 esp, 8
  017c9	0f b6 c0	 movzx	 eax, al
  017cc	85 c0		 test	 eax, eax
  017ce	74 2b		 je	 SHORT $LN290@InputTextE
$LN291@InputTextE:
  017d0	0f b6 4d a3	 movzx	 ecx, BYTE PTR _is_password$[ebp]
  017d4	85 c9		 test	 ecx, ecx
  017d6	75 23		 jne	 SHORT $LN290@InputTextE
  017d8	0f b6 55 bb	 movzx	 edx, BYTE PTR _is_multiline$[ebp]
  017dc	85 d2		 test	 edx, edx
  017de	74 12		 je	 SHORT $LN292@InputTextE
  017e0	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  017e6	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  017eb	0f b6 c0	 movzx	 eax, al
  017ee	85 c0		 test	 eax, eax
  017f0	74 09		 je	 SHORT $LN290@InputTextE
$LN292@InputTextE:
  017f2	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv979[ebp], 1
  017f9	eb 07		 jmp	 SHORT $LN293@InputTextE
$LN290@InputTextE:
  017fb	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv979[ebp], 0
$LN293@InputTextE:
  01802	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv979[ebp]
  01808	88 8d f3 fc ff
	ff		 mov	 BYTE PTR _is_copy$78[ebp], cl

; 3685 :         const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && !is_readonly;

  0180e	0f b6 85 47 fd
	ff ff		 movzx	 eax, BYTE PTR _is_shortcut_key$85[ebp]
  01815	85 c0		 test	 eax, eax
  01817	74 13		 je	 SHORT $LN294@InputTextE
  01819	6a 01		 push	 1
  0181b	6a 12		 push	 18			; 00000012H
  0181d	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01822	83 c4 08	 add	 esp, 8
  01825	0f b6 c8	 movzx	 ecx, al
  01828	85 c9		 test	 ecx, ecx
  0182a	75 1e		 jne	 SHORT $LN296@InputTextE
$LN294@InputTextE:
  0182c	0f b6 95 0b fd
	ff ff		 movzx	 edx, BYTE PTR _is_shift_key_only$80[ebp]
  01833	85 d2		 test	 edx, edx
  01835	74 24		 je	 SHORT $LN295@InputTextE
  01837	6a 01		 push	 1
  01839	6a 09		 push	 9
  0183b	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01840	83 c4 08	 add	 esp, 8
  01843	0f b6 c0	 movzx	 eax, al
  01846	85 c0		 test	 eax, eax
  01848	74 11		 je	 SHORT $LN295@InputTextE
$LN296@InputTextE:
  0184a	0f b6 4d af	 movzx	 ecx, BYTE PTR _is_readonly$[ebp]
  0184e	85 c9		 test	 ecx, ecx
  01850	75 09		 jne	 SHORT $LN295@InputTextE
  01852	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv996[ebp], 1
  01859	eb 07		 jmp	 SHORT $LN297@InputTextE
$LN295@InputTextE:
  0185b	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv996[ebp], 0
$LN297@InputTextE:
  01862	8a 95 2b f4 ff
	ff		 mov	 dl, BYTE PTR tv996[ebp]
  01868	88 95 e7 fc ff
	ff		 mov	 BYTE PTR _is_paste$77[ebp], dl

; 3686 :         const bool is_undo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && !is_readonly && is_undoable);

  0186e	0f b6 85 47 fd
	ff ff		 movzx	 eax, BYTE PTR _is_shortcut_key$85[ebp]
  01875	85 c0		 test	 eax, eax
  01877	74 2c		 je	 SHORT $LN298@InputTextE
  01879	6a 01		 push	 1
  0187b	6a 15		 push	 21			; 00000015H
  0187d	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01882	83 c4 08	 add	 esp, 8
  01885	0f b6 c8	 movzx	 ecx, al
  01888	85 c9		 test	 ecx, ecx
  0188a	74 19		 je	 SHORT $LN298@InputTextE
  0188c	0f b6 55 af	 movzx	 edx, BYTE PTR _is_readonly$[ebp]
  01890	85 d2		 test	 edx, edx
  01892	75 11		 jne	 SHORT $LN298@InputTextE
  01894	0f b6 45 97	 movzx	 eax, BYTE PTR _is_undoable$[ebp]
  01898	85 c0		 test	 eax, eax
  0189a	74 09		 je	 SHORT $LN298@InputTextE
  0189c	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv1008[ebp], 1
  018a3	eb 07		 jmp	 SHORT $LN299@InputTextE
$LN298@InputTextE:
  018a5	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv1008[ebp], 0
$LN299@InputTextE:
  018ac	8a 8d 2b f4 ff
	ff		 mov	 cl, BYTE PTR tv1008[ebp]
  018b2	88 8d db fc ff
	ff		 mov	 BYTE PTR _is_undo$76[ebp], cl

; 3687 :         const bool is_redo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && !is_readonly && is_undoable;

  018b8	0f b6 85 47 fd
	ff ff		 movzx	 eax, BYTE PTR _is_shortcut_key$85[ebp]
  018bf	85 c0		 test	 eax, eax
  018c1	74 13		 je	 SHORT $LN300@InputTextE
  018c3	6a 01		 push	 1
  018c5	6a 14		 push	 20			; 00000014H
  018c7	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  018cc	83 c4 08	 add	 esp, 8
  018cf	0f b6 c8	 movzx	 ecx, al
  018d2	85 c9		 test	 ecx, ecx
  018d4	75 1e		 jne	 SHORT $LN302@InputTextE
$LN300@InputTextE:
  018d6	0f b6 95 3b fd
	ff ff		 movzx	 edx, BYTE PTR _is_osx_shift_shortcut$84[ebp]
  018dd	85 d2		 test	 edx, edx
  018df	74 2c		 je	 SHORT $LN301@InputTextE
  018e1	6a 01		 push	 1
  018e3	6a 15		 push	 21			; 00000015H
  018e5	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  018ea	83 c4 08	 add	 esp, 8
  018ed	0f b6 c0	 movzx	 eax, al
  018f0	85 c0		 test	 eax, eax
  018f2	74 19		 je	 SHORT $LN301@InputTextE
$LN302@InputTextE:
  018f4	0f b6 4d af	 movzx	 ecx, BYTE PTR _is_readonly$[ebp]
  018f8	85 c9		 test	 ecx, ecx
  018fa	75 11		 jne	 SHORT $LN301@InputTextE
  018fc	0f b6 55 97	 movzx	 edx, BYTE PTR _is_undoable$[ebp]
  01900	85 d2		 test	 edx, edx
  01902	74 09		 je	 SHORT $LN301@InputTextE
  01904	c6 85 2b f4 ff
	ff 01		 mov	 BYTE PTR tv1027[ebp], 1
  0190b	eb 07		 jmp	 SHORT $LN303@InputTextE
$LN301@InputTextE:
  0190d	c6 85 2b f4 ff
	ff 00		 mov	 BYTE PTR tv1027[ebp], 0
$LN303@InputTextE:
  01914	8a 85 2b f4 ff
	ff		 mov	 al, BYTE PTR tv1027[ebp]
  0191a	88 85 cf fc ff
	ff		 mov	 BYTE PTR _is_redo$75[ebp], al

; 3688 : 
; 3689 :         if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }

  01920	6a 01		 push	 1
  01922	6a 01		 push	 1
  01924	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01929	83 c4 08	 add	 esp, 8
  0192c	0f b6 c0	 movzx	 eax, al
  0192f	85 c0		 test	 eax, eax
  01931	74 61		 je	 SHORT $LN66@InputTextE
  01933	0f b6 85 23 fd
	ff ff		 movzx	 eax, BYTE PTR _is_startend_key_down$82[ebp]
  0193a	85 c0		 test	 eax, eax
  0193c	74 0c		 je	 SHORT $LN306@InputTextE
  0193e	c7 85 28 f4 ff
	ff 04 00 20 00	 mov	 DWORD PTR tv1039[ebp], 2097156 ; 00200004H
  01948	eb 2d		 jmp	 SHORT $LN307@InputTextE
$LN306@InputTextE:
  0194a	0f b6 8d 2f fd
	ff ff		 movzx	 ecx, BYTE PTR _is_wordmove_key_down$83[ebp]
  01951	85 c9		 test	 ecx, ecx
  01953	74 0c		 je	 SHORT $LN304@InputTextE
  01955	c7 85 24 f4 ff
	ff 0c 00 20 00	 mov	 DWORD PTR tv1036[ebp], 2097164 ; 0020000cH
  0195f	eb 0a		 jmp	 SHORT $LN305@InputTextE
$LN304@InputTextE:
  01961	c7 85 24 f4 ff
	ff 00 00 20 00	 mov	 DWORD PTR tv1036[ebp], 2097152 ; 00200000H
$LN305@InputTextE:
  0196b	8b 95 24 f4 ff
	ff		 mov	 edx, DWORD PTR tv1036[ebp]
  01971	89 95 28 f4 ff
	ff		 mov	 DWORD PTR tv1039[ebp], edx
$LN307@InputTextE:
  01977	8b 85 28 f4 ff
	ff		 mov	 eax, DWORD PTR tv1039[ebp]
  0197d	0b 85 5c fd ff
	ff		 or	 eax, DWORD PTR _k_mask$87[ebp]
  01983	50		 push	 eax
  01984	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0198a	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
  0198f	e9 3b 08 00 00	 jmp	 $LN113@InputTextE
$LN66@InputTextE:

; 3690 :         else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }

  01994	6a 01		 push	 1
  01996	6a 02		 push	 2
  01998	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  0199d	83 c4 08	 add	 esp, 8
  019a0	0f b6 c0	 movzx	 eax, al
  019a3	85 c0		 test	 eax, eax
  019a5	74 61		 je	 SHORT $LN68@InputTextE
  019a7	0f b6 85 23 fd
	ff ff		 movzx	 eax, BYTE PTR _is_startend_key_down$82[ebp]
  019ae	85 c0		 test	 eax, eax
  019b0	74 0c		 je	 SHORT $LN310@InputTextE
  019b2	c7 85 28 f4 ff
	ff 05 00 20 00	 mov	 DWORD PTR tv1053[ebp], 2097157 ; 00200005H
  019bc	eb 2d		 jmp	 SHORT $LN311@InputTextE
$LN310@InputTextE:
  019be	0f b6 8d 2f fd
	ff ff		 movzx	 ecx, BYTE PTR _is_wordmove_key_down$83[ebp]
  019c5	85 c9		 test	 ecx, ecx
  019c7	74 0c		 je	 SHORT $LN308@InputTextE
  019c9	c7 85 24 f4 ff
	ff 0d 00 20 00	 mov	 DWORD PTR tv1050[ebp], 2097165 ; 0020000dH
  019d3	eb 0a		 jmp	 SHORT $LN309@InputTextE
$LN308@InputTextE:
  019d5	c7 85 24 f4 ff
	ff 01 00 20 00	 mov	 DWORD PTR tv1050[ebp], 2097153 ; 00200001H
$LN309@InputTextE:
  019df	8b 95 24 f4 ff
	ff		 mov	 edx, DWORD PTR tv1050[ebp]
  019e5	89 95 28 f4 ff
	ff		 mov	 DWORD PTR tv1053[ebp], edx
$LN311@InputTextE:
  019eb	8b 85 28 f4 ff
	ff		 mov	 eax, DWORD PTR tv1053[ebp]
  019f1	0b 85 5c fd ff
	ff		 or	 eax, DWORD PTR _k_mask$87[ebp]
  019f7	50		 push	 eax
  019f8	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  019fe	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
  01a03	e9 c7 07 00 00	 jmp	 $LN113@InputTextE
$LN68@InputTextE:

; 3691 :         else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }

  01a08	6a 01		 push	 1
  01a0a	6a 03		 push	 3
  01a0c	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01a11	83 c4 08	 add	 esp, 8
  01a14	0f b6 c0	 movzx	 eax, al
  01a17	85 c0		 test	 eax, eax
  01a19	0f 84 99 00 00
	00		 je	 $LN70@InputTextE
  01a1f	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  01a23	85 c0		 test	 eax, eax
  01a25	0f 84 8d 00 00
	00		 je	 $LN70@InputTextE
  01a2b	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01a2e	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01a35	85 c9		 test	 ecx, ecx
  01a37	74 41		 je	 SHORT $LN72@InputTextE
  01a39	51		 push	 ecx
  01a3a	0f 57 c0	 xorps	 xmm0, xmm0
  01a3d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a42	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  01a48	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  01a4b	f3 0f 10 40 54	 movss	 xmm0, DWORD PTR [eax+84]
  01a50	f3 0f 5c 81 c4
	18 00 00	 subss	 xmm0, DWORD PTR [ecx+6340]
  01a58	51		 push	 ecx
  01a59	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a5e	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  01a63	83 c4 04	 add	 esp, 4
  01a66	d9 1c 24	 fstp	 DWORD PTR [esp]
  01a69	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _draw_window$[ebp]
  01a6f	52		 push	 edx
  01a70	e8 00 00 00 00	 call	 ?SetScrollY@ImGui@@YAXPAUImGuiWindow@@M@Z ; ImGui::SetScrollY
  01a75	83 c4 08	 add	 esp, 8
  01a78	eb 39		 jmp	 SHORT $LN73@InputTextE
$LN72@InputTextE:
  01a7a	0f b6 85 23 fd
	ff ff		 movzx	 eax, BYTE PTR _is_startend_key_down$82[ebp]
  01a81	85 c0		 test	 eax, eax
  01a83	74 0c		 je	 SHORT $LN312@InputTextE
  01a85	c7 85 28 f4 ff
	ff 06 00 20 00	 mov	 DWORD PTR tv1078[ebp], 2097158 ; 00200006H
  01a8f	eb 0a		 jmp	 SHORT $LN313@InputTextE
$LN312@InputTextE:
  01a91	c7 85 28 f4 ff
	ff 02 00 20 00	 mov	 DWORD PTR tv1078[ebp], 2097154 ; 00200002H
$LN313@InputTextE:
  01a9b	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv1078[ebp]
  01aa1	0b 8d 5c fd ff
	ff		 or	 ecx, DWORD PTR _k_mask$87[ebp]
  01aa7	51		 push	 ecx
  01aa8	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01aae	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
$LN73@InputTextE:
  01ab3	e9 17 07 00 00	 jmp	 $LN113@InputTextE
$LN70@InputTextE:

; 3692 :         else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }

  01ab8	6a 01		 push	 1
  01aba	6a 04		 push	 4
  01abc	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01ac1	83 c4 08	 add	 esp, 8
  01ac4	0f b6 c0	 movzx	 eax, al
  01ac7	85 c0		 test	 eax, eax
  01ac9	0f 84 99 00 00
	00		 je	 $LN74@InputTextE
  01acf	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  01ad3	85 c0		 test	 eax, eax
  01ad5	0f 84 8d 00 00
	00		 je	 $LN74@InputTextE
  01adb	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01ade	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01ae5	85 c9		 test	 ecx, ecx
  01ae7	74 41		 je	 SHORT $LN76@InputTextE
  01ae9	e8 00 00 00 00	 call	 ?GetScrollMaxY@ImGui@@YAMXZ ; ImGui::GetScrollMaxY
  01aee	51		 push	 ecx
  01aef	d9 1c 24	 fstp	 DWORD PTR [esp]
  01af2	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  01af8	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  01afb	f3 0f 10 40 54	 movss	 xmm0, DWORD PTR [eax+84]
  01b00	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  01b08	51		 push	 ecx
  01b09	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01b0e	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  01b13	83 c4 04	 add	 esp, 4
  01b16	d9 1c 24	 fstp	 DWORD PTR [esp]
  01b19	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _draw_window$[ebp]
  01b1f	52		 push	 edx
  01b20	e8 00 00 00 00	 call	 ?SetScrollY@ImGui@@YAXPAUImGuiWindow@@M@Z ; ImGui::SetScrollY
  01b25	83 c4 08	 add	 esp, 8
  01b28	eb 39		 jmp	 SHORT $LN77@InputTextE
$LN76@InputTextE:
  01b2a	0f b6 85 23 fd
	ff ff		 movzx	 eax, BYTE PTR _is_startend_key_down$82[ebp]
  01b31	85 c0		 test	 eax, eax
  01b33	74 0c		 je	 SHORT $LN314@InputTextE
  01b35	c7 85 28 f4 ff
	ff 07 00 20 00	 mov	 DWORD PTR tv1104[ebp], 2097159 ; 00200007H
  01b3f	eb 0a		 jmp	 SHORT $LN315@InputTextE
$LN314@InputTextE:
  01b41	c7 85 28 f4 ff
	ff 03 00 20 00	 mov	 DWORD PTR tv1104[ebp], 2097155 ; 00200003H
$LN315@InputTextE:
  01b4b	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv1104[ebp]
  01b51	0b 8d 5c fd ff
	ff		 or	 ecx, DWORD PTR _k_mask$87[ebp]
  01b57	51		 push	 ecx
  01b58	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01b5e	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
$LN77@InputTextE:
  01b63	e9 67 06 00 00	 jmp	 $LN113@InputTextE
$LN74@InputTextE:

; 3693 :         else if (IsKeyPressedMap(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }

  01b68	6a 01		 push	 1
  01b6a	6a 07		 push	 7
  01b6c	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01b71	83 c4 08	 add	 esp, 8
  01b74	0f b6 c0	 movzx	 eax, al
  01b77	85 c0		 test	 eax, eax
  01b79	74 4a		 je	 SHORT $LN78@InputTextE
  01b7b	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01b7e	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01b85	85 c9		 test	 ecx, ecx
  01b87	74 14		 je	 SHORT $LN316@InputTextE
  01b89	8b 95 5c fd ff
	ff		 mov	 edx, DWORD PTR _k_mask$87[ebp]
  01b8f	81 ca 06 00 20
	00		 or	 edx, 2097158		; 00200006H
  01b95	89 95 28 f4 ff
	ff		 mov	 DWORD PTR tv1118[ebp], edx
  01b9b	eb 11		 jmp	 SHORT $LN317@InputTextE
$LN316@InputTextE:
  01b9d	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _k_mask$87[ebp]
  01ba3	0d 04 00 20 00	 or	 eax, 2097156		; 00200004H
  01ba8	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv1118[ebp], eax
$LN317@InputTextE:
  01bae	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv1118[ebp]
  01bb4	51		 push	 ecx
  01bb5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01bbb	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
  01bc0	e9 0a 06 00 00	 jmp	 $LN113@InputTextE
$LN78@InputTextE:

; 3694 :         else if (IsKeyPressedMap(ImGuiKey_End))                         { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }

  01bc5	6a 01		 push	 1
  01bc7	6a 08		 push	 8
  01bc9	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01bce	83 c4 08	 add	 esp, 8
  01bd1	0f b6 c0	 movzx	 eax, al
  01bd4	85 c0		 test	 eax, eax
  01bd6	74 4a		 je	 SHORT $LN80@InputTextE
  01bd8	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01bdb	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01be2	85 c9		 test	 ecx, ecx
  01be4	74 14		 je	 SHORT $LN318@InputTextE
  01be6	8b 95 5c fd ff
	ff		 mov	 edx, DWORD PTR _k_mask$87[ebp]
  01bec	81 ca 07 00 20
	00		 or	 edx, 2097159		; 00200007H
  01bf2	89 95 28 f4 ff
	ff		 mov	 DWORD PTR tv1131[ebp], edx
  01bf8	eb 11		 jmp	 SHORT $LN319@InputTextE
$LN318@InputTextE:
  01bfa	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _k_mask$87[ebp]
  01c00	0d 05 00 20 00	 or	 eax, 2097157		; 00200005H
  01c05	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv1131[ebp], eax
$LN319@InputTextE:
  01c0b	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv1131[ebp]
  01c11	51		 push	 ecx
  01c12	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01c18	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
  01c1d	e9 ad 05 00 00	 jmp	 $LN113@InputTextE
$LN80@InputTextE:

; 3695 :         else if (IsKeyPressedMap(ImGuiKey_Delete) && !is_readonly)      { state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }

  01c22	6a 01		 push	 1
  01c24	6a 0a		 push	 10			; 0000000aH
  01c26	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01c2b	83 c4 08	 add	 esp, 8
  01c2e	0f b6 c0	 movzx	 eax, al
  01c31	85 c0		 test	 eax, eax
  01c33	74 24		 je	 SHORT $LN82@InputTextE
  01c35	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  01c39	85 c0		 test	 eax, eax
  01c3b	75 1c		 jne	 SHORT $LN82@InputTextE
  01c3d	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _k_mask$87[ebp]
  01c43	0d 08 00 20 00	 or	 eax, 2097160		; 00200008H
  01c48	50		 push	 eax
  01c49	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01c4f	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
  01c54	e9 76 05 00 00	 jmp	 $LN113@InputTextE
$LN82@InputTextE:

; 3696 :         else if (IsKeyPressedMap(ImGuiKey_Backspace) && !is_readonly)

  01c59	6a 01		 push	 1
  01c5b	6a 0b		 push	 11			; 0000000bH
  01c5d	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01c62	83 c4 08	 add	 esp, 8
  01c65	0f b6 c0	 movzx	 eax, al
  01c68	85 c0		 test	 eax, eax
  01c6a	0f 84 9c 00 00
	00		 je	 $LN84@InputTextE
  01c70	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  01c74	85 c0		 test	 eax, eax
  01c76	0f 85 90 00 00
	00		 jne	 $LN84@InputTextE

; 3697 :         {
; 3698 :             if (!state->HasSelection())

  01c7c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01c82	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  01c87	0f b6 c0	 movzx	 eax, al
  01c8a	85 c0		 test	 eax, eax
  01c8c	75 62		 jne	 SHORT $LN89@InputTextE

; 3699 :             {
; 3700 :                 if (is_wordmove_key_down)

  01c8e	0f b6 85 2f fd
	ff ff		 movzx	 eax, BYTE PTR _is_wordmove_key_down$83[ebp]
  01c95	85 c0		 test	 eax, eax
  01c97	74 12		 je	 SHORT $LN87@InputTextE

; 3701 :                     state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);

  01c99	68 0c 00 60 00	 push	 6291468			; 0060000cH
  01c9e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01ca4	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
  01ca9	eb 45		 jmp	 SHORT $LN89@InputTextE
$LN87@InputTextE:

; 3702 :                 else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl)

  01cab	0f b6 85 53 fd
	ff ff		 movzx	 eax, BYTE PTR _is_osx$86[ebp]
  01cb2	85 c0		 test	 eax, eax
  01cb4	74 3a		 je	 SHORT $LN89@InputTextE
  01cb6	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01cb9	0f b6 88 fb 00
	00 00		 movzx	 ecx, BYTE PTR [eax+251]
  01cc0	85 c9		 test	 ecx, ecx
  01cc2	74 2c		 je	 SHORT $LN89@InputTextE
  01cc4	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01cc7	0f b6 88 fa 00
	00 00		 movzx	 ecx, BYTE PTR [eax+250]
  01cce	85 c9		 test	 ecx, ecx
  01cd0	75 1e		 jne	 SHORT $LN89@InputTextE
  01cd2	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01cd5	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01cdc	85 c9		 test	 ecx, ecx
  01cde	75 10		 jne	 SHORT $LN89@InputTextE

; 3703 :                     state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);

  01ce0	68 04 00 60 00	 push	 6291460			; 00600004H
  01ce5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01ceb	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
$LN89@InputTextE:

; 3704 :             }
; 3705 :             state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);

  01cf0	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _k_mask$87[ebp]
  01cf6	0d 09 00 20 00	 or	 eax, 2097161		; 00200009H
  01cfb	50		 push	 eax
  01cfc	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01d02	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed

; 3706 :         }

  01d07	e9 c3 04 00 00	 jmp	 $LN113@InputTextE
$LN84@InputTextE:

; 3707 :         else if (IsKeyPressedMap(ImGuiKey_Enter) || IsKeyPressedMap(ImGuiKey_KeyPadEnter))

  01d0c	6a 01		 push	 1
  01d0e	6a 0d		 push	 13			; 0000000dH
  01d10	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01d15	83 c4 08	 add	 esp, 8
  01d18	0f b6 c0	 movzx	 eax, al
  01d1b	85 c0		 test	 eax, eax
  01d1d	75 17		 jne	 SHORT $LN92@InputTextE
  01d1f	6a 01		 push	 1
  01d21	6a 0f		 push	 15			; 0000000fH
  01d23	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01d28	83 c4 08	 add	 esp, 8
  01d2b	0f b6 c0	 movzx	 eax, al
  01d2e	85 c0		 test	 eax, eax
  01d30	0f 84 c6 00 00
	00		 je	 $LN90@InputTextE
$LN92@InputTextE:

; 3708 :         {
; 3709 :             bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;

  01d36	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  01d39	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  01d3e	74 0c		 je	 SHORT $LN320@InputTextE
  01d40	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1186[ebp], 1
  01d4a	eb 0a		 jmp	 SHORT $LN321@InputTextE
$LN320@InputTextE:
  01d4c	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1186[ebp], 0
$LN321@InputTextE:
  01d56	8a 8d 28 f4 ff
	ff		 mov	 cl, BYTE PTR tv1186[ebp]
  01d5c	88 8d c3 fc ff
	ff		 mov	 BYTE PTR _ctrl_enter_for_new_line$74[ebp], cl

; 3710 :             if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))

  01d62	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  01d66	85 c0		 test	 eax, eax
  01d68	74 32		 je	 SHORT $LN95@InputTextE
  01d6a	0f b6 85 c3 fc
	ff ff		 movzx	 eax, BYTE PTR _ctrl_enter_for_new_line$74[ebp]
  01d71	85 c0		 test	 eax, eax
  01d73	74 0e		 je	 SHORT $LN96@InputTextE
  01d75	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01d78	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01d7f	85 c9		 test	 ecx, ecx
  01d81	74 19		 je	 SHORT $LN95@InputTextE
$LN96@InputTextE:
  01d83	0f b6 85 c3 fc
	ff ff		 movzx	 eax, BYTE PTR _ctrl_enter_for_new_line$74[ebp]
  01d8a	85 c0		 test	 eax, eax
  01d8c	75 23		 jne	 SHORT $LN93@InputTextE
  01d8e	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01d91	0f b6 88 f8 00
	00 00		 movzx	 ecx, BYTE PTR [eax+248]
  01d98	85 c9		 test	 ecx, ecx
  01d9a	74 15		 je	 SHORT $LN93@InputTextE
$LN95@InputTextE:

; 3711 :             {
; 3712 :                 enter_pressed = clear_active_id = true;

  01d9c	c6 85 8b fe ff
	ff 01		 mov	 BYTE PTR _clear_active_id$[ebp], 1
  01da3	8a 85 8b fe ff
	ff		 mov	 al, BYTE PTR _clear_active_id$[ebp]
  01da9	88 85 13 fe ff
	ff		 mov	 BYTE PTR _enter_pressed$[ebp], al

; 3713 :             }

  01daf	eb 46		 jmp	 SHORT $LN98@InputTextE
$LN93@InputTextE:

; 3714 :             else if (!is_readonly)

  01db1	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  01db5	85 c0		 test	 eax, eax
  01db7	75 3e		 jne	 SHORT $LN98@InputTextE

; 3715 :             {
; 3716 :                 unsigned int c = '\n'; // Insert new line

  01db9	c7 85 b4 fc ff
	ff 0a 00 00 00	 mov	 DWORD PTR _c$73[ebp], 10 ; 0000000aH

; 3717 :                 if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))

  01dc3	8b 45 24	 mov	 eax, DWORD PTR _callback_user_data$[ebp]
  01dc6	50		 push	 eax
  01dc7	8b 4d 20	 mov	 ecx, DWORD PTR _callback$[ebp]
  01dca	51		 push	 ecx
  01dcb	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  01dce	52		 push	 edx
  01dcf	8d 85 b4 fc ff
	ff		 lea	 eax, DWORD PTR _c$73[ebp]
  01dd5	50		 push	 eax
  01dd6	e8 00 00 00 00	 call	 ?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
  01ddb	83 c4 10	 add	 esp, 16			; 00000010H
  01dde	0f b6 c8	 movzx	 ecx, al
  01de1	85 c9		 test	 ecx, ecx
  01de3	74 12		 je	 SHORT $LN98@InputTextE

; 3718 :                     state->OnKeyPressed((int)c);

  01de5	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _c$73[ebp]
  01deb	50		 push	 eax
  01dec	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01df2	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed
$LN98@InputTextE:

; 3719 :             }
; 3720 :         }

  01df7	e9 d3 03 00 00	 jmp	 $LN113@InputTextE
$LN90@InputTextE:

; 3721 :         else if (IsKeyPressedMap(ImGuiKey_Escape))

  01dfc	6a 01		 push	 1
  01dfe	6a 0e		 push	 14			; 0000000eH
  01e00	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01e05	83 c4 08	 add	 esp, 8
  01e08	0f b6 c0	 movzx	 eax, al
  01e0b	85 c0		 test	 eax, eax
  01e0d	74 18		 je	 SHORT $LN99@InputTextE

; 3722 :         {
; 3723 :             clear_active_id = cancel_edit = true;

  01e0f	c6 85 6b fd ff
	ff 01		 mov	 BYTE PTR _cancel_edit$[ebp], 1
  01e16	8a 85 6b fd ff
	ff		 mov	 al, BYTE PTR _cancel_edit$[ebp]
  01e1c	88 85 8b fe ff
	ff		 mov	 BYTE PTR _clear_active_id$[ebp], al

; 3724 :         }

  01e22	e9 a8 03 00 00	 jmp	 $LN113@InputTextE
$LN99@InputTextE:

; 3725 :         else if (is_undo || is_redo)

  01e27	0f b6 85 db fc
	ff ff		 movzx	 eax, BYTE PTR _is_undo$76[ebp]
  01e2e	85 c0		 test	 eax, eax
  01e30	75 0b		 jne	 SHORT $LN103@InputTextE
  01e32	0f b6 85 cf fc
	ff ff		 movzx	 eax, BYTE PTR _is_redo$75[ebp]
  01e39	85 c0		 test	 eax, eax
  01e3b	74 43		 je	 SHORT $LN101@InputTextE
$LN103@InputTextE:

; 3726 :         {
; 3727 :             state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);

  01e3d	0f b6 85 db fc
	ff ff		 movzx	 eax, BYTE PTR _is_undo$76[ebp]
  01e44	85 c0		 test	 eax, eax
  01e46	74 0c		 je	 SHORT $LN322@InputTextE
  01e48	c7 85 28 f4 ff
	ff 0a 00 20 00	 mov	 DWORD PTR tv1223[ebp], 2097162 ; 0020000aH
  01e52	eb 0a		 jmp	 SHORT $LN323@InputTextE
$LN322@InputTextE:
  01e54	c7 85 28 f4 ff
	ff 0b 00 20 00	 mov	 DWORD PTR tv1223[ebp], 2097163 ; 0020000bH
$LN323@InputTextE:
  01e5e	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv1223[ebp]
  01e64	51		 push	 ecx
  01e65	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01e6b	e8 00 00 00 00	 call	 ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ; ImGuiInputTextState::OnKeyPressed

; 3728 :             state->ClearSelection();

  01e70	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01e76	e8 00 00 00 00	 call	 ?ClearSelection@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::ClearSelection

; 3729 :         }

  01e7b	e9 4f 03 00 00	 jmp	 $LN113@InputTextE
$LN101@InputTextE:

; 3730 :         else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))

  01e80	0f b6 85 47 fd
	ff ff		 movzx	 eax, BYTE PTR _is_shortcut_key$85[ebp]
  01e87	85 c0		 test	 eax, eax
  01e89	74 30		 je	 SHORT $LN104@InputTextE
  01e8b	6a 01		 push	 1
  01e8d	6a 10		 push	 16			; 00000010H
  01e8f	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  01e94	83 c4 08	 add	 esp, 8
  01e97	0f b6 c0	 movzx	 eax, al
  01e9a	85 c0		 test	 eax, eax
  01e9c	74 1d		 je	 SHORT $LN104@InputTextE

; 3731 :         {
; 3732 :             state->SelectAll();

  01e9e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01ea4	e8 00 00 00 00	 call	 ?SelectAll@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::SelectAll

; 3733 :             state->CursorFollow = true;

  01ea9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01eaf	c6 80 64 0e 00
	00 01		 mov	 BYTE PTR [eax+3684], 1

; 3734 :         }

  01eb6	e9 14 03 00 00	 jmp	 $LN113@InputTextE
$LN104@InputTextE:

; 3735 :         else if (is_cut || is_copy)

  01ebb	0f b6 85 ff fc
	ff ff		 movzx	 eax, BYTE PTR _is_cut$79[ebp]
  01ec2	85 c0		 test	 eax, eax
  01ec4	75 0f		 jne	 SHORT $LN108@InputTextE
  01ec6	0f b6 85 f3 fc
	ff ff		 movzx	 eax, BYTE PTR _is_copy$78[ebp]
  01ecd	85 c0		 test	 eax, eax
  01ecf	0f 84 a6 01 00
	00		 je	 $LN106@InputTextE
$LN108@InputTextE:

; 3736 :         {
; 3737 :             // Cut, Copy
; 3738 :             if (io.SetClipboardTextFn)

  01ed5	8b 45 dc	 mov	 eax, DWORD PTR _io$[ebp]
  01ed8	83 b8 cc 00 00
	00 00		 cmp	 DWORD PTR [eax+204], 0
  01edf	0f 84 43 01 00
	00		 je	 $LN109@InputTextE

; 3739 :             {
; 3740 :                 const int ib = state->HasSelection() ? ImMin(state->Stb.select_start, state->Stb.select_end) : 0;

  01ee5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01eeb	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  01ef0	0f b6 c0	 movzx	 eax, al
  01ef3	85 c0		 test	 eax, eax
  01ef5	74 24		 je	 SHORT $LN324@InputTextE
  01ef7	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01efd	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01f00	52		 push	 edx
  01f01	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01f07	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01f0a	51		 push	 ecx
  01f0b	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  01f10	83 c4 08	 add	 esp, 8
  01f13	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv1252[ebp], eax
  01f19	eb 0a		 jmp	 SHORT $LN325@InputTextE
$LN324@InputTextE:
  01f1b	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1252[ebp], 0
$LN325@InputTextE:
  01f25	8b 95 28 f4 ff
	ff		 mov	 edx, DWORD PTR tv1252[ebp]
  01f2b	89 95 a8 fc ff
	ff		 mov	 DWORD PTR _ib$72[ebp], edx

; 3741 :                 const int ie = state->HasSelection() ? ImMax(state->Stb.select_start, state->Stb.select_end) : state->CurLenW;

  01f31	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01f37	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  01f3c	0f b6 c0	 movzx	 eax, al
  01f3f	85 c0		 test	 eax, eax
  01f41	74 24		 je	 SHORT $LN326@InputTextE
  01f43	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01f49	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01f4c	52		 push	 edx
  01f4d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01f53	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01f56	51		 push	 ecx
  01f57	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  01f5c	83 c4 08	 add	 esp, 8
  01f5f	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv1265[ebp], eax
  01f65	eb 0f		 jmp	 SHORT $LN327@InputTextE
$LN326@InputTextE:
  01f67	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  01f6d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01f70	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv1265[ebp], eax
$LN327@InputTextE:
  01f76	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv1265[ebp]
  01f7c	89 8d 9c fc ff
	ff		 mov	 DWORD PTR _ie$71[ebp], ecx

; 3742 :                 const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state->TextW.Data + ib, state->TextW.Data + ie) + 1;

  01f82	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01f88	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01f8b	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _ie$71[ebp]
  01f91	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  01f94	50		 push	 eax
  01f95	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01f9b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01f9e	8b 85 a8 fc ff
	ff		 mov	 eax, DWORD PTR _ib$72[ebp]
  01fa4	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  01fa7	51		 push	 ecx
  01fa8	e8 00 00 00 00	 call	 ?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z ; ImTextCountUtf8BytesFromStr
  01fad	83 c4 08	 add	 esp, 8
  01fb0	83 c0 01	 add	 eax, 1
  01fb3	89 85 90 fc ff
	ff		 mov	 DWORD PTR _clipboard_data_len$70[ebp], eax

; 3743 :                 char* clipboard_data = (char*)IM_ALLOC(clipboard_data_len * sizeof(char));

  01fb9	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_data_len$70[ebp]
  01fbf	50		 push	 eax
  01fc0	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  01fc5	83 c4 04	 add	 esp, 4
  01fc8	89 85 84 fc ff
	ff		 mov	 DWORD PTR _clipboard_data$69[ebp], eax

; 3744 :                 ImTextStrToUtf8(clipboard_data, clipboard_data_len, state->TextW.Data + ib, state->TextW.Data + ie);

  01fce	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  01fd4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01fd7	8b 95 9c fc ff
	ff		 mov	 edx, DWORD PTR _ie$71[ebp]
  01fdd	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  01fe0	50		 push	 eax
  01fe1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  01fe7	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01fea	8b 85 a8 fc ff
	ff		 mov	 eax, DWORD PTR _ib$72[ebp]
  01ff0	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  01ff3	51		 push	 ecx
  01ff4	8b 95 90 fc ff
	ff		 mov	 edx, DWORD PTR _clipboard_data_len$70[ebp]
  01ffa	52		 push	 edx
  01ffb	8b 85 84 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_data$69[ebp]
  02001	50		 push	 eax
  02002	e8 00 00 00 00	 call	 ?ImTextStrToUtf8@@YAHPADHPBG1@Z ; ImTextStrToUtf8
  02007	83 c4 10	 add	 esp, 16			; 00000010H

; 3745 :                 SetClipboardText(clipboard_data);

  0200a	8b 85 84 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_data$69[ebp]
  02010	50		 push	 eax
  02011	e8 00 00 00 00	 call	 ?SetClipboardText@ImGui@@YAXPBD@Z ; ImGui::SetClipboardText
  02016	83 c4 04	 add	 esp, 4

; 3746 :                 MemFree(clipboard_data);

  02019	8b 85 84 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_data$69[ebp]
  0201f	50		 push	 eax
  02020	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  02025	83 c4 04	 add	 esp, 4
$LN109@InputTextE:

; 3747 :             }
; 3748 :             if (is_cut)

  02028	0f b6 85 ff fc
	ff ff		 movzx	 eax, BYTE PTR _is_cut$79[ebp]
  0202f	85 c0		 test	 eax, eax
  02031	74 43		 je	 SHORT $LN110@InputTextE

; 3749 :             {
; 3750 :                 if (!state->HasSelection())

  02033	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  02039	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  0203e	0f b6 c0	 movzx	 eax, al
  02041	85 c0		 test	 eax, eax
  02043	75 0b		 jne	 SHORT $LN111@InputTextE

; 3751 :                     state->SelectAll();

  02045	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0204b	e8 00 00 00 00	 call	 ?SelectAll@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::SelectAll
$LN111@InputTextE:

; 3752 :                 state->CursorFollow = true;

  02050	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02056	c6 80 64 0e 00
	00 01		 mov	 BYTE PTR [eax+3684], 1

; 3753 :                 stb_textedit_cut(state, &state->Stb);

  0205d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02063	83 c0 3c	 add	 eax, 60			; 0000003cH
  02066	50		 push	 eax
  02067	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0206d	51		 push	 ecx
  0206e	e8 00 00 00 00	 call	 ?stb_textedit_cut@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_cut
  02073	83 c4 08	 add	 esp, 8
$LN110@InputTextE:

; 3754 :             }
; 3755 :         }

  02076	e9 54 01 00 00	 jmp	 $LN113@InputTextE
$LN106@InputTextE:

; 3756 :         else if (is_paste)

  0207b	0f b6 85 e7 fc
	ff ff		 movzx	 eax, BYTE PTR _is_paste$77[ebp]
  02082	85 c0		 test	 eax, eax
  02084	0f 84 45 01 00
	00		 je	 $LN113@InputTextE

; 3757 :         {
; 3758 :             if (const char* clipboard = GetClipboardText())

  0208a	e8 00 00 00 00	 call	 ?GetClipboardText@ImGui@@YAPBDXZ ; ImGui::GetClipboardText
  0208f	89 85 78 fc ff
	ff		 mov	 DWORD PTR _clipboard$68[ebp], eax
  02095	83 bd 78 fc ff
	ff 00		 cmp	 DWORD PTR _clipboard$68[ebp], 0
  0209c	0f 84 2d 01 00
	00		 je	 $LN113@InputTextE

; 3759 :             {
; 3760 :                 // Filter pasted buffer
; 3761 :                 const int clipboard_len = (int)strlen(clipboard);

  020a2	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard$68[ebp]
  020a8	50		 push	 eax
  020a9	e8 00 00 00 00	 call	 _strlen
  020ae	83 c4 04	 add	 esp, 4
  020b1	89 85 6c fc ff
	ff		 mov	 DWORD PTR _clipboard_len$67[ebp], eax

; 3762 :                 ImWchar* clipboard_filtered = (ImWchar*)IM_ALLOC((clipboard_len+1) * sizeof(ImWchar));

  020b7	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_len$67[ebp]
  020bd	8d 4c 00 02	 lea	 ecx, DWORD PTR [eax+eax+2]
  020c1	51		 push	 ecx
  020c2	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  020c7	83 c4 04	 add	 esp, 4
  020ca	89 85 60 fc ff
	ff		 mov	 DWORD PTR _clipboard_filtered$66[ebp], eax

; 3763 :                 int clipboard_filtered_len = 0;

  020d0	c7 85 54 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _clipboard_filtered_len$65[ebp], 0

; 3764 :                 for (const char* s = clipboard; *s; )

  020da	8b 85 78 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard$68[ebp]
  020e0	89 85 48 fc ff
	ff		 mov	 DWORD PTR _s$64[ebp], eax
$LN5@InputTextE:
  020e6	8b 85 48 fc ff
	ff		 mov	 eax, DWORD PTR _s$64[ebp]
  020ec	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  020ef	85 c9		 test	 ecx, ecx
  020f1	74 7e		 je	 SHORT $LN6@InputTextE

; 3765 :                 {
; 3766 :                     unsigned int c;
; 3767 :                     s += ImTextCharFromUtf8(&c, s, NULL);

  020f3	6a 00		 push	 0
  020f5	8b 85 48 fc ff
	ff		 mov	 eax, DWORD PTR _s$64[ebp]
  020fb	50		 push	 eax
  020fc	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR _c$63[ebp]
  02102	51		 push	 ecx
  02103	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPAIPBD1@Z ; ImTextCharFromUtf8
  02108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0210b	03 85 48 fc ff
	ff		 add	 eax, DWORD PTR _s$64[ebp]
  02111	89 85 48 fc ff
	ff		 mov	 DWORD PTR _s$64[ebp], eax

; 3768 :                     if (c == 0)

  02117	83 bd 3c fc ff
	ff 00		 cmp	 DWORD PTR _c$63[ebp], 0
  0211e	75 02		 jne	 SHORT $LN114@InputTextE

; 3769 :                         break;

  02120	eb 4f		 jmp	 SHORT $LN6@InputTextE
$LN114@InputTextE:

; 3770 :                     if (!InputTextFilterCharacter(&c, flags, callback, callback_user_data))

  02122	8b 45 24	 mov	 eax, DWORD PTR _callback_user_data$[ebp]
  02125	50		 push	 eax
  02126	8b 4d 20	 mov	 ecx, DWORD PTR _callback$[ebp]
  02129	51		 push	 ecx
  0212a	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  0212d	52		 push	 edx
  0212e	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _c$63[ebp]
  02134	50		 push	 eax
  02135	e8 00 00 00 00	 call	 ?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
  0213a	83 c4 10	 add	 esp, 16			; 00000010H
  0213d	0f b6 c8	 movzx	 ecx, al
  02140	85 c9		 test	 ecx, ecx
  02142	75 02		 jne	 SHORT $LN115@InputTextE

; 3771 :                         continue;

  02144	eb a0		 jmp	 SHORT $LN5@InputTextE
$LN115@InputTextE:

; 3772 :                     clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;

  02146	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_filtered_len$65[ebp]
  0214c	8b 8d 60 fc ff
	ff		 mov	 ecx, DWORD PTR _clipboard_filtered$66[ebp]
  02152	66 8b 95 3c fc
	ff ff		 mov	 dx, WORD PTR _c$63[ebp]
  02159	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0215d	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_filtered_len$65[ebp]
  02163	83 c0 01	 add	 eax, 1
  02166	89 85 54 fc ff
	ff		 mov	 DWORD PTR _clipboard_filtered_len$65[ebp], eax

; 3773 :                 }

  0216c	e9 75 ff ff ff	 jmp	 $LN5@InputTextE
$LN6@InputTextE:

; 3774 :                 clipboard_filtered[clipboard_filtered_len] = 0;

  02171	33 c0		 xor	 eax, eax
  02173	8b 8d 54 fc ff
	ff		 mov	 ecx, DWORD PTR _clipboard_filtered_len$65[ebp]
  02179	8b 95 60 fc ff
	ff		 mov	 edx, DWORD PTR _clipboard_filtered$66[ebp]
  0217f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 3775 :                 if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation

  02183	83 bd 54 fc ff
	ff 00		 cmp	 DWORD PTR _clipboard_filtered_len$65[ebp], 0
  0218a	7e 34		 jle	 SHORT $LN116@InputTextE

; 3776 :                 {
; 3777 :                     stb_textedit_paste(state, &state->Stb, clipboard_filtered, clipboard_filtered_len);

  0218c	8b 85 54 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_filtered_len$65[ebp]
  02192	50		 push	 eax
  02193	8b 8d 60 fc ff
	ff		 mov	 ecx, DWORD PTR _clipboard_filtered$66[ebp]
  02199	51		 push	 ecx
  0219a	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  021a0	83 c2 3c	 add	 edx, 60			; 0000003cH
  021a3	52		 push	 edx
  021a4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  021aa	50		 push	 eax
  021ab	e8 00 00 00 00	 call	 ?stb_textedit_paste@ImStb@@YAHPAUImGuiInputTextState@@PAUSTB_TexteditState@1@PBGH@Z ; ImStb::stb_textedit_paste
  021b0	83 c4 10	 add	 esp, 16			; 00000010H

; 3778 :                     state->CursorFollow = true;

  021b3	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  021b9	c6 80 64 0e 00
	00 01		 mov	 BYTE PTR [eax+3684], 1
$LN116@InputTextE:

; 3779 :                 }
; 3780 :                 MemFree(clipboard_filtered);

  021c0	8b 85 60 fc ff
	ff		 mov	 eax, DWORD PTR _clipboard_filtered$66[ebp]
  021c6	50		 push	 eax
  021c7	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  021cc	83 c4 04	 add	 esp, 4
$LN113@InputTextE:

; 3781 :             }
; 3782 :         }
; 3783 : 
; 3784 :         // Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.
; 3785 :         render_selection |= state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);

  021cf	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  021d5	e8 00 00 00 00	 call	 ?HasSelection@ImGuiInputTextState@@QBE_NXZ ; ImGuiInputTextState::HasSelection
  021da	0f b6 c0	 movzx	 eax, al
  021dd	85 c0		 test	 eax, eax
  021df	74 1b		 je	 SHORT $LN329@InputTextE
  021e1	33 c9		 xor	 ecx, ecx
  021e3	75 0b		 jne	 SHORT $LN328@InputTextE
  021e5	0f b6 95 37 fe
	ff ff		 movzx	 edx, BYTE PTR _render_cursor$[ebp]
  021ec	85 d2		 test	 edx, edx
  021ee	74 0c		 je	 SHORT $LN329@InputTextE
$LN328@InputTextE:
  021f0	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1383[ebp], 1
  021fa	eb 0a		 jmp	 SHORT $LN330@InputTextE
$LN329@InputTextE:
  021fc	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1383[ebp], 0
$LN330@InputTextE:
  02206	0f b6 85 2b fe
	ff ff		 movzx	 eax, BYTE PTR _render_selection$[ebp]
  0220d	0b 85 28 f4 ff
	ff		 or	 eax, DWORD PTR tv1383[ebp]
  02213	88 85 2b fe ff
	ff		 mov	 BYTE PTR _render_selection$[ebp], al
$LN65@InputTextE:

; 3786 :     }
; 3787 : 
; 3788 :     // Process callbacks and apply result back to user's buffer.
; 3789 :     if (g.ActiveId == id)

  02219	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0221c	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  02222	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  02228	0f 85 6b 07 00
	00		 jne	 $LN117@InputTextE

; 3790 :     {
; 3791 :         IM_ASSERT(state != NULL);

  0222e	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  02235	75 27		 jne	 SHORT $LN331@InputTextE
  02237	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  0223c	05 88 01 00 00	 add	 eax, 392		; 00000188H
  02241	8b f4		 mov	 esi, esp
  02243	50		 push	 eax
  02244	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  02249	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@FOPGMADN@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  0224e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  02254	83 c4 0c	 add	 esp, 12			; 0000000cH
  02257	3b f4		 cmp	 esi, esp
  02259	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN331@InputTextE:

; 3792 :         const char* apply_new_text = NULL;

  0225e	c7 85 30 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _apply_new_text$62[ebp], 0

; 3793 :         int apply_new_text_length = 0;

  02268	c7 85 24 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _apply_new_text_length$61[ebp], 0

; 3794 :         if (cancel_edit)

  02272	0f b6 85 6b fd
	ff ff		 movzx	 eax, BYTE PTR _cancel_edit$[ebp]
  02279	85 c0		 test	 eax, eax
  0227b	74 43		 je	 SHORT $LN119@InputTextE

; 3795 :         {
; 3796 :             // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
; 3797 :             if (!is_readonly && strcmp(buf, state->InitialTextA.Data) != 0)

  0227d	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  02281	85 c0		 test	 eax, eax
  02283	75 3b		 jne	 SHORT $LN119@InputTextE
  02285	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0228b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0228e	51		 push	 ecx
  0228f	8b 55 10	 mov	 edx, DWORD PTR _buf$[ebp]
  02292	52		 push	 edx
  02293	e8 00 00 00 00	 call	 _strcmp
  02298	83 c4 08	 add	 esp, 8
  0229b	85 c0		 test	 eax, eax
  0229d	74 21		 je	 SHORT $LN119@InputTextE

; 3798 :             {
; 3799 :                 apply_new_text = state->InitialTextA.Data;

  0229f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  022a5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  022a8	89 8d 30 fc ff
	ff		 mov	 DWORD PTR _apply_new_text$62[ebp], ecx

; 3800 :                 apply_new_text_length = state->InitialTextA.Size - 1;

  022ae	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  022b4	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  022b7	83 e9 01	 sub	 ecx, 1
  022ba	89 8d 24 fc ff
	ff		 mov	 DWORD PTR _apply_new_text_length$61[ebp], ecx
$LN119@InputTextE:

; 3801 :             }
; 3802 :         }
; 3803 : 
; 3804 :         // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
; 3805 :         // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.
; 3806 :         bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);

  022c0	0f b6 85 6b fd
	ff ff		 movzx	 eax, BYTE PTR _cancel_edit$[ebp]
  022c7	85 c0		 test	 eax, eax
  022c9	74 1f		 je	 SHORT $LN333@InputTextE
  022cb	0f b6 8d 13 fe
	ff ff		 movzx	 ecx, BYTE PTR _enter_pressed$[ebp]
  022d2	85 c9		 test	 ecx, ecx
  022d4	74 08		 je	 SHORT $LN332@InputTextE
  022d6	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  022d9	83 e2 20	 and	 edx, 32			; 00000020H
  022dc	75 0c		 jne	 SHORT $LN333@InputTextE
$LN332@InputTextE:
  022de	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1415[ebp], 0
  022e8	eb 0a		 jmp	 SHORT $LN334@InputTextE
$LN333@InputTextE:
  022ea	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1415[ebp], 1
$LN334@InputTextE:
  022f4	8a 85 28 f4 ff
	ff		 mov	 al, BYTE PTR tv1415[ebp]
  022fa	88 85 1b fc ff
	ff		 mov	 BYTE PTR _apply_edit_back_to_user_buffer$60[ebp], al

; 3807 :         if (apply_edit_back_to_user_buffer)

  02300	0f b6 85 1b fc
	ff ff		 movzx	 eax, BYTE PTR _apply_edit_back_to_user_buffer$60[ebp]
  02307	85 c0		 test	 eax, eax
  02309	0f 84 fe 04 00
	00		 je	 $LN136@InputTextE

; 3808 :         {
; 3809 :             // Apply new value immediately - copy modified buffer back
; 3810 :             // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
; 3811 :             // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
; 3812 :             // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
; 3813 :             if (!is_readonly)

  0230f	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  02313	85 c0		 test	 eax, eax
  02315	75 51		 jne	 SHORT $LN121@InputTextE

; 3814 :             {
; 3815 :                 state->TextAIsValid = true;

  02317	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0231d	c6 40 30 01	 mov	 BYTE PTR [eax+48], 1

; 3816 :                 state->TextA.resize(state->TextW.Size * 4 + 1);

  02321	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02327	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0232a	8d 14 8d 01 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+1]
  02331	52		 push	 edx
  02332	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  02338	83 c1 18	 add	 ecx, 24			; 00000018H
  0233b	e8 00 00 00 00	 call	 ?resize@?$ImVector@D@@QAEXH@Z ; ImVector<char>::resize

; 3817 :                 ImTextStrToUtf8(state->TextA.Data, state->TextA.Size, state->TextW.Data, NULL);

  02340	6a 00		 push	 0
  02342	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02348	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0234b	51		 push	 ecx
  0234c	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  02352	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  02355	50		 push	 eax
  02356	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0235c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0235f	52		 push	 edx
  02360	e8 00 00 00 00	 call	 ?ImTextStrToUtf8@@YAHPADHPBG1@Z ; ImTextStrToUtf8
  02365	83 c4 10	 add	 esp, 16			; 00000010H
$LN121@InputTextE:

; 3818 :             }
; 3819 : 
; 3820 :             // User callback
; 3821 :             if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)

  02368	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0236b	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  02370	0f 84 57 04 00
	00		 je	 $LN134@InputTextE

; 3822 :             {
; 3823 :                 IM_ASSERT(callback != NULL);

  02376	83 7d 20 00	 cmp	 DWORD PTR _callback$[ebp], 0
  0237a	75 27		 jne	 SHORT $LN335@InputTextE
  0237c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  02381	05 a8 01 00 00	 add	 eax, 424		; 000001a8H
  02386	8b f4		 mov	 esi, esp
  02388	50		 push	 eax
  02389	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0238e	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@CBGPMFEC@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  02393	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  02399	83 c4 0c	 add	 esp, 12			; 0000000cH
  0239c	3b f4		 cmp	 esi, esp
  0239e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN335@InputTextE:

; 3824 : 
; 3825 :                 // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
; 3826 :                 ImGuiInputTextFlags event_flag = 0;

  023a3	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _event_flag$59[ebp], 0

; 3827 :                 ImGuiKey event_key = ImGuiKey_COUNT;

  023ad	c7 85 00 fc ff
	ff 16 00 00 00	 mov	 DWORD PTR _event_key$58[ebp], 22 ; 00000016H

; 3828 :                 if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))

  023b7	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  023ba	83 e0 40	 and	 eax, 64			; 00000040H
  023bd	74 29		 je	 SHORT $LN123@InputTextE
  023bf	6a 01		 push	 1
  023c1	6a 00		 push	 0
  023c3	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  023c8	83 c4 08	 add	 esp, 8
  023cb	0f b6 c0	 movzx	 eax, al
  023ce	85 c0		 test	 eax, eax
  023d0	74 16		 je	 SHORT $LN123@InputTextE

; 3829 :                 {
; 3830 :                     event_flag = ImGuiInputTextFlags_CallbackCompletion;

  023d2	c7 85 0c fc ff
	ff 40 00 00 00	 mov	 DWORD PTR _event_flag$59[ebp], 64 ; 00000040H

; 3831 :                     event_key = ImGuiKey_Tab;

  023dc	c7 85 00 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _event_key$58[ebp], 0

; 3832 :                 }

  023e6	eb 7a		 jmp	 SHORT $LN129@InputTextE
$LN123@InputTextE:

; 3833 :                 else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))

  023e8	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  023eb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  023f0	74 29		 je	 SHORT $LN125@InputTextE
  023f2	6a 01		 push	 1
  023f4	6a 03		 push	 3
  023f6	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  023fb	83 c4 08	 add	 esp, 8
  023fe	0f b6 c0	 movzx	 eax, al
  02401	85 c0		 test	 eax, eax
  02403	74 16		 je	 SHORT $LN125@InputTextE

; 3834 :                 {
; 3835 :                     event_flag = ImGuiInputTextFlags_CallbackHistory;

  02405	c7 85 0c fc ff
	ff 80 00 00 00	 mov	 DWORD PTR _event_flag$59[ebp], 128 ; 00000080H

; 3836 :                     event_key = ImGuiKey_UpArrow;

  0240f	c7 85 00 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR _event_key$58[ebp], 3

; 3837 :                 }

  02419	eb 47		 jmp	 SHORT $LN129@InputTextE
$LN125@InputTextE:

; 3838 :                 else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))

  0241b	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0241e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02423	74 29		 je	 SHORT $LN127@InputTextE
  02425	6a 01		 push	 1
  02427	6a 04		 push	 4
  02429	e8 00 00 00 00	 call	 ?IsKeyPressedMap@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressedMap
  0242e	83 c4 08	 add	 esp, 8
  02431	0f b6 c0	 movzx	 eax, al
  02434	85 c0		 test	 eax, eax
  02436	74 16		 je	 SHORT $LN127@InputTextE

; 3839 :                 {
; 3840 :                     event_flag = ImGuiInputTextFlags_CallbackHistory;

  02438	c7 85 0c fc ff
	ff 80 00 00 00	 mov	 DWORD PTR _event_flag$59[ebp], 128 ; 00000080H

; 3841 :                     event_key = ImGuiKey_DownArrow;

  02442	c7 85 00 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR _event_key$58[ebp], 4

; 3842 :                 }

  0244c	eb 14		 jmp	 SHORT $LN129@InputTextE
$LN127@InputTextE:

; 3843 :                 else if (flags & ImGuiInputTextFlags_CallbackAlways)

  0244e	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  02451	25 00 01 00 00	 and	 eax, 256		; 00000100H
  02456	74 0a		 je	 SHORT $LN129@InputTextE

; 3844 :                     event_flag = ImGuiInputTextFlags_CallbackAlways;

  02458	c7 85 0c fc ff
	ff 00 01 00 00	 mov	 DWORD PTR _event_flag$59[ebp], 256 ; 00000100H
$LN129@InputTextE:

; 3845 : 
; 3846 :                 if (event_flag)

  02462	83 bd 0c fc ff
	ff 00		 cmp	 DWORD PTR _event_flag$59[ebp], 0
  02469	0f 84 5e 03 00
	00		 je	 $LN134@InputTextE

; 3847 :                 {
; 3848 :                     ImGuiInputTextCallbackData callback_data;

  0246f	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _callback_data$57[ebp]
  02475	e8 00 00 00 00	 call	 ??0ImGuiInputTextCallbackData@@QAE@XZ ; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData

; 3849 :                     memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));

  0247a	6a 30		 push	 48			; 00000030H
  0247c	6a 00		 push	 0
  0247e	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _callback_data$57[ebp]
  02484	50		 push	 eax
  02485	e8 00 00 00 00	 call	 _memset
  0248a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3850 :                     callback_data.EventFlag = event_flag;

  0248d	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _event_flag$59[ebp]
  02493	89 85 c8 fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp], eax

; 3851 :                     callback_data.Flags = flags;

  02499	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0249c	89 85 cc fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+4], eax

; 3852 :                     callback_data.UserData = callback_user_data;

  024a2	8b 45 24	 mov	 eax, DWORD PTR _callback_user_data$[ebp]
  024a5	89 85 d0 fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+8], eax

; 3853 : 
; 3854 :                     callback_data.EventKey = event_key;

  024ab	8b 85 00 fc ff
	ff		 mov	 eax, DWORD PTR _event_key$58[ebp]
  024b1	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+16], eax

; 3855 :                     callback_data.Buf = state->TextA.Data;

  024b7	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  024bd	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  024c0	89 8d dc fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+20], ecx

; 3856 :                     callback_data.BufTextLen = state->CurLenA;

  024c6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  024cc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  024cf	89 8d e0 fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+24], ecx

; 3857 :                     callback_data.BufSize = state->BufCapacityA;

  024d5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  024db	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  024de	89 8d e4 fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+28], ecx

; 3858 :                     callback_data.BufDirty = false;

  024e4	c6 85 e8 fb ff
	ff 00		 mov	 BYTE PTR _callback_data$57[ebp+32], 0

; 3859 : 
; 3860 :                     // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
; 3861 :                     ImWchar* text = state->TextW.Data;

  024eb	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  024f1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  024f4	89 8d bc fb ff
	ff		 mov	 DWORD PTR _text$56[ebp], ecx

; 3862 :                     const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state->Stb.cursor);

  024fa	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02500	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  02503	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR _text$56[ebp]
  02509	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0250c	50		 push	 eax
  0250d	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _text$56[ebp]
  02513	51		 push	 ecx
  02514	e8 00 00 00 00	 call	 ?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z ; ImTextCountUtf8BytesFromStr
  02519	83 c4 08	 add	 esp, 8
  0251c	89 85 ec fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+36], eax
  02522	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _callback_data$57[ebp+36]
  02528	89 95 b0 fb ff
	ff		 mov	 DWORD PTR _utf8_cursor_pos$55[ebp], edx

; 3863 :                     const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_start);

  0252e	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02534	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  02537	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR _text$56[ebp]
  0253d	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  02540	50		 push	 eax
  02541	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _text$56[ebp]
  02547	51		 push	 ecx
  02548	e8 00 00 00 00	 call	 ?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z ; ImTextCountUtf8BytesFromStr
  0254d	83 c4 08	 add	 esp, 8
  02550	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+40], eax
  02556	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _callback_data$57[ebp+40]
  0255c	89 95 a4 fb ff
	ff		 mov	 DWORD PTR _utf8_selection_start$54[ebp], edx

; 3864 :                     const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_end);

  02562	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02568	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0256b	8b 95 bc fb ff
	ff		 mov	 edx, DWORD PTR _text$56[ebp]
  02571	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  02574	50		 push	 eax
  02575	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _text$56[ebp]
  0257b	51		 push	 ecx
  0257c	e8 00 00 00 00	 call	 ?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z ; ImTextCountUtf8BytesFromStr
  02581	83 c4 08	 add	 esp, 8
  02584	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _callback_data$57[ebp+44], eax
  0258a	8b 95 f4 fb ff
	ff		 mov	 edx, DWORD PTR _callback_data$57[ebp+44]
  02590	89 95 98 fb ff
	ff		 mov	 DWORD PTR _utf8_selection_end$53[ebp], edx

; 3865 : 
; 3866 :                     // Call user code
; 3867 :                     callback(&callback_data);

  02596	8b f4		 mov	 esi, esp
  02598	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR _callback_data$57[ebp]
  0259e	50		 push	 eax
  0259f	ff 55 20	 call	 DWORD PTR _callback$[ebp]
  025a2	83 c4 04	 add	 esp, 4
  025a5	3b f4		 cmp	 esi, esp
  025a7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3868 : 
; 3869 :                     // Read back what user may have modified
; 3870 :                     IM_ASSERT(callback_data.Buf == state->TextA.Data);  // Invalid to modify those fields

  025ac	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  025b2	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _callback_data$57[ebp+20]
  025b8	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  025bb	74 29		 je	 SHORT $LN336@InputTextE
  025bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  025c3	81 c2 d7 01 00
	00		 add	 edx, 471		; 000001d7H
  025c9	8b f4		 mov	 esi, esp
  025cb	52		 push	 edx
  025cc	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  025d1	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@GEAEFBFI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@
  025d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  025dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  025df	3b f4		 cmp	 esi, esp
  025e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN336@InputTextE:

; 3871 :                     IM_ASSERT(callback_data.BufSize == state->BufCapacityA);

  025e6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  025ec	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR _callback_data$57[ebp+28]
  025f2	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  025f5	74 29		 je	 SHORT $LN337@InputTextE
  025f7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  025fd	81 c2 d8 01 00
	00		 add	 edx, 472		; 000001d8H
  02603	8b f4		 mov	 esi, esp
  02605	52		 push	 edx
  02606	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0260b	68 00 00 00 00	 push	 OFFSET ??_C@_1FK@GDPCIOA@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@
  02610	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  02616	83 c4 0c	 add	 esp, 12			; 0000000cH
  02619	3b f4		 cmp	 esi, esp
  0261b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN337@InputTextE:

; 3872 :                     IM_ASSERT(callback_data.Flags == flags);

  02620	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+4]
  02626	3b 45 1c	 cmp	 eax, DWORD PTR _flags$[ebp]
  02629	74 29		 je	 SHORT $LN338@InputTextE
  0262b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  02631	81 c1 d9 01 00
	00		 add	 ecx, 473		; 000001d9H
  02637	8b f4		 mov	 esi, esp
  02639	51		 push	 ecx
  0263a	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0263f	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@HOPDKFNI@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAF@
  02644	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0264a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0264d	3b f4		 cmp	 esi, esp
  0264f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN338@InputTextE:

; 3873 :                     if (callback_data.CursorPos != utf8_cursor_pos)            { state->Stb.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); state->CursorFollow = true; }

  02654	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+36]
  0265a	3b 85 b0 fb ff
	ff		 cmp	 eax, DWORD PTR _utf8_cursor_pos$55[ebp]
  02660	74 32		 je	 SHORT $LN131@InputTextE
  02662	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+20]
  02668	03 85 ec fb ff
	ff		 add	 eax, DWORD PTR _callback_data$57[ebp+36]
  0266e	50		 push	 eax
  0266f	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _callback_data$57[ebp+20]
  02675	51		 push	 ecx
  02676	e8 00 00 00 00	 call	 ?ImTextCountCharsFromUtf8@@YAHPBD0@Z ; ImTextCountCharsFromUtf8
  0267b	83 c4 08	 add	 esp, 8
  0267e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  02684	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  02687	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0268d	c6 80 64 0e 00
	00 01		 mov	 BYTE PTR [eax+3684], 1
$LN131@InputTextE:

; 3874 :                     if (callback_data.SelectionStart != utf8_selection_start)  { state->Stb.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }

  02694	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+40]
  0269a	3b 85 a4 fb ff
	ff		 cmp	 eax, DWORD PTR _utf8_selection_start$54[ebp]
  026a0	74 25		 je	 SHORT $LN132@InputTextE
  026a2	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+20]
  026a8	03 85 f0 fb ff
	ff		 add	 eax, DWORD PTR _callback_data$57[ebp+40]
  026ae	50		 push	 eax
  026af	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _callback_data$57[ebp+20]
  026b5	51		 push	 ecx
  026b6	e8 00 00 00 00	 call	 ?ImTextCountCharsFromUtf8@@YAHPBD0@Z ; ImTextCountCharsFromUtf8
  026bb	83 c4 08	 add	 esp, 8
  026be	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  026c4	89 42 40	 mov	 DWORD PTR [edx+64], eax
$LN132@InputTextE:

; 3875 :                     if (callback_data.SelectionEnd != utf8_selection_end)      { state->Stb.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }

  026c7	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+44]
  026cd	3b 85 98 fb ff
	ff		 cmp	 eax, DWORD PTR _utf8_selection_end$53[ebp]
  026d3	74 25		 je	 SHORT $LN133@InputTextE
  026d5	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+20]
  026db	03 85 f4 fb ff
	ff		 add	 eax, DWORD PTR _callback_data$57[ebp+44]
  026e1	50		 push	 eax
  026e2	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _callback_data$57[ebp+20]
  026e8	51		 push	 ecx
  026e9	e8 00 00 00 00	 call	 ?ImTextCountCharsFromUtf8@@YAHPBD0@Z ; ImTextCountCharsFromUtf8
  026ee	83 c4 08	 add	 esp, 8
  026f1	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  026f7	89 42 44	 mov	 DWORD PTR [edx+68], eax
$LN133@InputTextE:

; 3876 :                     if (callback_data.BufDirty)

  026fa	0f b6 85 e8 fb
	ff ff		 movzx	 eax, BYTE PTR _callback_data$57[ebp+32]
  02701	85 c0		 test	 eax, eax
  02703	0f 84 c4 00 00
	00		 je	 $LN134@InputTextE

; 3877 :                     {
; 3878 :                         IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!

  02709	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+20]
  0270f	50		 push	 eax
  02710	e8 00 00 00 00	 call	 _strlen
  02715	83 c4 04	 add	 esp, 4
  02718	39 85 e0 fb ff
	ff		 cmp	 DWORD PTR _callback_data$57[ebp+24], eax
  0271e	74 29		 je	 SHORT $LN339@InputTextE
  02720	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  02726	81 c1 df 01 00
	00		 add	 ecx, 479		; 000001dfH
  0272c	8b f4		 mov	 esi, esp
  0272e	51		 push	 ecx
  0272f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  02734	68 00 00 00 00	 push	 OFFSET ??_C@_1HG@EHLBBEIB@?$AAc?$AAa?$AAl?$AAl?$AAb?$AAa?$AAc?$AAk?$AA_?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAB@
  02739	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0273f	83 c4 0c	 add	 esp, 12			; 0000000cH
  02742	3b f4		 cmp	 esi, esp
  02744	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN339@InputTextE:

; 3879 :                         if (callback_data.BufTextLen > backup_current_text_length && is_resizable)

  02749	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+24]
  0274f	3b 85 c8 fd ff
	ff		 cmp	 eax, DWORD PTR _backup_current_text_length$[ebp]
  02755	7e 2c		 jle	 SHORT $LN135@InputTextE
  02757	0f b6 45 8b	 movzx	 eax, BYTE PTR _is_resizable$[ebp]
  0275b	85 c0		 test	 eax, eax
  0275d	74 24		 je	 SHORT $LN135@InputTextE

; 3880 :                             state->TextW.resize(state->TextW.Size + (callback_data.BufTextLen - backup_current_text_length));

  0275f	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+24]
  02765	2b 85 c8 fd ff
	ff		 sub	 eax, DWORD PTR _backup_current_text_length$[ebp]
  0276b	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  02771	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  02774	50		 push	 eax
  02775	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  0277b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0277e	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize
$LN135@InputTextE:

; 3881 :                         state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL);

  02783	6a 00		 push	 0
  02785	6a 00		 push	 0
  02787	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$57[ebp+20]
  0278d	50		 push	 eax
  0278e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  02794	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  02797	52		 push	 edx
  02798	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0279e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  027a1	51		 push	 ecx
  027a2	e8 00 00 00 00	 call	 ?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z ; ImTextStrFromUtf8
  027a7	83 c4 14	 add	 esp, 20			; 00000014H
  027aa	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  027b0	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3882 :                         state->CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()

  027b3	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  027b9	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _callback_data$57[ebp+24]
  027bf	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 3883 :                         state->CursorAnimReset();

  027c2	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  027c8	e8 00 00 00 00	 call	 ?CursorAnimReset@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::CursorAnimReset
$LN134@InputTextE:

; 3884 :                     }
; 3885 :                 }
; 3886 :             }
; 3887 : 
; 3888 :             // Will copy result string if modified
; 3889 :             if (!is_readonly && strcmp(state->TextA.Data, buf) != 0)

  027cd	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  027d1	85 c0		 test	 eax, eax
  027d3	75 38		 jne	 SHORT $LN136@InputTextE
  027d5	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  027d8	50		 push	 eax
  027d9	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  027df	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  027e2	52		 push	 edx
  027e3	e8 00 00 00 00	 call	 _strcmp
  027e8	83 c4 08	 add	 esp, 8
  027eb	85 c0		 test	 eax, eax
  027ed	74 1e		 je	 SHORT $LN136@InputTextE

; 3890 :             {
; 3891 :                 apply_new_text = state->TextA.Data;

  027ef	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  027f5	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  027f8	89 8d 30 fc ff
	ff		 mov	 DWORD PTR _apply_new_text$62[ebp], ecx

; 3892 :                 apply_new_text_length = state->CurLenA;

  027fe	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02804	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  02807	89 8d 24 fc ff
	ff		 mov	 DWORD PTR _apply_new_text_length$61[ebp], ecx
$LN136@InputTextE:

; 3893 :             }
; 3894 :         }
; 3895 : 
; 3896 :         // Copy result to user buffer
; 3897 :         if (apply_new_text)

  0280d	83 bd 30 fc ff
	ff 00		 cmp	 DWORD PTR _apply_new_text$62[ebp], 0
  02814	0f 84 4f 01 00
	00		 je	 $LN137@InputTextE

; 3898 :         {
; 3899 :             IM_ASSERT(apply_new_text_length >= 0);

  0281a	83 bd 24 fc ff
	ff 00		 cmp	 DWORD PTR _apply_new_text_length$61[ebp], 0
  02821	7d 27		 jge	 SHORT $LN340@InputTextE
  02823	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  02828	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  0282d	8b f4		 mov	 esi, esp
  0282f	50		 push	 eax
  02830	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  02835	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@CHDFECEK@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@
  0283a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  02840	83 c4 0c	 add	 esp, 12			; 0000000cH
  02843	3b f4		 cmp	 esi, esp
  02845	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN340@InputTextE:

; 3900 :             if (backup_current_text_length != apply_new_text_length && is_resizable)

  0284a	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _backup_current_text_length$[ebp]
  02850	3b 85 24 fc ff
	ff		 cmp	 eax, DWORD PTR _apply_new_text_length$61[ebp]
  02856	0f 84 dc 00 00
	00		 je	 $LN341@InputTextE
  0285c	0f b6 45 8b	 movzx	 eax, BYTE PTR _is_resizable$[ebp]
  02860	85 c0		 test	 eax, eax
  02862	0f 84 d0 00 00
	00		 je	 $LN341@InputTextE

; 3901 :             {
; 3902 :                 ImGuiInputTextCallbackData callback_data;

  02868	8d 8d 60 fb ff
	ff		 lea	 ecx, DWORD PTR _callback_data$52[ebp]
  0286e	e8 00 00 00 00	 call	 ??0ImGuiInputTextCallbackData@@QAE@XZ ; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData

; 3903 :                 callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;

  02873	c7 85 60 fb ff
	ff 00 00 04 00	 mov	 DWORD PTR _callback_data$52[ebp], 262144 ; 00040000H

; 3904 :                 callback_data.Flags = flags;

  0287d	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  02880	89 85 64 fb ff
	ff		 mov	 DWORD PTR _callback_data$52[ebp+4], eax

; 3905 :                 callback_data.Buf = buf;

  02886	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  02889	89 85 74 fb ff
	ff		 mov	 DWORD PTR _callback_data$52[ebp+20], eax

; 3906 :                 callback_data.BufTextLen = apply_new_text_length;

  0288f	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _apply_new_text_length$61[ebp]
  02895	89 85 78 fb ff
	ff		 mov	 DWORD PTR _callback_data$52[ebp+24], eax

; 3907 :                 callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);

  0289b	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _apply_new_text_length$61[ebp]
  028a1	83 c0 01	 add	 eax, 1
  028a4	50		 push	 eax
  028a5	8b 4d 14	 mov	 ecx, DWORD PTR _buf_size$[ebp]
  028a8	51		 push	 ecx
  028a9	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  028ae	83 c4 08	 add	 esp, 8
  028b1	89 85 7c fb ff
	ff		 mov	 DWORD PTR _callback_data$52[ebp+28], eax

; 3908 :                 callback_data.UserData = callback_user_data;

  028b7	8b 45 24	 mov	 eax, DWORD PTR _callback_user_data$[ebp]
  028ba	89 85 68 fb ff
	ff		 mov	 DWORD PTR _callback_data$52[ebp+8], eax

; 3909 :                 callback(&callback_data);

  028c0	8b f4		 mov	 esi, esp
  028c2	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR _callback_data$52[ebp]
  028c8	50		 push	 eax
  028c9	ff 55 20	 call	 DWORD PTR _callback$[ebp]
  028cc	83 c4 04	 add	 esp, 4
  028cf	3b f4		 cmp	 esi, esp
  028d1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3910 :                 buf = callback_data.Buf;

  028d6	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$52[ebp+20]
  028dc	89 45 10	 mov	 DWORD PTR _buf$[ebp], eax

; 3911 :                 buf_size = callback_data.BufSize;

  028df	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _callback_data$52[ebp+28]
  028e5	89 45 14	 mov	 DWORD PTR _buf_size$[ebp], eax

; 3912 :                 apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);

  028e8	8b 45 14	 mov	 eax, DWORD PTR _buf_size$[ebp]
  028eb	83 e8 01	 sub	 eax, 1
  028ee	50		 push	 eax
  028ef	8b 8d 78 fb ff
	ff		 mov	 ecx, DWORD PTR _callback_data$52[ebp+24]
  028f5	51		 push	 ecx
  028f6	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  028fb	83 c4 08	 add	 esp, 8
  028fe	89 85 24 fc ff
	ff		 mov	 DWORD PTR _apply_new_text_length$61[ebp], eax

; 3913 :                 IM_ASSERT(apply_new_text_length <= buf_size);

  02904	8b 85 24 fc ff
	ff		 mov	 eax, DWORD PTR _apply_new_text_length$61[ebp]
  0290a	3b 45 14	 cmp	 eax, DWORD PTR _buf_size$[ebp]
  0290d	7e 29		 jle	 SHORT $LN341@InputTextE
  0290f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  02915	81 c1 02 02 00
	00		 add	 ecx, 514		; 00000202H
  0291b	8b f4		 mov	 esi, esp
  0291d	51		 push	 ecx
  0291e	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  02923	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@MOOHJKEO@?$AAa?$AAp?$AAp?$AAl?$AAy?$AA_?$AAn?$AAe?$AAw?$AA_?$AAt?$AAe?$AAx?$AAt?$AA_@
  02928	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0292e	83 c4 0c	 add	 esp, 12			; 0000000cH
  02931	3b f4		 cmp	 esi, esp
  02933	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN341@InputTextE:

; 3914 :             }
; 3915 : 
; 3916 :             // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
; 3917 :             ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));

  02938	8b 45 14	 mov	 eax, DWORD PTR _buf_size$[ebp]
  0293b	50		 push	 eax
  0293c	8b 8d 24 fc ff
	ff		 mov	 ecx, DWORD PTR _apply_new_text_length$61[ebp]
  02942	83 c1 01	 add	 ecx, 1
  02945	51		 push	 ecx
  02946	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  0294b	83 c4 08	 add	 esp, 8
  0294e	50		 push	 eax
  0294f	8b 95 30 fc ff
	ff		 mov	 edx, DWORD PTR _apply_new_text$62[ebp]
  02955	52		 push	 edx
  02956	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  02959	50		 push	 eax
  0295a	e8 00 00 00 00	 call	 ?ImStrncpy@@YAXPADPBDI@Z ; ImStrncpy
  0295f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3918 :             value_changed = true;

  02962	c6 85 1f fe ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN137@InputTextE:

; 3919 :         }
; 3920 : 
; 3921 :         // Clear temporary user storage
; 3922 :         state->UserFlags = 0;

  02969	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0296f	c7 80 68 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3688], 0

; 3923 :         state->UserCallback = NULL;

  02979	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0297f	c7 80 6c 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3692], 0

; 3924 :         state->UserCallbackData = NULL;

  02989	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0298f	c7 80 70 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3696], 0
$LN117@InputTextE:

; 3925 :     }
; 3926 : 
; 3927 :     // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
; 3928 :     if (clear_active_id && g.ActiveId == id)

  02999	0f b6 85 8b fe
	ff ff		 movzx	 eax, BYTE PTR _clear_active_id$[ebp]
  029a0	85 c0		 test	 eax, eax
  029a2	74 16		 je	 SHORT $LN139@InputTextE
  029a4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  029a7	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  029ad	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  029b3	75 05		 jne	 SHORT $LN139@InputTextE

; 3929 :         ClearActiveID();

  029b5	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN139@InputTextE:

; 3930 : 
; 3931 :     // Render frame
; 3932 :     if (!is_multiline)

  029ba	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  029be	85 c0		 test	 eax, eax
  029c0	75 65		 jne	 SHORT $LN140@InputTextE

; 3933 :     {
; 3934 :         RenderNavHighlight(frame_bb, id);

  029c2	6a 01		 push	 1
  029c4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _id$[ebp]
  029ca	50		 push	 eax
  029cb	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  029d1	51		 push	 ecx
  029d2	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  029d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3935 :         RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

  029da	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  029dd	51		 push	 ecx
  029de	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  029e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  029e8	6a 01		 push	 1
  029ea	51		 push	 ecx
  029eb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  029f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  029f8	6a 07		 push	 7
  029fa	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  029ff	83 c4 08	 add	 esp, 8
  02a02	50		 push	 eax
  02a03	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _frame_bb$[ebp+12]
  02a09	51		 push	 ecx
  02a0a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _frame_bb$[ebp+8]
  02a10	52		 push	 edx
  02a11	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _frame_bb$[ebp+4]
  02a17	50		 push	 eax
  02a18	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _frame_bb$[ebp]
  02a1e	51		 push	 ecx
  02a1f	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  02a24	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN140@InputTextE:

; 3936 :     }
; 3937 : 
; 3938 :     const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y); // Not using frame_bb.Max because we have adjusted size

  02a27	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  02a2f	f3 0f 58 85 04
	ff ff ff	 addss	 xmm0, DWORD PTR _inner_size$[ebp+4]
  02a37	51		 push	 ecx
  02a38	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02a3d	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp]
  02a45	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _inner_size$[ebp]
  02a4d	51		 push	 ecx
  02a4e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02a53	51		 push	 ecx
  02a54	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  02a5c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02a61	51		 push	 ecx
  02a62	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp]
  02a6a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02a6f	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _clip_rect$[ebp]
  02a75	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4

; 3939 :     ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;

  02a7a	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  02a7e	85 c0		 test	 eax, eax
  02a80	74 2c		 je	 SHORT $LN342@InputTextE
  02a82	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _draw_window$[ebp]
  02a88	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  02a8e	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  02a94	89 95 88 f5 ff
	ff		 mov	 DWORD PTR $T21[ebp], edx
  02a9a	89 85 8c f5 ff
	ff		 mov	 DWORD PTR $T21[ebp+4], eax
  02aa0	8d 8d 88 f5 ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  02aa6	89 8d 28 f4 ff
	ff		 mov	 DWORD PTR tv1693[ebp], ecx
  02aac	eb 23		 jmp	 SHORT $LN343@InputTextE
$LN342@InputTextE:
  02aae	8b 55 d0	 mov	 edx, DWORD PTR _style$[ebp]
  02ab1	83 c2 38	 add	 edx, 56			; 00000038H
  02ab4	52		 push	 edx
  02ab5	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  02abb	50		 push	 eax
  02abc	8d 8d 78 f5 ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  02ac2	51		 push	 ecx
  02ac3	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  02ac8	83 c4 0c	 add	 esp, 12			; 0000000cH
  02acb	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv1693[ebp], eax
$LN343@InputTextE:
  02ad1	8b 95 28 f4 ff
	ff		 mov	 edx, DWORD PTR tv1693[ebp]
  02ad7	89 95 98 f5 ff
	ff		 mov	 DWORD PTR $T22[ebp], edx
  02add	8b 85 98 f5 ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  02ae3	8b 08		 mov	 ecx, DWORD PTR [eax]
  02ae5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02ae8	89 8d 38 fb ff
	ff		 mov	 DWORD PTR _draw_pos$[ebp], ecx
  02aee	89 95 3c fb ff
	ff		 mov	 DWORD PTR _draw_pos$[ebp+4], edx

; 3940 :     ImVec2 text_size(0.0f, 0.0f);

  02af4	51		 push	 ecx
  02af5	0f 57 c0	 xorps	 xmm0, xmm0
  02af8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02afd	51		 push	 ecx
  02afe	0f 57 c0	 xorps	 xmm0, xmm0
  02b01	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02b06	8d 8d 28 fb ff
	ff		 lea	 ecx, DWORD PTR _text_size$[ebp]
  02b0c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 3941 : 
; 3942 :     // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
; 3943 :     // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
; 3944 :     // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
; 3945 :     const int buf_display_max_length = 2 * 1024 * 1024;

  02b11	c7 85 1c fb ff
	ff 00 00 20 00	 mov	 DWORD PTR _buf_display_max_length$[ebp], 2097152 ; 00200000H

; 3946 :     const char* buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595

  02b1b	0f b6 85 fb fd
	ff ff		 movzx	 eax, BYTE PTR _buf_display_from_state$[ebp]
  02b22	85 c0		 test	 eax, eax
  02b24	74 11		 je	 SHORT $LN344@InputTextE
  02b26	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  02b2c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  02b2f	89 95 28 f4 ff
	ff		 mov	 DWORD PTR tv1702[ebp], edx
  02b35	eb 09		 jmp	 SHORT $LN345@InputTextE
$LN344@InputTextE:
  02b37	8b 45 10	 mov	 eax, DWORD PTR _buf$[ebp]
  02b3a	89 85 28 f4 ff
	ff		 mov	 DWORD PTR tv1702[ebp], eax
$LN345@InputTextE:
  02b40	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv1702[ebp]
  02b46	89 8d 10 fb ff
	ff		 mov	 DWORD PTR _buf_display$[ebp], ecx

; 3947 :     const char* buf_display_end = NULL; // We have specialized paths below for setting the length

  02b4c	c7 85 04 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _buf_display_end$[ebp], 0

; 3948 :     if (is_displaying_hint)

  02b56	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  02b5d	85 c0		 test	 eax, eax
  02b5f	74 1e		 je	 SHORT $LN141@InputTextE

; 3949 :     {
; 3950 :         buf_display = hint;

  02b61	8b 45 0c	 mov	 eax, DWORD PTR _hint$[ebp]
  02b64	89 85 10 fb ff
	ff		 mov	 DWORD PTR _buf_display$[ebp], eax

; 3951 :         buf_display_end = hint + strlen(hint);

  02b6a	8b 45 0c	 mov	 eax, DWORD PTR _hint$[ebp]
  02b6d	50		 push	 eax
  02b6e	e8 00 00 00 00	 call	 _strlen
  02b73	83 c4 04	 add	 esp, 4
  02b76	03 45 0c	 add	 eax, DWORD PTR _hint$[ebp]
  02b79	89 85 04 fb ff
	ff		 mov	 DWORD PTR _buf_display_end$[ebp], eax
$LN141@InputTextE:

; 3952 :     }
; 3953 : 
; 3954 :     // Render text. We currently only render selection when the widget is active or while scrolling.
; 3955 :     // FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
; 3956 :     if (render_cursor || render_selection)

  02b7f	0f b6 85 37 fe
	ff ff		 movzx	 eax, BYTE PTR _render_cursor$[ebp]
  02b86	85 c0		 test	 eax, eax
  02b88	75 0f		 jne	 SHORT $LN144@InputTextE
  02b8a	0f b6 85 2b fe
	ff ff		 movzx	 eax, BYTE PTR _render_selection$[ebp]
  02b91	85 c0		 test	 eax, eax
  02b93	0f 84 16 0d 00
	00		 je	 $LN142@InputTextE
$LN144@InputTextE:

; 3957 :     {
; 3958 :         IM_ASSERT(state != NULL);

  02b99	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _state$[ebp], 0
  02ba0	75 27		 jne	 SHORT $LN346@InputTextE
  02ba2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  02ba7	05 2f 02 00 00	 add	 eax, 559		; 0000022fH
  02bac	8b f4		 mov	 esi, esp
  02bae	50		 push	 eax
  02baf	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  02bb4	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@FOPGMADN@?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  02bb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  02bbf	83 c4 0c	 add	 esp, 12			; 0000000cH
  02bc2	3b f4		 cmp	 esi, esp
  02bc4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN346@InputTextE:

; 3959 :         if (!is_displaying_hint)

  02bc9	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  02bd0	85 c0		 test	 eax, eax
  02bd2	75 15		 jne	 SHORT $LN145@InputTextE

; 3960 :             buf_display_end = buf_display + state->CurLenA;

  02bd4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02bda	8b 8d 10 fb ff
	ff		 mov	 ecx, DWORD PTR _buf_display$[ebp]
  02be0	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  02be3	89 8d 04 fb ff
	ff		 mov	 DWORD PTR _buf_display_end$[ebp], ecx
$LN145@InputTextE:

; 3961 : 
; 3962 :         // Render text (with cursor and selection)
; 3963 :         // This is going to be messy. We need to:
; 3964 :         // - Display the text (this alone can be more easily clipped)
; 3965 :         // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
; 3966 :         // - Measure text height (for scrollbar)
; 3967 :         // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
; 3968 :         // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
; 3969 :         const ImWchar* text_begin = state->TextW.Data;

  02be9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02bef	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  02bf2	89 8d f8 fa ff
	ff		 mov	 DWORD PTR _text_begin$51[ebp], ecx

; 3970 :         ImVec2 cursor_offset, select_start_offset;

  02bf8	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _cursor_offset$50[ebp]
  02bfe	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  02c03	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _select_start_offset$49[ebp]
  02c09	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2

; 3971 : 
; 3972 :         {
; 3973 :             // Find lines numbers straddling 'cursor' (slot 0) and 'select_start' (slot 1) positions.
; 3974 :             const ImWchar* searches_input_ptr[2] = { NULL, NULL };

  02c0e	c7 85 c8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _searches_input_ptr$48[ebp], 0
  02c18	c7 85 cc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _searches_input_ptr$48[ebp+4], 0

; 3975 :             int searches_result_line_no[2] = { -1000, -1000 };

  02c22	c7 85 b8 fa ff
	ff 18 fc ff ff	 mov	 DWORD PTR _searches_result_line_no$47[ebp], -1000 ; fffffc18H
  02c2c	c7 85 bc fa ff
	ff 18 fc ff ff	 mov	 DWORD PTR _searches_result_line_no$47[ebp+4], -1000 ; fffffc18H

; 3976 :             int searches_remaining = 0;

  02c36	c7 85 ac fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _searches_remaining$46[ebp], 0

; 3977 :             if (render_cursor)

  02c40	0f b6 85 37 fe
	ff ff		 movzx	 eax, BYTE PTR _render_cursor$[ebp]
  02c47	85 c0		 test	 eax, eax
  02c49	74 43		 je	 SHORT $LN146@InputTextE

; 3978 :             {
; 3979 :                 searches_input_ptr[0] = text_begin + state->Stb.cursor;

  02c4b	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02c51	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  02c54	8b 95 f8 fa ff
	ff		 mov	 edx, DWORD PTR _text_begin$51[ebp]
  02c5a	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  02c5d	b9 04 00 00 00	 mov	 ecx, 4
  02c62	6b d1 00	 imul	 edx, ecx, 0
  02c65	89 84 15 c8 fa
	ff ff		 mov	 DWORD PTR _searches_input_ptr$48[ebp+edx], eax

; 3980 :                 searches_result_line_no[0] = -1;

  02c6c	b8 04 00 00 00	 mov	 eax, 4
  02c71	6b c8 00	 imul	 ecx, eax, 0
  02c74	c7 84 0d b8 fa
	ff ff ff ff ff
	ff		 mov	 DWORD PTR _searches_result_line_no$47[ebp+ecx], -1

; 3981 :                 searches_remaining++;

  02c7f	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _searches_remaining$46[ebp]
  02c85	83 c0 01	 add	 eax, 1
  02c88	89 85 ac fa ff
	ff		 mov	 DWORD PTR _searches_remaining$46[ebp], eax
$LN146@InputTextE:

; 3982 :             }
; 3983 :             if (render_selection)

  02c8e	0f b6 85 2b fe
	ff ff		 movzx	 eax, BYTE PTR _render_selection$[ebp]
  02c95	85 c0		 test	 eax, eax
  02c97	74 56		 je	 SHORT $LN147@InputTextE

; 3984 :             {
; 3985 :                 searches_input_ptr[1] = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);

  02c99	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02c9f	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  02ca2	51		 push	 ecx
  02ca3	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  02ca9	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  02cac	50		 push	 eax
  02cad	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  02cb2	83 c4 08	 add	 esp, 8
  02cb5	8b 8d f8 fa ff
	ff		 mov	 ecx, DWORD PTR _text_begin$51[ebp]
  02cbb	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  02cbe	b8 04 00 00 00	 mov	 eax, 4
  02cc3	c1 e0 00	 shl	 eax, 0
  02cc6	89 94 05 c8 fa
	ff ff		 mov	 DWORD PTR _searches_input_ptr$48[ebp+eax], edx

; 3986 :                 searches_result_line_no[1] = -1;

  02ccd	b8 04 00 00 00	 mov	 eax, 4
  02cd2	c1 e0 00	 shl	 eax, 0
  02cd5	c7 84 05 b8 fa
	ff ff ff ff ff
	ff		 mov	 DWORD PTR _searches_result_line_no$47[ebp+eax], -1

; 3987 :                 searches_remaining++;

  02ce0	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _searches_remaining$46[ebp]
  02ce6	83 c0 01	 add	 eax, 1
  02ce9	89 85 ac fa ff
	ff		 mov	 DWORD PTR _searches_remaining$46[ebp], eax
$LN147@InputTextE:

; 3988 :             }
; 3989 : 
; 3990 :             // Iterate all lines to find our line numbers
; 3991 :             // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
; 3992 :             searches_remaining += is_multiline ? 1 : 0;

  02cef	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  02cf3	85 c0		 test	 eax, eax
  02cf5	74 0c		 je	 SHORT $LN347@InputTextE
  02cf7	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1787[ebp], 1
  02d01	eb 0a		 jmp	 SHORT $LN348@InputTextE
$LN347@InputTextE:
  02d03	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1787[ebp], 0
$LN348@InputTextE:
  02d0d	8b 8d ac fa ff
	ff		 mov	 ecx, DWORD PTR _searches_remaining$46[ebp]
  02d13	03 8d 28 f4 ff
	ff		 add	 ecx, DWORD PTR tv1787[ebp]
  02d19	89 8d ac fa ff
	ff		 mov	 DWORD PTR _searches_remaining$46[ebp], ecx

; 3993 :             int line_count = 0;

  02d1f	c7 85 a0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _line_count$45[ebp], 0

; 3994 :             //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bit
; 3995 :             for (const ImWchar* s = text_begin; *s != 0; s++)

  02d29	8b 85 f8 fa ff
	ff		 mov	 eax, DWORD PTR _text_begin$51[ebp]
  02d2f	89 85 94 fa ff
	ff		 mov	 DWORD PTR _s$44[ebp], eax
  02d35	eb 0f		 jmp	 SHORT $LN10@InputTextE
$LN8@InputTextE:
  02d37	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _s$44[ebp]
  02d3d	83 c0 02	 add	 eax, 2
  02d40	89 85 94 fa ff
	ff		 mov	 DWORD PTR _s$44[ebp], eax
$LN10@InputTextE:
  02d46	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _s$44[ebp]
  02d4c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  02d4f	85 c9		 test	 ecx, ecx
  02d51	0f 84 d6 00 00
	00		 je	 $LN9@InputTextE

; 3996 :                 if (*s == '\n')

  02d57	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _s$44[ebp]
  02d5d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  02d60	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  02d63	0f 85 bf 00 00
	00		 jne	 $LN152@InputTextE

; 3997 :                 {
; 3998 :                     line_count++;

  02d69	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR _line_count$45[ebp]
  02d6f	83 c0 01	 add	 eax, 1
  02d72	89 85 a0 fa ff
	ff		 mov	 DWORD PTR _line_count$45[ebp], eax

; 3999 :                     if (searches_result_line_no[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_no[0] = line_count; if (--searches_remaining <= 0) break; }

  02d78	b8 04 00 00 00	 mov	 eax, 4
  02d7d	6b c8 00	 imul	 ecx, eax, 0
  02d80	83 bc 0d b8 fa
	ff ff ff	 cmp	 DWORD PTR _searches_result_line_no$47[ebp+ecx], -1
  02d88	75 46		 jne	 SHORT $LN150@InputTextE
  02d8a	b8 04 00 00 00	 mov	 eax, 4
  02d8f	6b c8 00	 imul	 ecx, eax, 0
  02d92	8b 95 94 fa ff
	ff		 mov	 edx, DWORD PTR _s$44[ebp]
  02d98	3b 94 0d c8 fa
	ff ff		 cmp	 edx, DWORD PTR _searches_input_ptr$48[ebp+ecx]
  02d9f	72 2f		 jb	 SHORT $LN150@InputTextE
  02da1	b8 04 00 00 00	 mov	 eax, 4
  02da6	6b c8 00	 imul	 ecx, eax, 0
  02da9	8b 95 a0 fa ff
	ff		 mov	 edx, DWORD PTR _line_count$45[ebp]
  02daf	89 94 0d b8 fa
	ff ff		 mov	 DWORD PTR _searches_result_line_no$47[ebp+ecx], edx
  02db6	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _searches_remaining$46[ebp]
  02dbc	83 e8 01	 sub	 eax, 1
  02dbf	89 85 ac fa ff
	ff		 mov	 DWORD PTR _searches_remaining$46[ebp], eax
  02dc5	83 bd ac fa ff
	ff 00		 cmp	 DWORD PTR _searches_remaining$46[ebp], 0
  02dcc	7f 02		 jg	 SHORT $LN150@InputTextE
  02dce	eb 5d		 jmp	 SHORT $LN9@InputTextE
$LN150@InputTextE:

; 4000 :                     if (searches_result_line_no[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_no[1] = line_count; if (--searches_remaining <= 0) break; }

  02dd0	b8 04 00 00 00	 mov	 eax, 4
  02dd5	c1 e0 00	 shl	 eax, 0
  02dd8	83 bc 05 b8 fa
	ff ff ff	 cmp	 DWORD PTR _searches_result_line_no$47[ebp+eax], -1
  02de0	75 46		 jne	 SHORT $LN152@InputTextE
  02de2	b8 04 00 00 00	 mov	 eax, 4
  02de7	c1 e0 00	 shl	 eax, 0
  02dea	8b 8d 94 fa ff
	ff		 mov	 ecx, DWORD PTR _s$44[ebp]
  02df0	3b 8c 05 c8 fa
	ff ff		 cmp	 ecx, DWORD PTR _searches_input_ptr$48[ebp+eax]
  02df7	72 2f		 jb	 SHORT $LN152@InputTextE
  02df9	b8 04 00 00 00	 mov	 eax, 4
  02dfe	c1 e0 00	 shl	 eax, 0
  02e01	8b 8d a0 fa ff
	ff		 mov	 ecx, DWORD PTR _line_count$45[ebp]
  02e07	89 8c 05 b8 fa
	ff ff		 mov	 DWORD PTR _searches_result_line_no$47[ebp+eax], ecx
  02e0e	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _searches_remaining$46[ebp]
  02e14	83 e8 01	 sub	 eax, 1
  02e17	89 85 ac fa ff
	ff		 mov	 DWORD PTR _searches_remaining$46[ebp], eax
  02e1d	83 bd ac fa ff
	ff 00		 cmp	 DWORD PTR _searches_remaining$46[ebp], 0
  02e24	7f 02		 jg	 SHORT $LN152@InputTextE
  02e26	eb 05		 jmp	 SHORT $LN9@InputTextE
$LN152@InputTextE:

; 4001 :                 }

  02e28	e9 0a ff ff ff	 jmp	 $LN8@InputTextE
$LN9@InputTextE:

; 4002 :             line_count++;

  02e2d	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR _line_count$45[ebp]
  02e33	83 c0 01	 add	 eax, 1
  02e36	89 85 a0 fa ff
	ff		 mov	 DWORD PTR _line_count$45[ebp], eax

; 4003 :             if (searches_result_line_no[0] == -1)

  02e3c	b8 04 00 00 00	 mov	 eax, 4
  02e41	6b c8 00	 imul	 ecx, eax, 0
  02e44	83 bc 0d b8 fa
	ff ff ff	 cmp	 DWORD PTR _searches_result_line_no$47[ebp+ecx], -1
  02e4c	75 15		 jne	 SHORT $LN153@InputTextE

; 4004 :                 searches_result_line_no[0] = line_count;

  02e4e	b8 04 00 00 00	 mov	 eax, 4
  02e53	6b c8 00	 imul	 ecx, eax, 0
  02e56	8b 95 a0 fa ff
	ff		 mov	 edx, DWORD PTR _line_count$45[ebp]
  02e5c	89 94 0d b8 fa
	ff ff		 mov	 DWORD PTR _searches_result_line_no$47[ebp+ecx], edx
$LN153@InputTextE:

; 4005 :             if (searches_result_line_no[1] == -1)

  02e63	b8 04 00 00 00	 mov	 eax, 4
  02e68	c1 e0 00	 shl	 eax, 0
  02e6b	83 bc 05 b8 fa
	ff ff ff	 cmp	 DWORD PTR _searches_result_line_no$47[ebp+eax], -1
  02e73	75 15		 jne	 SHORT $LN154@InputTextE

; 4006 :                 searches_result_line_no[1] = line_count;

  02e75	b8 04 00 00 00	 mov	 eax, 4
  02e7a	c1 e0 00	 shl	 eax, 0
  02e7d	8b 8d a0 fa ff
	ff		 mov	 ecx, DWORD PTR _line_count$45[ebp]
  02e83	89 8c 05 b8 fa
	ff ff		 mov	 DWORD PTR _searches_result_line_no$47[ebp+eax], ecx
$LN154@InputTextE:

; 4007 : 
; 4008 :             // Calculate 2d position by finding the beginning of the line and measuring distance
; 4009 :             cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;

  02e8a	6a 00		 push	 0
  02e8c	6a 00		 push	 0
  02e8e	6a 00		 push	 0
  02e90	b8 04 00 00 00	 mov	 eax, 4
  02e95	6b c8 00	 imul	 ecx, eax, 0
  02e98	8b 94 0d c8 fa
	ff ff		 mov	 edx, DWORD PTR _searches_input_ptr$48[ebp+ecx]
  02e9f	52		 push	 edx
  02ea0	8b 85 f8 fa ff
	ff		 mov	 eax, DWORD PTR _text_begin$51[ebp]
  02ea6	50		 push	 eax
  02ea7	b9 04 00 00 00	 mov	 ecx, 4
  02eac	6b d1 00	 imul	 edx, ecx, 0
  02eaf	8b 84 15 c8 fa
	ff ff		 mov	 eax, DWORD PTR _searches_input_ptr$48[ebp+edx]
  02eb6	50		 push	 eax
  02eb7	e8 00 00 00 00	 call	 ?ImStrbolW@@YAPBGPBG0@Z	; ImStrbolW
  02ebc	83 c4 08	 add	 esp, 8
  02ebf	50		 push	 eax
  02ec0	8d 8d 68 f5 ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  02ec6	51		 push	 ecx
  02ec7	e8 00 00 00 00	 call	 ?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW
  02ecc	83 c4 18	 add	 esp, 24			; 00000018H
  02ecf	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  02ed3	f3 0f 11 85 e8
	fa ff ff	 movss	 DWORD PTR _cursor_offset$50[ebp], xmm0

; 4010 :             cursor_offset.y = searches_result_line_no[0] * g.FontSize;

  02edb	b8 04 00 00 00	 mov	 eax, 4
  02ee0	6b c8 00	 imul	 ecx, eax, 0
  02ee3	f3 0f 2a 84 0d
	b8 fa ff ff	 cvtsi2ss xmm0, DWORD PTR _searches_result_line_no$47[ebp+ecx]
  02eec	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  02eef	f3 0f 59 82 c4
	18 00 00	 mulss	 xmm0, DWORD PTR [edx+6340]
  02ef7	f3 0f 11 85 ec
	fa ff ff	 movss	 DWORD PTR _cursor_offset$50[ebp+4], xmm0

; 4011 :             if (searches_result_line_no[1] >= 0)

  02eff	b8 04 00 00 00	 mov	 eax, 4
  02f04	c1 e0 00	 shl	 eax, 0
  02f07	83 bc 05 b8 fa
	ff ff 00	 cmp	 DWORD PTR _searches_result_line_no$47[ebp+eax], 0
  02f0f	7c 75		 jl	 SHORT $LN155@InputTextE

; 4012 :             {
; 4013 :                 select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;

  02f11	6a 00		 push	 0
  02f13	6a 00		 push	 0
  02f15	6a 00		 push	 0
  02f17	b8 04 00 00 00	 mov	 eax, 4
  02f1c	c1 e0 00	 shl	 eax, 0
  02f1f	8b 8c 05 c8 fa
	ff ff		 mov	 ecx, DWORD PTR _searches_input_ptr$48[ebp+eax]
  02f26	51		 push	 ecx
  02f27	8b 95 f8 fa ff
	ff		 mov	 edx, DWORD PTR _text_begin$51[ebp]
  02f2d	52		 push	 edx
  02f2e	b8 04 00 00 00	 mov	 eax, 4
  02f33	c1 e0 00	 shl	 eax, 0
  02f36	8b 8c 05 c8 fa
	ff ff		 mov	 ecx, DWORD PTR _searches_input_ptr$48[ebp+eax]
  02f3d	51		 push	 ecx
  02f3e	e8 00 00 00 00	 call	 ?ImStrbolW@@YAPBGPBG0@Z	; ImStrbolW
  02f43	83 c4 08	 add	 esp, 8
  02f46	50		 push	 eax
  02f47	8d 95 58 f5 ff
	ff		 lea	 edx, DWORD PTR $T18[ebp]
  02f4d	52		 push	 edx
  02f4e	e8 00 00 00 00	 call	 ?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW
  02f53	83 c4 18	 add	 esp, 24			; 00000018H
  02f56	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  02f5a	f3 0f 11 85 d8
	fa ff ff	 movss	 DWORD PTR _select_start_offset$49[ebp], xmm0

; 4014 :                 select_start_offset.y = searches_result_line_no[1] * g.FontSize;

  02f62	b8 04 00 00 00	 mov	 eax, 4
  02f67	c1 e0 00	 shl	 eax, 0
  02f6a	f3 0f 2a 84 05
	b8 fa ff ff	 cvtsi2ss xmm0, DWORD PTR _searches_result_line_no$47[ebp+eax]
  02f73	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  02f76	f3 0f 59 81 c4
	18 00 00	 mulss	 xmm0, DWORD PTR [ecx+6340]
  02f7e	f3 0f 11 85 dc
	fa ff ff	 movss	 DWORD PTR _select_start_offset$49[ebp+4], xmm0
$LN155@InputTextE:

; 4015 :             }
; 4016 : 
; 4017 :             // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
; 4018 :             if (is_multiline)

  02f86	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  02f8a	85 c0		 test	 eax, eax
  02f8c	74 43		 je	 SHORT $LN156@InputTextE

; 4019 :                 text_size = ImVec2(inner_size.x, line_count * g.FontSize);

  02f8e	f3 0f 2a 85 a0
	fa ff ff	 cvtsi2ss xmm0, DWORD PTR _line_count$45[ebp]
  02f96	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  02f99	f3 0f 59 80 c4
	18 00 00	 mulss	 xmm0, DWORD PTR [eax+6340]
  02fa1	51		 push	 ecx
  02fa2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02fa7	51		 push	 ecx
  02fa8	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _inner_size$[ebp]
  02fb0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02fb5	8d 8d 48 f5 ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  02fbb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  02fc0	8b 08		 mov	 ecx, DWORD PTR [eax]
  02fc2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02fc5	89 8d 28 fb ff
	ff		 mov	 DWORD PTR _text_size$[ebp], ecx
  02fcb	89 95 2c fb ff
	ff		 mov	 DWORD PTR _text_size$[ebp+4], edx
$LN156@InputTextE:

; 4020 :         }
; 4021 : 
; 4022 :         // Scroll
; 4023 :         if (render_cursor && state->CursorFollow)

  02fd1	0f b6 85 37 fe
	ff ff		 movzx	 eax, BYTE PTR _render_cursor$[ebp]
  02fd8	85 c0		 test	 eax, eax
  02fda	0f 84 d5 01 00
	00		 je	 $LN157@InputTextE
  02fe0	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  02fe6	0f b6 88 64 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3684]
  02fed	85 c9		 test	 ecx, ecx
  02fef	0f 84 c0 01 00
	00		 je	 $LN157@InputTextE

; 4024 :         {
; 4025 :             // Horizontal scroll in chunks of quarter width
; 4026 :             if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))

  02ff5	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  02ff8	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  02ffd	0f 85 bf 00 00
	00		 jne	 $LN158@InputTextE

; 4027 :             {
; 4028 :                 const float scroll_increment_x = inner_size.x * 0.25f;

  03003	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _inner_size$[ebp]
  0300b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e800000
  03013	f3 0f 11 85 88
	fa ff ff	 movss	 DWORD PTR _scroll_increment_x$43[ebp], xmm0

; 4029 :                 if (cursor_offset.x < state->ScrollX)

  0301b	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  03021	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  03026	0f 2f 85 e8 fa
	ff ff		 comiss	 xmm0, DWORD PTR _cursor_offset$50[ebp]
  0302d	76 4a		 jbe	 SHORT $LN160@InputTextE

; 4030 :                     state->ScrollX = IM_FLOOR(ImMax(0.0f, cursor_offset.x - scroll_increment_x));

  0302f	f3 0f 10 85 e8
	fa ff ff	 movss	 xmm0, DWORD PTR _cursor_offset$50[ebp]
  03037	f3 0f 5c 85 88
	fa ff ff	 subss	 xmm0, DWORD PTR _scroll_increment_x$43[ebp]
  0303f	51		 push	 ecx
  03040	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03045	51		 push	 ecx
  03046	0f 57 c0	 xorps	 xmm0, xmm0
  03049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0304e	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  03053	83 c4 08	 add	 esp, 8
  03056	d9 9d 28 f4 ff
	ff		 fstp	 DWORD PTR tv3272[ebp]
  0305c	f3 0f 10 85 28
	f4 ff ff	 movss	 xmm0, DWORD PTR tv3272[ebp]
  03064	f3 0f 2c c0	 cvttss2si eax, xmm0
  03068	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0306c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  03072	f3 0f 11 41 38	 movss	 DWORD PTR [ecx+56], xmm0
  03077	eb 47		 jmp	 SHORT $LN162@InputTextE
$LN160@InputTextE:

; 4031 :                 else if (cursor_offset.x - inner_size.x >= state->ScrollX)

  03079	f3 0f 10 85 e8
	fa ff ff	 movss	 xmm0, DWORD PTR _cursor_offset$50[ebp]
  03081	f3 0f 5c 85 00
	ff ff ff	 subss	 xmm0, DWORD PTR _inner_size$[ebp]
  03089	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0308f	0f 2f 40 38	 comiss	 xmm0, DWORD PTR [eax+56]
  03093	72 2b		 jb	 SHORT $LN162@InputTextE

; 4032 :                     state->ScrollX = IM_FLOOR(cursor_offset.x - inner_size.x + scroll_increment_x);

  03095	f3 0f 10 85 e8
	fa ff ff	 movss	 xmm0, DWORD PTR _cursor_offset$50[ebp]
  0309d	f3 0f 5c 85 00
	ff ff ff	 subss	 xmm0, DWORD PTR _inner_size$[ebp]
  030a5	f3 0f 58 85 88
	fa ff ff	 addss	 xmm0, DWORD PTR _scroll_increment_x$43[ebp]
  030ad	f3 0f 2c c0	 cvttss2si eax, xmm0
  030b1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  030b5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _state$[ebp]
  030bb	f3 0f 11 41 38	 movss	 DWORD PTR [ecx+56], xmm0
$LN162@InputTextE:

; 4033 :             }

  030c0	eb 0e		 jmp	 SHORT $LN159@InputTextE
$LN158@InputTextE:

; 4034 :             else
; 4035 :             {
; 4036 :                 state->ScrollX = 0.0f;

  030c2	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  030c8	0f 57 c0	 xorps	 xmm0, xmm0
  030cb	f3 0f 11 40 38	 movss	 DWORD PTR [eax+56], xmm0
$LN159@InputTextE:

; 4037 :             }
; 4038 : 
; 4039 :             // Vertical scroll
; 4040 :             if (is_multiline)

  030d0	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  030d4	85 c0		 test	 eax, eax
  030d6	0f 84 cc 00 00
	00		 je	 $LN163@InputTextE

; 4041 :             {
; 4042 :                 float scroll_y = draw_window->Scroll.y;

  030dc	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  030e2	f3 0f 10 40 54	 movss	 xmm0, DWORD PTR [eax+84]
  030e7	f3 0f 11 85 7c
	fa ff ff	 movss	 DWORD PTR _scroll_y$42[ebp], xmm0

; 4043 :                 if (cursor_offset.y - g.FontSize < scroll_y)

  030ef	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  030f2	f3 0f 10 85 ec
	fa ff ff	 movss	 xmm0, DWORD PTR _cursor_offset$50[ebp+4]
  030fa	f3 0f 5c 80 c4
	18 00 00	 subss	 xmm0, DWORD PTR [eax+6340]
  03102	f3 0f 10 8d 7c
	fa ff ff	 movss	 xmm1, DWORD PTR _scroll_y$42[ebp]
  0310a	0f 2f c8	 comiss	 xmm1, xmm0
  0310d	76 32		 jbe	 SHORT $LN164@InputTextE

; 4044 :                     scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);

  0310f	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  03112	f3 0f 10 85 ec
	fa ff ff	 movss	 xmm0, DWORD PTR _cursor_offset$50[ebp+4]
  0311a	f3 0f 5c 80 c4
	18 00 00	 subss	 xmm0, DWORD PTR [eax+6340]
  03122	51		 push	 ecx
  03123	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03128	51		 push	 ecx
  03129	0f 57 c0	 xorps	 xmm0, xmm0
  0312c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03131	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  03136	83 c4 08	 add	 esp, 8
  03139	d9 9d 7c fa ff
	ff		 fstp	 DWORD PTR _scroll_y$42[ebp]
  0313f	eb 31		 jmp	 SHORT $LN166@InputTextE
$LN164@InputTextE:

; 4045 :                 else if (cursor_offset.y - inner_size.y >= scroll_y)

  03141	f3 0f 10 85 ec
	fa ff ff	 movss	 xmm0, DWORD PTR _cursor_offset$50[ebp+4]
  03149	f3 0f 5c 85 04
	ff ff ff	 subss	 xmm0, DWORD PTR _inner_size$[ebp+4]
  03151	0f 2f 85 7c fa
	ff ff		 comiss	 xmm0, DWORD PTR _scroll_y$42[ebp]
  03158	72 18		 jb	 SHORT $LN166@InputTextE

; 4046 :                     scroll_y = cursor_offset.y - inner_size.y;

  0315a	f3 0f 10 85 ec
	fa ff ff	 movss	 xmm0, DWORD PTR _cursor_offset$50[ebp+4]
  03162	f3 0f 5c 85 04
	ff ff ff	 subss	 xmm0, DWORD PTR _inner_size$[ebp+4]
  0316a	f3 0f 11 85 7c
	fa ff ff	 movss	 DWORD PTR _scroll_y$42[ebp], xmm0
$LN166@InputTextE:

; 4047 :                 draw_pos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag

  03172	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  03178	f3 0f 10 40 54	 movss	 xmm0, DWORD PTR [eax+84]
  0317d	f3 0f 5c 85 7c
	fa ff ff	 subss	 xmm0, DWORD PTR _scroll_y$42[ebp]
  03185	f3 0f 58 85 3c
	fb ff ff	 addss	 xmm0, DWORD PTR _draw_pos$[ebp+4]
  0318d	f3 0f 11 85 3c
	fb ff ff	 movss	 DWORD PTR _draw_pos$[ebp+4], xmm0

; 4048 :                 draw_window->Scroll.y = scroll_y;

  03195	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  0319b	f3 0f 10 85 7c
	fa ff ff	 movss	 xmm0, DWORD PTR _scroll_y$42[ebp]
  031a3	f3 0f 11 40 54	 movss	 DWORD PTR [eax+84], xmm0
$LN163@InputTextE:

; 4049 :             }
; 4050 : 
; 4051 :             state->CursorFollow = false;

  031a8	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  031ae	c6 80 64 0e 00
	00 00		 mov	 BYTE PTR [eax+3684], 0
$LN157@InputTextE:

; 4052 :         }
; 4053 : 
; 4054 :         // Draw selection
; 4055 :         const ImVec2 draw_scroll = ImVec2(state->ScrollX, 0.0f);

  031b5	51		 push	 ecx
  031b6	0f 57 c0	 xorps	 xmm0, xmm0
  031b9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  031be	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  031c4	51		 push	 ecx
  031c5	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  031ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  031cf	8d 8d 6c fa ff
	ff		 lea	 ecx, DWORD PTR _draw_scroll$41[ebp]
  031d5	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4056 :         if (render_selection)

  031da	0f b6 85 2b fe
	ff ff		 movzx	 eax, BYTE PTR _render_selection$[ebp]
  031e1	85 c0		 test	 eax, eax
  031e3	0f 84 a1 03 00
	00		 je	 $LN12@InputTextE

; 4057 :         {
; 4058 :             const ImWchar* text_selected_begin = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);

  031e9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  031ef	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  031f2	51		 push	 ecx
  031f3	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  031f9	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  031fc	50		 push	 eax
  031fd	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  03202	83 c4 08	 add	 esp, 8
  03205	8b 8d f8 fa ff
	ff		 mov	 ecx, DWORD PTR _text_begin$51[ebp]
  0320b	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0320e	89 95 60 fa ff
	ff		 mov	 DWORD PTR _text_selected_begin$40[ebp], edx

; 4059 :             const ImWchar* text_selected_end = text_begin + ImMax(state->Stb.select_start, state->Stb.select_end);

  03214	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  0321a	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0321d	51		 push	 ecx
  0321e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  03224	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  03227	50		 push	 eax
  03228	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  0322d	83 c4 08	 add	 esp, 8
  03230	8b 8d f8 fa ff
	ff		 mov	 ecx, DWORD PTR _text_begin$51[ebp]
  03236	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  03239	89 95 54 fa ff
	ff		 mov	 DWORD PTR _text_selected_end$39[ebp], edx

; 4060 : 
; 4061 :             ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.

  0323f	0f b6 85 37 fe
	ff ff		 movzx	 eax, BYTE PTR _render_cursor$[ebp]
  03246	85 c0		 test	 eax, eax
  03248	74 12		 je	 SHORT $LN349@InputTextE
  0324a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  03252	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv1956[ebp], xmm0
  0325a	eb 10		 jmp	 SHORT $LN350@InputTextE
$LN349@InputTextE:
  0325c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  03264	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv1956[ebp], xmm0
$LN350@InputTextE:
  0326c	51		 push	 ecx
  0326d	f3 0f 10 85 28
	f4 ff ff	 movss	 xmm0, DWORD PTR tv1956[ebp]
  03275	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0327a	6a 2a		 push	 42			; 0000002aH
  0327c	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  03281	83 c4 08	 add	 esp, 8
  03284	89 85 48 fa ff
	ff		 mov	 DWORD PTR _bg_color$38[ebp], eax

; 4062 :             float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.

  0328a	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  0328e	85 c0		 test	 eax, eax
  03290	74 0d		 je	 SHORT $LN351@InputTextE
  03292	0f 57 c0	 xorps	 xmm0, xmm0
  03295	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv1961[ebp], xmm0
  0329d	eb 10		 jmp	 SHORT $LN352@InputTextE
$LN351@InputTextE:
  0329f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  032a7	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv1961[ebp], xmm0
$LN352@InputTextE:
  032af	f3 0f 10 85 28
	f4 ff ff	 movss	 xmm0, DWORD PTR tv1961[ebp]
  032b7	f3 0f 11 85 3c
	fa ff ff	 movss	 DWORD PTR _bg_offy_up$37[ebp], xmm0

; 4063 :             float bg_offy_dn = is_multiline ? 0.0f : 2.0f;

  032bf	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  032c3	85 c0		 test	 eax, eax
  032c5	74 0d		 je	 SHORT $LN353@InputTextE
  032c7	0f 57 c0	 xorps	 xmm0, xmm0
  032ca	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv1964[ebp], xmm0
  032d2	eb 10		 jmp	 SHORT $LN354@InputTextE
$LN353@InputTextE:
  032d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  032dc	f3 0f 11 85 28
	f4 ff ff	 movss	 DWORD PTR tv1964[ebp], xmm0
$LN354@InputTextE:
  032e4	f3 0f 10 85 28
	f4 ff ff	 movss	 xmm0, DWORD PTR tv1964[ebp]
  032ec	f3 0f 11 85 30
	fa ff ff	 movss	 DWORD PTR _bg_offy_dn$36[ebp], xmm0

; 4064 :             ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;

  032f4	8d 85 6c fa ff
	ff		 lea	 eax, DWORD PTR _draw_scroll$41[ebp]
  032fa	50		 push	 eax
  032fb	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _select_start_offset$49[ebp]
  03301	51		 push	 ecx
  03302	8d 95 38 fb ff
	ff		 lea	 edx, DWORD PTR _draw_pos$[ebp]
  03308	52		 push	 edx
  03309	8d 85 38 f5 ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  0330f	50		 push	 eax
  03310	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  03315	83 c4 0c	 add	 esp, 12			; 0000000cH
  03318	50		 push	 eax
  03319	8d 8d 20 fa ff
	ff		 lea	 ecx, DWORD PTR _rect_pos$35[ebp]
  0331f	51		 push	 ecx
  03320	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  03325	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4065 :             for (const ImWchar* p = text_selected_begin; p < text_selected_end; )

  03328	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _text_selected_begin$40[ebp]
  0332e	89 85 14 fa ff
	ff		 mov	 DWORD PTR _p$34[ebp], eax
$LN11@InputTextE:
  03334	8b 85 14 fa ff
	ff		 mov	 eax, DWORD PTR _p$34[ebp]
  0333a	3b 85 54 fa ff
	ff		 cmp	 eax, DWORD PTR _text_selected_end$39[ebp]
  03340	0f 83 44 02 00
	00		 jae	 $LN12@InputTextE

; 4066 :             {
; 4067 :                 if (rect_pos.y > clip_rect.w + g.FontSize)

  03346	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  03349	f3 0f 10 85 54
	fb ff ff	 movss	 xmm0, DWORD PTR _clip_rect$[ebp+12]
  03351	f3 0f 58 80 c4
	18 00 00	 addss	 xmm0, DWORD PTR [eax+6340]
  03359	f3 0f 10 8d 24
	fa ff ff	 movss	 xmm1, DWORD PTR _rect_pos$35[ebp+4]
  03361	0f 2f c8	 comiss	 xmm1, xmm0
  03364	76 05		 jbe	 SHORT $LN168@InputTextE

; 4068 :                     break;

  03366	e9 1f 02 00 00	 jmp	 $LN12@InputTextE
$LN168@InputTextE:

; 4069 :                 if (rect_pos.y < clip_rect.y)

  0336b	f3 0f 10 85 4c
	fb ff ff	 movss	 xmm0, DWORD PTR _clip_rect$[ebp+4]
  03373	0f 2f 85 24 fa
	ff ff		 comiss	 xmm0, DWORD PTR _rect_pos$35[ebp+4]
  0337a	76 5d		 jbe	 SHORT $LN169@InputTextE
$LN14@InputTextE:

; 4070 :                 {
; 4071 :                     //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bit
; 4072 :                     //p = p ? p + 1 : text_selected_end;
; 4073 :                     while (p < text_selected_end)

  0337c	8b 85 14 fa ff
	ff		 mov	 eax, DWORD PTR _p$34[ebp]
  03382	3b 85 54 fa ff
	ff		 cmp	 eax, DWORD PTR _text_selected_end$39[ebp]
  03388	73 4a		 jae	 SHORT $LN15@InputTextE

; 4074 :                         if (*p++ == '\n')

  0338a	8b 85 14 fa ff
	ff		 mov	 eax, DWORD PTR _p$34[ebp]
  03390	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  03393	89 8d 28 f4 ff
	ff		 mov	 DWORD PTR tv1981[ebp], ecx
  03399	8b 95 14 fa ff
	ff		 mov	 edx, DWORD PTR _p$34[ebp]
  0339f	83 c2 02	 add	 edx, 2
  033a2	89 95 14 fa ff
	ff		 mov	 DWORD PTR _p$34[ebp], edx
  033a8	83 bd 28 f4 ff
	ff 0a		 cmp	 DWORD PTR tv1981[ebp], 10 ; 0000000aH
  033af	75 0c		 jne	 SHORT $LN355@InputTextE
  033b1	c7 85 24 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1982[ebp], 1
  033bb	eb 0a		 jmp	 SHORT $LN356@InputTextE
$LN355@InputTextE:
  033bd	c7 85 24 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1982[ebp], 0
$LN356@InputTextE:
  033c7	83 bd 24 f4 ff
	ff 00		 cmp	 DWORD PTR tv1982[ebp], 0
  033ce	74 02		 je	 SHORT $LN171@InputTextE

; 4075 :                             break;

  033d0	eb 02		 jmp	 SHORT $LN15@InputTextE
$LN171@InputTextE:
  033d2	eb a8		 jmp	 SHORT $LN14@InputTextE
$LN15@InputTextE:

; 4076 :                 }

  033d4	e9 79 01 00 00	 jmp	 $LN173@InputTextE
$LN169@InputTextE:

; 4077 :                 else
; 4078 :                 {
; 4079 :                     ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);

  033d9	6a 01		 push	 1
  033db	6a 00		 push	 0
  033dd	8d 85 14 fa ff
	ff		 lea	 eax, DWORD PTR _p$34[ebp]
  033e3	50		 push	 eax
  033e4	8b 8d 54 fa ff
	ff		 mov	 ecx, DWORD PTR _text_selected_end$39[ebp]
  033ea	51		 push	 ecx
  033eb	8b 95 14 fa ff
	ff		 mov	 edx, DWORD PTR _p$34[ebp]
  033f1	52		 push	 edx
  033f2	8d 85 04 fa ff
	ff		 lea	 eax, DWORD PTR _rect_size$33[ebp]
  033f8	50		 push	 eax
  033f9	e8 00 00 00 00	 call	 ?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW
  033fe	83 c4 18	 add	 esp, 24			; 00000018H

; 4080 :                     if (rect_size.x <= 0.0f) rect_size.x = IM_FLOOR(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines

  03401	0f 57 c0	 xorps	 xmm0, xmm0
  03404	0f 2f 85 04 fa
	ff ff		 comiss	 xmm0, DWORD PTR _rect_size$33[ebp]
  0340b	72 36		 jb	 SHORT $LN172@InputTextE
  0340d	6a 20		 push	 32			; 00000020H
  0340f	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  03412	8b 88 c0 18 00
	00		 mov	 ecx, DWORD PTR [eax+6336]
  03418	e8 00 00 00 00	 call	 ?GetCharAdvance@ImFont@@QBEMG@Z ; ImFont::GetCharAdvance
  0341d	d9 9d 28 f4 ff
	ff		 fstp	 DWORD PTR tv3352[ebp]
  03423	f3 0f 10 85 28
	f4 ff ff	 movss	 xmm0, DWORD PTR tv3352[ebp]
  0342b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  03433	f3 0f 2c c8	 cvttss2si ecx, xmm0
  03437	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0343b	f3 0f 11 85 04
	fa ff ff	 movss	 DWORD PTR _rect_size$33[ebp], xmm0
$LN172@InputTextE:

; 4081 :                     ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));

  03443	51		 push	 ecx
  03444	f3 0f 10 85 30
	fa ff ff	 movss	 xmm0, DWORD PTR _bg_offy_dn$36[ebp]
  0344c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03451	51		 push	 ecx
  03452	f3 0f 10 85 04
	fa ff ff	 movss	 xmm0, DWORD PTR _rect_size$33[ebp]
  0345a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0345f	8d 8d 28 f5 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  03465	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0346a	50		 push	 eax
  0346b	8d 85 20 fa ff
	ff		 lea	 eax, DWORD PTR _rect_pos$35[ebp]
  03471	50		 push	 eax
  03472	8d 8d 18 f5 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  03478	51		 push	 ecx
  03479	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0347e	83 c4 0c	 add	 esp, 12			; 0000000cH
  03481	50		 push	 eax
  03482	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  03485	f3 0f 10 85 3c
	fa ff ff	 movss	 xmm0, DWORD PTR _bg_offy_up$37[ebp]
  0348d	f3 0f 5c 82 c4
	18 00 00	 subss	 xmm0, DWORD PTR [edx+6340]
  03495	51		 push	 ecx
  03496	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0349b	51		 push	 ecx
  0349c	0f 57 c0	 xorps	 xmm0, xmm0
  0349f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  034a4	8d 8d 08 f5 ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  034aa	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  034af	50		 push	 eax
  034b0	8d 85 20 fa ff
	ff		 lea	 eax, DWORD PTR _rect_pos$35[ebp]
  034b6	50		 push	 eax
  034b7	8d 8d f8 f4 ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  034bd	51		 push	 ecx
  034be	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  034c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  034c6	50		 push	 eax
  034c7	8d 8d ec f9 ff
	ff		 lea	 ecx, DWORD PTR _rect$32[ebp]
  034cd	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 4082 :                     rect.ClipWith(clip_rect);

  034d2	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _clip_rect$[ebp]
  034d8	50		 push	 eax
  034d9	8d 8d e0 f4 ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  034df	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec4@@@Z ; ImRect::ImRect
  034e4	8d 8d e0 f4 ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  034ea	51		 push	 ecx
  034eb	8d 8d ec f9 ff
	ff		 lea	 ecx, DWORD PTR _rect$32[ebp]
  034f1	e8 00 00 00 00	 call	 ?ClipWith@ImRect@@QAEXABU1@@Z ; ImRect::ClipWith

; 4083 :                     if (rect.Overlaps(clip_rect))

  034f6	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _clip_rect$[ebp]
  034fc	50		 push	 eax
  034fd	8d 8d c8 f4 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  03503	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec4@@@Z ; ImRect::ImRect
  03508	8d 8d c8 f4 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0350e	51		 push	 ecx
  0350f	8d 8d ec f9 ff
	ff		 lea	 ecx, DWORD PTR _rect$32[ebp]
  03515	e8 00 00 00 00	 call	 ?Overlaps@ImRect@@QBE_NABU1@@Z ; ImRect::Overlaps
  0351a	0f b6 d0	 movzx	 edx, al
  0351d	85 d2		 test	 edx, edx
  0351f	74 31		 je	 SHORT $LN173@InputTextE

; 4084 :                         draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);

  03521	6a 0f		 push	 15			; 0000000fH
  03523	51		 push	 ecx
  03524	0f 57 c0	 xorps	 xmm0, xmm0
  03527	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0352c	8b 85 48 fa ff
	ff		 mov	 eax, DWORD PTR _bg_color$38[ebp]
  03532	50		 push	 eax
  03533	8d 8d f4 f9 ff
	ff		 lea	 ecx, DWORD PTR _rect$32[ebp+8]
  03539	51		 push	 ecx
  0353a	8d 95 ec f9 ff
	ff		 lea	 edx, DWORD PTR _rect$32[ebp]
  03540	52		 push	 edx
  03541	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  03547	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  0354d	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN173@InputTextE:

; 4085 :                 }
; 4086 :                 rect_pos.x = draw_pos.x - draw_scroll.x;

  03552	f3 0f 10 85 38
	fb ff ff	 movss	 xmm0, DWORD PTR _draw_pos$[ebp]
  0355a	f3 0f 5c 85 6c
	fa ff ff	 subss	 xmm0, DWORD PTR _draw_scroll$41[ebp]
  03562	f3 0f 11 85 20
	fa ff ff	 movss	 DWORD PTR _rect_pos$35[ebp], xmm0

; 4087 :                 rect_pos.y += g.FontSize;

  0356a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0356d	f3 0f 10 85 24
	fa ff ff	 movss	 xmm0, DWORD PTR _rect_pos$35[ebp+4]
  03575	f3 0f 58 80 c4
	18 00 00	 addss	 xmm0, DWORD PTR [eax+6340]
  0357d	f3 0f 11 85 24
	fa ff ff	 movss	 DWORD PTR _rect_pos$35[ebp+4], xmm0

; 4088 :             }

  03585	e9 aa fd ff ff	 jmp	 $LN11@InputTextE
$LN12@InputTextE:

; 4089 :         }
; 4090 : 
; 4091 :         // We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
; 4092 :         if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)

  0358a	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  0358e	85 c0		 test	 eax, eax
  03590	75 17		 jne	 SHORT $LN175@InputTextE
  03592	8b 85 04 fb ff
	ff		 mov	 eax, DWORD PTR _buf_display_end$[ebp]
  03598	2b 85 10 fb ff
	ff		 sub	 eax, DWORD PTR _buf_display$[ebp]
  0359e	3d 00 00 20 00	 cmp	 eax, 2097152		; 00200000H
  035a3	0f 8d d3 00 00
	00		 jge	 $LN174@InputTextE
$LN175@InputTextE:

; 4093 :         {
; 4094 :             ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);

  035a9	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  035b0	85 c0		 test	 eax, eax
  035b2	74 0c		 je	 SHORT $LN357@InputTextE
  035b4	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv2081[ebp], 1
  035be	eb 0a		 jmp	 SHORT $LN358@InputTextE
$LN357@InputTextE:
  035c0	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv2081[ebp], 0
$LN358@InputTextE:
  035ca	51		 push	 ecx
  035cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  035d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  035d8	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv2081[ebp]
  035de	51		 push	 ecx
  035df	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  035e4	83 c4 08	 add	 esp, 8
  035e7	89 85 e0 f9 ff
	ff		 mov	 DWORD PTR _col$31[ebp], eax

; 4095 :             draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);

  035ed	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  035f1	85 c0		 test	 eax, eax
  035f3	74 0c		 je	 SHORT $LN359@InputTextE
  035f5	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv2087[ebp], 0
  035ff	eb 0c		 jmp	 SHORT $LN360@InputTextE
$LN359@InputTextE:
  03601	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _clip_rect$[ebp]
  03607	89 8d 28 f4 ff
	ff		 mov	 DWORD PTR tv2087[ebp], ecx
$LN360@InputTextE:
  0360d	8b 95 28 f4 ff
	ff		 mov	 edx, DWORD PTR tv2087[ebp]
  03613	52		 push	 edx
  03614	51		 push	 ecx
  03615	0f 57 c0	 xorps	 xmm0, xmm0
  03618	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0361d	8b 85 04 fb ff
	ff		 mov	 eax, DWORD PTR _buf_display_end$[ebp]
  03623	50		 push	 eax
  03624	8b 8d 10 fb ff
	ff		 mov	 ecx, DWORD PTR _buf_display$[ebp]
  0362a	51		 push	 ecx
  0362b	8b 95 e0 f9 ff
	ff		 mov	 edx, DWORD PTR _col$31[ebp]
  03631	52		 push	 edx
  03632	8d 85 6c fa ff
	ff		 lea	 eax, DWORD PTR _draw_scroll$41[ebp]
  03638	50		 push	 eax
  03639	8d 8d 38 fb ff
	ff		 lea	 ecx, DWORD PTR _draw_pos$[ebp]
  0363f	51		 push	 ecx
  03640	8d 95 b8 f4 ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  03646	52		 push	 edx
  03647	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  0364c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0364f	50		 push	 eax
  03650	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  03653	51		 push	 ecx
  03654	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  0365c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03661	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  03664	8b 91 c0 18 00
	00		 mov	 edx, DWORD PTR [ecx+6336]
  0366a	52		 push	 edx
  0366b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _draw_window$[ebp]
  03671	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  03677	e8 00 00 00 00	 call	 ?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText
$LN174@InputTextE:

; 4096 :         }
; 4097 : 
; 4098 :         // Draw blinking cursor
; 4099 :         if (render_cursor)

  0367c	0f b6 85 37 fe
	ff ff		 movzx	 eax, BYTE PTR _render_cursor$[ebp]
  03683	85 c0		 test	 eax, eax
  03685	0f 84 1f 02 00
	00		 je	 $LN178@InputTextE

; 4100 :         {
; 4101 :             state->CursorAnim += io.DeltaTime;

  0368b	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  03691	8b 4d dc	 mov	 ecx, DWORD PTR _io$[ebp]
  03694	f3 0f 10 80 60
	0e 00 00	 movss	 xmm0, DWORD PTR [eax+3680]
  0369c	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  036a1	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  036a7	f3 0f 11 82 60
	0e 00 00	 movss	 DWORD PTR [edx+3680], xmm0

; 4102 :             bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;

  036af	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  036b2	0f b6 88 b2 00
	00 00		 movzx	 ecx, BYTE PTR [eax+178]
  036b9	85 c9		 test	 ecx, ecx
  036bb	74 5f		 je	 SHORT $LN361@InputTextE
  036bd	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _state$[ebp]
  036c3	0f 57 c0	 xorps	 xmm0, xmm0
  036c6	0f 2f 82 60 0e
	00 00		 comiss	 xmm0, DWORD PTR [edx+3680]
  036cd	73 4d		 jae	 SHORT $LN361@InputTextE
  036cf	51		 push	 ecx
  036d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f99999a
  036d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  036dd	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  036e3	51		 push	 ecx
  036e4	f3 0f 10 80 60
	0e 00 00	 movss	 xmm0, DWORD PTR [eax+3680]
  036ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  036f1	e8 00 00 00 00	 call	 ?ImFmod@@YAMMM@Z	; ImFmod
  036f6	83 c4 08	 add	 esp, 8
  036f9	d9 9d 28 f4 ff
	ff		 fstp	 DWORD PTR tv3421[ebp]
  036ff	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  03707	0f 2f 85 28 f4
	ff ff		 comiss	 xmm0, DWORD PTR tv3421[ebp]
  0370e	73 0c		 jae	 SHORT $LN361@InputTextE
  03710	c7 85 24 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv2119[ebp], 0
  0371a	eb 0a		 jmp	 SHORT $LN362@InputTextE
$LN361@InputTextE:
  0371c	c7 85 24 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv2119[ebp], 1
$LN362@InputTextE:
  03726	8a 8d 24 f4 ff
	ff		 mov	 cl, BYTE PTR tv2119[ebp]
  0372c	88 8d d7 f9 ff
	ff		 mov	 BYTE PTR _cursor_is_visible$30[ebp], cl

; 4103 :             ImVec2 cursor_screen_pos = draw_pos + cursor_offset - draw_scroll;

  03732	8d 85 6c fa ff
	ff		 lea	 eax, DWORD PTR _draw_scroll$41[ebp]
  03738	50		 push	 eax
  03739	8d 8d e8 fa ff
	ff		 lea	 ecx, DWORD PTR _cursor_offset$50[ebp]
  0373f	51		 push	 ecx
  03740	8d 95 38 fb ff
	ff		 lea	 edx, DWORD PTR _draw_pos$[ebp]
  03746	52		 push	 edx
  03747	8d 85 a8 f4 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  0374d	50		 push	 eax
  0374e	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  03753	83 c4 0c	 add	 esp, 12			; 0000000cH
  03756	50		 push	 eax
  03757	8d 8d c4 f9 ff
	ff		 lea	 ecx, DWORD PTR _cursor_screen_pos$29[ebp]
  0375d	51		 push	 ecx
  0375e	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  03763	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4104 :             ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);

  03766	f3 0f 10 85 c8
	f9 ff ff	 movss	 xmm0, DWORD PTR _cursor_screen_pos$29[ebp+4]
  0376e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3fc00000
  03776	51		 push	 ecx
  03777	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0377c	f3 0f 10 85 c4
	f9 ff ff	 movss	 xmm0, DWORD PTR _cursor_screen_pos$29[ebp]
  03784	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0378c	51		 push	 ecx
  0378d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03792	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  03795	f3 0f 10 85 c8
	f9 ff ff	 movss	 xmm0, DWORD PTR _cursor_screen_pos$29[ebp+4]
  0379d	f3 0f 5c 80 c4
	18 00 00	 subss	 xmm0, DWORD PTR [eax+6340]
  037a5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  037ad	51		 push	 ecx
  037ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  037b3	51		 push	 ecx
  037b4	f3 0f 10 85 c4
	f9 ff ff	 movss	 xmm0, DWORD PTR _cursor_screen_pos$29[ebp]
  037bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  037c1	8d 8d ac f9 ff
	ff		 lea	 ecx, DWORD PTR _cursor_screen_rect$28[ebp]
  037c7	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect

; 4105 :             if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))

  037cc	0f b6 85 d7 f9
	ff ff		 movzx	 eax, BYTE PTR _cursor_is_visible$30[ebp]
  037d3	85 c0		 test	 eax, eax
  037d5	74 7d		 je	 SHORT $LN177@InputTextE
  037d7	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _clip_rect$[ebp]
  037dd	50		 push	 eax
  037de	8d 8d 90 f4 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  037e4	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec4@@@Z ; ImRect::ImRect
  037e9	8d 8d 90 f4 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  037ef	51		 push	 ecx
  037f0	8d 8d ac f9 ff
	ff		 lea	 ecx, DWORD PTR _cursor_screen_rect$28[ebp]
  037f6	e8 00 00 00 00	 call	 ?Overlaps@ImRect@@QBE_NABU1@@Z ; ImRect::Overlaps
  037fb	0f b6 d0	 movzx	 edx, al
  037fe	85 d2		 test	 edx, edx
  03800	74 52		 je	 SHORT $LN177@InputTextE

; 4106 :                 draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

  03802	51		 push	 ecx
  03803	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0380b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03810	51		 push	 ecx
  03811	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  03819	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0381e	6a 00		 push	 0
  03820	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  03825	83 c4 08	 add	 esp, 8
  03828	50		 push	 eax
  03829	8d 85 80 f4 ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0382f	50		 push	 eax
  03830	8d 8d ac f9 ff
	ff		 lea	 ecx, DWORD PTR _cursor_screen_rect$28[ebp]
  03836	e8 00 00 00 00	 call	 ?GetBL@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetBL
  0383b	50		 push	 eax
  0383c	8d 8d ac f9 ff
	ff		 lea	 ecx, DWORD PTR _cursor_screen_rect$28[ebp]
  03842	51		 push	 ecx
  03843	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _draw_window$[ebp]
  03849	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  0384f	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN177@InputTextE:

; 4107 : 
; 4108 :             // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
; 4109 :             if (!is_readonly)

  03854	0f b6 45 af	 movzx	 eax, BYTE PTR _is_readonly$[ebp]
  03858	85 c0		 test	 eax, eax
  0385a	75 4e		 jne	 SHORT $LN178@InputTextE

; 4110 :                 g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);

  0385c	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0385f	f3 0f 10 85 c8
	f9 ff ff	 movss	 xmm0, DWORD PTR _cursor_screen_pos$29[ebp+4]
  03867	f3 0f 5c 80 c4
	18 00 00	 subss	 xmm0, DWORD PTR [eax+6340]
  0386f	51		 push	 ecx
  03870	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03875	f3 0f 10 85 c4
	f9 ff ff	 movss	 xmm0, DWORD PTR _cursor_screen_pos$29[ebp]
  0387d	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  03885	51		 push	 ecx
  03886	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0388b	8d 8d 70 f4 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  03891	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  03896	8b 08		 mov	 ecx, DWORD PTR [eax]
  03898	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0389b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0389e	89 88 1c 2d 00
	00		 mov	 DWORD PTR [eax+11548], ecx
  038a4	89 90 20 2d 00
	00		 mov	 DWORD PTR [eax+11552], edx
$LN178@InputTextE:

; 4111 :         }
; 4112 :     }

  038aa	e9 93 01 00 00	 jmp	 $LN184@InputTextE
$LN142@InputTextE:

; 4113 :     else
; 4114 :     {
; 4115 :         // Render text only (no selection, no cursor)
; 4116 :         if (is_multiline)

  038af	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  038b3	85 c0		 test	 eax, eax
  038b5	74 57		 je	 SHORT $LN179@InputTextE

; 4117 :             text_size = ImVec2(inner_size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) * g.FontSize); // We don't need width

  038b7	8d 85 04 fb ff
	ff		 lea	 eax, DWORD PTR _buf_display_end$[ebp]
  038bd	50		 push	 eax
  038be	8b 8d 10 fb ff
	ff		 mov	 ecx, DWORD PTR _buf_display$[ebp]
  038c4	51		 push	 ecx
  038c5	e8 00 00 00 00	 call	 ?InputTextCalcTextLenAndLineCount@@YAHPBDPAPBD@Z ; InputTextCalcTextLenAndLineCount
  038ca	83 c4 08	 add	 esp, 8
  038cd	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  038d1	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  038d4	f3 0f 59 82 c4
	18 00 00	 mulss	 xmm0, DWORD PTR [edx+6340]
  038dc	51		 push	 ecx
  038dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  038e2	51		 push	 ecx
  038e3	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _inner_size$[ebp]
  038eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  038f0	8d 8d 60 f4 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  038f6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  038fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  038fd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03900	89 8d 28 fb ff
	ff		 mov	 DWORD PTR _text_size$[ebp], ecx
  03906	89 95 2c fb ff
	ff		 mov	 DWORD PTR _text_size$[ebp+4], edx
  0390c	eb 59		 jmp	 SHORT $LN183@InputTextE
$LN179@InputTextE:

; 4118 :         else if (!is_displaying_hint && g.ActiveId == id)

  0390e	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  03915	85 c0		 test	 eax, eax
  03917	75 28		 jne	 SHORT $LN181@InputTextE
  03919	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0391c	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  03922	3b 8d 7c ff ff
	ff		 cmp	 ecx, DWORD PTR _id$[ebp]
  03928	75 17		 jne	 SHORT $LN181@InputTextE

; 4119 :             buf_display_end = buf_display + state->CurLenA;

  0392a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _state$[ebp]
  03930	8b 8d 10 fb ff
	ff		 mov	 ecx, DWORD PTR _buf_display$[ebp]
  03936	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  03939	89 8d 04 fb ff
	ff		 mov	 DWORD PTR _buf_display_end$[ebp], ecx
  0393f	eb 26		 jmp	 SHORT $LN183@InputTextE
$LN181@InputTextE:

; 4120 :         else if (!is_displaying_hint)

  03941	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  03948	85 c0		 test	 eax, eax
  0394a	75 1b		 jne	 SHORT $LN183@InputTextE

; 4121 :             buf_display_end = buf_display + strlen(buf_display);

  0394c	8b 85 10 fb ff
	ff		 mov	 eax, DWORD PTR _buf_display$[ebp]
  03952	50		 push	 eax
  03953	e8 00 00 00 00	 call	 _strlen
  03958	83 c4 04	 add	 esp, 4
  0395b	03 85 10 fb ff
	ff		 add	 eax, DWORD PTR _buf_display$[ebp]
  03961	89 85 04 fb ff
	ff		 mov	 DWORD PTR _buf_display_end$[ebp], eax
$LN183@InputTextE:

; 4122 : 
; 4123 :         if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)

  03967	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  0396b	85 c0		 test	 eax, eax
  0396d	75 17		 jne	 SHORT $LN185@InputTextE
  0396f	8b 85 04 fb ff
	ff		 mov	 eax, DWORD PTR _buf_display_end$[ebp]
  03975	2b 85 10 fb ff
	ff		 sub	 eax, DWORD PTR _buf_display$[ebp]
  0397b	3d 00 00 20 00	 cmp	 eax, 2097152		; 00200000H
  03980	0f 8d bc 00 00
	00		 jge	 $LN184@InputTextE
$LN185@InputTextE:

; 4124 :         {
; 4125 :             ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);

  03986	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  0398d	85 c0		 test	 eax, eax
  0398f	74 0c		 je	 SHORT $LN363@InputTextE
  03991	c7 85 28 f4 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv2234[ebp], 1
  0399b	eb 0a		 jmp	 SHORT $LN364@InputTextE
$LN363@InputTextE:
  0399d	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv2234[ebp], 0
$LN364@InputTextE:
  039a7	51		 push	 ecx
  039a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  039b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  039b5	8b 8d 28 f4 ff
	ff		 mov	 ecx, DWORD PTR tv2234[ebp]
  039bb	51		 push	 ecx
  039bc	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  039c1	83 c4 08	 add	 esp, 8
  039c4	89 85 a0 f9 ff
	ff		 mov	 DWORD PTR _col$27[ebp], eax

; 4126 :             draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);

  039ca	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  039ce	85 c0		 test	 eax, eax
  039d0	74 0c		 je	 SHORT $LN365@InputTextE
  039d2	c7 85 28 f4 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv2240[ebp], 0
  039dc	eb 0c		 jmp	 SHORT $LN366@InputTextE
$LN365@InputTextE:
  039de	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _clip_rect$[ebp]
  039e4	89 8d 28 f4 ff
	ff		 mov	 DWORD PTR tv2240[ebp], ecx
$LN366@InputTextE:
  039ea	8b 95 28 f4 ff
	ff		 mov	 edx, DWORD PTR tv2240[ebp]
  039f0	52		 push	 edx
  039f1	51		 push	 ecx
  039f2	0f 57 c0	 xorps	 xmm0, xmm0
  039f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  039fa	8b 85 04 fb ff
	ff		 mov	 eax, DWORD PTR _buf_display_end$[ebp]
  03a00	50		 push	 eax
  03a01	8b 8d 10 fb ff
	ff		 mov	 ecx, DWORD PTR _buf_display$[ebp]
  03a07	51		 push	 ecx
  03a08	8b 95 a0 f9 ff
	ff		 mov	 edx, DWORD PTR _col$27[ebp]
  03a0e	52		 push	 edx
  03a0f	8d 85 38 fb ff
	ff		 lea	 eax, DWORD PTR _draw_pos$[ebp]
  03a15	50		 push	 eax
  03a16	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  03a19	51		 push	 ecx
  03a1a	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  03a22	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03a27	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  03a2a	8b 82 c0 18 00
	00		 mov	 eax, DWORD PTR [edx+6336]
  03a30	50		 push	 eax
  03a31	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _draw_window$[ebp]
  03a37	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  03a3d	e8 00 00 00 00	 call	 ?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText
$LN184@InputTextE:

; 4127 :         }
; 4128 :     }
; 4129 : 
; 4130 :     if (is_multiline)

  03a42	0f b6 45 bb	 movzx	 eax, BYTE PTR _is_multiline$[ebp]
  03a46	85 c0		 test	 eax, eax
  03a48	74 4f		 je	 SHORT $LN186@InputTextE

; 4131 :     {
; 4132 :         Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line

  03a4a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  03a4d	51		 push	 ecx
  03a4e	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  03a56	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03a5b	51		 push	 ecx
  03a5c	0f 57 c0	 xorps	 xmm0, xmm0
  03a5f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03a64	8d 8d 50 f4 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  03a6a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  03a6f	50		 push	 eax
  03a70	8d 8d 28 fb ff
	ff		 lea	 ecx, DWORD PTR _text_size$[ebp]
  03a76	51		 push	 ecx
  03a77	8d 95 40 f4 ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  03a7d	52		 push	 edx
  03a7e	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  03a83	83 c4 0c	 add	 esp, 12			; 0000000cH
  03a86	50		 push	 eax
  03a87	e8 00 00 00 00	 call	 ?Dummy@ImGui@@YAXABUImVec2@@@Z ; ImGui::Dummy
  03a8c	83 c4 04	 add	 esp, 4

; 4133 :         EndChildFrame();

  03a8f	e8 00 00 00 00	 call	 ?EndChildFrame@ImGui@@YAXXZ ; ImGui::EndChildFrame

; 4134 :         EndGroup();

  03a94	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup
$LN186@InputTextE:

; 4135 :     }
; 4136 : 
; 4137 :     if (is_password && !is_displaying_hint)

  03a99	0f b6 45 a3	 movzx	 eax, BYTE PTR _is_password$[ebp]
  03a9d	85 c0		 test	 eax, eax
  03a9f	74 10		 je	 SHORT $LN187@InputTextE
  03aa1	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  03aa8	85 c0		 test	 eax, eax
  03aaa	75 05		 jne	 SHORT $LN187@InputTextE

; 4138 :         PopFont();

  03aac	e8 00 00 00 00	 call	 ?PopFont@ImGui@@YAXXZ	; ImGui::PopFont
$LN187@InputTextE:

; 4139 : 
; 4140 :     // Log as text
; 4141 :     if (g.LogEnabled && !(is_password && !is_displaying_hint))

  03ab1	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  03ab4	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  03abb	85 c9		 test	 ecx, ecx
  03abd	74 30		 je	 SHORT $LN188@InputTextE
  03abf	0f b6 45 a3	 movzx	 eax, BYTE PTR _is_password$[ebp]
  03ac3	85 c0		 test	 eax, eax
  03ac5	74 0b		 je	 SHORT $LN189@InputTextE
  03ac7	0f b6 85 ef fd
	ff ff		 movzx	 eax, BYTE PTR _is_displaying_hint$[ebp]
  03ace	85 c0		 test	 eax, eax
  03ad0	74 1d		 je	 SHORT $LN188@InputTextE
$LN189@InputTextE:

; 4142 :         LogRenderedText(&draw_pos, buf_display, buf_display_end);

  03ad2	8b 85 04 fb ff
	ff		 mov	 eax, DWORD PTR _buf_display_end$[ebp]
  03ad8	50		 push	 eax
  03ad9	8b 8d 10 fb ff
	ff		 mov	 ecx, DWORD PTR _buf_display$[ebp]
  03adf	51		 push	 ecx
  03ae0	8d 95 38 fb ff
	ff		 lea	 edx, DWORD PTR _draw_pos$[ebp]
  03ae6	52		 push	 edx
  03ae7	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z ; ImGui::LogRenderedText
  03aec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN188@InputTextE:

; 4143 : 
; 4144 :     if (label_size.x > 0)

  03aef	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  03af7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  03afe	76 4e		 jbe	 SHORT $LN190@InputTextE

; 4145 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

  03b00	6a 01		 push	 1
  03b02	6a 00		 push	 0
  03b04	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  03b07	50		 push	 eax
  03b08	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  03b0b	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  03b13	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  03b18	51		 push	 ecx
  03b19	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03b1e	8b 55 d0	 mov	 edx, DWORD PTR _style$[ebp]
  03b21	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  03b29	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  03b2e	51		 push	 ecx
  03b2f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  03b34	8d 8d 30 f4 ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  03b3a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  03b3f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  03b42	51		 push	 ecx
  03b43	8b 10		 mov	 edx, DWORD PTR [eax]
  03b45	52		 push	 edx
  03b46	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  03b4b	83 c4 14	 add	 esp, 20			; 00000014H
$LN190@InputTextE:

; 4146 : 
; 4147 :     if (value_changed && !(flags & ImGuiInputTextFlags_NoMarkEdited))

  03b4e	0f b6 85 1f fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  03b55	85 c0		 test	 eax, eax
  03b57	74 19		 je	 SHORT $LN191@InputTextE
  03b59	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  03b5c	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  03b61	75 0f		 jne	 SHORT $LN191@InputTextE

; 4148 :         MarkItemEdited(id);

  03b63	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _id$[ebp]
  03b69	50		 push	 eax
  03b6a	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  03b6f	83 c4 04	 add	 esp, 4
$LN191@InputTextE:

; 4149 : 
; 4150 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);

  03b72	33 c0		 xor	 eax, eax
  03b74	75 fc		 jne	 SHORT $LN191@InputTextE

; 4151 :     if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)

  03b76	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  03b79	83 e0 20	 and	 eax, 32			; 00000020H
  03b7c	74 0a		 je	 SHORT $LN192@InputTextE

; 4152 :         return enter_pressed;

  03b7e	8a 85 13 fe ff
	ff		 mov	 al, BYTE PTR _enter_pressed$[ebp]
  03b84	eb 08		 jmp	 SHORT $LN193@InputTextE
  03b86	eb 06		 jmp	 SHORT $LN193@InputTextE
$LN192@InputTextE:

; 4153 :     else
; 4154 :         return value_changed;

  03b88	8a 85 1f fe ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]
$LN193@InputTextE:

; 4155 : }

  03b8e	52		 push	 edx
  03b8f	8b cd		 mov	 ecx, ebp
  03b91	50		 push	 eax
  03b92	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN397@InputTextE
  03b98	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  03b9d	58		 pop	 eax
  03b9e	5a		 pop	 edx
  03b9f	5f		 pop	 edi
  03ba0	5e		 pop	 esi
  03ba1	5b		 pop	 ebx
  03ba2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  03ba5	33 cd		 xor	 ecx, ebp
  03ba7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  03bac	81 c4 e4 0b 00
	00		 add	 esp, 3044		; 00000be4H
  03bb2	3b ec		 cmp	 ebp, esp
  03bb4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03bb9	8b e5		 mov	 esp, ebp
  03bbb	5d		 pop	 ebp
  03bbc	c3		 ret	 0
  03bbd	0f 1f 00	 npad	 3
$LN397@InputTextE:
  03bc0	1d 00 00 00	 DD	 29			; 0000001dH
  03bc4	00 00 00 00	 DD	 $LN396@InputTextE
$LN396@InputTextE:
  03bc8	6c ff ff ff	 DD	 -148			; ffffff6cH
  03bcc	08 00 00 00	 DD	 8
  03bd0	00 00 00 00	 DD	 $LN367@InputTextE
  03bd4	5c ff ff ff	 DD	 -164			; ffffff5cH
  03bd8	08 00 00 00	 DD	 8
  03bdc	00 00 00 00	 DD	 $LN368@InputTextE
  03be0	4c ff ff ff	 DD	 -180			; ffffff4cH
  03be4	08 00 00 00	 DD	 8
  03be8	00 00 00 00	 DD	 $LN369@InputTextE
  03bec	34 ff ff ff	 DD	 -204			; ffffff34H
  03bf0	10 00 00 00	 DD	 16			; 00000010H
  03bf4	00 00 00 00	 DD	 $LN370@InputTextE
  03bf8	1c ff ff ff	 DD	 -228			; ffffff1cH
  03bfc	10 00 00 00	 DD	 16			; 00000010H
  03c00	00 00 00 00	 DD	 $LN371@InputTextE
  03c04	00 ff ff ff	 DD	 -256			; ffffff00H
  03c08	08 00 00 00	 DD	 8
  03c0c	00 00 00 00	 DD	 $LN372@InputTextE
  03c10	4c fe ff ff	 DD	 -436			; fffffe4cH
  03c14	04 00 00 00	 DD	 4
  03c18	00 00 00 00	 DD	 $LN373@InputTextE
  03c1c	04 fe ff ff	 DD	 -508			; fffffe04H
  03c20	04 00 00 00	 DD	 4
  03c24	00 00 00 00	 DD	 $LN374@InputTextE
  03c28	8c fd ff ff	 DD	 -628			; fffffd8cH
  03c2c	04 00 00 00	 DD	 4
  03c30	00 00 00 00	 DD	 $LN375@InputTextE
  03c34	74 fd ff ff	 DD	 -652			; fffffd74H
  03c38	04 00 00 00	 DD	 4
  03c3c	00 00 00 00	 DD	 $LN376@InputTextE
  03c40	b4 fc ff ff	 DD	 -844			; fffffcb4H
  03c44	04 00 00 00	 DD	 4
  03c48	00 00 00 00	 DD	 $LN377@InputTextE
  03c4c	3c fc ff ff	 DD	 -964			; fffffc3cH
  03c50	04 00 00 00	 DD	 4
  03c54	00 00 00 00	 DD	 $LN378@InputTextE
  03c58	c8 fb ff ff	 DD	 -1080			; fffffbc8H
  03c5c	30 00 00 00	 DD	 48			; 00000030H
  03c60	00 00 00 00	 DD	 $LN379@InputTextE
  03c64	60 fb ff ff	 DD	 -1184			; fffffb60H
  03c68	30 00 00 00	 DD	 48			; 00000030H
  03c6c	00 00 00 00	 DD	 $LN380@InputTextE
  03c70	48 fb ff ff	 DD	 -1208			; fffffb48H
  03c74	10 00 00 00	 DD	 16			; 00000010H
  03c78	00 00 00 00	 DD	 $LN381@InputTextE
  03c7c	38 fb ff ff	 DD	 -1224			; fffffb38H
  03c80	08 00 00 00	 DD	 8
  03c84	00 00 00 00	 DD	 $LN382@InputTextE
  03c88	28 fb ff ff	 DD	 -1240			; fffffb28H
  03c8c	08 00 00 00	 DD	 8
  03c90	00 00 00 00	 DD	 $LN383@InputTextE
  03c94	04 fb ff ff	 DD	 -1276			; fffffb04H
  03c98	04 00 00 00	 DD	 4
  03c9c	00 00 00 00	 DD	 $LN384@InputTextE
  03ca0	e8 fa ff ff	 DD	 -1304			; fffffae8H
  03ca4	08 00 00 00	 DD	 8
  03ca8	00 00 00 00	 DD	 $LN385@InputTextE
  03cac	d8 fa ff ff	 DD	 -1320			; fffffad8H
  03cb0	08 00 00 00	 DD	 8
  03cb4	00 00 00 00	 DD	 $LN386@InputTextE
  03cb8	c8 fa ff ff	 DD	 -1336			; fffffac8H
  03cbc	08 00 00 00	 DD	 8
  03cc0	00 00 00 00	 DD	 $LN387@InputTextE
  03cc4	b8 fa ff ff	 DD	 -1352			; fffffab8H
  03cc8	08 00 00 00	 DD	 8
  03ccc	00 00 00 00	 DD	 $LN388@InputTextE
  03cd0	6c fa ff ff	 DD	 -1428			; fffffa6cH
  03cd4	08 00 00 00	 DD	 8
  03cd8	00 00 00 00	 DD	 $LN389@InputTextE
  03cdc	20 fa ff ff	 DD	 -1504			; fffffa20H
  03ce0	08 00 00 00	 DD	 8
  03ce4	00 00 00 00	 DD	 $LN390@InputTextE
  03ce8	14 fa ff ff	 DD	 -1516			; fffffa14H
  03cec	04 00 00 00	 DD	 4
  03cf0	00 00 00 00	 DD	 $LN391@InputTextE
  03cf4	04 fa ff ff	 DD	 -1532			; fffffa04H
  03cf8	08 00 00 00	 DD	 8
  03cfc	00 00 00 00	 DD	 $LN392@InputTextE
  03d00	ec f9 ff ff	 DD	 -1556			; fffff9ecH
  03d04	10 00 00 00	 DD	 16			; 00000010H
  03d08	00 00 00 00	 DD	 $LN393@InputTextE
  03d0c	c4 f9 ff ff	 DD	 -1596			; fffff9c4H
  03d10	08 00 00 00	 DD	 8
  03d14	00 00 00 00	 DD	 $LN394@InputTextE
  03d18	ac f9 ff ff	 DD	 -1620			; fffff9acH
  03d1c	10 00 00 00	 DD	 16			; 00000010H
  03d20	00 00 00 00	 DD	 $LN395@InputTextE
$LN395@InputTextE:
  03d24	63		 DB	 99			; 00000063H
  03d25	75		 DB	 117			; 00000075H
  03d26	72		 DB	 114			; 00000072H
  03d27	73		 DB	 115			; 00000073H
  03d28	6f		 DB	 111			; 0000006fH
  03d29	72		 DB	 114			; 00000072H
  03d2a	5f		 DB	 95			; 0000005fH
  03d2b	73		 DB	 115			; 00000073H
  03d2c	63		 DB	 99			; 00000063H
  03d2d	72		 DB	 114			; 00000072H
  03d2e	65		 DB	 101			; 00000065H
  03d2f	65		 DB	 101			; 00000065H
  03d30	6e		 DB	 110			; 0000006eH
  03d31	5f		 DB	 95			; 0000005fH
  03d32	72		 DB	 114			; 00000072H
  03d33	65		 DB	 101			; 00000065H
  03d34	63		 DB	 99			; 00000063H
  03d35	74		 DB	 116			; 00000074H
  03d36	00		 DB	 0
$LN394@InputTextE:
  03d37	63		 DB	 99			; 00000063H
  03d38	75		 DB	 117			; 00000075H
  03d39	72		 DB	 114			; 00000072H
  03d3a	73		 DB	 115			; 00000073H
  03d3b	6f		 DB	 111			; 0000006fH
  03d3c	72		 DB	 114			; 00000072H
  03d3d	5f		 DB	 95			; 0000005fH
  03d3e	73		 DB	 115			; 00000073H
  03d3f	63		 DB	 99			; 00000063H
  03d40	72		 DB	 114			; 00000072H
  03d41	65		 DB	 101			; 00000065H
  03d42	65		 DB	 101			; 00000065H
  03d43	6e		 DB	 110			; 0000006eH
  03d44	5f		 DB	 95			; 0000005fH
  03d45	70		 DB	 112			; 00000070H
  03d46	6f		 DB	 111			; 0000006fH
  03d47	73		 DB	 115			; 00000073H
  03d48	00		 DB	 0
$LN393@InputTextE:
  03d49	72		 DB	 114			; 00000072H
  03d4a	65		 DB	 101			; 00000065H
  03d4b	63		 DB	 99			; 00000063H
  03d4c	74		 DB	 116			; 00000074H
  03d4d	00		 DB	 0
$LN392@InputTextE:
  03d4e	72		 DB	 114			; 00000072H
  03d4f	65		 DB	 101			; 00000065H
  03d50	63		 DB	 99			; 00000063H
  03d51	74		 DB	 116			; 00000074H
  03d52	5f		 DB	 95			; 0000005fH
  03d53	73		 DB	 115			; 00000073H
  03d54	69		 DB	 105			; 00000069H
  03d55	7a		 DB	 122			; 0000007aH
  03d56	65		 DB	 101			; 00000065H
  03d57	00		 DB	 0
$LN391@InputTextE:
  03d58	70		 DB	 112			; 00000070H
  03d59	00		 DB	 0
$LN390@InputTextE:
  03d5a	72		 DB	 114			; 00000072H
  03d5b	65		 DB	 101			; 00000065H
  03d5c	63		 DB	 99			; 00000063H
  03d5d	74		 DB	 116			; 00000074H
  03d5e	5f		 DB	 95			; 0000005fH
  03d5f	70		 DB	 112			; 00000070H
  03d60	6f		 DB	 111			; 0000006fH
  03d61	73		 DB	 115			; 00000073H
  03d62	00		 DB	 0
$LN389@InputTextE:
  03d63	64		 DB	 100			; 00000064H
  03d64	72		 DB	 114			; 00000072H
  03d65	61		 DB	 97			; 00000061H
  03d66	77		 DB	 119			; 00000077H
  03d67	5f		 DB	 95			; 0000005fH
  03d68	73		 DB	 115			; 00000073H
  03d69	63		 DB	 99			; 00000063H
  03d6a	72		 DB	 114			; 00000072H
  03d6b	6f		 DB	 111			; 0000006fH
  03d6c	6c		 DB	 108			; 0000006cH
  03d6d	6c		 DB	 108			; 0000006cH
  03d6e	00		 DB	 0
$LN388@InputTextE:
  03d6f	73		 DB	 115			; 00000073H
  03d70	65		 DB	 101			; 00000065H
  03d71	61		 DB	 97			; 00000061H
  03d72	72		 DB	 114			; 00000072H
  03d73	63		 DB	 99			; 00000063H
  03d74	68		 DB	 104			; 00000068H
  03d75	65		 DB	 101			; 00000065H
  03d76	73		 DB	 115			; 00000073H
  03d77	5f		 DB	 95			; 0000005fH
  03d78	72		 DB	 114			; 00000072H
  03d79	65		 DB	 101			; 00000065H
  03d7a	73		 DB	 115			; 00000073H
  03d7b	75		 DB	 117			; 00000075H
  03d7c	6c		 DB	 108			; 0000006cH
  03d7d	74		 DB	 116			; 00000074H
  03d7e	5f		 DB	 95			; 0000005fH
  03d7f	6c		 DB	 108			; 0000006cH
  03d80	69		 DB	 105			; 00000069H
  03d81	6e		 DB	 110			; 0000006eH
  03d82	65		 DB	 101			; 00000065H
  03d83	5f		 DB	 95			; 0000005fH
  03d84	6e		 DB	 110			; 0000006eH
  03d85	6f		 DB	 111			; 0000006fH
  03d86	00		 DB	 0
$LN387@InputTextE:
  03d87	73		 DB	 115			; 00000073H
  03d88	65		 DB	 101			; 00000065H
  03d89	61		 DB	 97			; 00000061H
  03d8a	72		 DB	 114			; 00000072H
  03d8b	63		 DB	 99			; 00000063H
  03d8c	68		 DB	 104			; 00000068H
  03d8d	65		 DB	 101			; 00000065H
  03d8e	73		 DB	 115			; 00000073H
  03d8f	5f		 DB	 95			; 0000005fH
  03d90	69		 DB	 105			; 00000069H
  03d91	6e		 DB	 110			; 0000006eH
  03d92	70		 DB	 112			; 00000070H
  03d93	75		 DB	 117			; 00000075H
  03d94	74		 DB	 116			; 00000074H
  03d95	5f		 DB	 95			; 0000005fH
  03d96	70		 DB	 112			; 00000070H
  03d97	74		 DB	 116			; 00000074H
  03d98	72		 DB	 114			; 00000072H
  03d99	00		 DB	 0
$LN386@InputTextE:
  03d9a	73		 DB	 115			; 00000073H
  03d9b	65		 DB	 101			; 00000065H
  03d9c	6c		 DB	 108			; 0000006cH
  03d9d	65		 DB	 101			; 00000065H
  03d9e	63		 DB	 99			; 00000063H
  03d9f	74		 DB	 116			; 00000074H
  03da0	5f		 DB	 95			; 0000005fH
  03da1	73		 DB	 115			; 00000073H
  03da2	74		 DB	 116			; 00000074H
  03da3	61		 DB	 97			; 00000061H
  03da4	72		 DB	 114			; 00000072H
  03da5	74		 DB	 116			; 00000074H
  03da6	5f		 DB	 95			; 0000005fH
  03da7	6f		 DB	 111			; 0000006fH
  03da8	66		 DB	 102			; 00000066H
  03da9	66		 DB	 102			; 00000066H
  03daa	73		 DB	 115			; 00000073H
  03dab	65		 DB	 101			; 00000065H
  03dac	74		 DB	 116			; 00000074H
  03dad	00		 DB	 0
$LN385@InputTextE:
  03dae	63		 DB	 99			; 00000063H
  03daf	75		 DB	 117			; 00000075H
  03db0	72		 DB	 114			; 00000072H
  03db1	73		 DB	 115			; 00000073H
  03db2	6f		 DB	 111			; 0000006fH
  03db3	72		 DB	 114			; 00000072H
  03db4	5f		 DB	 95			; 0000005fH
  03db5	6f		 DB	 111			; 0000006fH
  03db6	66		 DB	 102			; 00000066H
  03db7	66		 DB	 102			; 00000066H
  03db8	73		 DB	 115			; 00000073H
  03db9	65		 DB	 101			; 00000065H
  03dba	74		 DB	 116			; 00000074H
  03dbb	00		 DB	 0
$LN384@InputTextE:
  03dbc	62		 DB	 98			; 00000062H
  03dbd	75		 DB	 117			; 00000075H
  03dbe	66		 DB	 102			; 00000066H
  03dbf	5f		 DB	 95			; 0000005fH
  03dc0	64		 DB	 100			; 00000064H
  03dc1	69		 DB	 105			; 00000069H
  03dc2	73		 DB	 115			; 00000073H
  03dc3	70		 DB	 112			; 00000070H
  03dc4	6c		 DB	 108			; 0000006cH
  03dc5	61		 DB	 97			; 00000061H
  03dc6	79		 DB	 121			; 00000079H
  03dc7	5f		 DB	 95			; 0000005fH
  03dc8	65		 DB	 101			; 00000065H
  03dc9	6e		 DB	 110			; 0000006eH
  03dca	64		 DB	 100			; 00000064H
  03dcb	00		 DB	 0
$LN383@InputTextE:
  03dcc	74		 DB	 116			; 00000074H
  03dcd	65		 DB	 101			; 00000065H
  03dce	78		 DB	 120			; 00000078H
  03dcf	74		 DB	 116			; 00000074H
  03dd0	5f		 DB	 95			; 0000005fH
  03dd1	73		 DB	 115			; 00000073H
  03dd2	69		 DB	 105			; 00000069H
  03dd3	7a		 DB	 122			; 0000007aH
  03dd4	65		 DB	 101			; 00000065H
  03dd5	00		 DB	 0
$LN382@InputTextE:
  03dd6	64		 DB	 100			; 00000064H
  03dd7	72		 DB	 114			; 00000072H
  03dd8	61		 DB	 97			; 00000061H
  03dd9	77		 DB	 119			; 00000077H
  03dda	5f		 DB	 95			; 0000005fH
  03ddb	70		 DB	 112			; 00000070H
  03ddc	6f		 DB	 111			; 0000006fH
  03ddd	73		 DB	 115			; 00000073H
  03dde	00		 DB	 0
$LN381@InputTextE:
  03ddf	63		 DB	 99			; 00000063H
  03de0	6c		 DB	 108			; 0000006cH
  03de1	69		 DB	 105			; 00000069H
  03de2	70		 DB	 112			; 00000070H
  03de3	5f		 DB	 95			; 0000005fH
  03de4	72		 DB	 114			; 00000072H
  03de5	65		 DB	 101			; 00000065H
  03de6	63		 DB	 99			; 00000063H
  03de7	74		 DB	 116			; 00000074H
  03de8	00		 DB	 0
$LN380@InputTextE:
  03de9	63		 DB	 99			; 00000063H
  03dea	61		 DB	 97			; 00000061H
  03deb	6c		 DB	 108			; 0000006cH
  03dec	6c		 DB	 108			; 0000006cH
  03ded	62		 DB	 98			; 00000062H
  03dee	61		 DB	 97			; 00000061H
  03def	63		 DB	 99			; 00000063H
  03df0	6b		 DB	 107			; 0000006bH
  03df1	5f		 DB	 95			; 0000005fH
  03df2	64		 DB	 100			; 00000064H
  03df3	61		 DB	 97			; 00000061H
  03df4	74		 DB	 116			; 00000074H
  03df5	61		 DB	 97			; 00000061H
  03df6	00		 DB	 0
$LN379@InputTextE:
  03df7	63		 DB	 99			; 00000063H
  03df8	61		 DB	 97			; 00000061H
  03df9	6c		 DB	 108			; 0000006cH
  03dfa	6c		 DB	 108			; 0000006cH
  03dfb	62		 DB	 98			; 00000062H
  03dfc	61		 DB	 97			; 00000061H
  03dfd	63		 DB	 99			; 00000063H
  03dfe	6b		 DB	 107			; 0000006bH
  03dff	5f		 DB	 95			; 0000005fH
  03e00	64		 DB	 100			; 00000064H
  03e01	61		 DB	 97			; 00000061H
  03e02	74		 DB	 116			; 00000074H
  03e03	61		 DB	 97			; 00000061H
  03e04	00		 DB	 0
$LN378@InputTextE:
  03e05	63		 DB	 99			; 00000063H
  03e06	00		 DB	 0
$LN377@InputTextE:
  03e07	63		 DB	 99			; 00000063H
  03e08	00		 DB	 0
$LN376@InputTextE:
  03e09	63		 DB	 99			; 00000063H
  03e0a	00		 DB	 0
$LN375@InputTextE:
  03e0b	63		 DB	 99			; 00000063H
  03e0c	00		 DB	 0
$LN374@InputTextE:
  03e0d	62		 DB	 98			; 00000062H
  03e0e	75		 DB	 117			; 00000075H
  03e0f	66		 DB	 102			; 00000066H
  03e10	5f		 DB	 95			; 0000005fH
  03e11	65		 DB	 101			; 00000065H
  03e12	6e		 DB	 110			; 0000006eH
  03e13	64		 DB	 100			; 00000064H
  03e14	00		 DB	 0
$LN373@InputTextE:
  03e15	62		 DB	 98			; 00000062H
  03e16	75		 DB	 117			; 00000075H
  03e17	66		 DB	 102			; 00000066H
  03e18	5f		 DB	 95			; 0000005fH
  03e19	65		 DB	 101			; 00000065H
  03e1a	6e		 DB	 110			; 0000006eH
  03e1b	64		 DB	 100			; 00000064H
  03e1c	00		 DB	 0
$LN372@InputTextE:
  03e1d	69		 DB	 105			; 00000069H
  03e1e	6e		 DB	 110			; 0000006eH
  03e1f	6e		 DB	 110			; 0000006eH
  03e20	65		 DB	 101			; 00000065H
  03e21	72		 DB	 114			; 00000072H
  03e22	5f		 DB	 95			; 0000005fH
  03e23	73		 DB	 115			; 00000073H
  03e24	69		 DB	 105			; 00000069H
  03e25	7a		 DB	 122			; 0000007aH
  03e26	65		 DB	 101			; 00000065H
  03e27	00		 DB	 0
$LN371@InputTextE:
  03e28	74		 DB	 116			; 00000074H
  03e29	6f		 DB	 111			; 0000006fH
  03e2a	74		 DB	 116			; 00000074H
  03e2b	61		 DB	 97			; 00000061H
  03e2c	6c		 DB	 108			; 0000006cH
  03e2d	5f		 DB	 95			; 0000005fH
  03e2e	62		 DB	 98			; 00000062H
  03e2f	62		 DB	 98			; 00000062H
  03e30	00		 DB	 0
$LN370@InputTextE:
  03e31	66		 DB	 102			; 00000066H
  03e32	72		 DB	 114			; 00000072H
  03e33	61		 DB	 97			; 00000061H
  03e34	6d		 DB	 109			; 0000006dH
  03e35	65		 DB	 101			; 00000065H
  03e36	5f		 DB	 95			; 0000005fH
  03e37	62		 DB	 98			; 00000062H
  03e38	62		 DB	 98			; 00000062H
  03e39	00		 DB	 0
$LN369@InputTextE:
  03e3a	74		 DB	 116			; 00000074H
  03e3b	6f		 DB	 111			; 0000006fH
  03e3c	74		 DB	 116			; 00000074H
  03e3d	61		 DB	 97			; 00000061H
  03e3e	6c		 DB	 108			; 0000006cH
  03e3f	5f		 DB	 95			; 0000005fH
  03e40	73		 DB	 115			; 00000073H
  03e41	69		 DB	 105			; 00000069H
  03e42	7a		 DB	 122			; 0000007aH
  03e43	65		 DB	 101			; 00000065H
  03e44	00		 DB	 0
$LN368@InputTextE:
  03e45	66		 DB	 102			; 00000066H
  03e46	72		 DB	 114			; 00000072H
  03e47	61		 DB	 97			; 00000061H
  03e48	6d		 DB	 109			; 0000006dH
  03e49	65		 DB	 101			; 00000065H
  03e4a	5f		 DB	 95			; 0000005fH
  03e4b	73		 DB	 115			; 00000073H
  03e4c	69		 DB	 105			; 00000069H
  03e4d	7a		 DB	 122			; 0000007aH
  03e4e	65		 DB	 101			; 00000065H
  03e4f	00		 DB	 0
$LN367@InputTextE:
  03e50	6c		 DB	 108			; 0000006cH
  03e51	61		 DB	 97			; 00000061H
  03e52	62		 DB	 98			; 00000062H
  03e53	65		 DB	 101			; 00000065H
  03e54	6c		 DB	 108			; 0000006cH
  03e55	5f		 DB	 95			; 0000005fH
  03e56	73		 DB	 115			; 00000073H
  03e57	69		 DB	 105			; 00000069H
  03e58	7a		 DB	 122			; 0000007aH
  03e59	65		 DB	 101			; 00000065H
  03e5a	00		 DB	 0
?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ENDP ; ImGui::InputTextEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z
_TEXT	SEGMENT
tv275 = -380						; size = 4
_v32$1 = -180						; size = 4
_arg1f$2 = -168						; size = 8
_arg0f$3 = -152						; size = 8
_v$4 = -136						; size = 4
_arg1f$5 = -124						; size = 4
_arg0f$6 = -112						; size = 4
_v$7 = -100						; size = 4
_arg1f$8 = -88						; size = 4
_arg0i$9 = -76						; size = 4
_v$10 = -64						; size = 4
_arg1i$ = -52						; size = 4
_type_info$ = -40					; size = 4
_data_backup$ = -28					; size = 8
_op$ = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_buf$ = 8						; size = 4
_initial_value_buf$ = 12				; size = 4
_data_type$ = 16					; size = 4
_p_data$ = 20						; size = 4
_format$ = 24						; size = 4
?DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z PROC	; ImGui::DataTypeApplyOpFromText, COMDAT

; 1760 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 84 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-380]
  00012	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@DataTypeAp:

; 1761 :     while (ImCharIsBlankA(*buf))

  00032	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00035	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?ImCharIsBlankA@@YA_ND@Z ; ImCharIsBlankA
  0003e	83 c4 04	 add	 esp, 4
  00041	0f b6 d0	 movzx	 edx, al
  00044	85 d2		 test	 edx, edx
  00046	74 0b		 je	 SHORT $LN3@DataTypeAp

; 1762 :         buf++;

  00048	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0004b	83 c0 01	 add	 eax, 1
  0004e	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax
  00051	eb df		 jmp	 SHORT $LN2@DataTypeAp
$LN3@DataTypeAp:

; 1763 : 
; 1764 :     // We don't support '-' op because it would conflict with inputing negative value.
; 1765 :     // Instead you can use +-100 to subtract from an existing value
; 1766 :     char op = buf[0];

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	6b c8 00	 imul	 ecx, eax, 0
  0005b	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0005e	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  00061	88 45 f7	 mov	 BYTE PTR _op$[ebp], al

; 1767 :     if (op == '+' || op == '*' || op == '/')

  00064	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  00068	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0006b	74 12		 je	 SHORT $LN8@DataTypeAp
  0006d	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  00071	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00074	74 09		 je	 SHORT $LN8@DataTypeAp
  00076	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  0007a	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0007d	75 2c		 jne	 SHORT $LN6@DataTypeAp
$LN8@DataTypeAp:

; 1768 :     {
; 1769 :         buf++;

  0007f	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax
$LN4@DataTypeAp:

; 1770 :         while (ImCharIsBlankA(*buf))

  00088	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0008b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?ImCharIsBlankA@@YA_ND@Z ; ImCharIsBlankA
  00094	83 c4 04	 add	 esp, 4
  00097	0f b6 d0	 movzx	 edx, al
  0009a	85 d2		 test	 edx, edx
  0009c	74 0b		 je	 SHORT $LN5@DataTypeAp

; 1771 :             buf++;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax
  000a7	eb df		 jmp	 SHORT $LN4@DataTypeAp
$LN5@DataTypeAp:

; 1772 :     }

  000a9	eb 04		 jmp	 SHORT $LN7@DataTypeAp
$LN6@DataTypeAp:

; 1773 :     else
; 1774 :     {
; 1775 :         op = 0;

  000ab	c6 45 f7 00	 mov	 BYTE PTR _op$[ebp], 0
$LN7@DataTypeAp:

; 1776 :     }
; 1777 :     if (!buf[0])

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	6b c8 00	 imul	 ecx, eax, 0
  000b7	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000ba	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000be	85 c0		 test	 eax, eax
  000c0	75 07		 jne	 SHORT $LN9@DataTypeAp

; 1778 :         return false;

  000c2	32 c0		 xor	 al, al
  000c4	e9 f2 04 00 00	 jmp	 $LN1@DataTypeAp
$LN9@DataTypeAp:

; 1779 : 
; 1780 :     // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
; 1781 :     IM_ASSERT(data_type < ImGuiDataType_COUNT);

  000c9	83 7d 10 0a	 cmp	 DWORD PTR _data_type$[ebp], 10 ; 0000000aH
  000cd	7c 25		 jl	 SHORT $LN58@DataTypeAp
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z@4JA
  000d4	83 c0 15	 add	 eax, 21			; 00000015H
  000d7	8b f4		 mov	 esi, esp
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@ILBKEPMO@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5?$AAI?$AAm?$AAG@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ed	3b f4		 cmp	 esi, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN58@DataTypeAp:

; 1782 :     int data_backup[2];
; 1783 :     const ImGuiDataTypeInfo* type_info = ImGui::DataTypeGetInfo(data_type);

  000f4	8b 45 10	 mov	 eax, DWORD PTR _data_type$[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z ; ImGui::DataTypeGetInfo
  000fd	83 c4 04	 add	 esp, 4
  00100	89 45 d8	 mov	 DWORD PTR _type_info$[ebp], eax

; 1784 :     IM_ASSERT(type_info->Size <= sizeof(data_backup));

  00103	8b 45 d8	 mov	 eax, DWORD PTR _type_info$[ebp]
  00106	83 38 08	 cmp	 DWORD PTR [eax], 8
  00109	76 26		 jbe	 SHORT $LN59@DataTypeAp
  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z@4JA
  00111	83 c1 18	 add	 ecx, 24			; 00000018H
  00114	8b f4		 mov	 esi, esp
  00116	51		 push	 ecx
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@OEMFLDEM@?$AAt?$AAy?$AAp?$AAe?$AA_?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe@
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012a	3b f4		 cmp	 esi, esp
  0012c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN59@DataTypeAp:

; 1785 :     memcpy(data_backup, p_data, type_info->Size);

  00131	8b 45 d8	 mov	 eax, DWORD PTR _type_info$[ebp]
  00134	8b 08		 mov	 ecx, DWORD PTR [eax]
  00136	51		 push	 ecx
  00137	8b 55 14	 mov	 edx, DWORD PTR _p_data$[ebp]
  0013a	52		 push	 edx
  0013b	8d 45 e4	 lea	 eax, DWORD PTR _data_backup$[ebp]
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 _memcpy
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1786 : 
; 1787 :     if (format == NULL)

  00147	83 7d 18 00	 cmp	 DWORD PTR _format$[ebp], 0
  0014b	75 09		 jne	 SHORT $LN10@DataTypeAp

; 1788 :         format = type_info->ScanFmt;

  0014d	8b 45 d8	 mov	 eax, DWORD PTR _type_info$[ebp]
  00150	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00153	89 4d 18	 mov	 DWORD PTR _format$[ebp], ecx
$LN10@DataTypeAp:

; 1789 : 
; 1790 :     // FIXME-LEGACY: The aim is to remove those operators and write a proper expression evaluator at some point..
; 1791 :     int arg1i = 0;

  00156	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _arg1i$[ebp], 0

; 1792 :     if (data_type == ImGuiDataType_S32)

  0015d	83 7d 10 04	 cmp	 DWORD PTR _data_type$[ebp], 4
  00161	0f 85 16 01 00
	00		 jne	 $LN11@DataTypeAp

; 1793 :     {
; 1794 :         int* v = (int*)p_data;

  00167	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  0016a	89 45 c0	 mov	 DWORD PTR _v$10[ebp], eax

; 1795 :         int arg0i = *v;

  0016d	8b 45 c0	 mov	 eax, DWORD PTR _v$10[ebp]
  00170	8b 08		 mov	 ecx, DWORD PTR [eax]
  00172	89 4d b4	 mov	 DWORD PTR _arg0i$9[ebp], ecx

; 1796 :         float arg1f = 0.0f;

  00175	0f 57 c0	 xorps	 xmm0, xmm0
  00178	f3 0f 11 45 a8	 movss	 DWORD PTR _arg1f$8[ebp], xmm0

; 1797 :         if (op && sscanf(initial_value_buf, format, &arg0i) < 1)

  0017d	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  00181	85 c0		 test	 eax, eax
  00183	74 20		 je	 SHORT $LN13@DataTypeAp
  00185	8d 45 b4	 lea	 eax, DWORD PTR _arg0i$9[ebp]
  00188	50		 push	 eax
  00189	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  0018c	51		 push	 ecx
  0018d	8b 55 0c	 mov	 edx, DWORD PTR _initial_value_buf$[ebp]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 _sscanf
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH
  00199	83 f8 01	 cmp	 eax, 1
  0019c	7d 07		 jge	 SHORT $LN13@DataTypeAp

; 1798 :             return false;

  0019e	32 c0		 xor	 al, al
  001a0	e9 16 04 00 00	 jmp	 $LN1@DataTypeAp
$LN13@DataTypeAp:

; 1799 :         // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
; 1800 :         if (op == '+')      { if (sscanf(buf, "%d", &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)

  001a5	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  001a9	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  001ac	75 29		 jne	 SHORT $LN14@DataTypeAp
  001ae	8d 45 cc	 lea	 eax, DWORD PTR _arg1i$[ebp]
  001b1	50		 push	 eax
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _sscanf
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c3	85 c0		 test	 eax, eax
  001c5	74 0b		 je	 SHORT $LN16@DataTypeAp
  001c7	8b 45 b4	 mov	 eax, DWORD PTR _arg0i$9[ebp]
  001ca	03 45 cc	 add	 eax, DWORD PTR _arg1i$[ebp]
  001cd	8b 4d c0	 mov	 ecx, DWORD PTR _v$10[ebp]
  001d0	89 01		 mov	 DWORD PTR [ecx], eax
$LN16@DataTypeAp:
  001d2	e9 a1 00 00 00	 jmp	 $LN23@DataTypeAp
$LN14@DataTypeAp:

; 1801 :         else if (op == '*') { if (sscanf(buf, "%f", &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply

  001d7	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  001db	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  001de	75 2e		 jne	 SHORT $LN17@DataTypeAp
  001e0	8d 45 a8	 lea	 eax, DWORD PTR _arg1f$8[ebp]
  001e3	50		 push	 eax
  001e4	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf@
  001e9	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 _sscanf
  001f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f5	85 c0		 test	 eax, eax
  001f7	74 13		 je	 SHORT $LN19@DataTypeAp
  001f9	f3 0f 2a 45 b4	 cvtsi2ss xmm0, DWORD PTR _arg0i$9[ebp]
  001fe	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR _arg1f$8[ebp]
  00203	f3 0f 2c c0	 cvttss2si eax, xmm0
  00207	8b 4d c0	 mov	 ecx, DWORD PTR _v$10[ebp]
  0020a	89 01		 mov	 DWORD PTR [ecx], eax
$LN19@DataTypeAp:
  0020c	eb 6a		 jmp	 SHORT $LN23@DataTypeAp
$LN17@DataTypeAp:

; 1802 :         else if (op == '/') { if (sscanf(buf, "%f", &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide

  0020e	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  00212	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00215	75 40		 jne	 SHORT $LN20@DataTypeAp
  00217	8d 45 a8	 lea	 eax, DWORD PTR _arg1f$8[ebp]
  0021a	50		 push	 eax
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf@
  00220	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00223	51		 push	 ecx
  00224	e8 00 00 00 00	 call	 _sscanf
  00229	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022c	85 c0		 test	 eax, eax
  0022e	74 25		 je	 SHORT $LN22@DataTypeAp
  00230	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _arg1f$8[ebp]
  00235	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0023c	9f		 lahf
  0023d	f6 c4 44	 test	 ah, 68			; 00000044H
  00240	7b 13		 jnp	 SHORT $LN22@DataTypeAp
  00242	f3 0f 2a 45 b4	 cvtsi2ss xmm0, DWORD PTR _arg0i$9[ebp]
  00247	f3 0f 5e 45 a8	 divss	 xmm0, DWORD PTR _arg1f$8[ebp]
  0024c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00250	8b 4d c0	 mov	 ecx, DWORD PTR _v$10[ebp]
  00253	89 01		 mov	 DWORD PTR [ecx], eax
$LN22@DataTypeAp:
  00255	eb 21		 jmp	 SHORT $LN23@DataTypeAp
$LN20@DataTypeAp:

; 1803 :         else                { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant

  00257	8d 45 cc	 lea	 eax, DWORD PTR _arg1i$[ebp]
  0025a	50		 push	 eax
  0025b	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  0025e	51		 push	 ecx
  0025f	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 _sscanf
  00268	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026b	83 f8 01	 cmp	 eax, 1
  0026e	75 08		 jne	 SHORT $LN23@DataTypeAp
  00270	8b 45 c0	 mov	 eax, DWORD PTR _v$10[ebp]
  00273	8b 4d cc	 mov	 ecx, DWORD PTR _arg1i$[ebp]
  00276	89 08		 mov	 DWORD PTR [eax], ecx
$LN23@DataTypeAp:

; 1804 :     }

  00278	e9 08 03 00 00	 jmp	 $LN60@DataTypeAp
$LN11@DataTypeAp:

; 1805 :     else if (data_type == ImGuiDataType_Float)

  0027d	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00281	0f 85 e0 00 00
	00		 jne	 $LN24@DataTypeAp

; 1806 :     {
; 1807 :         // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
; 1808 :         format = "%f";

  00287	c7 45 18 00 00
	00 00		 mov	 DWORD PTR _format$[ebp], OFFSET ??_C@_02NJPGOMH@?$CFf@

; 1809 :         float* v = (float*)p_data;

  0028e	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  00291	89 45 9c	 mov	 DWORD PTR _v$7[ebp], eax

; 1810 :         float arg0f = *v, arg1f = 0.0f;

  00294	8b 45 9c	 mov	 eax, DWORD PTR _v$7[ebp]
  00297	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0029b	f3 0f 11 45 90	 movss	 DWORD PTR _arg0f$6[ebp], xmm0
  002a0	0f 57 c0	 xorps	 xmm0, xmm0
  002a3	f3 0f 11 45 84	 movss	 DWORD PTR _arg1f$5[ebp], xmm0

; 1811 :         if (op && sscanf(initial_value_buf, format, &arg0f) < 1)

  002a8	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  002ac	85 c0		 test	 eax, eax
  002ae	74 20		 je	 SHORT $LN26@DataTypeAp
  002b0	8d 45 90	 lea	 eax, DWORD PTR _arg0f$6[ebp]
  002b3	50		 push	 eax
  002b4	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  002b7	51		 push	 ecx
  002b8	8b 55 0c	 mov	 edx, DWORD PTR _initial_value_buf$[ebp]
  002bb	52		 push	 edx
  002bc	e8 00 00 00 00	 call	 _sscanf
  002c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c4	83 f8 01	 cmp	 eax, 1
  002c7	7d 07		 jge	 SHORT $LN26@DataTypeAp

; 1812 :             return false;

  002c9	32 c0		 xor	 al, al
  002cb	e9 eb 02 00 00	 jmp	 $LN1@DataTypeAp
$LN26@DataTypeAp:

; 1813 :         if (sscanf(buf, format, &arg1f) < 1)

  002d0	8d 45 84	 lea	 eax, DWORD PTR _arg1f$5[ebp]
  002d3	50		 push	 eax
  002d4	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  002d7	51		 push	 ecx
  002d8	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  002db	52		 push	 edx
  002dc	e8 00 00 00 00	 call	 _sscanf
  002e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e4	83 f8 01	 cmp	 eax, 1
  002e7	7d 07		 jge	 SHORT $LN27@DataTypeAp

; 1814 :             return false;

  002e9	32 c0		 xor	 al, al
  002eb	e9 cb 02 00 00	 jmp	 $LN1@DataTypeAp
$LN27@DataTypeAp:

; 1815 :         if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)

  002f0	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  002f4	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  002f7	75 13		 jne	 SHORT $LN28@DataTypeAp
  002f9	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _arg0f$6[ebp]
  002fe	f3 0f 58 45 84	 addss	 xmm0, DWORD PTR _arg1f$5[ebp]
  00303	8b 45 9c	 mov	 eax, DWORD PTR _v$7[ebp]
  00306	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0030a	eb 56		 jmp	 SHORT $LN33@DataTypeAp
$LN28@DataTypeAp:

; 1816 :         else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply

  0030c	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  00310	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00313	75 13		 jne	 SHORT $LN30@DataTypeAp
  00315	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _arg0f$6[ebp]
  0031a	f3 0f 59 45 84	 mulss	 xmm0, DWORD PTR _arg1f$5[ebp]
  0031f	8b 45 9c	 mov	 eax, DWORD PTR _v$7[ebp]
  00322	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00326	eb 3a		 jmp	 SHORT $LN33@DataTypeAp
$LN30@DataTypeAp:

; 1817 :         else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide

  00328	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  0032c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0032f	75 25		 jne	 SHORT $LN32@DataTypeAp
  00331	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _arg1f$5[ebp]
  00336	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0033d	9f		 lahf
  0033e	f6 c4 44	 test	 ah, 68			; 00000044H
  00341	7b 11		 jnp	 SHORT $LN34@DataTypeAp
  00343	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _arg0f$6[ebp]
  00348	f3 0f 5e 45 84	 divss	 xmm0, DWORD PTR _arg1f$5[ebp]
  0034d	8b 45 9c	 mov	 eax, DWORD PTR _v$7[ebp]
  00350	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN34@DataTypeAp:
  00354	eb 0c		 jmp	 SHORT $LN33@DataTypeAp
$LN32@DataTypeAp:

; 1818 :         else                { *v = arg1f; }                            // Assign constant

  00356	8b 45 9c	 mov	 eax, DWORD PTR _v$7[ebp]
  00359	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _arg1f$5[ebp]
  0035e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN33@DataTypeAp:

; 1819 :     }

  00362	e9 1e 02 00 00	 jmp	 $LN60@DataTypeAp
$LN24@DataTypeAp:

; 1820 :     else if (data_type == ImGuiDataType_Double)

  00367	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  0036b	0f 85 17 01 00
	00		 jne	 $LN35@DataTypeAp

; 1821 :     {
; 1822 :         format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis

  00371	c7 45 18 00 00
	00 00		 mov	 DWORD PTR _format$[ebp], OFFSET ??_C@_03DLDNIBIK@?$CFlf@

; 1823 :         double* v = (double*)p_data;

  00378	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  0037b	89 85 78 ff ff
	ff		 mov	 DWORD PTR _v$4[ebp], eax

; 1824 :         double arg0f = *v, arg1f = 0.0;

  00381	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _v$4[ebp]
  00387	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  0038b	f2 0f 11 85 68
	ff ff ff	 movsd	 QWORD PTR _arg0f$3[ebp], xmm0
  00393	0f 57 c0	 xorps	 xmm0, xmm0
  00396	f2 0f 11 85 58
	ff ff ff	 movsd	 QWORD PTR _arg1f$2[ebp], xmm0

; 1825 :         if (op && sscanf(initial_value_buf, format, &arg0f) < 1)

  0039e	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  003a2	85 c0		 test	 eax, eax
  003a4	74 23		 je	 SHORT $LN37@DataTypeAp
  003a6	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _arg0f$3[ebp]
  003ac	50		 push	 eax
  003ad	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  003b0	51		 push	 ecx
  003b1	8b 55 0c	 mov	 edx, DWORD PTR _initial_value_buf$[ebp]
  003b4	52		 push	 edx
  003b5	e8 00 00 00 00	 call	 _sscanf
  003ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  003bd	83 f8 01	 cmp	 eax, 1
  003c0	7d 07		 jge	 SHORT $LN37@DataTypeAp

; 1826 :             return false;

  003c2	32 c0		 xor	 al, al
  003c4	e9 f2 01 00 00	 jmp	 $LN1@DataTypeAp
$LN37@DataTypeAp:

; 1827 :         if (sscanf(buf, format, &arg1f) < 1)

  003c9	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _arg1f$2[ebp]
  003cf	50		 push	 eax
  003d0	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  003d3	51		 push	 ecx
  003d4	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  003d7	52		 push	 edx
  003d8	e8 00 00 00 00	 call	 _sscanf
  003dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e0	83 f8 01	 cmp	 eax, 1
  003e3	7d 07		 jge	 SHORT $LN38@DataTypeAp

; 1828 :             return false;

  003e5	32 c0		 xor	 al, al
  003e7	e9 cf 01 00 00	 jmp	 $LN1@DataTypeAp
$LN38@DataTypeAp:

; 1829 :         if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)

  003ec	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  003f0	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  003f3	75 1c		 jne	 SHORT $LN39@DataTypeAp
  003f5	f2 0f 10 85 68
	ff ff ff	 movsd	 xmm0, QWORD PTR _arg0f$3[ebp]
  003fd	f2 0f 58 85 58
	ff ff ff	 addsd	 xmm0, QWORD PTR _arg1f$2[ebp]
  00405	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _v$4[ebp]
  0040b	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  0040f	eb 72		 jmp	 SHORT $LN44@DataTypeAp
$LN39@DataTypeAp:

; 1830 :         else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply

  00411	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  00415	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00418	75 1c		 jne	 SHORT $LN41@DataTypeAp
  0041a	f2 0f 10 85 68
	ff ff ff	 movsd	 xmm0, QWORD PTR _arg0f$3[ebp]
  00422	f2 0f 59 85 58
	ff ff ff	 mulsd	 xmm0, QWORD PTR _arg1f$2[ebp]
  0042a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _v$4[ebp]
  00430	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
  00434	eb 4d		 jmp	 SHORT $LN44@DataTypeAp
$LN41@DataTypeAp:

; 1831 :         else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide

  00436	0f be 45 f7	 movsx	 eax, BYTE PTR _op$[ebp]
  0043a	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0043d	75 32		 jne	 SHORT $LN43@DataTypeAp
  0043f	f2 0f 10 85 58
	ff ff ff	 movsd	 xmm0, QWORD PTR _arg1f$2[ebp]
  00447	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0044f	9f		 lahf
  00450	f6 c4 44	 test	 ah, 68			; 00000044H
  00453	7b 1a		 jnp	 SHORT $LN45@DataTypeAp
  00455	f2 0f 10 85 68
	ff ff ff	 movsd	 xmm0, QWORD PTR _arg0f$3[ebp]
  0045d	f2 0f 5e 85 58
	ff ff ff	 divsd	 xmm0, QWORD PTR _arg1f$2[ebp]
  00465	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _v$4[ebp]
  0046b	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
$LN45@DataTypeAp:
  0046f	eb 12		 jmp	 SHORT $LN44@DataTypeAp
$LN43@DataTypeAp:

; 1832 :         else                { *v = arg1f; }                            // Assign constant

  00471	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _v$4[ebp]
  00477	f2 0f 10 85 58
	ff ff ff	 movsd	 xmm0, QWORD PTR _arg1f$2[ebp]
  0047f	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0
$LN44@DataTypeAp:

; 1833 :     }

  00483	e9 fd 00 00 00	 jmp	 $LN60@DataTypeAp
$LN35@DataTypeAp:

; 1834 :     else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)

  00488	83 7d 10 05	 cmp	 DWORD PTR _data_type$[ebp], 5
  0048c	74 0c		 je	 SHORT $LN48@DataTypeAp
  0048e	83 7d 10 06	 cmp	 DWORD PTR _data_type$[ebp], 6
  00492	74 06		 je	 SHORT $LN48@DataTypeAp
  00494	83 7d 10 07	 cmp	 DWORD PTR _data_type$[ebp], 7
  00498	75 19		 jne	 SHORT $LN46@DataTypeAp
$LN48@DataTypeAp:

; 1835 :     {
; 1836 :         // All other types assign constant
; 1837 :         // We don't bother handling support for legacy operators since they are a little too crappy. Instead we will later implement a proper expression evaluator in the future.
; 1838 :         sscanf(buf, format, p_data);

  0049a	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  0049d	50		 push	 eax
  0049e	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  004a1	51		 push	 ecx
  004a2	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  004a5	52		 push	 edx
  004a6	e8 00 00 00 00	 call	 _sscanf
  004ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1839 :     }

  004ae	e9 d2 00 00 00	 jmp	 $LN60@DataTypeAp
$LN46@DataTypeAp:

; 1840 :     else
; 1841 :     {
; 1842 :         // Small types need a 32-bit buffer to receive the result from scanf()
; 1843 :         int v32;
; 1844 :         sscanf(buf, format, &v32);

  004b3	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _v32$1[ebp]
  004b9	50		 push	 eax
  004ba	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  004bd	51		 push	 ecx
  004be	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  004c1	52		 push	 edx
  004c2	e8 00 00 00 00	 call	 _sscanf
  004c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1845 :         if (data_type == ImGuiDataType_S8)

  004ca	83 7d 10 00	 cmp	 DWORD PTR _data_type$[ebp], 0
  004ce	75 1d		 jne	 SHORT $LN49@DataTypeAp

; 1846 :             *(ImS8*)p_data = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);

  004d0	6a 7f		 push	 127			; 0000007fH
  004d2	6a 80		 push	 -128			; ffffff80H
  004d4	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _v32$1[ebp]
  004da	50		 push	 eax
  004db	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  004e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e3	8b 4d 14	 mov	 ecx, DWORD PTR _p_data$[ebp]
  004e6	88 01		 mov	 BYTE PTR [ecx], al
  004e8	e9 98 00 00 00	 jmp	 $LN60@DataTypeAp
$LN49@DataTypeAp:

; 1847 :         else if (data_type == ImGuiDataType_U8)

  004ed	83 7d 10 01	 cmp	 DWORD PTR _data_type$[ebp], 1
  004f1	75 1d		 jne	 SHORT $LN51@DataTypeAp

; 1848 :             *(ImU8*)p_data = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);

  004f3	68 ff 00 00 00	 push	 255			; 000000ffH
  004f8	6a 00		 push	 0
  004fa	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _v32$1[ebp]
  00500	50		 push	 eax
  00501	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00506	83 c4 0c	 add	 esp, 12			; 0000000cH
  00509	8b 4d 14	 mov	 ecx, DWORD PTR _p_data$[ebp]
  0050c	88 01		 mov	 BYTE PTR [ecx], al
  0050e	eb 75		 jmp	 SHORT $LN60@DataTypeAp
$LN51@DataTypeAp:

; 1849 :         else if (data_type == ImGuiDataType_S16)

  00510	83 7d 10 02	 cmp	 DWORD PTR _data_type$[ebp], 2
  00514	75 21		 jne	 SHORT $LN53@DataTypeAp

; 1850 :             *(ImS16*)p_data = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);

  00516	68 ff 7f 00 00	 push	 32767			; 00007fffH
  0051b	68 00 80 ff ff	 push	 -32768			; ffff8000H
  00520	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _v32$1[ebp]
  00526	50		 push	 eax
  00527	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  0052c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0052f	8b 4d 14	 mov	 ecx, DWORD PTR _p_data$[ebp]
  00532	66 89 01	 mov	 WORD PTR [ecx], ax
  00535	eb 4e		 jmp	 SHORT $LN60@DataTypeAp
$LN53@DataTypeAp:

; 1851 :         else if (data_type == ImGuiDataType_U16)

  00537	83 7d 10 03	 cmp	 DWORD PTR _data_type$[ebp], 3
  0053b	75 1e		 jne	 SHORT $LN55@DataTypeAp

; 1852 :             *(ImU16*)p_data = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);

  0053d	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00542	6a 00		 push	 0
  00544	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _v32$1[ebp]
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00550	83 c4 0c	 add	 esp, 12			; 0000000cH
  00553	8b 4d 14	 mov	 ecx, DWORD PTR _p_data$[ebp]
  00556	66 89 01	 mov	 WORD PTR [ecx], ax
  00559	eb 2a		 jmp	 SHORT $LN60@DataTypeAp
$LN55@DataTypeAp:

; 1853 :         else
; 1854 :             IM_ASSERT(0);

  0055b	33 c0		 xor	 eax, eax
  0055d	75 26		 jne	 SHORT $LN60@DataTypeAp
  0055f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z@4JA
  00565	83 c1 5e	 add	 ecx, 94			; 0000005eH
  00568	8b f4		 mov	 esi, esp
  0056a	51		 push	 ecx
  0056b	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00570	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  00575	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0057b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0057e	3b f4		 cmp	 esi, esp
  00580	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN60@DataTypeAp:

; 1855 :     }
; 1856 : 
; 1857 :     return memcmp(data_backup, p_data, type_info->Size) != 0;

  00585	8b 45 d8	 mov	 eax, DWORD PTR _type_info$[ebp]
  00588	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058a	51		 push	 ecx
  0058b	8b 55 14	 mov	 edx, DWORD PTR _p_data$[ebp]
  0058e	52		 push	 edx
  0058f	8d 45 e4	 lea	 eax, DWORD PTR _data_backup$[ebp]
  00592	50		 push	 eax
  00593	e8 00 00 00 00	 call	 _memcmp
  00598	83 c4 0c	 add	 esp, 12			; 0000000cH
  0059b	85 c0		 test	 eax, eax
  0059d	74 0c		 je	 SHORT $LN61@DataTypeAp
  0059f	c7 85 84 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv275[ebp], 1
  005a9	eb 0a		 jmp	 SHORT $LN62@DataTypeAp
$LN61@DataTypeAp:
  005ab	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv275[ebp], 0
$LN62@DataTypeAp:
  005b5	8a 85 84 fe ff
	ff		 mov	 al, BYTE PTR tv275[ebp]
$LN1@DataTypeAp:

; 1858 : }

  005bb	52		 push	 edx
  005bc	8b cd		 mov	 ecx, ebp
  005be	50		 push	 eax
  005bf	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN73@DataTypeAp
  005c5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005ca	58		 pop	 eax
  005cb	5a		 pop	 edx
  005cc	5f		 pop	 edi
  005cd	5e		 pop	 esi
  005ce	5b		 pop	 ebx
  005cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d2	33 cd		 xor	 ecx, ebp
  005d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d9	81 c4 7c 01 00
	00		 add	 esp, 380		; 0000017cH
  005df	3b ec		 cmp	 ebp, esp
  005e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005e6	8b e5		 mov	 esp, ebp
  005e8	5d		 pop	 ebp
  005e9	c3		 ret	 0
  005ea	66 90		 npad	 2
$LN73@DataTypeAp:
  005ec	09 00 00 00	 DD	 9
  005f0	00 00 00 00	 DD	 $LN72@DataTypeAp
$LN72@DataTypeAp:
  005f4	e4 ff ff ff	 DD	 -28			; ffffffe4H
  005f8	08 00 00 00	 DD	 8
  005fc	00 00 00 00	 DD	 $LN63@DataTypeAp
  00600	cc ff ff ff	 DD	 -52			; ffffffccH
  00604	04 00 00 00	 DD	 4
  00608	00 00 00 00	 DD	 $LN64@DataTypeAp
  0060c	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00610	04 00 00 00	 DD	 4
  00614	00 00 00 00	 DD	 $LN65@DataTypeAp
  00618	a8 ff ff ff	 DD	 -88			; ffffffa8H
  0061c	04 00 00 00	 DD	 4
  00620	00 00 00 00	 DD	 $LN66@DataTypeAp
  00624	90 ff ff ff	 DD	 -112			; ffffff90H
  00628	04 00 00 00	 DD	 4
  0062c	00 00 00 00	 DD	 $LN67@DataTypeAp
  00630	84 ff ff ff	 DD	 -124			; ffffff84H
  00634	04 00 00 00	 DD	 4
  00638	00 00 00 00	 DD	 $LN68@DataTypeAp
  0063c	68 ff ff ff	 DD	 -152			; ffffff68H
  00640	08 00 00 00	 DD	 8
  00644	00 00 00 00	 DD	 $LN69@DataTypeAp
  00648	58 ff ff ff	 DD	 -168			; ffffff58H
  0064c	08 00 00 00	 DD	 8
  00650	00 00 00 00	 DD	 $LN70@DataTypeAp
  00654	4c ff ff ff	 DD	 -180			; ffffff4cH
  00658	04 00 00 00	 DD	 4
  0065c	00 00 00 00	 DD	 $LN71@DataTypeAp
$LN71@DataTypeAp:
  00660	76		 DB	 118			; 00000076H
  00661	33		 DB	 51			; 00000033H
  00662	32		 DB	 50			; 00000032H
  00663	00		 DB	 0
$LN70@DataTypeAp:
  00664	61		 DB	 97			; 00000061H
  00665	72		 DB	 114			; 00000072H
  00666	67		 DB	 103			; 00000067H
  00667	31		 DB	 49			; 00000031H
  00668	66		 DB	 102			; 00000066H
  00669	00		 DB	 0
$LN69@DataTypeAp:
  0066a	61		 DB	 97			; 00000061H
  0066b	72		 DB	 114			; 00000072H
  0066c	67		 DB	 103			; 00000067H
  0066d	30		 DB	 48			; 00000030H
  0066e	66		 DB	 102			; 00000066H
  0066f	00		 DB	 0
$LN68@DataTypeAp:
  00670	61		 DB	 97			; 00000061H
  00671	72		 DB	 114			; 00000072H
  00672	67		 DB	 103			; 00000067H
  00673	31		 DB	 49			; 00000031H
  00674	66		 DB	 102			; 00000066H
  00675	00		 DB	 0
$LN67@DataTypeAp:
  00676	61		 DB	 97			; 00000061H
  00677	72		 DB	 114			; 00000072H
  00678	67		 DB	 103			; 00000067H
  00679	30		 DB	 48			; 00000030H
  0067a	66		 DB	 102			; 00000066H
  0067b	00		 DB	 0
$LN66@DataTypeAp:
  0067c	61		 DB	 97			; 00000061H
  0067d	72		 DB	 114			; 00000072H
  0067e	67		 DB	 103			; 00000067H
  0067f	31		 DB	 49			; 00000031H
  00680	66		 DB	 102			; 00000066H
  00681	00		 DB	 0
$LN65@DataTypeAp:
  00682	61		 DB	 97			; 00000061H
  00683	72		 DB	 114			; 00000072H
  00684	67		 DB	 103			; 00000067H
  00685	30		 DB	 48			; 00000030H
  00686	69		 DB	 105			; 00000069H
  00687	00		 DB	 0
$LN64@DataTypeAp:
  00688	61		 DB	 97			; 00000061H
  00689	72		 DB	 114			; 00000072H
  0068a	67		 DB	 103			; 00000067H
  0068b	31		 DB	 49			; 00000031H
  0068c	69		 DB	 105			; 00000069H
  0068d	00		 DB	 0
$LN63@DataTypeAp:
  0068e	64		 DB	 100			; 00000064H
  0068f	61		 DB	 97			; 00000061H
  00690	74		 DB	 116			; 00000074H
  00691	61		 DB	 97			; 00000061H
  00692	5f		 DB	 95			; 0000005fH
  00693	62		 DB	 98			; 00000062H
  00694	61		 DB	 97			; 00000061H
  00695	63		 DB	 99			; 00000063H
  00696	6b		 DB	 107			; 0000006bH
  00697	75		 DB	 117			; 00000075H
  00698	70		 DB	 112			; 00000070H
  00699	00		 DB	 0
?DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z ENDP	; ImGui::DataTypeApplyOpFromText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z
_TEXT	SEGMENT
tv71 = -196						; size = 4
_data_type$ = 8						; size = 4
_op$ = 12						; size = 4
_output$ = 16						; size = 4
_arg1$ = 20						; size = 4
_arg2$ = 24						; size = 4
?DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z PROC		; ImGui::DataTypeApplyOp, COMDAT

; 1708 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1709 :     IM_ASSERT(op == '+' || op == '-');

  00028	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  0002c	74 2b		 je	 SHORT $LN36@DataTypeAp
  0002e	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  00032	74 25		 je	 SHORT $LN36@DataTypeAp
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z@4JA
  00039	83 c0 01	 add	 eax, 1
  0003c	8b f4		 mov	 esi, esp
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@LEDHMGOL@?$AAo?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?8?$AA?$CL?$AA?8?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAp@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN36@DataTypeAp:

; 1710 :     switch (data_type)

  00059	8b 45 08	 mov	 eax, DWORD PTR _data_type$[ebp]
  0005c	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00062	83 bd 3c ff ff
	ff 09		 cmp	 DWORD PTR tv71[ebp], 9
  00069	0f 87 55 03 00
	00		 ja	 $LN2@DataTypeAp
  0006f	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  00075	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN38@DataTypeAp[ecx*4]
$LN4@DataTypeAp:

; 1711 :     {
; 1712 :         case ImGuiDataType_S8:
; 1713 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

  0007c	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  00080	75 1f		 jne	 SHORT $LN5@DataTypeAp
  00082	6a 7f		 push	 127			; 0000007fH
  00084	6a 80		 push	 -128			; ffffff80H
  00086	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  00089	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0008c	51		 push	 ecx
  0008d	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  00090	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@C@@YACCCCC@Z ; ImAddClampOverflow<signed char>
  00099	83 c4 10	 add	 esp, 16			; 00000010H
  0009c	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  0009f	88 01		 mov	 BYTE PTR [ecx], al
$LN5@DataTypeAp:

; 1714 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

  000a1	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  000a5	75 1f		 jne	 SHORT $LN6@DataTypeAp
  000a7	6a 7f		 push	 127			; 0000007fH
  000a9	6a 80		 push	 -128			; ffffff80H
  000ab	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  000ae	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000b1	51		 push	 ecx
  000b2	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  000b5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@C@@YACCCCC@Z ; ImSubClampOverflow<signed char>
  000be	83 c4 10	 add	 esp, 16			; 00000010H
  000c1	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  000c4	88 01		 mov	 BYTE PTR [ecx], al
$LN6@DataTypeAp:

; 1715 :             return;

  000c6	e9 23 03 00 00	 jmp	 $LN1@DataTypeAp
$LN7@DataTypeAp:

; 1716 :         case ImGuiDataType_U8:
; 1717 :             if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

  000cb	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  000cf	75 22		 jne	 SHORT $LN8@DataTypeAp
  000d1	68 ff 00 00 00	 push	 255			; 000000ffH
  000d6	6a 00		 push	 0
  000d8	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  000db	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000de	51		 push	 ecx
  000df	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  000e2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@E@@YAEEEEE@Z ; ImAddClampOverflow<unsigned char>
  000eb	83 c4 10	 add	 esp, 16			; 00000010H
  000ee	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  000f1	88 01		 mov	 BYTE PTR [ecx], al
$LN8@DataTypeAp:

; 1718 :             if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

  000f3	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  000f7	75 22		 jne	 SHORT $LN9@DataTypeAp
  000f9	68 ff 00 00 00	 push	 255			; 000000ffH
  000fe	6a 00		 push	 0
  00100	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  00103	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00106	51		 push	 ecx
  00107	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  0010a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@E@@YAEEEEE@Z ; ImSubClampOverflow<unsigned char>
  00113	83 c4 10	 add	 esp, 16			; 00000010H
  00116	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  00119	88 01		 mov	 BYTE PTR [ecx], al
$LN9@DataTypeAp:

; 1719 :             return;

  0011b	e9 ce 02 00 00	 jmp	 $LN1@DataTypeAp
$LN10@DataTypeAp:

; 1720 :         case ImGuiDataType_S16:
; 1721 :             if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

  00120	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  00124	75 26		 jne	 SHORT $LN11@DataTypeAp
  00126	68 ff 7f 00 00	 push	 32767			; 00007fffH
  0012b	68 00 80 ff ff	 push	 -32768			; ffff8000H
  00130	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  00133	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00136	51		 push	 ecx
  00137	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  0013a	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@F@@YAFFFFF@Z ; ImAddClampOverflow<short>
  00143	83 c4 10	 add	 esp, 16			; 00000010H
  00146	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  00149	66 89 01	 mov	 WORD PTR [ecx], ax
$LN11@DataTypeAp:

; 1722 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

  0014c	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  00150	75 26		 jne	 SHORT $LN12@DataTypeAp
  00152	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00157	68 00 80 ff ff	 push	 -32768			; ffff8000H
  0015c	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  0015f	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00162	51		 push	 ecx
  00163	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  00166	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@F@@YAFFFFF@Z ; ImSubClampOverflow<short>
  0016f	83 c4 10	 add	 esp, 16			; 00000010H
  00172	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  00175	66 89 01	 mov	 WORD PTR [ecx], ax
$LN12@DataTypeAp:

; 1723 :             return;

  00178	e9 71 02 00 00	 jmp	 $LN1@DataTypeAp
$LN13@DataTypeAp:

; 1724 :         case ImGuiDataType_U16:
; 1725 :             if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

  0017d	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  00181	75 23		 jne	 SHORT $LN14@DataTypeAp
  00183	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00188	6a 00		 push	 0
  0018a	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  0018d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00190	51		 push	 ecx
  00191	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  00194	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@G@@YAGGGGG@Z ; ImAddClampOverflow<unsigned short>
  0019d	83 c4 10	 add	 esp, 16			; 00000010H
  001a0	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  001a3	66 89 01	 mov	 WORD PTR [ecx], ax
$LN14@DataTypeAp:

; 1726 :             if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

  001a6	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  001aa	75 23		 jne	 SHORT $LN15@DataTypeAp
  001ac	68 ff ff 00 00	 push	 65535			; 0000ffffH
  001b1	6a 00		 push	 0
  001b3	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  001b6	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  001bd	0f b7 02	 movzx	 eax, WORD PTR [edx]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@G@@YAGGGGG@Z ; ImSubClampOverflow<unsigned short>
  001c6	83 c4 10	 add	 esp, 16			; 00000010H
  001c9	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  001cc	66 89 01	 mov	 WORD PTR [ecx], ax
$LN15@DataTypeAp:

; 1727 :             return;

  001cf	e9 1a 02 00 00	 jmp	 $LN1@DataTypeAp
$LN16@DataTypeAp:

; 1728 :         case ImGuiDataType_S32:
; 1729 :             if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

  001d4	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  001d8	75 23		 jne	 SHORT $LN17@DataTypeAp
  001da	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  001df	68 00 00 00 80	 push	 -2147483648		; 80000000H
  001e4	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  001e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e9	51		 push	 ecx
  001ea	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  001ed	8b 02		 mov	 eax, DWORD PTR [edx]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@H@@YAHHHHH@Z ; ImAddClampOverflow<int>
  001f5	83 c4 10	 add	 esp, 16			; 00000010H
  001f8	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  001fb	89 01		 mov	 DWORD PTR [ecx], eax
$LN17@DataTypeAp:

; 1730 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

  001fd	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  00201	75 23		 jne	 SHORT $LN18@DataTypeAp
  00203	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00208	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0020d	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  00210	8b 08		 mov	 ecx, DWORD PTR [eax]
  00212	51		 push	 ecx
  00213	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  00216	8b 02		 mov	 eax, DWORD PTR [edx]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@H@@YAHHHHH@Z ; ImSubClampOverflow<int>
  0021e	83 c4 10	 add	 esp, 16			; 00000010H
  00221	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  00224	89 01		 mov	 DWORD PTR [ecx], eax
$LN18@DataTypeAp:

; 1731 :             return;

  00226	e9 c3 01 00 00	 jmp	 $LN1@DataTypeAp
$LN19@DataTypeAp:

; 1732 :         case ImGuiDataType_U32:
; 1733 :             if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

  0022b	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  0022f	75 1d		 jne	 SHORT $LN20@DataTypeAp
  00231	6a ff		 push	 -1
  00233	6a 00		 push	 0
  00235	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  00238	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023a	51		 push	 ecx
  0023b	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  0023e	8b 02		 mov	 eax, DWORD PTR [edx]
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@I@@YAIIIII@Z ; ImAddClampOverflow<unsigned int>
  00246	83 c4 10	 add	 esp, 16			; 00000010H
  00249	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  0024c	89 01		 mov	 DWORD PTR [ecx], eax
$LN20@DataTypeAp:

; 1734 :             if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

  0024e	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  00252	75 1d		 jne	 SHORT $LN21@DataTypeAp
  00254	6a ff		 push	 -1
  00256	6a 00		 push	 0
  00258	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  0025b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025d	51		 push	 ecx
  0025e	8b 55 14	 mov	 edx, DWORD PTR _arg1$[ebp]
  00261	8b 02		 mov	 eax, DWORD PTR [edx]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@I@@YAIIIII@Z ; ImSubClampOverflow<unsigned int>
  00269	83 c4 10	 add	 esp, 16			; 00000010H
  0026c	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  0026f	89 01		 mov	 DWORD PTR [ecx], eax
$LN21@DataTypeAp:

; 1735 :             return;

  00271	e9 78 01 00 00	 jmp	 $LN1@DataTypeAp
$LN22@DataTypeAp:

; 1736 :         case ImGuiDataType_S64:
; 1737 :             if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

  00276	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  0027a	75 32		 jne	 SHORT $LN23@DataTypeAp
  0027c	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00281	6a ff		 push	 -1
  00283	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00288	6a 00		 push	 0
  0028a	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  0028d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00290	51		 push	 ecx
  00291	8b 10		 mov	 edx, DWORD PTR [eax]
  00293	52		 push	 edx
  00294	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  00297	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0029a	51		 push	 ecx
  0029b	8b 10		 mov	 edx, DWORD PTR [eax]
  0029d	52		 push	 edx
  0029e	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@_J@@YA_J_J000@Z ; ImAddClampOverflow<__int64>
  002a3	83 c4 20	 add	 esp, 32			; 00000020H
  002a6	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  002a9	89 01		 mov	 DWORD PTR [ecx], eax
  002ab	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN23@DataTypeAp:

; 1738 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

  002ae	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  002b2	75 32		 jne	 SHORT $LN24@DataTypeAp
  002b4	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  002b9	6a ff		 push	 -1
  002bb	68 00 00 00 80	 push	 -2147483648		; 80000000H
  002c0	6a 00		 push	 0
  002c2	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  002c5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002c8	51		 push	 ecx
  002c9	8b 10		 mov	 edx, DWORD PTR [eax]
  002cb	52		 push	 edx
  002cc	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  002cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002d2	51		 push	 ecx
  002d3	8b 10		 mov	 edx, DWORD PTR [eax]
  002d5	52		 push	 edx
  002d6	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@_J@@YA_J_J000@Z ; ImSubClampOverflow<__int64>
  002db	83 c4 20	 add	 esp, 32			; 00000020H
  002de	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  002e1	89 01		 mov	 DWORD PTR [ecx], eax
  002e3	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN24@DataTypeAp:

; 1739 :             return;

  002e6	e9 03 01 00 00	 jmp	 $LN1@DataTypeAp
$LN25@DataTypeAp:

; 1740 :         case ImGuiDataType_U64:
; 1741 :             if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

  002eb	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  002ef	75 2c		 jne	 SHORT $LN26@DataTypeAp
  002f1	6a ff		 push	 -1
  002f3	6a ff		 push	 -1
  002f5	6a 00		 push	 0
  002f7	6a 00		 push	 0
  002f9	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  002fc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ff	51		 push	 ecx
  00300	8b 10		 mov	 edx, DWORD PTR [eax]
  00302	52		 push	 edx
  00303	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  00306	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00309	51		 push	 ecx
  0030a	8b 10		 mov	 edx, DWORD PTR [eax]
  0030c	52		 push	 edx
  0030d	e8 00 00 00 00	 call	 ??$ImAddClampOverflow@_K@@YA_K_K000@Z ; ImAddClampOverflow<unsigned __int64>
  00312	83 c4 20	 add	 esp, 32			; 00000020H
  00315	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  00318	89 01		 mov	 DWORD PTR [ecx], eax
  0031a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN26@DataTypeAp:

; 1742 :             if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

  0031d	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  00321	75 2c		 jne	 SHORT $LN27@DataTypeAp
  00323	6a ff		 push	 -1
  00325	6a ff		 push	 -1
  00327	6a 00		 push	 0
  00329	6a 00		 push	 0
  0032b	8b 45 18	 mov	 eax, DWORD PTR _arg2$[ebp]
  0032e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00331	51		 push	 ecx
  00332	8b 10		 mov	 edx, DWORD PTR [eax]
  00334	52		 push	 edx
  00335	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  00338	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0033b	51		 push	 ecx
  0033c	8b 10		 mov	 edx, DWORD PTR [eax]
  0033e	52		 push	 edx
  0033f	e8 00 00 00 00	 call	 ??$ImSubClampOverflow@_K@@YA_K_K000@Z ; ImSubClampOverflow<unsigned __int64>
  00344	83 c4 20	 add	 esp, 32			; 00000020H
  00347	8b 4d 10	 mov	 ecx, DWORD PTR _output$[ebp]
  0034a	89 01		 mov	 DWORD PTR [ecx], eax
  0034c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN27@DataTypeAp:

; 1743 :             return;

  0034f	e9 9a 00 00 00	 jmp	 $LN1@DataTypeAp
$LN28@DataTypeAp:

; 1744 :         case ImGuiDataType_Float:
; 1745 :             if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }

  00354	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  00358	75 15		 jne	 SHORT $LN29@DataTypeAp
  0035a	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  0035d	8b 4d 18	 mov	 ecx, DWORD PTR _arg2$[ebp]
  00360	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00364	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00368	8b 55 10	 mov	 edx, DWORD PTR _output$[ebp]
  0036b	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
$LN29@DataTypeAp:

; 1746 :             if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }

  0036f	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  00373	75 15		 jne	 SHORT $LN30@DataTypeAp
  00375	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  00378	8b 4d 18	 mov	 ecx, DWORD PTR _arg2$[ebp]
  0037b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0037f	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00383	8b 55 10	 mov	 edx, DWORD PTR _output$[ebp]
  00386	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
$LN30@DataTypeAp:

; 1747 :             return;

  0038a	eb 62		 jmp	 SHORT $LN1@DataTypeAp
$LN31@DataTypeAp:

; 1748 :         case ImGuiDataType_Double:
; 1749 :             if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }

  0038c	83 7d 0c 2b	 cmp	 DWORD PTR _op$[ebp], 43	; 0000002bH
  00390	75 15		 jne	 SHORT $LN32@DataTypeAp
  00392	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  00395	8b 4d 18	 mov	 ecx, DWORD PTR _arg2$[ebp]
  00398	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  0039c	f2 0f 58 01	 addsd	 xmm0, QWORD PTR [ecx]
  003a0	8b 55 10	 mov	 edx, DWORD PTR _output$[ebp]
  003a3	f2 0f 11 02	 movsd	 QWORD PTR [edx], xmm0
$LN32@DataTypeAp:

; 1750 :             if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }

  003a7	83 7d 0c 2d	 cmp	 DWORD PTR _op$[ebp], 45	; 0000002dH
  003ab	75 15		 jne	 SHORT $LN33@DataTypeAp
  003ad	8b 45 14	 mov	 eax, DWORD PTR _arg1$[ebp]
  003b0	8b 4d 18	 mov	 ecx, DWORD PTR _arg2$[ebp]
  003b3	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  003b7	f2 0f 5c 01	 subsd	 xmm0, QWORD PTR [ecx]
  003bb	8b 55 10	 mov	 edx, DWORD PTR _output$[ebp]
  003be	f2 0f 11 02	 movsd	 QWORD PTR [edx], xmm0
$LN33@DataTypeAp:

; 1751 :             return;

  003c2	eb 2a		 jmp	 SHORT $LN1@DataTypeAp
$LN2@DataTypeAp:

; 1752 :         case ImGuiDataType_COUNT: break;
; 1753 :     }
; 1754 :     IM_ASSERT(0);

  003c4	33 c0		 xor	 eax, eax
  003c6	75 26		 jne	 SHORT $LN37@DataTypeAp
  003c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z@4JA
  003ce	83 c1 2e	 add	 ecx, 46			; 0000002eH
  003d1	8b f4		 mov	 esi, esp
  003d3	51		 push	 ecx
  003d4	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  003d9	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  003de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  003e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e7	3b f4		 cmp	 esi, esp
  003e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN37@DataTypeAp:
$LN1@DataTypeAp:

; 1755 : }

  003ee	5f		 pop	 edi
  003ef	5e		 pop	 esi
  003f0	5b		 pop	 ebx
  003f1	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  003f7	3b ec		 cmp	 ebp, esp
  003f9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003fe	8b e5		 mov	 esp, ebp
  00400	5d		 pop	 ebp
  00401	c3		 ret	 0
  00402	66 90		 npad	 2
$LN38@DataTypeAp:
  00404	00 00 00 00	 DD	 $LN4@DataTypeAp
  00408	00 00 00 00	 DD	 $LN7@DataTypeAp
  0040c	00 00 00 00	 DD	 $LN10@DataTypeAp
  00410	00 00 00 00	 DD	 $LN13@DataTypeAp
  00414	00 00 00 00	 DD	 $LN16@DataTypeAp
  00418	00 00 00 00	 DD	 $LN19@DataTypeAp
  0041c	00 00 00 00	 DD	 $LN22@DataTypeAp
  00420	00 00 00 00	 DD	 $LN25@DataTypeAp
  00424	00 00 00 00	 DD	 $LN28@DataTypeAp
  00428	00 00 00 00	 DD	 $LN31@DataTypeAp
?DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z ENDP		; ImGui::DataTypeApplyOp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buf_size$ = 12						; size = 4
_data_type$ = 16					; size = 4
_p_data$ = 20						; size = 4
_format$ = 24						; size = 4
?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z PROC	; ImGui::DataTypeFormatString, COMDAT

; 1685 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1686 :     // Signedness doesn't matter when pushing integer arguments
; 1687 :     if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)

  00028	83 7d 10 04	 cmp	 DWORD PTR _data_type$[ebp], 4
  0002c	74 06		 je	 SHORT $LN3@DataTypeFo
  0002e	83 7d 10 05	 cmp	 DWORD PTR _data_type$[ebp], 5
  00032	75 1f		 jne	 SHORT $LN2@DataTypeFo
$LN3@DataTypeFo:

; 1688 :         return ImFormatString(buf, buf_size, format, *(const ImU32*)p_data);

  00034	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	51		 push	 ecx
  0003a	8b 55 18	 mov	 edx, DWORD PTR _format$[ebp]
  0003d	52		 push	 edx
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _buf_size$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	e9 46 01 00 00	 jmp	 $LN1@DataTypeFo
$LN2@DataTypeFo:

; 1689 :     if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)

  00053	83 7d 10 06	 cmp	 DWORD PTR _data_type$[ebp], 6
  00057	74 06		 je	 SHORT $LN5@DataTypeFo
  00059	83 7d 10 07	 cmp	 DWORD PTR _data_type$[ebp], 7
  0005d	75 23		 jne	 SHORT $LN4@DataTypeFo
$LN5@DataTypeFo:

; 1690 :         return ImFormatString(buf, buf_size, format, *(const ImU64*)p_data);

  0005f	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	51		 push	 ecx
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	52		 push	 edx
  00069	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _buf_size$[ebp]
  00070	51		 push	 ecx
  00071	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0007a	83 c4 14	 add	 esp, 20			; 00000014H
  0007d	e9 17 01 00 00	 jmp	 $LN1@DataTypeFo
$LN4@DataTypeFo:

; 1691 :     if (data_type == ImGuiDataType_Float)

  00082	83 7d 10 08	 cmp	 DWORD PTR _data_type$[ebp], 8
  00086	75 28		 jne	 SHORT $LN6@DataTypeFo

; 1692 :         return ImFormatString(buf, buf_size, format, *(const float*)p_data);

  00088	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  0008b	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [eax]
  0008f	83 ec 08	 sub	 esp, 8
  00092	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00097	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 0c	 mov	 edx, DWORD PTR _buf_size$[ebp]
  0009e	52		 push	 edx
  0009f	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  000a8	83 c4 14	 add	 esp, 20			; 00000014H
  000ab	e9 e9 00 00 00	 jmp	 $LN1@DataTypeFo
$LN6@DataTypeFo:

; 1693 :     if (data_type == ImGuiDataType_Double)

  000b0	83 7d 10 09	 cmp	 DWORD PTR _data_type$[ebp], 9
  000b4	75 28		 jne	 SHORT $LN7@DataTypeFo

; 1694 :         return ImFormatString(buf, buf_size, format, *(const double*)p_data);

  000b6	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  000b9	83 ec 08	 sub	 esp, 8
  000bc	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  000c0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c5	8b 4d 18	 mov	 ecx, DWORD PTR _format$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 0c	 mov	 edx, DWORD PTR _buf_size$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  000d6	83 c4 14	 add	 esp, 20			; 00000014H
  000d9	e9 bb 00 00 00	 jmp	 $LN1@DataTypeFo
$LN7@DataTypeFo:

; 1695 :     if (data_type == ImGuiDataType_S8)

  000de	83 7d 10 00	 cmp	 DWORD PTR _data_type$[ebp], 0
  000e2	75 20		 jne	 SHORT $LN8@DataTypeFo

; 1696 :         return ImFormatString(buf, buf_size, format, *(const ImS8*)p_data);

  000e4	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  000e7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ea	51		 push	 ecx
  000eb	8b 55 18	 mov	 edx, DWORD PTR _format$[ebp]
  000ee	52		 push	 edx
  000ef	8b 45 0c	 mov	 eax, DWORD PTR _buf_size$[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  000fc	83 c4 10	 add	 esp, 16			; 00000010H
  000ff	e9 95 00 00 00	 jmp	 $LN1@DataTypeFo
$LN8@DataTypeFo:

; 1697 :     if (data_type == ImGuiDataType_U8)

  00104	83 7d 10 01	 cmp	 DWORD PTR _data_type$[ebp], 1
  00108	75 1d		 jne	 SHORT $LN9@DataTypeFo

; 1698 :         return ImFormatString(buf, buf_size, format, *(const ImU8*)p_data);

  0010a	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  0010d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00110	51		 push	 ecx
  00111	8b 55 18	 mov	 edx, DWORD PTR _format$[ebp]
  00114	52		 push	 edx
  00115	8b 45 0c	 mov	 eax, DWORD PTR _buf_size$[ebp]
  00118	50		 push	 eax
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0011c	51		 push	 ecx
  0011d	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00122	83 c4 10	 add	 esp, 16			; 00000010H
  00125	eb 72		 jmp	 SHORT $LN1@DataTypeFo
$LN9@DataTypeFo:

; 1699 :     if (data_type == ImGuiDataType_S16)

  00127	83 7d 10 02	 cmp	 DWORD PTR _data_type$[ebp], 2
  0012b	75 1d		 jne	 SHORT $LN10@DataTypeFo

; 1700 :         return ImFormatString(buf, buf_size, format, *(const ImS16*)p_data);

  0012d	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  00130	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00133	51		 push	 ecx
  00134	8b 55 18	 mov	 edx, DWORD PTR _format$[ebp]
  00137	52		 push	 edx
  00138	8b 45 0c	 mov	 eax, DWORD PTR _buf_size$[ebp]
  0013b	50		 push	 eax
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00145	83 c4 10	 add	 esp, 16			; 00000010H
  00148	eb 4f		 jmp	 SHORT $LN1@DataTypeFo
$LN10@DataTypeFo:

; 1701 :     if (data_type == ImGuiDataType_U16)

  0014a	83 7d 10 03	 cmp	 DWORD PTR _data_type$[ebp], 3
  0014e	75 1d		 jne	 SHORT $LN11@DataTypeFo

; 1702 :         return ImFormatString(buf, buf_size, format, *(const ImU16*)p_data);

  00150	8b 45 14	 mov	 eax, DWORD PTR _p_data$[ebp]
  00153	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00156	51		 push	 ecx
  00157	8b 55 18	 mov	 edx, DWORD PTR _format$[ebp]
  0015a	52		 push	 edx
  0015b	8b 45 0c	 mov	 eax, DWORD PTR _buf_size$[ebp]
  0015e	50		 push	 eax
  0015f	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00162	51		 push	 ecx
  00163	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00168	83 c4 10	 add	 esp, 16			; 00000010H
  0016b	eb 2c		 jmp	 SHORT $LN1@DataTypeFo
$LN11@DataTypeFo:

; 1703 :     IM_ASSERT(0);

  0016d	33 c0		 xor	 eax, eax
  0016f	75 26		 jne	 SHORT $LN13@DataTypeFo
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z@4JA
  00177	83 c1 12	 add	 ecx, 18			; 00000012H
  0017a	8b f4		 mov	 esi, esp
  0017c	51		 push	 ecx
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0018d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00190	3b f4		 cmp	 esi, esp
  00192	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@DataTypeFo:

; 1704 :     return 0;

  00197	33 c0		 xor	 eax, eax
$LN1@DataTypeFo:

; 1705 : }

  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5b		 pop	 ebx
  0019c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  001a2	3b ec		 cmp	 ebp, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c3		 ret	 0
?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z ENDP	; ImGui::DataTypeFormatString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z
_TEXT	SEGMENT
_data_type$ = 8						; size = 4
?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z PROC ; ImGui::DataTypeGetInfo, COMDAT

; 1679 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1680 :     IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);

  00028	83 7d 08 00	 cmp	 DWORD PTR _data_type$[ebp], 0
  0002c	7c 06		 jl	 SHORT $LN3@DataTypeGe
  0002e	83 7d 08 0a	 cmp	 DWORD PTR _data_type$[ebp], 10 ; 0000000aH
  00032	7c 25		 jl	 SHORT $LN4@DataTypeGe
$LN3@DataTypeGe:
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z@4JA
  00039	83 c0 01	 add	 eax, 1
  0003c	8b f4		 mov	 esi, esp
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1GE@PMGCKKHF@?$AAd?$AAa?$AAt?$AAa?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@DataTypeGe:

; 1681 :     return &GDataTypeInfo[data_type];

  00059	6b 45 08 0c	 imul	 eax, DWORD PTR _data_type$[ebp], 12
  0005d	05 00 00 00 00	 add	 eax, OFFSET ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B

; 1682 : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z ENDP ; ImGui::DataTypeGetInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreePushOverrideID@ImGui@@YAXI@Z
_TEXT	SEGMENT
_window$ = -8						; size = 4
_id$ = 8						; size = 4
?TreePushOverrideID@ImGui@@YAXI@Z PROC			; ImGui::TreePushOverrideID, COMDAT

; 5410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5411 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5412 :     Indent();

  00030	51		 push	 ecx
  00031	0f 57 c0	 xorps	 xmm0, xmm0
  00034	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00039	e8 00 00 00 00	 call	 ?Indent@ImGui@@YAXM@Z	; ImGui::Indent
  0003e	83 c4 04	 add	 esp, 4

; 5413 :     window->DC.TreeDepth++;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00044	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  0004a	83 c1 01	 add	 ecx, 1
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  00050	89 8a 00 01 00
	00		 mov	 DWORD PTR [edx+256], ecx

; 5414 :     window->IDStack.push_back(id);

  00056	8d 45 08	 lea	 eax, DWORD PTR _id$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0005d	81 c1 bc 00 00
	00		 add	 ecx, 188		; 000000bcH
  00063	e8 00 00 00 00	 call	 ?push_back@?$ImVector@I@@QAEXABI@Z ; ImVector<unsigned int>::push_back

; 5415 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?TreePushOverrideID@ImGui@@YAXI@Z ENDP			; ImGui::TreePushOverrideID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z
_TEXT	SEGMENT
tv137 = -260						; size = 4
tv133 = -256						; size = 4
tv95 = -256						; size = 4
_stored_value$1 = -56					; size = 4
_is_open$ = -41						; size = 1
_storage$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
_id$ = 8						; size = 4
_flags$ = 12						; size = 4
?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z PROC		; ImGui::TreeNodeBehaviorIsOpen, COMDAT

; 5165 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-260]
  00012	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5166 :     if (flags & ImGuiTreeNodeFlags_Leaf)

  00028	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00030	74 07		 je	 SHORT $LN2@TreeNodeBe

; 5167 :         return true;

  00032	b0 01		 mov	 al, 1
  00034	e9 4a 01 00 00	 jmp	 $LN1@TreeNodeBe
$LN2@TreeNodeBe:

; 5168 : 
; 5169 :     // We only write to the tree storage if the user clicks (or explicitly use the SetNextItemOpen function)
; 5170 :     ImGuiContext& g = *GImGui;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0003e	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 5171 :     ImGuiWindow* window = g.CurrentWindow;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00044	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  0004a	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 5172 :     ImGuiStorage* storage = window->DC.StateStorage;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00050	8b 88 58 01 00
	00		 mov	 ecx, DWORD PTR [eax+344]
  00056	89 4d e0	 mov	 DWORD PTR _storage$[ebp], ecx

; 5173 : 
; 5174 :     bool is_open;
; 5175 :     if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasOpen)

  00059	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0005c	8b 88 84 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6788]
  00062	83 e1 02	 and	 ecx, 2
  00065	0f 84 8a 00 00
	00		 je	 $LN3@TreeNodeBe

; 5176 :     {
; 5177 :         if (g.NextItemData.OpenCond & ImGuiCond_Always)

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0006e	8b 88 90 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6800]
  00074	83 e1 01	 and	 ecx, 1
  00077	74 1f		 je	 SHORT $LN5@TreeNodeBe

; 5178 :         {
; 5179 :             is_open = g.NextItemData.OpenVal;

  00079	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0007c	8a 88 8c 1a 00
	00		 mov	 cl, BYTE PTR [eax+6796]
  00082	88 4d d7	 mov	 BYTE PTR _is_open$[ebp], cl

; 5180 :             storage->SetInt(id, is_open);

  00085	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_open$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 4d e0	 mov	 ecx, DWORD PTR _storage$[ebp]
  00091	e8 00 00 00 00	 call	 ?SetInt@ImGuiStorage@@QAEXIH@Z ; ImGuiStorage::SetInt

; 5181 :         }

  00096	eb 5b		 jmp	 SHORT $LN6@TreeNodeBe
$LN5@TreeNodeBe:

; 5182 :         else
; 5183 :         {
; 5184 :             // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
; 5185 :             const int stored_value = storage->GetInt(id, -1);

  00098	6a ff		 push	 -1
  0009a	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d e0	 mov	 ecx, DWORD PTR _storage$[ebp]
  000a1	e8 00 00 00 00	 call	 ?GetInt@ImGuiStorage@@QBEHIH@Z ; ImGuiStorage::GetInt
  000a6	89 45 c8	 mov	 DWORD PTR _stored_value$1[ebp], eax

; 5186 :             if (stored_value == -1)

  000a9	83 7d c8 ff	 cmp	 DWORD PTR _stored_value$1[ebp], -1
  000ad	75 1f		 jne	 SHORT $LN7@TreeNodeBe

; 5187 :             {
; 5188 :                 is_open = g.NextItemData.OpenVal;

  000af	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  000b2	8a 88 8c 1a 00
	00		 mov	 cl, BYTE PTR [eax+6796]
  000b8	88 4d d7	 mov	 BYTE PTR _is_open$[ebp], cl

; 5189 :                 storage->SetInt(id, is_open);

  000bb	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_open$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  000c3	51		 push	 ecx
  000c4	8b 4d e0	 mov	 ecx, DWORD PTR _storage$[ebp]
  000c7	e8 00 00 00 00	 call	 ?SetInt@ImGuiStorage@@QAEXIH@Z ; ImGuiStorage::SetInt

; 5190 :             }

  000cc	eb 25		 jmp	 SHORT $LN6@TreeNodeBe
$LN7@TreeNodeBe:

; 5191 :             else
; 5192 :             {
; 5193 :                 is_open = stored_value != 0;

  000ce	83 7d c8 00	 cmp	 DWORD PTR _stored_value$1[ebp], 0
  000d2	74 0c		 je	 SHORT $LN11@TreeNodeBe
  000d4	c7 85 00 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv95[ebp], 1
  000de	eb 0a		 jmp	 SHORT $LN12@TreeNodeBe
$LN11@TreeNodeBe:
  000e0	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv95[ebp], 0
$LN12@TreeNodeBe:
  000ea	8a 85 00 ff ff
	ff		 mov	 al, BYTE PTR tv95[ebp]
  000f0	88 45 d7	 mov	 BYTE PTR _is_open$[ebp], al
$LN6@TreeNodeBe:

; 5194 :             }
; 5195 :         }
; 5196 :     }

  000f3	eb 54		 jmp	 SHORT $LN4@TreeNodeBe
$LN3@TreeNodeBe:

; 5197 :     else
; 5198 :     {
; 5199 :         is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;

  000f5	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  000f8	83 e0 20	 and	 eax, 32			; 00000020H
  000fb	74 0c		 je	 SHORT $LN13@TreeNodeBe
  000fd	c7 85 00 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv133[ebp], 1
  00107	eb 0a		 jmp	 SHORT $LN14@TreeNodeBe
$LN13@TreeNodeBe:
  00109	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv133[ebp], 0
$LN14@TreeNodeBe:
  00113	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv133[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 08	 mov	 edx, DWORD PTR _id$[ebp]
  0011d	52		 push	 edx
  0011e	8b 4d e0	 mov	 ecx, DWORD PTR _storage$[ebp]
  00121	e8 00 00 00 00	 call	 ?GetInt@ImGuiStorage@@QBEHIH@Z ; ImGuiStorage::GetInt
  00126	85 c0		 test	 eax, eax
  00128	74 0c		 je	 SHORT $LN15@TreeNodeBe
  0012a	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv137[ebp], 1
  00134	eb 0a		 jmp	 SHORT $LN16@TreeNodeBe
$LN15@TreeNodeBe:
  00136	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv137[ebp], 0
$LN16@TreeNodeBe:
  00140	8a 85 fc fe ff
	ff		 mov	 al, BYTE PTR tv137[ebp]
  00146	88 45 d7	 mov	 BYTE PTR _is_open$[ebp], al
$LN4@TreeNodeBe:

; 5200 :     }
; 5201 : 
; 5202 :     // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
; 5203 :     // NB- If we are above max depth we still allow manually opened nodes to be logged.
; 5204 :     if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)

  00149	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0014c	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  00153	85 c9		 test	 ecx, ecx
  00155	74 29		 je	 SHORT $LN9@TreeNodeBe
  00157	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0015a	83 e0 10	 and	 eax, 16			; 00000010H
  0015d	75 21		 jne	 SHORT $LN9@TreeNodeBe
  0015f	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00162	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00165	8b 90 00 01 00
	00		 mov	 edx, DWORD PTR [eax+256]
  0016b	2b 91 78 2d 00
	00		 sub	 edx, DWORD PTR [ecx+11640]
  00171	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00174	3b 90 7c 2d 00
	00		 cmp	 edx, DWORD PTR [eax+11644]
  0017a	7d 04		 jge	 SHORT $LN9@TreeNodeBe

; 5205 :         is_open = true;

  0017c	c6 45 d7 01	 mov	 BYTE PTR _is_open$[ebp], 1
$LN9@TreeNodeBe:

; 5206 : 
; 5207 :     return is_open;

  00180	8a 45 d7	 mov	 al, BYTE PTR _is_open$[ebp]
$LN1@TreeNodeBe:

; 5208 : }

  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  0018c	3b ec		 cmp	 ebp, esp
  0018e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z ENDP		; ImGui::TreeNodeBehaviorIsOpen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z
_TEXT	SEGMENT
tv584 = -972						; size = 4
tv445 = -972						; size = 4
tv615 = -968						; size = 4
tv585 = -968						; size = 4
tv477 = -968						; size = 4
tv446 = -968						; size = 4
tv409 = -968						; size = 4
tv371 = -968						; size = 4
tv341 = -968						; size = 4
tv312 = -968						; size = 4
tv203 = -968						; size = 4
tv192 = -968						; size = 4
tv159 = -968						; size = 4
tv91 = -968						; size = 4
tv265 = -965						; size = 1
tv71 = -965						; size = 1
$T1 = -960						; size = 8
$T2 = -944						; size = 8
$T3 = -928						; size = 8
$T4 = -912						; size = 8
$T5 = -896						; size = 8
$T6 = -880						; size = 8
$T7 = -864						; size = 8
$T8 = -848						; size = 8
$T9 = -832						; size = 8
$T10 = -816						; size = 4
_bg_col$11 = -420					; size = 4
_log_suffix$12 = -408					; size = 3
_log_prefix$13 = -396					; size = 4
_bg_col$14 = -384					; size = 4
_nav_highlight_flags$ = -372				; size = 4
_text_col$ = -360					; size = 4
_toggled$15 = -345					; size = 1
_pressed$ = -333					; size = 1
_held$ = -321						; size = 1
_hovered$ = -309					; size = 1
_was_selected$ = -297					; size = 1
_selected$ = -285					; size = 1
_arrow_hit_x2$ = -276					; size = 4
_arrow_hit_x1$ = -264					; size = 4
_hit_padding_x$ = -252					; size = 4
_button_flags$ = -240					; size = 4
_item_add$ = -225					; size = 1
_is_open$ = -213					; size = 1
_is_leaf$ = -201					; size = 1
_interact_bb$ = -192					; size = 16
_text_pos$ = -168					; size = 8
_text_width$ = -152					; size = 4
_text_offset_y$ = -140					; size = 4
_text_offset_x$ = -128					; size = 4
_frame_bb$ = -116					; size = 16
_frame_height$ = -92					; size = 4
_label_size$ = -80					; size = 8
_padding$ = -64						; size = 8
_display_frame$ = -45					; size = 1
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_label$ = 16						; size = 4
_label_end$ = 20					; size = 4
?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z PROC		; ImGui::TreeNodeBehavior, COMDAT

; 5211 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 03 00
	00		 sub	 esp, 972		; 000003ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-972]
  00012	b9 f3 00 00 00	 mov	 ecx, 243		; 000000f3H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5212 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 5213 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN8@TreeNodeBe

; 5214 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 0e 0e 00 00	 jmp	 $LN1@TreeNodeBe
$LN8@TreeNodeBe:

; 5215 : 
; 5216 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 5217 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 5218 :     const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;

  0005f	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00062	83 e0 02	 and	 eax, 2
  00065	74 09		 je	 SHORT $LN50@TreeNodeBe
  00067	c6 85 3b fc ff
	ff 01		 mov	 BYTE PTR tv71[ebp], 1
  0006e	eb 07		 jmp	 SHORT $LN51@TreeNodeBe
$LN50@TreeNodeBe:
  00070	c6 85 3b fc ff
	ff 00		 mov	 BYTE PTR tv71[ebp], 0
$LN51@TreeNodeBe:
  00077	8a 8d 3b fc ff
	ff		 mov	 cl, BYTE PTR tv71[ebp]
  0007d	88 4d d3	 mov	 BYTE PTR _display_frame$[ebp], cl

; 5219 :     const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));

  00080	0f b6 45 d3	 movzx	 eax, BYTE PTR _display_frame$[ebp]
  00084	85 c0		 test	 eax, eax
  00086	75 56		 jne	 SHORT $LN52@TreeNodeBe
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  0008b	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00091	75 4b		 jne	 SHORT $LN52@TreeNodeBe
  00093	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  00096	51		 push	 ecx
  00097	f3 0f 10 42 3c	 movss	 xmm0, DWORD PTR [edx+60]
  0009c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a1	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000a4	51		 push	 ecx
  000a5	f3 0f 10 80 f8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+248]
  000ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b2	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  000b7	83 c4 04	 add	 esp, 4
  000ba	d9 1c 24	 fstp	 DWORD PTR [esp]
  000bd	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  000c0	51		 push	 ecx
  000c1	f3 0f 10 41 38	 movss	 xmm0, DWORD PTR [ecx+56]
  000c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cb	8d 8d b0 fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  000d1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000d6	89 85 38 fc ff
	ff		 mov	 DWORD PTR tv91[ebp], eax
  000dc	eb 21		 jmp	 SHORT $LN53@TreeNodeBe
$LN52@TreeNodeBe:
  000de	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  000e1	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000e4	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  000e7	89 85 c0 fc ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  000ed	89 8d c4 fc ff
	ff		 mov	 DWORD PTR $T9[ebp+4], ecx
  000f3	8d 95 c0 fc ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  000f9	89 95 38 fc ff
	ff		 mov	 DWORD PTR tv91[ebp], edx
$LN53@TreeNodeBe:
  000ff	8b 85 38 fc ff
	ff		 mov	 eax, DWORD PTR tv91[ebp]
  00105	89 85 d0 fc ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
  0010b	8b 8d d0 fc ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  00111	8b 11		 mov	 edx, DWORD PTR [ecx]
  00113	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00116	89 55 c0	 mov	 DWORD PTR _padding$[ebp], edx
  00119	89 45 c4	 mov	 DWORD PTR _padding$[ebp+4], eax

; 5220 : 
; 5221 :     if (!label_end)

  0011c	83 7d 14 00	 cmp	 DWORD PTR _label_end$[ebp], 0
  00120	75 11		 jne	 SHORT $LN9@TreeNodeBe

; 5222 :         label_end = FindRenderedTextEnd(label);

  00122	6a 00		 push	 0
  00124	8b 45 10	 mov	 eax, DWORD PTR _label$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  0012d	83 c4 08	 add	 esp, 8
  00130	89 45 14	 mov	 DWORD PTR _label_end$[ebp], eax
$LN9@TreeNodeBe:

; 5223 :     const ImVec2 label_size = CalcTextSize(label, label_end, false);

  00133	51		 push	 ecx
  00134	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0013c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00141	6a 00		 push	 0
  00143	8b 45 14	 mov	 eax, DWORD PTR _label_end$[ebp]
  00146	50		 push	 eax
  00147	8b 4d 10	 mov	 ecx, DWORD PTR _label$[ebp]
  0014a	51		 push	 ecx
  0014b	8d 55 b0	 lea	 edx, DWORD PTR _label_size$[ebp]
  0014e	52		 push	 edx
  0014f	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00154	83 c4 14	 add	 esp, 20			; 00000014H

; 5224 : 
; 5225 :     // We vertically grow up to current line height up the typical widget height.
; 5226 :     const float frame_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);

  00157	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _padding$[ebp+4]
  0015c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00164	f3 0f 58 45 b4	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  00169	51		 push	 ecx
  0016a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016f	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00172	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00177	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0017f	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00182	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  0018a	51		 push	 ecx
  0018b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00190	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00193	51		 push	 ecx
  00194	f3 0f 10 82 ec
	00 00 00	 movss	 xmm0, DWORD PTR [edx+236]
  0019c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a1	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001a6	83 c4 04	 add	 esp, 4
  001a9	d9 1c 24	 fstp	 DWORD PTR [esp]
  001ac	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001b1	83 c4 08	 add	 esp, 8
  001b4	d9 5d a4	 fstp	 DWORD PTR _frame_height$[ebp]

; 5227 :     ImRect frame_bb;

  001b7	8d 4d 8c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  001ba	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect

; 5228 :     frame_bb.Min.x = (flags & ImGuiTreeNodeFlags_SpanFullWidth) ? window->WorkRect.Min.x : window->DC.CursorPos.x;

  001bf	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  001c2	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  001c7	74 15		 je	 SHORT $LN54@TreeNodeBe
  001c9	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  001cc	f3 0f 10 81 f4
	01 00 00	 movss	 xmm0, DWORD PTR [ecx+500]
  001d4	f3 0f 11 85 38
	fc ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
  001dc	eb 13		 jmp	 SHORT $LN55@TreeNodeBe
$LN54@TreeNodeBe:
  001de	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  001e1	f3 0f 10 82 c8
	00 00 00	 movss	 xmm0, DWORD PTR [edx+200]
  001e9	f3 0f 11 85 38
	fc ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
$LN55@TreeNodeBe:
  001f1	f3 0f 10 85 38
	fc ff ff	 movss	 xmm0, DWORD PTR tv159[ebp]
  001f9	f3 0f 11 45 8c	 movss	 DWORD PTR _frame_bb$[ebp], xmm0

; 5229 :     frame_bb.Min.y = window->DC.CursorPos.y;

  001fe	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00201	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  00209	f3 0f 11 45 90	 movss	 DWORD PTR _frame_bb$[ebp+4], xmm0

; 5230 :     frame_bb.Max.x = window->WorkRect.Max.x;

  0020e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00211	f3 0f 10 80 fc
	01 00 00	 movss	 xmm0, DWORD PTR [eax+508]
  00219	f3 0f 11 45 94	 movss	 DWORD PTR _frame_bb$[ebp+8], xmm0

; 5231 :     frame_bb.Max.y = window->DC.CursorPos.y + frame_height;

  0021e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00221	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  00229	f3 0f 58 45 a4	 addss	 xmm0, DWORD PTR _frame_height$[ebp]
  0022e	f3 0f 11 45 98	 movss	 DWORD PTR _frame_bb$[ebp+12], xmm0

; 5232 :     if (display_frame)

  00233	0f b6 45 d3	 movzx	 eax, BYTE PTR _display_frame$[ebp]
  00237	85 c0		 test	 eax, eax
  00239	74 50		 je	 SHORT $LN10@TreeNodeBe

; 5233 :     {
; 5234 :         // Framed header expand a little outside the default padding, to the edge of InnerClipRect
; 5235 :         // (FIXME: May remove this at some point and make InnerClipRect align with WindowPadding.x instead of WindowPadding.x*0.5f)
; 5236 :         frame_bb.Min.x -= IM_FLOOR(window->WindowPadding.x * 0.5f - 1.0f);

  0023b	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0023e	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [eax+52]
  00243	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0024b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00253	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00257	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0025b	f3 0f 10 4d 8c	 movss	 xmm1, DWORD PTR _frame_bb$[ebp]
  00260	f3 0f 5c c8	 subss	 xmm1, xmm0
  00264	f3 0f 11 4d 8c	 movss	 DWORD PTR _frame_bb$[ebp], xmm1

; 5237 :         frame_bb.Max.x += IM_FLOOR(window->WindowPadding.x * 0.5f);

  00269	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0026c	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [eax+52]
  00271	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00279	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0027d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00281	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  00286	f3 0f 11 45 94	 movss	 DWORD PTR _frame_bb$[ebp+8], xmm0
$LN10@TreeNodeBe:

; 5238 :     }
; 5239 : 
; 5240 :     const float text_offset_x = g.FontSize + (display_frame ? padding.x*3 : padding.x*2);               // Collapser arrow width + Spacing

  0028b	0f b6 45 d3	 movzx	 eax, BYTE PTR _display_frame$[ebp]
  0028f	85 c0		 test	 eax, eax
  00291	74 17		 je	 SHORT $LN56@TreeNodeBe
  00293	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _padding$[ebp]
  00298	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  002a0	f3 0f 11 85 38
	fc ff ff	 movss	 DWORD PTR tv192[ebp], xmm0
  002a8	eb 15		 jmp	 SHORT $LN57@TreeNodeBe
$LN56@TreeNodeBe:
  002aa	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _padding$[ebp]
  002af	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  002b7	f3 0f 11 85 38
	fc ff ff	 movss	 DWORD PTR tv192[ebp], xmm0
$LN57@TreeNodeBe:
  002bf	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  002c2	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  002ca	f3 0f 58 85 38
	fc ff ff	 addss	 xmm0, DWORD PTR tv192[ebp]
  002d2	f3 0f 11 45 80	 movss	 DWORD PTR _text_offset_x$[ebp], xmm0

; 5241 :     const float text_offset_y = ImMax(padding.y, window->DC.CurrLineTextBaseOffset);                    // Latch before ItemSize changes it

  002d7	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002da	51		 push	 ecx
  002db	f3 0f 10 80 f8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+248]
  002e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e8	51		 push	 ecx
  002e9	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _padding$[ebp+4]
  002ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002f8	83 c4 08	 add	 esp, 8
  002fb	d9 9d 74 ff ff
	ff		 fstp	 DWORD PTR _text_offset_y$[ebp]

; 5242 :     const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);    // Include collapser

  00301	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00306	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0030d	76 1c		 jbe	 SHORT $LN58@TreeNodeBe
  0030f	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _padding$[ebp]
  00314	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0031c	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  00321	f3 0f 11 85 38
	fc ff ff	 movss	 DWORD PTR tv203[ebp], xmm0
  00329	eb 0b		 jmp	 SHORT $LN59@TreeNodeBe
$LN58@TreeNodeBe:
  0032b	0f 57 c0	 xorps	 xmm0, xmm0
  0032e	f3 0f 11 85 38
	fc ff ff	 movss	 DWORD PTR tv203[ebp], xmm0
$LN59@TreeNodeBe:
  00336	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00339	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00341	f3 0f 58 85 38
	fc ff ff	 addss	 xmm0, DWORD PTR tv203[ebp]
  00349	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _text_width$[ebp], xmm0

; 5243 :     ImVec2 text_pos(window->DC.CursorPos.x + text_offset_x, window->DC.CursorPos.y + text_offset_y);

  00351	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00354	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  0035c	f3 0f 58 85 74
	ff ff ff	 addss	 xmm0, DWORD PTR _text_offset_y$[ebp]
  00364	51		 push	 ecx
  00365	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036a	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0036d	f3 0f 10 81 c8
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+200]
  00375	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  0037a	51		 push	 ecx
  0037b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00380	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _text_pos$[ebp]
  00386	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 5244 :     ItemSize(ImVec2(text_width, frame_height), padding.y);

  0038b	51		 push	 ecx
  0038c	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _padding$[ebp+4]
  00391	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00396	51		 push	 ecx
  00397	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _frame_height$[ebp]
  0039c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a1	51		 push	 ecx
  003a2	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _text_width$[ebp]
  003aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003af	8d 8d a0 fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  003b5	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  003c0	83 c4 08	 add	 esp, 8

; 5245 : 
; 5246 :     // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
; 5247 :     ImRect interact_bb = frame_bb;

  003c3	8b 45 8c	 mov	 eax, DWORD PTR _frame_bb$[ebp]
  003c6	89 85 40 ff ff
	ff		 mov	 DWORD PTR _interact_bb$[ebp], eax
  003cc	8b 4d 90	 mov	 ecx, DWORD PTR _frame_bb$[ebp+4]
  003cf	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _interact_bb$[ebp+4], ecx
  003d5	8b 55 94	 mov	 edx, DWORD PTR _frame_bb$[ebp+8]
  003d8	89 95 48 ff ff
	ff		 mov	 DWORD PTR _interact_bb$[ebp+8], edx
  003de	8b 45 98	 mov	 eax, DWORD PTR _frame_bb$[ebp+12]
  003e1	89 85 4c ff ff
	ff		 mov	 DWORD PTR _interact_bb$[ebp+12], eax

; 5248 :     if (!display_frame && (flags & (ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_SpanFullWidth)) == 0)

  003e7	0f b6 45 d3	 movzx	 eax, BYTE PTR _display_frame$[ebp]
  003eb	85 c0		 test	 eax, eax
  003ed	75 33		 jne	 SHORT $LN11@TreeNodeBe
  003ef	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  003f2	25 00 18 00 00	 and	 eax, 6144		; 00001800H
  003f7	75 29		 jne	 SHORT $LN11@TreeNodeBe

; 5249 :         interact_bb.Max.x = frame_bb.Min.x + text_width + style.ItemSpacing.x * 2.0f;

  003f9	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _frame_bb$[ebp]
  003fe	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _text_width$[ebp]
  00406	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00409	f3 0f 10 48 48	 movss	 xmm1, DWORD PTR [eax+72]
  0040e	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  00416	f3 0f 58 c1	 addss	 xmm0, xmm1
  0041a	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _interact_bb$[ebp+8], xmm0
$LN11@TreeNodeBe:

; 5250 : 
; 5251 :     // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
; 5252 :     // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
; 5253 :     // This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
; 5254 :     const bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;

  00422	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00425	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0042a	74 09		 je	 SHORT $LN60@TreeNodeBe
  0042c	c6 85 3b fc ff
	ff 01		 mov	 BYTE PTR tv265[ebp], 1
  00433	eb 07		 jmp	 SHORT $LN61@TreeNodeBe
$LN60@TreeNodeBe:
  00435	c6 85 3b fc ff
	ff 00		 mov	 BYTE PTR tv265[ebp], 0
$LN61@TreeNodeBe:
  0043c	8a 8d 3b fc ff
	ff		 mov	 cl, BYTE PTR tv265[ebp]
  00442	88 8d 37 ff ff
	ff		 mov	 BYTE PTR _is_leaf$[ebp], cl

; 5255 :     bool is_open = TreeNodeBehaviorIsOpen(id, flags);

  00448	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0044b	50		 push	 eax
  0044c	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  0044f	51		 push	 ecx
  00450	e8 00 00 00 00	 call	 ?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z ; ImGui::TreeNodeBehaviorIsOpen
  00455	83 c4 08	 add	 esp, 8
  00458	88 85 2b ff ff
	ff		 mov	 BYTE PTR _is_open$[ebp], al

; 5256 :     if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

  0045e	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  00465	85 c0		 test	 eax, eax
  00467	74 42		 je	 SHORT $LN12@TreeNodeBe
  00469	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0046c	0f b6 88 30 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6960]
  00473	85 c9		 test	 ecx, ecx
  00475	75 34		 jne	 SHORT $LN12@TreeNodeBe
  00477	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0047a	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0047f	74 2a		 je	 SHORT $LN12@TreeNodeBe
  00481	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00484	83 e0 08	 and	 eax, 8
  00487	75 22		 jne	 SHORT $LN12@TreeNodeBe

; 5257 :         window->DC.TreeMayJumpToParentOnPopMask |= (1 << window->DC.TreeDepth);

  00489	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0048c	ba 01 00 00 00	 mov	 edx, 1
  00491	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  00497	d3 e2		 shl	 edx, cl
  00499	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0049c	0b 90 04 01 00
	00		 or	 edx, DWORD PTR [eax+260]
  004a2	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  004a5	89 91 04 01 00
	00		 mov	 DWORD PTR [ecx+260], edx
$LN12@TreeNodeBe:

; 5258 : 
; 5259 :     bool item_add = ItemAdd(interact_bb, id);

  004ab	6a 00		 push	 0
  004ad	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  004b0	50		 push	 eax
  004b1	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _interact_bb$[ebp]
  004b7	51		 push	 ecx
  004b8	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  004bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c0	88 85 1f ff ff
	ff		 mov	 BYTE PTR _item_add$[ebp], al

; 5260 :     window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;

  004c6	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  004c9	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  004cf	83 c9 02	 or	 ecx, 2
  004d2	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  004d5	89 8a 0c 01 00
	00		 mov	 DWORD PTR [edx+268], ecx

; 5261 :     window->DC.LastItemDisplayRect = frame_bb;

  004db	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  004de	05 20 01 00 00	 add	 eax, 288		; 00000120H
  004e3	8b 4d 8c	 mov	 ecx, DWORD PTR _frame_bb$[ebp]
  004e6	89 08		 mov	 DWORD PTR [eax], ecx
  004e8	8b 55 90	 mov	 edx, DWORD PTR _frame_bb$[ebp+4]
  004eb	89 50 04	 mov	 DWORD PTR [eax+4], edx
  004ee	8b 4d 94	 mov	 ecx, DWORD PTR _frame_bb$[ebp+8]
  004f1	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  004f4	8b 55 98	 mov	 edx, DWORD PTR _frame_bb$[ebp+12]
  004f7	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 5262 : 
; 5263 :     if (!item_add)

  004fa	0f b6 85 1f ff
	ff ff		 movzx	 eax, BYTE PTR _item_add$[ebp]
  00501	85 c0		 test	 eax, eax
  00503	75 2e		 jne	 SHORT $LN13@TreeNodeBe

; 5264 :     {
; 5265 :         if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

  00505	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  0050c	85 c0		 test	 eax, eax
  0050e	74 14		 je	 SHORT $LN14@TreeNodeBe
  00510	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00513	83 e0 08	 and	 eax, 8
  00516	75 0c		 jne	 SHORT $LN14@TreeNodeBe

; 5266 :             TreePushOverrideID(id);

  00518	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 ?TreePushOverrideID@ImGui@@YAXI@Z ; ImGui::TreePushOverrideID
  00521	83 c4 04	 add	 esp, 4
$LN14@TreeNodeBe:

; 5267 :         IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));

  00524	33 c0		 xor	 eax, eax
  00526	75 fc		 jne	 SHORT $LN14@TreeNodeBe

; 5268 :         return is_open;

  00528	8a 85 2b ff ff
	ff		 mov	 al, BYTE PTR _is_open$[ebp]
  0052e	e9 27 09 00 00	 jmp	 $LN1@TreeNodeBe
$LN13@TreeNodeBe:

; 5269 :     }
; 5270 : 
; 5271 :     // Flags that affects opening behavior:
; 5272 :     // - 0 (default) .................... single-click anywhere to open
; 5273 :     // - OpenOnDoubleClick .............. double-click anywhere to open
; 5274 :     // - OpenOnArrow .................... single-click on arrow to open
; 5275 :     // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
; 5276 :     ImGuiButtonFlags button_flags = 0;

  00533	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _button_flags$[ebp], 0

; 5277 :     if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)

  0053d	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00540	83 e0 04	 and	 eax, 4
  00543	74 0f		 je	 SHORT $LN15@TreeNodeBe

; 5278 :         button_flags |= ImGuiButtonFlags_AllowItemOverlap;

  00545	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  0054b	83 c8 40	 or	 eax, 64			; 00000040H
  0054e	89 85 10 ff ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN15@TreeNodeBe:

; 5279 :     if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)

  00554	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00557	83 e0 40	 and	 eax, 64			; 00000040H
  0055a	74 35		 je	 SHORT $LN16@TreeNodeBe

; 5280 :         button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);

  0055c	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0055f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00564	74 0c		 je	 SHORT $LN62@TreeNodeBe
  00566	c7 85 38 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR tv312[ebp], 2
  00570	eb 0a		 jmp	 SHORT $LN63@TreeNodeBe
$LN62@TreeNodeBe:
  00572	c7 85 38 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv312[ebp], 0
$LN63@TreeNodeBe:
  0057c	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv312[ebp]
  00582	83 c9 10	 or	 ecx, 16			; 00000010H
  00585	0b 8d 10 ff ff
	ff		 or	 ecx, DWORD PTR _button_flags$[ebp]
  0058b	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], ecx
$LN16@TreeNodeBe:

; 5281 :     if (!is_leaf)

  00591	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _is_leaf$[ebp]
  00598	85 c0		 test	 eax, eax
  0059a	75 11		 jne	 SHORT $LN17@TreeNodeBe

; 5282 :         button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

  0059c	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  005a2	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  005a7	89 85 10 ff ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN17@TreeNodeBe:

; 5283 : 
; 5284 :     // We allow clicking on the arrow section with keyboard modifiers held, in order to easily 
; 5285 :     // allow browsing a tree while preserving selection with code implementing multi-selection patterns.
; 5286 :     // When clicking on the rest of the tree node we always disallow keyboard modifiers.
; 5287 :     const float hit_padding_x = style.TouchExtraPadding.x;

  005ad	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  005b0	f3 0f 10 40 58	 movss	 xmm0, DWORD PTR [eax+88]
  005b5	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _hit_padding_x$[ebp], xmm0

; 5288 :     const float arrow_hit_x1 = (text_pos.x - text_offset_x) - hit_padding_x;

  005bd	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _text_pos$[ebp]
  005c5	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  005ca	f3 0f 5c 85 04
	ff ff ff	 subss	 xmm0, DWORD PTR _hit_padding_x$[ebp]
  005d2	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR _arrow_hit_x1$[ebp], xmm0

; 5289 :     const float arrow_hit_x2 = (text_pos.x - text_offset_x) + (g.FontSize + padding.x * 2.0f) + hit_padding_x;

  005da	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _text_pos$[ebp]
  005e2	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  005e7	f3 0f 10 4d c0	 movss	 xmm1, DWORD PTR _padding$[ebp]
  005ec	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  005f4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005f7	f3 0f 58 88 c4
	18 00 00	 addss	 xmm1, DWORD PTR [eax+6340]
  005ff	f3 0f 58 c1	 addss	 xmm0, xmm1
  00603	f3 0f 58 85 04
	ff ff ff	 addss	 xmm0, DWORD PTR _hit_padding_x$[ebp]
  0060b	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _arrow_hit_x2$[ebp], xmm0

; 5290 :     if (window != g.HoveredWindow || !(g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2))

  00613	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00616	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00619	3b 88 b4 19 00
	00		 cmp	 ecx, DWORD PTR [eax+6580]
  0061f	75 28		 jne	 SHORT $LN20@TreeNodeBe
  00621	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00624	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+232]
  0062c	0f 2f 85 f8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _arrow_hit_x1$[ebp]
  00633	72 14		 jb	 SHORT $LN20@TreeNodeBe
  00635	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00638	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _arrow_hit_x2$[ebp]
  00640	0f 2f 80 e8 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+232]
  00647	77 11		 ja	 SHORT $LN18@TreeNodeBe
$LN20@TreeNodeBe:

; 5291 :         button_flags |= ImGuiButtonFlags_NoKeyModifiers;

  00649	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  0064f	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  00654	89 85 10 ff ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN18@TreeNodeBe:

; 5292 :     
; 5293 :     bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;

  0065a	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0065d	83 e0 01	 and	 eax, 1
  00660	74 0c		 je	 SHORT $LN64@TreeNodeBe
  00662	c7 85 38 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv341[ebp], 1
  0066c	eb 0a		 jmp	 SHORT $LN65@TreeNodeBe
$LN64@TreeNodeBe:
  0066e	c7 85 38 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv341[ebp], 0
$LN65@TreeNodeBe:
  00678	8a 8d 38 fc ff
	ff		 mov	 cl, BYTE PTR tv341[ebp]
  0067e	88 8d e3 fe ff
	ff		 mov	 BYTE PTR _selected$[ebp], cl

; 5294 :     const bool was_selected = selected;

  00684	8a 85 e3 fe ff
	ff		 mov	 al, BYTE PTR _selected$[ebp]
  0068a	88 85 d7 fe ff
	ff		 mov	 BYTE PTR _was_selected$[ebp], al

; 5295 : 
; 5296 :     bool hovered, held;
; 5297 :     bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);

  00690	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  00696	50		 push	 eax
  00697	8d 8d bf fe ff
	ff		 lea	 ecx, DWORD PTR _held$[ebp]
  0069d	51		 push	 ecx
  0069e	8d 95 cb fe ff
	ff		 lea	 edx, DWORD PTR _hovered$[ebp]
  006a4	52		 push	 edx
  006a5	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  006a8	50		 push	 eax
  006a9	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _interact_bb$[ebp]
  006af	51		 push	 ecx
  006b0	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  006b5	83 c4 14	 add	 esp, 20			; 00000014H
  006b8	88 85 b3 fe ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 5298 :     if (!is_leaf)

  006be	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _is_leaf$[ebp]
  006c5	85 c0		 test	 eax, eax
  006c7	0f 85 c9 01 00
	00		 jne	 $LN30@TreeNodeBe

; 5299 :     {
; 5300 :         bool toggled = false;

  006cd	c6 85 a7 fe ff
	ff 00		 mov	 BYTE PTR _toggled$15[ebp], 0

; 5301 :         if (pressed)

  006d4	0f b6 85 b3 fe
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  006db	85 c0		 test	 eax, eax
  006dd	0f 84 ce 00 00
	00		 je	 $LN27@TreeNodeBe

; 5302 :         {
; 5303 :             if ((flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) == 0 || (g.NavActivateId == id))

  006e3	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  006e6	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  006eb	74 0e		 je	 SHORT $LN24@TreeNodeBe
  006ed	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  006f0	8b 88 d8 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6872]
  006f6	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  006f9	75 07		 jne	 SHORT $LN23@TreeNodeBe
$LN24@TreeNodeBe:

; 5304 :                 toggled = true;

  006fb	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR _toggled$15[ebp], 1
$LN23@TreeNodeBe:

; 5305 :             if (flags & ImGuiTreeNodeFlags_OpenOnArrow)

  00702	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00705	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0070a	74 5f		 je	 SHORT $LN25@TreeNodeBe

; 5306 :                 toggled |= (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2) && (!g.NavDisableMouseHover); // Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job

  0070c	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0070f	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+232]
  00717	0f 2f 85 f8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _arrow_hit_x1$[ebp]
  0071e	72 2e		 jb	 SHORT $LN66@TreeNodeBe
  00720	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00723	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _arrow_hit_x2$[ebp]
  0072b	0f 2f 81 e8 00
	00 00		 comiss	 xmm0, DWORD PTR [ecx+232]
  00732	76 1a		 jbe	 SHORT $LN66@TreeNodeBe
  00734	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00737	0f b6 82 33 1b
	00 00		 movzx	 eax, BYTE PTR [edx+6963]
  0073e	85 c0		 test	 eax, eax
  00740	75 0c		 jne	 SHORT $LN66@TreeNodeBe
  00742	c7 85 38 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv371[ebp], 1
  0074c	eb 0a		 jmp	 SHORT $LN67@TreeNodeBe
$LN66@TreeNodeBe:
  0074e	c7 85 38 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv371[ebp], 0
$LN67@TreeNodeBe:
  00758	0f b6 8d a7 fe
	ff ff		 movzx	 ecx, BYTE PTR _toggled$15[ebp]
  0075f	0b 8d 38 fc ff
	ff		 or	 ecx, DWORD PTR tv371[ebp]
  00765	88 8d a7 fe ff
	ff		 mov	 BYTE PTR _toggled$15[ebp], cl
$LN25@TreeNodeBe:

; 5307 :             if ((flags & ImGuiTreeNodeFlags_OpenOnDoubleClick) && g.IO.MouseDoubleClicked[0])

  0076b	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  0076e	83 e0 40	 and	 eax, 64			; 00000040H
  00771	74 1e		 je	 SHORT $LN26@TreeNodeBe
  00773	b8 01 00 00 00	 mov	 eax, 1
  00778	6b c8 00	 imul	 ecx, eax, 0
  0077b	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  0077e	0f b6 84 0a dd
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+989]
  00786	85 c0		 test	 eax, eax
  00788	74 07		 je	 SHORT $LN26@TreeNodeBe

; 5308 :                 toggled = true;

  0078a	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR _toggled$15[ebp], 1
$LN26@TreeNodeBe:

; 5309 :             if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.

  00791	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00794	0f b6 88 34 1d
	00 00		 movzx	 ecx, BYTE PTR [eax+7476]
  0079b	85 c9		 test	 ecx, ecx
  0079d	74 12		 je	 SHORT $LN27@TreeNodeBe
  0079f	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  007a6	85 c0		 test	 eax, eax
  007a8	74 07		 je	 SHORT $LN27@TreeNodeBe

; 5310 :                 toggled = false;

  007aa	c6 85 a7 fe ff
	ff 00		 mov	 BYTE PTR _toggled$15[ebp], 0
$LN27@TreeNodeBe:

; 5311 :         }
; 5312 : 
; 5313 :         if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)

  007b1	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  007b4	8b 88 d4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6868]
  007ba	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  007bd	75 31		 jne	 SHORT $LN28@TreeNodeBe
  007bf	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  007c2	0f b6 88 4d 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6989]
  007c9	85 c9		 test	 ecx, ecx
  007cb	74 23		 je	 SHORT $LN28@TreeNodeBe
  007cd	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  007d0	83 b8 58 1b 00
	00 00		 cmp	 DWORD PTR [eax+7000], 0
  007d7	75 17		 jne	 SHORT $LN28@TreeNodeBe
  007d9	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  007e0	85 c0		 test	 eax, eax
  007e2	74 0c		 je	 SHORT $LN28@TreeNodeBe

; 5314 :         {
; 5315 :             toggled = true;

  007e4	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR _toggled$15[ebp], 1

; 5316 :             NavMoveRequestCancel();

  007eb	e8 00 00 00 00	 call	 ?NavMoveRequestCancel@ImGui@@YAXXZ ; ImGui::NavMoveRequestCancel
$LN28@TreeNodeBe:

; 5317 :         }
; 5318 :         if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?

  007f0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  007f3	8b 88 d4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6868]
  007f9	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  007fc	75 31		 jne	 SHORT $LN29@TreeNodeBe
  007fe	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00801	0f b6 88 4d 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6989]
  00808	85 c9		 test	 ecx, ecx
  0080a	74 23		 je	 SHORT $LN29@TreeNodeBe
  0080c	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0080f	83 b8 58 1b 00
	00 01		 cmp	 DWORD PTR [eax+7000], 1
  00816	75 17		 jne	 SHORT $LN29@TreeNodeBe
  00818	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  0081f	85 c0		 test	 eax, eax
  00821	75 0c		 jne	 SHORT $LN29@TreeNodeBe

; 5319 :         {
; 5320 :             toggled = true;

  00823	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR _toggled$15[ebp], 1

; 5321 :             NavMoveRequestCancel();

  0082a	e8 00 00 00 00	 call	 ?NavMoveRequestCancel@ImGui@@YAXXZ ; ImGui::NavMoveRequestCancel
$LN29@TreeNodeBe:

; 5322 :         }
; 5323 : 
; 5324 :         if (toggled)

  0082f	0f b6 85 a7 fe
	ff ff		 movzx	 eax, BYTE PTR _toggled$15[ebp]
  00836	85 c0		 test	 eax, eax
  00838	74 5c		 je	 SHORT $LN30@TreeNodeBe

; 5325 :         {
; 5326 :             is_open = !is_open;

  0083a	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  00841	85 c0		 test	 eax, eax
  00843	75 0c		 jne	 SHORT $LN68@TreeNodeBe
  00845	c7 85 38 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv409[ebp], 1
  0084f	eb 0a		 jmp	 SHORT $LN69@TreeNodeBe
$LN68@TreeNodeBe:
  00851	c7 85 38 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv409[ebp], 0
$LN69@TreeNodeBe:
  0085b	8a 8d 38 fc ff
	ff		 mov	 cl, BYTE PTR tv409[ebp]
  00861	88 8d 2b ff ff
	ff		 mov	 BYTE PTR _is_open$[ebp], cl

; 5327 :             window->DC.StateStorage->SetInt(id, is_open);

  00867	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  0086e	50		 push	 eax
  0086f	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00872	51		 push	 ecx
  00873	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00876	8b 8a 58 01 00
	00		 mov	 ecx, DWORD PTR [edx+344]
  0087c	e8 00 00 00 00	 call	 ?SetInt@ImGuiStorage@@QAEXIH@Z ; ImGuiStorage::SetInt

; 5328 :             window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledOpen;

  00881	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00884	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  0088a	83 c9 10	 or	 ecx, 16			; 00000010H
  0088d	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00890	89 8a 0c 01 00
	00		 mov	 DWORD PTR [edx+268], ecx
$LN30@TreeNodeBe:

; 5329 :         }
; 5330 :     }
; 5331 :     if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)

  00896	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00899	83 e0 04	 and	 eax, 4
  0089c	74 05		 je	 SHORT $LN31@TreeNodeBe

; 5332 :         SetItemAllowOverlap();

  0089e	e8 00 00 00 00	 call	 ?SetItemAllowOverlap@ImGui@@YAXXZ ; ImGui::SetItemAllowOverlap
$LN31@TreeNodeBe:

; 5333 : 
; 5334 :     // In this branch, TreeNodeBehavior() cannot toggle the selection so this will never trigger.
; 5335 :     if (selected != was_selected) //-V547

  008a3	0f b6 85 e3 fe
	ff ff		 movzx	 eax, BYTE PTR _selected$[ebp]
  008aa	0f b6 8d d7 fe
	ff ff		 movzx	 ecx, BYTE PTR _was_selected$[ebp]
  008b1	3b c1		 cmp	 eax, ecx
  008b3	74 15		 je	 SHORT $LN32@TreeNodeBe

; 5336 :         window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

  008b5	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  008b8	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  008be	83 c9 08	 or	 ecx, 8
  008c1	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  008c4	89 8a 0c 01 00
	00		 mov	 DWORD PTR [edx+268], ecx
$LN32@TreeNodeBe:

; 5337 : 
; 5338 :     // Render
; 5339 :     const ImU32 text_col = GetColorU32(ImGuiCol_Text);

  008ca	51		 push	 ecx
  008cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d8	6a 00		 push	 0
  008da	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  008df	83 c4 08	 add	 esp, 8
  008e2	89 85 98 fe ff
	ff		 mov	 DWORD PTR _text_col$[ebp], eax

; 5340 :     ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_TypeThin;

  008e8	c7 85 8c fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _nav_highlight_flags$[ebp], 2

; 5341 :     if (display_frame)

  008f2	0f b6 45 d3	 movzx	 eax, BYTE PTR _display_frame$[ebp]
  008f6	85 c0		 test	 eax, eax
  008f8	0f 84 ff 02 00
	00		 je	 $LN33@TreeNodeBe

; 5342 :     {
; 5343 :         // Framed type
; 5344 :         const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

  008fe	0f b6 85 bf fe
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  00905	85 c0		 test	 eax, eax
  00907	74 17		 je	 SHORT $LN70@TreeNodeBe
  00909	0f b6 8d cb fe
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  00910	85 c9		 test	 ecx, ecx
  00912	74 0c		 je	 SHORT $LN70@TreeNodeBe
  00914	c7 85 38 fc ff
	ff 1a 00 00 00	 mov	 DWORD PTR tv446[ebp], 26 ; 0000001aH
  0091e	eb 2d		 jmp	 SHORT $LN73@TreeNodeBe
$LN70@TreeNodeBe:
  00920	0f b6 95 cb fe
	ff ff		 movzx	 edx, BYTE PTR _hovered$[ebp]
  00927	85 d2		 test	 edx, edx
  00929	74 0c		 je	 SHORT $LN71@TreeNodeBe
  0092b	c7 85 34 fc ff
	ff 19 00 00 00	 mov	 DWORD PTR tv445[ebp], 25 ; 00000019H
  00935	eb 0a		 jmp	 SHORT $LN72@TreeNodeBe
$LN71@TreeNodeBe:
  00937	c7 85 34 fc ff
	ff 18 00 00 00	 mov	 DWORD PTR tv445[ebp], 24 ; 00000018H
$LN72@TreeNodeBe:
  00941	8b 85 34 fc ff
	ff		 mov	 eax, DWORD PTR tv445[ebp]
  00947	89 85 38 fc ff
	ff		 mov	 DWORD PTR tv446[ebp], eax
$LN73@TreeNodeBe:
  0094d	51		 push	 ecx
  0094e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00956	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0095b	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv446[ebp]
  00961	51		 push	 ecx
  00962	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00967	83 c4 08	 add	 esp, 8
  0096a	89 85 80 fe ff
	ff		 mov	 DWORD PTR _bg_col$14[ebp], eax

; 5345 :         RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);

  00970	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00973	51		 push	 ecx
  00974	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00979	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0097e	6a 01		 push	 1
  00980	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _bg_col$14[ebp]
  00986	51		 push	 ecx
  00987	8b 55 98	 mov	 edx, DWORD PTR _frame_bb$[ebp+12]
  0098a	52		 push	 edx
  0098b	8b 45 94	 mov	 eax, DWORD PTR _frame_bb$[ebp+8]
  0098e	50		 push	 eax
  0098f	8b 4d 90	 mov	 ecx, DWORD PTR _frame_bb$[ebp+4]
  00992	51		 push	 ecx
  00993	8b 55 8c	 mov	 edx, DWORD PTR _frame_bb$[ebp]
  00996	52		 push	 edx
  00997	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  0099c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5346 :         RenderNavHighlight(frame_bb, id, nav_highlight_flags);

  0099f	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _nav_highlight_flags$[ebp]
  009a5	50		 push	 eax
  009a6	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  009a9	51		 push	 ecx
  009aa	8d 55 8c	 lea	 edx, DWORD PTR _frame_bb$[ebp]
  009ad	52		 push	 edx
  009ae	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  009b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5347 :         if (flags & ImGuiTreeNodeFlags_Bullet)

  009b6	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  009b9	25 00 02 00 00	 and	 eax, 512		; 00000200H
  009be	74 70		 je	 SHORT $LN35@TreeNodeBe

; 5348 :             RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.60f, text_pos.y + g.FontSize * 0.5f), text_col);

  009c0	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _text_col$[ebp]
  009c6	50		 push	 eax
  009c7	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  009ca	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  009d2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  009da	f3 0f 58 85 5c
	ff ff ff	 addss	 xmm0, DWORD PTR _text_pos$[ebp+4]
  009e2	51		 push	 ecx
  009e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009e8	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  009ed	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f19999a
  009f5	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _text_pos$[ebp]
  009fd	f3 0f 5c c8	 subss	 xmm1, xmm0
  00a01	51		 push	 ecx
  00a02	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00a07	8d 8d 90 fc ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00a0d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00a12	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00a15	52		 push	 edx
  00a16	8b 00		 mov	 eax, DWORD PTR [eax]
  00a18	50		 push	 eax
  00a19	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00a1c	8b 91 74 02 00
	00		 mov	 edx, DWORD PTR [ecx+628]
  00a22	52		 push	 edx
  00a23	e8 00 00 00 00	 call	 ?RenderBullet@ImGui@@YAXPAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
  00a28	83 c4 10	 add	 esp, 16			; 00000010H
  00a2b	e9 ad 00 00 00	 jmp	 $LN38@TreeNodeBe
$LN35@TreeNodeBe:

; 5349 :         else if (!is_leaf)

  00a30	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _is_leaf$[ebp]
  00a37	85 c0		 test	 eax, eax
  00a39	0f 85 89 00 00
	00		 jne	 $LN37@TreeNodeBe

; 5350 :             RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y), text_col, is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);

  00a3f	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  00a46	85 c0		 test	 eax, eax
  00a48	74 0c		 je	 SHORT $LN74@TreeNodeBe
  00a4a	c7 85 38 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR tv477[ebp], 3
  00a54	eb 0a		 jmp	 SHORT $LN75@TreeNodeBe
$LN74@TreeNodeBe:
  00a56	c7 85 38 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv477[ebp], 1
$LN75@TreeNodeBe:
  00a60	51		 push	 ecx
  00a61	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a69	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a6e	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv477[ebp]
  00a74	51		 push	 ecx
  00a75	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _text_col$[ebp]
  00a7b	52		 push	 edx
  00a7c	51		 push	 ecx
  00a7d	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _text_pos$[ebp+4]
  00a85	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a8a	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _text_pos$[ebp]
  00a92	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  00a97	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _padding$[ebp]
  00a9c	51		 push	 ecx
  00a9d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aa2	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00aa8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00aad	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ab0	51		 push	 ecx
  00ab1	8b 10		 mov	 edx, DWORD PTR [eax]
  00ab3	52		 push	 edx
  00ab4	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00ab7	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00abd	51		 push	 ecx
  00abe	e8 00 00 00 00	 call	 ?RenderArrow@ImGui@@YAXPAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
  00ac3	83 c4 18	 add	 esp, 24			; 00000018H
  00ac6	eb 15		 jmp	 SHORT $LN38@TreeNodeBe
$LN37@TreeNodeBe:

; 5351 :         else // Leaf without bullet, left-adjusted text
; 5352 :             text_pos.x -= text_offset_x;

  00ac8	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _text_pos$[ebp]
  00ad0	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  00ad5	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _text_pos$[ebp], xmm0
$LN38@TreeNodeBe:

; 5353 :         if (flags & ImGuiTreeNodeFlags_ClipLabelForTrailingButton)

  00add	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00ae0	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00ae5	74 21		 je	 SHORT $LN39@TreeNodeBe

; 5354 :             frame_bb.Max.x -= g.FontSize + style.FramePadding.x;

  00ae7	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00aea	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00aed	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00af5	f3 0f 58 41 38	 addss	 xmm0, DWORD PTR [ecx+56]
  00afa	f3 0f 10 4d 94	 movss	 xmm1, DWORD PTR _frame_bb$[ebp+8]
  00aff	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b03	f3 0f 11 4d 94	 movss	 DWORD PTR _frame_bb$[ebp+8], xmm1
$LN39@TreeNodeBe:

; 5355 :         if (g.LogEnabled)

  00b08	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00b0b	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  00b12	85 c9		 test	 ecx, ecx
  00b14	0f 84 9f 00 00
	00		 je	 $LN40@TreeNodeBe

; 5356 :         {
; 5357 :             // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
; 5358 :             const char log_prefix[] = "\n##";

  00b1a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_03DFKEEPFP@?6?$CD?$CD@
  00b1f	89 85 74 fe ff
	ff		 mov	 DWORD PTR _log_prefix$13[ebp], eax

; 5359 :             const char log_suffix[] = "##";

  00b25	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02IEBMKJDF@?$CD?$CD@
  00b2b	66 89 85 68 fe
	ff ff		 mov	 WORD PTR _log_suffix$12[ebp], ax
  00b32	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ??_C@_02IEBMKJDF@?$CD?$CD@+2
  00b38	88 8d 6a fe ff
	ff		 mov	 BYTE PTR _log_suffix$12[ebp+2], cl

; 5360 :             LogRenderedText(&text_pos, log_prefix, log_prefix+3);

  00b3e	8d 85 77 fe ff
	ff		 lea	 eax, DWORD PTR _log_prefix$13[ebp+3]
  00b44	50		 push	 eax
  00b45	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _log_prefix$13[ebp]
  00b4b	51		 push	 ecx
  00b4c	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _text_pos$[ebp]
  00b52	52		 push	 edx
  00b53	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z ; ImGui::LogRenderedText
  00b58	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5361 :             RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);

  00b5b	6a 00		 push	 0
  00b5d	51		 push	 ecx
  00b5e	0f 57 c0	 xorps	 xmm0, xmm0
  00b61	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b66	51		 push	 ecx
  00b67	0f 57 c0	 xorps	 xmm0, xmm0
  00b6a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b6f	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00b75	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00b7a	50		 push	 eax
  00b7b	8d 45 b0	 lea	 eax, DWORD PTR _label_size$[ebp]
  00b7e	50		 push	 eax
  00b7f	8b 4d 14	 mov	 ecx, DWORD PTR _label_end$[ebp]
  00b82	51		 push	 ecx
  00b83	8b 55 10	 mov	 edx, DWORD PTR _label$[ebp]
  00b86	52		 push	 edx
  00b87	8d 45 94	 lea	 eax, DWORD PTR _frame_bb$[ebp+8]
  00b8a	50		 push	 eax
  00b8b	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _text_pos$[ebp]
  00b91	51		 push	 ecx
  00b92	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00b97	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5362 :             LogRenderedText(&text_pos, log_suffix, log_suffix+2);

  00b9a	8d 85 6a fe ff
	ff		 lea	 eax, DWORD PTR _log_suffix$12[ebp+2]
  00ba0	50		 push	 eax
  00ba1	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _log_suffix$12[ebp]
  00ba7	51		 push	 ecx
  00ba8	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _text_pos$[ebp]
  00bae	52		 push	 edx
  00baf	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z ; ImGui::LogRenderedText
  00bb4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5363 :         }

  00bb7	eb 3f		 jmp	 SHORT $LN41@TreeNodeBe
$LN40@TreeNodeBe:

; 5364 :         else
; 5365 :         {
; 5366 :             RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);

  00bb9	6a 00		 push	 0
  00bbb	51		 push	 ecx
  00bbc	0f 57 c0	 xorps	 xmm0, xmm0
  00bbf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bc4	51		 push	 ecx
  00bc5	0f 57 c0	 xorps	 xmm0, xmm0
  00bc8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bcd	8d 8d 60 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00bd3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00bd8	50		 push	 eax
  00bd9	8d 45 b0	 lea	 eax, DWORD PTR _label_size$[ebp]
  00bdc	50		 push	 eax
  00bdd	8b 4d 14	 mov	 ecx, DWORD PTR _label_end$[ebp]
  00be0	51		 push	 ecx
  00be1	8b 55 10	 mov	 edx, DWORD PTR _label$[ebp]
  00be4	52		 push	 edx
  00be5	8d 45 94	 lea	 eax, DWORD PTR _frame_bb$[ebp+8]
  00be8	50		 push	 eax
  00be9	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _text_pos$[ebp]
  00bef	51		 push	 ecx
  00bf0	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00bf5	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN41@TreeNodeBe:

; 5367 :         }
; 5368 :     }

  00bf8	e9 34 02 00 00	 jmp	 $LN34@TreeNodeBe
$LN33@TreeNodeBe:

; 5369 :     else
; 5370 :     {
; 5371 :         // Unframed typed for tree nodes
; 5372 :         if (hovered || selected)

  00bfd	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  00c04	85 c0		 test	 eax, eax
  00c06	75 0f		 jne	 SHORT $LN43@TreeNodeBe
  00c08	0f b6 85 e3 fe
	ff ff		 movzx	 eax, BYTE PTR _selected$[ebp]
  00c0f	85 c0		 test	 eax, eax
  00c11	0f 84 b3 00 00
	00		 je	 $LN42@TreeNodeBe
$LN43@TreeNodeBe:

; 5373 :         {
; 5374 :             const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

  00c17	0f b6 85 bf fe
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  00c1e	85 c0		 test	 eax, eax
  00c20	74 17		 je	 SHORT $LN76@TreeNodeBe
  00c22	0f b6 8d cb fe
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  00c29	85 c9		 test	 ecx, ecx
  00c2b	74 0c		 je	 SHORT $LN76@TreeNodeBe
  00c2d	c7 85 38 fc ff
	ff 1a 00 00 00	 mov	 DWORD PTR tv585[ebp], 26 ; 0000001aH
  00c37	eb 2d		 jmp	 SHORT $LN79@TreeNodeBe
$LN76@TreeNodeBe:
  00c39	0f b6 95 cb fe
	ff ff		 movzx	 edx, BYTE PTR _hovered$[ebp]
  00c40	85 d2		 test	 edx, edx
  00c42	74 0c		 je	 SHORT $LN77@TreeNodeBe
  00c44	c7 85 34 fc ff
	ff 19 00 00 00	 mov	 DWORD PTR tv584[ebp], 25 ; 00000019H
  00c4e	eb 0a		 jmp	 SHORT $LN78@TreeNodeBe
$LN77@TreeNodeBe:
  00c50	c7 85 34 fc ff
	ff 18 00 00 00	 mov	 DWORD PTR tv584[ebp], 24 ; 00000018H
$LN78@TreeNodeBe:
  00c5a	8b 85 34 fc ff
	ff		 mov	 eax, DWORD PTR tv584[ebp]
  00c60	89 85 38 fc ff
	ff		 mov	 DWORD PTR tv585[ebp], eax
$LN79@TreeNodeBe:
  00c66	51		 push	 ecx
  00c67	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c6f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c74	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv585[ebp]
  00c7a	51		 push	 ecx
  00c7b	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00c80	83 c4 08	 add	 esp, 8
  00c83	89 85 5c fe ff
	ff		 mov	 DWORD PTR _bg_col$11[ebp], eax

; 5375 :             RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false);

  00c89	51		 push	 ecx
  00c8a	0f 57 c0	 xorps	 xmm0, xmm0
  00c8d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c92	6a 00		 push	 0
  00c94	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _bg_col$11[ebp]
  00c9a	50		 push	 eax
  00c9b	8b 4d 98	 mov	 ecx, DWORD PTR _frame_bb$[ebp+12]
  00c9e	51		 push	 ecx
  00c9f	8b 55 94	 mov	 edx, DWORD PTR _frame_bb$[ebp+8]
  00ca2	52		 push	 edx
  00ca3	8b 45 90	 mov	 eax, DWORD PTR _frame_bb$[ebp+4]
  00ca6	50		 push	 eax
  00ca7	8b 4d 8c	 mov	 ecx, DWORD PTR _frame_bb$[ebp]
  00caa	51		 push	 ecx
  00cab	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  00cb0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5376 :             RenderNavHighlight(frame_bb, id, nav_highlight_flags);

  00cb3	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _nav_highlight_flags$[ebp]
  00cb9	50		 push	 eax
  00cba	8b 4d 08	 mov	 ecx, DWORD PTR _id$[ebp]
  00cbd	51		 push	 ecx
  00cbe	8d 55 8c	 lea	 edx, DWORD PTR _frame_bb$[ebp]
  00cc1	52		 push	 edx
  00cc2	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  00cc7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN42@TreeNodeBe:

; 5377 :         }
; 5378 :         if (flags & ImGuiTreeNodeFlags_Bullet)

  00cca	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00ccd	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00cd2	74 70		 je	 SHORT $LN44@TreeNodeBe

; 5379 :             RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.5f, text_pos.y + g.FontSize * 0.5f), text_col);

  00cd4	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _text_col$[ebp]
  00cda	50		 push	 eax
  00cdb	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00cde	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  00ce6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00cee	f3 0f 58 85 5c
	ff ff ff	 addss	 xmm0, DWORD PTR _text_pos$[ebp+4]
  00cf6	51		 push	 ecx
  00cf7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cfc	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  00d01	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00d09	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _text_pos$[ebp]
  00d11	f3 0f 5c c8	 subss	 xmm1, xmm0
  00d15	51		 push	 ecx
  00d16	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00d1b	8d 8d 50 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00d21	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00d26	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00d29	52		 push	 edx
  00d2a	8b 00		 mov	 eax, DWORD PTR [eax]
  00d2c	50		 push	 eax
  00d2d	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00d30	8b 91 74 02 00
	00		 mov	 edx, DWORD PTR [ecx+628]
  00d36	52		 push	 edx
  00d37	e8 00 00 00 00	 call	 ?RenderBullet@ImGui@@YAXPAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
  00d3c	83 c4 10	 add	 esp, 16			; 00000010H
  00d3f	e9 a9 00 00 00	 jmp	 $LN46@TreeNodeBe
$LN44@TreeNodeBe:

; 5380 :         else if (!is_leaf)

  00d44	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _is_leaf$[ebp]
  00d4b	85 c0		 test	 eax, eax
  00d4d	0f 85 9a 00 00
	00		 jne	 $LN46@TreeNodeBe

; 5381 :             RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15f), text_col, is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);

  00d53	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  00d5a	85 c0		 test	 eax, eax
  00d5c	74 0c		 je	 SHORT $LN80@TreeNodeBe
  00d5e	c7 85 38 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR tv615[ebp], 3
  00d68	eb 0a		 jmp	 SHORT $LN81@TreeNodeBe
$LN80@TreeNodeBe:
  00d6a	c7 85 38 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv615[ebp], 1
$LN81@TreeNodeBe:
  00d74	51		 push	 ecx
  00d75	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00d7d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d82	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR tv615[ebp]
  00d88	51		 push	 ecx
  00d89	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _text_col$[ebp]
  00d8f	52		 push	 edx
  00d90	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00d93	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00d9b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e19999a
  00da3	f3 0f 58 85 5c
	ff ff ff	 addss	 xmm0, DWORD PTR _text_pos$[ebp+4]
  00dab	51		 push	 ecx
  00dac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00db1	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _text_pos$[ebp]
  00db9	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR _text_offset_x$[ebp]
  00dbe	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _padding$[ebp]
  00dc3	51		 push	 ecx
  00dc4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dc9	8d 8d 40 fc ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00dcf	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00dd4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00dd7	51		 push	 ecx
  00dd8	8b 10		 mov	 edx, DWORD PTR [eax]
  00dda	52		 push	 edx
  00ddb	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00dde	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00de4	51		 push	 ecx
  00de5	e8 00 00 00 00	 call	 ?RenderArrow@ImGui@@YAXPAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
  00dea	83 c4 18	 add	 esp, 24			; 00000018H
$LN46@TreeNodeBe:

; 5382 :         if (g.LogEnabled)

  00ded	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00df0	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  00df7	85 c9		 test	 ecx, ecx
  00df9	74 16		 je	 SHORT $LN47@TreeNodeBe

; 5383 :             LogRenderedText(&text_pos, ">");

  00dfb	6a 00		 push	 0
  00dfd	68 00 00 00 00	 push	 OFFSET ??_C@_01PPODPGHN@?$DO@
  00e02	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _text_pos$[ebp]
  00e08	50		 push	 eax
  00e09	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z ; ImGui::LogRenderedText
  00e0e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN47@TreeNodeBe:

; 5384 :         RenderText(text_pos, label, label_end, false);

  00e11	6a 00		 push	 0
  00e13	8b 45 14	 mov	 eax, DWORD PTR _label_end$[ebp]
  00e16	50		 push	 eax
  00e17	8b 4d 10	 mov	 ecx, DWORD PTR _label$[ebp]
  00e1a	51		 push	 ecx
  00e1b	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _text_pos$[ebp+4]
  00e21	52		 push	 edx
  00e22	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _text_pos$[ebp]
  00e28	50		 push	 eax
  00e29	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  00e2e	83 c4 14	 add	 esp, 20			; 00000014H
$LN34@TreeNodeBe:

; 5385 :     }
; 5386 : 
; 5387 :     if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

  00e31	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _is_open$[ebp]
  00e38	85 c0		 test	 eax, eax
  00e3a	74 14		 je	 SHORT $LN48@TreeNodeBe
  00e3c	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00e3f	83 e0 08	 and	 eax, 8
  00e42	75 0c		 jne	 SHORT $LN48@TreeNodeBe

; 5388 :         TreePushOverrideID(id);

  00e44	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  00e47	50		 push	 eax
  00e48	e8 00 00 00 00	 call	 ?TreePushOverrideID@ImGui@@YAXI@Z ; ImGui::TreePushOverrideID
  00e4d	83 c4 04	 add	 esp, 4
$LN48@TreeNodeBe:

; 5389 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));

  00e50	33 c0		 xor	 eax, eax
  00e52	75 fc		 jne	 SHORT $LN48@TreeNodeBe

; 5390 :     return is_open;

  00e54	8a 85 2b ff ff
	ff		 mov	 al, BYTE PTR _is_open$[ebp]
$LN1@TreeNodeBe:

; 5391 : }

  00e5a	52		 push	 edx
  00e5b	8b cd		 mov	 ecx, ebp
  00e5d	50		 push	 eax
  00e5e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN92@TreeNodeBe
  00e64	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00e69	58		 pop	 eax
  00e6a	5a		 pop	 edx
  00e6b	5f		 pop	 edi
  00e6c	5e		 pop	 esi
  00e6d	5b		 pop	 ebx
  00e6e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e71	33 cd		 xor	 ecx, ebp
  00e73	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e78	81 c4 cc 03 00
	00		 add	 esp, 972		; 000003ccH
  00e7e	3b ec		 cmp	 ebp, esp
  00e80	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e85	8b e5		 mov	 esp, ebp
  00e87	5d		 pop	 ebp
  00e88	c3		 ret	 0
  00e89	0f 1f 00	 npad	 3
$LN92@TreeNodeBe:
  00e8c	09 00 00 00	 DD	 9
  00e90	00 00 00 00	 DD	 $LN91@TreeNodeBe
$LN91@TreeNodeBe:
  00e94	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00e98	08 00 00 00	 DD	 8
  00e9c	00 00 00 00	 DD	 $LN82@TreeNodeBe
  00ea0	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00ea4	08 00 00 00	 DD	 8
  00ea8	00 00 00 00	 DD	 $LN83@TreeNodeBe
  00eac	8c ff ff ff	 DD	 -116			; ffffff8cH
  00eb0	10 00 00 00	 DD	 16			; 00000010H
  00eb4	00 00 00 00	 DD	 $LN84@TreeNodeBe
  00eb8	58 ff ff ff	 DD	 -168			; ffffff58H
  00ebc	08 00 00 00	 DD	 8
  00ec0	00 00 00 00	 DD	 $LN85@TreeNodeBe
  00ec4	40 ff ff ff	 DD	 -192			; ffffff40H
  00ec8	10 00 00 00	 DD	 16			; 00000010H
  00ecc	00 00 00 00	 DD	 $LN86@TreeNodeBe
  00ed0	cb fe ff ff	 DD	 -309			; fffffecbH
  00ed4	01 00 00 00	 DD	 1
  00ed8	00 00 00 00	 DD	 $LN87@TreeNodeBe
  00edc	bf fe ff ff	 DD	 -321			; fffffebfH
  00ee0	01 00 00 00	 DD	 1
  00ee4	00 00 00 00	 DD	 $LN88@TreeNodeBe
  00ee8	74 fe ff ff	 DD	 -396			; fffffe74H
  00eec	04 00 00 00	 DD	 4
  00ef0	00 00 00 00	 DD	 $LN89@TreeNodeBe
  00ef4	68 fe ff ff	 DD	 -408			; fffffe68H
  00ef8	03 00 00 00	 DD	 3
  00efc	00 00 00 00	 DD	 $LN90@TreeNodeBe
$LN90@TreeNodeBe:
  00f00	6c		 DB	 108			; 0000006cH
  00f01	6f		 DB	 111			; 0000006fH
  00f02	67		 DB	 103			; 00000067H
  00f03	5f		 DB	 95			; 0000005fH
  00f04	73		 DB	 115			; 00000073H
  00f05	75		 DB	 117			; 00000075H
  00f06	66		 DB	 102			; 00000066H
  00f07	66		 DB	 102			; 00000066H
  00f08	69		 DB	 105			; 00000069H
  00f09	78		 DB	 120			; 00000078H
  00f0a	00		 DB	 0
$LN89@TreeNodeBe:
  00f0b	6c		 DB	 108			; 0000006cH
  00f0c	6f		 DB	 111			; 0000006fH
  00f0d	67		 DB	 103			; 00000067H
  00f0e	5f		 DB	 95			; 0000005fH
  00f0f	70		 DB	 112			; 00000070H
  00f10	72		 DB	 114			; 00000072H
  00f11	65		 DB	 101			; 00000065H
  00f12	66		 DB	 102			; 00000066H
  00f13	69		 DB	 105			; 00000069H
  00f14	78		 DB	 120			; 00000078H
  00f15	00		 DB	 0
$LN88@TreeNodeBe:
  00f16	68		 DB	 104			; 00000068H
  00f17	65		 DB	 101			; 00000065H
  00f18	6c		 DB	 108			; 0000006cH
  00f19	64		 DB	 100			; 00000064H
  00f1a	00		 DB	 0
$LN87@TreeNodeBe:
  00f1b	68		 DB	 104			; 00000068H
  00f1c	6f		 DB	 111			; 0000006fH
  00f1d	76		 DB	 118			; 00000076H
  00f1e	65		 DB	 101			; 00000065H
  00f1f	72		 DB	 114			; 00000072H
  00f20	65		 DB	 101			; 00000065H
  00f21	64		 DB	 100			; 00000064H
  00f22	00		 DB	 0
$LN86@TreeNodeBe:
  00f23	69		 DB	 105			; 00000069H
  00f24	6e		 DB	 110			; 0000006eH
  00f25	74		 DB	 116			; 00000074H
  00f26	65		 DB	 101			; 00000065H
  00f27	72		 DB	 114			; 00000072H
  00f28	61		 DB	 97			; 00000061H
  00f29	63		 DB	 99			; 00000063H
  00f2a	74		 DB	 116			; 00000074H
  00f2b	5f		 DB	 95			; 0000005fH
  00f2c	62		 DB	 98			; 00000062H
  00f2d	62		 DB	 98			; 00000062H
  00f2e	00		 DB	 0
$LN85@TreeNodeBe:
  00f2f	74		 DB	 116			; 00000074H
  00f30	65		 DB	 101			; 00000065H
  00f31	78		 DB	 120			; 00000078H
  00f32	74		 DB	 116			; 00000074H
  00f33	5f		 DB	 95			; 0000005fH
  00f34	70		 DB	 112			; 00000070H
  00f35	6f		 DB	 111			; 0000006fH
  00f36	73		 DB	 115			; 00000073H
  00f37	00		 DB	 0
$LN84@TreeNodeBe:
  00f38	66		 DB	 102			; 00000066H
  00f39	72		 DB	 114			; 00000072H
  00f3a	61		 DB	 97			; 00000061H
  00f3b	6d		 DB	 109			; 0000006dH
  00f3c	65		 DB	 101			; 00000065H
  00f3d	5f		 DB	 95			; 0000005fH
  00f3e	62		 DB	 98			; 00000062H
  00f3f	62		 DB	 98			; 00000062H
  00f40	00		 DB	 0
$LN83@TreeNodeBe:
  00f41	6c		 DB	 108			; 0000006cH
  00f42	61		 DB	 97			; 00000061H
  00f43	62		 DB	 98			; 00000062H
  00f44	65		 DB	 101			; 00000065H
  00f45	6c		 DB	 108			; 0000006cH
  00f46	5f		 DB	 95			; 0000005fH
  00f47	73		 DB	 115			; 00000073H
  00f48	69		 DB	 105			; 00000069H
  00f49	7a		 DB	 122			; 0000007aH
  00f4a	65		 DB	 101			; 00000065H
  00f4b	00		 DB	 0
$LN82@TreeNodeBe:
  00f4c	70		 DB	 112			; 00000070H
  00f4d	61		 DB	 97			; 00000061H
  00f4e	64		 DB	 100			; 00000064H
  00f4f	64		 DB	 100			; 00000064H
  00f50	69		 DB	 105			; 00000069H
  00f51	6e		 DB	 110			; 0000006eH
  00f52	67		 DB	 103			; 00000067H
  00f53	00		 DB	 0
?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ENDP		; ImGui::TreeNodeBehavior
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z
_TEXT	SEGMENT
tv208 = -492						; size = 4
tv211 = -488						; size = 4
tv199 = -488						; size = 4
tv157 = -488						; size = 4
tv141 = -488						; size = 4
tv91 = -488						; size = 4
$T1 = -480						; size = 8
$T2 = -464						; size = 8
$T3 = -448						; size = 4
$T4 = -436						; size = 8
$T5 = -420						; size = 8
$T6 = -404						; size = 8
$T7 = -388						; size = 4
_col$ = -184						; size = 4
_size_2_maximum_delta$8 = -172				; size = 4
_size_1_maximum_delta$9 = -160				; size = 4
_mouse_delta$10 = -148					; size = 4
_mouse_delta_2d$11 = -136				; size = 8
_bb_render$ = -120					; size = 16
_bb_interact$ = -96					; size = 16
_held$ = -69						; size = 1
_hovered$ = -57						; size = 1
_item_add$ = -45					; size = 1
_item_flags_backup$ = -36				; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_axis$ = 16						; size = 4
_size1$ = 20						; size = 4
_size2$ = 24						; size = 4
_min_size1$ = 28					; size = 4
_min_size2$ = 32					; size = 4
_hover_extend$ = 36					; size = 4
_hover_visibility_delay$ = 40				; size = 4
?SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z PROC ; ImGui::SplitterBehavior, COMDAT

; 1300 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 01 00
	00		 sub	 esp, 492		; 000001ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-492]
  00012	b9 7b 00 00 00	 mov	 ecx, 123		; 0000007bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1301 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 1302 :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 1303 : 
; 1304 :     const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;

  00046	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00049	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  0004f	89 4d dc	 mov	 DWORD PTR _item_flags_backup$[ebp], ecx

; 1305 :     window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00055	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  0005b	83 c9 18	 or	 ecx, 24			; 00000018H
  0005e	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  00061	89 8a 6c 01 00
	00		 mov	 DWORD PTR [edx+364], ecx

; 1306 :     bool item_add = ItemAdd(bb, id);

  00067	6a 00		 push	 0
  00069	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	88 45 d3	 mov	 BYTE PTR _item_add$[ebp], al

; 1307 :     window->DC.ItemFlags = item_flags_backup;

  0007c	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0007f	8b 4d dc	 mov	 ecx, DWORD PTR _item_flags_backup$[ebp]
  00082	89 88 6c 01 00
	00		 mov	 DWORD PTR [eax+364], ecx

; 1308 :     if (!item_add)

  00088	0f b6 45 d3	 movzx	 eax, BYTE PTR _item_add$[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	75 07		 jne	 SHORT $LN2@SplitterBe

; 1309 :         return false;

  00090	32 c0		 xor	 al, al
  00092	e9 3f 04 00 00	 jmp	 $LN1@SplitterBe
$LN2@SplitterBe:

; 1310 : 
; 1311 :     bool hovered, held;
; 1312 :     ImRect bb_interact = bb;

  00097	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	89 4d a0	 mov	 DWORD PTR _bb_interact$[ebp], ecx
  0009f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a2	89 55 a4	 mov	 DWORD PTR _bb_interact$[ebp+4], edx
  000a5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a8	89 4d a8	 mov	 DWORD PTR _bb_interact$[ebp+8], ecx
  000ab	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000ae	89 55 ac	 mov	 DWORD PTR _bb_interact$[ebp+12], edx

; 1313 :     bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));

  000b1	83 7d 10 01	 cmp	 DWORD PTR _axis$[ebp], 1
  000b5	75 27		 jne	 SHORT $LN13@SplitterBe
  000b7	51		 push	 ecx
  000b8	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _hover_extend$[ebp]
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	51		 push	 ecx
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cb	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000d1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000d6	89 85 18 fe ff
	ff		 mov	 DWORD PTR tv91[ebp], eax
  000dc	eb 25		 jmp	 SHORT $LN14@SplitterBe
$LN13@SplitterBe:
  000de	51		 push	 ecx
  000df	0f 57 c0	 xorps	 xmm0, xmm0
  000e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e7	51		 push	 ecx
  000e8	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _hover_extend$[ebp]
  000ed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f2	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000f8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000fd	89 85 18 fe ff
	ff		 mov	 DWORD PTR tv91[ebp], eax
$LN14@SplitterBe:
  00103	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR tv91[ebp]
  00109	89 85 7c fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  0010f	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  00115	51		 push	 ecx
  00116	8d 4d a0	 lea	 ecx, DWORD PTR _bb_interact$[ebp]
  00119	e8 00 00 00 00	 call	 ?Expand@ImRect@@QAEXABUImVec2@@@Z ; ImRect::Expand

; 1314 :     ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);

  0011e	6a 60		 push	 96			; 00000060H
  00120	8d 45 bb	 lea	 eax, DWORD PTR _held$[ebp]
  00123	50		 push	 eax
  00124	8d 4d c7	 lea	 ecx, DWORD PTR _hovered$[ebp]
  00127	51		 push	 ecx
  00128	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  0012b	52		 push	 edx
  0012c	8d 45 a0	 lea	 eax, DWORD PTR _bb_interact$[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  00135	83 c4 14	 add	 esp, 20			; 00000014H

; 1315 :     if (g.ActiveId != id)

  00138	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0013b	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00141	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00144	74 05		 je	 SHORT $LN3@SplitterBe

; 1316 :         SetItemAllowOverlap();

  00146	e8 00 00 00 00	 call	 ?SetItemAllowOverlap@ImGui@@YAXXZ ; ImGui::SetItemAllowOverlap
$LN3@SplitterBe:

; 1317 : 
; 1318 :     if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))

  0014b	0f b6 45 bb	 movzx	 eax, BYTE PTR _held$[ebp]
  0014f	85 c0		 test	 eax, eax
  00151	75 2d		 jne	 SHORT $LN5@SplitterBe
  00153	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00156	8b 88 d0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6608]
  0015c	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0015f	75 4a		 jne	 SHORT $LN4@SplitterBe
  00161	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00164	8b 88 d8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6616]
  0016a	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0016d	75 3c		 jne	 SHORT $LN4@SplitterBe
  0016f	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00172	f3 0f 10 80 dc
	19 00 00	 movss	 xmm0, DWORD PTR [eax+6620]
  0017a	0f 2f 45 28	 comiss	 xmm0, DWORD PTR _hover_visibility_delay$[ebp]
  0017e	72 2b		 jb	 SHORT $LN4@SplitterBe
$LN5@SplitterBe:

; 1319 :         SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

  00180	83 7d 10 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00184	75 0c		 jne	 SHORT $LN15@SplitterBe
  00186	c7 85 18 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv141[ebp], 3
  00190	eb 0a		 jmp	 SHORT $LN16@SplitterBe
$LN15@SplitterBe:
  00192	c7 85 18 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR tv141[ebp], 4
$LN16@SplitterBe:
  0019c	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 ?SetMouseCursor@ImGui@@YAXH@Z ; ImGui::SetMouseCursor
  001a8	83 c4 04	 add	 esp, 4
$LN4@SplitterBe:

; 1320 : 
; 1321 :     ImRect bb_render = bb;

  001ab	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  001ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b0	89 4d 88	 mov	 DWORD PTR _bb_render$[ebp], ecx
  001b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001b6	89 55 8c	 mov	 DWORD PTR _bb_render$[ebp+4], edx
  001b9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001bc	89 4d 90	 mov	 DWORD PTR _bb_render$[ebp+8], ecx
  001bf	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  001c2	89 55 94	 mov	 DWORD PTR _bb_render$[ebp+12], edx

; 1322 :     if (held)

  001c5	0f b6 45 bb	 movzx	 eax, BYTE PTR _held$[ebp]
  001c9	85 c0		 test	 eax, eax
  001cb	0f 84 68 02 00
	00		 je	 $LN9@SplitterBe

; 1323 :     {
; 1324 :         ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;

  001d1	8d 45 a0	 lea	 eax, DWORD PTR _bb_interact$[ebp]
  001d4	50		 push	 eax
  001d5	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  001d8	81 c1 08 1a 00
	00		 add	 ecx, 6664		; 00001a08H
  001de	51		 push	 ecx
  001df	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  001e2	81 c2 e8 00 00
	00		 add	 edx, 232		; 000000e8H
  001e8	52		 push	 edx
  001e9	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f8	50		 push	 eax
  001f9	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _mouse_delta_2d$11[ebp]
  001ff	51		 push	 ecx
  00200	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00205	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1325 :         float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

  00208	83 7d 10 01	 cmp	 DWORD PTR _axis$[ebp], 1
  0020c	75 12		 jne	 SHORT $LN17@SplitterBe
  0020e	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_delta_2d$11[ebp+4]
  00216	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR tv157[ebp], xmm0
  0021e	eb 10		 jmp	 SHORT $LN18@SplitterBe
$LN17@SplitterBe:
  00220	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_delta_2d$11[ebp]
  00228	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR tv157[ebp], xmm0
$LN18@SplitterBe:
  00230	f3 0f 10 85 18
	fe ff ff	 movss	 xmm0, DWORD PTR tv157[ebp]
  00238	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _mouse_delta$10[ebp], xmm0

; 1326 : 
; 1327 :         // Minimum pane size
; 1328 :         float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);

  00240	8b 45 14	 mov	 eax, DWORD PTR _size1$[ebp]
  00243	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00247	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _min_size1$[ebp]
  0024c	51		 push	 ecx
  0024d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00252	51		 push	 ecx
  00253	0f 57 c0	 xorps	 xmm0, xmm0
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00260	83 c4 08	 add	 esp, 8
  00263	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR _size_1_maximum_delta$9[ebp]

; 1329 :         float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);

  00269	8b 45 18	 mov	 eax, DWORD PTR _size2$[ebp]
  0026c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00270	f3 0f 5c 45 20	 subss	 xmm0, DWORD PTR _min_size2$[ebp]
  00275	51		 push	 ecx
  00276	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027b	51		 push	 ecx
  0027c	0f 57 c0	 xorps	 xmm0, xmm0
  0027f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00284	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00289	83 c4 08	 add	 esp, 8
  0028c	d9 9d 54 ff ff
	ff		 fstp	 DWORD PTR _size_2_maximum_delta$8[ebp]

; 1330 :         if (mouse_delta < -size_1_maximum_delta)

  00292	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _size_1_maximum_delta$9[ebp]
  0029a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002a1	0f 2f 85 6c ff
	ff ff		 comiss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  002a8	76 17		 jbe	 SHORT $LN7@SplitterBe

; 1331 :             mouse_delta = -size_1_maximum_delta;

  002aa	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _size_1_maximum_delta$9[ebp]
  002b2	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002b9	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _mouse_delta$10[ebp], xmm0
$LN7@SplitterBe:

; 1332 :         if (mouse_delta > size_2_maximum_delta)

  002c1	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  002c9	0f 2f 85 54 ff
	ff ff		 comiss	 xmm0, DWORD PTR _size_2_maximum_delta$8[ebp]
  002d0	76 10		 jbe	 SHORT $LN8@SplitterBe

; 1333 :             mouse_delta = size_2_maximum_delta;

  002d2	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _size_2_maximum_delta$8[ebp]
  002da	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _mouse_delta$10[ebp], xmm0
$LN8@SplitterBe:

; 1334 : 
; 1335 :         // Apply resize
; 1336 :         if (mouse_delta != 0.0f)

  002e2	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  002ea	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  002f1	9f		 lahf
  002f2	f6 c4 44	 test	 ah, 68			; 00000044H
  002f5	0f 8b 3e 01 00
	00		 jnp	 $LN9@SplitterBe

; 1337 :         {
; 1338 :             if (mouse_delta < 0.0f)

  002fb	0f 57 c0	 xorps	 xmm0, xmm0
  002fe	0f 2f 85 6c ff
	ff ff		 comiss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  00305	76 3b		 jbe	 SHORT $LN19@SplitterBe

; 1339 :                 IM_ASSERT(*size1 + mouse_delta >= min_size1);

  00307	8b 45 14	 mov	 eax, DWORD PTR _size1$[ebp]
  0030a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0030e	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  00316	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _min_size1$[ebp]
  0031a	73 26		 jae	 SHORT $LN19@SplitterBe
  0031c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z@4JA
  00322	83 c1 27	 add	 ecx, 39			; 00000027H
  00325	8b f4		 mov	 esi, esp
  00327	51		 push	 ecx
  00328	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0032d	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HJGLFFIG@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA1?$AA?5?$AA?$CL?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@
  00332	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00338	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033b	3b f4		 cmp	 esi, esp
  0033d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN19@SplitterBe:

; 1340 :             if (mouse_delta > 0.0f)

  00342	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  0034a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00351	76 3b		 jbe	 SHORT $LN20@SplitterBe

; 1341 :                 IM_ASSERT(*size2 - mouse_delta >= min_size2);

  00353	8b 45 18	 mov	 eax, DWORD PTR _size2$[ebp]
  00356	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0035a	f3 0f 5c 85 6c
	ff ff ff	 subss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  00362	0f 2f 45 20	 comiss	 xmm0, DWORD PTR _min_size2$[ebp]
  00366	73 26		 jae	 SHORT $LN20@SplitterBe
  00368	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z@4JA
  0036e	83 c1 29	 add	 ecx, 41			; 00000029H
  00371	8b f4		 mov	 esi, esp
  00373	51		 push	 ecx
  00374	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00379	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@LBEKBPGJ@?$AA?$CK?$AAs?$AAi?$AAz?$AAe?$AA2?$AA?5?$AA?9?$AA?5?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_@
  0037e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00384	83 c4 0c	 add	 esp, 12			; 0000000cH
  00387	3b f4		 cmp	 esi, esp
  00389	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@SplitterBe:

; 1342 :             *size1 += mouse_delta;

  0038e	8b 45 14	 mov	 eax, DWORD PTR _size1$[ebp]
  00391	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00395	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  0039d	8b 4d 14	 mov	 ecx, DWORD PTR _size1$[ebp]
  003a0	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 1343 :             *size2 -= mouse_delta;

  003a4	8b 45 18	 mov	 eax, DWORD PTR _size2$[ebp]
  003a7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003ab	f3 0f 5c 85 6c
	ff ff ff	 subss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  003b3	8b 4d 18	 mov	 ecx, DWORD PTR _size2$[ebp]
  003b6	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 1344 :             bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));

  003ba	83 7d 10 00	 cmp	 DWORD PTR _axis$[ebp], 0
  003be	75 2a		 jne	 SHORT $LN21@SplitterBe
  003c0	51		 push	 ecx
  003c1	0f 57 c0	 xorps	 xmm0, xmm0
  003c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c9	51		 push	 ecx
  003ca	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  003d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d7	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  003dd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003e2	89 85 18 fe ff
	ff		 mov	 DWORD PTR tv199[ebp], eax
  003e8	eb 28		 jmp	 SHORT $LN22@SplitterBe
$LN21@SplitterBe:
  003ea	51		 push	 ecx
  003eb	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_delta$10[ebp]
  003f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003f8	51		 push	 ecx
  003f9	0f 57 c0	 xorps	 xmm0, xmm0
  003fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00401	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00407	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0040c	89 85 18 fe ff
	ff		 mov	 DWORD PTR tv199[ebp], eax
$LN22@SplitterBe:
  00412	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR tv199[ebp]
  00418	89 85 40 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0041e	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00424	51		 push	 ecx
  00425	8d 4d 88	 lea	 ecx, DWORD PTR _bb_render$[ebp]
  00428	e8 00 00 00 00	 call	 ?Translate@ImRect@@QAEXABUImVec2@@@Z ; ImRect::Translate

; 1345 :             MarkItemEdited(id);

  0042d	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  00436	83 c4 04	 add	 esp, 4
$LN9@SplitterBe:

; 1346 :         }
; 1347 :     }
; 1348 : 
; 1349 :     // Render
; 1350 :     const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);

  00439	0f b6 45 bb	 movzx	 eax, BYTE PTR _held$[ebp]
  0043d	85 c0		 test	 eax, eax
  0043f	74 0c		 je	 SHORT $LN25@SplitterBe
  00441	c7 85 18 fe ff
	ff 1d 00 00 00	 mov	 DWORD PTR tv211[ebp], 29 ; 0000001dH
  0044b	eb 3b		 jmp	 SHORT $LN26@SplitterBe
$LN25@SplitterBe:
  0044d	0f b6 4d c7	 movzx	 ecx, BYTE PTR _hovered$[ebp]
  00451	85 c9		 test	 ecx, ecx
  00453	74 1d		 je	 SHORT $LN23@SplitterBe
  00455	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00458	f3 0f 10 82 dc
	19 00 00	 movss	 xmm0, DWORD PTR [edx+6620]
  00460	0f 2f 45 28	 comiss	 xmm0, DWORD PTR _hover_visibility_delay$[ebp]
  00464	72 0c		 jb	 SHORT $LN23@SplitterBe
  00466	c7 85 14 fe ff
	ff 1c 00 00 00	 mov	 DWORD PTR tv208[ebp], 28 ; 0000001cH
  00470	eb 0a		 jmp	 SHORT $LN24@SplitterBe
$LN23@SplitterBe:
  00472	c7 85 14 fe ff
	ff 1b 00 00 00	 mov	 DWORD PTR tv208[ebp], 27 ; 0000001bH
$LN24@SplitterBe:
  0047c	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR tv208[ebp]
  00482	89 85 18 fe ff
	ff		 mov	 DWORD PTR tv211[ebp], eax
$LN26@SplitterBe:
  00488	51		 push	 ecx
  00489	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00491	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00496	8b 8d 18 fe ff
	ff		 mov	 ecx, DWORD PTR tv211[ebp]
  0049c	51		 push	 ecx
  0049d	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  004a2	83 c4 08	 add	 esp, 8
  004a5	89 85 48 ff ff
	ff		 mov	 DWORD PTR _col$[ebp], eax

; 1351 :     window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);

  004ab	6a 0f		 push	 15			; 0000000fH
  004ad	51		 push	 ecx
  004ae	0f 57 c0	 xorps	 xmm0, xmm0
  004b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b6	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _col$[ebp]
  004bc	50		 push	 eax
  004bd	8d 4d 90	 lea	 ecx, DWORD PTR _bb_render$[ebp+8]
  004c0	51		 push	 ecx
  004c1	8d 55 88	 lea	 edx, DWORD PTR _bb_render$[ebp]
  004c4	52		 push	 edx
  004c5	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  004c8	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  004ce	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1352 : 
; 1353 :     return held;

  004d3	8a 45 bb	 mov	 al, BYTE PTR _held$[ebp]
$LN1@SplitterBe:

; 1354 : }

  004d6	52		 push	 edx
  004d7	8b cd		 mov	 ecx, ebp
  004d9	50		 push	 eax
  004da	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN33@SplitterBe
  004e0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004e5	58		 pop	 eax
  004e6	5a		 pop	 edx
  004e7	5f		 pop	 edi
  004e8	5e		 pop	 esi
  004e9	5b		 pop	 ebx
  004ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ed	33 cd		 xor	 ecx, ebp
  004ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f4	81 c4 ec 01 00
	00		 add	 esp, 492		; 000001ecH
  004fa	3b ec		 cmp	 ebp, esp
  004fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00501	8b e5		 mov	 esp, ebp
  00503	5d		 pop	 ebp
  00504	c3		 ret	 0
  00505	0f 1f 00	 npad	 3
$LN33@SplitterBe:
  00508	05 00 00 00	 DD	 5
  0050c	00 00 00 00	 DD	 $LN32@SplitterBe
$LN32@SplitterBe:
  00510	c7 ff ff ff	 DD	 -57			; ffffffc7H
  00514	01 00 00 00	 DD	 1
  00518	00 00 00 00	 DD	 $LN27@SplitterBe
  0051c	bb ff ff ff	 DD	 -69			; ffffffbbH
  00520	01 00 00 00	 DD	 1
  00524	00 00 00 00	 DD	 $LN28@SplitterBe
  00528	a0 ff ff ff	 DD	 -96			; ffffffa0H
  0052c	10 00 00 00	 DD	 16			; 00000010H
  00530	00 00 00 00	 DD	 $LN29@SplitterBe
  00534	88 ff ff ff	 DD	 -120			; ffffff88H
  00538	10 00 00 00	 DD	 16			; 00000010H
  0053c	00 00 00 00	 DD	 $LN30@SplitterBe
  00540	78 ff ff ff	 DD	 -136			; ffffff78H
  00544	08 00 00 00	 DD	 8
  00548	00 00 00 00	 DD	 $LN31@SplitterBe
$LN31@SplitterBe:
  0054c	6d		 DB	 109			; 0000006dH
  0054d	6f		 DB	 111			; 0000006fH
  0054e	75		 DB	 117			; 00000075H
  0054f	73		 DB	 115			; 00000073H
  00550	65		 DB	 101			; 00000065H
  00551	5f		 DB	 95			; 0000005fH
  00552	64		 DB	 100			; 00000064H
  00553	65		 DB	 101			; 00000065H
  00554	6c		 DB	 108			; 0000006cH
  00555	74		 DB	 116			; 00000074H
  00556	61		 DB	 97			; 00000061H
  00557	5f		 DB	 95			; 0000005fH
  00558	32		 DB	 50			; 00000032H
  00559	64		 DB	 100			; 00000064H
  0055a	00		 DB	 0
$LN30@SplitterBe:
  0055b	62		 DB	 98			; 00000062H
  0055c	62		 DB	 98			; 00000062H
  0055d	5f		 DB	 95			; 0000005fH
  0055e	72		 DB	 114			; 00000072H
  0055f	65		 DB	 101			; 00000065H
  00560	6e		 DB	 110			; 0000006eH
  00561	64		 DB	 100			; 00000064H
  00562	65		 DB	 101			; 00000065H
  00563	72		 DB	 114			; 00000072H
  00564	00		 DB	 0
$LN29@SplitterBe:
  00565	62		 DB	 98			; 00000062H
  00566	62		 DB	 98			; 00000062H
  00567	5f		 DB	 95			; 0000005fH
  00568	69		 DB	 105			; 00000069H
  00569	6e		 DB	 110			; 0000006eH
  0056a	74		 DB	 116			; 00000074H
  0056b	65		 DB	 101			; 00000065H
  0056c	72		 DB	 114			; 00000072H
  0056d	61		 DB	 97			; 00000061H
  0056e	63		 DB	 99			; 00000063H
  0056f	74		 DB	 116			; 00000074H
  00570	00		 DB	 0
$LN28@SplitterBe:
  00571	68		 DB	 104			; 00000068H
  00572	65		 DB	 101			; 00000065H
  00573	6c		 DB	 108			; 0000006cH
  00574	64		 DB	 100			; 00000064H
  00575	00		 DB	 0
$LN27@SplitterBe:
  00576	68		 DB	 104			; 00000068H
  00577	6f		 DB	 111			; 0000006fH
  00578	76		 DB	 118			; 00000076H
  00579	65		 DB	 101			; 00000065H
  0057a	72		 DB	 114			; 00000072H
  0057b	65		 DB	 101			; 00000065H
  0057c	64		 DB	 100			; 00000064H
  0057d	00		 DB	 0
?SplitterBehavior@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAM2MMMM@Z ENDP ; ImGui::SplitterBehavior
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU2@@Z
_TEXT	SEGMENT
tv385 = -300						; size = 4
tv418 = -296						; size = 4
tv379 = -296						; size = 4
tv64 = -296						; size = 4
_r$1 = -93						; size = 1
_v32$2 = -84						; size = 4
_r$3 = -69						; size = 1
_v32$4 = -60						; size = 4
_r$5 = -45						; size = 1
_v32$6 = -36						; size = 4
_r$7 = -21						; size = 1
_v32$8 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_data_type$ = 16					; size = 4
_p_v$ = 20						; size = 4
_p_min$ = 24						; size = 4
_p_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
_flags$ = 40						; size = 4
_out_grab_bb$ = 44					; size = 4
?SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU2@@Z PROC ; ImGui::SliderBehavior, COMDAT

; 2481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2482 :     switch (data_type)

  00032	8b 45 10	 mov	 eax, DWORD PTR _data_type$[ebp]
  00035	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  0003b	83 bd d8 fe ff
	ff 09		 cmp	 DWORD PTR tv64[ebp], 9
  00042	0f 87 ee 04 00
	00		 ja	 $LN2@SliderBeha
  00048	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  0004e	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN31@SliderBeha[ecx*4]
$LN4@SliderBeha:

; 2483 :     {
; 2484 :     case ImGuiDataType_S8:  { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS8*)p_min,  *(const ImS8*)p_max,  format, power, flags, out_grab_bb); if (r) *(ImS8*)p_v  = (ImS8)v32;  return r; }

  00055	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  00058	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005b	89 4d f4	 mov	 DWORD PTR _v32$8[ebp], ecx
  0005e	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00065	51		 push	 ecx
  00066	51		 push	 ecx
  00067	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0006c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00071	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00074	52		 push	 edx
  00075	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00078	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007b	51		 push	 ecx
  0007c	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  0007f	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00082	50		 push	 eax
  00083	8d 4d f4	 lea	 ecx, DWORD PTR _v32$8[ebp]
  00086	51		 push	 ecx
  00087	6a 04		 push	 4
  00089	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  0008c	52		 push	 edx
  0008d	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??$SliderBehaviorT@HHM@ImGui@@YA_NABUImRect@@IHPAHHHPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<int,int,float>
  00096	83 c4 28	 add	 esp, 40			; 00000028H
  00099	88 45 eb	 mov	 BYTE PTR _r$7[ebp], al
  0009c	0f b6 45 eb	 movzx	 eax, BYTE PTR _r$7[ebp]
  000a0	85 c0		 test	 eax, eax
  000a2	74 08		 je	 SHORT $LN5@SliderBeha
  000a4	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  000a7	8a 4d f4	 mov	 cl, BYTE PTR _v32$8[ebp]
  000aa	88 08		 mov	 BYTE PTR [eax], cl
$LN5@SliderBeha:
  000ac	8a 45 eb	 mov	 al, BYTE PTR _r$7[ebp]
  000af	e9 ae 04 00 00	 jmp	 $LN1@SliderBeha
$LN6@SliderBeha:

; 2485 :     case ImGuiDataType_U8:  { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU8*)p_min,  *(const ImU8*)p_max,  format, power, flags, out_grab_bb); if (r) *(ImU8*)p_v  = (ImU8)v32;  return r; }

  000b4	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  000b7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000ba	89 4d dc	 mov	 DWORD PTR _v32$6[ebp], ecx
  000bd	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  000c4	51		 push	 ecx
  000c5	51		 push	 ecx
  000c6	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  000cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d0	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  000d3	52		 push	 edx
  000d4	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  000d7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000da	51		 push	 ecx
  000db	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  000de	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e1	50		 push	 eax
  000e2	8d 4d dc	 lea	 ecx, DWORD PTR _v32$6[ebp]
  000e5	51		 push	 ecx
  000e6	6a 05		 push	 5
  000e8	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ??$SliderBehaviorT@IHM@ImGui@@YA_NABUImRect@@IHPAIIIPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<unsigned int,int,float>
  000f5	83 c4 28	 add	 esp, 40			; 00000028H
  000f8	88 45 d3	 mov	 BYTE PTR _r$5[ebp], al
  000fb	0f b6 45 d3	 movzx	 eax, BYTE PTR _r$5[ebp]
  000ff	85 c0		 test	 eax, eax
  00101	74 08		 je	 SHORT $LN7@SliderBeha
  00103	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  00106	8a 4d dc	 mov	 cl, BYTE PTR _v32$6[ebp]
  00109	88 08		 mov	 BYTE PTR [eax], cl
$LN7@SliderBeha:
  0010b	8a 45 d3	 mov	 al, BYTE PTR _r$5[ebp]
  0010e	e9 4f 04 00 00	 jmp	 $LN1@SliderBeha
$LN8@SliderBeha:

; 2486 :     case ImGuiDataType_S16: { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = SliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32, *(const ImS16*)p_min, *(const ImS16*)p_max, format, power, flags, out_grab_bb); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }

  00113	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  00116	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00119	89 4d c4	 mov	 DWORD PTR _v32$4[ebp], ecx
  0011c	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  0011f	50		 push	 eax
  00120	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00123	51		 push	 ecx
  00124	51		 push	 ecx
  00125	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0012a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012f	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00132	52		 push	 edx
  00133	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00136	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00139	51		 push	 ecx
  0013a	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  0013d	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00140	50		 push	 eax
  00141	8d 4d c4	 lea	 ecx, DWORD PTR _v32$4[ebp]
  00144	51		 push	 ecx
  00145	6a 04		 push	 4
  00147	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  0014a	52		 push	 edx
  0014b	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 ??$SliderBehaviorT@HHM@ImGui@@YA_NABUImRect@@IHPAHHHPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<int,int,float>
  00154	83 c4 28	 add	 esp, 40			; 00000028H
  00157	88 45 bb	 mov	 BYTE PTR _r$3[ebp], al
  0015a	0f b6 45 bb	 movzx	 eax, BYTE PTR _r$3[ebp]
  0015e	85 c0		 test	 eax, eax
  00160	74 0a		 je	 SHORT $LN9@SliderBeha
  00162	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  00165	66 8b 4d c4	 mov	 cx, WORD PTR _v32$4[ebp]
  00169	66 89 08	 mov	 WORD PTR [eax], cx
$LN9@SliderBeha:
  0016c	8a 45 bb	 mov	 al, BYTE PTR _r$3[ebp]
  0016f	e9 ee 03 00 00	 jmp	 $LN1@SliderBeha
$LN10@SliderBeha:

; 2487 :     case ImGuiDataType_U16: { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = SliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32, *(const ImU16*)p_min, *(const ImU16*)p_max, format, power, flags, out_grab_bb); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }

  00174	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  00177	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0017a	89 4d ac	 mov	 DWORD PTR _v32$2[ebp], ecx
  0017d	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  00180	50		 push	 eax
  00181	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00184	51		 push	 ecx
  00185	51		 push	 ecx
  00186	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0018b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00190	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00193	52		 push	 edx
  00194	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00197	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0019a	51		 push	 ecx
  0019b	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  0019e	0f b7 02	 movzx	 eax, WORD PTR [edx]
  001a1	50		 push	 eax
  001a2	8d 4d ac	 lea	 ecx, DWORD PTR _v32$2[ebp]
  001a5	51		 push	 ecx
  001a6	6a 05		 push	 5
  001a8	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  001ab	52		 push	 edx
  001ac	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ??$SliderBehaviorT@IHM@ImGui@@YA_NABUImRect@@IHPAIIIPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<unsigned int,int,float>
  001b5	83 c4 28	 add	 esp, 40			; 00000028H
  001b8	88 45 a3	 mov	 BYTE PTR _r$1[ebp], al
  001bb	0f b6 45 a3	 movzx	 eax, BYTE PTR _r$1[ebp]
  001bf	85 c0		 test	 eax, eax
  001c1	74 0a		 je	 SHORT $LN11@SliderBeha
  001c3	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  001c6	66 8b 4d ac	 mov	 cx, WORD PTR _v32$2[ebp]
  001ca	66 89 08	 mov	 WORD PTR [eax], cx
$LN11@SliderBeha:
  001cd	8a 45 a3	 mov	 al, BYTE PTR _r$1[ebp]
  001d0	e9 8d 03 00 00	 jmp	 $LN1@SliderBeha
$LN12@SliderBeha:

; 2488 :     case ImGuiDataType_S32:
; 2489 :         IM_ASSERT(*(const ImS32*)p_min >= IM_S32_MIN/2 && *(const ImS32*)p_max <= IM_S32_MAX/2);

  001d5	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  001d8	81 38 00 00 00
	c0		 cmp	 DWORD PTR [eax], -1073741824 ; c0000000H
  001de	7c 0b		 jl	 SHORT $LN20@SliderBeha
  001e0	8b 4d 1c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  001e3	81 39 ff ff ff
	3f		 cmp	 DWORD PTR [ecx], 1073741823 ; 3fffffffH
  001e9	7e 26		 jle	 SHORT $LN21@SliderBeha
$LN20@SliderBeha:
  001eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
  001f1	83 c2 08	 add	 edx, 8
  001f4	8b f4		 mov	 esi, esp
  001f6	52		 push	 edx
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_1JK@KBPJHMJO@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA3?$AA2?$AA?$CK?$AA?$CJ@
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020a	3b f4		 cmp	 esi, esp
  0020c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@SliderBeha:

; 2490 :         return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)p_v,  *(const ImS32*)p_min,  *(const ImS32*)p_max,  format, power, flags, out_grab_bb);

  00211	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  00214	50		 push	 eax
  00215	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00218	51		 push	 ecx
  00219	51		 push	 ecx
  0021a	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0021f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00224	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00227	52		 push	 edx
  00228	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  0022b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022d	51		 push	 ecx
  0022e	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  00231	8b 02		 mov	 eax, DWORD PTR [edx]
  00233	50		 push	 eax
  00234	8b 4d 14	 mov	 ecx, DWORD PTR _p_v$[ebp]
  00237	51		 push	 ecx
  00238	8b 55 10	 mov	 edx, DWORD PTR _data_type$[ebp]
  0023b	52		 push	 edx
  0023c	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  0023f	50		 push	 eax
  00240	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  00243	51		 push	 ecx
  00244	e8 00 00 00 00	 call	 ??$SliderBehaviorT@HHM@ImGui@@YA_NABUImRect@@IHPAHHHPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<int,int,float>
  00249	83 c4 28	 add	 esp, 40			; 00000028H
  0024c	e9 11 03 00 00	 jmp	 $LN1@SliderBeha
$LN13@SliderBeha:

; 2491 :     case ImGuiDataType_U32:
; 2492 :         IM_ASSERT(*(const ImU32*)p_max <= IM_U32_MAX/2);

  00251	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00254	81 38 ff ff ff
	7f		 cmp	 DWORD PTR [eax], 2147483647 ; 7fffffffH
  0025a	76 26		 jbe	 SHORT $LN22@SliderBeha
  0025c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
  00262	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00265	8b f4		 mov	 esi, esp
  00267	51		 push	 ecx
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0026d	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@CNKAEFCM@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA3?$AA2?$AA?$CK?$AA?$CJ@
  00272	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00278	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027b	3b f4		 cmp	 esi, esp
  0027d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN22@SliderBeha:

; 2493 :         return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)p_v,  *(const ImU32*)p_min,  *(const ImU32*)p_max,  format, power, flags, out_grab_bb);

  00282	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  00285	50		 push	 eax
  00286	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00289	51		 push	 ecx
  0028a	51		 push	 ecx
  0028b	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00290	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00295	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00298	52		 push	 edx
  00299	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  0029c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029e	51		 push	 ecx
  0029f	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  002a2	8b 02		 mov	 eax, DWORD PTR [edx]
  002a4	50		 push	 eax
  002a5	8b 4d 14	 mov	 ecx, DWORD PTR _p_v$[ebp]
  002a8	51		 push	 ecx
  002a9	8b 55 10	 mov	 edx, DWORD PTR _data_type$[ebp]
  002ac	52		 push	 edx
  002ad	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  002b0	50		 push	 eax
  002b1	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  002b4	51		 push	 ecx
  002b5	e8 00 00 00 00	 call	 ??$SliderBehaviorT@IHM@ImGui@@YA_NABUImRect@@IHPAIIIPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<unsigned int,int,float>
  002ba	83 c4 28	 add	 esp, 40			; 00000028H
  002bd	e9 a0 02 00 00	 jmp	 $LN1@SliderBeha
$LN14@SliderBeha:

; 2494 :     case ImGuiDataType_S64:
; 2495 :         IM_ASSERT(*(const ImS64*)p_min >= IM_S64_MIN/2 && *(const ImS64*)p_max <= IM_S64_MAX/2);

  002c2	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  002c5	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv379[ebp], eax
  002cb	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv379[ebp]
  002d1	81 79 04 00 00
	00 c0		 cmp	 DWORD PTR [ecx+4], -1073741824 ; c0000000H
  002d8	7c 32		 jl	 SHORT $LN33@SliderBeha
  002da	7f 0b		 jg	 SHORT $LN32@SliderBeha
  002dc	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv379[ebp]
  002e2	83 3a 00	 cmp	 DWORD PTR [edx], 0
  002e5	72 25		 jb	 SHORT $LN33@SliderBeha
$LN32@SliderBeha:
  002e7	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  002ea	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv385[ebp], eax
  002f0	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv385[ebp]
  002f6	81 79 04 ff ff
	ff 3f		 cmp	 DWORD PTR [ecx+4], 1073741823 ; 3fffffffH
  002fd	7c 32		 jl	 SHORT $LN24@SliderBeha
  002ff	7f 0b		 jg	 SHORT $LN33@SliderBeha
  00301	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR tv385[ebp]
  00307	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0030a	76 25		 jbe	 SHORT $LN24@SliderBeha
$LN33@SliderBeha:
  0030c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
  00311	83 c0 0e	 add	 eax, 14			; 0000000eH
  00314	8b f4		 mov	 esi, esp
  00316	50		 push	 eax
  00317	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0031c	68 00 00 00 00	 push	 OFFSET ??_C@_1JK@NOHGLDJN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAS?$AA6?$AA4?$AA?$CK?$AA?$CJ@
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00327	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032a	3b f4		 cmp	 esi, esp
  0032c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN24@SliderBeha:

; 2496 :         return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)p_v,  *(const ImS64*)p_min,  *(const ImS64*)p_max,  format, power, flags, out_grab_bb);

  00331	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  00334	50		 push	 eax
  00335	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00338	51		 push	 ecx
  00339	51		 push	 ecx
  0033a	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0033f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00344	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00347	52		 push	 edx
  00348	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  0034b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0034e	51		 push	 ecx
  0034f	8b 10		 mov	 edx, DWORD PTR [eax]
  00351	52		 push	 edx
  00352	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  00355	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00358	51		 push	 ecx
  00359	8b 10		 mov	 edx, DWORD PTR [eax]
  0035b	52		 push	 edx
  0035c	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  0035f	50		 push	 eax
  00360	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00363	51		 push	 ecx
  00364	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  00367	52		 push	 edx
  00368	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  0036b	50		 push	 eax
  0036c	e8 00 00 00 00	 call	 ??$SliderBehaviorT@_J_JN@ImGui@@YA_NABUImRect@@IHPA_J_J2PBDMHPAU1@@Z ; ImGui::SliderBehaviorT<__int64,__int64,double>
  00371	83 c4 30	 add	 esp, 48			; 00000030H
  00374	e9 e9 01 00 00	 jmp	 $LN1@SliderBeha
$LN15@SliderBeha:

; 2497 :     case ImGuiDataType_U64:
; 2498 :         IM_ASSERT(*(const ImU64*)p_max <= IM_U64_MAX/2);

  00379	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  0037c	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv418[ebp], eax
  00382	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv418[ebp]
  00388	81 79 04 ff ff
	ff 7f		 cmp	 DWORD PTR [ecx+4], 2147483647 ; 7fffffffH
  0038f	72 32		 jb	 SHORT $LN25@SliderBeha
  00391	77 0b		 ja	 SHORT $LN34@SliderBeha
  00393	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv418[ebp]
  00399	83 3a ff	 cmp	 DWORD PTR [edx], -1
  0039c	76 25		 jbe	 SHORT $LN25@SliderBeha
$LN34@SliderBeha:
  0039e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
  003a3	83 c0 11	 add	 eax, 17			; 00000011H
  003a6	8b f4		 mov	 esi, esp
  003a8	50		 push	 eax
  003a9	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  003ae	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@CBABBPPD@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAI?$AAm?$AAU?$AA6?$AA4?$AA?$CK?$AA?$CJ@
  003b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  003b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  003bc	3b f4		 cmp	 esi, esp
  003be	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN25@SliderBeha:

; 2499 :         return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)p_v,  *(const ImU64*)p_min,  *(const ImU64*)p_max,  format, power, flags, out_grab_bb);

  003c3	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  003c6	50		 push	 eax
  003c7	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  003ca	51		 push	 ecx
  003cb	51		 push	 ecx
  003cc	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  003d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d6	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  003d9	52		 push	 edx
  003da	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  003dd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003e0	51		 push	 ecx
  003e1	8b 10		 mov	 edx, DWORD PTR [eax]
  003e3	52		 push	 edx
  003e4	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  003e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003ea	51		 push	 ecx
  003eb	8b 10		 mov	 edx, DWORD PTR [eax]
  003ed	52		 push	 edx
  003ee	8b 45 14	 mov	 eax, DWORD PTR _p_v$[ebp]
  003f1	50		 push	 eax
  003f2	8b 4d 10	 mov	 ecx, DWORD PTR _data_type$[ebp]
  003f5	51		 push	 ecx
  003f6	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  003f9	52		 push	 edx
  003fa	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  003fd	50		 push	 eax
  003fe	e8 00 00 00 00	 call	 ??$SliderBehaviorT@_K_JN@ImGui@@YA_NABUImRect@@IHPA_K_K2PBDMHPAU1@@Z ; ImGui::SliderBehaviorT<unsigned __int64,__int64,double>
  00403	83 c4 30	 add	 esp, 48			; 00000030H
  00406	e9 57 01 00 00	 jmp	 $LN1@SliderBeha
$LN16@SliderBeha:

; 2500 :     case ImGuiDataType_Float:
; 2501 :         IM_ASSERT(*(const float*)p_min >= -FLT_MAX/2.0f && *(const float*)p_max <= FLT_MAX/2.0f);

  0040b	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  0040e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00412	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@feffffff
  00419	72 10		 jb	 SHORT $LN26@SliderBeha
  0041b	8b 4d 1c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  0041e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7effffff
  00426	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00429	73 26		 jae	 SHORT $LN27@SliderBeha
$LN26@SliderBeha:
  0042b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
  00431	83 c2 14	 add	 edx, 20			; 00000014H
  00434	8b f4		 mov	 esi, esp
  00436	52		 push	 edx
  00437	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0043c	68 00 00 00 00	 push	 OFFSET ??_C@_1MA@ELIKKGKL@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$CK?$AA?$CJ@
  00441	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00447	83 c4 0c	 add	 esp, 12			; 0000000cH
  0044a	3b f4		 cmp	 esi, esp
  0044c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN27@SliderBeha:

; 2502 :         return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)p_v,  *(const float*)p_min,  *(const float*)p_max,  format, power, flags, out_grab_bb);

  00451	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  00454	50		 push	 eax
  00455	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00458	51		 push	 ecx
  00459	51		 push	 ecx
  0045a	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0045f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00464	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00467	52		 push	 edx
  00468	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  0046b	51		 push	 ecx
  0046c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00470	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00475	8b 4d 18	 mov	 ecx, DWORD PTR _p_min$[ebp]
  00478	51		 push	 ecx
  00479	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0047d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00482	8b 55 14	 mov	 edx, DWORD PTR _p_v$[ebp]
  00485	52		 push	 edx
  00486	8b 45 10	 mov	 eax, DWORD PTR _data_type$[ebp]
  00489	50		 push	 eax
  0048a	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  0048d	51		 push	 ecx
  0048e	8b 55 08	 mov	 edx, DWORD PTR _bb$[ebp]
  00491	52		 push	 edx
  00492	e8 00 00 00 00	 call	 ??$SliderBehaviorT@MMM@ImGui@@YA_NABUImRect@@IHPAMMMPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<float,float,float>
  00497	83 c4 28	 add	 esp, 40			; 00000028H
  0049a	e9 c3 00 00 00	 jmp	 $LN1@SliderBeha
$LN17@SliderBeha:

; 2503 :     case ImGuiDataType_Double:
; 2504 :         IM_ASSERT(*(const double*)p_min >= -DBL_MAX/2.0f && *(const double*)p_max <= DBL_MAX/2.0f);

  0049f	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  004a2	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  004a6	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@ffdfffffffffffff
  004ae	72 11		 jb	 SHORT $LN28@SliderBeha
  004b0	8b 4d 1c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  004b3	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@7fdfffffffffffff
  004bb	66 0f 2f 01	 comisd	 xmm0, QWORD PTR [ecx]
  004bf	73 26		 jae	 SHORT $LN29@SliderBeha
$LN28@SliderBeha:
  004c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
  004c7	83 c2 17	 add	 edx, 23			; 00000017H
  004ca	8b f4		 mov	 esi, esp
  004cc	52		 push	 edx
  004cd	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  004d2	68 00 00 00 00	 push	 OFFSET ??_C@_1OA@OEHGOKMN@?$AA?$CK?$AA?$CI?$AAc?$AAo?$AAn?$AAs?$AAt?$AA?5?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$CK@
  004d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  004dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e0	3b f4		 cmp	 esi, esp
  004e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN29@SliderBeha:

; 2505 :         return SliderBehaviorT<double,double,double>(bb, id, data_type, (double*)p_v, *(const double*)p_min, *(const double*)p_max, format, power, flags, out_grab_bb);

  004e7	8b 45 2c	 mov	 eax, DWORD PTR _out_grab_bb$[ebp]
  004ea	50		 push	 eax
  004eb	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  004ee	51		 push	 ecx
  004ef	51		 push	 ecx
  004f0	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  004f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004fa	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  004fd	52		 push	 edx
  004fe	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00501	83 ec 08	 sub	 esp, 8
  00504	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00508	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0050d	8b 4d 18	 mov	 ecx, DWORD PTR _p_min$[ebp]
  00510	83 ec 08	 sub	 esp, 8
  00513	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00517	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0051c	8b 55 14	 mov	 edx, DWORD PTR _p_v$[ebp]
  0051f	52		 push	 edx
  00520	8b 45 10	 mov	 eax, DWORD PTR _data_type$[ebp]
  00523	50		 push	 eax
  00524	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  00527	51		 push	 ecx
  00528	8b 55 08	 mov	 edx, DWORD PTR _bb$[ebp]
  0052b	52		 push	 edx
  0052c	e8 00 00 00 00	 call	 ??$SliderBehaviorT@NNN@ImGui@@YA_NABUImRect@@IHPANNNPBDMHPAU1@@Z ; ImGui::SliderBehaviorT<double,double,double>
  00531	83 c4 30	 add	 esp, 48			; 00000030H
  00534	eb 2c		 jmp	 SHORT $LN1@SliderBeha
$LN2@SliderBeha:

; 2506 :     case ImGuiDataType_COUNT: break;
; 2507 :     }
; 2508 :     IM_ASSERT(0);

  00536	33 c0		 xor	 eax, eax
  00538	75 26		 jne	 SHORT $LN30@SliderBeha
  0053a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU3@@Z@4JA
  00540	83 c1 1b	 add	 ecx, 27			; 0000001bH
  00543	8b f4		 mov	 esi, esp
  00545	51		 push	 ecx
  00546	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0054b	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  00550	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00556	83 c4 0c	 add	 esp, 12			; 0000000cH
  00559	3b f4		 cmp	 esi, esp
  0055b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN30@SliderBeha:

; 2509 :     return false;

  00560	32 c0		 xor	 al, al
$LN1@SliderBeha:

; 2510 : }

  00562	52		 push	 edx
  00563	8b cd		 mov	 ecx, ebp
  00565	50		 push	 eax
  00566	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN40@SliderBeha
  0056c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00571	58		 pop	 eax
  00572	5a		 pop	 edx
  00573	5f		 pop	 edi
  00574	5e		 pop	 esi
  00575	5b		 pop	 ebx
  00576	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00579	33 cd		 xor	 ecx, ebp
  0057b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00580	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  00586	3b ec		 cmp	 ebp, esp
  00588	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0058d	8b e5		 mov	 esp, ebp
  0058f	5d		 pop	 ebp
  00590	c3		 ret	 0
  00591	0f 1f 00	 npad	 3
$LN40@SliderBeha:
  00594	04 00 00 00	 DD	 4
  00598	00 00 00 00	 DD	 $LN39@SliderBeha
$LN39@SliderBeha:
  0059c	f4 ff ff ff	 DD	 -12			; fffffff4H
  005a0	04 00 00 00	 DD	 4
  005a4	00 00 00 00	 DD	 $LN35@SliderBeha
  005a8	dc ff ff ff	 DD	 -36			; ffffffdcH
  005ac	04 00 00 00	 DD	 4
  005b0	00 00 00 00	 DD	 $LN36@SliderBeha
  005b4	c4 ff ff ff	 DD	 -60			; ffffffc4H
  005b8	04 00 00 00	 DD	 4
  005bc	00 00 00 00	 DD	 $LN37@SliderBeha
  005c0	ac ff ff ff	 DD	 -84			; ffffffacH
  005c4	04 00 00 00	 DD	 4
  005c8	00 00 00 00	 DD	 $LN38@SliderBeha
$LN38@SliderBeha:
  005cc	76		 DB	 118			; 00000076H
  005cd	33		 DB	 51			; 00000033H
  005ce	32		 DB	 50			; 00000032H
  005cf	00		 DB	 0
$LN37@SliderBeha:
  005d0	76		 DB	 118			; 00000076H
  005d1	33		 DB	 51			; 00000033H
  005d2	32		 DB	 50			; 00000032H
  005d3	00		 DB	 0
$LN36@SliderBeha:
  005d4	76		 DB	 118			; 00000076H
  005d5	33		 DB	 51			; 00000033H
  005d6	32		 DB	 50			; 00000032H
  005d7	00		 DB	 0
$LN35@SliderBeha:
  005d8	76		 DB	 118			; 00000076H
  005d9	33		 DB	 51			; 00000033H
  005da	32		 DB	 50			; 00000032H
  005db	00		 DB	 0
$LN31@SliderBeha:
  005dc	00 00 00 00	 DD	 $LN4@SliderBeha
  005e0	00 00 00 00	 DD	 $LN6@SliderBeha
  005e4	00 00 00 00	 DD	 $LN8@SliderBeha
  005e8	00 00 00 00	 DD	 $LN10@SliderBeha
  005ec	00 00 00 00	 DD	 $LN12@SliderBeha
  005f0	00 00 00 00	 DD	 $LN13@SliderBeha
  005f4	00 00 00 00	 DD	 $LN14@SliderBeha
  005f8	00 00 00 00	 DD	 $LN15@SliderBeha
  005fc	00 00 00 00	 DD	 $LN16@SliderBeha
  00600	00 00 00 00	 DD	 $LN17@SliderBeha
?SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU2@@Z ENDP ; ImGui::SliderBehavior
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z
_TEXT	SEGMENT
tv261 = -320						; size = 8
tv235 = -320						; size = 8
tv222 = -320						; size = 8
tv258 = -312						; size = 8
tv248 = -312						; size = 4
tv232 = -312						; size = 8
tv219 = -312						; size = 8
tv209 = -312						; size = 4
tv196 = -312						; size = 4
tv245 = -308						; size = 4
tv206 = -308						; size = 4
tv193 = -308						; size = 4
tv180 = -308						; size = 2
tv162 = -308						; size = 2
tv83 = -308						; size = 4
tv176 = -306						; size = 2
tv158 = -306						; size = 2
tv144 = -306						; size = 1
tv94 = -306						; size = 1
tv140 = -305						; size = 1
tv90 = -305						; size = 1
_r$1 = -105						; size = 1
_v32$2 = -96						; size = 4
_r$3 = -81						; size = 1
_v32$4 = -72						; size = 4
_r$5 = -57						; size = 1
_v32$6 = -48						; size = 4
_r$7 = -33						; size = 1
_v32$8 = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_id$ = 8						; size = 4
_data_type$ = 12					; size = 4
_p_v$ = 16						; size = 4
_v_speed$ = 20						; size = 4
_p_min$ = 24						; size = 4
_p_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
_flags$ = 40						; size = 4
?DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z PROC		; ImGui::DragBehavior, COMDAT

; 2028 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00012	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2029 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 2030 :     if (g.ActiveId == id)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00043	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  00046	75 57		 jne	 SHORT $LN7@DragBehavi

; 2031 :     {
; 2032 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])

  00048	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0004b	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  00052	75 1e		 jne	 SHORT $LN5@DragBehavi
  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	6b c8 00	 imul	 ecx, eax, 0
  0005c	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  0005f	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  00067	85 c0		 test	 eax, eax
  00069	75 07		 jne	 SHORT $LN5@DragBehavi

; 2033 :             ClearActiveID();

  0006b	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
  00070	eb 2d		 jmp	 SHORT $LN7@DragBehavi
$LN5@DragBehavi:

; 2034 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

  00072	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00075	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  0007c	75 21		 jne	 SHORT $LN7@DragBehavi
  0007e	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00081	8b 88 e0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6880]
  00087	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  0008a	75 13		 jne	 SHORT $LN7@DragBehavi
  0008c	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0008f	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  00096	85 c9		 test	 ecx, ecx
  00098	75 05		 jne	 SHORT $LN7@DragBehavi

; 2035 :             ClearActiveID();

  0009a	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN7@DragBehavi:

; 2036 :     }
; 2037 :     if (g.ActiveId != id)

  0009f	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000a2	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  000a8	3b 4d 08	 cmp	 ecx, DWORD PTR _id$[ebp]
  000ab	74 07		 je	 SHORT $LN8@DragBehavi

; 2038 :         return false;

  000ad	32 c0		 xor	 al, al
  000af	e9 42 06 00 00	 jmp	 $LN1@DragBehavi
$LN8@DragBehavi:

; 2039 : 
; 2040 :     switch (data_type)

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _data_type$[ebp]
  000b7	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  000bd	83 bd cc fe ff
	ff 09		 cmp	 DWORD PTR tv83[ebp], 9
  000c4	0f 87 00 06 00
	00		 ja	 $LN2@DragBehavi
  000ca	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv83[ebp]
  000d0	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN66@DragBehavi[ecx*4]
$LN9@DragBehavi:

; 2041 :     {
; 2042 :     case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS8*) p_min : IM_S8_MIN,  p_max ? *(const ImS8*)p_max  : IM_S8_MAX,  format, power, flags); if (r) *(ImS8*)p_v = (ImS8)v32; return r; }

  000d7	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  000da	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000dd	89 4d e8	 mov	 DWORD PTR _v32$8[ebp], ecx
  000e0	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  000e4	74 0d		 je	 SHORT $LN25@DragBehavi
  000e6	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  000e9	8a 08		 mov	 cl, BYTE PTR [eax]
  000eb	88 8d cf fe ff
	ff		 mov	 BYTE PTR tv90[ebp], cl
  000f1	eb 07		 jmp	 SHORT $LN26@DragBehavi
$LN25@DragBehavi:
  000f3	c6 85 cf fe ff
	ff 7f		 mov	 BYTE PTR tv90[ebp], 127	; 0000007fH
$LN26@DragBehavi:
  000fa	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  000fe	74 0d		 je	 SHORT $LN27@DragBehavi
  00100	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  00103	8a 02		 mov	 al, BYTE PTR [edx]
  00105	88 85 ce fe ff
	ff		 mov	 BYTE PTR tv94[ebp], al
  0010b	eb 07		 jmp	 SHORT $LN28@DragBehavi
$LN27@DragBehavi:
  0010d	c6 85 ce fe ff
	ff 80		 mov	 BYTE PTR tv94[ebp], -128 ; ffffff80H
$LN28@DragBehavi:
  00114	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00117	51		 push	 ecx
  00118	51		 push	 ecx
  00119	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0011e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00123	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00126	52		 push	 edx
  00127	0f be 85 cf fe
	ff ff		 movsx	 eax, BYTE PTR tv90[ebp]
  0012e	50		 push	 eax
  0012f	0f be 8d ce fe
	ff ff		 movsx	 ecx, BYTE PTR tv94[ebp]
  00136	51		 push	 ecx
  00137	51		 push	 ecx
  00138	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  0013d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00142	8d 55 e8	 lea	 edx, DWORD PTR _v32$8[ebp]
  00145	52		 push	 edx
  00146	6a 04		 push	 4
  00148	e8 00 00 00 00	 call	 ??$DragBehaviorT@HHM@ImGui@@YA_NHPAHMHHPBDMH@Z ; ImGui::DragBehaviorT<int,int,float>
  0014d	83 c4 20	 add	 esp, 32			; 00000020H
  00150	88 45 df	 mov	 BYTE PTR _r$7[ebp], al
  00153	0f b6 45 df	 movzx	 eax, BYTE PTR _r$7[ebp]
  00157	85 c0		 test	 eax, eax
  00159	74 08		 je	 SHORT $LN10@DragBehavi
  0015b	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  0015e	8a 4d e8	 mov	 cl, BYTE PTR _v32$8[ebp]
  00161	88 08		 mov	 BYTE PTR [eax], cl
$LN10@DragBehavi:
  00163	8a 45 df	 mov	 al, BYTE PTR _r$7[ebp]
  00166	e9 8b 05 00 00	 jmp	 $LN1@DragBehavi
$LN11@DragBehavi:

; 2043 :     case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU8*) p_min : IM_U8_MIN,  p_max ? *(const ImU8*)p_max  : IM_U8_MAX,  format, power, flags); if (r) *(ImU8*)p_v = (ImU8)v32; return r; }

  0016b	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  0016e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00171	89 4d d0	 mov	 DWORD PTR _v32$6[ebp], ecx
  00174	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  00178	74 0d		 je	 SHORT $LN29@DragBehavi
  0017a	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  0017d	8a 08		 mov	 cl, BYTE PTR [eax]
  0017f	88 8d cf fe ff
	ff		 mov	 BYTE PTR tv140[ebp], cl
  00185	eb 07		 jmp	 SHORT $LN30@DragBehavi
$LN29@DragBehavi:
  00187	c6 85 cf fe ff
	ff ff		 mov	 BYTE PTR tv140[ebp], 255 ; 000000ffH
$LN30@DragBehavi:
  0018e	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  00192	74 0d		 je	 SHORT $LN31@DragBehavi
  00194	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  00197	8a 02		 mov	 al, BYTE PTR [edx]
  00199	88 85 ce fe ff
	ff		 mov	 BYTE PTR tv144[ebp], al
  0019f	eb 07		 jmp	 SHORT $LN32@DragBehavi
$LN31@DragBehavi:
  001a1	c6 85 ce fe ff
	ff 00		 mov	 BYTE PTR tv144[ebp], 0
$LN32@DragBehavi:
  001a8	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  001ab	51		 push	 ecx
  001ac	51		 push	 ecx
  001ad	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  001b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b7	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  001ba	52		 push	 edx
  001bb	0f b6 85 cf fe
	ff ff		 movzx	 eax, BYTE PTR tv140[ebp]
  001c2	50		 push	 eax
  001c3	0f b6 8d ce fe
	ff ff		 movzx	 ecx, BYTE PTR tv144[ebp]
  001ca	51		 push	 ecx
  001cb	51		 push	 ecx
  001cc	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  001d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d6	8d 55 d0	 lea	 edx, DWORD PTR _v32$6[ebp]
  001d9	52		 push	 edx
  001da	6a 05		 push	 5
  001dc	e8 00 00 00 00	 call	 ??$DragBehaviorT@IHM@ImGui@@YA_NHPAIMIIPBDMH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
  001e1	83 c4 20	 add	 esp, 32			; 00000020H
  001e4	88 45 c7	 mov	 BYTE PTR _r$5[ebp], al
  001e7	0f b6 45 c7	 movzx	 eax, BYTE PTR _r$5[ebp]
  001eb	85 c0		 test	 eax, eax
  001ed	74 08		 je	 SHORT $LN12@DragBehavi
  001ef	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  001f2	8a 4d d0	 mov	 cl, BYTE PTR _v32$6[ebp]
  001f5	88 08		 mov	 BYTE PTR [eax], cl
$LN12@DragBehavi:
  001f7	8a 45 c7	 mov	 al, BYTE PTR _r$5[ebp]
  001fa	e9 f7 04 00 00	 jmp	 $LN1@DragBehavi
$LN13@DragBehavi:

; 2044 :     case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS16*)p_min : IM_S16_MIN, p_max ? *(const ImS16*)p_max : IM_S16_MAX, format, power, flags); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }

  001ff	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  00202	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00205	89 4d b8	 mov	 DWORD PTR _v32$4[ebp], ecx
  00208	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  0020c	74 0f		 je	 SHORT $LN33@DragBehavi
  0020e	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00211	66 8b 08	 mov	 cx, WORD PTR [eax]
  00214	66 89 8d ce fe
	ff ff		 mov	 WORD PTR tv158[ebp], cx
  0021b	eb 0c		 jmp	 SHORT $LN34@DragBehavi
$LN33@DragBehavi:
  0021d	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  00222	66 89 95 ce fe
	ff ff		 mov	 WORD PTR tv158[ebp], dx
$LN34@DragBehavi:
  00229	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  0022d	74 0f		 je	 SHORT $LN35@DragBehavi
  0022f	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  00232	66 8b 08	 mov	 cx, WORD PTR [eax]
  00235	66 89 8d cc fe
	ff ff		 mov	 WORD PTR tv162[ebp], cx
  0023c	eb 0c		 jmp	 SHORT $LN36@DragBehavi
$LN35@DragBehavi:
  0023e	ba 00 80 ff ff	 mov	 edx, -32768		; ffff8000H
  00243	66 89 95 cc fe
	ff ff		 mov	 WORD PTR tv162[ebp], dx
$LN36@DragBehavi:
  0024a	8b 45 28	 mov	 eax, DWORD PTR _flags$[ebp]
  0024d	50		 push	 eax
  0024e	51		 push	 ecx
  0024f	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00254	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00259	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  0025c	51		 push	 ecx
  0025d	0f bf 95 ce fe
	ff ff		 movsx	 edx, WORD PTR tv158[ebp]
  00264	52		 push	 edx
  00265	0f bf 85 cc fe
	ff ff		 movsx	 eax, WORD PTR tv162[ebp]
  0026c	50		 push	 eax
  0026d	51		 push	 ecx
  0026e	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00273	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00278	8d 4d b8	 lea	 ecx, DWORD PTR _v32$4[ebp]
  0027b	51		 push	 ecx
  0027c	6a 04		 push	 4
  0027e	e8 00 00 00 00	 call	 ??$DragBehaviorT@HHM@ImGui@@YA_NHPAHMHHPBDMH@Z ; ImGui::DragBehaviorT<int,int,float>
  00283	83 c4 20	 add	 esp, 32			; 00000020H
  00286	88 45 af	 mov	 BYTE PTR _r$3[ebp], al
  00289	0f b6 45 af	 movzx	 eax, BYTE PTR _r$3[ebp]
  0028d	85 c0		 test	 eax, eax
  0028f	74 0a		 je	 SHORT $LN14@DragBehavi
  00291	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  00294	66 8b 4d b8	 mov	 cx, WORD PTR _v32$4[ebp]
  00298	66 89 08	 mov	 WORD PTR [eax], cx
$LN14@DragBehavi:
  0029b	8a 45 af	 mov	 al, BYTE PTR _r$3[ebp]
  0029e	e9 53 04 00 00	 jmp	 $LN1@DragBehavi
$LN15@DragBehavi:

; 2045 :     case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU16*)p_min : IM_U16_MIN, p_max ? *(const ImU16*)p_max : IM_U16_MAX, format, power, flags); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }

  002a3	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  002a6	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  002a9	89 4d a0	 mov	 DWORD PTR _v32$2[ebp], ecx
  002ac	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  002b0	74 0f		 je	 SHORT $LN37@DragBehavi
  002b2	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  002b5	66 8b 08	 mov	 cx, WORD PTR [eax]
  002b8	66 89 8d ce fe
	ff ff		 mov	 WORD PTR tv176[ebp], cx
  002bf	eb 0c		 jmp	 SHORT $LN38@DragBehavi
$LN37@DragBehavi:
  002c1	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  002c6	66 89 95 ce fe
	ff ff		 mov	 WORD PTR tv176[ebp], dx
$LN38@DragBehavi:
  002cd	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  002d1	74 0f		 je	 SHORT $LN39@DragBehavi
  002d3	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  002d6	66 8b 08	 mov	 cx, WORD PTR [eax]
  002d9	66 89 8d cc fe
	ff ff		 mov	 WORD PTR tv180[ebp], cx
  002e0	eb 09		 jmp	 SHORT $LN40@DragBehavi
$LN39@DragBehavi:
  002e2	33 d2		 xor	 edx, edx
  002e4	66 89 95 cc fe
	ff ff		 mov	 WORD PTR tv180[ebp], dx
$LN40@DragBehavi:
  002eb	8b 45 28	 mov	 eax, DWORD PTR _flags$[ebp]
  002ee	50		 push	 eax
  002ef	51		 push	 ecx
  002f0	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  002f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fa	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  002fd	51		 push	 ecx
  002fe	0f b7 95 ce fe
	ff ff		 movzx	 edx, WORD PTR tv176[ebp]
  00305	52		 push	 edx
  00306	0f b7 85 cc fe
	ff ff		 movzx	 eax, WORD PTR tv180[ebp]
  0030d	50		 push	 eax
  0030e	51		 push	 ecx
  0030f	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00314	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00319	8d 4d a0	 lea	 ecx, DWORD PTR _v32$2[ebp]
  0031c	51		 push	 ecx
  0031d	6a 05		 push	 5
  0031f	e8 00 00 00 00	 call	 ??$DragBehaviorT@IHM@ImGui@@YA_NHPAIMIIPBDMH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
  00324	83 c4 20	 add	 esp, 32			; 00000020H
  00327	88 45 97	 mov	 BYTE PTR _r$1[ebp], al
  0032a	0f b6 45 97	 movzx	 eax, BYTE PTR _r$1[ebp]
  0032e	85 c0		 test	 eax, eax
  00330	74 0a		 je	 SHORT $LN16@DragBehavi
  00332	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  00335	66 8b 4d a0	 mov	 cx, WORD PTR _v32$2[ebp]
  00339	66 89 08	 mov	 WORD PTR [eax], cx
$LN16@DragBehavi:
  0033c	8a 45 97	 mov	 al, BYTE PTR _r$1[ebp]
  0033f	e9 b2 03 00 00	 jmp	 $LN1@DragBehavi
$LN17@DragBehavi:

; 2046 :     case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)p_v,  v_speed, p_min ? *(const ImS32* )p_min : IM_S32_MIN, p_max ? *(const ImS32* )p_max : IM_S32_MAX, format, power, flags);

  00344	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  00348	74 0d		 je	 SHORT $LN41@DragBehavi
  0034a	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  0034d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034f	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv193[ebp], ecx
  00355	eb 0a		 jmp	 SHORT $LN42@DragBehavi
$LN41@DragBehavi:
  00357	c7 85 cc fe ff
	ff ff ff ff 7f	 mov	 DWORD PTR tv193[ebp], 2147483647 ; 7fffffffH
$LN42@DragBehavi:
  00361	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  00365	74 0d		 je	 SHORT $LN43@DragBehavi
  00367	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  0036a	8b 02		 mov	 eax, DWORD PTR [edx]
  0036c	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv196[ebp], eax
  00372	eb 0a		 jmp	 SHORT $LN44@DragBehavi
$LN43@DragBehavi:
  00374	c7 85 c8 fe ff
	ff 00 00 00 80	 mov	 DWORD PTR tv196[ebp], -2147483648 ; 80000000H
$LN44@DragBehavi:
  0037e	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  00381	51		 push	 ecx
  00382	51		 push	 ecx
  00383	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00388	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038d	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  00390	52		 push	 edx
  00391	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv193[ebp]
  00397	50		 push	 eax
  00398	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv196[ebp]
  0039e	51		 push	 ecx
  0039f	51		 push	 ecx
  003a0	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  003a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003aa	8b 55 10	 mov	 edx, DWORD PTR _p_v$[ebp]
  003ad	52		 push	 edx
  003ae	8b 45 0c	 mov	 eax, DWORD PTR _data_type$[ebp]
  003b1	50		 push	 eax
  003b2	e8 00 00 00 00	 call	 ??$DragBehaviorT@HHM@ImGui@@YA_NHPAHMHHPBDMH@Z ; ImGui::DragBehaviorT<int,int,float>
  003b7	83 c4 20	 add	 esp, 32			; 00000020H
  003ba	e9 37 03 00 00	 jmp	 $LN1@DragBehavi
$LN18@DragBehavi:

; 2047 :     case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)p_v,  v_speed, p_min ? *(const ImU32* )p_min : IM_U32_MIN, p_max ? *(const ImU32* )p_max : IM_U32_MAX, format, power, flags);

  003bf	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  003c3	74 0d		 je	 SHORT $LN45@DragBehavi
  003c5	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  003c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ca	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv206[ebp], ecx
  003d0	eb 0a		 jmp	 SHORT $LN46@DragBehavi
$LN45@DragBehavi:
  003d2	c7 85 cc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv206[ebp], -1
$LN46@DragBehavi:
  003dc	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  003e0	74 0d		 je	 SHORT $LN47@DragBehavi
  003e2	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  003e5	8b 02		 mov	 eax, DWORD PTR [edx]
  003e7	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv209[ebp], eax
  003ed	eb 0a		 jmp	 SHORT $LN48@DragBehavi
$LN47@DragBehavi:
  003ef	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv209[ebp], 0
$LN48@DragBehavi:
  003f9	8b 4d 28	 mov	 ecx, DWORD PTR _flags$[ebp]
  003fc	51		 push	 ecx
  003fd	51		 push	 ecx
  003fe	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00403	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00408	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  0040b	52		 push	 edx
  0040c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  00412	50		 push	 eax
  00413	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv209[ebp]
  00419	51		 push	 ecx
  0041a	51		 push	 ecx
  0041b	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00420	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00425	8b 55 10	 mov	 edx, DWORD PTR _p_v$[ebp]
  00428	52		 push	 edx
  00429	8b 45 0c	 mov	 eax, DWORD PTR _data_type$[ebp]
  0042c	50		 push	 eax
  0042d	e8 00 00 00 00	 call	 ??$DragBehaviorT@IHM@ImGui@@YA_NHPAIMIIPBDMH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
  00432	83 c4 20	 add	 esp, 32			; 00000020H
  00435	e9 bc 02 00 00	 jmp	 $LN1@DragBehavi
$LN19@DragBehavi:

; 2048 :     case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)p_v,  v_speed, p_min ? *(const ImS64* )p_min : IM_S64_MIN, p_max ? *(const ImS64* )p_max : IM_S64_MAX, format, power, flags);

  0043a	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  0043e	74 16		 je	 SHORT $LN49@DragBehavi
  00440	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00443	8b 08		 mov	 ecx, DWORD PTR [eax]
  00445	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv219[ebp], ecx
  0044b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0044e	89 95 cc fe ff
	ff		 mov	 DWORD PTR tv219[ebp+4], edx
  00454	eb 14		 jmp	 SHORT $LN50@DragBehavi
$LN49@DragBehavi:
  00456	c7 85 c8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv219[ebp], -1
  00460	c7 85 cc fe ff
	ff ff ff ff 7f	 mov	 DWORD PTR tv219[ebp+4], 2147483647 ; 7fffffffH
$LN50@DragBehavi:
  0046a	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  0046e	74 16		 je	 SHORT $LN51@DragBehavi
  00470	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  00473	8b 08		 mov	 ecx, DWORD PTR [eax]
  00475	89 8d c0 fe ff
	ff		 mov	 DWORD PTR tv222[ebp], ecx
  0047b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0047e	89 95 c4 fe ff
	ff		 mov	 DWORD PTR tv222[ebp+4], edx
  00484	eb 14		 jmp	 SHORT $LN52@DragBehavi
$LN51@DragBehavi:
  00486	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv222[ebp], 0
  00490	c7 85 c4 fe ff
	ff 00 00 00 80	 mov	 DWORD PTR tv222[ebp+4], -2147483648 ; 80000000H
$LN52@DragBehavi:
  0049a	8b 45 28	 mov	 eax, DWORD PTR _flags$[ebp]
  0049d	50		 push	 eax
  0049e	51		 push	 ecx
  0049f	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  004a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a9	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  004ac	51		 push	 ecx
  004ad	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv219[ebp+4]
  004b3	52		 push	 edx
  004b4	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR tv219[ebp]
  004ba	50		 push	 eax
  004bb	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv222[ebp+4]
  004c1	51		 push	 ecx
  004c2	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR tv222[ebp]
  004c8	52		 push	 edx
  004c9	51		 push	 ecx
  004ca	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  004cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d4	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  004d7	50		 push	 eax
  004d8	8b 4d 0c	 mov	 ecx, DWORD PTR _data_type$[ebp]
  004db	51		 push	 ecx
  004dc	e8 00 00 00 00	 call	 ??$DragBehaviorT@_J_JN@ImGui@@YA_NHPA_JM_J1PBDMH@Z ; ImGui::DragBehaviorT<__int64,__int64,double>
  004e1	83 c4 28	 add	 esp, 40			; 00000028H
  004e4	e9 0d 02 00 00	 jmp	 $LN1@DragBehavi
$LN20@DragBehavi:

; 2049 :     case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)p_v,  v_speed, p_min ? *(const ImU64* )p_min : IM_U64_MIN, p_max ? *(const ImU64* )p_max : IM_U64_MAX, format, power, flags);

  004e9	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  004ed	74 16		 je	 SHORT $LN53@DragBehavi
  004ef	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  004f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  004f4	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv232[ebp], ecx
  004fa	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004fd	89 95 cc fe ff
	ff		 mov	 DWORD PTR tv232[ebp+4], edx
  00503	eb 14		 jmp	 SHORT $LN54@DragBehavi
$LN53@DragBehavi:
  00505	c7 85 c8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv232[ebp], -1
  0050f	c7 85 cc fe ff
	ff ff ff ff ff	 mov	 DWORD PTR tv232[ebp+4], -1
$LN54@DragBehavi:
  00519	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  0051d	74 16		 je	 SHORT $LN55@DragBehavi
  0051f	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  00522	8b 08		 mov	 ecx, DWORD PTR [eax]
  00524	89 8d c0 fe ff
	ff		 mov	 DWORD PTR tv235[ebp], ecx
  0052a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0052d	89 95 c4 fe ff
	ff		 mov	 DWORD PTR tv235[ebp+4], edx
  00533	eb 0b		 jmp	 SHORT $LN56@DragBehavi
$LN55@DragBehavi:
  00535	0f 57 c0	 xorps	 xmm0, xmm0
  00538	66 0f 13 85 c0
	fe ff ff	 movlpd	 QWORD PTR tv235[ebp], xmm0
$LN56@DragBehavi:
  00540	8b 45 28	 mov	 eax, DWORD PTR _flags$[ebp]
  00543	50		 push	 eax
  00544	51		 push	 ecx
  00545	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0054a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0054f	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  00552	51		 push	 ecx
  00553	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv232[ebp+4]
  00559	52		 push	 edx
  0055a	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR tv232[ebp]
  00560	50		 push	 eax
  00561	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv235[ebp+4]
  00567	51		 push	 ecx
  00568	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR tv235[ebp]
  0056e	52		 push	 edx
  0056f	51		 push	 ecx
  00570	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00575	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0057a	8b 45 10	 mov	 eax, DWORD PTR _p_v$[ebp]
  0057d	50		 push	 eax
  0057e	8b 4d 0c	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00581	51		 push	 ecx
  00582	e8 00 00 00 00	 call	 ??$DragBehaviorT@_K_JN@ImGui@@YA_NHPA_KM_K1PBDMH@Z ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
  00587	83 c4 28	 add	 esp, 40			; 00000028H
  0058a	e9 67 01 00 00	 jmp	 $LN1@DragBehavi
$LN21@DragBehavi:

; 2050 :     case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)p_v,  v_speed, p_min ? *(const float* )p_min : -FLT_MAX,   p_max ? *(const float* )p_max : FLT_MAX,    format, power, flags);

  0058f	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  00593	74 11		 je	 SHORT $LN57@DragBehavi
  00595	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00598	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0059c	f3 0f 11 85 cc
	fe ff ff	 movss	 DWORD PTR tv245[ebp], xmm0
  005a4	eb 10		 jmp	 SHORT $LN58@DragBehavi
$LN57@DragBehavi:
  005a6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  005ae	f3 0f 11 85 cc
	fe ff ff	 movss	 DWORD PTR tv245[ebp], xmm0
$LN58@DragBehavi:
  005b6	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  005ba	74 11		 je	 SHORT $LN59@DragBehavi
  005bc	8b 4d 18	 mov	 ecx, DWORD PTR _p_min$[ebp]
  005bf	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  005c3	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR tv248[ebp], xmm0
  005cb	eb 10		 jmp	 SHORT $LN60@DragBehavi
$LN59@DragBehavi:
  005cd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  005d5	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR tv248[ebp], xmm0
$LN60@DragBehavi:
  005dd	8b 55 28	 mov	 edx, DWORD PTR _flags$[ebp]
  005e0	52		 push	 edx
  005e1	51		 push	 ecx
  005e2	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  005e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005ec	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  005ef	50		 push	 eax
  005f0	51		 push	 ecx
  005f1	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR tv245[ebp]
  005f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005fe	51		 push	 ecx
  005ff	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR tv248[ebp]
  00607	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0060c	51		 push	 ecx
  0060d	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00612	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00617	8b 4d 10	 mov	 ecx, DWORD PTR _p_v$[ebp]
  0061a	51		 push	 ecx
  0061b	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  0061e	52		 push	 edx
  0061f	e8 00 00 00 00	 call	 ??$DragBehaviorT@MMM@ImGui@@YA_NHPAMMMMPBDMH@Z ; ImGui::DragBehaviorT<float,float,float>
  00624	83 c4 20	 add	 esp, 32			; 00000020H
  00627	e9 ca 00 00 00	 jmp	 $LN1@DragBehavi
$LN22@DragBehavi:

; 2051 :     case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)p_v, v_speed, p_min ? *(const double*)p_min : -DBL_MAX,   p_max ? *(const double*)p_max : DBL_MAX,    format, power, flags);

  0062c	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  00630	74 11		 je	 SHORT $LN61@DragBehavi
  00632	8b 45 1c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00635	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [eax]
  00639	f2 0f 11 85 c8
	fe ff ff	 movsd	 QWORD PTR tv258[ebp], xmm0
  00641	eb 10		 jmp	 SHORT $LN62@DragBehavi
$LN61@DragBehavi:
  00643	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@7fefffffffffffff
  0064b	f2 0f 11 85 c8
	fe ff ff	 movsd	 QWORD PTR tv258[ebp], xmm0
$LN62@DragBehavi:
  00653	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  00657	74 11		 je	 SHORT $LN63@DragBehavi
  00659	8b 4d 18	 mov	 ecx, DWORD PTR _p_min$[ebp]
  0065c	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [ecx]
  00660	f2 0f 11 85 c0
	fe ff ff	 movsd	 QWORD PTR tv261[ebp], xmm0
  00668	eb 10		 jmp	 SHORT $LN64@DragBehavi
$LN63@DragBehavi:
  0066a	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@ffefffffffffffff
  00672	f2 0f 11 85 c0
	fe ff ff	 movsd	 QWORD PTR tv261[ebp], xmm0
$LN64@DragBehavi:
  0067a	8b 55 28	 mov	 edx, DWORD PTR _flags$[ebp]
  0067d	52		 push	 edx
  0067e	51		 push	 ecx
  0067f	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00684	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00689	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  0068c	50		 push	 eax
  0068d	83 ec 08	 sub	 esp, 8
  00690	f2 0f 10 85 c8
	fe ff ff	 movsd	 xmm0, QWORD PTR tv258[ebp]
  00698	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0069d	83 ec 08	 sub	 esp, 8
  006a0	f2 0f 10 85 c0
	fe ff ff	 movsd	 xmm0, QWORD PTR tv261[ebp]
  006a8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006ad	51		 push	 ecx
  006ae	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  006b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006b8	8b 4d 10	 mov	 ecx, DWORD PTR _p_v$[ebp]
  006bb	51		 push	 ecx
  006bc	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  006bf	52		 push	 edx
  006c0	e8 00 00 00 00	 call	 ??$DragBehaviorT@NNN@ImGui@@YA_NHPANMNNPBDMH@Z ; ImGui::DragBehaviorT<double,double,double>
  006c5	83 c4 28	 add	 esp, 40			; 00000028H
  006c8	eb 2c		 jmp	 SHORT $LN1@DragBehavi
$LN2@DragBehavi:

; 2052 :     case ImGuiDataType_COUNT:  break;
; 2053 :     }
; 2054 :     IM_ASSERT(0);

  006ca	33 c0		 xor	 eax, eax
  006cc	75 26		 jne	 SHORT $LN65@DragBehavi
  006ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z@4JA
  006d4	83 c1 1a	 add	 ecx, 26			; 0000001aH
  006d7	8b f4		 mov	 esi, esp
  006d9	51		 push	 ecx
  006da	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  006df	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  006e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  006ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  006ed	3b f4		 cmp	 esi, esp
  006ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN65@DragBehavi:

; 2055 :     return false;

  006f4	32 c0		 xor	 al, al
$LN1@DragBehavi:

; 2056 : }

  006f6	52		 push	 edx
  006f7	8b cd		 mov	 ecx, ebp
  006f9	50		 push	 eax
  006fa	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN72@DragBehavi
  00700	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00705	58		 pop	 eax
  00706	5a		 pop	 edx
  00707	5f		 pop	 edi
  00708	5e		 pop	 esi
  00709	5b		 pop	 ebx
  0070a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0070d	33 cd		 xor	 ecx, ebp
  0070f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00714	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  0071a	3b ec		 cmp	 ebp, esp
  0071c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00721	8b e5		 mov	 esp, ebp
  00723	5d		 pop	 ebp
  00724	c3		 ret	 0
  00725	0f 1f 00	 npad	 3
$LN72@DragBehavi:
  00728	04 00 00 00	 DD	 4
  0072c	00 00 00 00	 DD	 $LN71@DragBehavi
$LN71@DragBehavi:
  00730	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00734	04 00 00 00	 DD	 4
  00738	00 00 00 00	 DD	 $LN67@DragBehavi
  0073c	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00740	04 00 00 00	 DD	 4
  00744	00 00 00 00	 DD	 $LN68@DragBehavi
  00748	b8 ff ff ff	 DD	 -72			; ffffffb8H
  0074c	04 00 00 00	 DD	 4
  00750	00 00 00 00	 DD	 $LN69@DragBehavi
  00754	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00758	04 00 00 00	 DD	 4
  0075c	00 00 00 00	 DD	 $LN70@DragBehavi
$LN70@DragBehavi:
  00760	76		 DB	 118			; 00000076H
  00761	33		 DB	 51			; 00000033H
  00762	32		 DB	 50			; 00000032H
  00763	00		 DB	 0
$LN69@DragBehavi:
  00764	76		 DB	 118			; 00000076H
  00765	33		 DB	 51			; 00000033H
  00766	32		 DB	 50			; 00000032H
  00767	00		 DB	 0
$LN68@DragBehavi:
  00768	76		 DB	 118			; 00000076H
  00769	33		 DB	 51			; 00000033H
  0076a	32		 DB	 50			; 00000032H
  0076b	00		 DB	 0
$LN67@DragBehavi:
  0076c	76		 DB	 118			; 00000076H
  0076d	33		 DB	 51			; 00000033H
  0076e	32		 DB	 50			; 00000032H
  0076f	00		 DB	 0
$LN66@DragBehavi:
  00770	00 00 00 00	 DD	 $LN9@DragBehavi
  00774	00 00 00 00	 DD	 $LN11@DragBehavi
  00778	00 00 00 00	 DD	 $LN13@DragBehavi
  0077c	00 00 00 00	 DD	 $LN15@DragBehavi
  00780	00 00 00 00	 DD	 $LN17@DragBehavi
  00784	00 00 00 00	 DD	 $LN18@DragBehavi
  00788	00 00 00 00	 DD	 $LN19@DragBehavi
  0078c	00 00 00 00	 DD	 $LN20@DragBehavi
  00790	00 00 00 00	 DD	 $LN21@DragBehavi
  00794	00 00 00 00	 DD	 $LN22@DragBehavi
?DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z ENDP		; ImGui::DragBehavior
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z
_TEXT	SEGMENT
tv354 = -344						; size = 4
tv343 = -344						; size = 4
tv279 = -344						; size = 4
tv274 = -344						; size = 4
tv79 = -341						; size = 1
$T1 = -336						; size = 8
_is_repeating_already$2 = -125				; size = 1
_is_double_click_release$3 = -113			; size = 1
_held$ = -101						; size = 1
_nav_activated_by_inputs$4 = -89			; size = 1
_nav_activated_by_code$5 = -77				; size = 1
_hovered$ = -65						; size = 1
_pressed$ = -53						; size = 1
_flatten_hovered_children$ = -41			; size = 1
_backup_hovered_window$ = -32				; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_out_hovered$ = 16					; size = 4
_out_held$ = 20						; size = 4
_flags$ = 24						; size = 4
?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z PROC	; ImGui::ButtonBehavior, COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-344]
  00012	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 453  :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 454  :     ImGuiWindow* window = GetCurrentWindow();

  00030	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00035	89 45 ec	 mov	 DWORD PTR _window$[ebp], eax

; 455  : 
; 456  :     if (flags & ImGuiButtonFlags_Disabled)

  00038	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  0003b	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00040	74 32		 je	 SHORT $LN2@ButtonBeha

; 457  :     {
; 458  :         if (out_hovered) *out_hovered = false;

  00042	83 7d 10 00	 cmp	 DWORD PTR _out_hovered$[ebp], 0
  00046	74 06		 je	 SHORT $LN3@ButtonBeha
  00048	8b 45 10	 mov	 eax, DWORD PTR _out_hovered$[ebp]
  0004b	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN3@ButtonBeha:

; 459  :         if (out_held) *out_held = false;

  0004e	83 7d 14 00	 cmp	 DWORD PTR _out_held$[ebp], 0
  00052	74 06		 je	 SHORT $LN4@ButtonBeha
  00054	8b 45 14	 mov	 eax, DWORD PTR _out_held$[ebp]
  00057	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN4@ButtonBeha:

; 460  :         if (g.ActiveId == id) ClearActiveID();

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0005d	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00063	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00066	75 05		 jne	 SHORT $LN5@ButtonBeha
  00068	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN5@ButtonBeha:

; 461  :         return false;

  0006d	32 c0		 xor	 al, al
  0006f	e9 6a 06 00 00	 jmp	 $LN1@ButtonBeha
$LN2@ButtonBeha:

; 462  :     }
; 463  : 
; 464  :     // Default behavior requires click+release on same spot
; 465  :     if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)

  00074	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00077	83 e0 1e	 and	 eax, 30			; 0000001eH
  0007a	75 09		 jne	 SHORT $LN6@ButtonBeha

; 466  :         flags |= ImGuiButtonFlags_PressedOnClickRelease;

  0007c	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  0007f	83 c8 02	 or	 eax, 2
  00082	89 45 18	 mov	 DWORD PTR _flags$[ebp], eax
$LN6@ButtonBeha:

; 467  : 
; 468  :     ImGuiWindow* backup_hovered_window = g.HoveredWindow;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00088	8b 88 b4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6580]
  0008e	89 4d e0	 mov	 DWORD PTR _backup_hovered_window$[ebp], ecx

; 469  :     const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window;

  00091	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00094	83 e0 20	 and	 eax, 32			; 00000020H
  00097	74 17		 je	 SHORT $LN54@ButtonBeha
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0009c	8b 91 b8 19 00
	00		 mov	 edx, DWORD PTR [ecx+6584]
  000a2	3b 55 ec	 cmp	 edx, DWORD PTR _window$[ebp]
  000a5	75 09		 jne	 SHORT $LN54@ButtonBeha
  000a7	c6 85 ab fe ff
	ff 01		 mov	 BYTE PTR tv79[ebp], 1
  000ae	eb 07		 jmp	 SHORT $LN55@ButtonBeha
$LN54@ButtonBeha:
  000b0	c6 85 ab fe ff
	ff 00		 mov	 BYTE PTR tv79[ebp], 0
$LN55@ButtonBeha:
  000b7	8a 85 ab fe ff
	ff		 mov	 al, BYTE PTR tv79[ebp]
  000bd	88 45 d7	 mov	 BYTE PTR _flatten_hovered_children$[ebp], al

; 470  :     if (flatten_hovered_children)

  000c0	0f b6 45 d7	 movzx	 eax, BYTE PTR _flatten_hovered_children$[ebp]
  000c4	85 c0		 test	 eax, eax
  000c6	74 0c		 je	 SHORT $LN7@ButtonBeha

; 471  :         g.HoveredWindow = window;

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  000cb	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  000ce	89 88 b4 19 00
	00		 mov	 DWORD PTR [eax+6580], ecx
$LN7@ButtonBeha:

; 472  : 
; 473  : #ifdef IMGUI_ENABLE_TEST_ENGINE
; 474  :     if (id != 0 && window->DC.LastItemId != id)
; 475  :         ImGuiTestEngineHook_ItemAdd(&g, bb, id);
; 476  : #endif
; 477  : 
; 478  :     bool pressed = false;

  000d4	c6 45 cb 00	 mov	 BYTE PTR _pressed$[ebp], 0

; 479  :     bool hovered = ItemHoverable(bb, id);

  000d8	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  000db	50		 push	 eax
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _bb$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z ; ImGui::ItemHoverable
  000e5	83 c4 08	 add	 esp, 8
  000e8	88 45 bf	 mov	 BYTE PTR _hovered$[ebp], al

; 480  : 
; 481  :     // Drag source doesn't report as hovered
; 482  :     if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))

  000eb	0f b6 45 bf	 movzx	 eax, BYTE PTR _hovered$[ebp]
  000ef	85 c0		 test	 eax, eax
  000f1	74 2e		 je	 SHORT $LN8@ButtonBeha
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  000f6	0f b6 88 34 1d
	00 00		 movzx	 ecx, BYTE PTR [eax+7476]
  000fd	85 c9		 test	 ecx, ecx
  000ff	74 20		 je	 SHORT $LN8@ButtonBeha
  00101	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00104	8b 88 4c 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7500]
  0010a	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0010d	75 12		 jne	 SHORT $LN8@ButtonBeha
  0010f	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00112	8b 88 38 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7480]
  00118	83 e1 02	 and	 ecx, 2
  0011b	75 04		 jne	 SHORT $LN8@ButtonBeha

; 483  :         hovered = false;

  0011d	c6 45 bf 00	 mov	 BYTE PTR _hovered$[ebp], 0
$LN8@ButtonBeha:

; 484  : 
; 485  :     // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
; 486  :     if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))

  00121	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00124	0f b6 88 34 1d
	00 00		 movzx	 ecx, BYTE PTR [eax+7476]
  0012b	85 c9		 test	 ecx, ecx
  0012d	0f 84 ae 00 00
	00		 je	 $LN11@ButtonBeha
  00133	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00136	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  0013b	0f 84 a0 00 00
	00		 je	 $LN11@ButtonBeha
  00141	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00144	8b 88 38 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7480]
  0014a	83 e1 04	 and	 ecx, 4
  0014d	0f 85 8e 00 00
	00		 jne	 $LN11@ButtonBeha

; 487  :         if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))

  00153	6a 20		 push	 32			; 00000020H
  00155	e8 00 00 00 00	 call	 ?IsItemHovered@ImGui@@YA_NH@Z ; ImGui::IsItemHovered
  0015a	83 c4 04	 add	 esp, 4
  0015d	0f b6 c0	 movzx	 eax, al
  00160	85 c0		 test	 eax, eax
  00162	74 7d		 je	 SHORT $LN11@ButtonBeha

; 488  :         {
; 489  :             hovered = true;

  00164	c6 45 bf 01	 mov	 BYTE PTR _hovered$[ebp], 1

; 490  :             SetHoveredID(id);

  00168	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?SetHoveredID@ImGui@@YAXI@Z ; ImGui::SetHoveredID
  00171	83 c4 04	 add	 esp, 4

; 491  :             if (CalcTypematicRepeatAmount(g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, g.HoveredIdTimer + 0.0001f, 0.70f, 0.00f))

  00174	51		 push	 ecx
  00175	0f 57 c0	 xorps	 xmm0, xmm0
  00178	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017d	51		 push	 ecx
  0017e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00186	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0018e	f3 0f 10 80 dc
	19 00 00	 movss	 xmm0, DWORD PTR [eax+6620]
  00196	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@38d1b717
  0019e	51		 push	 ecx
  0019f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a4	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  001a7	f3 0f 10 81 dc
	19 00 00	 movss	 xmm0, DWORD PTR [ecx+6620]
  001af	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@38d1b717
  001b7	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  001ba	f3 0f 5c 42 18	 subss	 xmm0, DWORD PTR [edx+24]
  001bf	51		 push	 ecx
  001c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c5	e8 00 00 00 00	 call	 ?CalcTypematicRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicRepeatAmount
  001ca	83 c4 10	 add	 esp, 16			; 00000010H
  001cd	85 c0		 test	 eax, eax
  001cf	74 10		 je	 SHORT $LN11@ButtonBeha

; 492  :             {
; 493  :                 pressed = true;

  001d1	c6 45 cb 01	 mov	 BYTE PTR _pressed$[ebp], 1

; 494  :                 FocusWindow(window);

  001d5	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  001d8	50		 push	 eax
  001d9	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  001de	83 c4 04	 add	 esp, 4
$LN11@ButtonBeha:

; 495  :             }
; 496  :         }
; 497  : 
; 498  :     if (flatten_hovered_children)

  001e1	0f b6 45 d7	 movzx	 eax, BYTE PTR _flatten_hovered_children$[ebp]
  001e5	85 c0		 test	 eax, eax
  001e7	74 0c		 je	 SHORT $LN12@ButtonBeha

; 499  :         g.HoveredWindow = backup_hovered_window;

  001e9	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001ec	8b 4d e0	 mov	 ecx, DWORD PTR _backup_hovered_window$[ebp]
  001ef	89 88 b4 19 00
	00		 mov	 DWORD PTR [eax+6580], ecx
$LN12@ButtonBeha:

; 500  : 
; 501  :     // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
; 502  :     if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))

  001f5	0f b6 45 bf	 movzx	 eax, BYTE PTR _hovered$[ebp]
  001f9	85 c0		 test	 eax, eax
  001fb	74 26		 je	 SHORT $LN13@ButtonBeha
  001fd	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00200	83 e0 40	 and	 eax, 64			; 00000040H
  00203	74 1e		 je	 SHORT $LN13@ButtonBeha
  00205	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00208	8b 88 d8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6616]
  0020e	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00211	74 10		 je	 SHORT $LN13@ButtonBeha
  00213	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00216	83 b8 d8 19 00
	00 00		 cmp	 DWORD PTR [eax+6616], 0
  0021d	74 04		 je	 SHORT $LN13@ButtonBeha

; 503  :         hovered = false;

  0021f	c6 45 bf 00	 mov	 BYTE PTR _hovered$[ebp], 0
$LN13@ButtonBeha:

; 504  : 
; 505  :     // Mouse
; 506  :     if (hovered)

  00223	0f b6 45 bf	 movzx	 eax, BYTE PTR _hovered$[ebp]
  00227	85 c0		 test	 eax, eax
  00229	0f 84 b0 01 00
	00		 je	 $LN28@ButtonBeha

; 507  :     {
; 508  :         if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))

  0022f	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00232	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00237	74 36		 je	 SHORT $LN16@ButtonBeha
  00239	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0023c	0f b6 88 00 01
	00 00		 movzx	 ecx, BYTE PTR [eax+256]
  00243	85 c9		 test	 ecx, ecx
  00245	0f 85 82 01 00
	00		 jne	 $LN27@ButtonBeha
  0024b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0024e	0f b6 88 01 01
	00 00		 movzx	 ecx, BYTE PTR [eax+257]
  00255	85 c9		 test	 ecx, ecx
  00257	0f 85 70 01 00
	00		 jne	 $LN27@ButtonBeha
  0025d	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00260	0f b6 88 02 01
	00 00		 movzx	 ecx, BYTE PTR [eax+258]
  00267	85 c9		 test	 ecx, ecx
  00269	0f 85 5e 01 00
	00		 jne	 $LN27@ButtonBeha
$LN16@ButtonBeha:

; 509  :         {
; 510  :             if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])

  0026f	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00272	83 e0 02	 and	 eax, 2
  00275	74 4d		 je	 SHORT $LN17@ButtonBeha
  00277	b8 01 00 00 00	 mov	 eax, 1
  0027c	6b c8 00	 imul	 ecx, eax, 0
  0027f	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00282	0f b6 84 0a d8
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+984]
  0028a	85 c0		 test	 eax, eax
  0028c	74 36		 je	 SHORT $LN17@ButtonBeha

; 511  :             {
; 512  :                 SetActiveID(id, window);

  0028e	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00291	50		 push	 eax
  00292	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  00295	51		 push	 ecx
  00296	e8 00 00 00 00	 call	 ?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
  0029b	83 c4 08	 add	 esp, 8

; 513  :                 if (!(flags & ImGuiButtonFlags_NoNavFocus))

  0029e	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  002a1	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  002a6	75 10		 jne	 SHORT $LN18@ButtonBeha

; 514  :                     SetFocusID(id, window);

  002a8	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  002ab	50		 push	 eax
  002ac	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  002af	51		 push	 ecx
  002b0	e8 00 00 00 00	 call	 ?SetFocusID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetFocusID
  002b5	83 c4 08	 add	 esp, 8
$LN18@ButtonBeha:

; 515  :                 FocusWindow(window);

  002b8	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  002c1	83 c4 04	 add	 esp, 4
$LN17@ButtonBeha:

; 516  :             }
; 517  :             if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))

  002c4	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  002c7	83 e0 04	 and	 eax, 4
  002ca	74 17		 je	 SHORT $LN21@ButtonBeha
  002cc	b8 01 00 00 00	 mov	 eax, 1
  002d1	6b c8 00	 imul	 ecx, eax, 0
  002d4	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  002d7	0f b6 84 0a d8
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+984]
  002df	85 c0		 test	 eax, eax
  002e1	75 1f		 jne	 SHORT $LN20@ButtonBeha
$LN21@ButtonBeha:
  002e3	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  002e6	83 e0 10	 and	 eax, 16			; 00000010H
  002e9	74 48		 je	 SHORT $LN19@ButtonBeha
  002eb	b8 01 00 00 00	 mov	 eax, 1
  002f0	6b c8 00	 imul	 ecx, eax, 0
  002f3	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  002f6	0f b6 84 0a dd
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+989]
  002fe	85 c0		 test	 eax, eax
  00300	74 31		 je	 SHORT $LN19@ButtonBeha
$LN20@ButtonBeha:

; 518  :             {
; 519  :                 pressed = true;

  00302	c6 45 cb 01	 mov	 BYTE PTR _pressed$[ebp], 1

; 520  :                 if (flags & ImGuiButtonFlags_NoHoldingActiveID)

  00306	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00309	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0030e	74 07		 je	 SHORT $LN22@ButtonBeha

; 521  :                     ClearActiveID();

  00310	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
  00315	eb 10		 jmp	 SHORT $LN23@ButtonBeha
$LN22@ButtonBeha:

; 522  :                 else
; 523  :                     SetActiveID(id, window); // Hold on ID

  00317	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0031a	50		 push	 eax
  0031b	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  0031e	51		 push	 ecx
  0031f	e8 00 00 00 00	 call	 ?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
  00324	83 c4 08	 add	 esp, 8
$LN23@ButtonBeha:

; 524  :                 FocusWindow(window);

  00327	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  00330	83 c4 04	 add	 esp, 4
$LN19@ButtonBeha:

; 525  :             }
; 526  :             if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])

  00333	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00336	83 e0 08	 and	 eax, 8
  00339	74 48		 je	 SHORT $LN24@ButtonBeha
  0033b	b8 01 00 00 00	 mov	 eax, 1
  00340	6b c8 00	 imul	 ecx, eax, 0
  00343	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00346	0f b6 84 0a e2
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+994]
  0034e	85 c0		 test	 eax, eax
  00350	74 31		 je	 SHORT $LN24@ButtonBeha

; 527  :             {
; 528  :                 if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>

  00352	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00355	83 e0 01	 and	 eax, 1
  00358	74 20		 je	 SHORT $LN26@ButtonBeha
  0035a	b8 04 00 00 00	 mov	 eax, 4
  0035f	6b c8 00	 imul	 ecx, eax, 0
  00362	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00365	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00368	f3 0f 10 84 0a
	08 04 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1032]
  00371	0f 2f 80 8c 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+140]
  00378	73 04		 jae	 SHORT $LN25@ButtonBeha
$LN26@ButtonBeha:

; 529  :                     pressed = true;

  0037a	c6 45 cb 01	 mov	 BYTE PTR _pressed$[ebp], 1
$LN25@ButtonBeha:

; 530  :                 ClearActiveID();

  0037e	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN24@ButtonBeha:

; 531  :             }
; 532  : 
; 533  :             // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
; 534  :             // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
; 535  :             if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))

  00383	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00386	83 e0 01	 and	 eax, 1
  00389	74 42		 je	 SHORT $LN27@ButtonBeha
  0038b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0038e	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00394	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00397	75 34		 jne	 SHORT $LN27@ButtonBeha
  00399	b8 04 00 00 00	 mov	 eax, 4
  0039e	6b c8 00	 imul	 ecx, eax, 0
  003a1	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  003a4	f3 0f 10 84 0a
	f4 03 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+1012]
  003ad	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003b4	76 17		 jbe	 SHORT $LN27@ButtonBeha
  003b6	6a 01		 push	 1
  003b8	6a 00		 push	 0
  003ba	e8 00 00 00 00	 call	 ?IsMouseClicked@ImGui@@YA_NH_N@Z ; ImGui::IsMouseClicked
  003bf	83 c4 08	 add	 esp, 8
  003c2	0f b6 c0	 movzx	 eax, al
  003c5	85 c0		 test	 eax, eax
  003c7	74 04		 je	 SHORT $LN27@ButtonBeha

; 536  :                 pressed = true;

  003c9	c6 45 cb 01	 mov	 BYTE PTR _pressed$[ebp], 1
$LN27@ButtonBeha:

; 537  :         }
; 538  : 
; 539  :         if (pressed)

  003cd	0f b6 45 cb	 movzx	 eax, BYTE PTR _pressed$[ebp]
  003d1	85 c0		 test	 eax, eax
  003d3	74 0a		 je	 SHORT $LN28@ButtonBeha

; 540  :             g.NavDisableHighlight = true;

  003d5	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003d8	c6 80 32 1b 00
	00 01		 mov	 BYTE PTR [eax+6962], 1
$LN28@ButtonBeha:

; 541  :     }
; 542  : 
; 543  :     // Gamepad/Keyboard navigation
; 544  :     // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
; 545  :     if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))

  003df	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003e2	8b 88 d4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6868]
  003e8	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  003eb	75 55		 jne	 SHORT $LN31@ButtonBeha
  003ed	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003f0	0f b6 88 32 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6962]
  003f7	85 c9		 test	 ecx, ecx
  003f9	75 47		 jne	 SHORT $LN31@ButtonBeha
  003fb	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  003fe	0f b6 88 33 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6963]
  00405	85 c9		 test	 ecx, ecx
  00407	74 39		 je	 SHORT $LN31@ButtonBeha
  00409	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0040c	83 b8 e4 19 00
	00 00		 cmp	 DWORD PTR [eax+6628], 0
  00413	74 1f		 je	 SHORT $LN30@ButtonBeha
  00415	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00418	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0041e	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00421	74 11		 je	 SHORT $LN30@ButtonBeha
  00423	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00426	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  00429	8b 90 e4 19 00
	00		 mov	 edx, DWORD PTR [eax+6628]
  0042f	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00432	75 0e		 jne	 SHORT $LN31@ButtonBeha
$LN30@ButtonBeha:

; 546  :         if (!(flags & ImGuiButtonFlags_NoHoveredOnNav))

  00434	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00437	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0043c	75 04		 jne	 SHORT $LN31@ButtonBeha

; 547  :             hovered = true;

  0043e	c6 45 bf 01	 mov	 BYTE PTR _hovered$[ebp], 1
$LN31@ButtonBeha:

; 548  : 
; 549  :     if (g.NavActivateDownId == id)

  00442	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00445	8b 88 dc 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6876]
  0044b	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0044e	0f 85 d7 00 00
	00		 jne	 $LN37@ButtonBeha

; 550  :     {
; 551  :         bool nav_activated_by_code = (g.NavActivateId == id);

  00454	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00457	8b 88 d8 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6872]
  0045d	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  00460	75 0c		 jne	 SHORT $LN56@ButtonBeha
  00462	c7 85 a8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv274[ebp], 1
  0046c	eb 0a		 jmp	 SHORT $LN57@ButtonBeha
$LN56@ButtonBeha:
  0046e	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv274[ebp], 0
$LN57@ButtonBeha:
  00478	8a 95 a8 fe ff
	ff		 mov	 dl, BYTE PTR tv274[ebp]
  0047e	88 55 b3	 mov	 BYTE PTR _nav_activated_by_code$5[ebp], dl

; 552  :         bool nav_activated_by_inputs = IsNavInputTest(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);

  00481	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00484	83 e0 01	 and	 eax, 1
  00487	74 0c		 je	 SHORT $LN58@ButtonBeha
  00489	c7 85 a8 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv279[ebp], 3
  00493	eb 0a		 jmp	 SHORT $LN59@ButtonBeha
$LN58@ButtonBeha:
  00495	c7 85 a8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv279[ebp], 1
$LN59@ButtonBeha:
  0049f	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv279[ebp]
  004a5	51		 push	 ecx
  004a6	6a 00		 push	 0
  004a8	e8 00 00 00 00	 call	 ?IsNavInputTest@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ; ImGui::IsNavInputTest
  004ad	83 c4 08	 add	 esp, 8
  004b0	88 45 a7	 mov	 BYTE PTR _nav_activated_by_inputs$4[ebp], al

; 553  :         if (nav_activated_by_code || nav_activated_by_inputs)

  004b3	0f b6 45 b3	 movzx	 eax, BYTE PTR _nav_activated_by_code$5[ebp]
  004b7	85 c0		 test	 eax, eax
  004b9	75 08		 jne	 SHORT $LN34@ButtonBeha
  004bb	0f b6 45 a7	 movzx	 eax, BYTE PTR _nav_activated_by_inputs$4[ebp]
  004bf	85 c0		 test	 eax, eax
  004c1	74 04		 je	 SHORT $LN33@ButtonBeha
$LN34@ButtonBeha:

; 554  :             pressed = true;

  004c3	c6 45 cb 01	 mov	 BYTE PTR _pressed$[ebp], 1
$LN33@ButtonBeha:

; 555  :         if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)

  004c7	0f b6 45 b3	 movzx	 eax, BYTE PTR _nav_activated_by_code$5[ebp]
  004cb	85 c0		 test	 eax, eax
  004cd	75 16		 jne	 SHORT $LN36@ButtonBeha
  004cf	0f b6 45 a7	 movzx	 eax, BYTE PTR _nav_activated_by_inputs$4[ebp]
  004d3	85 c0		 test	 eax, eax
  004d5	75 0e		 jne	 SHORT $LN36@ButtonBeha
  004d7	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  004da	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  004e0	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  004e3	75 46		 jne	 SHORT $LN37@ButtonBeha
$LN36@ButtonBeha:

; 556  :         {
; 557  :             // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
; 558  :             g.NavActivateId = id; // This is so SetActiveId assign a Nav source

  004e5	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  004e8	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  004eb	89 88 d8 1a 00
	00		 mov	 DWORD PTR [eax+6872], ecx

; 559  :             SetActiveID(id, window);

  004f1	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  004f4	50		 push	 eax
  004f5	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  004f8	51		 push	 ecx
  004f9	e8 00 00 00 00	 call	 ?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
  004fe	83 c4 08	 add	 esp, 8

; 560  :             if ((nav_activated_by_code || nav_activated_by_inputs) && !(flags & ImGuiButtonFlags_NoNavFocus))

  00501	0f b6 45 b3	 movzx	 eax, BYTE PTR _nav_activated_by_code$5[ebp]
  00505	85 c0		 test	 eax, eax
  00507	75 08		 jne	 SHORT $LN38@ButtonBeha
  00509	0f b6 45 a7	 movzx	 eax, BYTE PTR _nav_activated_by_inputs$4[ebp]
  0050d	85 c0		 test	 eax, eax
  0050f	74 1a		 je	 SHORT $LN37@ButtonBeha
$LN38@ButtonBeha:
  00511	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00514	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00519	75 10		 jne	 SHORT $LN37@ButtonBeha

; 561  :                 SetFocusID(id, window);

  0051b	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0051e	50		 push	 eax
  0051f	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  00522	51		 push	 ecx
  00523	e8 00 00 00 00	 call	 ?SetFocusID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetFocusID
  00528	83 c4 08	 add	 esp, 8
$LN37@ButtonBeha:

; 562  :         }
; 563  :     }
; 564  : 
; 565  :     bool held = false;

  0052b	c6 45 9b 00	 mov	 BYTE PTR _held$[ebp], 0

; 566  :     if (g.ActiveId == id)

  0052f	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00532	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  00538	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0053b	0f 85 7e 01 00
	00		 jne	 $LN50@ButtonBeha

; 567  :     {
; 568  :         if (pressed)

  00541	0f b6 45 cb	 movzx	 eax, BYTE PTR _pressed$[ebp]
  00545	85 c0		 test	 eax, eax
  00547	74 0a		 je	 SHORT $LN40@ButtonBeha

; 569  :             g.ActiveIdHasBeenPressedBefore = true;

  00549	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0054c	c6 80 f2 19 00
	00 01		 mov	 BYTE PTR [eax+6642], 1
$LN40@ButtonBeha:

; 570  :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

  00553	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00556	83 b8 14 1a 00
	00 01		 cmp	 DWORD PTR [eax+6676], 1
  0055d	0f 85 3d 01 00
	00		 jne	 $LN41@ButtonBeha

; 571  :         {
; 572  :             if (g.ActiveIdIsJustActivated)

  00563	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00566	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  0056d	85 c9		 test	 ecx, ecx
  0056f	74 31		 je	 SHORT $LN43@ButtonBeha

; 573  :                 g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

  00571	8b 45 08	 mov	 eax, DWORD PTR _bb$[ebp]
  00574	50		 push	 eax
  00575	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00578	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  0057e	51		 push	 ecx
  0057f	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00585	52		 push	 edx
  00586	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  0058b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0058e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00590	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00593	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00596	89 88 08 1a 00
	00		 mov	 DWORD PTR [eax+6664], ecx
  0059c	89 90 0c 1a 00
	00		 mov	 DWORD PTR [eax+6668], edx
$LN43@ButtonBeha:

; 574  :             if (g.IO.MouseDown[0])

  005a2	b8 01 00 00 00	 mov	 eax, 1
  005a7	6b c8 00	 imul	 ecx, eax, 0
  005aa	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  005ad	0f b6 84 0a f0
	00 00 00	 movzx	 eax, BYTE PTR [edx+ecx+240]
  005b5	85 c0		 test	 eax, eax
  005b7	74 09		 je	 SHORT $LN44@ButtonBeha

; 575  :             {
; 576  :                 held = true;

  005b9	c6 45 9b 01	 mov	 BYTE PTR _held$[ebp], 1

; 577  :             }

  005bd	e9 c8 00 00 00	 jmp	 $LN45@ButtonBeha
$LN44@ButtonBeha:

; 578  :             else
; 579  :             {
; 580  :                 if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) && !g.DragDropActive)

  005c2	0f b6 45 bf	 movzx	 eax, BYTE PTR _hovered$[ebp]
  005c6	85 c0		 test	 eax, eax
  005c8	0f 84 b7 00 00
	00		 je	 $LN47@ButtonBeha
  005ce	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  005d1	83 e0 02	 and	 eax, 2
  005d4	0f 84 ab 00 00
	00		 je	 $LN47@ButtonBeha
  005da	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005dd	0f b6 88 34 1d
	00 00		 movzx	 ecx, BYTE PTR [eax+7476]
  005e4	85 c9		 test	 ecx, ecx
  005e6	0f 85 99 00 00
	00		 jne	 $LN47@ButtonBeha

; 581  :                 {
; 582  :                     bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDownWasDoubleClick[0];

  005ec	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  005ef	83 e0 10	 and	 eax, 16			; 00000010H
  005f2	74 23		 je	 SHORT $LN60@ButtonBeha
  005f4	b9 01 00 00 00	 mov	 ecx, 1
  005f9	6b d1 00	 imul	 edx, ecx, 0
  005fc	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  005ff	0f b6 8c 10 ec
	03 00 00	 movzx	 ecx, BYTE PTR [eax+edx+1004]
  00607	85 c9		 test	 ecx, ecx
  00609	74 0c		 je	 SHORT $LN60@ButtonBeha
  0060b	c7 85 a8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv343[ebp], 1
  00615	eb 0a		 jmp	 SHORT $LN61@ButtonBeha
$LN60@ButtonBeha:
  00617	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv343[ebp], 0
$LN61@ButtonBeha:
  00621	8a 95 a8 fe ff
	ff		 mov	 dl, BYTE PTR tv343[ebp]
  00627	88 55 8f	 mov	 BYTE PTR _is_double_click_release$3[ebp], dl

; 583  :                     bool is_repeating_already = (flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>

  0062a	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  0062d	83 e0 01	 and	 eax, 1
  00630	74 2c		 je	 SHORT $LN62@ButtonBeha
  00632	b9 04 00 00 00	 mov	 ecx, 4
  00637	6b d1 00	 imul	 edx, ecx, 0
  0063a	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0063d	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00640	f3 0f 10 84 10
	08 04 00 00	 movss	 xmm0, DWORD PTR [eax+edx+1032]
  00649	0f 2f 81 8c 00
	00 00		 comiss	 xmm0, DWORD PTR [ecx+140]
  00650	72 0c		 jb	 SHORT $LN62@ButtonBeha
  00652	c7 85 a8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv354[ebp], 1
  0065c	eb 0a		 jmp	 SHORT $LN63@ButtonBeha
$LN62@ButtonBeha:
  0065e	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv354[ebp], 0
$LN63@ButtonBeha:
  00668	8a 95 a8 fe ff
	ff		 mov	 dl, BYTE PTR tv354[ebp]
  0066e	88 55 83	 mov	 BYTE PTR _is_repeating_already$2[ebp], dl

; 584  :                     if (!is_double_click_release && !is_repeating_already)

  00671	0f b6 45 8f	 movzx	 eax, BYTE PTR _is_double_click_release$3[ebp]
  00675	85 c0		 test	 eax, eax
  00677	75 0c		 jne	 SHORT $LN47@ButtonBeha
  00679	0f b6 45 83	 movzx	 eax, BYTE PTR _is_repeating_already$2[ebp]
  0067d	85 c0		 test	 eax, eax
  0067f	75 04		 jne	 SHORT $LN47@ButtonBeha

; 585  :                         pressed = true;

  00681	c6 45 cb 01	 mov	 BYTE PTR _pressed$[ebp], 1
$LN47@ButtonBeha:

; 586  :                 }
; 587  :                 ClearActiveID();

  00685	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN45@ButtonBeha:

; 588  :             }
; 589  :             if (!(flags & ImGuiButtonFlags_NoNavFocus))

  0068a	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  0068d	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00692	75 0a		 jne	 SHORT $LN48@ButtonBeha

; 590  :                 g.NavDisableHighlight = true;

  00694	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00697	c6 80 32 1b 00
	00 01		 mov	 BYTE PTR [eax+6962], 1
$LN48@ButtonBeha:

; 591  :         }

  0069e	eb 1f		 jmp	 SHORT $LN50@ButtonBeha
$LN41@ButtonBeha:

; 592  :         else if (g.ActiveIdSource == ImGuiInputSource_Nav)

  006a0	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  006a3	83 b8 14 1a 00
	00 02		 cmp	 DWORD PTR [eax+6676], 2
  006aa	75 13		 jne	 SHORT $LN50@ButtonBeha

; 593  :         {
; 594  :             if (g.NavActivateDownId != id)

  006ac	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  006af	8b 88 dc 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6876]
  006b5	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  006b8	74 05		 je	 SHORT $LN50@ButtonBeha

; 595  :                 ClearActiveID();

  006ba	e8 00 00 00 00	 call	 ?ClearActiveID@ImGui@@YAXXZ ; ImGui::ClearActiveID
$LN50@ButtonBeha:

; 596  :         }
; 597  :     }
; 598  : 
; 599  :     if (out_hovered) *out_hovered = hovered;

  006bf	83 7d 10 00	 cmp	 DWORD PTR _out_hovered$[ebp], 0
  006c3	74 08		 je	 SHORT $LN51@ButtonBeha
  006c5	8b 45 10	 mov	 eax, DWORD PTR _out_hovered$[ebp]
  006c8	8a 4d bf	 mov	 cl, BYTE PTR _hovered$[ebp]
  006cb	88 08		 mov	 BYTE PTR [eax], cl
$LN51@ButtonBeha:

; 600  :     if (out_held) *out_held = held;

  006cd	83 7d 14 00	 cmp	 DWORD PTR _out_held$[ebp], 0
  006d1	74 08		 je	 SHORT $LN52@ButtonBeha
  006d3	8b 45 14	 mov	 eax, DWORD PTR _out_held$[ebp]
  006d6	8a 4d 9b	 mov	 cl, BYTE PTR _held$[ebp]
  006d9	88 08		 mov	 BYTE PTR [eax], cl
$LN52@ButtonBeha:

; 601  : 
; 602  :     return pressed;

  006db	8a 45 cb	 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@ButtonBeha:

; 603  : }

  006de	5f		 pop	 edi
  006df	5e		 pop	 esi
  006e0	5b		 pop	 ebx
  006e1	81 c4 58 01 00
	00		 add	 esp, 344		; 00000158H
  006e7	3b ec		 cmp	 ebp, esp
  006e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006ee	8b e5		 mov	 esp, ebp
  006f0	5d		 pop	 ebp
  006f1	c3		 ret	 0
?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ENDP	; ImGui::ButtonBehavior
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SeparatorEx@ImGui@@YAXH@Z
_TEXT	SEGMENT
tv196 = -500						; size = 4
$T1 = -492						; size = 8
$T2 = -476						; size = 8
$T3 = -460						; size = 8
$T4 = -444						; size = 8
$T5 = -428						; size = 8
$T6 = -412						; size = 8
$T7 = -396						; size = 8
$T8 = -380						; size = 8
$T9 = -364						; size = 8
_bb$10 = -156						; size = 16
_columns$11 = -132					; size = 4
_x2$12 = -120						; size = 4
_x1$13 = -108						; size = 4
_bb$14 = -96						; size = 16
_y2$15 = -72						; size = 4
_y1$16 = -60						; size = 4
_thickness_layout$ = -48				; size = 4
_thickness_draw$ = -36					; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_flags$ = 8						; size = 4
?SeparatorEx@ImGui@@YAXH@Z PROC				; ImGui::SeparatorEx, COMDAT

; 1222 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 01 00
	00		 sub	 esp, 500		; 000001f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-500]
  00012	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1223 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 1224 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN2@SeparatorE

; 1225 :         return;

  00045	e9 ea 03 00 00	 jmp	 $LN1@SeparatorE
$LN2@SeparatorE:

; 1226 : 
; 1227 :     ImGuiContext& g = *GImGui;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004f	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 1228 :     IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected

  00052	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00055	83 e0 03	 and	 eax, 3
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  0005e	83 c4 04	 add	 esp, 4
  00061	0f b6 c8	 movzx	 ecx, al
  00064	85 c9		 test	 ecx, ecx
  00066	75 26		 jne	 SHORT $LN15@SeparatorE
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SeparatorEx@ImGui@@YAXH@Z@4JA
  0006e	83 c2 06	 add	 edx, 6
  00071	8b f4		 mov	 esi, esp
  00073	52		 push	 edx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@FPPCKOP@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	3b f4		 cmp	 esi, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN15@SeparatorE:

; 1229 : 
; 1230 :     float thickness_draw = 1.0f;

  0008e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00096	f3 0f 11 45 dc	 movss	 DWORD PTR _thickness_draw$[ebp], xmm0

; 1231 :     float thickness_layout = 0.0f;

  0009b	0f 57 c0	 xorps	 xmm0, xmm0
  0009e	f3 0f 11 45 d0	 movss	 DWORD PTR _thickness_layout$[ebp], xmm0

; 1232 :     if (flags & ImGuiSeparatorFlags_Vertical)

  000a3	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  000a6	83 e0 02	 and	 eax, 2
  000a9	0f 84 73 01 00
	00		 je	 $LN3@SeparatorE

; 1233 :     {
; 1234 :         // Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.
; 1235 :         float y1 = window->DC.CursorPos.y;

  000af	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000b2	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  000ba	f3 0f 11 45 c4	 movss	 DWORD PTR _y1$16[ebp], xmm0

; 1236 :         float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;

  000bf	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000c2	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000c5	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  000cd	f3 0f 58 81 ec
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+236]
  000d5	f3 0f 11 45 b8	 movss	 DWORD PTR _y2$15[ebp], xmm0

; 1237 :         const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + thickness_draw, y2));

  000da	51		 push	 ecx
  000db	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _y2$15[ebp]
  000e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e5	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000e8	f3 0f 10 80 c8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+200]
  000f0	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _thickness_draw$[ebp]
  000f5	51		 push	 ecx
  000f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fb	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00101	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00106	50		 push	 eax
  00107	51		 push	 ecx
  00108	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _y1$16[ebp]
  0010d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00112	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00115	51		 push	 ecx
  00116	f3 0f 10 81 c8
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+200]
  0011e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00123	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00129	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0012e	50		 push	 eax
  0012f	8d 4d a0	 lea	 ecx, DWORD PTR _bb$14[ebp]
  00132	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1238 :         ItemSize(ImVec2(thickness_layout, 0.0f));

  00137	51		 push	 ecx
  00138	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00140	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00145	51		 push	 ecx
  00146	0f 57 c0	 xorps	 xmm0, xmm0
  00149	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014e	51		 push	 ecx
  0014f	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _thickness_layout$[ebp]
  00154	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00159	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0015f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  0016a	83 c4 08	 add	 esp, 8

; 1239 :         if (!ItemAdd(bb, 0))

  0016d	6a 00		 push	 0
  0016f	6a 00		 push	 0
  00171	8d 45 a0	 lea	 eax, DWORD PTR _bb$14[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017d	0f b6 c8	 movzx	 ecx, al
  00180	85 c9		 test	 ecx, ecx
  00182	75 05		 jne	 SHORT $LN5@SeparatorE

; 1240 :             return;

  00184	e9 ab 02 00 00	 jmp	 $LN1@SeparatorE
$LN5@SeparatorE:

; 1241 : 
; 1242 :         // Draw
; 1243 :         window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));

  00189	51		 push	 ecx
  0018a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00192	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00197	51		 push	 ecx
  00198	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a5	6a 1b		 push	 27			; 0000001bH
  001a7	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  001ac	83 c4 08	 add	 esp, 8
  001af	50		 push	 eax
  001b0	51		 push	 ecx
  001b1	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _bb$14[ebp+12]
  001b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bb	51		 push	 ecx
  001bc	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _bb$14[ebp]
  001c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c6	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  001cc	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001d1	50		 push	 eax
  001d2	51		 push	 ecx
  001d3	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _bb$14[ebp+4]
  001d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001dd	51		 push	 ecx
  001de	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _bb$14[ebp]
  001e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e8	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  001ee	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001f3	50		 push	 eax
  001f4	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  001f7	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  001fd	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 1244 :         if (g.LogEnabled)

  00202	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00205	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  0020c	85 c9		 test	 ecx, ecx
  0020e	74 0d		 je	 SHORT $LN6@SeparatorE

; 1245 :             LogText(" |");

  00210	68 00 00 00 00	 push	 OFFSET ??_C@_02LLHJFGPH@?5?$HM@
  00215	e8 00 00 00 00	 call	 ?LogText@ImGui@@YAXPBDZZ ; ImGui::LogText
  0021a	83 c4 04	 add	 esp, 4
$LN6@SeparatorE:

; 1246 :     }

  0021d	e9 12 02 00 00	 jmp	 $LN13@SeparatorE
$LN3@SeparatorE:

; 1247 :     else if (flags & ImGuiSeparatorFlags_Horizontal)

  00222	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00225	83 e0 01	 and	 eax, 1
  00228	0f 84 06 02 00
	00		 je	 $LN13@SeparatorE

; 1248 :     {
; 1249 :         // Horizontal Separator
; 1250 :         float x1 = window->Pos.x;

  0022e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00231	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00236	f3 0f 11 45 94	 movss	 DWORD PTR _x1$13[ebp], xmm0

; 1251 :         float x2 = window->Pos.x + window->Size.x;

  0023b	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0023e	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00241	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00246	f3 0f 58 41 14	 addss	 xmm0, DWORD PTR [ecx+20]
  0024b	f3 0f 11 45 88	 movss	 DWORD PTR _x2$12[ebp], xmm0

; 1252 :         if (!window->DC.GroupStack.empty())

  00250	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00253	81 c1 9c 01 00
	00		 add	 ecx, 412		; 0000019cH
  00259	e8 00 00 00 00	 call	 ?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ ; ImVector<ImGuiGroupData>::empty
  0025e	0f b6 c0	 movzx	 eax, al
  00261	85 c0		 test	 eax, eax
  00263	75 15		 jne	 SHORT $LN8@SeparatorE

; 1253 :             x1 += window->DC.Indent.x;

  00265	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00268	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  0026d	f3 0f 58 80 b4
	01 00 00	 addss	 xmm0, DWORD PTR [eax+436]
  00275	f3 0f 11 45 94	 movss	 DWORD PTR _x1$13[ebp], xmm0
$LN8@SeparatorE:

; 1254 : 
; 1255 :         ImGuiColumns* columns = (flags & ImGuiSeparatorFlags_SpanAllColumns) ? window->DC.CurrentColumns : NULL;

  0027a	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  0027d	83 e0 04	 and	 eax, 4
  00280	74 11		 je	 SHORT $LN16@SeparatorE
  00282	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00285	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [ecx+448]
  0028b	89 95 0c fe ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  00291	eb 0a		 jmp	 SHORT $LN17@SeparatorE
$LN16@SeparatorE:
  00293	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv196[ebp], 0
$LN17@SeparatorE:
  0029d	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002a3	89 85 7c ff ff
	ff		 mov	 DWORD PTR _columns$11[ebp], eax

; 1256 :         if (columns)

  002a9	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _columns$11[ebp], 0
  002b0	74 05		 je	 SHORT $LN9@SeparatorE

; 1257 :             PushColumnsBackground();

  002b2	e8 00 00 00 00	 call	 ?PushColumnsBackground@ImGui@@YAXXZ ; ImGui::PushColumnsBackground
$LN9@SeparatorE:

; 1258 : 
; 1259 :         // We don't provide our width to the layout so that it doesn't get feed back into AutoFit
; 1260 :         const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + thickness_draw));

  002b7	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002ba	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  002c2	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _thickness_draw$[ebp]
  002c7	51		 push	 ecx
  002c8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002cd	51		 push	 ecx
  002ce	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _x2$12[ebp]
  002d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d8	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  002de	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002e3	50		 push	 eax
  002e4	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  002e7	51		 push	 ecx
  002e8	f3 0f 10 81 cc
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+204]
  002f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f5	51		 push	 ecx
  002f6	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  002fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00300	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00306	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0030b	50		 push	 eax
  0030c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$10[ebp]
  00312	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1261 :         ItemSize(ImVec2(0.0f, thickness_layout));

  00317	51		 push	 ecx
  00318	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00320	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00325	51		 push	 ecx
  00326	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _thickness_layout$[ebp]
  0032b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00330	51		 push	 ecx
  00331	0f 57 c0	 xorps	 xmm0, xmm0
  00334	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00339	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0033f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00344	50		 push	 eax
  00345	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  0034a	83 c4 08	 add	 esp, 8

; 1262 :         if (!ItemAdd(bb, 0))

  0034d	6a 00		 push	 0
  0034f	6a 00		 push	 0
  00351	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _bb$10[ebp]
  00357	50		 push	 eax
  00358	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0035d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00360	0f b6 c8	 movzx	 ecx, al
  00363	85 c9		 test	 ecx, ecx
  00365	75 25		 jne	 SHORT $LN10@SeparatorE

; 1263 :         {
; 1264 :             if (columns)

  00367	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _columns$11[ebp], 0
  0036e	74 17		 je	 SHORT $LN11@SeparatorE

; 1265 :             {
; 1266 :                 PopColumnsBackground();

  00370	e8 00 00 00 00	 call	 ?PopColumnsBackground@ImGui@@YAXXZ ; ImGui::PopColumnsBackground

; 1267 :                 columns->LineMinY = window->DC.CursorPos.y;

  00375	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _columns$11[ebp]
  0037b	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0037e	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  00384	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN11@SeparatorE:

; 1268 :             }
; 1269 :             return;

  00387	e9 a8 00 00 00	 jmp	 $LN1@SeparatorE
$LN10@SeparatorE:

; 1270 :         }
; 1271 : 
; 1272 :         // Draw
; 1273 :         window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x, bb.Min.y), GetColorU32(ImGuiCol_Separator));

  0038c	51		 push	 ecx
  0038d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00395	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039a	51		 push	 ecx
  0039b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a8	6a 1b		 push	 27			; 0000001bH
  003aa	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  003af	83 c4 08	 add	 esp, 8
  003b2	50		 push	 eax
  003b3	51		 push	 ecx
  003b4	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$10[ebp+4]
  003bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c1	51		 push	 ecx
  003c2	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$10[ebp+8]
  003ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cf	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  003d5	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003da	50		 push	 eax
  003db	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _bb$10[ebp]
  003e1	50		 push	 eax
  003e2	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  003e5	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  003eb	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 1274 :         if (g.LogEnabled)

  003f0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  003f3	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  003fa	85 c9		 test	 ecx, ecx
  003fc	74 16		 je	 SHORT $LN12@SeparatorE

; 1275 :             LogRenderedText(&bb.Min, "--------------------------------");

  003fe	6a 00		 push	 0
  00400	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GNHPAIID@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
  00405	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _bb$10[ebp]
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z ; ImGui::LogRenderedText
  00411	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@SeparatorE:

; 1276 : 
; 1277 :         if (columns)

  00414	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _columns$11[ebp], 0
  0041b	74 17		 je	 SHORT $LN13@SeparatorE

; 1278 :         {
; 1279 :             PopColumnsBackground();

  0041d	e8 00 00 00 00	 call	 ?PopColumnsBackground@ImGui@@YAXXZ ; ImGui::PopColumnsBackground

; 1280 :             columns->LineMinY = window->DC.CursorPos.y;

  00422	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _columns$11[ebp]
  00428	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0042b	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  00431	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN13@SeparatorE:
$LN1@SeparatorE:

; 1281 :         }
; 1282 :     }
; 1283 : }

  00434	52		 push	 edx
  00435	8b cd		 mov	 ecx, ebp
  00437	50		 push	 eax
  00438	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@SeparatorE
  0043e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00443	58		 pop	 eax
  00444	5a		 pop	 edx
  00445	5f		 pop	 edi
  00446	5e		 pop	 esi
  00447	5b		 pop	 ebx
  00448	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044b	33 cd		 xor	 ecx, ebp
  0044d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00452	81 c4 f4 01 00
	00		 add	 esp, 500		; 000001f4H
  00458	3b ec		 cmp	 ebp, esp
  0045a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0045f	8b e5		 mov	 esp, ebp
  00461	5d		 pop	 ebp
  00462	c3		 ret	 0
  00463	90		 npad	 1
$LN21@SeparatorE:
  00464	02 00 00 00	 DD	 2
  00468	00 00 00 00	 DD	 $LN20@SeparatorE
$LN20@SeparatorE:
  0046c	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00470	10 00 00 00	 DD	 16			; 00000010H
  00474	00 00 00 00	 DD	 $LN18@SeparatorE
  00478	64 ff ff ff	 DD	 -156			; ffffff64H
  0047c	10 00 00 00	 DD	 16			; 00000010H
  00480	00 00 00 00	 DD	 $LN19@SeparatorE
$LN19@SeparatorE:
  00484	62		 DB	 98			; 00000062H
  00485	62		 DB	 98			; 00000062H
  00486	00		 DB	 0
$LN18@SeparatorE:
  00487	62		 DB	 98			; 00000062H
  00488	62		 DB	 98			; 00000062H
  00489	00		 DB	 0
?SeparatorEx@ImGui@@YAXH@Z ENDP				; ImGui::SeparatorEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetWindowScrollbarID@ImGui@@YAIPAUImGuiWindow@@W4ImGuiAxis@@@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_window$ = 8						; size = 4
_axis$ = 12						; size = 4
?GetWindowScrollbarID@ImGui@@YAIPAUImGuiWindow@@W4ImGuiAxis@@@Z PROC ; ImGui::GetWindowScrollbarID, COMDAT

; 778  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 779  :     return window->GetIDNoKeepAlive(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");

  00028	83 7d 0c 00	 cmp	 DWORD PTR _axis$[ebp], 0
  0002c	75 0c		 jne	 SHORT $LN3@GetWindowS
  0002e	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], OFFSET ??_C@_08ENAFOMOP@?$CDSCROLLX@
  00038	eb 0a		 jmp	 SHORT $LN4@GetWindowS
$LN3@GetWindowS:
  0003a	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], OFFSET ??_C@_08FEBONNKO@?$CDSCROLLY@
$LN4@GetWindowS:
  00044	6a 00		 push	 0
  00046	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _window$[ebp]
  00050	e8 00 00 00 00	 call	 ?GetIDNoKeepAlive@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetIDNoKeepAlive

; 780  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?GetWindowScrollbarID@ImGui@@YAIPAUImGuiWindow@@W4ImGuiAxis@@@Z ENDP ; ImGui::GetWindowScrollbarID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z
_TEXT	SEGMENT
tv462 = -592						; size = 4
tv314 = -592						; size = 4
tv625 = -588						; size = 4
tv589 = -588						; size = 4
tv478 = -588						; size = 4
tv452 = -588						; size = 4
tv317 = -588						; size = 4
tv263 = -588						; size = 4
tv219 = -588						; size = 4
tv210 = -588						; size = 4
tv164 = -588						; size = 4
tv128 = -585						; size = 1
tv94 = -585						; size = 1
$T1 = -580						; size = 16
$T2 = -556						; size = 16
$T3 = -532						; size = 8
_grab_rect$ = -324					; size = 16
_grab_col$ = -300					; size = 4
_scroll_v_norm$4 = -288					; size = 4
_seek_absolute$5 = -273					; size = 1
_clicked_v_norm$6 = -264				; size = 4
_mouse_pos_v$7 = -252					; size = 4
_scrollbar_pos_v$8 = -240				; size = 4
_grab_v_norm$ = -228					; size = 4
_scroll_ratio$ = -216					; size = 4
_scroll_max$ = -204					; size = 4
_hovered$ = -189					; size = 1
_held$ = -177						; size = 1
_grab_h_norm$ = -168					; size = 4
_grab_h_pixels$ = -156					; size = 4
_win_size_v$ = -144					; size = 4
_scrollbar_size_v$ = -132				; size = 4
_bb$ = -120						; size = 16
_horizontal$ = -93					; size = 1
_allow_interaction$ = -81				; size = 1
_style$ = -72						; size = 4
_alpha$ = -60						; size = 4
_bb_frame_height$ = -48					; size = 4
_bb_frame_width$ = -36					; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_bb_frame$ = 8						; size = 4
_id$ = 12						; size = 4
_axis$ = 16						; size = 4
_p_scroll_v$ = 20					; size = 4
_size_avail_v$ = 24					; size = 4
_size_contents_v$ = 28					; size = 4
_rounding_corners$ = 32					; size = 4
?ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z PROC ; ImGui::ScrollbarEx, COMDAT

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-592]
  00012	b9 94 00 00 00	 mov	 ecx, 148		; 00000094H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 790  :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 791  :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 792  :     if (window->SkipItems)

  00046	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00049	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 07		 je	 SHORT $LN2@ScrollbarE

; 793  :         return false;

  00051	32 c0		 xor	 al, al
  00053	e9 b6 08 00 00	 jmp	 $LN1@ScrollbarE
$LN2@ScrollbarE:

; 794  : 
; 795  :     const float bb_frame_width = bb_frame.GetWidth();

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _bb_frame$[ebp]
  0005b	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  00060	d9 5d dc	 fstp	 DWORD PTR _bb_frame_width$[ebp]

; 796  :     const float bb_frame_height = bb_frame.GetHeight();

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _bb_frame$[ebp]
  00066	e8 00 00 00 00	 call	 ?GetHeight@ImRect@@QBEMXZ ; ImRect::GetHeight
  0006b	d9 5d d0	 fstp	 DWORD PTR _bb_frame_height$[ebp]

; 797  :     if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)

  0006e	0f 57 c0	 xorps	 xmm0, xmm0
  00071	0f 2f 45 dc	 comiss	 xmm0, DWORD PTR _bb_frame_width$[ebp]
  00075	73 09		 jae	 SHORT $LN4@ScrollbarE
  00077	0f 57 c0	 xorps	 xmm0, xmm0
  0007a	0f 2f 45 d0	 comiss	 xmm0, DWORD PTR _bb_frame_height$[ebp]
  0007e	72 07		 jb	 SHORT $LN3@ScrollbarE
$LN4@ScrollbarE:

; 798  :         return false;

  00080	32 c0		 xor	 al, al
  00082	e9 87 08 00 00	 jmp	 $LN1@ScrollbarE
$LN3@ScrollbarE:

; 799  : 
; 800  :     // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the resize grab)
; 801  :     float alpha = 1.0f;

  00087	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008f	f3 0f 11 45 c4	 movss	 DWORD PTR _alpha$[ebp], xmm0

; 802  :     if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)

  00094	83 7d 10 01	 cmp	 DWORD PTR _axis$[ebp], 1
  00098	75 5c		 jne	 SHORT $LN5@ScrollbarE
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0009d	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  000a5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  000b0	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  000b8	0f 2f 45 d0	 comiss	 xmm0, DWORD PTR _bb_frame_height$[ebp]
  000bc	76 38		 jbe	 SHORT $LN5@ScrollbarE

; 803  :         alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));

  000be	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000c1	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _bb_frame_height$[ebp]
  000c6	f3 0f 5c 80 c4
	18 00 00	 subss	 xmm0, DWORD PTR [eax+6340]
  000ce	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  000d1	f3 0f 10 89 4c
	15 00 00	 movss	 xmm1, DWORD PTR [ecx+5452]
  000d9	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  000e1	f3 0f 5e c1	 divss	 xmm0, xmm1
  000e5	51		 push	 ecx
  000e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000eb	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  000f0	83 c4 04	 add	 esp, 4
  000f3	d9 5d c4	 fstp	 DWORD PTR _alpha$[ebp]
$LN5@ScrollbarE:

; 804  :     if (alpha <= 0.0f)

  000f6	0f 57 c0	 xorps	 xmm0, xmm0
  000f9	0f 2f 45 c4	 comiss	 xmm0, DWORD PTR _alpha$[ebp]
  000fd	72 07		 jb	 SHORT $LN6@ScrollbarE

; 805  :         return false;

  000ff	32 c0		 xor	 al, al
  00101	e9 08 08 00 00	 jmp	 $LN1@ScrollbarE
$LN6@ScrollbarE:

; 806  : 
; 807  :     const ImGuiStyle& style = g.Style;

  00106	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00109	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0010e	89 45 b8	 mov	 DWORD PTR _style$[ebp], eax

; 808  :     const bool allow_interaction = (alpha >= 1.0f);

  00111	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _alpha$[ebp]
  00116	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0011d	72 09		 jb	 SHORT $LN15@ScrollbarE
  0011f	c6 85 b7 fd ff
	ff 01		 mov	 BYTE PTR tv94[ebp], 1
  00126	eb 07		 jmp	 SHORT $LN16@ScrollbarE
$LN15@ScrollbarE:
  00128	c6 85 b7 fd ff
	ff 00		 mov	 BYTE PTR tv94[ebp], 0
$LN16@ScrollbarE:
  0012f	8a 85 b7 fd ff
	ff		 mov	 al, BYTE PTR tv94[ebp]
  00135	88 45 af	 mov	 BYTE PTR _allow_interaction$[ebp], al

; 809  :     const bool horizontal = (axis == ImGuiAxis_X);

  00138	83 7d 10 00	 cmp	 DWORD PTR _axis$[ebp], 0
  0013c	75 09		 jne	 SHORT $LN17@ScrollbarE
  0013e	c6 85 b7 fd ff
	ff 01		 mov	 BYTE PTR tv128[ebp], 1
  00145	eb 07		 jmp	 SHORT $LN18@ScrollbarE
$LN17@ScrollbarE:
  00147	c6 85 b7 fd ff
	ff 00		 mov	 BYTE PTR tv128[ebp], 0
$LN18@ScrollbarE:
  0014e	8a 85 b7 fd ff
	ff		 mov	 al, BYTE PTR tv128[ebp]
  00154	88 45 a3	 mov	 BYTE PTR _horizontal$[ebp], al

; 810  : 
; 811  :     ImRect bb = bb_frame;

  00157	8b 45 08	 mov	 eax, DWORD PTR _bb_frame$[ebp]
  0015a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015c	89 4d 88	 mov	 DWORD PTR _bb$[ebp], ecx
  0015f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00162	89 55 8c	 mov	 DWORD PTR _bb$[ebp+4], edx
  00165	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00168	89 4d 90	 mov	 DWORD PTR _bb$[ebp+8], ecx
  0016b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0016e	89 55 94	 mov	 DWORD PTR _bb$[ebp+12], edx

; 812  :     bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

  00171	51		 push	 ecx
  00172	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  0017a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017f	51		 push	 ecx
  00180	0f 57 c0	 xorps	 xmm0, xmm0
  00183	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00188	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _bb_frame_height$[ebp]
  0018d	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00195	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0019d	f3 0f 2c c0	 cvttss2si eax, xmm0
  001a1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001a5	51		 push	 ecx
  001a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ab	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b3	d9 9d b4 fd ff
	ff		 fstp	 DWORD PTR tv452[ebp]
  001b9	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR tv452[ebp]
  001c1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001c8	51		 push	 ecx
  001c9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ce	51		 push	 ecx
  001cf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  001d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001dc	51		 push	 ecx
  001dd	0f 57 c0	 xorps	 xmm0, xmm0
  001e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e5	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _bb_frame_width$[ebp]
  001ea	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  001f2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001fa	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001fe	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00202	51		 push	 ecx
  00203	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00208	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  0020d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00210	d9 9d b0 fd ff
	ff		 fstp	 DWORD PTR tv462[ebp]
  00216	f3 0f 10 85 b0
	fd ff ff	 movss	 xmm0, DWORD PTR tv462[ebp]
  0021e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00225	51		 push	 ecx
  00226	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022b	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00231	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00236	50		 push	 eax
  00237	8d 4d 88	 lea	 ecx, DWORD PTR _bb$[ebp]
  0023a	e8 00 00 00 00	 call	 ?Expand@ImRect@@QAEXABUImVec2@@@Z ; ImRect::Expand

; 813  : 
; 814  :     // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
; 815  :     const float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();

  0023f	0f b6 45 a3	 movzx	 eax, BYTE PTR _horizontal$[ebp]
  00243	85 c0		 test	 eax, eax
  00245	74 10		 je	 SHORT $LN19@ScrollbarE
  00247	8d 4d 88	 lea	 ecx, DWORD PTR _bb$[ebp]
  0024a	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  0024f	d9 9d b4 fd ff
	ff		 fstp	 DWORD PTR tv164[ebp]
  00255	eb 0e		 jmp	 SHORT $LN20@ScrollbarE
$LN19@ScrollbarE:
  00257	8d 4d 88	 lea	 ecx, DWORD PTR _bb$[ebp]
  0025a	e8 00 00 00 00	 call	 ?GetHeight@ImRect@@QBEMXZ ; ImRect::GetHeight
  0025f	d9 9d b4 fd ff
	ff		 fstp	 DWORD PTR tv164[ebp]
$LN20@ScrollbarE:
  00265	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR tv164[ebp]
  0026d	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _scrollbar_size_v$[ebp], xmm0

; 816  : 
; 817  :     // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
; 818  :     // But we maintain a minimum size in pixel to allow for the user to still aim inside.
; 819  :     IM_ASSERT(ImMax(size_contents_v, size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.

  00275	51		 push	 ecx
  00276	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _size_avail_v$[ebp]
  0027b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00280	51		 push	 ecx
  00281	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _size_contents_v$[ebp]
  00286	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028b	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00290	83 c4 08	 add	 esp, 8
  00293	d9 9d b4 fd ff
	ff		 fstp	 DWORD PTR tv478[ebp]
  00299	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR tv478[ebp]
  002a1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002a8	77 25		 ja	 SHORT $LN21@ScrollbarE
  002aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z@4JA
  002af	83 c0 1e	 add	 eax, 30			; 0000001eH
  002b2	8b f4		 mov	 esi, esp
  002b4	50		 push	 eax
  002b5	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  002ba	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@OFJDJLOI@?$AAI?$AAm?$AAM?$AAa?$AAx?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAc?$AAo?$AAn?$AAt@
  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  002c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c8	3b f4		 cmp	 esi, esp
  002ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@ScrollbarE:

; 820  :     const float win_size_v = ImMax(ImMax(size_contents_v, size_avail_v), 1.0f);

  002cf	51		 push	 ecx
  002d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002dd	51		 push	 ecx
  002de	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _size_avail_v$[ebp]
  002e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e8	51		 push	 ecx
  002e9	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _size_contents_v$[ebp]
  002ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002f8	83 c4 04	 add	 esp, 4
  002fb	d9 1c 24	 fstp	 DWORD PTR [esp]
  002fe	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00303	83 c4 08	 add	 esp, 8
  00306	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _win_size_v$[ebp]

; 821  :     const float grab_h_pixels = ImClamp(scrollbar_size_v * (size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);

  0030c	51		 push	 ecx
  0030d	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  00315	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0031a	8b 45 b8	 mov	 eax, DWORD PTR _style$[ebp]
  0031d	51		 push	 ecx
  0031e	f3 0f 10 40 70	 movss	 xmm0, DWORD PTR [eax+112]
  00323	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00328	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _size_avail_v$[ebp]
  0032d	f3 0f 5e 85 70
	ff ff ff	 divss	 xmm0, DWORD PTR _win_size_v$[ebp]
  00335	f3 0f 59 85 7c
	ff ff ff	 mulss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  0033d	51		 push	 ecx
  0033e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00343	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  00348	83 c4 0c	 add	 esp, 12			; 0000000cH
  0034b	d9 9d 64 ff ff
	ff		 fstp	 DWORD PTR _grab_h_pixels$[ebp]

; 822  :     const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

  00351	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_h_pixels$[ebp]
  00359	f3 0f 5e 85 7c
	ff ff ff	 divss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  00361	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _grab_h_norm$[ebp], xmm0

; 823  : 
; 824  :     // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
; 825  :     bool held = false;

  00369	c6 85 4f ff ff
	ff 00		 mov	 BYTE PTR _held$[ebp], 0

; 826  :     bool hovered = false;

  00370	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _hovered$[ebp], 0

; 827  :     ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

  00377	68 00 20 00 00	 push	 8192			; 00002000H
  0037c	8d 85 4f ff ff
	ff		 lea	 eax, DWORD PTR _held$[ebp]
  00382	50		 push	 eax
  00383	8d 8d 43 ff ff
	ff		 lea	 ecx, DWORD PTR _hovered$[ebp]
  00389	51		 push	 ecx
  0038a	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  0038d	52		 push	 edx
  0038e	8d 45 88	 lea	 eax, DWORD PTR _bb$[ebp]
  00391	50		 push	 eax
  00392	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  00397	83 c4 14	 add	 esp, 20			; 00000014H

; 828  : 
; 829  :     float scroll_max = ImMax(1.0f, size_contents_v - size_avail_v);

  0039a	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _size_contents_v$[ebp]
  0039f	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _size_avail_v$[ebp]
  003a4	51		 push	 ecx
  003a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003aa	51		 push	 ecx
  003ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b8	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  003bd	83 c4 08	 add	 esp, 8
  003c0	d9 9d 34 ff ff
	ff		 fstp	 DWORD PTR _scroll_max$[ebp]

; 830  :     float scroll_ratio = ImSaturate(*p_scroll_v / scroll_max);

  003c6	8b 45 14	 mov	 eax, DWORD PTR _p_scroll_v$[ebp]
  003c9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003cd	f3 0f 5e 85 34
	ff ff ff	 divss	 xmm0, DWORD PTR _scroll_max$[ebp]
  003d5	51		 push	 ecx
  003d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003db	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  003e0	83 c4 04	 add	 esp, 4
  003e3	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _scroll_ratio$[ebp]

; 831  :     float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

  003e9	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  003f1	f3 0f 5c 85 64
	ff ff ff	 subss	 xmm0, DWORD PTR _grab_h_pixels$[ebp]
  003f9	f3 0f 59 85 28
	ff ff ff	 mulss	 xmm0, DWORD PTR _scroll_ratio$[ebp]
  00401	f3 0f 5e 85 7c
	ff ff ff	 divss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  00409	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _grab_v_norm$[ebp], xmm0

; 832  :     if (held && allow_interaction && grab_h_norm < 1.0f)

  00411	0f b6 85 4f ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  00418	85 c0		 test	 eax, eax
  0041a	0f 84 7b 02 00
	00		 je	 $LN11@ScrollbarE
  00420	0f b6 45 af	 movzx	 eax, BYTE PTR _allow_interaction$[ebp]
  00424	85 c0		 test	 eax, eax
  00426	0f 84 6f 02 00
	00		 je	 $LN11@ScrollbarE
  0042c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00434	0f 2f 85 58 ff
	ff ff		 comiss	 xmm0, DWORD PTR _grab_h_norm$[ebp]
  0043b	0f 86 5a 02 00
	00		 jbe	 $LN11@ScrollbarE

; 833  :     {
; 834  :         float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;

  00441	0f b6 45 a3	 movzx	 eax, BYTE PTR _horizontal$[ebp]
  00445	85 c0		 test	 eax, eax
  00447	74 0f		 je	 SHORT $LN22@ScrollbarE
  00449	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _bb$[ebp]
  0044e	f3 0f 11 85 b4
	fd ff ff	 movss	 DWORD PTR tv210[ebp], xmm0
  00456	eb 0d		 jmp	 SHORT $LN23@ScrollbarE
$LN22@ScrollbarE:
  00458	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _bb$[ebp+4]
  0045d	f3 0f 11 85 b4
	fd ff ff	 movss	 DWORD PTR tv210[ebp], xmm0
$LN23@ScrollbarE:
  00465	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR tv210[ebp]
  0046d	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _scrollbar_pos_v$8[ebp], xmm0

; 835  :         float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;

  00475	0f b6 45 a3	 movzx	 eax, BYTE PTR _horizontal$[ebp]
  00479	85 c0		 test	 eax, eax
  0047b	74 15		 je	 SHORT $LN24@ScrollbarE
  0047d	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00480	f3 0f 10 81 e8
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+232]
  00488	f3 0f 11 85 b4
	fd ff ff	 movss	 DWORD PTR tv219[ebp], xmm0
  00490	eb 13		 jmp	 SHORT $LN25@ScrollbarE
$LN24@ScrollbarE:
  00492	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00495	f3 0f 10 82 ec
	00 00 00	 movss	 xmm0, DWORD PTR [edx+236]
  0049d	f3 0f 11 85 b4
	fd ff ff	 movss	 DWORD PTR tv219[ebp], xmm0
$LN25@ScrollbarE:
  004a5	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR tv219[ebp]
  004ad	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _mouse_pos_v$7[ebp], xmm0

; 836  : 
; 837  :         // Click position in scrollbar normalized space (0.0f->1.0f)
; 838  :         const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);

  004b5	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _mouse_pos_v$7[ebp]
  004bd	f3 0f 5c 85 10
	ff ff ff	 subss	 xmm0, DWORD PTR _scrollbar_pos_v$8[ebp]
  004c5	f3 0f 5e 85 7c
	ff ff ff	 divss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  004cd	51		 push	 ecx
  004ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d3	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  004d8	83 c4 04	 add	 esp, 4
  004db	d9 9d f8 fe ff
	ff		 fstp	 DWORD PTR _clicked_v_norm$6[ebp]

; 839  :         SetHoveredID(id);

  004e1	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  004e4	50		 push	 eax
  004e5	e8 00 00 00 00	 call	 ?SetHoveredID@ImGui@@YAXI@Z ; ImGui::SetHoveredID
  004ea	83 c4 04	 add	 esp, 4

; 840  : 
; 841  :         bool seek_absolute = false;

  004ed	c6 85 ef fe ff
	ff 00		 mov	 BYTE PTR _seek_absolute$5[ebp], 0

; 842  :         if (g.ActiveIdIsJustActivated)

  004f4	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  004f7	0f b6 88 f0 19
	00 00		 movzx	 ecx, BYTE PTR [eax+6640]
  004fe	85 c9		 test	 ecx, ecx
  00500	0f 84 9a 00 00
	00		 je	 $LN10@ScrollbarE

; 843  :         {
; 844  :             // On initial click calculate the distance between mouse and the center of the grab
; 845  :             seek_absolute = (clicked_v_norm < grab_v_norm || clicked_v_norm > grab_v_norm + grab_h_norm);

  00506	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  0050e	0f 2f 85 f8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _clicked_v_norm$6[ebp]
  00515	77 29		 ja	 SHORT $LN26@ScrollbarE
  00517	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  0051f	f3 0f 58 85 58
	ff ff ff	 addss	 xmm0, DWORD PTR _grab_h_norm$[ebp]
  00527	f3 0f 10 8d f8
	fe ff ff	 movss	 xmm1, DWORD PTR _clicked_v_norm$6[ebp]
  0052f	0f 2f c8	 comiss	 xmm1, xmm0
  00532	77 0c		 ja	 SHORT $LN26@ScrollbarE
  00534	c7 85 b4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv263[ebp], 0
  0053e	eb 0a		 jmp	 SHORT $LN27@ScrollbarE
$LN26@ScrollbarE:
  00540	c7 85 b4 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv263[ebp], 1
$LN27@ScrollbarE:
  0054a	8a 85 b4 fd ff
	ff		 mov	 al, BYTE PTR tv263[ebp]
  00550	88 85 ef fe ff
	ff		 mov	 BYTE PTR _seek_absolute$5[ebp], al

; 846  :             if (seek_absolute)

  00556	0f b6 85 ef fe
	ff ff		 movzx	 eax, BYTE PTR _seek_absolute$5[ebp]
  0055d	85 c0		 test	 eax, eax
  0055f	74 10		 je	 SHORT $LN9@ScrollbarE

; 847  :                 g.ScrollbarClickDeltaToGrabCenter = 0.0f;

  00561	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00564	0f 57 c0	 xorps	 xmm0, xmm0
  00567	f3 0f 11 80 04
	2d 00 00	 movss	 DWORD PTR [eax+11524], xmm0
  0056f	eb 2f		 jmp	 SHORT $LN10@ScrollbarE
$LN9@ScrollbarE:

; 848  :             else
; 849  :                 g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;

  00571	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _clicked_v_norm$6[ebp]
  00579	f3 0f 5c 85 1c
	ff ff ff	 subss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  00581	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _grab_h_norm$[ebp]
  00589	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  00591	f3 0f 5c c1	 subss	 xmm0, xmm1
  00595	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00598	f3 0f 11 80 04
	2d 00 00	 movss	 DWORD PTR [eax+11524], xmm0
$LN10@ScrollbarE:

; 850  :         }
; 851  : 
; 852  :         // Apply scroll
; 853  :         // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
; 854  :         const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));

  005a0	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  005a3	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _clicked_v_norm$6[ebp]
  005ab	f3 0f 5c 80 04
	2d 00 00	 subss	 xmm0, DWORD PTR [eax+11524]
  005b3	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _grab_h_norm$[ebp]
  005bb	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  005c3	f3 0f 5c c1	 subss	 xmm0, xmm1
  005c7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  005cf	f3 0f 5c 8d 58
	ff ff ff	 subss	 xmm1, DWORD PTR _grab_h_norm$[ebp]
  005d7	f3 0f 5e c1	 divss	 xmm0, xmm1
  005db	51		 push	 ecx
  005dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005e1	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  005e6	83 c4 04	 add	 esp, 4
  005e9	d9 9d e0 fe ff
	ff		 fstp	 DWORD PTR _scroll_v_norm$4[ebp]

; 855  :         *p_scroll_v = IM_ROUND(scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));

  005ef	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _scroll_v_norm$4[ebp]
  005f7	f3 0f 59 85 34
	ff ff ff	 mulss	 xmm0, DWORD PTR _scroll_max$[ebp]
  005ff	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00607	f3 0f 2c c0	 cvttss2si eax, xmm0
  0060b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0060f	8b 4d 14	 mov	 ecx, DWORD PTR _p_scroll_v$[ebp]
  00612	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 856  : 
; 857  :         // Update values for rendering
; 858  :         scroll_ratio = ImSaturate(*p_scroll_v / scroll_max);

  00616	8b 45 14	 mov	 eax, DWORD PTR _p_scroll_v$[ebp]
  00619	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0061d	f3 0f 5e 85 34
	ff ff ff	 divss	 xmm0, DWORD PTR _scroll_max$[ebp]
  00625	51		 push	 ecx
  00626	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0062b	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00630	83 c4 04	 add	 esp, 4
  00633	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _scroll_ratio$[ebp]

; 859  :         grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

  00639	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  00641	f3 0f 5c 85 64
	ff ff ff	 subss	 xmm0, DWORD PTR _grab_h_pixels$[ebp]
  00649	f3 0f 59 85 28
	ff ff ff	 mulss	 xmm0, DWORD PTR _scroll_ratio$[ebp]
  00651	f3 0f 5e 85 7c
	ff ff ff	 divss	 xmm0, DWORD PTR _scrollbar_size_v$[ebp]
  00659	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _grab_v_norm$[ebp], xmm0

; 860  : 
; 861  :         // Update distance to grab now that we have seeked and saturated
; 862  :         if (seek_absolute)

  00661	0f b6 85 ef fe
	ff ff		 movzx	 eax, BYTE PTR _seek_absolute$5[ebp]
  00668	85 c0		 test	 eax, eax
  0066a	74 2f		 je	 SHORT $LN11@ScrollbarE

; 863  :             g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;

  0066c	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _clicked_v_norm$6[ebp]
  00674	f3 0f 5c 85 1c
	ff ff ff	 subss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  0067c	f3 0f 10 8d 58
	ff ff ff	 movss	 xmm1, DWORD PTR _grab_h_norm$[ebp]
  00684	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  0068c	f3 0f 5c c1	 subss	 xmm0, xmm1
  00690	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00693	f3 0f 11 80 04
	2d 00 00	 movss	 DWORD PTR [eax+11524], xmm0
$LN11@ScrollbarE:

; 864  :     }
; 865  : 
; 866  :     // Render
; 867  :     window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, rounding_corners);

  0069b	8b 45 20	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  0069e	50		 push	 eax
  0069f	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  006a2	51		 push	 ecx
  006a3	f3 0f 10 41 3c	 movss	 xmm0, DWORD PTR [ecx+60]
  006a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ad	51		 push	 ecx
  006ae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006bb	6a 0e		 push	 14			; 0000000eH
  006bd	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  006c2	83 c4 08	 add	 esp, 8
  006c5	50		 push	 eax
  006c6	8b 55 08	 mov	 edx, DWORD PTR _bb_frame$[ebp]
  006c9	83 c2 08	 add	 edx, 8
  006cc	52		 push	 edx
  006cd	8b 45 08	 mov	 eax, DWORD PTR _bb_frame$[ebp]
  006d0	50		 push	 eax
  006d1	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  006d4	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  006da	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 868  :     const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);

  006df	0f b6 85 4f ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  006e6	85 c0		 test	 eax, eax
  006e8	74 0c		 je	 SHORT $LN30@ScrollbarE
  006ea	c7 85 b4 fd ff
	ff 11 00 00 00	 mov	 DWORD PTR tv317[ebp], 17 ; 00000011H
  006f4	eb 2d		 jmp	 SHORT $LN31@ScrollbarE
$LN30@ScrollbarE:
  006f6	0f b6 8d 43 ff
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  006fd	85 c9		 test	 ecx, ecx
  006ff	74 0c		 je	 SHORT $LN28@ScrollbarE
  00701	c7 85 b0 fd ff
	ff 10 00 00 00	 mov	 DWORD PTR tv314[ebp], 16 ; 00000010H
  0070b	eb 0a		 jmp	 SHORT $LN29@ScrollbarE
$LN28@ScrollbarE:
  0070d	c7 85 b0 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR tv314[ebp], 15 ; 0000000fH
$LN29@ScrollbarE:
  00717	8b 95 b0 fd ff
	ff		 mov	 edx, DWORD PTR tv314[ebp]
  0071d	89 95 b4 fd ff
	ff		 mov	 DWORD PTR tv317[ebp], edx
$LN31@ScrollbarE:
  00723	51		 push	 ecx
  00724	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _alpha$[ebp]
  00729	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0072e	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR tv317[ebp]
  00734	50		 push	 eax
  00735	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0073a	83 c4 08	 add	 esp, 8
  0073d	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _grab_col$[ebp], eax

; 869  :     ImRect grab_rect;

  00743	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _grab_rect$[ebp]
  00749	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect

; 870  :     if (horizontal)

  0074e	0f b6 45 a3	 movzx	 eax, BYTE PTR _horizontal$[ebp]
  00752	85 c0		 test	 eax, eax
  00754	0f 84 c0 00 00
	00		 je	 $LN12@ScrollbarE

; 871  :         grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);

  0075a	51		 push	 ecx
  0075b	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _bb$[ebp+12]
  00760	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00765	51		 push	 ecx
  00766	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  0076e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00773	51		 push	 ecx
  00774	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _bb$[ebp+8]
  00779	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0077e	51		 push	 ecx
  0077f	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _bb$[ebp]
  00784	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00789	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  0078e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00791	d9 9d b4 fd ff
	ff		 fstp	 DWORD PTR tv589[ebp]
  00797	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR tv589[ebp]
  0079f	f3 0f 58 85 64
	ff ff ff	 addss	 xmm0, DWORD PTR _grab_h_pixels$[ebp]
  007a7	51		 push	 ecx
  007a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007ad	51		 push	 ecx
  007ae	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _bb$[ebp+4]
  007b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007b8	51		 push	 ecx
  007b9	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  007c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007c6	51		 push	 ecx
  007c7	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _bb$[ebp+8]
  007cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007d1	51		 push	 ecx
  007d2	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _bb$[ebp]
  007d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007dc	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  007e1	83 c4 08	 add	 esp, 8
  007e4	d9 1c 24	 fstp	 DWORD PTR [esp]
  007e7	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  007ed	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  007f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  007f4	89 8d bc fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp], ecx
  007fa	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  007fd	89 95 c0 fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp+4], edx
  00803	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00806	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp+8], ecx
  0080c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0080f	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp+12], edx
  00815	e9 bb 00 00 00	 jmp	 $LN13@ScrollbarE
$LN12@ScrollbarE:

; 872  :     else
; 873  :         grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);

  0081a	51		 push	 ecx
  0081b	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  00823	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00828	51		 push	 ecx
  00829	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _bb$[ebp+12]
  0082e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00833	51		 push	 ecx
  00834	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _bb$[ebp+4]
  00839	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0083e	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00843	83 c4 0c	 add	 esp, 12			; 0000000cH
  00846	d9 9d b4 fd ff
	ff		 fstp	 DWORD PTR tv625[ebp]
  0084c	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR tv625[ebp]
  00854	f3 0f 58 85 64
	ff ff ff	 addss	 xmm0, DWORD PTR _grab_h_pixels$[ebp]
  0085c	51		 push	 ecx
  0085d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00862	51		 push	 ecx
  00863	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _bb$[ebp+8]
  00868	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0086d	51		 push	 ecx
  0086e	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_v_norm$[ebp]
  00876	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0087b	51		 push	 ecx
  0087c	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _bb$[ebp+12]
  00881	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00886	51		 push	 ecx
  00887	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _bb$[ebp+4]
  0088c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00891	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  00896	83 c4 08	 add	 esp, 8
  00899	d9 1c 24	 fstp	 DWORD PTR [esp]
  0089c	51		 push	 ecx
  0089d	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _bb$[ebp]
  008a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008a7	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  008ad	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  008b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  008b4	89 8d bc fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp], ecx
  008ba	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  008bd	89 95 c0 fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp+4], edx
  008c3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  008c6	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp+8], ecx
  008cc	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  008cf	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _grab_rect$[ebp+12], edx
$LN13@ScrollbarE:

; 874  :     window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);

  008d5	6a 0f		 push	 15			; 0000000fH
  008d7	8b 45 b8	 mov	 eax, DWORD PTR _style$[ebp]
  008da	51		 push	 ecx
  008db	f3 0f 10 40 6c	 movss	 xmm0, DWORD PTR [eax+108]
  008e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008e5	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _grab_col$[ebp]
  008eb	51		 push	 ecx
  008ec	8d 95 c4 fe ff
	ff		 lea	 edx, DWORD PTR _grab_rect$[ebp+8]
  008f2	52		 push	 edx
  008f3	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _grab_rect$[ebp]
  008f9	50		 push	 eax
  008fa	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  008fd	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  00903	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 875  : 
; 876  :     return held;

  00908	8a 85 4f ff ff
	ff		 mov	 al, BYTE PTR _held$[ebp]
$LN1@ScrollbarE:

; 877  : }

  0090e	52		 push	 edx
  0090f	8b cd		 mov	 ecx, ebp
  00911	50		 push	 eax
  00912	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN37@ScrollbarE
  00918	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0091d	58		 pop	 eax
  0091e	5a		 pop	 edx
  0091f	5f		 pop	 edi
  00920	5e		 pop	 esi
  00921	5b		 pop	 ebx
  00922	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00925	33 cd		 xor	 ecx, ebp
  00927	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0092c	81 c4 50 02 00
	00		 add	 esp, 592		; 00000250H
  00932	3b ec		 cmp	 ebp, esp
  00934	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00939	8b e5		 mov	 esp, ebp
  0093b	5d		 pop	 ebp
  0093c	c3		 ret	 0
  0093d	0f 1f 00	 npad	 3
$LN37@ScrollbarE:
  00940	04 00 00 00	 DD	 4
  00944	00 00 00 00	 DD	 $LN36@ScrollbarE
$LN36@ScrollbarE:
  00948	88 ff ff ff	 DD	 -120			; ffffff88H
  0094c	10 00 00 00	 DD	 16			; 00000010H
  00950	00 00 00 00	 DD	 $LN32@ScrollbarE
  00954	4f ff ff ff	 DD	 -177			; ffffff4fH
  00958	01 00 00 00	 DD	 1
  0095c	00 00 00 00	 DD	 $LN33@ScrollbarE
  00960	43 ff ff ff	 DD	 -189			; ffffff43H
  00964	01 00 00 00	 DD	 1
  00968	00 00 00 00	 DD	 $LN34@ScrollbarE
  0096c	bc fe ff ff	 DD	 -324			; fffffebcH
  00970	10 00 00 00	 DD	 16			; 00000010H
  00974	00 00 00 00	 DD	 $LN35@ScrollbarE
$LN35@ScrollbarE:
  00978	67		 DB	 103			; 00000067H
  00979	72		 DB	 114			; 00000072H
  0097a	61		 DB	 97			; 00000061H
  0097b	62		 DB	 98			; 00000062H
  0097c	5f		 DB	 95			; 0000005fH
  0097d	72		 DB	 114			; 00000072H
  0097e	65		 DB	 101			; 00000065H
  0097f	63		 DB	 99			; 00000063H
  00980	74		 DB	 116			; 00000074H
  00981	00		 DB	 0
$LN34@ScrollbarE:
  00982	68		 DB	 104			; 00000068H
  00983	6f		 DB	 111			; 0000006fH
  00984	76		 DB	 118			; 00000076H
  00985	65		 DB	 101			; 00000065H
  00986	72		 DB	 114			; 00000072H
  00987	65		 DB	 101			; 00000065H
  00988	64		 DB	 100			; 00000064H
  00989	00		 DB	 0
$LN33@ScrollbarE:
  0098a	68		 DB	 104			; 00000068H
  0098b	65		 DB	 101			; 00000065H
  0098c	6c		 DB	 108			; 0000006cH
  0098d	64		 DB	 100			; 00000064H
  0098e	00		 DB	 0
$LN32@ScrollbarE:
  0098f	62		 DB	 98			; 00000062H
  00990	62		 DB	 98			; 00000062H
  00991	00		 DB	 0
?ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z ENDP ; ImGui::ScrollbarEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z
_TEXT	SEGMENT
tv333 = -428						; size = 4
tv344 = -424						; size = 4
tv328 = -420						; size = 4
tv165 = -420						; size = 4
tv90 = -420						; size = 4
$T1 = -412						; size = 8
$T2 = -396						; size = 8
$T3 = -380						; size = 8
$T4 = -364						; size = 8
_bb$ = -156						; size = 16
_rounding_corners$ = -132				; size = 4
_other_scrollbar_size$ = -120				; size = 4
_scrollbar_size$ = -108					; size = 4
_border_size$ = -96					; size = 4
_inner_rect$ = -84					; size = 16
_outer_rect$ = -60					; size = 16
_id$ = -36						; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_axis$ = 8						; size = 4
?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z PROC		; ImGui::Scrollbar, COMDAT

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 54 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-428]
  00012	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 881  :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 882  :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 883  : 
; 884  :     const ImGuiID id = GetWindowScrollbarID(window, axis);

  00046	8b 45 08	 mov	 eax, DWORD PTR _axis$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?GetWindowScrollbarID@ImGui@@YAIPAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetWindowScrollbarID
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 885  :     KeepAliveID(id);

  00059	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?KeepAliveID@ImGui@@YAXI@Z ; ImGui::KeepAliveID
  00062	83 c4 04	 add	 esp, 4

; 886  : 
; 887  :     // Calculate scrollbar bounding box
; 888  :     const ImRect outer_rect = window->Rect();

  00065	8d 45 c4	 lea	 eax, DWORD PTR _outer_rect$[ebp]
  00068	50		 push	 eax
  00069	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  0006c	e8 00 00 00 00	 call	 ?Rect@ImGuiWindow@@QBE?AUImRect@@XZ ; ImGuiWindow::Rect

; 889  :     const ImRect inner_rect = window->InnerRect;

  00071	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00074	05 d4 01 00 00	 add	 eax, 468		; 000001d4H
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	89 4d ac	 mov	 DWORD PTR _inner_rect$[ebp], ecx
  0007e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00081	89 55 b0	 mov	 DWORD PTR _inner_rect$[ebp+4], edx
  00084	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00087	89 4d b4	 mov	 DWORD PTR _inner_rect$[ebp+8], ecx
  0008a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0008d	89 55 b8	 mov	 DWORD PTR _inner_rect$[ebp+12], edx

; 890  :     const float border_size = window->WindowBorderSize;

  00090	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00093	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00098	f3 0f 11 45 a0	 movss	 DWORD PTR _border_size$[ebp], xmm0

; 891  :     const float scrollbar_size = window->ScrollbarSizes[axis ^ 1];

  0009d	8b 45 08	 mov	 eax, DWORD PTR _axis$[ebp]
  000a0	83 f0 01	 xor	 eax, 1
  000a3	50		 push	 eax
  000a4	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  000a7	83 c1 70	 add	 ecx, 112		; 00000070H
  000aa	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  000af	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000b3	f3 0f 11 45 94	 movss	 DWORD PTR _scrollbar_size$[ebp], xmm0

; 892  :     IM_ASSERT(scrollbar_size > 0.0f);

  000b8	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _scrollbar_size$[ebp]
  000bd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000c4	77 25		 ja	 SHORT $LN5@Scrollbar
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z@4JA
  000cb	83 c0 0c	 add	 eax, 12			; 0000000cH
  000ce	8b f4		 mov	 esi, esp
  000d0	50		 push	 eax
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@GFPJIOBE@?$AAs?$AAc?$AAr?$AAo?$AAl?$AAl?$AAb?$AAa?$AAr?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5@
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	3b f4		 cmp	 esi, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Scrollbar:

; 893  :     const float other_scrollbar_size = window->ScrollbarSizes[axis];

  000eb	8b 45 08	 mov	 eax, DWORD PTR _axis$[ebp]
  000ee	50		 push	 eax
  000ef	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  000f2	83 c1 70	 add	 ecx, 112		; 00000070H
  000f5	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  000fa	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000fe	f3 0f 11 45 88	 movss	 DWORD PTR _other_scrollbar_size$[ebp], xmm0

; 894  :     ImDrawCornerFlags rounding_corners = (other_scrollbar_size <= 0.0f) ? ImDrawCornerFlags_BotRight : 0;

  00103	0f 57 c0	 xorps	 xmm0, xmm0
  00106	0f 2f 45 88	 comiss	 xmm0, DWORD PTR _other_scrollbar_size$[ebp]
  0010a	72 0c		 jb	 SHORT $LN6@Scrollbar
  0010c	c7 85 5c fe ff
	ff 08 00 00 00	 mov	 DWORD PTR tv90[ebp], 8
  00116	eb 0a		 jmp	 SHORT $LN7@Scrollbar
$LN6@Scrollbar:
  00118	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
$LN7@Scrollbar:
  00122	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv90[ebp]
  00128	89 85 7c ff ff
	ff		 mov	 DWORD PTR _rounding_corners$[ebp], eax

; 895  :     ImRect bb;

  0012e	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  00134	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect

; 896  :     if (axis == ImGuiAxis_X)

  00139	83 7d 08 00	 cmp	 DWORD PTR _axis$[ebp], 0
  0013d	0f 85 98 00 00
	00		 jne	 $LN2@Scrollbar

; 897  :     {
; 898  :         bb.Min = ImVec2(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size));

  00143	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _outer_rect$[ebp+12]
  00148	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _border_size$[ebp]
  0014d	f3 0f 5c 45 94	 subss	 xmm0, DWORD PTR _scrollbar_size$[ebp]
  00152	51		 push	 ecx
  00153	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00158	51		 push	 ecx
  00159	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _outer_rect$[ebp+4]
  0015e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00163	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00168	83 c4 04	 add	 esp, 4
  0016b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0016e	51		 push	 ecx
  0016f	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _inner_rect$[ebp]
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	8d 8d 94 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0017f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00184	8b 08		 mov	 ecx, DWORD PTR [eax]
  00186	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00189	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _bb$[ebp], ecx
  0018f	89 95 68 ff ff
	ff		 mov	 DWORD PTR _bb$[ebp+4], edx

; 899  :         bb.Max = ImVec2(inner_rect.Max.x, outer_rect.Max.y);

  00195	51		 push	 ecx
  00196	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _outer_rect$[ebp+12]
  0019b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a0	51		 push	 ecx
  001a1	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _inner_rect$[ebp+8]
  001a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ab	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001b1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bb	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _bb$[ebp+8], ecx
  001c1	89 95 70 ff ff
	ff		 mov	 DWORD PTR _bb$[ebp+12], edx

; 900  :         rounding_corners |= ImDrawCornerFlags_BotLeft;

  001c7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  001cd	83 c8 04	 or	 eax, 4
  001d0	89 85 7c ff ff
	ff		 mov	 DWORD PTR _rounding_corners$[ebp], eax

; 901  :     }

  001d6	e9 ca 00 00 00	 jmp	 $LN3@Scrollbar
$LN2@Scrollbar:

; 902  :     else
; 903  :     {
; 904  :         bb.Min = ImVec2(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y);

  001db	51		 push	 ecx
  001dc	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _inner_rect$[ebp+4]
  001e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e6	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _outer_rect$[ebp+8]
  001eb	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _border_size$[ebp]
  001f0	f3 0f 5c 45 94	 subss	 xmm0, DWORD PTR _scrollbar_size$[ebp]
  001f5	51		 push	 ecx
  001f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fb	51		 push	 ecx
  001fc	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _outer_rect$[ebp]
  00201	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00206	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0020b	83 c4 04	 add	 esp, 4
  0020e	d9 1c 24	 fstp	 DWORD PTR [esp]
  00211	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00217	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0021c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00221	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _bb$[ebp], ecx
  00227	89 95 68 ff ff
	ff		 mov	 DWORD PTR _bb$[ebp+4], edx

; 905  :         bb.Max = ImVec2(outer_rect.Max.x, window->InnerRect.Max.y);

  0022d	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00230	51		 push	 ecx
  00231	f3 0f 10 80 e0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+480]
  00239	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023e	51		 push	 ecx
  0023f	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _outer_rect$[ebp+8]
  00244	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00249	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0024f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00254	8b 08		 mov	 ecx, DWORD PTR [eax]
  00256	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00259	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _bb$[ebp+8], ecx
  0025f	89 95 70 ff ff
	ff		 mov	 DWORD PTR _bb$[ebp+12], edx

; 906  :         rounding_corners |= ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0;

  00265	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00268	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0026b	83 e1 01	 and	 ecx, 1
  0026e	74 19		 je	 SHORT $LN8@Scrollbar
  00270	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  00273	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00276	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0027b	75 0c		 jne	 SHORT $LN8@Scrollbar
  0027d	c7 85 5c fe ff
	ff 02 00 00 00	 mov	 DWORD PTR tv165[ebp], 2
  00287	eb 0a		 jmp	 SHORT $LN9@Scrollbar
$LN8@Scrollbar:
  00289	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv165[ebp], 0
$LN9@Scrollbar:
  00293	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _rounding_corners$[ebp]
  00299	0b 8d 5c fe ff
	ff		 or	 ecx, DWORD PTR tv165[ebp]
  0029f	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _rounding_corners$[ebp], ecx
$LN3@Scrollbar:

; 907  :     }
; 908  :     ScrollbarEx(bb, id, axis, &window->Scroll[axis], inner_rect.Max[axis] - inner_rect.Min[axis], window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f, rounding_corners);

  002a5	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  002ab	50		 push	 eax
  002ac	8b 4d 08	 mov	 ecx, DWORD PTR _axis$[ebp]
  002af	51		 push	 ecx
  002b0	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  002b3	83 c1 24	 add	 ecx, 36			; 00000024H
  002b6	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  002bb	8b f0		 mov	 esi, eax
  002bd	8b 55 08	 mov	 edx, DWORD PTR _axis$[ebp]
  002c0	52		 push	 edx
  002c1	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  002c4	83 c1 34	 add	 ecx, 52			; 00000034H
  002c7	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  002cc	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002d0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  002d8	f3 0f 58 06	 addss	 xmm0, DWORD PTR [esi]
  002dc	51		 push	 ecx
  002dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e2	8b 45 08	 mov	 eax, DWORD PTR _axis$[ebp]
  002e5	50		 push	 eax
  002e6	8d 4d b4	 lea	 ecx, DWORD PTR _inner_rect$[ebp+8]
  002e9	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  002ee	d9 9d 5c fe ff
	ff		 fstp	 DWORD PTR tv328[ebp]
  002f4	f3 0f 10 85 5c
	fe ff ff	 movss	 xmm0, DWORD PTR tv328[ebp]
  002fc	8b 4d 08	 mov	 ecx, DWORD PTR _axis$[ebp]
  002ff	51		 push	 ecx
  00300	8d 4d ac	 lea	 ecx, DWORD PTR _inner_rect$[ebp]
  00303	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR tv344[ebp], xmm0
  0030b	e8 00 00 00 00	 call	 ??AImVec2@@QBEMI@Z	; ImVec2::operator[]
  00310	d9 9d 54 fe ff
	ff		 fstp	 DWORD PTR tv333[ebp]
  00316	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR tv344[ebp]
  0031e	f3 0f 5c 85 54
	fe ff ff	 subss	 xmm0, DWORD PTR tv333[ebp]
  00326	51		 push	 ecx
  00327	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032c	8b 55 08	 mov	 edx, DWORD PTR _axis$[ebp]
  0032f	52		 push	 edx
  00330	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00333	83 c1 50	 add	 ecx, 80			; 00000050H
  00336	e8 00 00 00 00	 call	 ??AImVec2@@QAEAAMI@Z	; ImVec2::operator[]
  0033b	50		 push	 eax
  0033c	8b 45 08	 mov	 eax, DWORD PTR _axis$[ebp]
  0033f	50		 push	 eax
  00340	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  00343	51		 push	 ecx
  00344	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _bb$[ebp]
  0034a	52		 push	 edx
  0034b	e8 00 00 00 00	 call	 ?ScrollbarEx@ImGui@@YA_NABUImRect@@IW4ImGuiAxis@@PAMMMH@Z ; ImGui::ScrollbarEx
  00350	83 c4 1c	 add	 esp, 28			; 0000001cH

; 909  : }

  00353	52		 push	 edx
  00354	8b cd		 mov	 ecx, ebp
  00356	50		 push	 eax
  00357	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@Scrollbar
  0035d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00362	58		 pop	 eax
  00363	5a		 pop	 edx
  00364	5f		 pop	 edi
  00365	5e		 pop	 esi
  00366	5b		 pop	 ebx
  00367	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036a	33 cd		 xor	 ecx, ebp
  0036c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00371	81 c4 ac 01 00
	00		 add	 esp, 428		; 000001acH
  00377	3b ec		 cmp	 ebp, esp
  00379	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0037e	8b e5		 mov	 esp, ebp
  00380	5d		 pop	 ebp
  00381	c3		 ret	 0
  00382	66 90		 npad	 2
$LN14@Scrollbar:
  00384	03 00 00 00	 DD	 3
  00388	00 00 00 00	 DD	 $LN13@Scrollbar
$LN13@Scrollbar:
  0038c	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00390	10 00 00 00	 DD	 16			; 00000010H
  00394	00 00 00 00	 DD	 $LN10@Scrollbar
  00398	ac ff ff ff	 DD	 -84			; ffffffacH
  0039c	10 00 00 00	 DD	 16			; 00000010H
  003a0	00 00 00 00	 DD	 $LN11@Scrollbar
  003a4	64 ff ff ff	 DD	 -156			; ffffff64H
  003a8	10 00 00 00	 DD	 16			; 00000010H
  003ac	00 00 00 00	 DD	 $LN12@Scrollbar
$LN12@Scrollbar:
  003b0	62		 DB	 98			; 00000062H
  003b1	62		 DB	 98			; 00000062H
  003b2	00		 DB	 0
$LN11@Scrollbar:
  003b3	69		 DB	 105			; 00000069H
  003b4	6e		 DB	 110			; 0000006eH
  003b5	6e		 DB	 110			; 0000006eH
  003b6	65		 DB	 101			; 00000065H
  003b7	72		 DB	 114			; 00000072H
  003b8	5f		 DB	 95			; 0000005fH
  003b9	72		 DB	 114			; 00000072H
  003ba	65		 DB	 101			; 00000065H
  003bb	63		 DB	 99			; 00000063H
  003bc	74		 DB	 116			; 00000074H
  003bd	00		 DB	 0
$LN10@Scrollbar:
  003be	6f		 DB	 111			; 0000006fH
  003bf	75		 DB	 117			; 00000075H
  003c0	74		 DB	 116			; 00000074H
  003c1	65		 DB	 101			; 00000065H
  003c2	72		 DB	 114			; 00000072H
  003c3	5f		 DB	 95			; 0000005fH
  003c4	72		 DB	 114			; 00000072H
  003c5	65		 DB	 101			; 00000065H
  003c6	63		 DB	 99			; 00000063H
  003c7	74		 DB	 116			; 00000074H
  003c8	00		 DB	 0
?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z ENDP		; ImGui::Scrollbar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ArrowButtonEx@ImGui@@YA_NPBDHUImVec2@@H@Z
_TEXT	SEGMENT
tv148 = -384						; size = 4
tv149 = -380						; size = 4
tv88 = -380						; size = 4
$T1 = -372						; size = 8
$T2 = -356						; size = 8
$T3 = -340						; size = 8
_text_col$ = -132					; size = 4
_bg_col$ = -120						; size = 4
_pressed$ = -105					; size = 1
_held$ = -93						; size = 1
_hovered$ = -81						; size = 1
_default_size$ = -72					; size = 4
_bb$ = -60						; size = 16
_id$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_str_id$ = 8						; size = 4
_dir$ = 12						; size = 4
_size$ = 16						; size = 8
_flags$ = 24						; size = 4
?ArrowButtonEx@ImGui@@YA_NPBDHUImVec2@@H@Z PROC		; ImGui::ArrowButtonEx, COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 01 00
	00		 sub	 esp, 384		; 00000180H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 80 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-384]
  00012	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 687  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 688  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@ArrowButto

; 689  :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 6d 02 00 00	 jmp	 $LN1@ArrowButto
$LN2@ArrowButto:

; 690  : 
; 691  :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 692  :     const ImGuiID id = window->GetID(str_id);

  00054	6a 00		 push	 0
  00056	8b 45 08	 mov	 eax, DWORD PTR _str_id$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0005d	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00062	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 693  :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

  00065	8d 45 10	 lea	 eax, DWORD PTR _size$[ebp]
  00068	50		 push	 eax
  00069	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0006c	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  00072	51		 push	 ecx
  00073	8d 95 ac fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	50		 push	 eax
  00083	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00086	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0008b	50		 push	 eax
  0008c	8d 4d c4	 lea	 ecx, DWORD PTR _bb$[ebp]
  0008f	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 694  :     const float default_size = GetFrameHeight();

  00094	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  00099	d9 5d b8	 fstp	 DWORD PTR _default_size$[ebp]

; 695  :     ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : -1.0f);

  0009c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  000a1	0f 2f 45 b8	 comiss	 xmm0, DWORD PTR _default_size$[ebp]
  000a5	72 15		 jb	 SHORT $LN6@ArrowButto
  000a7	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  000aa	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  000b2	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR tv88[ebp], xmm0
  000ba	eb 10		 jmp	 SHORT $LN7@ArrowButto
$LN6@ArrowButto:
  000bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000c4	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR tv88[ebp], xmm0
$LN7@ArrowButto:
  000cc	51		 push	 ecx
  000cd	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv88[ebp]
  000d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000da	8d 4d 10	 lea	 ecx, DWORD PTR _size$[ebp]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  000e3	83 c4 08	 add	 esp, 8

; 696  :     if (!ItemAdd(bb, id))

  000e6	6a 00		 push	 0
  000e8	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  000eb	50		 push	 eax
  000ec	8d 4d c4	 lea	 ecx, DWORD PTR _bb$[ebp]
  000ef	51		 push	 ecx
  000f0	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	0f b6 d0	 movzx	 edx, al
  000fb	85 d2		 test	 edx, edx
  000fd	75 07		 jne	 SHORT $LN3@ArrowButto

; 697  :         return false;

  000ff	32 c0		 xor	 al, al
  00101	e9 b3 01 00 00	 jmp	 $LN1@ArrowButto
$LN3@ArrowButto:

; 698  : 
; 699  :     if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)

  00106	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00109	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  0010f	83 e1 02	 and	 ecx, 2
  00112	74 09		 je	 SHORT $LN4@ArrowButto

; 700  :         flags |= ImGuiButtonFlags_Repeat;

  00114	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00117	83 c8 01	 or	 eax, 1
  0011a	89 45 18	 mov	 DWORD PTR _flags$[ebp], eax
$LN4@ArrowButto:

; 701  : 
; 702  :     bool hovered, held;
; 703  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

  0011d	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  00120	50		 push	 eax
  00121	8d 4d a3	 lea	 ecx, DWORD PTR _held$[ebp]
  00124	51		 push	 ecx
  00125	8d 55 af	 lea	 edx, DWORD PTR _hovered$[ebp]
  00128	52		 push	 edx
  00129	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  0012c	50		 push	 eax
  0012d	8d 4d c4	 lea	 ecx, DWORD PTR _bb$[ebp]
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  00136	83 c4 14	 add	 esp, 20			; 00000014H
  00139	88 45 97	 mov	 BYTE PTR _pressed$[ebp], al

; 704  : 
; 705  :     // Render
; 706  :     const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

  0013c	0f b6 45 a3	 movzx	 eax, BYTE PTR _held$[ebp]
  00140	85 c0		 test	 eax, eax
  00142	74 14		 je	 SHORT $LN8@ArrowButto
  00144	0f b6 4d af	 movzx	 ecx, BYTE PTR _hovered$[ebp]
  00148	85 c9		 test	 ecx, ecx
  0014a	74 0c		 je	 SHORT $LN8@ArrowButto
  0014c	c7 85 84 fe ff
	ff 17 00 00 00	 mov	 DWORD PTR tv149[ebp], 23 ; 00000017H
  00156	eb 2a		 jmp	 SHORT $LN11@ArrowButto
$LN8@ArrowButto:
  00158	0f b6 55 af	 movzx	 edx, BYTE PTR _hovered$[ebp]
  0015c	85 d2		 test	 edx, edx
  0015e	74 0c		 je	 SHORT $LN9@ArrowButto
  00160	c7 85 80 fe ff
	ff 16 00 00 00	 mov	 DWORD PTR tv148[ebp], 22 ; 00000016H
  0016a	eb 0a		 jmp	 SHORT $LN10@ArrowButto
$LN9@ArrowButto:
  0016c	c7 85 80 fe ff
	ff 15 00 00 00	 mov	 DWORD PTR tv148[ebp], 21 ; 00000015H
$LN10@ArrowButto:
  00176	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  0017c	89 85 84 fe ff
	ff		 mov	 DWORD PTR tv149[ebp], eax
$LN11@ArrowButto:
  00182	51		 push	 ecx
  00183	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0018b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00190	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv149[ebp]
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0019c	83 c4 08	 add	 esp, 8
  0019f	89 45 88	 mov	 DWORD PTR _bg_col$[ebp], eax

; 707  :     const ImU32 text_col = GetColorU32(ImGuiCol_Text);

  001a2	51		 push	 ecx
  001a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b0	6a 00		 push	 0
  001b2	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  001b7	83 c4 08	 add	 esp, 8
  001ba	89 85 7c ff ff
	ff		 mov	 DWORD PTR _text_col$[ebp], eax

; 708  :     RenderNavHighlight(bb, id);

  001c0	6a 01		 push	 1
  001c2	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  001c5	50		 push	 eax
  001c6	8d 4d c4	 lea	 ecx, DWORD PTR _bb$[ebp]
  001c9	51		 push	 ecx
  001ca	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 709  :     RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);

  001d2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  001d5	51		 push	 ecx
  001d6	f3 0f 10 80 50
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5456]
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	6a 01		 push	 1
  001e5	8b 4d 88	 mov	 ecx, DWORD PTR _bg_col$[ebp]
  001e8	51		 push	 ecx
  001e9	8b 55 d0	 mov	 edx, DWORD PTR _bb$[ebp+12]
  001ec	52		 push	 edx
  001ed	8b 45 cc	 mov	 eax, DWORD PTR _bb$[ebp+8]
  001f0	50		 push	 eax
  001f1	8b 4d c8	 mov	 ecx, DWORD PTR _bb$[ebp+4]
  001f4	51		 push	 ecx
  001f5	8b 55 c4	 mov	 edx, DWORD PTR _bb$[ebp]
  001f8	52		 push	 edx
  001f9	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  001fe	83 c4 1c	 add	 esp, 28			; 0000001cH

; 710  :     RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);

  00201	51		 push	 ecx
  00202	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020f	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  00212	50		 push	 eax
  00213	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _text_col$[ebp]
  00219	51		 push	 ecx
  0021a	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  0021d	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  00222	f3 0f 5c 82 c4
	18 00 00	 subss	 xmm0, DWORD PTR [edx+6340]
  0022a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00232	51		 push	 ecx
  00233	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00238	51		 push	 ecx
  00239	0f 57 c0	 xorps	 xmm0, xmm0
  0023c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00241	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00246	83 c4 04	 add	 esp, 4
  00249	d9 1c 24	 fstp	 DWORD PTR [esp]
  0024c	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0024f	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _size$[ebp]
  00254	f3 0f 5c 80 c4
	18 00 00	 subss	 xmm0, DWORD PTR [eax+6340]
  0025c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00264	51		 push	 ecx
  00265	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026a	51		 push	 ecx
  0026b	0f 57 c0	 xorps	 xmm0, xmm0
  0026e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00273	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00278	83 c4 04	 add	 esp, 4
  0027b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0027e	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00284	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00289	50		 push	 eax
  0028a	8d 4d c4	 lea	 ecx, DWORD PTR _bb$[ebp]
  0028d	51		 push	 ecx
  0028e	8d 95 8c fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00294	52		 push	 edx
  00295	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0029a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002a0	51		 push	 ecx
  002a1	8b 10		 mov	 edx, DWORD PTR [eax]
  002a3	52		 push	 edx
  002a4	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002a7	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  002ad	51		 push	 ecx
  002ae	e8 00 00 00 00	 call	 ?RenderArrow@ImGui@@YAXPAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
  002b3	83 c4 18	 add	 esp, 24			; 00000018H

; 711  : 
; 712  :     return pressed;

  002b6	8a 45 97	 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@ArrowButto:

; 713  : }

  002b9	52		 push	 edx
  002ba	8b cd		 mov	 ecx, ebp
  002bc	50		 push	 eax
  002bd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@ArrowButto
  002c3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002c8	58		 pop	 eax
  002c9	5a		 pop	 edx
  002ca	5f		 pop	 edi
  002cb	5e		 pop	 esi
  002cc	5b		 pop	 ebx
  002cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d0	33 cd		 xor	 ecx, ebp
  002d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d7	81 c4 80 01 00
	00		 add	 esp, 384		; 00000180H
  002dd	3b ec		 cmp	 ebp, esp
  002df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e4	8b e5		 mov	 esp, ebp
  002e6	5d		 pop	 ebp
  002e7	c3		 ret	 0
$LN16@ArrowButto:
  002e8	03 00 00 00	 DD	 3
  002ec	00 00 00 00	 DD	 $LN15@ArrowButto
$LN15@ArrowButto:
  002f0	c4 ff ff ff	 DD	 -60			; ffffffc4H
  002f4	10 00 00 00	 DD	 16			; 00000010H
  002f8	00 00 00 00	 DD	 $LN12@ArrowButto
  002fc	af ff ff ff	 DD	 -81			; ffffffafH
  00300	01 00 00 00	 DD	 1
  00304	00 00 00 00	 DD	 $LN13@ArrowButto
  00308	a3 ff ff ff	 DD	 -93			; ffffffa3H
  0030c	01 00 00 00	 DD	 1
  00310	00 00 00 00	 DD	 $LN14@ArrowButto
$LN14@ArrowButto:
  00314	68		 DB	 104			; 00000068H
  00315	65		 DB	 101			; 00000065H
  00316	6c		 DB	 108			; 0000006cH
  00317	64		 DB	 100			; 00000064H
  00318	00		 DB	 0
$LN13@ArrowButto:
  00319	68		 DB	 104			; 00000068H
  0031a	6f		 DB	 111			; 0000006fH
  0031b	76		 DB	 118			; 00000076H
  0031c	65		 DB	 101			; 00000065H
  0031d	72		 DB	 114			; 00000072H
  0031e	65		 DB	 101			; 00000065H
  0031f	64		 DB	 100			; 00000064H
  00320	00		 DB	 0
$LN12@ArrowButto:
  00321	62		 DB	 98			; 00000062H
  00322	62		 DB	 98			; 00000062H
  00323	00		 DB	 0
?ArrowButtonEx@ImGui@@YA_NPBDHUImVec2@@H@Z ENDP		; ImGui::ArrowButtonEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?CollapseButton@ImGui@@YA_NIABUImVec2@@@Z
_TEXT	SEGMENT
tv137 = -408						; size = 4
tv162 = -404						; size = 4
tv138 = -404						; size = 4
$T1 = -396						; size = 8
$T2 = -380						; size = 8
$T3 = -364						; size = 8
$T4 = -348						; size = 8
$T5 = -332						; size = 8
_center$ = -124						; size = 8
_text_col$ = -108					; size = 4
_bg_col$ = -96						; size = 4
_pressed$ = -81						; size = 1
_held$ = -69						; size = 1
_hovered$ = -57						; size = 1
_bb$ = -48						; size = 16
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_id$ = 8						; size = 4
_pos$ = 12						; size = 4
?CollapseButton@ImGui@@YA_NIABUImVec2@@@Z PROC		; ImGui::CollapseButton, COMDAT

; 753  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 68 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-408]
  00012	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 754  :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 755  :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 756  : 
; 757  :     ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);

  00046	51		 push	 ecx
  00047	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 48 15 00 00	 add	 eax, 5448		; 00001548H
  0005c	50		 push	 eax
  0005d	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	50		 push	 eax
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00070	51		 push	 ecx
  00071	f3 0f 10 82 c4
	18 00 00	 movss	 xmm0, DWORD PTR [edx+6340]
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00081	51		 push	 ecx
  00082	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0009a	50		 push	 eax
  0009b	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 94 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	50		 push	 eax
  000af	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000be	50		 push	 eax
  000bf	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  000c2	51		 push	 ecx
  000c3	8d 4d d0	 lea	 ecx, DWORD PTR _bb$[ebp]
  000c6	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 758  :     ItemAdd(bb, id);

  000cb	6a 00		 push	 0
  000cd	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  000d0	50		 push	 eax
  000d1	8d 4d d0	 lea	 ecx, DWORD PTR _bb$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 759  :     bool hovered, held;
; 760  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);

  000dd	6a 00		 push	 0
  000df	8d 45 bb	 lea	 eax, DWORD PTR _held$[ebp]
  000e2	50		 push	 eax
  000e3	8d 4d c7	 lea	 ecx, DWORD PTR _hovered$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 08	 mov	 edx, DWORD PTR _id$[ebp]
  000ea	52		 push	 edx
  000eb	8d 45 d0	 lea	 eax, DWORD PTR _bb$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  000f4	83 c4 14	 add	 esp, 20			; 00000014H
  000f7	88 45 af	 mov	 BYTE PTR _pressed$[ebp], al

; 761  : 
; 762  :     // Render
; 763  :     ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

  000fa	0f b6 45 bb	 movzx	 eax, BYTE PTR _held$[ebp]
  000fe	85 c0		 test	 eax, eax
  00100	74 14		 je	 SHORT $LN6@CollapseBu
  00102	0f b6 4d c7	 movzx	 ecx, BYTE PTR _hovered$[ebp]
  00106	85 c9		 test	 ecx, ecx
  00108	74 0c		 je	 SHORT $LN6@CollapseBu
  0010a	c7 85 6c fe ff
	ff 17 00 00 00	 mov	 DWORD PTR tv138[ebp], 23 ; 00000017H
  00114	eb 2a		 jmp	 SHORT $LN9@CollapseBu
$LN6@CollapseBu:
  00116	0f b6 55 c7	 movzx	 edx, BYTE PTR _hovered$[ebp]
  0011a	85 d2		 test	 edx, edx
  0011c	74 0c		 je	 SHORT $LN7@CollapseBu
  0011e	c7 85 68 fe ff
	ff 16 00 00 00	 mov	 DWORD PTR tv137[ebp], 22 ; 00000016H
  00128	eb 0a		 jmp	 SHORT $LN8@CollapseBu
$LN7@CollapseBu:
  0012a	c7 85 68 fe ff
	ff 15 00 00 00	 mov	 DWORD PTR tv137[ebp], 21 ; 00000015H
$LN8@CollapseBu:
  00134	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv137[ebp]
  0013a	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
$LN9@CollapseBu:
  00140	51		 push	 ecx
  00141	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00149	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014e	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv138[ebp]
  00154	51		 push	 ecx
  00155	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0015a	83 c4 08	 add	 esp, 8
  0015d	89 45 a0	 mov	 DWORD PTR _bg_col$[ebp], eax

; 764  :     ImU32 text_col = GetColorU32(ImGuiCol_Text);

  00160	51		 push	 ecx
  00161	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00169	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016e	6a 00		 push	 0
  00170	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00175	83 c4 08	 add	 esp, 8
  00178	89 45 94	 mov	 DWORD PTR _text_col$[ebp], eax

; 765  :     ImVec2 center = bb.GetCenter();

  0017b	8d 45 84	 lea	 eax, DWORD PTR _center$[ebp]
  0017e	50		 push	 eax
  0017f	8d 4d d0	 lea	 ecx, DWORD PTR _bb$[ebp]
  00182	e8 00 00 00 00	 call	 ?GetCenter@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetCenter

; 766  :     if (hovered || held)

  00187	0f b6 45 c7	 movzx	 eax, BYTE PTR _hovered$[ebp]
  0018b	85 c0		 test	 eax, eax
  0018d	75 08		 jne	 SHORT $LN3@CollapseBu
  0018f	0f b6 45 bb	 movzx	 eax, BYTE PTR _held$[ebp]
  00193	85 c0		 test	 eax, eax
  00195	74 39		 je	 SHORT $LN2@CollapseBu
$LN3@CollapseBu:

; 767  :         window->DrawList->AddCircleFilled(center/*+ ImVec2(0.0f, -0.5f)*/, g.FontSize * 0.5f + 1.0f, bg_col, 12);

  00197	6a 0c		 push	 12			; 0000000cH
  00199	8b 45 a0	 mov	 eax, DWORD PTR _bg_col$[ebp]
  0019c	50		 push	 eax
  0019d	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  001a0	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  001a8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001b0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  001b8	51		 push	 ecx
  001b9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001be	8d 55 84	 lea	 edx, DWORD PTR _center$[ebp]
  001c1	52		 push	 edx
  001c2	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  001c5	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  001cb	e8 00 00 00 00	 call	 ?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
$LN2@CollapseBu:

; 768  :     RenderArrow(window->DrawList, bb.Min + g.Style.FramePadding, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

  001d0	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  001d3	0f b6 48 7d	 movzx	 ecx, BYTE PTR [eax+125]
  001d7	85 c9		 test	 ecx, ecx
  001d9	74 0c		 je	 SHORT $LN10@CollapseBu
  001db	c7 85 6c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv162[ebp], 1
  001e5	eb 0a		 jmp	 SHORT $LN11@CollapseBu
$LN10@CollapseBu:
  001e7	c7 85 6c fe ff
	ff 03 00 00 00	 mov	 DWORD PTR tv162[ebp], 3
$LN11@CollapseBu:
  001f1	51		 push	 ecx
  001f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ff	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR tv162[ebp]
  00205	52		 push	 edx
  00206	8b 45 94	 mov	 eax, DWORD PTR _text_col$[ebp]
  00209	50		 push	 eax
  0020a	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0020d	81 c1 48 15 00
	00		 add	 ecx, 5448		; 00001548H
  00213	51		 push	 ecx
  00214	8d 55 d0	 lea	 edx, DWORD PTR _bb$[ebp]
  00217	52		 push	 edx
  00218	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH
  00227	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0022a	51		 push	 ecx
  0022b	8b 10		 mov	 edx, DWORD PTR [eax]
  0022d	52		 push	 edx
  0022e	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00231	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00237	51		 push	 ecx
  00238	e8 00 00 00 00	 call	 ?RenderArrow@ImGui@@YAXPAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
  0023d	83 c4 18	 add	 esp, 24			; 00000018H

; 769  : 
; 770  :     // Switch to moving the window after mouse is moved beyond the initial drag threshold
; 771  :     if (IsItemActive() && IsMouseDragging(0))

  00240	e8 00 00 00 00	 call	 ?IsItemActive@ImGui@@YA_NXZ ; ImGui::IsItemActive
  00245	0f b6 c0	 movzx	 eax, al
  00248	85 c0		 test	 eax, eax
  0024a	74 2b		 je	 SHORT $LN4@CollapseBu
  0024c	51		 push	 ecx
  0024d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00255	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025a	6a 00		 push	 0
  0025c	e8 00 00 00 00	 call	 ?IsMouseDragging@ImGui@@YA_NHM@Z ; ImGui::IsMouseDragging
  00261	83 c4 08	 add	 esp, 8
  00264	0f b6 c0	 movzx	 eax, al
  00267	85 c0		 test	 eax, eax
  00269	74 0c		 je	 SHORT $LN4@CollapseBu

; 772  :         StartMouseMovingWindow(window);

  0026b	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0026e	50		 push	 eax
  0026f	e8 00 00 00 00	 call	 ?StartMouseMovingWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::StartMouseMovingWindow
  00274	83 c4 04	 add	 esp, 4
$LN4@CollapseBu:

; 773  : 
; 774  :     return pressed;

  00277	8a 45 af	 mov	 al, BYTE PTR _pressed$[ebp]

; 775  : }

  0027a	52		 push	 edx
  0027b	8b cd		 mov	 ecx, ebp
  0027d	50		 push	 eax
  0027e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@CollapseBu
  00284	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00289	58		 pop	 eax
  0028a	5a		 pop	 edx
  0028b	5f		 pop	 edi
  0028c	5e		 pop	 esi
  0028d	5b		 pop	 ebx
  0028e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00291	33 cd		 xor	 ecx, ebp
  00293	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00298	81 c4 98 01 00
	00		 add	 esp, 408		; 00000198H
  0029e	3b ec		 cmp	 ebp, esp
  002a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c3		 ret	 0
  002a9	0f 1f 00	 npad	 3
$LN17@CollapseBu:
  002ac	04 00 00 00	 DD	 4
  002b0	00 00 00 00	 DD	 $LN16@CollapseBu
$LN16@CollapseBu:
  002b4	d0 ff ff ff	 DD	 -48			; ffffffd0H
  002b8	10 00 00 00	 DD	 16			; 00000010H
  002bc	00 00 00 00	 DD	 $LN12@CollapseBu
  002c0	c7 ff ff ff	 DD	 -57			; ffffffc7H
  002c4	01 00 00 00	 DD	 1
  002c8	00 00 00 00	 DD	 $LN13@CollapseBu
  002cc	bb ff ff ff	 DD	 -69			; ffffffbbH
  002d0	01 00 00 00	 DD	 1
  002d4	00 00 00 00	 DD	 $LN14@CollapseBu
  002d8	84 ff ff ff	 DD	 -124			; ffffff84H
  002dc	08 00 00 00	 DD	 8
  002e0	00 00 00 00	 DD	 $LN15@CollapseBu
$LN15@CollapseBu:
  002e4	63		 DB	 99			; 00000063H
  002e5	65		 DB	 101			; 00000065H
  002e6	6e		 DB	 110			; 0000006eH
  002e7	74		 DB	 116			; 00000074H
  002e8	65		 DB	 101			; 00000065H
  002e9	72		 DB	 114			; 00000072H
  002ea	00		 DB	 0
$LN14@CollapseBu:
  002eb	68		 DB	 104			; 00000068H
  002ec	65		 DB	 101			; 00000065H
  002ed	6c		 DB	 108			; 0000006cH
  002ee	64		 DB	 100			; 00000064H
  002ef	00		 DB	 0
$LN13@CollapseBu:
  002f0	68		 DB	 104			; 00000068H
  002f1	6f		 DB	 111			; 0000006fH
  002f2	76		 DB	 118			; 00000076H
  002f3	65		 DB	 101			; 00000065H
  002f4	72		 DB	 114			; 00000072H
  002f5	65		 DB	 101			; 00000065H
  002f6	64		 DB	 100			; 00000064H
  002f7	00		 DB	 0
$LN12@CollapseBu:
  002f8	62		 DB	 98			; 00000062H
  002f9	62		 DB	 98			; 00000062H
  002fa	00		 DB	 0
?CollapseButton@ImGui@@YA_NIABUImVec2@@@Z ENDP		; ImGui::CollapseButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?CloseButton@ImGui@@YA_NIABUImVec2@@@Z
_TEXT	SEGMENT
tv140 = -556						; size = 4
tv94 = -556						; size = 4
$T1 = -548						; size = 8
$T2 = -532						; size = 8
$T3 = -516						; size = 8
$T4 = -500						; size = 8
$T5 = -484						; size = 8
$T6 = -468						; size = 8
$T7 = -452						; size = 8
$T8 = -436						; size = 8
$T9 = -420						; size = 8
$T10 = -404						; size = 8
$T11 = -388						; size = 8
$T12 = -372						; size = 8
$T13 = -356						; size = 8
_cross_col$ = -148					; size = 4
_cross_extent$ = -136					; size = 4
_center$ = -124						; size = 8
_col$ = -108						; size = 4
_pressed$ = -93						; size = 1
_held$ = -81						; size = 1
_hovered$ = -69						; size = 1
_is_clipped$ = -57					; size = 1
_bb$ = -48						; size = 16
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_id$ = 8						; size = 4
_pos$ = 12						; size = 4
?CloseButton@ImGui@@YA_NIABUImVec2@@@Z PROC		; ImGui::CloseButton, COMDAT

; 723  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-556]
  00012	b9 8b 00 00 00	 mov	 ecx, 139		; 0000008bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 724  :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 725  :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 726  : 
; 727  :     // We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
; 728  :     // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
; 729  :     const ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);

  00046	51		 push	 ecx
  00047	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 48 15 00 00	 add	 eax, 5448		; 00001548H
  0005c	50		 push	 eax
  0005d	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	50		 push	 eax
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00070	51		 push	 ecx
  00071	f3 0f 10 82 c4
	18 00 00	 movss	 xmm0, DWORD PTR [edx+6340]
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00081	51		 push	 ecx
  00082	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00095	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0009a	50		 push	 eax
  0009b	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  0009e	51		 push	 ecx
  0009f	8d 95 7c fe ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	50		 push	 eax
  000af	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000be	50		 push	 eax
  000bf	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  000c2	51		 push	 ecx
  000c3	8d 4d d0	 lea	 ecx, DWORD PTR _bb$[ebp]
  000c6	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 730  :     bool is_clipped = !ItemAdd(bb, id);

  000cb	6a 00		 push	 0
  000cd	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  000d0	50		 push	 eax
  000d1	8d 4d d0	 lea	 ecx, DWORD PTR _bb$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dd	0f b6 d0	 movzx	 edx, al
  000e0	85 d2		 test	 edx, edx
  000e2	75 0c		 jne	 SHORT $LN5@CloseButto
  000e4	c7 85 d4 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv94[ebp], 1
  000ee	eb 0a		 jmp	 SHORT $LN6@CloseButto
$LN5@CloseButto:
  000f0	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv94[ebp], 0
$LN6@CloseButto:
  000fa	8a 85 d4 fd ff
	ff		 mov	 al, BYTE PTR tv94[ebp]
  00100	88 45 c7	 mov	 BYTE PTR _is_clipped$[ebp], al

; 731  : 
; 732  :     bool hovered, held;
; 733  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

  00103	6a 00		 push	 0
  00105	8d 45 af	 lea	 eax, DWORD PTR _held$[ebp]
  00108	50		 push	 eax
  00109	8d 4d bb	 lea	 ecx, DWORD PTR _hovered$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 55 08	 mov	 edx, DWORD PTR _id$[ebp]
  00110	52		 push	 edx
  00111	8d 45 d0	 lea	 eax, DWORD PTR _bb$[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  0011a	83 c4 14	 add	 esp, 20			; 00000014H
  0011d	88 45 a3	 mov	 BYTE PTR _pressed$[ebp], al

; 734  :     if (is_clipped)

  00120	0f b6 45 c7	 movzx	 eax, BYTE PTR _is_clipped$[ebp]
  00124	85 c0		 test	 eax, eax
  00126	74 08		 je	 SHORT $LN2@CloseButto

; 735  :         return pressed;

  00128	8a 45 a3	 mov	 al, BYTE PTR _pressed$[ebp]
  0012b	e9 76 02 00 00	 jmp	 $LN1@CloseButto
$LN2@CloseButto:

; 736  : 
; 737  :     // Render
; 738  :     ImU32 col = GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered);

  00130	0f b6 45 af	 movzx	 eax, BYTE PTR _held$[ebp]
  00134	85 c0		 test	 eax, eax
  00136	74 0c		 je	 SHORT $LN7@CloseButto
  00138	c7 85 d4 fd ff
	ff 17 00 00 00	 mov	 DWORD PTR tv140[ebp], 23 ; 00000017H
  00142	eb 0a		 jmp	 SHORT $LN8@CloseButto
$LN7@CloseButto:
  00144	c7 85 d4 fd ff
	ff 16 00 00 00	 mov	 DWORD PTR tv140[ebp], 22 ; 00000016H
$LN8@CloseButto:
  0014e	51		 push	 ecx
  0014f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00157	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015c	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR tv140[ebp]
  00162	51		 push	 ecx
  00163	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00168	83 c4 08	 add	 esp, 8
  0016b	89 45 94	 mov	 DWORD PTR _col$[ebp], eax

; 739  :     ImVec2 center = bb.GetCenter();

  0016e	8d 45 84	 lea	 eax, DWORD PTR _center$[ebp]
  00171	50		 push	 eax
  00172	8d 4d d0	 lea	 ecx, DWORD PTR _bb$[ebp]
  00175	e8 00 00 00 00	 call	 ?GetCenter@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetCenter

; 740  :     if (hovered)

  0017a	0f b6 45 bb	 movzx	 eax, BYTE PTR _hovered$[ebp]
  0017e	85 c0		 test	 eax, eax
  00180	74 52		 je	 SHORT $LN3@CloseButto

; 741  :         window->DrawList->AddCircleFilled(center, ImMax(2.0f, g.FontSize * 0.5f + 1.0f), col, 12);

  00182	6a 0c		 push	 12			; 0000000cH
  00184	8b 45 94	 mov	 eax, DWORD PTR _col$[ebp]
  00187	50		 push	 eax
  00188	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0018b	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  00193	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0019b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  001a3	51		 push	 ecx
  001a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a9	51		 push	 ecx
  001aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b7	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001bc	83 c4 04	 add	 esp, 4
  001bf	d9 1c 24	 fstp	 DWORD PTR [esp]
  001c2	8d 55 84	 lea	 edx, DWORD PTR _center$[ebp]
  001c5	52		 push	 edx
  001c6	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  001c9	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  001cf	e8 00 00 00 00	 call	 ?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
$LN3@CloseButto:

; 742  : 
; 743  :     float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;

  001d4	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  001d7	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  001df	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001e7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f350481
  001ef	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  001f7	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _cross_extent$[ebp], xmm0

; 744  :     ImU32 cross_col = GetColorU32(ImGuiCol_Text);

  001ff	51		 push	 ecx
  00200	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00208	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020d	6a 00		 push	 0
  0020f	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00214	83 c4 08	 add	 esp, 8
  00217	89 85 6c ff ff
	ff		 mov	 DWORD PTR _cross_col$[ebp], eax

; 745  :     center -= ImVec2(0.5f, 0.5f);

  0021d	51		 push	 ecx
  0021e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00226	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022b	51		 push	 ecx
  0022c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00234	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00239	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0023f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00244	50		 push	 eax
  00245	8d 45 84	 lea	 eax, DWORD PTR _center$[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 ??Z@YAAAUImVec2@@AAU0@ABU0@@Z ; operator-=
  0024e	83 c4 08	 add	 esp, 8

; 746  :     window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), cross_col, 1.0f);

  00251	51		 push	 ecx
  00252	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0025a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025f	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cross_col$[ebp]
  00265	50		 push	 eax
  00266	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  0026e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00275	51		 push	 ecx
  00276	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027b	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  00283	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0028a	51		 push	 ecx
  0028b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00290	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00296	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0029b	50		 push	 eax
  0029c	8d 4d 84	 lea	 ecx, DWORD PTR _center$[ebp]
  0029f	51		 push	 ecx
  002a0	8d 95 3c fe ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  002a6	52		 push	 edx
  002a7	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	50		 push	 eax
  002b0	51		 push	 ecx
  002b1	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  002b9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002be	51		 push	 ecx
  002bf	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  002c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002cc	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  002d2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002d7	50		 push	 eax
  002d8	8d 45 84	 lea	 eax, DWORD PTR _center$[ebp]
  002db	50		 push	 eax
  002dc	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  002e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002eb	50		 push	 eax
  002ec	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  002ef	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  002f5	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 747  :     window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), cross_col, 1.0f);

  002fa	51		 push	 ecx
  002fb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00303	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00308	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _cross_col$[ebp]
  0030e	50		 push	 eax
  0030f	51		 push	 ecx
  00310	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  00318	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0031d	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  00325	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0032c	51		 push	 ecx
  0032d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00332	8d 8d 0c fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00338	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0033d	50		 push	 eax
  0033e	8d 4d 84	 lea	 ecx, DWORD PTR _center$[ebp]
  00341	51		 push	 ecx
  00342	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00348	52		 push	 edx
  00349	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0034e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00351	50		 push	 eax
  00352	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  0035a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00361	51		 push	 ecx
  00362	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00367	51		 push	 ecx
  00368	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _cross_extent$[ebp]
  00370	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00375	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0037b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00380	50		 push	 eax
  00381	8d 45 84	 lea	 eax, DWORD PTR _center$[ebp]
  00384	50		 push	 eax
  00385	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0038b	51		 push	 ecx
  0038c	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH
  00394	50		 push	 eax
  00395	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  00398	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  0039e	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 748  : 
; 749  :     return pressed;

  003a3	8a 45 a3	 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@CloseButto:

; 750  : }

  003a6	52		 push	 edx
  003a7	8b cd		 mov	 ecx, ebp
  003a9	50		 push	 eax
  003aa	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@CloseButto
  003b0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003b5	58		 pop	 eax
  003b6	5a		 pop	 edx
  003b7	5f		 pop	 edi
  003b8	5e		 pop	 esi
  003b9	5b		 pop	 ebx
  003ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bd	33 cd		 xor	 ecx, ebp
  003bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c4	81 c4 2c 02 00
	00		 add	 esp, 556		; 0000022cH
  003ca	3b ec		 cmp	 ebp, esp
  003cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d1	8b e5		 mov	 esp, ebp
  003d3	5d		 pop	 ebp
  003d4	c3		 ret	 0
  003d5	0f 1f 00	 npad	 3
$LN14@CloseButto:
  003d8	04 00 00 00	 DD	 4
  003dc	00 00 00 00	 DD	 $LN13@CloseButto
$LN13@CloseButto:
  003e0	d0 ff ff ff	 DD	 -48			; ffffffd0H
  003e4	10 00 00 00	 DD	 16			; 00000010H
  003e8	00 00 00 00	 DD	 $LN9@CloseButto
  003ec	bb ff ff ff	 DD	 -69			; ffffffbbH
  003f0	01 00 00 00	 DD	 1
  003f4	00 00 00 00	 DD	 $LN10@CloseButto
  003f8	af ff ff ff	 DD	 -81			; ffffffafH
  003fc	01 00 00 00	 DD	 1
  00400	00 00 00 00	 DD	 $LN11@CloseButto
  00404	84 ff ff ff	 DD	 -124			; ffffff84H
  00408	08 00 00 00	 DD	 8
  0040c	00 00 00 00	 DD	 $LN12@CloseButto
$LN12@CloseButto:
  00410	63		 DB	 99			; 00000063H
  00411	65		 DB	 101			; 00000065H
  00412	6e		 DB	 110			; 0000006eH
  00413	74		 DB	 116			; 00000074H
  00414	65		 DB	 101			; 00000065H
  00415	72		 DB	 114			; 00000072H
  00416	00		 DB	 0
$LN11@CloseButto:
  00417	68		 DB	 104			; 00000068H
  00418	65		 DB	 101			; 00000065H
  00419	6c		 DB	 108			; 0000006cH
  0041a	64		 DB	 100			; 00000064H
  0041b	00		 DB	 0
$LN10@CloseButto:
  0041c	68		 DB	 104			; 00000068H
  0041d	6f		 DB	 111			; 0000006fH
  0041e	76		 DB	 118			; 00000076H
  0041f	65		 DB	 101			; 00000065H
  00420	72		 DB	 114			; 00000072H
  00421	65		 DB	 101			; 00000065H
  00422	64		 DB	 100			; 00000064H
  00423	00		 DB	 0
$LN9@CloseButto:
  00424	62		 DB	 98			; 00000062H
  00425	62		 DB	 98			; 00000062H
  00426	00		 DB	 0
?CloseButton@ImGui@@YA_NIABUImVec2@@@Z ENDP		; ImGui::CloseButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z
_TEXT	SEGMENT
tv174 = -420						; size = 4
tv175 = -416						; size = 4
$T1 = -408						; size = 8
$T2 = -392						; size = 8
$T3 = -376						; size = 8
_col$ = -168						; size = 4
_pressed$ = -153					; size = 1
_held$ = -141						; size = 1
_hovered$ = -129					; size = 1
_bb$ = -120						; size = 16
_size$ = -96						; size = 8
_pos$ = -80						; size = 8
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_size_arg$ = 12						; size = 4
_flags$ = 16						; size = 4
?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z PROC		; ImGui::ButtonEx, COMDAT

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 5c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-420]
  00012	b9 69 00 00 00	 mov	 ecx, 105		; 00000069H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 607  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 608  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN5@ButtonEx

; 609  :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 92 02 00 00	 jmp	 $LN1@ButtonEx
$LN5@ButtonEx:

; 610  : 
; 611  :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 612  :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 613  :     const ImGuiID id = window->GetID(label);

  0005f	6a 00		 push	 0
  00061	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00068	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0006d	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 614  :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  00070	51		 push	 ecx
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	6a 01		 push	 1
  00080	6a 00		 push	 0
  00082	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00085	50		 push	 eax
  00086	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0008f	83 c4 14	 add	 esp, 20			; 00000014H

; 615  : 
; 616  :     ImVec2 pos = window->DC.CursorPos;

  00092	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00095	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0009b	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  000a1	89 4d b0	 mov	 DWORD PTR _pos$[ebp], ecx
  000a4	89 55 b4	 mov	 DWORD PTR _pos$[ebp+4], edx

; 617  :     if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)

  000a7	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000aa	25 00 02 00 00	 and	 eax, 512		; 00000200H
  000af	74 31		 je	 SHORT $LN6@ButtonEx
  000b1	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000b4	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  000b7	f3 0f 10 80 f8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+248]
  000bf	0f 2f 41 3c	 comiss	 xmm0, DWORD PTR [ecx+60]
  000c3	76 1d		 jbe	 SHORT $LN6@ButtonEx

; 618  :         pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;

  000c5	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000c8	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  000cb	f3 0f 10 80 f8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+248]
  000d3	f3 0f 5c 41 3c	 subss	 xmm0, DWORD PTR [ecx+60]
  000d8	f3 0f 58 45 b4	 addss	 xmm0, DWORD PTR _pos$[ebp+4]
  000dd	f3 0f 11 45 b4	 movss	 DWORD PTR _pos$[ebp+4], xmm0
$LN6@ButtonEx:

; 619  :     ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

  000e2	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000e5	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  000ea	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000f2	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000f7	51		 push	 ecx
  000f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fd	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00100	f3 0f 10 41 38	 movss	 xmm0, DWORD PTR [ecx+56]
  00105	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0010d	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  00112	51		 push	 ecx
  00113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00118	8b 55 0c	 mov	 edx, DWORD PTR _size_arg$[ebp]
  0011b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011e	50		 push	 eax
  0011f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00121	51		 push	 ecx
  00122	8d 55 a0	 lea	 edx, DWORD PTR _size$[ebp]
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 ?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
  0012b	83 c4 14	 add	 esp, 20			; 00000014H

; 620  : 
; 621  :     const ImRect bb(pos, pos + size);

  0012e	8d 45 a0	 lea	 eax, DWORD PTR _size$[ebp]
  00131	50		 push	 eax
  00132	8d 4d b0	 lea	 ecx, DWORD PTR _pos$[ebp]
  00135	51		 push	 ecx
  00136	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0013c	52		 push	 edx
  0013d	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
  00145	50		 push	 eax
  00146	8d 45 b0	 lea	 eax, DWORD PTR _pos$[ebp]
  00149	50		 push	 eax
  0014a	8d 4d 88	 lea	 ecx, DWORD PTR _bb$[ebp]
  0014d	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 622  :     ItemSize(size, style.FramePadding.y);

  00152	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00155	51		 push	 ecx
  00156	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0015b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00160	8d 4d a0	 lea	 ecx, DWORD PTR _size$[ebp]
  00163	51		 push	 ecx
  00164	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  00169	83 c4 08	 add	 esp, 8

; 623  :     if (!ItemAdd(bb, id))

  0016c	6a 00		 push	 0
  0016e	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00171	50		 push	 eax
  00172	8d 4d 88	 lea	 ecx, DWORD PTR _bb$[ebp]
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0017b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017e	0f b6 d0	 movzx	 edx, al
  00181	85 d2		 test	 edx, edx
  00183	75 07		 jne	 SHORT $LN7@ButtonEx

; 624  :         return false;

  00185	32 c0		 xor	 al, al
  00187	e9 52 01 00 00	 jmp	 $LN1@ButtonEx
$LN7@ButtonEx:

; 625  : 
; 626  :     if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)

  0018c	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0018f	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00195	83 e1 02	 and	 ecx, 2
  00198	74 09		 je	 SHORT $LN8@ButtonEx

; 627  :         flags |= ImGuiButtonFlags_Repeat;

  0019a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0019d	83 c8 01	 or	 eax, 1
  001a0	89 45 10	 mov	 DWORD PTR _flags$[ebp], eax
$LN8@ButtonEx:

; 628  :     bool hovered, held;
; 629  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

  001a3	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001a6	50		 push	 eax
  001a7	8d 8d 73 ff ff
	ff		 lea	 ecx, DWORD PTR _held$[ebp]
  001ad	51		 push	 ecx
  001ae	8d 95 7f ff ff
	ff		 lea	 edx, DWORD PTR _hovered$[ebp]
  001b4	52		 push	 edx
  001b5	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  001b8	50		 push	 eax
  001b9	8d 4d 88	 lea	 ecx, DWORD PTR _bb$[ebp]
  001bc	51		 push	 ecx
  001bd	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  001c2	83 c4 14	 add	 esp, 20			; 00000014H
  001c5	88 85 67 ff ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 630  : 
; 631  :     // Render
; 632  :     const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

  001cb	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  001d2	85 c0		 test	 eax, eax
  001d4	74 17		 je	 SHORT $LN10@ButtonEx
  001d6	0f b6 8d 7f ff
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  001dd	85 c9		 test	 ecx, ecx
  001df	74 0c		 je	 SHORT $LN10@ButtonEx
  001e1	c7 85 60 fe ff
	ff 17 00 00 00	 mov	 DWORD PTR tv175[ebp], 23 ; 00000017H
  001eb	eb 2d		 jmp	 SHORT $LN13@ButtonEx
$LN10@ButtonEx:
  001ed	0f b6 95 7f ff
	ff ff		 movzx	 edx, BYTE PTR _hovered$[ebp]
  001f4	85 d2		 test	 edx, edx
  001f6	74 0c		 je	 SHORT $LN11@ButtonEx
  001f8	c7 85 5c fe ff
	ff 16 00 00 00	 mov	 DWORD PTR tv174[ebp], 22 ; 00000016H
  00202	eb 0a		 jmp	 SHORT $LN12@ButtonEx
$LN11@ButtonEx:
  00204	c7 85 5c fe ff
	ff 15 00 00 00	 mov	 DWORD PTR tv174[ebp], 21 ; 00000015H
$LN12@ButtonEx:
  0020e	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv174[ebp]
  00214	89 85 60 fe ff
	ff		 mov	 DWORD PTR tv175[ebp], eax
$LN13@ButtonEx:
  0021a	51		 push	 ecx
  0021b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00223	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00228	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR tv175[ebp]
  0022e	51		 push	 ecx
  0022f	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00234	83 c4 08	 add	 esp, 8
  00237	89 85 58 ff ff
	ff		 mov	 DWORD PTR _col$[ebp], eax

; 633  :     RenderNavHighlight(bb, id);

  0023d	6a 01		 push	 1
  0023f	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00242	50		 push	 eax
  00243	8d 4d 88	 lea	 ecx, DWORD PTR _bb$[ebp]
  00246	51		 push	 ecx
  00247	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  0024c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 634  :     RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

  0024f	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00252	51		 push	 ecx
  00253	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00258	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025d	6a 01		 push	 1
  0025f	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _col$[ebp]
  00265	51		 push	 ecx
  00266	8b 55 94	 mov	 edx, DWORD PTR _bb$[ebp+12]
  00269	52		 push	 edx
  0026a	8b 45 90	 mov	 eax, DWORD PTR _bb$[ebp+8]
  0026d	50		 push	 eax
  0026e	8b 4d 8c	 mov	 ecx, DWORD PTR _bb$[ebp+4]
  00271	51		 push	 ecx
  00272	8b 55 88	 mov	 edx, DWORD PTR _bb$[ebp]
  00275	52		 push	 edx
  00276	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  0027b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 635  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

  0027e	8d 45 88	 lea	 eax, DWORD PTR _bb$[ebp]
  00281	50		 push	 eax
  00282	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00285	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0028b	51		 push	 ecx
  0028c	8d 55 c0	 lea	 edx, DWORD PTR _label_size$[ebp]
  0028f	52		 push	 edx
  00290	6a 00		 push	 0
  00292	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00295	50		 push	 eax
  00296	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00299	83 c1 38	 add	 ecx, 56			; 00000038H
  0029c	51		 push	 ecx
  0029d	8d 55 90	 lea	 edx, DWORD PTR _bb$[ebp+8]
  002a0	52		 push	 edx
  002a1	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  002a7	50		 push	 eax
  002a8	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  002ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b0	50		 push	 eax
  002b1	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  002b4	83 c1 38	 add	 ecx, 56			; 00000038H
  002b7	51		 push	 ecx
  002b8	8d 55 88	 lea	 edx, DWORD PTR _bb$[ebp]
  002bb	52		 push	 edx
  002bc	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  002c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002cb	50		 push	 eax
  002cc	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  002d1	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN4@ButtonEx:

; 636  : 
; 637  :     // Automatically close popups
; 638  :     //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
; 639  :     //    CloseCurrentPopup();
; 640  : 
; 641  :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.LastItemStatusFlags);

  002d4	33 c0		 xor	 eax, eax
  002d6	75 fc		 jne	 SHORT $LN4@ButtonEx

; 642  :     return pressed;

  002d8	8a 85 67 ff ff
	ff		 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@ButtonEx:

; 643  : }

  002de	52		 push	 edx
  002df	8b cd		 mov	 ecx, ebp
  002e1	50		 push	 eax
  002e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@ButtonEx
  002e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002ed	58		 pop	 eax
  002ee	5a		 pop	 edx
  002ef	5f		 pop	 edi
  002f0	5e		 pop	 esi
  002f1	5b		 pop	 ebx
  002f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f5	33 cd		 xor	 ecx, ebp
  002f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fc	81 c4 a4 01 00
	00		 add	 esp, 420		; 000001a4H
  00302	3b ec		 cmp	 ebp, esp
  00304	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00309	8b e5		 mov	 esp, ebp
  0030b	5d		 pop	 ebp
  0030c	c3		 ret	 0
  0030d	0f 1f 00	 npad	 3
$LN21@ButtonEx:
  00310	06 00 00 00	 DD	 6
  00314	00 00 00 00	 DD	 $LN20@ButtonEx
$LN20@ButtonEx:
  00318	c0 ff ff ff	 DD	 -64			; ffffffc0H
  0031c	08 00 00 00	 DD	 8
  00320	00 00 00 00	 DD	 $LN14@ButtonEx
  00324	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00328	08 00 00 00	 DD	 8
  0032c	00 00 00 00	 DD	 $LN15@ButtonEx
  00330	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00334	08 00 00 00	 DD	 8
  00338	00 00 00 00	 DD	 $LN16@ButtonEx
  0033c	88 ff ff ff	 DD	 -120			; ffffff88H
  00340	10 00 00 00	 DD	 16			; 00000010H
  00344	00 00 00 00	 DD	 $LN17@ButtonEx
  00348	7f ff ff ff	 DD	 -129			; ffffff7fH
  0034c	01 00 00 00	 DD	 1
  00350	00 00 00 00	 DD	 $LN18@ButtonEx
  00354	73 ff ff ff	 DD	 -141			; ffffff73H
  00358	01 00 00 00	 DD	 1
  0035c	00 00 00 00	 DD	 $LN19@ButtonEx
$LN19@ButtonEx:
  00360	68		 DB	 104			; 00000068H
  00361	65		 DB	 101			; 00000065H
  00362	6c		 DB	 108			; 0000006cH
  00363	64		 DB	 100			; 00000064H
  00364	00		 DB	 0
$LN18@ButtonEx:
  00365	68		 DB	 104			; 00000068H
  00366	6f		 DB	 111			; 0000006fH
  00367	76		 DB	 118			; 00000076H
  00368	65		 DB	 101			; 00000065H
  00369	72		 DB	 114			; 00000072H
  0036a	65		 DB	 101			; 00000065H
  0036b	64		 DB	 100			; 00000064H
  0036c	00		 DB	 0
$LN17@ButtonEx:
  0036d	62		 DB	 98			; 00000062H
  0036e	62		 DB	 98			; 00000062H
  0036f	00		 DB	 0
$LN16@ButtonEx:
  00370	73		 DB	 115			; 00000073H
  00371	69		 DB	 105			; 00000069H
  00372	7a		 DB	 122			; 0000007aH
  00373	65		 DB	 101			; 00000065H
  00374	00		 DB	 0
$LN15@ButtonEx:
  00375	70		 DB	 112			; 00000070H
  00376	6f		 DB	 111			; 0000006fH
  00377	73		 DB	 115			; 00000073H
  00378	00		 DB	 0
$LN14@ButtonEx:
  00379	6c		 DB	 108			; 0000006cH
  0037a	61		 DB	 97			; 00000061H
  0037b	62		 DB	 98			; 00000062H
  0037c	65		 DB	 101			; 00000065H
  0037d	6c		 DB	 108			; 0000006cH
  0037e	5f		 DB	 95			; 0000005fH
  0037f	73		 DB	 115			; 00000073H
  00380	69		 DB	 105			; 00000069H
  00381	7a		 DB	 122			; 0000007aH
  00382	65		 DB	 101			; 00000065H
  00383	00		 DB	 0
?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z ENDP		; ImGui::ButtonEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextEx@ImGui@@YAXPBD0H@Z
_TEXT	SEGMENT
tv293 = -632						; size = 4
tv93 = -629						; size = 1
$T1 = -624						; size = 8
$T2 = -608						; size = 8
$T3 = -592						; size = 8
$T4 = -576						; size = 8
$T5 = -560						; size = 8
$T6 = -544						; size = 8
$T7 = -528						; size = 8
$T8 = -512						; size = 8
_bb$9 = -304						; size = 16
_text_size$10 = -280					; size = 8
_wrap_width$11 = -264					; size = 4
_bb$12 = -252						; size = 16
_line_end$13 = -228					; size = 4
_lines_skipped$14 = -216				; size = 4
_line_end$15 = -204					; size = 4
_line_rect$16 = -192					; size = 16
_line_end$17 = -168					; size = 4
_lines_skipped$18 = -156				; size = 4
_lines_skippable$19 = -144				; size = 4
_pos$20 = -132						; size = 8
_text_size$21 = -116					; size = 8
_line_height$22 = -100					; size = 4
_line$23 = -88						; size = 4
_wrap_enabled$ = -73					; size = 1
_wrap_pos_x$ = -64					; size = 4
_text_pos$ = -52					; size = 8
_text_begin$ = -36					; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_text_end$ = 12						; size = 4
_flags$ = 16						; size = 4
?TextEx@ImGui@@YAXPBD0H@Z PROC				; ImGui::TextEx, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 02 00
	00		 sub	 esp, 632		; 00000278H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 88 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-632]
  00012	b9 9e 00 00 00	 mov	 ecx, 158		; 0000009eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 133  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 134  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN8@TextEx

; 135  :         return;

  00045	e9 cd 05 00 00	 jmp	 $LN1@TextEx
$LN8@TextEx:

; 136  : 
; 137  :     ImGuiContext& g = *GImGui;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004f	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 138  :     IM_ASSERT(text != NULL);

  00052	83 7d 08 00	 cmp	 DWORD PTR _text$[ebp], 0
  00056	75 25		 jne	 SHORT $LN23@TextEx
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??TextEx@ImGui@@YAXPBD0H@Z@4JA
  0005d	83 c0 06	 add	 eax, 6
  00060	8b f4		 mov	 esi, esp
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@HMGDGFIB@?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN23@TextEx:

; 139  :     const char* text_begin = text;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  00080	89 45 dc	 mov	 DWORD PTR _text_begin$[ebp], eax

; 140  :     if (text_end == NULL)

  00083	83 7d 0c 00	 cmp	 DWORD PTR _text_end$[ebp], 0
  00087	75 12		 jne	 SHORT $LN9@TextEx

; 141  :         text_end = text + strlen(text); // FIXME-OPT

  00089	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _strlen
  00092	83 c4 04	 add	 esp, 4
  00095	03 45 08	 add	 eax, DWORD PTR _text$[ebp]
  00098	89 45 0c	 mov	 DWORD PTR _text_end$[ebp], eax
$LN9@TextEx:

; 142  : 
; 143  :     const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000a1	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  000a9	f3 0f 58 81 f8
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+248]
  000b1	51		 push	 ecx
  000b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b7	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  000ba	51		 push	 ecx
  000bb	f3 0f 10 82 c8
	00 00 00	 movss	 xmm0, DWORD PTR [edx+200]
  000c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c8	8d 4d cc	 lea	 ecx, DWORD PTR _text_pos$[ebp]
  000cb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 144  :     const float wrap_pos_x = window->DC.TextWrapPos;

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000d3	f3 0f 10 80 74
	01 00 00	 movss	 xmm0, DWORD PTR [eax+372]
  000db	f3 0f 11 45 c0	 movss	 DWORD PTR _wrap_pos_x$[ebp], xmm0

; 145  :     const bool wrap_enabled = (wrap_pos_x >= 0.0f);

  000e0	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _wrap_pos_x$[ebp]
  000e5	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000ec	72 09		 jb	 SHORT $LN24@TextEx
  000ee	c6 85 8b fd ff
	ff 01		 mov	 BYTE PTR tv93[ebp], 1
  000f5	eb 07		 jmp	 SHORT $LN25@TextEx
$LN24@TextEx:
  000f7	c6 85 8b fd ff
	ff 00		 mov	 BYTE PTR tv93[ebp], 0
$LN25@TextEx:
  000fe	8a 85 8b fd ff
	ff		 mov	 al, BYTE PTR tv93[ebp]
  00104	88 45 b7	 mov	 BYTE PTR _wrap_enabled$[ebp], al

; 146  :     if (text_end - text > 2000 && !wrap_enabled)

  00107	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  0010a	2b 45 08	 sub	 eax, DWORD PTR _text$[ebp]
  0010d	3d d0 07 00 00	 cmp	 eax, 2000		; 000007d0H
  00112	0f 8e 06 04 00
	00		 jle	 $LN10@TextEx
  00118	0f b6 45 b7	 movzx	 eax, BYTE PTR _wrap_enabled$[ebp]
  0011c	85 c0		 test	 eax, eax
  0011e	0f 85 fa 03 00
	00		 jne	 $LN10@TextEx

; 147  :     {
; 148  :         // Long text!
; 149  :         // Perform manual coarse clipping to optimize for long multi-line text
; 150  :         // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
; 151  :         // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
; 152  :         // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
; 153  :         const char* line = text;

  00124	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  00127	89 45 a8	 mov	 DWORD PTR _line$23[ebp], eax

; 154  :         const float line_height = GetTextLineHeight();

  0012a	e8 00 00 00 00	 call	 ?GetTextLineHeight@ImGui@@YAMXZ ; ImGui::GetTextLineHeight
  0012f	d9 5d 9c	 fstp	 DWORD PTR _line_height$22[ebp]

; 155  :         ImVec2 text_size(0,0);

  00132	51		 push	 ecx
  00133	0f 57 c0	 xorps	 xmm0, xmm0
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	51		 push	 ecx
  0013c	0f 57 c0	 xorps	 xmm0, xmm0
  0013f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00144	8d 4d 8c	 lea	 ecx, DWORD PTR _text_size$21[ebp]
  00147	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 156  : 
; 157  :         // Lines to skip (can't skip when logging text)
; 158  :         ImVec2 pos = text_pos;

  0014c	8b 45 cc	 mov	 eax, DWORD PTR _text_pos$[ebp]
  0014f	89 85 7c ff ff
	ff		 mov	 DWORD PTR _pos$20[ebp], eax
  00155	8b 4d d0	 mov	 ecx, DWORD PTR _text_pos$[ebp+4]
  00158	89 4d 80	 mov	 DWORD PTR _pos$20[ebp+4], ecx

; 159  :         if (!g.LogEnabled)

  0015b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0015e	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  00165	85 c9		 test	 ecx, ecx
  00167	0f 85 09 01 00
	00		 jne	 $LN13@TextEx

; 160  :         {
; 161  :             int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);

  0016d	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00170	f3 0f 10 80 08
	02 00 00	 movss	 xmm0, DWORD PTR [eax+520]
  00178	f3 0f 5c 45 d0	 subss	 xmm0, DWORD PTR _text_pos$[ebp+4]
  0017d	f3 0f 5e 45 9c	 divss	 xmm0, DWORD PTR _line_height$22[ebp]
  00182	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00186	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _lines_skippable$19[ebp], ecx

; 162  :             if (lines_skippable > 0)

  0018c	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _lines_skippable$19[ebp], 0
  00193	0f 8e dd 00 00
	00		 jle	 $LN13@TextEx

; 163  :             {
; 164  :                 int lines_skipped = 0;

  00199	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _lines_skipped$18[ebp], 0
$LN2@TextEx:

; 165  :                 while (line < text_end && lines_skipped < lines_skippable)

  001a3	8b 45 a8	 mov	 eax, DWORD PTR _line$23[ebp]
  001a6	3b 45 0c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  001a9	0f 83 b0 00 00
	00		 jae	 $LN3@TextEx
  001af	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _lines_skipped$18[ebp]
  001b5	3b 85 70 ff ff
	ff		 cmp	 eax, DWORD PTR _lines_skippable$19[ebp]
  001bb	0f 8d 9e 00 00
	00		 jge	 $LN3@TextEx

; 166  :                 {
; 167  :                     const char* line_end = (const char*)memchr(line, '\n', text_end - line);

  001c1	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  001c4	2b 45 a8	 sub	 eax, DWORD PTR _line$23[ebp]
  001c7	50		 push	 eax
  001c8	6a 0a		 push	 10			; 0000000aH
  001ca	8b 4d a8	 mov	 ecx, DWORD PTR _line$23[ebp]
  001cd	51		 push	 ecx
  001ce	e8 00 00 00 00	 call	 _memchr
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d6	89 85 58 ff ff
	ff		 mov	 DWORD PTR _line_end$17[ebp], eax

; 168  :                     if (!line_end)

  001dc	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _line_end$17[ebp], 0
  001e3	75 09		 jne	 SHORT $LN14@TextEx

; 169  :                         line_end = text_end;

  001e5	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  001e8	89 85 58 ff ff
	ff		 mov	 DWORD PTR _line_end$17[ebp], eax
$LN14@TextEx:

; 170  :                     if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)

  001ee	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001f1	83 e0 01	 and	 eax, 1
  001f4	75 49		 jne	 SHORT $LN15@TextEx

; 171  :                         text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);

  001f6	51		 push	 ecx
  001f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00204	6a 00		 push	 0
  00206	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _line_end$17[ebp]
  0020c	50		 push	 eax
  0020d	8b 4d a8	 mov	 ecx, DWORD PTR _line$23[ebp]
  00210	51		 push	 ecx
  00211	8d 95 00 fe ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00217	52		 push	 edx
  00218	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0021d	83 c4 10	 add	 esp, 16			; 00000010H
  00220	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00224	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00229	51		 push	 ecx
  0022a	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _text_size$21[ebp]
  0022f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00234	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00239	83 c4 08	 add	 esp, 8
  0023c	d9 5d 8c	 fstp	 DWORD PTR _text_size$21[ebp]
$LN15@TextEx:

; 172  :                     line = line_end + 1;

  0023f	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _line_end$17[ebp]
  00245	83 c0 01	 add	 eax, 1
  00248	89 45 a8	 mov	 DWORD PTR _line$23[ebp], eax

; 173  :                     lines_skipped++;

  0024b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _lines_skipped$18[ebp]
  00251	83 c0 01	 add	 eax, 1
  00254	89 85 64 ff ff
	ff		 mov	 DWORD PTR _lines_skipped$18[ebp], eax

; 174  :                 }

  0025a	e9 44 ff ff ff	 jmp	 $LN2@TextEx
$LN3@TextEx:

; 175  :                 pos.y += lines_skipped * line_height;

  0025f	f3 0f 2a 85 64
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _lines_skipped$18[ebp]
  00267	f3 0f 59 45 9c	 mulss	 xmm0, DWORD PTR _line_height$22[ebp]
  0026c	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _pos$20[ebp+4]
  00271	f3 0f 11 45 80	 movss	 DWORD PTR _pos$20[ebp+4], xmm0
$LN13@TextEx:

; 176  :             }
; 177  :         }
; 178  : 
; 179  :         // Lines to render
; 180  :         if (line < text_end)

  00276	8b 45 a8	 mov	 eax, DWORD PTR _line$23[ebp]
  00279	3b 45 0c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  0027c	0f 83 24 02 00
	00		 jae	 $LN16@TextEx

; 181  :         {
; 182  :             ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));

  00282	51		 push	 ecx
  00283	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _line_height$22[ebp]
  00288	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028d	51		 push	 ecx
  0028e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00296	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029b	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  002a1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002a6	50		 push	 eax
  002a7	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _pos$20[ebp]
  002ad	50		 push	 eax
  002ae	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  002b4	51		 push	 ecx
  002b5	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  002ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bd	50		 push	 eax
  002be	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _pos$20[ebp]
  002c4	52		 push	 edx
  002c5	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _line_rect$16[ebp]
  002cb	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect
$LN4@TextEx:

; 183  :             while (line < text_end)

  002d0	8b 45 a8	 mov	 eax, DWORD PTR _line$23[ebp]
  002d3	3b 45 0c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  002d6	0f 83 ff 00 00
	00		 jae	 $LN5@TextEx

; 184  :             {
; 185  :                 if (IsClippedEx(line_rect, 0, false))

  002dc	6a 00		 push	 0
  002de	6a 00		 push	 0
  002e0	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _line_rect$16[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 ?IsClippedEx@ImGui@@YA_NABUImRect@@I_N@Z ; ImGui::IsClippedEx
  002ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ef	0f b6 c8	 movzx	 ecx, al
  002f2	85 c9		 test	 ecx, ecx
  002f4	74 05		 je	 SHORT $LN17@TextEx

; 186  :                     break;

  002f6	e9 e0 00 00 00	 jmp	 $LN5@TextEx
$LN17@TextEx:

; 187  : 
; 188  :                 const char* line_end = (const char*)memchr(line, '\n', text_end - line);

  002fb	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  002fe	2b 45 a8	 sub	 eax, DWORD PTR _line$23[ebp]
  00301	50		 push	 eax
  00302	6a 0a		 push	 10			; 0000000aH
  00304	8b 4d a8	 mov	 ecx, DWORD PTR _line$23[ebp]
  00307	51		 push	 ecx
  00308	e8 00 00 00 00	 call	 _memchr
  0030d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00310	89 85 34 ff ff
	ff		 mov	 DWORD PTR _line_end$15[ebp], eax

; 189  :                 if (!line_end)

  00316	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR _line_end$15[ebp], 0
  0031d	75 09		 jne	 SHORT $LN18@TextEx

; 190  :                     line_end = text_end;

  0031f	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  00322	89 85 34 ff ff
	ff		 mov	 DWORD PTR _line_end$15[ebp], eax
$LN18@TextEx:

; 191  :                 text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);

  00328	51		 push	 ecx
  00329	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00331	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00336	6a 00		 push	 0
  00338	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _line_end$15[ebp]
  0033e	50		 push	 eax
  0033f	8b 4d a8	 mov	 ecx, DWORD PTR _line$23[ebp]
  00342	51		 push	 ecx
  00343	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00349	52		 push	 edx
  0034a	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0034f	83 c4 10	 add	 esp, 16			; 00000010H
  00352	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00356	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035b	51		 push	 ecx
  0035c	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _text_size$21[ebp]
  00361	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00366	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0036b	83 c4 08	 add	 esp, 8
  0036e	d9 5d 8c	 fstp	 DWORD PTR _text_size$21[ebp]

; 192  :                 RenderText(pos, line, line_end, false);

  00371	6a 00		 push	 0
  00373	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _line_end$15[ebp]
  00379	50		 push	 eax
  0037a	8b 4d a8	 mov	 ecx, DWORD PTR _line$23[ebp]
  0037d	51		 push	 ecx
  0037e	8b 55 80	 mov	 edx, DWORD PTR _pos$20[ebp+4]
  00381	52		 push	 edx
  00382	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _pos$20[ebp]
  00388	50		 push	 eax
  00389	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  0038e	83 c4 14	 add	 esp, 20			; 00000014H

; 193  :                 line = line_end + 1;

  00391	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _line_end$15[ebp]
  00397	83 c0 01	 add	 eax, 1
  0039a	89 45 a8	 mov	 DWORD PTR _line$23[ebp], eax

; 194  :                 line_rect.Min.y += line_height;

  0039d	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _line_rect$16[ebp+4]
  003a5	f3 0f 58 45 9c	 addss	 xmm0, DWORD PTR _line_height$22[ebp]
  003aa	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _line_rect$16[ebp+4], xmm0

; 195  :                 line_rect.Max.y += line_height;

  003b2	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _line_rect$16[ebp+12]
  003ba	f3 0f 58 45 9c	 addss	 xmm0, DWORD PTR _line_height$22[ebp]
  003bf	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _line_rect$16[ebp+12], xmm0

; 196  :                 pos.y += line_height;

  003c7	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _pos$20[ebp+4]
  003cc	f3 0f 58 45 9c	 addss	 xmm0, DWORD PTR _line_height$22[ebp]
  003d1	f3 0f 11 45 80	 movss	 DWORD PTR _pos$20[ebp+4], xmm0

; 197  :             }

  003d6	e9 f5 fe ff ff	 jmp	 $LN4@TextEx
$LN5@TextEx:

; 198  : 
; 199  :             // Count remaining lines
; 200  :             int lines_skipped = 0;

  003db	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _lines_skipped$14[ebp], 0
$LN6@TextEx:

; 201  :             while (line < text_end)

  003e5	8b 45 a8	 mov	 eax, DWORD PTR _line$23[ebp]
  003e8	3b 45 0c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  003eb	0f 83 9e 00 00
	00		 jae	 $LN7@TextEx

; 202  :             {
; 203  :                 const char* line_end = (const char*)memchr(line, '\n', text_end - line);

  003f1	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  003f4	2b 45 a8	 sub	 eax, DWORD PTR _line$23[ebp]
  003f7	50		 push	 eax
  003f8	6a 0a		 push	 10			; 0000000aH
  003fa	8b 4d a8	 mov	 ecx, DWORD PTR _line$23[ebp]
  003fd	51		 push	 ecx
  003fe	e8 00 00 00 00	 call	 _memchr
  00403	83 c4 0c	 add	 esp, 12			; 0000000cH
  00406	89 85 1c ff ff
	ff		 mov	 DWORD PTR _line_end$13[ebp], eax

; 204  :                 if (!line_end)

  0040c	83 bd 1c ff ff
	ff 00		 cmp	 DWORD PTR _line_end$13[ebp], 0
  00413	75 09		 jne	 SHORT $LN19@TextEx

; 205  :                     line_end = text_end;

  00415	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  00418	89 85 1c ff ff
	ff		 mov	 DWORD PTR _line_end$13[ebp], eax
$LN19@TextEx:

; 206  :                 if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)

  0041e	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00421	83 e0 01	 and	 eax, 1
  00424	75 49		 jne	 SHORT $LN20@TextEx

; 207  :                     text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);

  00426	51		 push	 ecx
  00427	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0042f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00434	6a 00		 push	 0
  00436	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _line_end$13[ebp]
  0043c	50		 push	 eax
  0043d	8b 4d a8	 mov	 ecx, DWORD PTR _line$23[ebp]
  00440	51		 push	 ecx
  00441	8d 95 c0 fd ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00447	52		 push	 edx
  00448	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0044d	83 c4 10	 add	 esp, 16			; 00000010H
  00450	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00454	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00459	51		 push	 ecx
  0045a	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _text_size$21[ebp]
  0045f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00464	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00469	83 c4 08	 add	 esp, 8
  0046c	d9 5d 8c	 fstp	 DWORD PTR _text_size$21[ebp]
$LN20@TextEx:

; 208  :                 line = line_end + 1;

  0046f	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _line_end$13[ebp]
  00475	83 c0 01	 add	 eax, 1
  00478	89 45 a8	 mov	 DWORD PTR _line$23[ebp], eax

; 209  :                 lines_skipped++;

  0047b	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _lines_skipped$14[ebp]
  00481	83 c0 01	 add	 eax, 1
  00484	89 85 28 ff ff
	ff		 mov	 DWORD PTR _lines_skipped$14[ebp], eax

; 210  :             }

  0048a	e9 56 ff ff ff	 jmp	 $LN6@TextEx
$LN7@TextEx:

; 211  :             pos.y += lines_skipped * line_height;

  0048f	f3 0f 2a 85 28
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _lines_skipped$14[ebp]
  00497	f3 0f 59 45 9c	 mulss	 xmm0, DWORD PTR _line_height$22[ebp]
  0049c	f3 0f 58 45 80	 addss	 xmm0, DWORD PTR _pos$20[ebp+4]
  004a1	f3 0f 11 45 80	 movss	 DWORD PTR _pos$20[ebp+4], xmm0
$LN16@TextEx:

; 212  :         }
; 213  :         text_size.y = (pos - text_pos).y;

  004a6	8d 45 cc	 lea	 eax, DWORD PTR _text_pos$[ebp]
  004a9	50		 push	 eax
  004aa	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pos$20[ebp]
  004b0	51		 push	 ecx
  004b1	8d 95 b0 fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  004b7	52		 push	 edx
  004b8	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  004bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c0	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004c5	f3 0f 11 45 90	 movss	 DWORD PTR _text_size$21[ebp+4], xmm0

; 214  : 
; 215  :         ImRect bb(text_pos, text_pos + text_size);

  004ca	8d 45 8c	 lea	 eax, DWORD PTR _text_size$21[ebp]
  004cd	50		 push	 eax
  004ce	8d 4d cc	 lea	 ecx, DWORD PTR _text_pos$[ebp]
  004d1	51		 push	 ecx
  004d2	8d 95 a0 fd ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  004d8	52		 push	 edx
  004d9	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  004de	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e1	50		 push	 eax
  004e2	8d 45 cc	 lea	 eax, DWORD PTR _text_pos$[ebp]
  004e5	50		 push	 eax
  004e6	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$12[ebp]
  004ec	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 216  :         ItemSize(text_size, 0.0f);

  004f1	51		 push	 ecx
  004f2	0f 57 c0	 xorps	 xmm0, xmm0
  004f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004fa	8d 45 8c	 lea	 eax, DWORD PTR _text_size$21[ebp]
  004fd	50		 push	 eax
  004fe	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  00503	83 c4 08	 add	 esp, 8

; 217  :         ItemAdd(bb, 0);

  00506	6a 00		 push	 0
  00508	6a 00		 push	 0
  0050a	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _bb$12[ebp]
  00510	50		 push	 eax
  00511	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00516	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  :     }

  00519	e9 f9 00 00 00	 jmp	 $LN11@TextEx
$LN10@TextEx:

; 219  :     else
; 220  :     {
; 221  :         const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;

  0051e	0f b6 45 b7	 movzx	 eax, BYTE PTR _wrap_enabled$[ebp]
  00522	85 c0		 test	 eax, eax
  00524	74 25		 je	 SHORT $LN26@TextEx
  00526	51		 push	 ecx
  00527	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _wrap_pos_x$[ebp]
  0052c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00531	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00534	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  0053a	51		 push	 ecx
  0053b	e8 00 00 00 00	 call	 ?CalcWrapWidthForPos@ImGui@@YAMABUImVec2@@M@Z ; ImGui::CalcWrapWidthForPos
  00540	83 c4 08	 add	 esp, 8
  00543	d9 9d 88 fd ff
	ff		 fstp	 DWORD PTR tv293[ebp]
  00549	eb 0b		 jmp	 SHORT $LN27@TextEx
$LN26@TextEx:
  0054b	0f 57 c0	 xorps	 xmm0, xmm0
  0054e	f3 0f 11 85 88
	fd ff ff	 movss	 DWORD PTR tv293[ebp], xmm0
$LN27@TextEx:
  00556	f3 0f 10 85 88
	fd ff ff	 movss	 xmm0, DWORD PTR tv293[ebp]
  0055e	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR _wrap_width$11[ebp], xmm0

; 222  :         const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

  00566	51		 push	 ecx
  00567	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _wrap_width$11[ebp]
  0056f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00574	6a 00		 push	 0
  00576	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  00579	50		 push	 eax
  0057a	8b 4d dc	 mov	 ecx, DWORD PTR _text_begin$[ebp]
  0057d	51		 push	 ecx
  0057e	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _text_size$10[ebp]
  00584	52		 push	 edx
  00585	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0058a	83 c4 14	 add	 esp, 20			; 00000014H

; 223  : 
; 224  :         ImRect bb(text_pos, text_pos + text_size);

  0058d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _text_size$10[ebp]
  00593	50		 push	 eax
  00594	8d 4d cc	 lea	 ecx, DWORD PTR _text_pos$[ebp]
  00597	51		 push	 ecx
  00598	8d 95 90 fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0059e	52		 push	 edx
  0059f	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  005a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  005a7	50		 push	 eax
  005a8	8d 45 cc	 lea	 eax, DWORD PTR _text_pos$[ebp]
  005ab	50		 push	 eax
  005ac	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _bb$9[ebp]
  005b2	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 225  :         ItemSize(text_size, 0.0f);

  005b7	51		 push	 ecx
  005b8	0f 57 c0	 xorps	 xmm0, xmm0
  005bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _text_size$10[ebp]
  005c6	50		 push	 eax
  005c7	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  005cc	83 c4 08	 add	 esp, 8

; 226  :         if (!ItemAdd(bb, 0))

  005cf	6a 00		 push	 0
  005d1	6a 00		 push	 0
  005d3	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _bb$9[ebp]
  005d9	50		 push	 eax
  005da	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  005df	83 c4 0c	 add	 esp, 12			; 0000000cH
  005e2	0f b6 c8	 movzx	 ecx, al
  005e5	85 c9		 test	 ecx, ecx
  005e7	75 02		 jne	 SHORT $LN21@TextEx

; 227  :             return;

  005e9	eb 2c		 jmp	 SHORT $LN1@TextEx
$LN21@TextEx:

; 228  : 
; 229  :         // Render (we don't hide text after ## in this end-user function)
; 230  :         RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);

  005eb	51		 push	 ecx
  005ec	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _wrap_width$11[ebp]
  005f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005f9	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  005fc	50		 push	 eax
  005fd	8b 4d dc	 mov	 ecx, DWORD PTR _text_begin$[ebp]
  00600	51		 push	 ecx
  00601	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _bb$9[ebp+4]
  00607	52		 push	 edx
  00608	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _bb$9[ebp]
  0060e	50		 push	 eax
  0060f	e8 00 00 00 00	 call	 ?RenderTextWrapped@ImGui@@YAXUImVec2@@PBD1M@Z ; ImGui::RenderTextWrapped
  00614	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@TextEx:
$LN1@TextEx:

; 231  :     }
; 232  : }

  00617	52		 push	 edx
  00618	8b cd		 mov	 ecx, ebp
  0061a	50		 push	 eax
  0061b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN36@TextEx
  00621	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00626	58		 pop	 eax
  00627	5a		 pop	 edx
  00628	5f		 pop	 edi
  00629	5e		 pop	 esi
  0062a	5b		 pop	 ebx
  0062b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062e	33 cd		 xor	 ecx, ebp
  00630	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00635	81 c4 78 02 00
	00		 add	 esp, 632		; 00000278H
  0063b	3b ec		 cmp	 ebp, esp
  0063d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00642	8b e5		 mov	 esp, ebp
  00644	5d		 pop	 ebp
  00645	c3		 ret	 0
  00646	66 90		 npad	 2
$LN36@TextEx:
  00648	07 00 00 00	 DD	 7
  0064c	00 00 00 00	 DD	 $LN35@TextEx
$LN35@TextEx:
  00650	cc ff ff ff	 DD	 -52			; ffffffccH
  00654	08 00 00 00	 DD	 8
  00658	00 00 00 00	 DD	 $LN28@TextEx
  0065c	8c ff ff ff	 DD	 -116			; ffffff8cH
  00660	08 00 00 00	 DD	 8
  00664	00 00 00 00	 DD	 $LN29@TextEx
  00668	7c ff ff ff	 DD	 -132			; ffffff7cH
  0066c	08 00 00 00	 DD	 8
  00670	00 00 00 00	 DD	 $LN30@TextEx
  00674	40 ff ff ff	 DD	 -192			; ffffff40H
  00678	10 00 00 00	 DD	 16			; 00000010H
  0067c	00 00 00 00	 DD	 $LN31@TextEx
  00680	04 ff ff ff	 DD	 -252			; ffffff04H
  00684	10 00 00 00	 DD	 16			; 00000010H
  00688	00 00 00 00	 DD	 $LN32@TextEx
  0068c	e8 fe ff ff	 DD	 -280			; fffffee8H
  00690	08 00 00 00	 DD	 8
  00694	00 00 00 00	 DD	 $LN33@TextEx
  00698	d0 fe ff ff	 DD	 -304			; fffffed0H
  0069c	10 00 00 00	 DD	 16			; 00000010H
  006a0	00 00 00 00	 DD	 $LN34@TextEx
$LN34@TextEx:
  006a4	62		 DB	 98			; 00000062H
  006a5	62		 DB	 98			; 00000062H
  006a6	00		 DB	 0
$LN33@TextEx:
  006a7	74		 DB	 116			; 00000074H
  006a8	65		 DB	 101			; 00000065H
  006a9	78		 DB	 120			; 00000078H
  006aa	74		 DB	 116			; 00000074H
  006ab	5f		 DB	 95			; 0000005fH
  006ac	73		 DB	 115			; 00000073H
  006ad	69		 DB	 105			; 00000069H
  006ae	7a		 DB	 122			; 0000007aH
  006af	65		 DB	 101			; 00000065H
  006b0	00		 DB	 0
$LN32@TextEx:
  006b1	62		 DB	 98			; 00000062H
  006b2	62		 DB	 98			; 00000062H
  006b3	00		 DB	 0
$LN31@TextEx:
  006b4	6c		 DB	 108			; 0000006cH
  006b5	69		 DB	 105			; 00000069H
  006b6	6e		 DB	 110			; 0000006eH
  006b7	65		 DB	 101			; 00000065H
  006b8	5f		 DB	 95			; 0000005fH
  006b9	72		 DB	 114			; 00000072H
  006ba	65		 DB	 101			; 00000065H
  006bb	63		 DB	 99			; 00000063H
  006bc	74		 DB	 116			; 00000074H
  006bd	00		 DB	 0
$LN30@TextEx:
  006be	70		 DB	 112			; 00000070H
  006bf	6f		 DB	 111			; 0000006fH
  006c0	73		 DB	 115			; 00000073H
  006c1	00		 DB	 0
$LN29@TextEx:
  006c2	74		 DB	 116			; 00000074H
  006c3	65		 DB	 101			; 00000065H
  006c4	78		 DB	 120			; 00000078H
  006c5	74		 DB	 116			; 00000074H
  006c6	5f		 DB	 95			; 0000005fH
  006c7	73		 DB	 115			; 00000073H
  006c8	69		 DB	 105			; 00000069H
  006c9	7a		 DB	 122			; 0000007aH
  006ca	65		 DB	 101			; 00000065H
  006cb	00		 DB	 0
$LN28@TextEx:
  006cc	74		 DB	 116			; 00000074H
  006cd	65		 DB	 101			; 00000065H
  006ce	78		 DB	 120			; 00000078H
  006cf	74		 DB	 116			; 00000074H
  006d0	5f		 DB	 95			; 0000005fH
  006d1	70		 DB	 112			; 00000070H
  006d2	6f		 DB	 111			; 0000006fH
  006d3	73		 DB	 115			; 00000073H
  006d4	00		 DB	 0
?TextEx@ImGui@@YAXPBD0H@Z ENDP				; ImGui::TextEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z
_TEXT	SEGMENT
tv162 = -360						; size = 4
$T1 = -352						; size = 8
$T2 = -336						; size = 8
_rounding_corners_flags_cell$3 = -128			; size = 4
_x2$4 = -116						; size = 4
_x1$5 = -104						; size = 4
_x$6 = -92						; size = 4
_y2$7 = -80						; size = 4
_y1$8 = -68						; size = 4
_y$9 = -56						; size = 4
_yi$10 = -44						; size = 4
_col_bg2$11 = -32					; size = 4
_col_bg1$12 = -20					; size = 4
_window$ = -8						; size = 4
_p_min$ = 8						; size = 8
_p_max$ = 16						; size = 8
_col$ = 24						; size = 4
_grid_step$ = 28					; size = 4
_grid_off$ = 32						; size = 8
_rounding$ = 40						; size = 4
_rounding_corners_flags$ = 44				; size = 4
?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z PROC ; ImGui::RenderColorRectWithAlphaCheckerboard, COMDAT

; 4433 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 98 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-360]
  00012	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4434 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 4435 :     if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)

  00030	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00033	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00038	c1 e8 18	 shr	 eax, 24			; 00000018H
  0003b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00040	0f 83 b6 02 00
	00		 jae	 $LN8@RenderColo

; 4436 :     {
; 4437 :         ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));

  00046	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00049	50		 push	 eax
  0004a	68 cc cc cc ff	 push	 -3355444		; ffccccccH
  0004f	e8 00 00 00 00	 call	 ?ImAlphaBlendColor@@YAIII@Z ; ImAlphaBlendColor
  00054	83 c4 08	 add	 esp, 8
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAII@Z ; ImGui::GetColorU32
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR _col_bg1$12[ebp], eax

; 4438 :         ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));

  00063	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00066	50		 push	 eax
  00067	68 80 80 80 ff	 push	 -8355712		; ff808080H
  0006c	e8 00 00 00 00	 call	 ?ImAlphaBlendColor@@YAIII@Z ; ImAlphaBlendColor
  00071	83 c4 08	 add	 esp, 8
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAII@Z ; ImGui::GetColorU32
  0007a	83 c4 04	 add	 esp, 4
  0007d	89 45 e0	 mov	 DWORD PTR _col_bg2$11[ebp], eax

; 4439 :         window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);

  00080	8b 45 2c	 mov	 eax, DWORD PTR _rounding_corners_flags$[ebp]
  00083	50		 push	 eax
  00084	51		 push	 ecx
  00085	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _col_bg1$12[ebp]
  00092	51		 push	 ecx
  00093	8d 55 10	 lea	 edx, DWORD PTR _p_max$[ebp]
  00096	52		 push	 edx
  00097	8d 45 08	 lea	 eax, DWORD PTR _p_min$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0009e	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  000a4	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 4440 : 
; 4441 :         int yi = 0;

  000a9	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _yi$10[ebp], 0

; 4442 :         for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)

  000b0	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _p_min$[ebp+4]
  000b5	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _grid_off$[ebp+4]
  000ba	f3 0f 11 45 c8	 movss	 DWORD PTR _y$9[ebp], xmm0
  000bf	eb 18		 jmp	 SHORT $LN4@RenderColo
$LN2@RenderColo:
  000c1	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y$9[ebp]
  000c6	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _grid_step$[ebp]
  000cb	f3 0f 11 45 c8	 movss	 DWORD PTR _y$9[ebp], xmm0
  000d0	8b 45 d4	 mov	 eax, DWORD PTR _yi$10[ebp]
  000d3	83 c0 01	 add	 eax, 1
  000d6	89 45 d4	 mov	 DWORD PTR _yi$10[ebp], eax
$LN4@RenderColo:
  000d9	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _p_max$[ebp+4]
  000de	0f 2f 45 c8	 comiss	 xmm0, DWORD PTR _y$9[ebp]
  000e2	0f 86 12 02 00
	00		 jbe	 $LN3@RenderColo

; 4443 :         {
; 4444 :             float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);

  000e8	51		 push	 ecx
  000e9	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _p_max$[ebp+4]
  000ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f3	51		 push	 ecx
  000f4	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _p_min$[ebp+4]
  000f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fe	51		 push	 ecx
  000ff	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y$9[ebp]
  00104	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00109	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	d9 5d bc	 fstp	 DWORD PTR _y1$8[ebp]
  00114	51		 push	 ecx
  00115	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _p_max$[ebp+4]
  0011a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011f	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y$9[ebp]
  00124	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _grid_step$[ebp]
  00129	51		 push	 ecx
  0012a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012f	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00134	83 c4 08	 add	 esp, 8
  00137	d9 5d b0	 fstp	 DWORD PTR _y2$7[ebp]

; 4445 :             if (y2 <= y1)

  0013a	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _y1$8[ebp]
  0013f	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _y2$7[ebp]
  00143	72 05		 jb	 SHORT $LN10@RenderColo

; 4446 :                 continue;

  00145	e9 77 ff ff ff	 jmp	 $LN2@RenderColo
$LN10@RenderColo:

; 4447 :             for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)

  0014a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _p_min$[ebp]
  0014f	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _grid_off$[ebp]
  00154	8b 45 d4	 mov	 eax, DWORD PTR _yi$10[ebp]
  00157	83 e0 01	 and	 eax, 1
  0015a	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  0015e	f3 0f 59 4d 1c	 mulss	 xmm1, DWORD PTR _grid_step$[ebp]
  00163	f3 0f 58 c1	 addss	 xmm0, xmm1
  00167	f3 0f 11 45 a4	 movss	 DWORD PTR _x$6[ebp], xmm0
  0016c	eb 17		 jmp	 SHORT $LN7@RenderColo
$LN5@RenderColo:
  0016e	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _grid_step$[ebp]
  00173	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0017b	f3 0f 58 45 a4	 addss	 xmm0, DWORD PTR _x$6[ebp]
  00180	f3 0f 11 45 a4	 movss	 DWORD PTR _x$6[ebp], xmm0
$LN7@RenderColo:
  00185	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _p_max$[ebp]
  0018a	0f 2f 45 a4	 comiss	 xmm0, DWORD PTR _x$6[ebp]
  0018e	0f 86 61 01 00
	00		 jbe	 $LN6@RenderColo

; 4448 :             {
; 4449 :                 float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);

  00194	51		 push	 ecx
  00195	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _p_max$[ebp]
  0019a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019f	51		 push	 ecx
  001a0	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _p_min$[ebp]
  001a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001aa	51		 push	 ecx
  001ab	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x$6[ebp]
  001b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b5	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  001ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bd	d9 5d 98	 fstp	 DWORD PTR _x1$5[ebp]
  001c0	51		 push	 ecx
  001c1	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _p_max$[ebp]
  001c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001cb	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x$6[ebp]
  001d0	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _grid_step$[ebp]
  001d5	51		 push	 ecx
  001d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001db	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  001e0	83 c4 08	 add	 esp, 8
  001e3	d9 5d 8c	 fstp	 DWORD PTR _x2$4[ebp]

; 4450 :                 if (x2 <= x1)

  001e6	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _x1$5[ebp]
  001eb	0f 2f 45 8c	 comiss	 xmm0, DWORD PTR _x2$4[ebp]
  001ef	72 05		 jb	 SHORT $LN11@RenderColo

; 4451 :                     continue;

  001f1	e9 78 ff ff ff	 jmp	 $LN5@RenderColo
$LN11@RenderColo:

; 4452 :                 int rounding_corners_flags_cell = 0;

  001f6	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _rounding_corners_flags_cell$3[ebp], 0

; 4453 :                 if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }

  001fd	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _p_min$[ebp+4]
  00202	0f 2f 45 bc	 comiss	 xmm0, DWORD PTR _y1$8[ebp]
  00206	72 28		 jb	 SHORT $LN14@RenderColo
  00208	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _p_min$[ebp]
  0020d	0f 2f 45 98	 comiss	 xmm0, DWORD PTR _x1$5[ebp]
  00211	72 09		 jb	 SHORT $LN13@RenderColo
  00213	8b 45 80	 mov	 eax, DWORD PTR _rounding_corners_flags_cell$3[ebp]
  00216	83 c8 01	 or	 eax, 1
  00219	89 45 80	 mov	 DWORD PTR _rounding_corners_flags_cell$3[ebp], eax
$LN13@RenderColo:
  0021c	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _x2$4[ebp]
  00221	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _p_max$[ebp]
  00225	72 09		 jb	 SHORT $LN14@RenderColo
  00227	8b 45 80	 mov	 eax, DWORD PTR _rounding_corners_flags_cell$3[ebp]
  0022a	83 c8 02	 or	 eax, 2
  0022d	89 45 80	 mov	 DWORD PTR _rounding_corners_flags_cell$3[ebp], eax
$LN14@RenderColo:

; 4454 :                 if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }

  00230	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _y2$7[ebp]
  00235	0f 2f 45 14	 comiss	 xmm0, DWORD PTR _p_max$[ebp+4]
  00239	72 28		 jb	 SHORT $LN17@RenderColo
  0023b	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _p_min$[ebp]
  00240	0f 2f 45 98	 comiss	 xmm0, DWORD PTR _x1$5[ebp]
  00244	72 09		 jb	 SHORT $LN16@RenderColo
  00246	8b 45 80	 mov	 eax, DWORD PTR _rounding_corners_flags_cell$3[ebp]
  00249	83 c8 04	 or	 eax, 4
  0024c	89 45 80	 mov	 DWORD PTR _rounding_corners_flags_cell$3[ebp], eax
$LN16@RenderColo:
  0024f	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _x2$4[ebp]
  00254	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _p_max$[ebp]
  00258	72 09		 jb	 SHORT $LN17@RenderColo
  0025a	8b 45 80	 mov	 eax, DWORD PTR _rounding_corners_flags_cell$3[ebp]
  0025d	83 c8 08	 or	 eax, 8
  00260	89 45 80	 mov	 DWORD PTR _rounding_corners_flags_cell$3[ebp], eax
$LN17@RenderColo:

; 4455 :                 rounding_corners_flags_cell &= rounding_corners_flags;

  00263	8b 45 80	 mov	 eax, DWORD PTR _rounding_corners_flags_cell$3[ebp]
  00266	23 45 2c	 and	 eax, DWORD PTR _rounding_corners_flags$[ebp]
  00269	89 45 80	 mov	 DWORD PTR _rounding_corners_flags_cell$3[ebp], eax

; 4456 :                 window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);

  0026c	74 0f		 je	 SHORT $LN19@RenderColo
  0026e	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00273	f3 0f 11 85 98
	fe ff ff	 movss	 DWORD PTR tv162[ebp], xmm0
  0027b	eb 0b		 jmp	 SHORT $LN20@RenderColo
$LN19@RenderColo:
  0027d	0f 57 c0	 xorps	 xmm0, xmm0
  00280	f3 0f 11 85 98
	fe ff ff	 movss	 DWORD PTR tv162[ebp], xmm0
$LN20@RenderColo:
  00288	8b 45 80	 mov	 eax, DWORD PTR _rounding_corners_flags_cell$3[ebp]
  0028b	50		 push	 eax
  0028c	51		 push	 ecx
  0028d	f3 0f 10 85 98
	fe ff ff	 movss	 xmm0, DWORD PTR tv162[ebp]
  00295	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029a	8b 4d e0	 mov	 ecx, DWORD PTR _col_bg2$11[ebp]
  0029d	51		 push	 ecx
  0029e	51		 push	 ecx
  0029f	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _y2$7[ebp]
  002a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a9	51		 push	 ecx
  002aa	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _x2$4[ebp]
  002af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b4	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  002ba	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002bf	50		 push	 eax
  002c0	51		 push	 ecx
  002c1	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _y1$8[ebp]
  002c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002cb	51		 push	 ecx
  002cc	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _x1$5[ebp]
  002d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d6	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002dc	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002e1	50		 push	 eax
  002e2	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  002e5	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  002eb	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 4457 :             }

  002f0	e9 79 fe ff ff	 jmp	 $LN5@RenderColo
$LN6@RenderColo:

; 4458 :         }

  002f5	e9 c7 fd ff ff	 jmp	 $LN2@RenderColo
$LN3@RenderColo:

; 4459 :     }

  002fa	eb 29		 jmp	 SHORT $LN9@RenderColo
$LN8@RenderColo:

; 4460 :     else
; 4461 :     {
; 4462 :         window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);

  002fc	8b 45 2c	 mov	 eax, DWORD PTR _rounding_corners_flags$[ebp]
  002ff	50		 push	 eax
  00300	51		 push	 ecx
  00301	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00306	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030b	8b 4d 18	 mov	 ecx, DWORD PTR _col$[ebp]
  0030e	51		 push	 ecx
  0030f	8d 55 10	 lea	 edx, DWORD PTR _p_max$[ebp]
  00312	52		 push	 edx
  00313	8d 45 08	 lea	 eax, DWORD PTR _p_min$[ebp]
  00316	50		 push	 eax
  00317	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0031a	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  00320	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN9@RenderColo:

; 4463 :     }
; 4464 : }

  00325	5f		 pop	 edi
  00326	5e		 pop	 esi
  00327	5b		 pop	 ebx
  00328	81 c4 68 01 00
	00		 add	 esp, 360		; 00000168H
  0032e	3b ec		 cmp	 ebp, esp
  00330	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00335	8b e5		 mov	 esp, ebp
  00337	5d		 pop	 ebp
  00338	c3		 ret	 0
?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ENDP ; ImGui::RenderColorRectWithAlphaCheckerboard
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemLabelAndCloseButton@ImGui@@YA_NPAUImDrawList@@ABUImRect@@HUImVec2@@PBDII@Z
_TEXT	SEGMENT
tv263 = -464						; size = 4
tv212 = -464						; size = 4
$T1 = -456						; size = 8
$T2 = -440						; size = 8
$T3 = -424						; size = 8
$T4 = -408						; size = 8
_ellipsis_max_x$ = -200					; size = 4
_close_button_sz$5 = -188				; size = 4
_last_item_backup$6 = -176				; size = 40
_close_button_visible$ = -125				; size = 1
_close_button_pressed$ = -113				; size = 1
_text_ellipsis_clip_bb$ = -104				; size = 16
_unsaved_marker_pos$7 = -80				; size = 8
_text_pixel_clip_bb$ = -64				; size = 16
_TAB_UNSAVED_MARKER$ = -40				; size = 4
_label_size$ = -28					; size = 8
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_draw_list$ = 8						; size = 4
_bb$ = 12						; size = 4
_flags$ = 16						; size = 4
_frame_padding$ = 20					; size = 8
_label$ = 28						; size = 4
_tab_id$ = 32						; size = 4
_close_button_id$ = 36					; size = 4
?TabItemLabelAndCloseButton@ImGui@@YA_NPAUImDrawList@@ABUImRect@@HUImVec2@@PBDII@Z PROC ; ImGui::TabItemLabelAndCloseButton, COMDAT

; 7160 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-464]
  00012	b9 74 00 00 00	 mov	 ecx, 116		; 00000074H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7161 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 7162 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

  0003a	51		 push	 ecx
  0003b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	6a 01		 push	 1
  0004a	6a 00		 push	 0
  0004c	8b 45 1c	 mov	 eax, DWORD PTR _label$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d e4	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 7163 :     if (bb.GetWidth() <= 1.0f)

  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _bb$[ebp]
  0005f	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  00064	d9 9d 30 fe ff
	ff		 fstp	 DWORD PTR tv263[ebp]
  0006a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00072	0f 2f 85 30 fe
	ff ff		 comiss	 xmm0, DWORD PTR tv263[ebp]
  00079	72 07		 jb	 SHORT $LN2@TabItemLab

; 7164 :         return false;

  0007b	32 c0		 xor	 al, al
  0007d	e9 00 03 00 00	 jmp	 $LN1@TabItemLab
$LN2@TabItemLab:

; 7165 : 
; 7166 :     // Render text label (with clipping + alpha gradient) + unsaved marker
; 7167 :     const char* TAB_UNSAVED_MARKER = "*";

  00082	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _TAB_UNSAVED_MARKER$[ebp], OFFSET ??_C@_01NBENCBCI@?$CK@

; 7168 :     ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);

  00089	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  0008c	51		 push	 ecx
  0008d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00092	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00097	8b 4d 0c	 mov	 ecx, DWORD PTR _bb$[ebp]
  0009a	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0009f	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _frame_padding$[ebp]
  000a4	51		 push	 ecx
  000a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _bb$[ebp]
  000ad	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  000b2	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _frame_padding$[ebp+4]
  000b7	51		 push	 ecx
  000b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bd	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  000c0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000c4	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _frame_padding$[ebp]
  000c9	51		 push	 ecx
  000ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cf	8d 4d c0	 lea	 ecx, DWORD PTR _text_pixel_clip_bb$[ebp]
  000d2	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect

; 7169 :     if (flags & ImGuiTabItemFlags_UnsavedDocument)

  000d7	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000da	83 e0 01	 and	 eax, 1
  000dd	0f 84 fc 00 00
	00		 je	 $LN3@TabItemLab

; 7170 :     {
; 7171 :         text_pixel_clip_bb.Max.x -= CalcTextSize(TAB_UNSAVED_MARKER, NULL, false).x;

  000e3	51		 push	 ecx
  000e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	6a 00		 push	 0
  000f3	6a 00		 push	 0
  000f5	8b 45 d8	 mov	 eax, DWORD PTR _TAB_UNSAVED_MARKER$[ebp]
  000f8	50		 push	 eax
  000f9	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00105	83 c4 14	 add	 esp, 20			; 00000014H
  00108	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _text_pixel_clip_bb$[ebp+8]
  0010d	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00111	f3 0f 11 45 c8	 movss	 DWORD PTR _text_pixel_clip_bb$[ebp+8], xmm0

; 7172 :         ImVec2 unsaved_marker_pos(ImMin(bb.Min.x + frame_padding.x + label_size.x + 2, text_pixel_clip_bb.Max.x), bb.Min.y + frame_padding.y + IM_FLOOR(-g.FontSize * 0.25f));

  00116	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  00119	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0011e	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _frame_padding$[ebp+4]
  00123	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00126	f3 0f 10 89 c4
	18 00 00	 movss	 xmm1, DWORD PTR [ecx+6340]
  0012e	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00135	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3e800000
  0013d	f3 0f 2c d1	 cvttss2si edx, xmm1
  00141	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00145	f3 0f 58 c1	 addss	 xmm0, xmm1
  00149	51		 push	 ecx
  0014a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014f	51		 push	 ecx
  00150	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _text_pixel_clip_bb$[ebp+8]
  00155	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015a	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  0015d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00161	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _frame_padding$[ebp]
  00166	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  0016b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00173	51		 push	 ecx
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0017e	83 c4 04	 add	 esp, 4
  00181	d9 1c 24	 fstp	 DWORD PTR [esp]
  00184	8d 4d b0	 lea	 ecx, DWORD PTR _unsaved_marker_pos$7[ebp]
  00187	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 7173 :         RenderTextClippedEx(draw_list, unsaved_marker_pos, bb.Max - frame_padding, TAB_UNSAVED_MARKER, NULL, NULL);

  0018c	6a 00		 push	 0
  0018e	51		 push	 ecx
  0018f	0f 57 c0	 xorps	 xmm0, xmm0
  00192	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00197	51		 push	 ecx
  00198	0f 57 c0	 xorps	 xmm0, xmm0
  0019b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a0	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001a6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001ab	50		 push	 eax
  001ac	6a 00		 push	 0
  001ae	6a 00		 push	 0
  001b0	8b 45 d8	 mov	 eax, DWORD PTR _TAB_UNSAVED_MARKER$[ebp]
  001b3	50		 push	 eax
  001b4	8d 4d 14	 lea	 ecx, DWORD PTR _frame_padding$[ebp]
  001b7	51		 push	 ecx
  001b8	8b 55 0c	 mov	 edx, DWORD PTR _bb$[ebp]
  001bb	83 c2 08	 add	 edx, 8
  001be	52		 push	 edx
  001bf	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ce	50		 push	 eax
  001cf	8d 4d b0	 lea	 ecx, DWORD PTR _unsaved_marker_pos$7[ebp]
  001d2	51		 push	 ecx
  001d3	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  001d6	52		 push	 edx
  001d7	e8 00 00 00 00	 call	 ?RenderTextClippedEx@ImGui@@YAXPAUImDrawList@@ABUImVec2@@1PBD2PBU3@1PBUImRect@@@Z ; ImGui::RenderTextClippedEx
  001dc	83 c4 20	 add	 esp, 32			; 00000020H
$LN3@TabItemLab:

; 7174 :     }
; 7175 :     ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

  001df	8b 45 c0	 mov	 eax, DWORD PTR _text_pixel_clip_bb$[ebp]
  001e2	89 45 98	 mov	 DWORD PTR _text_ellipsis_clip_bb$[ebp], eax
  001e5	8b 4d c4	 mov	 ecx, DWORD PTR _text_pixel_clip_bb$[ebp+4]
  001e8	89 4d 9c	 mov	 DWORD PTR _text_ellipsis_clip_bb$[ebp+4], ecx
  001eb	8b 55 c8	 mov	 edx, DWORD PTR _text_pixel_clip_bb$[ebp+8]
  001ee	89 55 a0	 mov	 DWORD PTR _text_ellipsis_clip_bb$[ebp+8], edx
  001f1	8b 45 cc	 mov	 eax, DWORD PTR _text_pixel_clip_bb$[ebp+12]
  001f4	89 45 a4	 mov	 DWORD PTR _text_ellipsis_clip_bb$[ebp+12], eax

; 7176 : 
; 7177 :     // Close Button
; 7178 :     // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
; 7179 :     //  'hovered' will be true when hovering the Tab but NOT when hovering the close button
; 7180 :     //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
; 7181 :     //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
; 7182 :     bool close_button_pressed = false;

  001f7	c6 45 8f 00	 mov	 BYTE PTR _close_button_pressed$[ebp], 0

; 7183 :     bool close_button_visible = false;

  001fb	c6 45 83 00	 mov	 BYTE PTR _close_button_visible$[ebp], 0

; 7184 :     if (close_button_id != 0)

  001ff	83 7d 24 00	 cmp	 DWORD PTR _close_button_id$[ebp], 0
  00203	74 2e		 je	 SHORT $LN5@TabItemLab

; 7185 :         if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == close_button_id)

  00205	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00208	8b 88 d0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6608]
  0020e	3b 4d 20	 cmp	 ecx, DWORD PTR _tab_id$[ebp]
  00211	74 1c		 je	 SHORT $LN6@TabItemLab
  00213	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00216	8b 88 d0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6608]
  0021c	3b 4d 24	 cmp	 ecx, DWORD PTR _close_button_id$[ebp]
  0021f	74 0e		 je	 SHORT $LN6@TabItemLab
  00221	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00224	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0022a	3b 4d 24	 cmp	 ecx, DWORD PTR _close_button_id$[ebp]
  0022d	75 04		 jne	 SHORT $LN5@TabItemLab
$LN6@TabItemLab:

; 7186 :             close_button_visible = true;

  0022f	c6 45 83 01	 mov	 BYTE PTR _close_button_visible$[ebp], 1
$LN5@TabItemLab:

; 7187 :     if (close_button_visible)

  00233	0f b6 45 83	 movzx	 eax, BYTE PTR _close_button_visible$[ebp]
  00237	85 c0		 test	 eax, eax
  00239	0f 84 ca 00 00
	00		 je	 $LN7@TabItemLab

; 7188 :     {
; 7189 :         ImGuiItemHoveredDataBackup last_item_backup;

  0023f	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _last_item_backup$6[ebp]
  00245	e8 00 00 00 00	 call	 ??0ImGuiItemHoveredDataBackup@@QAE@XZ ; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup

; 7190 :         const float close_button_sz = g.FontSize;

  0024a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0024d	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00255	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _close_button_sz$5[ebp], xmm0

; 7191 :         PushStyleVar(ImGuiStyleVar_FramePadding, frame_padding);

  0025d	8d 45 14	 lea	 eax, DWORD PTR _frame_padding$[ebp]
  00260	50		 push	 eax
  00261	6a 0a		 push	 10			; 0000000aH
  00263	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z ; ImGui::PushStyleVar
  00268	83 c4 08	 add	 esp, 8

; 7192 :         if (CloseButton(close_button_id, ImVec2(bb.Max.x - frame_padding.x * 2.0f - close_button_sz, bb.Min.y)))

  0026b	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  0026e	51		 push	 ecx
  0026f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00274	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00279	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _frame_padding$[ebp]
  0027e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00286	8b 4d 0c	 mov	 ecx, DWORD PTR _bb$[ebp]
  00289	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  0028e	f3 0f 5c c8	 subss	 xmm1, xmm0
  00292	f3 0f 5c 8d 44
	ff ff ff	 subss	 xmm1, DWORD PTR _close_button_sz$5[ebp]
  0029a	51		 push	 ecx
  0029b	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  002a0	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002a6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002ab	50		 push	 eax
  002ac	8b 55 24	 mov	 edx, DWORD PTR _close_button_id$[ebp]
  002af	52		 push	 edx
  002b0	e8 00 00 00 00	 call	 ?CloseButton@ImGui@@YA_NIABUImVec2@@@Z ; ImGui::CloseButton
  002b5	83 c4 08	 add	 esp, 8
  002b8	0f b6 c0	 movzx	 eax, al
  002bb	85 c0		 test	 eax, eax
  002bd	74 04		 je	 SHORT $LN8@TabItemLab

; 7193 :             close_button_pressed = true;

  002bf	c6 45 8f 01	 mov	 BYTE PTR _close_button_pressed$[ebp], 1
$LN8@TabItemLab:

; 7194 :         PopStyleVar();

  002c3	6a 01		 push	 1
  002c5	e8 00 00 00 00	 call	 ?PopStyleVar@ImGui@@YAXH@Z ; ImGui::PopStyleVar
  002ca	83 c4 04	 add	 esp, 4

; 7195 :         last_item_backup.Restore();

  002cd	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _last_item_backup$6[ebp]
  002d3	e8 00 00 00 00	 call	 ?Restore@ImGuiItemHoveredDataBackup@@QBEXXZ ; ImGuiItemHoveredDataBackup::Restore

; 7196 : 
; 7197 :         // Close with middle mouse button
; 7198 :         if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))

  002d8	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  002db	83 e0 04	 and	 eax, 4
  002de	75 17		 jne	 SHORT $LN9@TabItemLab
  002e0	6a 00		 push	 0
  002e2	6a 02		 push	 2
  002e4	e8 00 00 00 00	 call	 ?IsMouseClicked@ImGui@@YA_NH_N@Z ; ImGui::IsMouseClicked
  002e9	83 c4 08	 add	 esp, 8
  002ec	0f b6 c0	 movzx	 eax, al
  002ef	85 c0		 test	 eax, eax
  002f1	74 04		 je	 SHORT $LN9@TabItemLab

; 7199 :             close_button_pressed = true;

  002f3	c6 45 8f 01	 mov	 BYTE PTR _close_button_pressed$[ebp], 1
$LN9@TabItemLab:

; 7200 : 
; 7201 :         text_pixel_clip_bb.Max.x -= close_button_sz;

  002f7	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _text_pixel_clip_bb$[ebp+8]
  002fc	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _close_button_sz$5[ebp]
  00304	f3 0f 11 45 c8	 movss	 DWORD PTR _text_pixel_clip_bb$[ebp+8], xmm0
$LN7@TabItemLab:

; 7202 :     }
; 7203 : 
; 7204 :     float ellipsis_max_x = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;

  00309	0f b6 45 83	 movzx	 eax, BYTE PTR _close_button_visible$[ebp]
  0030d	85 c0		 test	 eax, eax
  0030f	74 0f		 je	 SHORT $LN11@TabItemLab
  00311	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _text_pixel_clip_bb$[ebp+8]
  00316	f3 0f 11 85 30
	fe ff ff	 movss	 DWORD PTR tv212[ebp], xmm0
  0031e	eb 18		 jmp	 SHORT $LN12@TabItemLab
$LN11@TabItemLab:
  00320	8b 4d 0c	 mov	 ecx, DWORD PTR _bb$[ebp]
  00323	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00328	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00330	f3 0f 11 85 30
	fe ff ff	 movss	 DWORD PTR tv212[ebp], xmm0
$LN12@TabItemLab:
  00338	f3 0f 10 85 30
	fe ff ff	 movss	 xmm0, DWORD PTR tv212[ebp]
  00340	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _ellipsis_max_x$[ebp], xmm0

; 7205 :     RenderTextEllipsis(draw_list, text_ellipsis_clip_bb.Min, text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x, ellipsis_max_x, label, NULL, &label_size);

  00348	8d 45 e4	 lea	 eax, DWORD PTR _label_size$[ebp]
  0034b	50		 push	 eax
  0034c	6a 00		 push	 0
  0034e	8b 4d 1c	 mov	 ecx, DWORD PTR _label$[ebp]
  00351	51		 push	 ecx
  00352	51		 push	 ecx
  00353	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _ellipsis_max_x$[ebp]
  0035b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00360	51		 push	 ecx
  00361	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _text_pixel_clip_bb$[ebp+8]
  00366	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036b	8d 55 a0	 lea	 edx, DWORD PTR _text_ellipsis_clip_bb$[ebp+8]
  0036e	52		 push	 edx
  0036f	8d 45 98	 lea	 eax, DWORD PTR _text_ellipsis_clip_bb$[ebp]
  00372	50		 push	 eax
  00373	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00376	51		 push	 ecx
  00377	e8 00 00 00 00	 call	 ?RenderTextEllipsis@ImGui@@YAXPAUImDrawList@@ABUImVec2@@1MMPBD2PBU3@@Z ; ImGui::RenderTextEllipsis
  0037c	83 c4 20	 add	 esp, 32			; 00000020H

; 7206 : 
; 7207 :     return close_button_pressed;

  0037f	8a 45 8f	 mov	 al, BYTE PTR _close_button_pressed$[ebp]
$LN1@TabItemLab:

; 7208 : }

  00382	52		 push	 edx
  00383	8b cd		 mov	 ecx, ebp
  00385	50		 push	 eax
  00386	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@TabItemLab
  0038c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00391	58		 pop	 eax
  00392	5a		 pop	 edx
  00393	5f		 pop	 edi
  00394	5e		 pop	 esi
  00395	5b		 pop	 ebx
  00396	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00399	33 cd		 xor	 ecx, ebp
  0039b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a0	81 c4 d0 01 00
	00		 add	 esp, 464		; 000001d0H
  003a6	3b ec		 cmp	 ebp, esp
  003a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003ad	8b e5		 mov	 esp, ebp
  003af	5d		 pop	 ebp
  003b0	c3		 ret	 0
  003b1	0f 1f 00	 npad	 3
$LN19@TabItemLab:
  003b4	05 00 00 00	 DD	 5
  003b8	00 00 00 00	 DD	 $LN18@TabItemLab
$LN18@TabItemLab:
  003bc	e4 ff ff ff	 DD	 -28			; ffffffe4H
  003c0	08 00 00 00	 DD	 8
  003c4	00 00 00 00	 DD	 $LN13@TabItemLab
  003c8	c0 ff ff ff	 DD	 -64			; ffffffc0H
  003cc	10 00 00 00	 DD	 16			; 00000010H
  003d0	00 00 00 00	 DD	 $LN14@TabItemLab
  003d4	b0 ff ff ff	 DD	 -80			; ffffffb0H
  003d8	08 00 00 00	 DD	 8
  003dc	00 00 00 00	 DD	 $LN15@TabItemLab
  003e0	98 ff ff ff	 DD	 -104			; ffffff98H
  003e4	10 00 00 00	 DD	 16			; 00000010H
  003e8	00 00 00 00	 DD	 $LN16@TabItemLab
  003ec	50 ff ff ff	 DD	 -176			; ffffff50H
  003f0	28 00 00 00	 DD	 40			; 00000028H
  003f4	00 00 00 00	 DD	 $LN17@TabItemLab
$LN17@TabItemLab:
  003f8	6c		 DB	 108			; 0000006cH
  003f9	61		 DB	 97			; 00000061H
  003fa	73		 DB	 115			; 00000073H
  003fb	74		 DB	 116			; 00000074H
  003fc	5f		 DB	 95			; 0000005fH
  003fd	69		 DB	 105			; 00000069H
  003fe	74		 DB	 116			; 00000074H
  003ff	65		 DB	 101			; 00000065H
  00400	6d		 DB	 109			; 0000006dH
  00401	5f		 DB	 95			; 0000005fH
  00402	62		 DB	 98			; 00000062H
  00403	61		 DB	 97			; 00000061H
  00404	63		 DB	 99			; 00000063H
  00405	6b		 DB	 107			; 0000006bH
  00406	75		 DB	 117			; 00000075H
  00407	70		 DB	 112			; 00000070H
  00408	00		 DB	 0
$LN16@TabItemLab:
  00409	74		 DB	 116			; 00000074H
  0040a	65		 DB	 101			; 00000065H
  0040b	78		 DB	 120			; 00000078H
  0040c	74		 DB	 116			; 00000074H
  0040d	5f		 DB	 95			; 0000005fH
  0040e	65		 DB	 101			; 00000065H
  0040f	6c		 DB	 108			; 0000006cH
  00410	6c		 DB	 108			; 0000006cH
  00411	69		 DB	 105			; 00000069H
  00412	70		 DB	 112			; 00000070H
  00413	73		 DB	 115			; 00000073H
  00414	69		 DB	 105			; 00000069H
  00415	73		 DB	 115			; 00000073H
  00416	5f		 DB	 95			; 0000005fH
  00417	63		 DB	 99			; 00000063H
  00418	6c		 DB	 108			; 0000006cH
  00419	69		 DB	 105			; 00000069H
  0041a	70		 DB	 112			; 00000070H
  0041b	5f		 DB	 95			; 0000005fH
  0041c	62		 DB	 98			; 00000062H
  0041d	62		 DB	 98			; 00000062H
  0041e	00		 DB	 0
$LN15@TabItemLab:
  0041f	75		 DB	 117			; 00000075H
  00420	6e		 DB	 110			; 0000006eH
  00421	73		 DB	 115			; 00000073H
  00422	61		 DB	 97			; 00000061H
  00423	76		 DB	 118			; 00000076H
  00424	65		 DB	 101			; 00000065H
  00425	64		 DB	 100			; 00000064H
  00426	5f		 DB	 95			; 0000005fH
  00427	6d		 DB	 109			; 0000006dH
  00428	61		 DB	 97			; 00000061H
  00429	72		 DB	 114			; 00000072H
  0042a	6b		 DB	 107			; 0000006bH
  0042b	65		 DB	 101			; 00000065H
  0042c	72		 DB	 114			; 00000072H
  0042d	5f		 DB	 95			; 0000005fH
  0042e	70		 DB	 112			; 00000070H
  0042f	6f		 DB	 111			; 0000006fH
  00430	73		 DB	 115			; 00000073H
  00431	00		 DB	 0
$LN14@TabItemLab:
  00432	74		 DB	 116			; 00000074H
  00433	65		 DB	 101			; 00000065H
  00434	78		 DB	 120			; 00000078H
  00435	74		 DB	 116			; 00000074H
  00436	5f		 DB	 95			; 0000005fH
  00437	70		 DB	 112			; 00000070H
  00438	69		 DB	 105			; 00000069H
  00439	78		 DB	 120			; 00000078H
  0043a	65		 DB	 101			; 00000065H
  0043b	6c		 DB	 108			; 0000006cH
  0043c	5f		 DB	 95			; 0000005fH
  0043d	63		 DB	 99			; 00000063H
  0043e	6c		 DB	 108			; 0000006cH
  0043f	69		 DB	 105			; 00000069H
  00440	70		 DB	 112			; 00000070H
  00441	5f		 DB	 95			; 0000005fH
  00442	62		 DB	 98			; 00000062H
  00443	62		 DB	 98			; 00000062H
  00444	00		 DB	 0
$LN13@TabItemLab:
  00445	6c		 DB	 108			; 0000006cH
  00446	61		 DB	 97			; 00000061H
  00447	62		 DB	 98			; 00000062H
  00448	65		 DB	 101			; 00000065H
  00449	6c		 DB	 108			; 0000006cH
  0044a	5f		 DB	 95			; 0000005fH
  0044b	73		 DB	 115			; 00000073H
  0044c	69		 DB	 105			; 00000069H
  0044d	7a		 DB	 122			; 0000007aH
  0044e	65		 DB	 101			; 00000065H
  0044f	00		 DB	 0
?TabItemLabelAndCloseButton@ImGui@@YA_NPAUImDrawList@@ABUImRect@@HUImVec2@@PBDII@Z ENDP ; ImGui::TabItemLabelAndCloseButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z
_TEXT	SEGMENT
$T1 = -376						; size = 8
$T2 = -360						; size = 8
$T3 = -344						; size = 8
$T4 = -328						; size = 8
$T5 = -312						; size = 8
$T6 = -296						; size = 8
$T7 = -280						; size = 8
$T8 = -264						; size = 8
_y2$ = -56						; size = 4
_y1$ = -44						; size = 4
_rounding$ = -32					; size = 4
_width$ = -20						; size = 4
_g$ = -8						; size = 4
_draw_list$ = 8						; size = 4
_bb$ = 12						; size = 4
_flags$ = 16						; size = 4
_col$ = 20						; size = 4
?TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z PROC ; ImGui::TabItemBackground, COMDAT

; 7133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 84 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-380]
  00012	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7134 :     // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
; 7135 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 7136 :     const float width = bb.GetWidth();

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _bb$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  00038	d9 5d ec	 fstp	 DWORD PTR _width$[ebp]

; 7137 :     IM_UNUSED(flags);
; 7138 :     IM_ASSERT(width > 0.0f);

  0003b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _width$[ebp]
  00040	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00047	77 25		 ja	 SHORT $LN4@TabItemBac
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z@4JA
  0004e	83 c0 05	 add	 eax, 5
  00051	8b f4		 mov	 esi, esp
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@HMBBPDPB@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AAf@
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@TabItemBac:

; 7139 :     const float rounding = ImMax(0.0f, ImMin(g.Style.TabRounding, width * 0.5f - 1.0f));

  0006e	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _width$[ebp]
  00073	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0007b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00083	51		 push	 ecx
  00084	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00089	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0008c	51		 push	 ecx
  0008d	f3 0f 10 80 88
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5512]
  00095	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009a	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0009f	83 c4 04	 add	 esp, 4
  000a2	d9 1c 24	 fstp	 DWORD PTR [esp]
  000a5	51		 push	 ecx
  000a6	0f 57 c0	 xorps	 xmm0, xmm0
  000a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ae	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000b3	83 c4 08	 add	 esp, 8
  000b6	d9 5d e0	 fstp	 DWORD PTR _rounding$[ebp]

; 7140 :     const float y1 = bb.Min.y + 1.0f;

  000b9	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  000bc	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000c1	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  000c9	f3 0f 11 45 d4	 movss	 DWORD PTR _y1$[ebp], xmm0

; 7141 :     const float y2 = bb.Max.y - 1.0f;

  000ce	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  000d1	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000d6	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  000de	f3 0f 11 45 c8	 movss	 DWORD PTR _y2$[ebp], xmm0

; 7142 :     draw_list->PathLineTo(ImVec2(bb.Min.x, y2));

  000e3	51		 push	 ecx
  000e4	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y2$[ebp]
  000e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ee	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  000f1	51		 push	 ecx
  000f2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fb	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00101	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00106	50		 push	 eax
  00107	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0010a	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 7143 :     draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);

  0010f	6a 09		 push	 9
  00111	6a 06		 push	 6
  00113	51		 push	 ecx
  00114	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00119	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011e	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00123	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  00128	51		 push	 ecx
  00129	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012e	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  00131	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00135	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  0013a	51		 push	 ecx
  0013b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00140	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00146	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0014b	50		 push	 eax
  0014c	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0014f	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 7144 :     draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);

  00154	6a 0c		 push	 12			; 0000000cH
  00156	6a 09		 push	 9
  00158	51		 push	 ecx
  00159	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0015e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00163	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00168	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  0016d	51		 push	 ecx
  0016e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00173	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  00176	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0017b	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _rounding$[ebp]
  00180	51		 push	 ecx
  00181	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00186	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0018c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00191	50		 push	 eax
  00192	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00195	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 7145 :     draw_list->PathLineTo(ImVec2(bb.Max.x, y2));

  0019a	51		 push	 ecx
  0019b	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y2$[ebp]
  001a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a5	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  001a8	51		 push	 ecx
  001a9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b3	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  001b9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001be	50		 push	 eax
  001bf	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  001c2	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 7146 :     draw_list->PathFillConvex(col);

  001c7	8b 45 14	 mov	 eax, DWORD PTR _col$[ebp]
  001ca	50		 push	 eax
  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  001ce	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex

; 7147 :     if (g.Style.TabBorderSize > 0.0f)

  001d3	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001d6	f3 0f 10 80 8c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5516]
  001de	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  001e5	0f 86 48 01 00
	00		 jbe	 $LN2@TabItemBac

; 7148 :     {
; 7149 :         draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));

  001eb	51		 push	 ecx
  001ec	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y2$[ebp]
  001f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f6	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  001f9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001fd	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00205	51		 push	 ecx
  00206	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020b	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00211	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00216	50		 push	 eax
  00217	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0021a	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 7150 :         draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);

  0021f	6a 09		 push	 9
  00221	6a 06		 push	 6
  00223	51		 push	 ecx
  00224	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00229	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022e	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00233	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  00238	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00240	51		 push	 ecx
  00241	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00246	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  00249	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0024d	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  00252	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0025a	51		 push	 ecx
  0025b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00260	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00266	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0026b	50		 push	 eax
  0026c	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0026f	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 7151 :         draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);

  00274	6a 0c		 push	 12			; 0000000cH
  00276	6a 09		 push	 9
  00278	51		 push	 ecx
  00279	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0027e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00283	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00288	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  0028d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00295	51		 push	 ecx
  00296	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029b	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  0029e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002a3	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _rounding$[ebp]
  002a8	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  002b0	51		 push	 ecx
  002b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b6	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  002bc	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002c1	50		 push	 eax
  002c2	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  002c5	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 7152 :         draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));

  002ca	51		 push	 ecx
  002cb	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y2$[ebp]
  002d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d5	8b 45 0c	 mov	 eax, DWORD PTR _bb$[ebp]
  002d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002dd	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  002e5	51		 push	 ecx
  002e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002eb	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002f1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002f6	50		 push	 eax
  002f7	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  002fa	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 7153 :         draw_list->PathStroke(GetColorU32(ImGuiCol_Border), false, g.Style.TabBorderSize);

  002ff	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00302	51		 push	 ecx
  00303	f3 0f 10 80 8c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5516]
  0030b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00310	6a 00		 push	 0
  00312	51		 push	 ecx
  00313	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0031b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00320	6a 05		 push	 5
  00322	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00327	83 c4 08	 add	 esp, 8
  0032a	50		 push	 eax
  0032b	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0032e	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN2@TabItemBac:

; 7154 :     }
; 7155 : }

  00333	5f		 pop	 edi
  00334	5e		 pop	 esi
  00335	5b		 pop	 ebx
  00336	81 c4 7c 01 00
	00		 add	 esp, 380		; 0000017cH
  0033c	3b ec		 cmp	 ebp, esp
  0033e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00343	8b e5		 mov	 esp, ebp
  00345	5d		 pop	 ebp
  00346	c3		 ret	 0
?TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z ENDP ; ImGui::TabItemBackground
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemCalcSize@ImGui@@YA?AUImVec2@@PBD_N@Z
_TEXT	SEGMENT
_size$ = -44						; size = 8
_label_size$ = -28					; size = 8
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_label$ = 12						; size = 4
_has_close_button$ = 16					; size = 1
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PBD_N@Z PROC	; ImGui::TabItemCalcSize, COMDAT

; 7121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7122 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 7123 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

  0003a	51		 push	 ecx
  0003b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	6a 01		 push	 1
  0004a	6a 00		 push	 0
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d e4	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00059	83 c4 14	 add	 esp, 20			; 00000014H

; 7124 :     ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0005f	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  00067	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0006f	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  00074	51		 push	 ecx
  00075	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0007d	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00082	f3 0f 58 81 48
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5448]
  0008a	51		 push	 ecx
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	8d 4d d4	 lea	 ecx, DWORD PTR _size$[ebp]
  00093	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 7125 :     if (has_close_button)

  00098	0f b6 45 10	 movzx	 eax, BYTE PTR _has_close_button$[ebp]
  0009c	85 c0		 test	 eax, eax
  0009e	74 2d		 je	 SHORT $LN2@TabItemCal

; 7126 :         size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000a3	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  000a6	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  000ae	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  000b6	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  000b9	f3 0f 58 82 48
	15 00 00	 addss	 xmm0, DWORD PTR [edx+5448]
  000c1	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _size$[ebp]
  000c6	f3 0f 11 45 d4	 movss	 DWORD PTR _size$[ebp], xmm0
  000cb	eb 1d		 jmp	 SHORT $LN3@TabItemCal
$LN2@TabItemCal:

; 7127 :     else
; 7128 :         size.x += g.Style.FramePadding.x + 1.0f;

  000cd	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000d0	f3 0f 10 80 48
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5448]
  000d8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  000e0	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _size$[ebp]
  000e5	f3 0f 11 45 d4	 movss	 DWORD PTR _size$[ebp], xmm0
$LN3@TabItemCal:

; 7129 :     return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);

  000ea	51		 push	 ecx
  000eb	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  000f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f5	e8 00 00 00 00	 call	 ?TabBarCalcMaxTabWidth@ImGui@@YAMXZ ; ImGui::TabBarCalcMaxTabWidth
  000fa	51		 push	 ecx
  000fb	d9 1c 24	 fstp	 DWORD PTR [esp]
  000fe	51		 push	 ecx
  000ff	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _size$[ebp]
  00104	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00109	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0010e	83 c4 04	 add	 esp, 4
  00111	d9 1c 24	 fstp	 DWORD PTR [esp]
  00114	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00117	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0011c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 7130 : }

  0011f	52		 push	 edx
  00120	8b cd		 mov	 ecx, ebp
  00122	50		 push	 eax
  00123	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@TabItemCal
  00129	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012e	58		 pop	 eax
  0012f	5a		 pop	 edx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00143	3b ec		 cmp	 ebp, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
  0014e	66 90		 npad	 2
$LN8@TabItemCal:
  00150	02 00 00 00	 DD	 2
  00154	00 00 00 00	 DD	 $LN7@TabItemCal
$LN7@TabItemCal:
  00158	e4 ff ff ff	 DD	 -28			; ffffffe4H
  0015c	08 00 00 00	 DD	 8
  00160	00 00 00 00	 DD	 $LN5@TabItemCal
  00164	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00168	08 00 00 00	 DD	 8
  0016c	00 00 00 00	 DD	 $LN6@TabItemCal
$LN6@TabItemCal:
  00170	73		 DB	 115			; 00000073H
  00171	69		 DB	 105			; 00000069H
  00172	7a		 DB	 122			; 0000007aH
  00173	65		 DB	 101			; 00000065H
  00174	00		 DB	 0
$LN5@TabItemCal:
  00175	6c		 DB	 108			; 0000006cH
  00176	61		 DB	 97			; 00000061H
  00177	62		 DB	 98			; 00000062H
  00178	65		 DB	 101			; 00000065H
  00179	6c		 DB	 108			; 0000006cH
  0017a	5f		 DB	 95			; 0000005fH
  0017b	73		 DB	 115			; 00000073H
  0017c	69		 DB	 105			; 00000069H
  0017d	7a		 DB	 122			; 0000007aH
  0017e	65		 DB	 101			; 00000065H
  0017f	00		 DB	 0
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PBD_N@Z ENDP	; ImGui::TabItemCalcSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemEx@ImGui@@YA_NPAUImGuiTabBar@@PBDPA_NH@Z
_TEXT	SEGMENT
tv446 = -916						; size = 4
tv442 = -912						; size = 4
tv445 = -908						; size = 4
tv478 = -904						; size = 4
tv439 = -904						; size = 4
tv382 = -904						; size = 4
tv287 = -904						; size = 4
tv211 = -904						; size = 4
tv161 = -901						; size = 1
tv156 = -901						; size = 1
tv152 = -901						; size = 1
tv92 = -901						; size = 1
$T1 = -896						; size = 8
$T2 = -880						; size = 8
$T3 = -864						; size = 8
$T4 = -848						; size = 8
$T5 = -832						; size = 8
$T6 = -816						; size = 8
$T7 = -800						; size = 16
$T8 = -776						; size = 32
$T9 = -736						; size = 16
_just_closed$ = -325					; size = 1
_close_button_id$ = -316				; size = 4
_hovered_unblocked$ = -301				; size = 1
_tab_col$ = -292					; size = 4
_display_draw_list$ = -280				; size = 4
_pressed$ = -265					; size = 1
_held$ = -253						; size = 1
_hovered$ = -241					; size = 1
_button_flags$ = -232					; size = 4
_backup_cursor_max_pos$ = -220				; size = 8
_want_clip_rect$ = -201					; size = 1
_bb$ = -192						; size = 16
_pos$ = -168						; size = 8
_backup_main_cursor_pos$ = -152				; size = 8
_tab_contents_visible$ = -133				; size = 1
_tab_appearing$ = -121					; size = 1
_tab_bar_focused$ = -109				; size = 1
_tab_bar_appearing$ = -97				; size = 1
_tab_is_new$ = -85					; size = 1
_tab$ = -76						; size = 4
_size$ = -64						; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_tab_bar$ = 8						; size = 4
_label$ = 12						; size = 4
_p_open$ = 16						; size = 4
_flags$ = 20						; size = 4
?TabItemEx@ImGui@@YA_NPAUImGuiTabBar@@PBDPA_NH@Z PROC	; ImGui::TabItemEx, COMDAT

; 6908 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 03 00
	00		 sub	 esp, 916		; 00000394H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fc ff
	ff		 lea	 edi, DWORD PTR [ebp-916]
  00012	b9 e5 00 00 00	 mov	 ecx, 229		; 000000e5H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6909 :     // Layout whole tab bar if not already done
; 6910 :     if (tab_bar->WantLayout)

  00032	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00035	0f b6 48 5d	 movzx	 ecx, BYTE PTR [eax+93]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 0c		 je	 SHORT $LN2@TabItemEx

; 6911 :         TabBarLayout(tab_bar);

  0003d	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z ; ImGui::TabBarLayout
  00046	83 c4 04	 add	 esp, 4
$LN2@TabItemEx:

; 6912 : 
; 6913 :     ImGuiContext& g = *GImGui;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004e	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 6914 :     ImGuiWindow* window = g.CurrentWindow;

  00051	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00054	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  0005a	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 6915 :     if (window->SkipItems)

  0005d	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00060	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00064	85 c9		 test	 ecx, ecx
  00066	74 07		 je	 SHORT $LN3@TabItemEx

; 6916 :         return false;

  00068	32 c0		 xor	 al, al
  0006a	e9 c9 09 00 00	 jmp	 $LN1@TabItemEx
$LN3@TabItemEx:

; 6917 : 
; 6918 :     const ImGuiStyle& style = g.Style;

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00072	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00077	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 6919 :     const ImGuiID id = TabBarCalcTabID(tab_bar, label);

  0007a	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 ?TabBarCalcTabID@ImGui@@YAIPAUImGuiTabBar@@PBD@Z ; ImGui::TabBarCalcTabID
  00087	83 c4 08	 add	 esp, 8
  0008a	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 6920 : 
; 6921 :     // If the user called us with *p_open == false, we early out and don't render. We make a dummy call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
; 6922 :     if (p_open && !*p_open)

  0008d	83 7d 10 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  00091	74 3c		 je	 SHORT $LN4@TabItemEx
  00093	8b 45 10	 mov	 eax, DWORD PTR _p_open$[ebp]
  00096	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00099	85 c9		 test	 ecx, ecx
  0009b	75 32		 jne	 SHORT $LN4@TabItemEx

; 6923 :     {
; 6924 :         PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);

  0009d	6a 01		 push	 1
  0009f	6a 18		 push	 24			; 00000018H
  000a1	e8 00 00 00 00	 call	 ?PushItemFlag@ImGui@@YAXH_N@Z ; ImGui::PushItemFlag
  000a6	83 c4 08	 add	 esp, 8

; 6925 :         ItemAdd(ImRect(), id);

  000a9	6a 00		 push	 0
  000ab	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  000ae	50		 push	 eax
  000af	8d 8d 20 fd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  000b5	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6926 :         PopItemFlag();

  000c3	e8 00 00 00 00	 call	 ?PopItemFlag@ImGui@@YAXXZ ; ImGui::PopItemFlag

; 6927 :         return false;

  000c8	32 c0		 xor	 al, al
  000ca	e9 69 09 00 00	 jmp	 $LN1@TabItemEx
$LN4@TabItemEx:

; 6928 :     }
; 6929 : 
; 6930 :     // Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)
; 6931 :     if (flags & ImGuiTabItemFlags_NoCloseButton)

  000cf	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  000d2	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  000d7	74 09		 je	 SHORT $LN5@TabItemEx

; 6932 :         p_open = NULL;

  000d9	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _p_open$[ebp], 0
  000e0	eb 11		 jmp	 SHORT $LN7@TabItemEx
$LN5@TabItemEx:

; 6933 :     else if (p_open == NULL)

  000e2	83 7d 10 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  000e6	75 0b		 jne	 SHORT $LN7@TabItemEx

; 6934 :         flags |= ImGuiTabItemFlags_NoCloseButton;

  000e8	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  000eb	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  000f0	89 45 14	 mov	 DWORD PTR _flags$[ebp], eax
$LN7@TabItemEx:

; 6935 : 
; 6936 :     // Calculate tab contents size
; 6937 :     ImVec2 size = TabItemCalcSize(label, p_open != NULL);

  000f3	83 7d 10 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  000f7	74 09		 je	 SHORT $LN41@TabItemEx
  000f9	c6 85 7b fc ff
	ff 01		 mov	 BYTE PTR tv92[ebp], 1
  00100	eb 07		 jmp	 SHORT $LN42@TabItemEx
$LN41@TabItemEx:
  00102	c6 85 7b fc ff
	ff 00		 mov	 BYTE PTR tv92[ebp], 0
$LN42@TabItemEx:
  00109	0f b6 85 7b fc
	ff ff		 movzx	 eax, BYTE PTR tv92[ebp]
  00110	50		 push	 eax
  00111	8b 4d 0c	 mov	 ecx, DWORD PTR _label$[ebp]
  00114	51		 push	 ecx
  00115	8d 55 c0	 lea	 edx, DWORD PTR _size$[ebp]
  00118	52		 push	 edx
  00119	e8 00 00 00 00	 call	 ?TabItemCalcSize@ImGui@@YA?AUImVec2@@PBD_N@Z ; ImGui::TabItemCalcSize
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6938 : 
; 6939 :     // Acquire tab data
; 6940 :     ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);

  00121	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00124	50		 push	 eax
  00125	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00128	51		 push	 ecx
  00129	e8 00 00 00 00	 call	 ?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
  0012e	83 c4 08	 add	 esp, 8
  00131	89 45 b4	 mov	 DWORD PTR _tab$[ebp], eax

; 6941 :     bool tab_is_new = false;

  00134	c6 45 ab 00	 mov	 BYTE PTR _tab_is_new$[ebp], 0

; 6942 :     if (tab == NULL)

  00138	83 7d b4 00	 cmp	 DWORD PTR _tab$[ebp], 0
  0013c	75 38		 jne	 SHORT $LN8@TabItemEx

; 6943 :     {
; 6944 :         tab_bar->Tabs.push_back(ImGuiTabItem());

  0013e	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00144	e8 00 00 00 00	 call	 ??0ImGuiTabItem@@QAE@XZ	; ImGuiTabItem::ImGuiTabItem
  00149	50		 push	 eax
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0014d	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImGuiTabItem@@@@QAEXABUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::push_back

; 6945 :         tab = &tab_bar->Tabs.back();

  00152	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00155	e8 00 00 00 00	 call	 ?back@?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@XZ ; ImVector<ImGuiTabItem>::back
  0015a	89 45 b4	 mov	 DWORD PTR _tab$[ebp], eax

; 6946 :         tab->ID = id;

  0015d	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00160	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00163	89 08		 mov	 DWORD PTR [eax], ecx

; 6947 :         tab->Width = size.x;

  00165	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00168	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _size$[ebp]
  0016d	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 6948 :         tab_is_new = true;

  00172	c6 45 ab 01	 mov	 BYTE PTR _tab_is_new$[ebp], 1
$LN8@TabItemEx:

; 6949 :     }
; 6950 :     tab_bar->LastTabItemIdx = (short)tab_bar->Tabs.index_from_ptr(tab);

  00176	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00179	50		 push	 eax
  0017a	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0017d	e8 00 00 00 00	 call	 ?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QBEHPBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::index_from_ptr
  00182	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00185	66 89 41 60	 mov	 WORD PTR [ecx+96], ax

; 6951 :     tab->ContentWidth = size.x;

  00189	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  0018c	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _size$[ebp]
  00191	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 6952 : 
; 6953 :     const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);

  00196	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00199	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0019c	83 c1 01	 add	 ecx, 1
  0019f	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  001a2	3b 8a 60 19 00
	00		 cmp	 ecx, DWORD PTR [edx+6496]
  001a8	7d 09		 jge	 SHORT $LN43@TabItemEx
  001aa	c6 85 7b fc ff
	ff 01		 mov	 BYTE PTR tv152[ebp], 1
  001b1	eb 07		 jmp	 SHORT $LN44@TabItemEx
$LN43@TabItemEx:
  001b3	c6 85 7b fc ff
	ff 00		 mov	 BYTE PTR tv152[ebp], 0
$LN44@TabItemEx:
  001ba	8a 85 7b fc ff
	ff		 mov	 al, BYTE PTR tv152[ebp]
  001c0	88 45 9f	 mov	 BYTE PTR _tab_bar_appearing$[ebp], al

; 6954 :     const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;

  001c3	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  001c6	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  001c9	81 e1 00 00 20
	00		 and	 ecx, 2097152		; 00200000H
  001cf	74 09		 je	 SHORT $LN45@TabItemEx
  001d1	c6 85 7b fc ff
	ff 01		 mov	 BYTE PTR tv156[ebp], 1
  001d8	eb 07		 jmp	 SHORT $LN46@TabItemEx
$LN45@TabItemEx:
  001da	c6 85 7b fc ff
	ff 00		 mov	 BYTE PTR tv156[ebp], 0
$LN46@TabItemEx:
  001e1	8a 95 7b fc ff
	ff		 mov	 dl, BYTE PTR tv156[ebp]
  001e7	88 55 93	 mov	 BYTE PTR _tab_bar_focused$[ebp], dl

; 6955 :     const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);

  001ea	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  001ed	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f0	83 c1 01	 add	 ecx, 1
  001f3	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  001f6	3b 8a 60 19 00
	00		 cmp	 ecx, DWORD PTR [edx+6496]
  001fc	7d 09		 jge	 SHORT $LN47@TabItemEx
  001fe	c6 85 7b fc ff
	ff 01		 mov	 BYTE PTR tv161[ebp], 1
  00205	eb 07		 jmp	 SHORT $LN48@TabItemEx
$LN47@TabItemEx:
  00207	c6 85 7b fc ff
	ff 00		 mov	 BYTE PTR tv161[ebp], 0
$LN48@TabItemEx:
  0020e	8a 85 7b fc ff
	ff		 mov	 al, BYTE PTR tv161[ebp]
  00214	88 45 87	 mov	 BYTE PTR _tab_appearing$[ebp], al

; 6956 :     tab->LastFrameVisible = g.FrameCount;

  00217	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  0021a	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0021d	8b 91 60 19 00
	00		 mov	 edx, DWORD PTR [ecx+6496]
  00223	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 6957 :     tab->Flags = flags;

  00226	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00229	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  0022c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 6958 : 
; 6959 :     // Append name with zero-terminator
; 6960 :     tab->NameOffset = tab_bar->TabsNames.size();

  0022f	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00232	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00235	e8 00 00 00 00	 call	 ?size@ImGuiTextBuffer@@QBEHXZ ; ImGuiTextBuffer::size
  0023a	8b 4d b4	 mov	 ecx, DWORD PTR _tab$[ebp]
  0023d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 6961 :     tab_bar->TabsNames.append(label, label + strlen(label) + 1);

  00240	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 _strlen
  00249	83 c4 04	 add	 esp, 4
  0024c	8b 4d 0c	 mov	 ecx, DWORD PTR _label$[ebp]
  0024f	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00253	52		 push	 edx
  00254	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  00257	50		 push	 eax
  00258	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0025b	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0025e	e8 00 00 00 00	 call	 ?append@ImGuiTextBuffer@@QAEXPBD0@Z ; ImGuiTextBuffer::append

; 6962 : 
; 6963 :     // If we are not reorderable, always reset offset based on submission order.
; 6964 :     // (We already handled layout and sizing using the previous known order, but sizing is not affected by order!)
; 6965 :     if (!tab_appearing && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable))

  00263	0f b6 45 87	 movzx	 eax, BYTE PTR _tab_appearing$[ebp]
  00267	85 c0		 test	 eax, eax
  00269	75 3a		 jne	 SHORT $LN9@TabItemEx
  0026b	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0026e	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00271	83 e1 01	 and	 ecx, 1
  00274	75 2f		 jne	 SHORT $LN9@TabItemEx

; 6966 :     {
; 6967 :         tab->Offset = tab_bar->OffsetNextTab;

  00276	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00279	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0027c	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0027f	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 6968 :         tab_bar->OffsetNextTab += tab->Width + g.Style.ItemInnerSpacing.x;

  00282	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00285	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00288	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0028d	f3 0f 58 81 60
	15 00 00	 addss	 xmm0, DWORD PTR [ecx+5472]
  00295	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  00298	f3 0f 58 42 40	 addss	 xmm0, DWORD PTR [edx+64]
  0029d	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002a0	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0
$LN9@TabItemEx:

; 6969 :     }
; 6970 : 
; 6971 :     // Update selected tab
; 6972 :     if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)

  002a5	0f b6 45 87	 movzx	 eax, BYTE PTR _tab_appearing$[ebp]
  002a9	85 c0		 test	 eax, eax
  002ab	74 2e		 je	 SHORT $LN11@TabItemEx
  002ad	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002b0	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  002b3	83 e1 02	 and	 ecx, 2
  002b6	74 23		 je	 SHORT $LN11@TabItemEx
  002b8	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002bb	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  002bf	75 1a		 jne	 SHORT $LN11@TabItemEx

; 6973 :         if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)

  002c1	0f b6 45 9f	 movzx	 eax, BYTE PTR _tab_bar_appearing$[ebp]
  002c5	85 c0		 test	 eax, eax
  002c7	74 09		 je	 SHORT $LN12@TabItemEx
  002c9	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002cc	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  002d0	75 09		 jne	 SHORT $LN11@TabItemEx
$LN12@TabItemEx:

; 6974 :             tab_bar->NextSelectedTabId = id;  // New tabs gets activated

  002d2	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002d5	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  002d8	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN11@TabItemEx:

; 6975 :     if ((flags & ImGuiTabItemFlags_SetSelected) && (tab_bar->SelectedTabId != id)) // SetSelected can only be passed on explicit tab bar

  002db	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  002de	83 e0 02	 and	 eax, 2
  002e1	74 14		 je	 SHORT $LN13@TabItemEx
  002e3	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002e6	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002e9	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  002ec	74 09		 je	 SHORT $LN13@TabItemEx

; 6976 :         tab_bar->NextSelectedTabId = id;

  002ee	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002f1	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  002f4	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN13@TabItemEx:

; 6977 : 
; 6978 :     // Lock visibility
; 6979 :     bool tab_contents_visible = (tab_bar->VisibleTabId == id);

  002f7	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  002fa	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  002fd	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  00300	75 0c		 jne	 SHORT $LN49@TabItemEx
  00302	c7 85 78 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv211[ebp], 1
  0030c	eb 0a		 jmp	 SHORT $LN50@TabItemEx
$LN49@TabItemEx:
  0030e	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv211[ebp], 0
$LN50@TabItemEx:
  00318	8a 95 78 fc ff
	ff		 mov	 dl, BYTE PTR tv211[ebp]
  0031e	88 95 7b ff ff
	ff		 mov	 BYTE PTR _tab_contents_visible$[ebp], dl

; 6980 :     if (tab_contents_visible)

  00324	0f b6 85 7b ff
	ff ff		 movzx	 eax, BYTE PTR _tab_contents_visible$[ebp]
  0032b	85 c0		 test	 eax, eax
  0032d	74 07		 je	 SHORT $LN14@TabItemEx

; 6981 :         tab_bar->VisibleTabWasSubmitted = true;

  0032f	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00332	c6 40 5e 01	 mov	 BYTE PTR [eax+94], 1
$LN14@TabItemEx:

; 6982 : 
; 6983 :     // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
; 6984 :     if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)

  00336	0f b6 85 7b ff
	ff ff		 movzx	 eax, BYTE PTR _tab_contents_visible$[ebp]
  0033d	85 c0		 test	 eax, eax
  0033f	75 2b		 jne	 SHORT $LN16@TabItemEx
  00341	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00344	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00348	75 22		 jne	 SHORT $LN16@TabItemEx
  0034a	0f b6 45 9f	 movzx	 eax, BYTE PTR _tab_bar_appearing$[ebp]
  0034e	85 c0		 test	 eax, eax
  00350	74 1a		 je	 SHORT $LN16@TabItemEx

; 6985 :         if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))

  00352	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00355	83 38 01	 cmp	 DWORD PTR [eax], 1
  00358	75 12		 jne	 SHORT $LN16@TabItemEx
  0035a	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0035d	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00360	83 e1 02	 and	 ecx, 2
  00363	75 07		 jne	 SHORT $LN16@TabItemEx

; 6986 :             tab_contents_visible = true;

  00365	c6 85 7b ff ff
	ff 01		 mov	 BYTE PTR _tab_contents_visible$[ebp], 1
$LN16@TabItemEx:

; 6987 : 
; 6988 :     if (tab_appearing && !(tab_bar_appearing && !tab_is_new))

  0036c	0f b6 45 87	 movzx	 eax, BYTE PTR _tab_appearing$[ebp]
  00370	85 c0		 test	 eax, eax
  00372	74 46		 je	 SHORT $LN17@TabItemEx
  00374	0f b6 45 9f	 movzx	 eax, BYTE PTR _tab_bar_appearing$[ebp]
  00378	85 c0		 test	 eax, eax
  0037a	74 08		 je	 SHORT $LN18@TabItemEx
  0037c	0f b6 45 ab	 movzx	 eax, BYTE PTR _tab_is_new$[ebp]
  00380	85 c0		 test	 eax, eax
  00382	74 36		 je	 SHORT $LN17@TabItemEx
$LN18@TabItemEx:

; 6989 :     {
; 6990 :         PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);

  00384	6a 01		 push	 1
  00386	6a 18		 push	 24			; 00000018H
  00388	e8 00 00 00 00	 call	 ?PushItemFlag@ImGui@@YAXH_N@Z ; ImGui::PushItemFlag
  0038d	83 c4 08	 add	 esp, 8

; 6991 :         ItemAdd(ImRect(), id);

  00390	6a 00		 push	 0
  00392	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00395	50		 push	 eax
  00396	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0039c	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  003a1	50		 push	 eax
  003a2	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6992 :         PopItemFlag();

  003aa	e8 00 00 00 00	 call	 ?PopItemFlag@ImGui@@YAXXZ ; ImGui::PopItemFlag

; 6993 :         return tab_contents_visible;

  003af	8a 85 7b ff ff
	ff		 mov	 al, BYTE PTR _tab_contents_visible$[ebp]
  003b5	e9 7e 06 00 00	 jmp	 $LN1@TabItemEx
$LN17@TabItemEx:

; 6994 :     }
; 6995 : 
; 6996 :     if (tab_bar->SelectedTabId == id)

  003ba	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  003bd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003c0	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  003c3	75 0f		 jne	 SHORT $LN19@TabItemEx

; 6997 :         tab->LastFrameSelected = g.FrameCount;

  003c5	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  003c8	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  003cb	8b 91 60 19 00
	00		 mov	 edx, DWORD PTR [ecx+6496]
  003d1	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN19@TabItemEx:

; 6998 : 
; 6999 :     // Backup current layout position
; 7000 :     const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

  003d4	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  003d7	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  003dd	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  003e3	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _backup_main_cursor_pos$[ebp], ecx
  003e9	89 95 6c ff ff
	ff		 mov	 DWORD PTR _backup_main_cursor_pos$[ebp+4], edx

; 7001 : 
; 7002 :     // Layout
; 7003 :     size.x = tab->Width;

  003ef	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  003f2	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  003f7	f3 0f 11 45 c0	 movss	 DWORD PTR _size$[ebp], xmm0

; 7004 :     window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(IM_FLOOR(tab->Offset - tab_bar->ScrollingAnim), 0.0f);

  003fc	51		 push	 ecx
  003fd	0f 57 c0	 xorps	 xmm0, xmm0
  00400	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00405	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00408	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0040b	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00410	f3 0f 5c 41 44	 subss	 xmm0, DWORD PTR [ecx+68]
  00415	f3 0f 2c d0	 cvttss2si edx, xmm0
  00419	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0041d	51		 push	 ecx
  0041e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00423	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00429	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0042e	50		 push	 eax
  0042f	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00432	83 c0 24	 add	 eax, 36			; 00000024H
  00435	50		 push	 eax
  00436	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0043c	51		 push	 ecx
  0043d	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00442	83 c4 0c	 add	 esp, 12			; 0000000cH
  00445	8b 10		 mov	 edx, DWORD PTR [eax]
  00447	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0044a	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  0044d	89 91 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], edx
  00453	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax

; 7005 :     ImVec2 pos = window->DC.CursorPos;

  00459	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0045c	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00462	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00468	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _pos$[ebp], ecx
  0046e	89 95 5c ff ff
	ff		 mov	 DWORD PTR _pos$[ebp+4], edx

; 7006 :     ImRect bb(pos, pos + size);

  00474	8d 45 c0	 lea	 eax, DWORD PTR _size$[ebp]
  00477	50		 push	 eax
  00478	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _pos$[ebp]
  0047e	51		 push	 ecx
  0047f	8d 95 b0 fc ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00485	52		 push	 edx
  00486	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0048b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0048e	50		 push	 eax
  0048f	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _pos$[ebp]
  00495	50		 push	 eax
  00496	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  0049c	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 7007 : 
; 7008 :     // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
; 7009 :     bool want_clip_rect = (bb.Min.x < tab_bar->BarRect.Min.x) || (bb.Max.x > tab_bar->BarRect.Max.x);

  004a1	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  004a4	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  004a9	0f 2f 85 40 ff
	ff ff		 comiss	 xmm0, DWORD PTR _bb$[ebp]
  004b0	77 1d		 ja	 SHORT $LN51@TabItemEx
  004b2	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  004b5	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp+8]
  004bd	0f 2f 41 2c	 comiss	 xmm0, DWORD PTR [ecx+44]
  004c1	77 0c		 ja	 SHORT $LN51@TabItemEx
  004c3	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv287[ebp], 0
  004cd	eb 0a		 jmp	 SHORT $LN52@TabItemEx
$LN51@TabItemEx:
  004cf	c7 85 78 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv287[ebp], 1
$LN52@TabItemEx:
  004d9	8a 95 78 fc ff
	ff		 mov	 dl, BYTE PTR tv287[ebp]
  004df	88 95 37 ff ff
	ff		 mov	 BYTE PTR _want_clip_rect$[ebp], dl

; 7010 :     if (want_clip_rect)

  004e5	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _want_clip_rect$[ebp]
  004ec	85 c0		 test	 eax, eax
  004ee	74 7b		 je	 SHORT $LN20@TabItemEx

; 7011 :         PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->BarRect.Min.x), bb.Min.y - 1), ImVec2(tab_bar->BarRect.Max.x, bb.Max.y), true);

  004f0	6a 01		 push	 1
  004f2	51		 push	 ecx
  004f3	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp+12]
  004fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00500	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00503	51		 push	 ecx
  00504	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  00509	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0050e	8d 8d a0 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00514	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00519	50		 push	 eax
  0051a	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp+4]
  00522	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0052a	51		 push	 ecx
  0052b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00530	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00533	51		 push	 ecx
  00534	f3 0f 10 41 24	 movss	 xmm0, DWORD PTR [ecx+36]
  00539	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0053e	51		 push	 ecx
  0053f	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp]
  00547	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0054c	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00551	83 c4 04	 add	 esp, 4
  00554	d9 1c 24	 fstp	 DWORD PTR [esp]
  00557	8d 8d 90 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0055d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00562	50		 push	 eax
  00563	e8 00 00 00 00	 call	 ?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
  00568	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@TabItemEx:

; 7012 : 
; 7013 :     ImVec2 backup_cursor_max_pos = window->DC.CursorMaxPos;

  0056b	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0056e	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  00574	8b 90 e4 00 00
	00		 mov	 edx, DWORD PTR [eax+228]
  0057a	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _backup_cursor_max_pos$[ebp], ecx
  00580	89 95 28 ff ff
	ff		 mov	 DWORD PTR _backup_cursor_max_pos$[ebp+4], edx

; 7014 :     ItemSize(bb.GetSize(), style.FramePadding.y);

  00586	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00589	51		 push	 ecx
  0058a	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0058f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00594	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0059a	51		 push	 ecx
  0059b	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  005a1	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetSize
  005a6	50		 push	 eax
  005a7	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  005ac	83 c4 08	 add	 esp, 8

; 7015 :     window->DC.CursorMaxPos = backup_cursor_max_pos;

  005af	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  005b2	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _backup_cursor_max_pos$[ebp]
  005b8	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx
  005be	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _backup_cursor_max_pos$[ebp+4]
  005c4	89 90 e4 00 00
	00		 mov	 DWORD PTR [eax+228], edx

; 7016 : 
; 7017 :     if (!ItemAdd(bb, id))

  005ca	6a 00		 push	 0
  005cc	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  005cf	50		 push	 eax
  005d0	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  005d6	51		 push	 ecx
  005d7	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  005dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  005df	0f b6 d0	 movzx	 edx, al
  005e2	85 d2		 test	 edx, edx
  005e4	75 36		 jne	 SHORT $LN21@TabItemEx

; 7018 :     {
; 7019 :         if (want_clip_rect)

  005e6	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _want_clip_rect$[ebp]
  005ed	85 c0		 test	 eax, eax
  005ef	74 05		 je	 SHORT $LN22@TabItemEx

; 7020 :             PopClipRect();

  005f1	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect
$LN22@TabItemEx:

; 7021 :         window->DC.CursorPos = backup_main_cursor_pos;

  005f6	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  005f9	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _backup_main_cursor_pos$[ebp]
  005ff	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  00605	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _backup_main_cursor_pos$[ebp+4]
  0060b	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 7022 :         return tab_contents_visible;

  00611	8a 85 7b ff ff
	ff		 mov	 al, BYTE PTR _tab_contents_visible$[ebp]
  00617	e9 1c 04 00 00	 jmp	 $LN1@TabItemEx
$LN21@TabItemEx:

; 7023 :     }
; 7024 : 
; 7025 :     // Click to Select a tab
; 7026 :     ImGuiButtonFlags button_flags = (ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_AllowItemOverlap);

  0061c	c7 85 18 ff ff
	ff 44 00 00 00	 mov	 DWORD PTR _button_flags$[ebp], 68 ; 00000044H

; 7027 :     if (g.DragDropActive)

  00626	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00629	0f b6 88 34 1d
	00 00		 movzx	 ecx, BYTE PTR [eax+7476]
  00630	85 c9		 test	 ecx, ecx
  00632	74 11		 je	 SHORT $LN23@TabItemEx

; 7028 :         button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

  00634	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  0063a	0d 00 10 00 00	 or	 eax, 4096		; 00001000H
  0063f	89 85 18 ff ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN23@TabItemEx:

; 7029 :     bool hovered, held;
; 7030 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

  00645	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  0064b	50		 push	 eax
  0064c	8d 8d 03 ff ff
	ff		 lea	 ecx, DWORD PTR _held$[ebp]
  00652	51		 push	 ecx
  00653	8d 95 0f ff ff
	ff		 lea	 edx, DWORD PTR _hovered$[ebp]
  00659	52		 push	 edx
  0065a	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0065d	50		 push	 eax
  0065e	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  00664	51		 push	 ecx
  00665	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  0066a	83 c4 14	 add	 esp, 20			; 00000014H
  0066d	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 7031 :     if (pressed)

  00673	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  0067a	85 c0		 test	 eax, eax
  0067c	74 09		 je	 SHORT $LN24@TabItemEx

; 7032 :         tab_bar->NextSelectedTabId = id;

  0067e	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00681	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00684	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN24@TabItemEx:

; 7033 :     hovered |= (g.HoveredId == id);

  00687	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0068a	8b 88 d0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6608]
  00690	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  00693	75 0c		 jne	 SHORT $LN53@TabItemEx
  00695	c7 85 78 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv382[ebp], 1
  0069f	eb 0a		 jmp	 SHORT $LN54@TabItemEx
$LN53@TabItemEx:
  006a1	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv382[ebp], 0
$LN54@TabItemEx:
  006ab	0f b6 95 0f ff
	ff ff		 movzx	 edx, BYTE PTR _hovered$[ebp]
  006b2	0b 95 78 fc ff
	ff		 or	 edx, DWORD PTR tv382[ebp]
  006b8	88 95 0f ff ff
	ff		 mov	 BYTE PTR _hovered$[ebp], dl

; 7034 : 
; 7035 :     // Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)
; 7036 :     if (!held)

  006be	0f b6 85 03 ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  006c5	85 c0		 test	 eax, eax
  006c7	75 05		 jne	 SHORT $LN25@TabItemEx

; 7037 :         SetItemAllowOverlap();

  006c9	e8 00 00 00 00	 call	 ?SetItemAllowOverlap@ImGui@@YAXXZ ; ImGui::SetItemAllowOverlap
$LN25@TabItemEx:

; 7038 : 
; 7039 :     // Drag and drop: re-order tabs
; 7040 :     if (held && !tab_appearing && IsMouseDragging(0))

  006ce	0f b6 85 03 ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  006d5	85 c0		 test	 eax, eax
  006d7	0f 84 d7 00 00
	00		 je	 $LN32@TabItemEx
  006dd	0f b6 45 87	 movzx	 eax, BYTE PTR _tab_appearing$[ebp]
  006e1	85 c0		 test	 eax, eax
  006e3	0f 85 cb 00 00
	00		 jne	 $LN32@TabItemEx
  006e9	51		 push	 ecx
  006ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  006f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006f7	6a 00		 push	 0
  006f9	e8 00 00 00 00	 call	 ?IsMouseDragging@ImGui@@YA_NHM@Z ; ImGui::IsMouseDragging
  006fe	83 c4 08	 add	 esp, 8
  00701	0f b6 c0	 movzx	 eax, al
  00704	85 c0		 test	 eax, eax
  00706	0f 84 a8 00 00
	00		 je	 $LN32@TabItemEx

; 7041 :     {
; 7042 :         if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable))

  0070c	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0070f	0f b6 88 34 1d
	00 00		 movzx	 ecx, BYTE PTR [eax+7476]
  00716	85 c9		 test	 ecx, ecx
  00718	0f 85 96 00 00
	00		 jne	 $LN32@TabItemEx
  0071e	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00721	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00724	83 e1 01	 and	 ecx, 1
  00727	0f 84 87 00 00
	00		 je	 $LN32@TabItemEx

; 7043 :         {
; 7044 :             // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
; 7045 :             if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)

  0072d	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00730	0f 57 c0	 xorps	 xmm0, xmm0
  00733	0f 2f 80 78 03
	00 00		 comiss	 xmm0, DWORD PTR [eax+888]
  0073a	76 33		 jbe	 SHORT $LN28@TabItemEx
  0073c	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0073f	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp]
  00747	0f 2f 80 e8 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+232]
  0074e	76 1f		 jbe	 SHORT $LN28@TabItemEx

; 7046 :             {
; 7047 :                 if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)

  00750	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00753	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00756	83 e1 01	 and	 ecx, 1
  00759	74 12		 je	 SHORT $LN30@TabItemEx

; 7048 :                     TabBarQueueChangeTabOrder(tab_bar, tab, -1);

  0075b	6a ff		 push	 -1
  0075d	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  00760	50		 push	 eax
  00761	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00764	51		 push	 ecx
  00765	e8 00 00 00 00	 call	 ?TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
  0076a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@TabItemEx:

; 7049 :             }

  0076d	eb 45		 jmp	 SHORT $LN32@TabItemEx
$LN28@TabItemEx:

; 7050 :             else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)

  0076f	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00772	f3 0f 10 80 78
	03 00 00	 movss	 xmm0, DWORD PTR [eax+888]
  0077a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00781	76 31		 jbe	 SHORT $LN32@TabItemEx
  00783	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00786	f3 0f 10 80 e8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+232]
  0078e	0f 2f 85 48 ff
	ff ff		 comiss	 xmm0, DWORD PTR _bb$[ebp+8]
  00795	76 1d		 jbe	 SHORT $LN32@TabItemEx

; 7051 :             {
; 7052 :                 if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)

  00797	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0079a	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0079d	83 e1 01	 and	 ecx, 1
  007a0	74 12		 je	 SHORT $LN32@TabItemEx

; 7053 :                     TabBarQueueChangeTabOrder(tab_bar, tab, +1);

  007a2	6a 01		 push	 1
  007a4	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  007a7	50		 push	 eax
  007a8	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  007ab	51		 push	 ecx
  007ac	e8 00 00 00 00	 call	 ?TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z ; ImGui::TabBarQueueChangeTabOrder
  007b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@TabItemEx:

; 7054 :             }
; 7055 :         }
; 7056 :     }
; 7057 : 
; 7058 : #if 0
; 7059 :     if (hovered && g.HoveredIdNotActiveTimer > 0.50f && bb.GetWidth() < tab->ContentWidth)
; 7060 :     {
; 7061 :         // Enlarge tab display when hovering
; 7062 :         bb.Max.x = bb.Min.x + IM_FLOOR(ImLerp(bb.GetWidth(), tab->ContentWidth, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f)));
; 7063 :         display_draw_list = GetForegroundDrawList(window);
; 7064 :         TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
; 7065 :     }
; 7066 : #endif
; 7067 : 
; 7068 :     // Render tab shape
; 7069 :     ImDrawList* display_draw_list = window->DrawList;

  007b4	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  007b7	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  007bd	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _display_draw_list$[ebp], ecx

; 7070 :     const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));

  007c3	0f b6 85 03 ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  007ca	85 c0		 test	 eax, eax
  007cc	75 7a		 jne	 SHORT $LN55@TabItemEx
  007ce	0f b6 8d 0f ff
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  007d5	85 c9		 test	 ecx, ecx
  007d7	75 6f		 jne	 SHORT $LN55@TabItemEx
  007d9	0f b6 95 7b ff
	ff ff		 movzx	 edx, BYTE PTR _tab_contents_visible$[ebp]
  007e0	85 d2		 test	 edx, edx
  007e2	74 2c		 je	 SHORT $LN60@TabItemEx
  007e4	0f b6 45 93	 movzx	 eax, BYTE PTR _tab_bar_focused$[ebp]
  007e8	85 c0		 test	 eax, eax
  007ea	74 0c		 je	 SHORT $LN56@TabItemEx
  007ec	c7 85 78 fc ff
	ff 23 00 00 00	 mov	 DWORD PTR tv439[ebp], 35 ; 00000023H
  007f6	eb 0a		 jmp	 SHORT $LN57@TabItemEx
$LN56@TabItemEx:
  007f8	c7 85 78 fc ff
	ff 25 00 00 00	 mov	 DWORD PTR tv439[ebp], 37 ; 00000025H
$LN57@TabItemEx:
  00802	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR tv439[ebp]
  00808	89 8d 74 fc ff
	ff		 mov	 DWORD PTR tv445[ebp], ecx
  0080e	eb 2a		 jmp	 SHORT $LN61@TabItemEx
$LN60@TabItemEx:
  00810	0f b6 55 93	 movzx	 edx, BYTE PTR _tab_bar_focused$[ebp]
  00814	85 d2		 test	 edx, edx
  00816	74 0c		 je	 SHORT $LN58@TabItemEx
  00818	c7 85 70 fc ff
	ff 21 00 00 00	 mov	 DWORD PTR tv442[ebp], 33 ; 00000021H
  00822	eb 0a		 jmp	 SHORT $LN59@TabItemEx
$LN58@TabItemEx:
  00824	c7 85 70 fc ff
	ff 24 00 00 00	 mov	 DWORD PTR tv442[ebp], 36 ; 00000024H
$LN59@TabItemEx:
  0082e	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR tv442[ebp]
  00834	89 85 74 fc ff
	ff		 mov	 DWORD PTR tv445[ebp], eax
$LN61@TabItemEx:
  0083a	8b 8d 74 fc ff
	ff		 mov	 ecx, DWORD PTR tv445[ebp]
  00840	89 8d 6c fc ff
	ff		 mov	 DWORD PTR tv446[ebp], ecx
  00846	eb 0a		 jmp	 SHORT $LN62@TabItemEx
$LN55@TabItemEx:
  00848	c7 85 6c fc ff
	ff 22 00 00 00	 mov	 DWORD PTR tv446[ebp], 34 ; 00000022H
$LN62@TabItemEx:
  00852	51		 push	 ecx
  00853	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0085b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00860	8b 95 6c fc ff
	ff		 mov	 edx, DWORD PTR tv446[ebp]
  00866	52		 push	 edx
  00867	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0086c	83 c4 08	 add	 esp, 8
  0086f	89 85 dc fe ff
	ff		 mov	 DWORD PTR _tab_col$[ebp], eax

; 7071 :     TabItemBackground(display_draw_list, bb, flags, tab_col);

  00875	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _tab_col$[ebp]
  0087b	50		 push	 eax
  0087c	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  0087f	51		 push	 ecx
  00880	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR _bb$[ebp]
  00886	52		 push	 edx
  00887	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _display_draw_list$[ebp]
  0088d	50		 push	 eax
  0088e	e8 00 00 00 00	 call	 ?TabItemBackground@ImGui@@YAXPAUImDrawList@@ABUImRect@@HI@Z ; ImGui::TabItemBackground
  00893	83 c4 10	 add	 esp, 16			; 00000010H

; 7072 :     RenderNavHighlight(bb, id);

  00896	6a 01		 push	 1
  00898	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0089b	50		 push	 eax
  0089c	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  008a2	51		 push	 ecx
  008a3	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  008a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7073 : 
; 7074 :     // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
; 7075 :     const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);

  008ab	6a 08		 push	 8
  008ad	e8 00 00 00 00	 call	 ?IsItemHovered@ImGui@@YA_NH@Z ; ImGui::IsItemHovered
  008b2	83 c4 04	 add	 esp, 4
  008b5	88 85 d3 fe ff
	ff		 mov	 BYTE PTR _hovered_unblocked$[ebp], al

; 7076 :     if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)))

  008bb	0f b6 85 d3 fe
	ff ff		 movzx	 eax, BYTE PTR _hovered_unblocked$[ebp]
  008c2	85 c0		 test	 eax, eax
  008c4	74 2d		 je	 SHORT $LN33@TabItemEx
  008c6	6a 00		 push	 0
  008c8	6a 01		 push	 1
  008ca	e8 00 00 00 00	 call	 ?IsMouseClicked@ImGui@@YA_NH_N@Z ; ImGui::IsMouseClicked
  008cf	83 c4 08	 add	 esp, 8
  008d2	0f b6 c0	 movzx	 eax, al
  008d5	85 c0		 test	 eax, eax
  008d7	75 11		 jne	 SHORT $LN34@TabItemEx
  008d9	6a 01		 push	 1
  008db	e8 00 00 00 00	 call	 ?IsMouseReleased@ImGui@@YA_NH@Z ; ImGui::IsMouseReleased
  008e0	83 c4 04	 add	 esp, 4
  008e3	0f b6 c0	 movzx	 eax, al
  008e6	85 c0		 test	 eax, eax
  008e8	74 09		 je	 SHORT $LN33@TabItemEx
$LN34@TabItemEx:

; 7077 :         tab_bar->NextSelectedTabId = id;

  008ea	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  008ed	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  008f0	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN33@TabItemEx:

; 7078 : 
; 7079 :     if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)

  008f3	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  008f6	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  008f9	83 e1 08	 and	 ecx, 8
  008fc	74 09		 je	 SHORT $LN35@TabItemEx

; 7080 :         flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

  008fe	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00901	83 c8 04	 or	 eax, 4
  00904	89 45 14	 mov	 DWORD PTR _flags$[ebp], eax
$LN35@TabItemEx:

; 7081 : 
; 7082 :     // Render tab label, process close button
; 7083 :     const ImGuiID close_button_id = p_open ? window->GetID((void*)((intptr_t)id + 1)) : 0;

  00907	83 7d 10 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  0090b	74 17		 je	 SHORT $LN63@TabItemEx
  0090d	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00910	83 c0 01	 add	 eax, 1
  00913	50		 push	 eax
  00914	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00917	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBX@Z ; ImGuiWindow::GetID
  0091c	89 85 78 fc ff
	ff		 mov	 DWORD PTR tv478[ebp], eax
  00922	eb 0a		 jmp	 SHORT $LN64@TabItemEx
$LN63@TabItemEx:
  00924	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv478[ebp], 0
$LN64@TabItemEx:
  0092e	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR tv478[ebp]
  00934	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _close_button_id$[ebp], ecx

; 7084 :     bool just_closed = TabItemLabelAndCloseButton(display_draw_list, bb, flags, tab_bar->FramePadding, label, id, close_button_id);

  0093a	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _close_button_id$[ebp]
  00940	50		 push	 eax
  00941	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00944	51		 push	 ecx
  00945	8b 55 0c	 mov	 edx, DWORD PTR _label$[ebp]
  00948	52		 push	 edx
  00949	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0094c	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0094f	51		 push	 ecx
  00950	8b 50 64	 mov	 edx, DWORD PTR [eax+100]
  00953	52		 push	 edx
  00954	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00957	50		 push	 eax
  00958	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  0095e	51		 push	 ecx
  0095f	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _display_draw_list$[ebp]
  00965	52		 push	 edx
  00966	e8 00 00 00 00	 call	 ?TabItemLabelAndCloseButton@ImGui@@YA_NPAUImDrawList@@ABUImRect@@HUImVec2@@PBDII@Z ; ImGui::TabItemLabelAndCloseButton
  0096b	83 c4 20	 add	 esp, 32			; 00000020H
  0096e	88 85 bb fe ff
	ff		 mov	 BYTE PTR _just_closed$[ebp], al

; 7085 :     if (just_closed && p_open != NULL)

  00974	0f b6 85 bb fe
	ff ff		 movzx	 eax, BYTE PTR _just_closed$[ebp]
  0097b	85 c0		 test	 eax, eax
  0097d	74 1c		 je	 SHORT $LN36@TabItemEx
  0097f	83 7d 10 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  00983	74 16		 je	 SHORT $LN36@TabItemEx

; 7086 :     {
; 7087 :         *p_open = false;

  00985	8b 45 10	 mov	 eax, DWORD PTR _p_open$[ebp]
  00988	c6 00 00	 mov	 BYTE PTR [eax], 0

; 7088 :         TabBarCloseTab(tab_bar, tab);

  0098b	8b 45 b4	 mov	 eax, DWORD PTR _tab$[ebp]
  0098e	50		 push	 eax
  0098f	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00992	51		 push	 ecx
  00993	e8 00 00 00 00	 call	 ?TabBarCloseTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z ; ImGui::TabBarCloseTab
  00998	83 c4 08	 add	 esp, 8
$LN36@TabItemEx:

; 7089 :     }
; 7090 : 
; 7091 :     // Restore main window position so user can draw there
; 7092 :     if (want_clip_rect)

  0099b	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _want_clip_rect$[ebp]
  009a2	85 c0		 test	 eax, eax
  009a4	74 05		 je	 SHORT $LN37@TabItemEx

; 7093 :         PopClipRect();

  009a6	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect
$LN37@TabItemEx:

; 7094 :     window->DC.CursorPos = backup_main_cursor_pos;

  009ab	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  009ae	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _backup_main_cursor_pos$[ebp]
  009b4	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  009ba	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _backup_main_cursor_pos$[ebp+4]
  009c0	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 7095 : 
; 7096 :     // Tooltip (FIXME: Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer)
; 7097 :     // We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar (which g.HoveredId ignores)
; 7098 :     if (g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.50f && IsItemHovered())

  009c6	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  009c9	8b 88 d0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6608]
  009cf	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  009d2	75 5e		 jne	 SHORT $LN39@TabItemEx
  009d4	0f b6 85 03 ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  009db	85 c0		 test	 eax, eax
  009dd	75 53		 jne	 SHORT $LN39@TabItemEx
  009df	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  009e2	f3 0f 10 80 e0
	19 00 00	 movss	 xmm0, DWORD PTR [eax+6624]
  009ea	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f000000
  009f1	76 3f		 jbe	 SHORT $LN39@TabItemEx
  009f3	6a 00		 push	 0
  009f5	e8 00 00 00 00	 call	 ?IsItemHovered@ImGui@@YA_NH@Z ; ImGui::IsItemHovered
  009fa	83 c4 04	 add	 esp, 4
  009fd	0f b6 c0	 movzx	 eax, al
  00a00	85 c0		 test	 eax, eax
  00a02	74 2e		 je	 SHORT $LN39@TabItemEx

; 7099 :         if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip))

  00a04	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00a07	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00a0a	83 e1 20	 and	 ecx, 32			; 00000020H
  00a0d	75 23		 jne	 SHORT $LN39@TabItemEx

; 7100 :             SetTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);

  00a0f	8b 45 0c	 mov	 eax, DWORD PTR _label$[ebp]
  00a12	50		 push	 eax
  00a13	6a 00		 push	 0
  00a15	8b 4d 0c	 mov	 ecx, DWORD PTR _label$[ebp]
  00a18	51		 push	 ecx
  00a19	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  00a1e	83 c4 08	 add	 esp, 8
  00a21	2b 45 0c	 sub	 eax, DWORD PTR _label$[ebp]
  00a24	50		 push	 eax
  00a25	68 00 00 00 00	 push	 OFFSET ??_C@_04EBNJJJJI@?$CF?4?$CKs@
  00a2a	e8 00 00 00 00	 call	 ?SetTooltip@ImGui@@YAXPBDZZ ; ImGui::SetTooltip
  00a2f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@TabItemEx:

; 7101 : 
; 7102 :     return tab_contents_visible;

  00a32	8a 85 7b ff ff
	ff		 mov	 al, BYTE PTR _tab_contents_visible$[ebp]
$LN1@TabItemEx:

; 7103 : }

  00a38	52		 push	 edx
  00a39	8b cd		 mov	 ecx, ebp
  00a3b	50		 push	 eax
  00a3c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN73@TabItemEx
  00a42	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00a47	58		 pop	 eax
  00a48	5a		 pop	 edx
  00a49	5f		 pop	 edi
  00a4a	5e		 pop	 esi
  00a4b	5b		 pop	 ebx
  00a4c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a4f	33 cd		 xor	 ecx, ebp
  00a51	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a56	81 c4 94 03 00
	00		 add	 esp, 916		; 00000394H
  00a5c	3b ec		 cmp	 ebp, esp
  00a5e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a63	8b e5		 mov	 esp, ebp
  00a65	5d		 pop	 ebp
  00a66	c3		 ret	 0
  00a67	90		 npad	 1
$LN73@TabItemEx:
  00a68	07 00 00 00	 DD	 7
  00a6c	00 00 00 00	 DD	 $LN72@TabItemEx
$LN72@TabItemEx:
  00a70	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00a74	08 00 00 00	 DD	 8
  00a78	00 00 00 00	 DD	 $LN65@TabItemEx
  00a7c	68 ff ff ff	 DD	 -152			; ffffff68H
  00a80	08 00 00 00	 DD	 8
  00a84	00 00 00 00	 DD	 $LN66@TabItemEx
  00a88	58 ff ff ff	 DD	 -168			; ffffff58H
  00a8c	08 00 00 00	 DD	 8
  00a90	00 00 00 00	 DD	 $LN67@TabItemEx
  00a94	40 ff ff ff	 DD	 -192			; ffffff40H
  00a98	10 00 00 00	 DD	 16			; 00000010H
  00a9c	00 00 00 00	 DD	 $LN68@TabItemEx
  00aa0	24 ff ff ff	 DD	 -220			; ffffff24H
  00aa4	08 00 00 00	 DD	 8
  00aa8	00 00 00 00	 DD	 $LN69@TabItemEx
  00aac	0f ff ff ff	 DD	 -241			; ffffff0fH
  00ab0	01 00 00 00	 DD	 1
  00ab4	00 00 00 00	 DD	 $LN70@TabItemEx
  00ab8	03 ff ff ff	 DD	 -253			; ffffff03H
  00abc	01 00 00 00	 DD	 1
  00ac0	00 00 00 00	 DD	 $LN71@TabItemEx
$LN71@TabItemEx:
  00ac4	68		 DB	 104			; 00000068H
  00ac5	65		 DB	 101			; 00000065H
  00ac6	6c		 DB	 108			; 0000006cH
  00ac7	64		 DB	 100			; 00000064H
  00ac8	00		 DB	 0
$LN70@TabItemEx:
  00ac9	68		 DB	 104			; 00000068H
  00aca	6f		 DB	 111			; 0000006fH
  00acb	76		 DB	 118			; 00000076H
  00acc	65		 DB	 101			; 00000065H
  00acd	72		 DB	 114			; 00000072H
  00ace	65		 DB	 101			; 00000065H
  00acf	64		 DB	 100			; 00000064H
  00ad0	00		 DB	 0
$LN69@TabItemEx:
  00ad1	62		 DB	 98			; 00000062H
  00ad2	61		 DB	 97			; 00000061H
  00ad3	63		 DB	 99			; 00000063H
  00ad4	6b		 DB	 107			; 0000006bH
  00ad5	75		 DB	 117			; 00000075H
  00ad6	70		 DB	 112			; 00000070H
  00ad7	5f		 DB	 95			; 0000005fH
  00ad8	63		 DB	 99			; 00000063H
  00ad9	75		 DB	 117			; 00000075H
  00ada	72		 DB	 114			; 00000072H
  00adb	73		 DB	 115			; 00000073H
  00adc	6f		 DB	 111			; 0000006fH
  00add	72		 DB	 114			; 00000072H
  00ade	5f		 DB	 95			; 0000005fH
  00adf	6d		 DB	 109			; 0000006dH
  00ae0	61		 DB	 97			; 00000061H
  00ae1	78		 DB	 120			; 00000078H
  00ae2	5f		 DB	 95			; 0000005fH
  00ae3	70		 DB	 112			; 00000070H
  00ae4	6f		 DB	 111			; 0000006fH
  00ae5	73		 DB	 115			; 00000073H
  00ae6	00		 DB	 0
$LN68@TabItemEx:
  00ae7	62		 DB	 98			; 00000062H
  00ae8	62		 DB	 98			; 00000062H
  00ae9	00		 DB	 0
$LN67@TabItemEx:
  00aea	70		 DB	 112			; 00000070H
  00aeb	6f		 DB	 111			; 0000006fH
  00aec	73		 DB	 115			; 00000073H
  00aed	00		 DB	 0
$LN66@TabItemEx:
  00aee	62		 DB	 98			; 00000062H
  00aef	61		 DB	 97			; 00000061H
  00af0	63		 DB	 99			; 00000063H
  00af1	6b		 DB	 107			; 0000006bH
  00af2	75		 DB	 117			; 00000075H
  00af3	70		 DB	 112			; 00000070H
  00af4	5f		 DB	 95			; 0000005fH
  00af5	6d		 DB	 109			; 0000006dH
  00af6	61		 DB	 97			; 00000061H
  00af7	69		 DB	 105			; 00000069H
  00af8	6e		 DB	 110			; 0000006eH
  00af9	5f		 DB	 95			; 0000005fH
  00afa	63		 DB	 99			; 00000063H
  00afb	75		 DB	 117			; 00000075H
  00afc	72		 DB	 114			; 00000072H
  00afd	73		 DB	 115			; 00000073H
  00afe	6f		 DB	 111			; 0000006fH
  00aff	72		 DB	 114			; 00000072H
  00b00	5f		 DB	 95			; 0000005fH
  00b01	70		 DB	 112			; 00000070H
  00b02	6f		 DB	 111			; 0000006fH
  00b03	73		 DB	 115			; 00000073H
  00b04	00		 DB	 0
$LN65@TabItemEx:
  00b05	73		 DB	 115			; 00000073H
  00b06	69		 DB	 105			; 00000069H
  00b07	7a		 DB	 122			; 0000007aH
  00b08	65		 DB	 101			; 00000065H
  00b09	00		 DB	 0
?TabItemEx@ImGui@@YA_NPAUImGuiTabBar@@PBDPA_NH@Z ENDP	; ImGui::TabItemEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z
_TEXT	SEGMENT
_tab_bar$ = 8						; size = 4
_tab$ = 12						; size = 4
_dir$ = 16						; size = 4
?TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z PROC ; ImGui::TabBarQueueChangeTabOrder, COMDAT

; 6755 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6756 :     IM_ASSERT(dir == -1 || dir == +1);

  00028	83 7d 10 ff	 cmp	 DWORD PTR _dir$[ebp], -1
  0002c	74 2b		 je	 SHORT $LN3@TabBarQueu
  0002e	83 7d 10 01	 cmp	 DWORD PTR _dir$[ebp], 1
  00032	74 25		 je	 SHORT $LN3@TabBarQueu
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z@4JA
  00039	83 c0 01	 add	 eax, 1
  0003c	8b f4		 mov	 esi, esp
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@FGAFEEBL@?$AAd?$AAi?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAd?$AAi@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@TabBarQueu:

; 6757 :     IM_ASSERT(tab_bar->ReorderRequestTabId == 0);

  00059	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0005c	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00060	74 26		 je	 SHORT $LN4@TabBarQueu
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z@4JA
  00068	83 c1 02	 add	 ecx, 2
  0006b	8b f4		 mov	 esi, esp
  0006d	51		 push	 ecx
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@NGAACFPK@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAR?$AAe?$AAo?$AAr?$AAd?$AAe@
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@TabBarQueu:

; 6758 :     tab_bar->ReorderRequestTabId = tab->ID;

  00088	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR _tab$[ebp]
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	89 50 58	 mov	 DWORD PTR [eax+88], edx

; 6759 :     tab_bar->ReorderRequestDir = (ImS8)dir;

  00093	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00096	8a 4d 10	 mov	 cl, BYTE PTR _dir$[ebp]
  00099	88 48 5c	 mov	 BYTE PTR [eax+92], cl

; 6760 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?TabBarQueueChangeTabOrder@ImGui@@YAXPAUImGuiTabBar@@PBUImGuiTabItem@@H@Z ENDP ; ImGui::TabBarQueueChangeTabOrder
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarCloseTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z
_TEXT	SEGMENT
_tab_bar$ = 8						; size = 4
_tab$ = 12						; size = 4
?TabBarCloseTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z PROC ; ImGui::TabBarCloseTab, COMDAT

; 6713 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6714 :     if ((tab_bar->VisibleTabId == tab->ID) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))

  00028	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _tab$[ebp]
  0002e	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00031	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00033	75 2b		 jne	 SHORT $LN2@TabBarClos
  00035	8b 45 0c	 mov	 eax, DWORD PTR _tab$[ebp]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	83 e1 01	 and	 ecx, 1
  0003e	75 20		 jne	 SHORT $LN2@TabBarClos

; 6715 :     {
; 6716 :         // This will remove a frame of lag for selecting another tab on closure.
; 6717 :         // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
; 6718 :         tab->LastFrameVisible = -1;

  00040	8b 45 0c	 mov	 eax, DWORD PTR _tab$[ebp]
  00043	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1

; 6719 :         tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0004d	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00057	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 6720 :     }

  0005e	eb 23		 jmp	 SHORT $LN1@TabBarClos
$LN2@TabBarClos:

; 6721 :     else if ((tab_bar->VisibleTabId != tab->ID) && (tab->Flags & ImGuiTabItemFlags_UnsavedDocument))

  00060	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _tab$[ebp]
  00066	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  00069	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0006b	74 16		 je	 SHORT $LN1@TabBarClos
  0006d	8b 45 0c	 mov	 eax, DWORD PTR _tab$[ebp]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	83 e1 01	 and	 ecx, 1
  00076	74 0b		 je	 SHORT $LN1@TabBarClos

; 6722 :     {
; 6723 :         // Actually select before expecting closure
; 6724 :         tab_bar->NextSelectedTabId = tab->ID;

  00078	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _tab$[ebp]
  0007e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00080	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN1@TabBarClos:

; 6725 :     }
; 6726 : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?TabBarCloseTab@ImGui@@YAXPAUImGuiTabBar@@PAUImGuiTabItem@@@Z ENDP ; ImGui::TabBarCloseTab
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarRemoveTab@ImGui@@YAXPAUImGuiTabBar@@I@Z
_TEXT	SEGMENT
_tab$1 = -8						; size = 4
_tab_bar$ = 8						; size = 4
_tab_id$ = 12						; size = 4
?TabBarRemoveTab@ImGui@@YAXPAUImGuiTabBar@@I@Z PROC	; ImGui::TabBarRemoveTab, COMDAT

; 6703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6704 :     if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))

  00028	8b 45 0c	 mov	 eax, DWORD PTR _tab_id$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
  00035	83 c4 08	 add	 esp, 8
  00038	89 45 f8	 mov	 DWORD PTR _tab$1[ebp], eax
  0003b	83 7d f8 00	 cmp	 DWORD PTR _tab$1[ebp], 0
  0003f	74 0c		 je	 SHORT $LN2@TabBarRemo

; 6705 :         tab_bar->Tabs.erase(tab);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _tab$1[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00048	e8 00 00 00 00	 call	 ?erase@?$ImVector@UImGuiTabItem@@@@QAEPAUImGuiTabItem@@PBU2@@Z ; ImVector<ImGuiTabItem>::erase
$LN2@TabBarRemo:

; 6706 :     if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }

  0004d	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00050	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00053	3b 4d 0c	 cmp	 ecx, DWORD PTR _tab_id$[ebp]
  00056	75 0a		 jne	 SHORT $LN3@TabBarRemo
  00058	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0005b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
$LN3@TabBarRemo:

; 6707 :     if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }

  00062	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00065	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00068	3b 4d 0c	 cmp	 ecx, DWORD PTR _tab_id$[ebp]
  0006b	75 0a		 jne	 SHORT $LN4@TabBarRemo
  0006d	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00070	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN4@TabBarRemo:

; 6708 :     if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }

  00077	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0007a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0007d	3b 4d 0c	 cmp	 ecx, DWORD PTR _tab_id$[ebp]
  00080	75 0a		 jne	 SHORT $LN1@TabBarRemo
  00082	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00085	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
$LN1@TabBarRemo:

; 6709 : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?TabBarRemoveTab@ImGui@@YAXPAUImGuiTabBar@@I@Z ENDP	; ImGui::TabBarRemoveTab
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_tab_bar$ = 8						; size = 4
_tab_id$ = 12						; size = 4
?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z PROC ; ImGui::TabBarFindTabByID, COMDAT

; 6693 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6694 :     if (tab_id != 0)

  00028	83 7d 0c 00	 cmp	 DWORD PTR _tab_id$[ebp], 0
  0002c	74 3f		 je	 SHORT $LN5@TabBarFind

; 6695 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00035	eb 09		 jmp	 SHORT $LN4@TabBarFind
$LN2@TabBarFind:
  00037	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0003a	83 c0 01	 add	 eax, 1
  0003d	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@TabBarFind:
  00040	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  00046	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00048	7d 23		 jge	 SHORT $LN5@TabBarFind

; 6696 :             if (tab_bar->Tabs[n].ID == tab_id)

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00051	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	3b 4d 0c	 cmp	 ecx, DWORD PTR _tab_id$[ebp]
  0005b	75 0e		 jne	 SHORT $LN6@TabBarFind

; 6697 :                 return &tab_bar->Tabs[n];

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00060	50		 push	 eax
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00064	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  00069	eb 04		 jmp	 SHORT $LN1@TabBarFind
$LN6@TabBarFind:
  0006b	eb ca		 jmp	 SHORT $LN2@TabBarFind
$LN5@TabBarFind:

; 6698 :     return NULL;

  0006d	33 c0		 xor	 eax, eax
$LN1@TabBarFind:

; 6699 : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?TabBarFindTabByID@ImGui@@YAPAUImGuiTabItem@@PAUImGuiTabBar@@I@Z ENDP ; ImGui::TabBarFindTabByID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z
_TEXT	SEGMENT
tv175 = -332						; size = 4
$T1 = -324						; size = 8
$T2 = -308						; size = 8
$T3 = -292						; size = 8
$T4 = -276						; size = 8
_separator_max_x$5 = -68				; size = 4
_separator_min_x$6 = -56				; size = 4
_y$ = -44						; size = 4
_col$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
_tab_bar$ = 8						; size = 4
_tab_bar_bb$ = 12					; size = 4
_flags$ = 16						; size = 4
?BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z PROC ; ImGui::BeginTabBarEx, COMDAT

; 6418 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00012	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6419 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6420 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 6421 :     if (window->SkipItems)

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003f	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00043	85 c9		 test	 ecx, ecx
  00045	74 07		 je	 SHORT $LN2@BeginTabBa

; 6422 :         return false;

  00047	32 c0		 xor	 al, al
  00049	e9 9f 02 00 00	 jmp	 $LN1@BeginTabBa
$LN2@BeginTabBa:

; 6423 : 
; 6424 :     if ((flags & ImGuiTabBarFlags_DockNode) == 0)

  0004e	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00051	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00056	75 0f		 jne	 SHORT $LN3@BeginTabBa

; 6425 :         PushOverrideID(tab_bar->ID);

  00058	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0005b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?PushOverrideID@ImGui@@YAXI@Z ; ImGui::PushOverrideID
  00064	83 c4 04	 add	 esp, 4
$LN3@BeginTabBa:

; 6426 : 
; 6427 :     // Add to stack
; 6428 :     g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));

  00067	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0006a	50		 push	 eax
  0006b	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?GetTabBarRefFromTabBar@@YA?AUImGuiPtrOrIndex@@PAUImGuiTabBar@@@Z ; GetTabBarRefFromTabBar
  00077	83 c4 08	 add	 esp, 8
  0007a	50		 push	 eax
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0007e	81 c1 e0 1d 00
	00		 add	 ecx, 7648		; 00001de0H
  00084	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXABUImGuiPtrOrIndex@@@Z ; ImVector<ImGuiPtrOrIndex>::push_back

; 6429 :     g.CurrentTabBar = tab_bar;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  0008f	89 88 c0 1d 00
	00		 mov	 DWORD PTR [eax+7616], ecx

; 6430 : 
; 6431 :     if (tab_bar->CurrFrameVisible == g.FrameCount)

  00095	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0009b	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0009e	3b 91 60 19 00
	00		 cmp	 edx, DWORD PTR [ecx+6496]
  000a4	75 31		 jne	 SHORT $LN4@BeginTabBa

; 6432 :     {
; 6433 :         //IMGUI_DEBUG_LOG("BeginTabBarEx already called this frame\n", g.FrameCount);
; 6434 :         IM_ASSERT(0);

  000a6	33 c0		 xor	 eax, eax
  000a8	75 26		 jne	 SHORT $LN8@BeginTabBa
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z@4JA
  000b0	83 c1 10	 add	 ecx, 16			; 00000010H
  000b3	8b f4		 mov	 esi, esp
  000b5	51		 push	 ecx
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@BeginTabBa:

; 6435 :         return true;

  000d0	b0 01		 mov	 al, 1
  000d2	e9 16 02 00 00	 jmp	 $LN1@BeginTabBa
$LN4@BeginTabBa:

; 6436 :     }
; 6437 : 
; 6438 :     // When toggling back from ordered to manually-reorderable, shuffle tabs to enforce the last visible order.
; 6439 :     // Otherwise, the most recently inserted tabs would move at the end of visible list which can be a little too confusing or magic for the user.
; 6440 :     if ((flags & ImGuiTabBarFlags_Reorderable) && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable) && tab_bar->Tabs.Size > 1 && tab_bar->PrevFrameVisible != -1)

  000d7	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000da	83 e0 01	 and	 eax, 1
  000dd	74 42		 je	 SHORT $LN5@BeginTabBa
  000df	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000e2	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000e5	83 e1 01	 and	 ecx, 1
  000e8	75 37		 jne	 SHORT $LN5@BeginTabBa
  000ea	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000ed	83 38 01	 cmp	 DWORD PTR [eax], 1
  000f0	7e 2f		 jle	 SHORT $LN5@BeginTabBa
  000f2	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000f5	83 78 20 ff	 cmp	 DWORD PTR [eax+32], -1
  000f9	74 26		 je	 SHORT $LN5@BeginTabBa

; 6441 :         ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByVisibleOffset);

  000fb	8b f4		 mov	 esi, esp
  000fd	68 00 00 00 00	 push	 OFFSET ?TabItemComparerByVisibleOffset@@YAHPBX0@Z ; TabItemComparerByVisibleOffset
  00102	6a 20		 push	 32			; 00000020H
  00104	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00107	8b 08		 mov	 ecx, DWORD PTR [eax]
  00109	51		 push	 ecx
  0010a	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  0010d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00110	50		 push	 eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__qsort
  00117	83 c4 10	 add	 esp, 16			; 00000010H
  0011a	3b f4		 cmp	 esi, esp
  0011c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@BeginTabBa:

; 6442 : 
; 6443 :     // Flags
; 6444 :     if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)

  00121	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00124	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00129	75 09		 jne	 SHORT $LN6@BeginTabBa

; 6445 :         flags |= ImGuiTabBarFlags_FittingPolicyDefault_;

  0012b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0012e	83 c8 40	 or	 eax, 64			; 00000040H
  00131	89 45 10	 mov	 DWORD PTR _flags$[ebp], eax
$LN6@BeginTabBa:

; 6446 : 
; 6447 :     tab_bar->Flags = flags;

  00134	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00137	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  0013a	89 48 54	 mov	 DWORD PTR [eax+84], ecx

; 6448 :     tab_bar->BarRect = tab_bar_bb;

  0013d	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00140	83 c0 24	 add	 eax, 36			; 00000024H
  00143	8b 4d 0c	 mov	 ecx, DWORD PTR _tab_bar_bb$[ebp]
  00146	8b 11		 mov	 edx, DWORD PTR [ecx]
  00148	89 10		 mov	 DWORD PTR [eax], edx
  0014a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0014d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00150	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00153	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00156	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00159	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 6449 :     tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()

  0015c	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0015f	c6 40 5d 01	 mov	 BYTE PTR [eax+93], 1

; 6450 :     tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;

  00163	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00166	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00169	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0016c	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 6451 :     tab_bar->CurrFrameVisible = g.FrameCount;

  0016f	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00172	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00175	8b 91 60 19 00
	00		 mov	 edx, DWORD PTR [ecx+6496]
  0017b	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 6452 :     tab_bar->FramePadding = g.Style.FramePadding;

  0017e	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00181	8b 88 48 15 00
	00		 mov	 ecx, DWORD PTR [eax+5448]
  00187	8b 90 4c 15 00
	00		 mov	 edx, DWORD PTR [eax+5452]
  0018d	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00190	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00193	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 6453 : 
; 6454 :     // Layout
; 6455 :     ItemSize(ImVec2(tab_bar->OffsetMaxIdeal, tab_bar->BarRect.GetHeight()), tab_bar->FramePadding.y);

  00196	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00199	51		 push	 ecx
  0019a	f3 0f 10 40 68	 movss	 xmm0, DWORD PTR [eax+104]
  0019f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001a7	83 c1 24	 add	 ecx, 36			; 00000024H
  001aa	e8 00 00 00 00	 call	 ?GetHeight@ImRect@@QBEMXZ ; ImRect::GetHeight
  001af	51		 push	 ecx
  001b0	d9 1c 24	 fstp	 DWORD PTR [esp]
  001b3	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001b6	51		 push	 ecx
  001b7	f3 0f 10 41 3c	 movss	 xmm0, DWORD PTR [ecx+60]
  001bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c1	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001c7	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  001d2	83 c4 08	 add	 esp, 8

; 6456 :     window->DC.CursorPos.x = tab_bar->BarRect.Min.x;

  001d5	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  001d8	8b 4d 08	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  001db	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001de	89 90 c8 00 00
	00		 mov	 DWORD PTR [eax+200], edx

; 6457 : 
; 6458 :     // Draw separator
; 6459 :     const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive);

  001e4	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001e7	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  001ec	74 0c		 je	 SHORT $LN9@BeginTabBa
  001ee	c7 85 b4 fe ff
	ff 23 00 00 00	 mov	 DWORD PTR tv175[ebp], 35 ; 00000023H
  001f8	eb 0a		 jmp	 SHORT $LN10@BeginTabBa
$LN9@BeginTabBa:
  001fa	c7 85 b4 fe ff
	ff 25 00 00 00	 mov	 DWORD PTR tv175[ebp], 37 ; 00000025H
$LN10@BeginTabBa:
  00204	51		 push	 ecx
  00205	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00212	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv175[ebp]
  00218	51		 push	 ecx
  00219	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0021e	83 c4 08	 add	 esp, 8
  00221	89 45 e0	 mov	 DWORD PTR _col$[ebp], eax

; 6460 :     const float y = tab_bar->BarRect.Max.y - 1.0f;

  00224	8b 45 08	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00227	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  0022c	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00234	f3 0f 11 45 d4	 movss	 DWORD PTR _y$[ebp], xmm0

; 6461 :     {
; 6462 :         const float separator_min_x = tab_bar->BarRect.Min.x - IM_FLOOR(window->WindowPadding.x * 0.5f);

  00239	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0023c	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [eax+52]
  00241	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00249	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0024d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00251	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  00254	f3 0f 10 4a 24	 movss	 xmm1, DWORD PTR [edx+36]
  00259	f3 0f 5c c8	 subss	 xmm1, xmm0
  0025d	f3 0f 11 4d c8	 movss	 DWORD PTR _separator_min_x$6[ebp], xmm1

; 6463 :         const float separator_max_x = tab_bar->BarRect.Max.x + IM_FLOOR(window->WindowPadding.x * 0.5f);

  00262	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00265	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [eax+52]
  0026a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00272	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00276	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0027a	8b 55 08	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  0027d	f3 0f 58 42 2c	 addss	 xmm0, DWORD PTR [edx+44]
  00282	f3 0f 11 45 bc	 movss	 DWORD PTR _separator_max_x$5[ebp], xmm0

; 6464 :         window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);

  00287	51		 push	 ecx
  00288	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00290	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00295	8b 45 e0	 mov	 eax, DWORD PTR _col$[ebp]
  00298	50		 push	 eax
  00299	51		 push	 ecx
  0029a	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _y$[ebp]
  0029f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a4	51		 push	 ecx
  002a5	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _separator_max_x$5[ebp]
  002aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002af	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  002b5	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002ba	50		 push	 eax
  002bb	51		 push	 ecx
  002bc	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _y$[ebp]
  002c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c6	51		 push	 ecx
  002c7	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _separator_min_x$6[ebp]
  002cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d1	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002d7	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002dc	50		 push	 eax
  002dd	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  002e0	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  002e6	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 6465 :     }
; 6466 :     return true;

  002eb	b0 01		 mov	 al, 1
$LN1@BeginTabBa:

; 6467 : }

  002ed	5f		 pop	 edi
  002ee	5e		 pop	 esi
  002ef	5b		 pop	 ebx
  002f0	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  002f6	3b ec		 cmp	 ebp, esp
  002f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fd	8b e5		 mov	 esp, ebp
  002ff	5d		 pop	 ebp
  00300	c3		 ret	 0
?BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z ENDP ; ImGui::BeginTabBarEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnNormFromOffset@ImGui@@YAMPBUImGuiColumns@@M@Z
_TEXT	SEGMENT
tv74 = -196						; size = 4
_columns$ = 8						; size = 4
_offset$ = 12						; size = 4
?GetColumnNormFromOffset@ImGui@@YAMPBUImGuiColumns@@M@Z PROC ; ImGui::GetColumnNormFromOffset, COMDAT

; 7250 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7251 :     return offset / (columns->OffMaxX - columns->OffMinX);

  00028	8b 45 08	 mov	 eax, DWORD PTR _columns$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _columns$[ebp]
  0002e	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00033	f3 0f 5c 41 14	 subss	 xmm0, DWORD PTR [ecx+20]
  00038	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _offset$[ebp]
  0003d	f3 0f 5e c8	 divss	 xmm1, xmm0
  00041	f3 0f 11 8d 3c
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm1
  00049	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv74[ebp]

; 7252 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?GetColumnNormFromOffset@ImGui@@YAMPBUImGuiColumns@@M@Z ENDP ; ImGui::GetColumnNormFromOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnOffsetFromNorm@ImGui@@YAMPBUImGuiColumns@@M@Z
_TEXT	SEGMENT
tv74 = -196						; size = 4
_columns$ = 8						; size = 4
_offset_norm$ = 12					; size = 4
?GetColumnOffsetFromNorm@ImGui@@YAMPBUImGuiColumns@@M@Z PROC ; ImGui::GetColumnOffsetFromNorm, COMDAT

; 7245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7246 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

  00028	8b 45 08	 mov	 eax, DWORD PTR _columns$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _columns$[ebp]
  0002e	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00033	f3 0f 5c 41 14	 subss	 xmm0, DWORD PTR [ecx+20]
  00038	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _offset_norm$[ebp]
  0003d	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
  00045	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv74[ebp]

; 7247 : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GetColumnOffsetFromNorm@ImGui@@YAMPBUImGuiColumns@@M@Z ENDP ; ImGui::GetColumnOffsetFromNorm
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z
_TEXT	SEGMENT
tv91 = -332						; size = 4
tv92 = -328						; size = 4
$T2 = -320						; size = 88
_columns$ = -32						; size = 4
_n$3 = -20						; size = 4
__$EHRec$ = -12						; size = 12
_window$ = 8						; size = 4
_id$ = 12						; size = 4
?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z PROC ; ImGui::FindOrCreateColumns, COMDAT

; 7384 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00020	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7385 :     // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
; 7386 :     for (int n = 0; n < window->ColumnsStorage.Size; n++)

  00047	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _n$3[ebp], 0
  0004e	eb 09		 jmp	 SHORT $LN4@FindOrCrea
$LN2@FindOrCrea:
  00050	8b 45 ec	 mov	 eax, DWORD PTR _n$3[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 ec	 mov	 DWORD PTR _n$3[ebp], eax
$LN4@FindOrCrea:
  00059	8b 45 08	 mov	 eax, DWORD PTR _window$[ebp]
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR _n$3[ebp]
  0005f	3b 88 60 02 00
	00		 cmp	 ecx, DWORD PTR [eax+608]
  00065	7d 2f		 jge	 SHORT $LN3@FindOrCrea

; 7387 :         if (window->ColumnsStorage[n].ID == id)

  00067	8b 45 ec	 mov	 eax, DWORD PTR _n$3[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _window$[ebp]
  0006e	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  00074	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@H@Z ; ImVector<ImGuiColumns>::operator[]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	3b 4d 0c	 cmp	 ecx, DWORD PTR _id$[ebp]
  0007e	75 14		 jne	 SHORT $LN5@FindOrCrea

; 7388 :             return &window->ColumnsStorage[n];

  00080	8b 45 ec	 mov	 eax, DWORD PTR _n$3[ebp]
  00083	50		 push	 eax
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _window$[ebp]
  00087	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  0008d	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@H@Z ; ImVector<ImGuiColumns>::operator[]
  00092	eb 69		 jmp	 SHORT $LN1@FindOrCrea
$LN5@FindOrCrea:
  00094	eb ba		 jmp	 SHORT $LN2@FindOrCrea
$LN3@FindOrCrea:

; 7389 : 
; 7390 :     window->ColumnsStorage.push_back(ImGuiColumns());

  00096	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0009c	e8 00 00 00 00	 call	 ??0ImGuiColumns@@QAE@XZ	; ImGuiColumns::ImGuiColumns
  000a1	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv92[ebp], eax
  000a7	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv92[ebp]
  000ad	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv91[ebp], eax
  000b3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000ba	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv91[ebp]
  000c0	51		 push	 ecx
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _window$[ebp]
  000c4	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  000ca	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImGuiColumns@@@@QAEXABUImGuiColumns@@@Z ; ImVector<ImGuiColumns>::push_back
  000cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d6	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000dc	e8 00 00 00 00	 call	 ??1ImGuiColumns@@QAE@XZ

; 7391 :     ImGuiColumns* columns = &window->ColumnsStorage.back();

  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _window$[ebp]
  000e4	81 c1 60 02 00
	00		 add	 ecx, 608		; 00000260H
  000ea	e8 00 00 00 00	 call	 ?back@?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@XZ ; ImVector<ImGuiColumns>::back
  000ef	89 45 e0	 mov	 DWORD PTR _columns$[ebp], eax

; 7392 :     columns->ID = id;

  000f2	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  000f5	8b 4d 0c	 mov	 ecx, DWORD PTR _id$[ebp]
  000f8	89 08		 mov	 DWORD PTR [eax], ecx

; 7393 :     return columns;

  000fa	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
$LN1@FindOrCrea:

; 7394 : }

  000fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00107	59		 pop	 ecx
  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  00111	3b ec		 cmp	 ebp, esp
  00113	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z$0:
  00000	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1ImGuiColumns@@QAE@XZ
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a b0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-336]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z ENDP ; ImGui::FindOrCreateColumns
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnsID@ImGui@@YAIPBDH@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
tv66 = -220						; size = 4
_id$ = -20						; size = 4
_window$ = -8						; size = 4
_str_id$ = 8						; size = 4
_columns_count$ = 12					; size = 4
?GetColumnsID@ImGui@@YAIPBDH@Z PROC			; ImGui::GetColumnsID, COMDAT

; 7397 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7398 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7399 : 
; 7400 :     // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
; 7401 :     // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
; 7402 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

  00030	83 7d 08 00	 cmp	 DWORD PTR _str_id$[ebp], 0
  00034	74 0c		 je	 SHORT $LN3@GetColumns
  00036	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  00040	eb 09		 jmp	 SHORT $LN4@GetColumns
$LN3@GetColumns:
  00042	8b 45 0c	 mov	 eax, DWORD PTR _columns_count$[ebp]
  00045	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
$LN4@GetColumns:
  0004b	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00051	81 c1 47 33 22
	11		 add	 ecx, 287454023		; 11223347H
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID
  0005d	83 c4 04	 add	 esp, 4

; 7403 :     ImGuiID id = window->GetID(str_id ? str_id : "columns");

  00060	83 7d 08 00	 cmp	 DWORD PTR _str_id$[ebp], 0
  00064	74 0b		 je	 SHORT $LN5@GetColumns
  00066	8b 45 08	 mov	 eax, DWORD PTR _str_id$[ebp]
  00069	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  0006f	eb 0a		 jmp	 SHORT $LN6@GetColumns
$LN5@GetColumns:
  00071	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], OFFSET ??_C@_07HIFEPIJN@columns@
$LN6@GetColumns:
  0007b	6a 00		 push	 0
  0007d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  00083	51		 push	 ecx
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  00087	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0008c	89 45 ec	 mov	 DWORD PTR _id$[ebp], eax

; 7404 :     PopID();

  0008f	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 7405 : 
; 7406 :     return id;

  00094	8b 45 ec	 mov	 eax, DWORD PTR _id$[ebp]

; 7407 : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
?GetColumnsID@ImGui@@YAIPBDH@Z ENDP			; ImGui::GetColumnsID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PopColumnsBackground@ImGui@@YAXXZ
_TEXT	SEGMENT
_columns$ = -20						; size = 4
_window$ = -8						; size = 4
?PopColumnsBackground@ImGui@@YAXXZ PROC			; ImGui::PopColumnsBackground, COMDAT

; 7374 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7375 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7376 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  00039	89 4d ec	 mov	 DWORD PTR _columns$[ebp], ecx

; 7377 :     if (columns->Count == 1)

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  0003f	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00043	75 02		 jne	 SHORT $LN2@PopColumns

; 7378 :         return;

  00045	eb 1d		 jmp	 SHORT $LN1@PopColumns
$LN2@PopColumns:

; 7379 :     window->DrawList->ChannelsSetCurrent(columns->Current + 1);

  00047	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  0004a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004d	83 c1 01	 add	 ecx, 1
  00050	51		 push	 ecx
  00051	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  00054	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  0005a	e8 00 00 00 00	 call	 ?ChannelsSetCurrent@ImDrawList@@QAEXH@Z ; ImDrawList::ChannelsSetCurrent

; 7380 :     PopClipRect();

  0005f	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect
$LN1@PopColumns:

; 7381 : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?PopColumnsBackground@ImGui@@YAXXZ ENDP			; ImGui::PopColumnsBackground
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PushColumnsBackground@ImGui@@YAXXZ
_TEXT	SEGMENT
_cmd_size$ = -32					; size = 4
_columns$ = -20						; size = 4
_window$ = -8						; size = 4
?PushColumnsBackground@ImGui@@YAXXZ PROC		; ImGui::PushColumnsBackground, COMDAT

; 7361 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7362 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7363 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  00039	89 4d ec	 mov	 DWORD PTR _columns$[ebp], ecx

; 7364 :     if (columns->Count == 1)

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  0003f	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00043	75 02		 jne	 SHORT $LN2@PushColumn

; 7365 :         return;

  00045	eb 6b		 jmp	 SHORT $LN1@PushColumn
$LN2@PushColumn:

; 7366 :     window->DrawList->ChannelsSetCurrent(0);

  00047	6a 00		 push	 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0004c	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00052	e8 00 00 00 00	 call	 ?ChannelsSetCurrent@ImDrawList@@QAEXH@Z ; ImDrawList::ChannelsSetCurrent

; 7367 :     int cmd_size = window->DrawList->CmdBuffer.Size;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0005a	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	89 55 e0	 mov	 DWORD PTR _cmd_size$[ebp], edx

; 7368 :     PushClipRect(columns->HostClipRect.Min, columns->HostClipRect.Max, false);

  00065	6a 00		 push	 0
  00067	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  0006a	83 c0 34	 add	 eax, 52			; 00000034H
  0006d	50		 push	 eax
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR _columns$[ebp]
  00071	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 ?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7369 :     IM_UNUSED(cmd_size);
; 7370 :     IM_ASSERT(cmd_size == window->DrawList->CmdBuffer.Size); // Being in channel 0 this should not have created an ImDrawCmd

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00080	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00086	8b 55 e0	 mov	 edx, DWORD PTR _cmd_size$[ebp]
  00089	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0008b	74 25		 je	 SHORT $LN1@PushColumn
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??PushColumnsBackground@ImGui@@YAXXZ@4JA
  00092	83 c0 09	 add	 eax, 9
  00095	8b f4		 mov	 esi, esp
  00097	50		 push	 eax
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_1FK@BKCOEDF@?$AAc?$AAm?$AAd?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAw?$AAi?$AAn@
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@PushColumn:

; 7371 : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000bb	3b ec		 cmp	 ebp, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
?PushColumnsBackground@ImGui@@YAXXZ ENDP		; ImGui::PushColumnsBackground
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PushColumnClipRect@ImGui@@YAXH@Z
_TEXT	SEGMENT
_column$ = -32						; size = 4
_columns$ = -20						; size = 4
_window$ = -8						; size = 4
_column_index$ = 8					; size = 4
?PushColumnClipRect@ImGui@@YAXH@Z PROC			; ImGui::PushColumnClipRect, COMDAT

; 7349 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7350 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7351 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  00039	89 4d ec	 mov	 DWORD PTR _columns$[ebp], ecx

; 7352 :     if (column_index < 0)

  0003c	83 7d 08 00	 cmp	 DWORD PTR _column_index$[ebp], 0
  00040	7d 09		 jge	 SHORT $LN2@PushColumn

; 7353 :         column_index = columns->Current;

  00042	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  00045	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00048	89 4d 08	 mov	 DWORD PTR _column_index$[ebp], ecx
$LN2@PushColumn:

; 7354 : 
; 7355 :     ImGuiColumnData* column = &columns->Columns[column_index];

  0004b	8b 45 08	 mov	 eax, DWORD PTR _column_index$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d ec	 mov	 ecx, DWORD PTR _columns$[ebp]
  00052	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00055	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  0005a	89 45 e0	 mov	 DWORD PTR _column$[ebp], eax

; 7356 :     PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);

  0005d	6a 00		 push	 0
  0005f	8b 45 e0	 mov	 eax, DWORD PTR _column$[ebp]
  00062	83 c0 14	 add	 eax, 20			; 00000014H
  00065	50		 push	 eax
  00066	8b 4d e0	 mov	 ecx, DWORD PTR _column$[ebp]
  00069	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7357 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?PushColumnClipRect@ImGui@@YAXH@Z ENDP			; ImGui::PushColumnClipRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?EndColumns@ImGui@@YAXXZ
_TEXT	SEGMENT
tv204 = -520						; size = 4
tv334 = -516						; size = 4
tv207 = -516						; size = 4
$T1 = -508						; size = 8
$T2 = -492						; size = 8
$T3 = -476						; size = 8
$T4 = -460						; size = 8
_x$5 = -252						; size = 4
_n$6 = -240						; size = 4
_xi$7 = -228						; size = 4
_col$8 = -216						; size = 4
_held$9 = -201						; size = 1
_hovered$10 = -189					; size = 1
_column_hit_rect$11 = -180				; size = 16
_column_hit_hw$12 = -156				; size = 4
_column_id$13 = -144					; size = 4
_x$14 = -132						; size = 4
_column$15 = -120					; size = 4
_n$16 = -108						; size = 4
_dragging_column$17 = -96				; size = 4
_y2$18 = -84						; size = 4
_y1$19 = -72						; size = 4
_is_being_resized$ = -57				; size = 1
_flags$ = -48						; size = 4
_columns$ = -36						; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?EndColumns@ImGui@@YAXXZ PROC				; ImGui::EndColumns, COMDAT

; 7537 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-520]
  00012	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7538 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 7539 :     ImGuiWindow* window = GetCurrentWindow();

  0003a	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0003f	89 45 e8	 mov	 DWORD PTR _window$[ebp], eax

; 7540 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00042	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00045	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  0004b	89 4d dc	 mov	 DWORD PTR _columns$[ebp], ecx

; 7541 :     IM_ASSERT(columns != NULL);

  0004e	83 7d dc 00	 cmp	 DWORD PTR _columns$[ebp], 0
  00052	75 25		 jne	 SHORT $LN19@EndColumns
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??EndColumns@ImGui@@YAXXZ@4JA
  00059	83 c0 04	 add	 eax, 4
  0005c	8b f4		 mov	 esi, esp
  0005e	50		 push	 eax
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN19@EndColumns:

; 7542 : 
; 7543 :     PopItemWidth();

  00079	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 7544 :     if (columns->Count > 1)

  0007e	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  00081	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00085	7e 13		 jle	 SHORT $LN8@EndColumns

; 7545 :     {
; 7546 :         PopClipRect();

  00087	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect

; 7547 :         window->DrawList->ChannelsMerge();

  0008c	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0008f	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00095	e8 00 00 00 00	 call	 ?ChannelsMerge@ImDrawList@@QAEXXZ ; ImDrawList::ChannelsMerge
$LN8@EndColumns:

; 7548 :     }
; 7549 : 
; 7550 :     const ImGuiColumnsFlags flags = columns->Flags;

  0009a	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  0009d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a0	89 4d d0	 mov	 DWORD PTR _flags$[ebp], ecx

; 7551 :     columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);

  000a3	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  000a6	51		 push	 ecx
  000a7	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  000af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b4	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  000b7	51		 push	 ecx
  000b8	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [ecx+32]
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000c7	83 c4 08	 add	 esp, 8
  000ca	8b 55 dc	 mov	 edx, DWORD PTR _columns$[ebp]
  000cd	d9 5a 20	 fstp	 DWORD PTR [edx+32]

; 7552 :     window->DC.CursorPos.y = columns->LineMaxY;

  000d0	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  000d3	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  000d6	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000d9	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 7553 :     if (!(flags & ImGuiColumnsFlags_GrowParentContentsSize))

  000df	8b 45 d0	 mov	 eax, DWORD PTR _flags$[ebp]
  000e2	83 e0 10	 and	 eax, 16			; 00000010H
  000e5	75 0f		 jne	 SHORT $LN9@EndColumns

; 7554 :         window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

  000e7	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  000ea	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  000ed	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000f0	89 90 e0 00 00
	00		 mov	 DWORD PTR [eax+224], edx
$LN9@EndColumns:

; 7555 : 
; 7556 :     // Draw columns borders and handle resize
; 7557 :     // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
; 7558 :     bool is_being_resized = false;

  000f6	c6 45 c7 00	 mov	 BYTE PTR _is_being_resized$[ebp], 0

; 7559 :     if (!(flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)

  000fa	8b 45 d0	 mov	 eax, DWORD PTR _flags$[ebp]
  000fd	83 e0 01	 and	 eax, 1
  00100	0f 85 9b 03 00
	00		 jne	 $LN16@EndColumns
  00106	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00109	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  0010d	85 c9		 test	 ecx, ecx
  0010f	0f 85 8c 03 00
	00		 jne	 $LN16@EndColumns

; 7560 :     {
; 7561 :         // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
; 7562 :         const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);

  00115	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00118	51		 push	 ecx
  00119	f3 0f 10 80 08
	02 00 00	 movss	 xmm0, DWORD PTR [eax+520]
  00121	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00126	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  00129	51		 push	 ecx
  0012a	f3 0f 10 41 24	 movss	 xmm0, DWORD PTR [ecx+36]
  0012f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00134	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00139	83 c4 08	 add	 esp, 8
  0013c	d9 5d b8	 fstp	 DWORD PTR _y1$19[ebp]

; 7563 :         const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);

  0013f	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00142	51		 push	 ecx
  00143	f3 0f 10 80 10
	02 00 00	 movss	 xmm0, DWORD PTR [eax+528]
  0014b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00150	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00153	51		 push	 ecx
  00154	f3 0f 10 81 cc
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+204]
  0015c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00161	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00166	83 c4 08	 add	 esp, 8
  00169	d9 5d ac	 fstp	 DWORD PTR _y2$18[ebp]

; 7564 :         int dragging_column = -1;

  0016c	c7 45 a0 ff ff
	ff ff		 mov	 DWORD PTR _dragging_column$17[ebp], -1

; 7565 :         for (int n = 1; n < columns->Count; n++)

  00173	c7 45 94 01 00
	00 00		 mov	 DWORD PTR _n$16[ebp], 1
  0017a	eb 09		 jmp	 SHORT $LN4@EndColumns
$LN2@EndColumns:
  0017c	8b 45 94	 mov	 eax, DWORD PTR _n$16[ebp]
  0017f	83 c0 01	 add	 eax, 1
  00182	89 45 94	 mov	 DWORD PTR _n$16[ebp], eax
$LN4@EndColumns:
  00185	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  00188	8b 4d 94	 mov	 ecx, DWORD PTR _n$16[ebp]
  0018b	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0018e	0f 8d 62 02 00
	00		 jge	 $LN3@EndColumns

; 7566 :         {
; 7567 :             ImGuiColumnData* column = &columns->Columns[n];

  00194	8b 45 94	 mov	 eax, DWORD PTR _n$16[ebp]
  00197	50		 push	 eax
  00198	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  0019b	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0019e	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  001a3	89 45 88	 mov	 DWORD PTR _column$15[ebp], eax

; 7568 :             float x = window->Pos.x + GetColumnOffset(n);

  001a6	8b 45 94	 mov	 eax, DWORD PTR _n$16[ebp]
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  001af	83 c4 04	 add	 esp, 4
  001b2	d9 9d fc fd ff
	ff		 fstp	 DWORD PTR tv334[ebp]
  001b8	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  001bb	f3 0f 10 85 fc
	fd ff ff	 movss	 xmm0, DWORD PTR tv334[ebp]
  001c3	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  001c8	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _x$14[ebp], xmm0

; 7569 :             const ImGuiID column_id = columns->ID + ImGuiID(n);

  001d0	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  001d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d5	03 4d 94	 add	 ecx, DWORD PTR _n$16[ebp]
  001d8	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _column_id$13[ebp], ecx

; 7570 :             const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;

  001de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  001e6	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _column_hit_hw$12[ebp], xmm0

; 7571 :             const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));

  001ee	51		 push	 ecx
  001ef	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _y2$18[ebp]
  001f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f9	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _x$14[ebp]
  00201	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  00209	51		 push	 ecx
  0020a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020f	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00215	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0021a	50		 push	 eax
  0021b	51		 push	 ecx
  0021c	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _y1$19[ebp]
  00221	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00226	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _x$14[ebp]
  0022e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40800000
  00236	51		 push	 ecx
  00237	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023c	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00242	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00247	50		 push	 eax
  00248	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _column_hit_rect$11[ebp]
  0024e	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 7572 :             KeepAliveID(column_id);

  00253	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _column_id$13[ebp]
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 ?KeepAliveID@ImGui@@YAXI@Z ; ImGui::KeepAliveID
  0025f	83 c4 04	 add	 esp, 4

; 7573 :             if (IsClippedEx(column_hit_rect, column_id, false))

  00262	6a 00		 push	 0
  00264	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _column_id$13[ebp]
  0026a	50		 push	 eax
  0026b	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _column_hit_rect$11[ebp]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 ?IsClippedEx@ImGui@@YA_NABUImRect@@I_N@Z ; ImGui::IsClippedEx
  00277	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027a	0f b6 d0	 movzx	 edx, al
  0027d	85 d2		 test	 edx, edx
  0027f	74 05		 je	 SHORT $LN11@EndColumns

; 7574 :                 continue;

  00281	e9 f6 fe ff ff	 jmp	 $LN2@EndColumns
$LN11@EndColumns:

; 7575 : 
; 7576 :             bool hovered = false, held = false;

  00286	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _hovered$10[ebp], 0
  0028d	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _held$9[ebp], 0

; 7577 :             if (!(flags & ImGuiColumnsFlags_NoResize))

  00294	8b 45 d0	 mov	 eax, DWORD PTR _flags$[ebp]
  00297	83 e0 02	 and	 eax, 2
  0029a	75 65		 jne	 SHORT $LN15@EndColumns

; 7578 :             {
; 7579 :                 ButtonBehavior(column_hit_rect, column_id, &hovered, &held);

  0029c	6a 00		 push	 0
  0029e	8d 85 37 ff ff
	ff		 lea	 eax, DWORD PTR _held$9[ebp]
  002a4	50		 push	 eax
  002a5	8d 8d 43 ff ff
	ff		 lea	 ecx, DWORD PTR _hovered$10[ebp]
  002ab	51		 push	 ecx
  002ac	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _column_id$13[ebp]
  002b2	52		 push	 edx
  002b3	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _column_hit_rect$11[ebp]
  002b9	50		 push	 eax
  002ba	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  002bf	83 c4 14	 add	 esp, 20			; 00000014H

; 7580 :                 if (hovered || held)

  002c2	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$10[ebp]
  002c9	85 c0		 test	 eax, eax
  002cb	75 0b		 jne	 SHORT $LN14@EndColumns
  002cd	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _held$9[ebp]
  002d4	85 c0		 test	 eax, eax
  002d6	74 0d		 je	 SHORT $LN13@EndColumns
$LN14@EndColumns:

; 7581 :                     g.MouseCursor = ImGuiMouseCursor_ResizeEW;

  002d8	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  002db	c7 80 30 1d 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+7472], 4
$LN13@EndColumns:

; 7582 :                 if (held && !(column->Flags & ImGuiColumnsFlags_NoResize))

  002e5	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _held$9[ebp]
  002ec	85 c0		 test	 eax, eax
  002ee	74 11		 je	 SHORT $LN15@EndColumns
  002f0	8b 45 88	 mov	 eax, DWORD PTR _column$15[ebp]
  002f3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002f6	83 e1 02	 and	 ecx, 2
  002f9	75 06		 jne	 SHORT $LN15@EndColumns

; 7583 :                     dragging_column = n;

  002fb	8b 45 94	 mov	 eax, DWORD PTR _n$16[ebp]
  002fe	89 45 a0	 mov	 DWORD PTR _dragging_column$17[ebp], eax
$LN15@EndColumns:

; 7584 :             }
; 7585 : 
; 7586 :             // Draw column
; 7587 :             const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);

  00301	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _held$9[ebp]
  00308	85 c0		 test	 eax, eax
  0030a	74 0c		 je	 SHORT $LN22@EndColumns
  0030c	c7 85 fc fd ff
	ff 1d 00 00 00	 mov	 DWORD PTR tv207[ebp], 29 ; 0000001dH
  00316	eb 2d		 jmp	 SHORT $LN23@EndColumns
$LN22@EndColumns:
  00318	0f b6 8d 43 ff
	ff ff		 movzx	 ecx, BYTE PTR _hovered$10[ebp]
  0031f	85 c9		 test	 ecx, ecx
  00321	74 0c		 je	 SHORT $LN20@EndColumns
  00323	c7 85 f8 fd ff
	ff 1c 00 00 00	 mov	 DWORD PTR tv204[ebp], 28 ; 0000001cH
  0032d	eb 0a		 jmp	 SHORT $LN21@EndColumns
$LN20@EndColumns:
  0032f	c7 85 f8 fd ff
	ff 1b 00 00 00	 mov	 DWORD PTR tv204[ebp], 27 ; 0000001bH
$LN21@EndColumns:
  00339	8b 95 f8 fd ff
	ff		 mov	 edx, DWORD PTR tv204[ebp]
  0033f	89 95 fc fd ff
	ff		 mov	 DWORD PTR tv207[ebp], edx
$LN23@EndColumns:
  00345	51		 push	 ecx
  00346	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0034e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00353	8b 85 fc fd ff
	ff		 mov	 eax, DWORD PTR tv207[ebp]
  00359	50		 push	 eax
  0035a	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0035f	83 c4 08	 add	 esp, 8
  00362	89 85 28 ff ff
	ff		 mov	 DWORD PTR _col$8[ebp], eax

; 7588 :             const float xi = IM_FLOOR(x);

  00368	f3 0f 2c 85 7c
	ff ff ff	 cvttss2si eax, DWORD PTR _x$14[ebp]
  00370	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00374	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _xi$7[ebp], xmm0

; 7589 :             window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);

  0037c	51		 push	 ecx
  0037d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00385	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038a	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _col$8[ebp]
  00390	50		 push	 eax
  00391	51		 push	 ecx
  00392	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _y2$18[ebp]
  00397	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039c	51		 push	 ecx
  0039d	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _xi$7[ebp]
  003a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003aa	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  003b0	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003b5	50		 push	 eax
  003b6	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _y1$19[ebp]
  003bb	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  003c3	51		 push	 ecx
  003c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c9	51		 push	 ecx
  003ca	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _xi$7[ebp]
  003d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d7	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  003dd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003e2	50		 push	 eax
  003e3	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  003e6	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  003ec	e8 00 00 00 00	 call	 ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 7590 :         }

  003f1	e9 86 fd ff ff	 jmp	 $LN2@EndColumns
$LN3@EndColumns:

; 7591 : 
; 7592 :         // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
; 7593 :         if (dragging_column != -1)

  003f6	83 7d a0 ff	 cmp	 DWORD PTR _dragging_column$17[ebp], -1
  003fa	0f 84 a1 00 00
	00		 je	 $LN16@EndColumns

; 7594 :         {
; 7595 :             if (!columns->IsBeingResized)

  00400	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  00403	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00407	85 c9		 test	 ecx, ecx
  00409	75 59		 jne	 SHORT $LN6@EndColumns

; 7596 :                 for (int n = 0; n < columns->Count + 1; n++)

  0040b	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$6[ebp], 0
  00415	eb 0f		 jmp	 SHORT $LN7@EndColumns
$LN5@EndColumns:
  00417	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _n$6[ebp]
  0041d	83 c0 01	 add	 eax, 1
  00420	89 85 10 ff ff
	ff		 mov	 DWORD PTR _n$6[ebp], eax
$LN7@EndColumns:
  00426	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  00429	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0042c	83 c1 01	 add	 ecx, 1
  0042f	39 8d 10 ff ff
	ff		 cmp	 DWORD PTR _n$6[ebp], ecx
  00435	7d 2d		 jge	 SHORT $LN6@EndColumns

; 7597 :                     columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;

  00437	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _n$6[ebp]
  0043d	50		 push	 eax
  0043e	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  00441	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00444	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00449	8b f0		 mov	 esi, eax
  0044b	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _n$6[ebp]
  00451	51		 push	 ecx
  00452	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  00455	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00458	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  0045d	8b 16		 mov	 edx, DWORD PTR [esi]
  0045f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00462	eb b3		 jmp	 SHORT $LN5@EndColumns
$LN6@EndColumns:

; 7598 :             columns->IsBeingResized = is_being_resized = true;

  00464	c6 45 c7 01	 mov	 BYTE PTR _is_being_resized$[ebp], 1
  00468	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  0046b	8a 4d c7	 mov	 cl, BYTE PTR _is_being_resized$[ebp]
  0046e	88 48 09	 mov	 BYTE PTR [eax+9], cl

; 7599 :             float x = GetDraggedColumnOffset(columns, dragging_column);

  00471	8b 45 a0	 mov	 eax, DWORD PTR _dragging_column$17[ebp]
  00474	50		 push	 eax
  00475	8b 4d dc	 mov	 ecx, DWORD PTR _columns$[ebp]
  00478	51		 push	 ecx
  00479	e8 00 00 00 00	 call	 ?GetDraggedColumnOffset@@YAMPAUImGuiColumns@@H@Z ; GetDraggedColumnOffset
  0047e	83 c4 08	 add	 esp, 8
  00481	d9 9d 04 ff ff
	ff		 fstp	 DWORD PTR _x$5[ebp]

; 7600 :             SetColumnOffset(dragging_column, x);

  00487	51		 push	 ecx
  00488	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _x$5[ebp]
  00490	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00495	8b 45 a0	 mov	 eax, DWORD PTR _dragging_column$17[ebp]
  00498	50		 push	 eax
  00499	e8 00 00 00 00	 call	 ?SetColumnOffset@ImGui@@YAXHM@Z ; ImGui::SetColumnOffset
  0049e	83 c4 08	 add	 esp, 8
$LN16@EndColumns:

; 7601 :         }
; 7602 :     }
; 7603 :     columns->IsBeingResized = is_being_resized;

  004a1	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  004a4	8a 4d c7	 mov	 cl, BYTE PTR _is_being_resized$[ebp]
  004a7	88 48 09	 mov	 BYTE PTR [eax+9], cl

; 7604 : 
; 7605 :     window->WorkRect = columns->HostWorkRect;

  004aa	8b 45 dc	 mov	 eax, DWORD PTR _columns$[ebp]
  004ad	83 c0 3c	 add	 eax, 60			; 0000003cH
  004b0	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  004b3	81 c1 f4 01 00
	00		 add	 ecx, 500		; 000001f4H
  004b9	8b 10		 mov	 edx, DWORD PTR [eax]
  004bb	89 11		 mov	 DWORD PTR [ecx], edx
  004bd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004c0	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  004c3	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  004c6	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  004c9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  004cc	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 7606 :     window->DC.CurrentColumns = NULL;

  004cf	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  004d2	c7 80 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+448], 0

; 7607 :     window->DC.ColumnsOffset.x = 0.0f;

  004dc	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  004df	0f 57 c0	 xorps	 xmm0, xmm0
  004e2	f3 0f 11 80 bc
	01 00 00	 movss	 DWORD PTR [eax+444], xmm0

; 7608 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  004ea	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  004ed	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  004f0	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  004f5	f3 0f 58 81 b4
	01 00 00	 addss	 xmm0, DWORD PTR [ecx+436]
  004fd	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  00500	f3 0f 58 82 bc
	01 00 00	 addss	 xmm0, DWORD PTR [edx+444]
  00508	f3 0f 2c c0	 cvttss2si eax, xmm0
  0050c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00510	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00513	f3 0f 11 81 c8
	00 00 00	 movss	 DWORD PTR [ecx+200], xmm0

; 7609 : }

  0051b	52		 push	 edx
  0051c	8b cd		 mov	 ecx, ebp
  0051e	50		 push	 eax
  0051f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@EndColumns
  00525	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0052a	58		 pop	 eax
  0052b	5a		 pop	 edx
  0052c	5f		 pop	 edi
  0052d	5e		 pop	 esi
  0052e	5b		 pop	 ebx
  0052f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00532	33 cd		 xor	 ecx, ebp
  00534	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00539	81 c4 08 02 00
	00		 add	 esp, 520		; 00000208H
  0053f	3b ec		 cmp	 ebp, esp
  00541	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00546	8b e5		 mov	 esp, ebp
  00548	5d		 pop	 ebp
  00549	c3		 ret	 0
  0054a	66 90		 npad	 2
$LN28@EndColumns:
  0054c	03 00 00 00	 DD	 3
  00550	00 00 00 00	 DD	 $LN27@EndColumns
$LN27@EndColumns:
  00554	4c ff ff ff	 DD	 -180			; ffffff4cH
  00558	10 00 00 00	 DD	 16			; 00000010H
  0055c	00 00 00 00	 DD	 $LN24@EndColumns
  00560	43 ff ff ff	 DD	 -189			; ffffff43H
  00564	01 00 00 00	 DD	 1
  00568	00 00 00 00	 DD	 $LN25@EndColumns
  0056c	37 ff ff ff	 DD	 -201			; ffffff37H
  00570	01 00 00 00	 DD	 1
  00574	00 00 00 00	 DD	 $LN26@EndColumns
$LN26@EndColumns:
  00578	68		 DB	 104			; 00000068H
  00579	65		 DB	 101			; 00000065H
  0057a	6c		 DB	 108			; 0000006cH
  0057b	64		 DB	 100			; 00000064H
  0057c	00		 DB	 0
$LN25@EndColumns:
  0057d	68		 DB	 104			; 00000068H
  0057e	6f		 DB	 111			; 0000006fH
  0057f	76		 DB	 118			; 00000076H
  00580	65		 DB	 101			; 00000065H
  00581	72		 DB	 114			; 00000072H
  00582	65		 DB	 101			; 00000065H
  00583	64		 DB	 100			; 00000064H
  00584	00		 DB	 0
$LN24@EndColumns:
  00585	63		 DB	 99			; 00000063H
  00586	6f		 DB	 111			; 0000006fH
  00587	6c		 DB	 108			; 0000006cH
  00588	75		 DB	 117			; 00000075H
  00589	6d		 DB	 109			; 0000006dH
  0058a	6e		 DB	 110			; 0000006eH
  0058b	5f		 DB	 95			; 0000005fH
  0058c	68		 DB	 104			; 00000068H
  0058d	69		 DB	 105			; 00000069H
  0058e	74		 DB	 116			; 00000074H
  0058f	5f		 DB	 95			; 0000005fH
  00590	72		 DB	 114			; 00000072H
  00591	65		 DB	 101			; 00000065H
  00592	63		 DB	 99			; 00000063H
  00593	74		 DB	 116			; 00000074H
  00594	00		 DB	 0
?EndColumns@ImGui@@YAXXZ ENDP				; ImGui::EndColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginColumns@ImGui@@YAXPBDHH@Z
_TEXT	SEGMENT
tv466 = -456						; size = 4
tv453 = -456						; size = 4
tv581 = -452						; size = 4
tv579 = -452						; size = 4
tv520 = -452						; size = 4
tv513 = -452						; size = 4
tv477 = -452						; size = 4
tv214 = -452						; size = 4
$T1 = -444						; size = 16
_width$ = -228						; size = 4
_offset_1$ = -216					; size = 4
_offset_0$ = -204					; size = 4
_clip_x2$2 = -192					; size = 4
_clip_x1$3 = -180					; size = 4
_column$4 = -168					; size = 4
_n$5 = -156						; size = 4
_column$6 = -144					; size = 28
_n$7 = -108						; size = 4
_max_2$ = -96						; size = 4
_max_1$ = -84						; size = 4
_half_clip_extend_x$ = -72				; size = 4
_column_padding$ = -60					; size = 4
_columns$ = -48						; size = 4
_id$ = -36						; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_str_id$ = 8						; size = 4
_columns_count$ = 12					; size = 4
_flags$ = 16						; size = 4
?BeginColumns@ImGui@@YAXPBDHH@Z PROC			; ImGui::BeginColumns, COMDAT

; 7410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 01 00
	00		 sub	 esp, 456		; 000001c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-456]
  00012	b9 72 00 00 00	 mov	 ecx, 114		; 00000072H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7411 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 7412 :     ImGuiWindow* window = GetCurrentWindow();

  0003a	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0003f	89 45 e8	 mov	 DWORD PTR _window$[ebp], eax

; 7413 : 
; 7414 :     IM_ASSERT(columns_count >= 1);

  00042	83 7d 0c 01	 cmp	 DWORD PTR _columns_count$[ebp], 1
  00046	7d 25		 jge	 SHORT $LN12@BeginColum
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPBDHH@Z@4JA
  0004d	83 c0 04	 add	 eax, 4
  00050	8b f4		 mov	 esi, esp
  00052	50		 push	 eax
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO@
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@BeginColum:

; 7415 :     IM_ASSERT(window->DC.CurrentColumns == NULL); // Nested columns are currently not supported

  0006d	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00070	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  00077	74 26		 je	 SHORT $LN13@BeginColum
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPBDHH@Z@4JA
  0007f	83 c1 05	 add	 ecx, 5
  00082	8b f4		 mov	 esi, esp
  00084	51		 push	 ecx
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_1DO@BPFJENMI@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAC?$AAu?$AAr?$AAr@
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@BeginColum:

; 7416 : 
; 7417 :     // Acquire storage for the columns set
; 7418 :     ImGuiID id = GetColumnsID(str_id, columns_count);

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _columns_count$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _str_id$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?GetColumnsID@ImGui@@YAIPBDH@Z ; ImGui::GetColumnsID
  000ac	83 c4 08	 add	 esp, 8
  000af	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 7419 :     ImGuiColumns* columns = FindOrCreateColumns(window, id);

  000b2	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 ?FindOrCreateColumns@ImGui@@YAPAUImGuiColumns@@PAUImGuiWindow@@I@Z ; ImGui::FindOrCreateColumns
  000bf	83 c4 08	 add	 esp, 8
  000c2	89 45 d0	 mov	 DWORD PTR _columns$[ebp], eax

; 7420 :     IM_ASSERT(columns->ID == id);

  000c5	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	3b 4d dc	 cmp	 ecx, DWORD PTR _id$[ebp]
  000cd	74 26		 je	 SHORT $LN14@BeginColum
  000cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??BeginColumns@ImGui@@YAXPBDHH@Z@4JA
  000d5	83 c2 0a	 add	 edx, 10			; 0000000aH
  000d8	8b f4		 mov	 esi, esp
  000da	52		 push	 edx
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IJEAECLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@BeginColum:

; 7421 :     columns->Current = 0;

  000f5	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  000f8	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 7422 :     columns->Count = columns_count;

  000ff	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00102	8b 4d 0c	 mov	 ecx, DWORD PTR _columns_count$[ebp]
  00105	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 7423 :     columns->Flags = flags;

  00108	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  0010b	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  0010e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 7424 :     window->DC.CurrentColumns = columns;

  00111	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00114	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00117	89 88 c0 01 00
	00		 mov	 DWORD PTR [eax+448], ecx

; 7425 : 
; 7426 :     columns->HostCursorPosY = window->DC.CursorPos.y;

  0011d	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00120	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00123	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  00129	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 7427 :     columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;

  0012c	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00132	8b 91 e0 00 00
	00		 mov	 edx, DWORD PTR [ecx+224]
  00138	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 7428 :     columns->HostClipRect = window->ClipRect;

  0013b	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0013e	05 04 02 00 00	 add	 eax, 516		; 00000204H
  00143	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00146	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00149	8b 10		 mov	 edx, DWORD PTR [eax]
  0014b	89 11		 mov	 DWORD PTR [ecx], edx
  0014d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00150	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00153	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00156	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00159	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0015c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 7429 :     columns->HostWorkRect = window->WorkRect;

  0015f	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00162	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  00167	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  0016a	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0016d	8b 10		 mov	 edx, DWORD PTR [eax]
  0016f	89 11		 mov	 DWORD PTR [ecx], edx
  00171	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00174	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0017d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00180	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 7430 : 
; 7431 :     // Set state for first column
; 7432 :     // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
; 7433 :     const float column_padding = g.Style.ItemSpacing.x;

  00183	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00186	f3 0f 10 80 58
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5464]
  0018e	f3 0f 11 45 c4	 movss	 DWORD PTR _column_padding$[ebp], xmm0

; 7434 :     const float half_clip_extend_x = ImFloor(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));

  00193	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00196	51		 push	 ecx
  00197	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  0019c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a1	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  001a4	f3 0f 10 41 34	 movss	 xmm0, DWORD PTR [ecx+52]
  001a9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001b1	51		 push	 ecx
  001b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b7	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001bc	83 c4 04	 add	 esp, 4
  001bf	d9 1c 24	 fstp	 DWORD PTR [esp]
  001c2	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  001c7	83 c4 04	 add	 esp, 4
  001ca	d9 5d b8	 fstp	 DWORD PTR _half_clip_extend_x$[ebp]

; 7435 :     const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);

  001cd	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  001d0	f3 0f 10 80 fc
	01 00 00	 movss	 xmm0, DWORD PTR [eax+508]
  001d8	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _column_padding$[ebp]
  001dd	51		 push	 ecx
  001de	0f 57 c9	 xorps	 xmm1, xmm1
  001e1	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001e6	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  001e9	f3 0f 10 4d c4	 movss	 xmm1, DWORD PTR _column_padding$[ebp]
  001ee	f3 0f 5c 49 34	 subss	 xmm1, DWORD PTR [ecx+52]
  001f3	51		 push	 ecx
  001f4	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001f9	f3 0f 11 85 3c
	fe ff ff	 movss	 DWORD PTR tv579[ebp], xmm0
  00201	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00206	83 c4 08	 add	 esp, 8
  00209	d9 9d 38 fe ff
	ff		 fstp	 DWORD PTR tv453[ebp]
  0020f	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR tv579[ebp]
  00217	f3 0f 5c 85 38
	fe ff ff	 subss	 xmm0, DWORD PTR tv453[ebp]
  0021f	f3 0f 11 45 ac	 movss	 DWORD PTR _max_1$[ebp], xmm0

; 7436 :     const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;

  00224	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00227	f3 0f 10 80 fc
	01 00 00	 movss	 xmm0, DWORD PTR [eax+508]
  0022f	f3 0f 58 45 b8	 addss	 xmm0, DWORD PTR _half_clip_extend_x$[ebp]
  00234	f3 0f 11 45 a0	 movss	 DWORD PTR _max_2$[ebp], xmm0

; 7437 :     columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);

  00239	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0023c	f3 0f 10 80 b4
	01 00 00	 movss	 xmm0, DWORD PTR [eax+436]
  00244	f3 0f 5c 45 c4	 subss	 xmm0, DWORD PTR _column_padding$[ebp]
  00249	51		 push	 ecx
  0024a	0f 57 c9	 xorps	 xmm1, xmm1
  0024d	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00252	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00255	f3 0f 10 4d c4	 movss	 xmm1, DWORD PTR _column_padding$[ebp]
  0025a	f3 0f 5c 49 34	 subss	 xmm1, DWORD PTR [ecx+52]
  0025f	51		 push	 ecx
  00260	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00265	f3 0f 11 85 3c
	fe ff ff	 movss	 DWORD PTR tv581[ebp], xmm0
  0026d	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00272	83 c4 08	 add	 esp, 8
  00275	d9 9d 38 fe ff
	ff		 fstp	 DWORD PTR tv466[ebp]
  0027b	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR tv581[ebp]
  00283	f3 0f 58 85 38
	fe ff ff	 addss	 xmm0, DWORD PTR tv466[ebp]
  0028b	8b 55 d0	 mov	 edx, DWORD PTR _columns$[ebp]
  0028e	f3 0f 11 42 14	 movss	 DWORD PTR [edx+20], xmm0

; 7438 :     columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);

  00293	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00296	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0029b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  002a3	51		 push	 ecx
  002a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a9	51		 push	 ecx
  002aa	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _max_2$[ebp]
  002af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b4	51		 push	 ecx
  002b5	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _max_1$[ebp]
  002ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bf	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  002c4	83 c4 08	 add	 esp, 8
  002c7	d9 9d 3c fe ff
	ff		 fstp	 DWORD PTR tv477[ebp]
  002cd	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR tv477[ebp]
  002d5	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  002d8	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]
  002dd	51		 push	 ecx
  002de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002e8	83 c4 08	 add	 esp, 8
  002eb	8b 55 d0	 mov	 edx, DWORD PTR _columns$[ebp]
  002ee	d9 5a 18	 fstp	 DWORD PTR [edx+24]

; 7439 :     columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

  002f1	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  002f4	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  002f7	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  002fd	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00300	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00303	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00306	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00309	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 7440 : 
; 7441 :     // Clear data if columns count changed
; 7442 :     if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)

  0030c	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  0030f	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00313	74 1b		 je	 SHORT $LN8@BeginColum
  00315	8b 45 0c	 mov	 eax, DWORD PTR _columns_count$[ebp]
  00318	83 c0 01	 add	 eax, 1
  0031b	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  0031e	39 41 4c	 cmp	 DWORD PTR [ecx+76], eax
  00321	74 0d		 je	 SHORT $LN8@BeginColum

; 7443 :         columns->Columns.resize(0);

  00323	6a 00		 push	 0
  00325	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00328	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0032b	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ; ImVector<ImGuiColumnData>::resize
$LN8@BeginColum:

; 7444 : 
; 7445 :     // Initialize default widths
; 7446 :     columns->IsFirstFrame = (columns->Columns.Size == 0);

  00330	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00333	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00337	75 0c		 jne	 SHORT $LN15@BeginColum
  00339	c7 85 3c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv214[ebp], 1
  00343	eb 0a		 jmp	 SHORT $LN16@BeginColum
$LN15@BeginColum:
  00345	c7 85 3c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
$LN16@BeginColum:
  0034f	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00352	8a 95 3c fe ff
	ff		 mov	 dl, BYTE PTR tv214[ebp]
  00358	88 51 08	 mov	 BYTE PTR [ecx+8], dl

; 7447 :     if (columns->Columns.Size == 0)

  0035b	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  0035e	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00362	75 64		 jne	 SHORT $LN3@BeginColum

; 7448 :     {
; 7449 :         columns->Columns.reserve(columns_count + 1);

  00364	8b 45 0c	 mov	 eax, DWORD PTR _columns_count$[ebp]
  00367	83 c0 01	 add	 eax, 1
  0036a	50		 push	 eax
  0036b	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  0036e	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00371	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ; ImVector<ImGuiColumnData>::reserve

; 7450 :         for (int n = 0; n < columns_count + 1; n++)

  00376	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _n$7[ebp], 0
  0037d	eb 09		 jmp	 SHORT $LN4@BeginColum
$LN2@BeginColum:
  0037f	8b 45 94	 mov	 eax, DWORD PTR _n$7[ebp]
  00382	83 c0 01	 add	 eax, 1
  00385	89 45 94	 mov	 DWORD PTR _n$7[ebp], eax
$LN4@BeginColum:
  00388	8b 45 0c	 mov	 eax, DWORD PTR _columns_count$[ebp]
  0038b	83 c0 01	 add	 eax, 1
  0038e	39 45 94	 cmp	 DWORD PTR _n$7[ebp], eax
  00391	7d 35		 jge	 SHORT $LN3@BeginColum

; 7451 :         {
; 7452 :             ImGuiColumnData column;

  00393	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _column$6[ebp]
  00399	e8 00 00 00 00	 call	 ??0ImGuiColumnData@@QAE@XZ ; ImGuiColumnData::ImGuiColumnData

; 7453 :             column.OffsetNorm = n / (float)columns_count;

  0039e	f3 0f 2a 45 94	 cvtsi2ss xmm0, DWORD PTR _n$7[ebp]
  003a3	f3 0f 2a 4d 0c	 cvtsi2ss xmm1, DWORD PTR _columns_count$[ebp]
  003a8	f3 0f 5e c1	 divss	 xmm0, xmm1
  003ac	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _column$6[ebp], xmm0

; 7454 :             columns->Columns.push_back(column);

  003b4	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _column$6[ebp]
  003ba	50		 push	 eax
  003bb	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  003be	83 c1 4c	 add	 ecx, 76			; 0000004cH
  003c1	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImGuiColumnData@@@@QAEXABUImGuiColumnData@@@Z ; ImVector<ImGuiColumnData>::push_back

; 7455 :         }

  003c6	eb b7		 jmp	 SHORT $LN2@BeginColum
$LN3@BeginColum:

; 7456 :     }
; 7457 : 
; 7458 :     for (int n = 0; n < columns_count; n++)

  003c8	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$5[ebp], 0
  003d2	eb 0f		 jmp	 SHORT $LN7@BeginColum
$LN5@BeginColum:
  003d4	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _n$5[ebp]
  003da	83 c0 01	 add	 eax, 1
  003dd	89 85 64 ff ff
	ff		 mov	 DWORD PTR _n$5[ebp], eax
$LN7@BeginColum:
  003e3	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _n$5[ebp]
  003e9	3b 45 0c	 cmp	 eax, DWORD PTR _columns_count$[ebp]
  003ec	0f 8d 1b 01 00
	00		 jge	 $LN6@BeginColum

; 7459 :     {
; 7460 :         // Compute clipping rectangle
; 7461 :         ImGuiColumnData* column = &columns->Columns[n];

  003f2	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _n$5[ebp]
  003f8	50		 push	 eax
  003f9	8b 4d d0	 mov	 ecx, DWORD PTR _columns$[ebp]
  003fc	83 c1 4c	 add	 ecx, 76			; 0000004cH
  003ff	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00404	89 85 58 ff ff
	ff		 mov	 DWORD PTR _column$4[ebp], eax

; 7462 :         float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));

  0040a	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _n$5[ebp]
  00410	50		 push	 eax
  00411	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00416	83 c4 04	 add	 esp, 4
  00419	d9 9d 3c fe ff
	ff		 fstp	 DWORD PTR tv513[ebp]
  0041f	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00422	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR tv513[ebp]
  0042a	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  0042f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00437	f3 0f 2c d0	 cvttss2si edx, xmm0
  0043b	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0043f	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _clip_x1$3[ebp], xmm0

; 7463 :         float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);

  00447	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _n$5[ebp]
  0044d	83 c0 01	 add	 eax, 1
  00450	50		 push	 eax
  00451	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00456	83 c4 04	 add	 esp, 4
  00459	d9 9d 3c fe ff
	ff		 fstp	 DWORD PTR tv520[ebp]
  0045f	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00462	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR tv520[ebp]
  0046a	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  0046f	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00477	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0047f	f3 0f 2c d0	 cvttss2si edx, xmm0
  00483	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00487	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _clip_x2$2[ebp], xmm0

; 7464 :         column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);

  0048f	51		 push	 ecx
  00490	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00498	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0049d	51		 push	 ecx
  0049e	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _clip_x2$2[ebp]
  004a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ab	51		 push	 ecx
  004ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  004b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b9	51		 push	 ecx
  004ba	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _clip_x1$3[ebp]
  004c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c7	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  004cd	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  004d2	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _column$4[ebp]
  004d8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  004db	8b 10		 mov	 edx, DWORD PTR [eax]
  004dd	89 11		 mov	 DWORD PTR [ecx], edx
  004df	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  004e2	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  004e5	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  004e8	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  004eb	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  004ee	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 7465 :         column->ClipRect.ClipWith(window->ClipRect);

  004f1	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  004f4	05 04 02 00 00	 add	 eax, 516		; 00000204H
  004f9	50		 push	 eax
  004fa	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _column$4[ebp]
  00500	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00503	e8 00 00 00 00	 call	 ?ClipWith@ImRect@@QAEXABU1@@Z ; ImRect::ClipWith

; 7466 :     }

  00508	e9 c7 fe ff ff	 jmp	 $LN5@BeginColum
$LN6@BeginColum:

; 7467 : 
; 7468 :     if (columns->Count > 1)

  0050d	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00510	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00514	7e 32		 jle	 SHORT $LN10@BeginColum

; 7469 :     {
; 7470 :         window->DrawList->ChannelsSplit(1 + columns->Count);

  00516	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00519	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0051c	83 c1 01	 add	 ecx, 1
  0051f	51		 push	 ecx
  00520	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  00523	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  00529	e8 00 00 00 00	 call	 ?ChannelsSplit@ImDrawList@@QAEXH@Z ; ImDrawList::ChannelsSplit

; 7471 :         window->DrawList->ChannelsSetCurrent(1);

  0052e	6a 01		 push	 1
  00530	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00533	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00539	e8 00 00 00 00	 call	 ?ChannelsSetCurrent@ImDrawList@@QAEXH@Z ; ImDrawList::ChannelsSetCurrent

; 7472 :         PushColumnClipRect(0);

  0053e	6a 00		 push	 0
  00540	e8 00 00 00 00	 call	 ?PushColumnClipRect@ImGui@@YAXH@Z ; ImGui::PushColumnClipRect
  00545	83 c4 04	 add	 esp, 4
$LN10@BeginColum:

; 7473 :     }
; 7474 : 
; 7475 :     // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
; 7476 :     float offset_0 = GetColumnOffset(columns->Current);

  00548	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  0054b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0054e	51		 push	 ecx
  0054f	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00554	83 c4 04	 add	 esp, 4
  00557	d9 9d 34 ff ff
	ff		 fstp	 DWORD PTR _offset_0$[ebp]

; 7477 :     float offset_1 = GetColumnOffset(columns->Current + 1);

  0055d	8b 45 d0	 mov	 eax, DWORD PTR _columns$[ebp]
  00560	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00563	83 c1 01	 add	 ecx, 1
  00566	51		 push	 ecx
  00567	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  0056c	83 c4 04	 add	 esp, 4
  0056f	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _offset_1$[ebp]

; 7478 :     float width = offset_1 - offset_0;

  00575	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _offset_1$[ebp]
  0057d	f3 0f 5c 85 34
	ff ff ff	 subss	 xmm0, DWORD PTR _offset_0$[ebp]
  00585	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _width$[ebp], xmm0

; 7479 :     PushItemWidth(width * 0.65f);

  0058d	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _width$[ebp]
  00595	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f266666
  0059d	51		 push	 ecx
  0059e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a3	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth
  005a8	83 c4 04	 add	 esp, 4

; 7480 :     window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);

  005ab	51		 push	 ecx
  005ac	0f 57 c0	 xorps	 xmm0, xmm0
  005af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b4	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  005b7	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _column_padding$[ebp]
  005bc	f3 0f 5c 40 34	 subss	 xmm0, DWORD PTR [eax+52]
  005c1	51		 push	 ecx
  005c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c7	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  005cc	83 c4 08	 add	 esp, 8
  005cf	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  005d2	d9 99 bc 01 00
	00		 fstp	 DWORD PTR [ecx+444]

; 7481 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  005d8	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  005db	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  005de	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  005e3	f3 0f 58 81 b4
	01 00 00	 addss	 xmm0, DWORD PTR [ecx+436]
  005eb	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  005ee	f3 0f 58 82 bc
	01 00 00	 addss	 xmm0, DWORD PTR [edx+444]
  005f6	f3 0f 2c c0	 cvttss2si eax, xmm0
  005fa	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  005fe	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00601	f3 0f 11 81 c8
	00 00 00	 movss	 DWORD PTR [ecx+200], xmm0

; 7482 :     window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;

  00609	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0060c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00611	f3 0f 58 85 28
	ff ff ff	 addss	 xmm0, DWORD PTR _offset_1$[ebp]
  00619	f3 0f 5c 45 c4	 subss	 xmm0, DWORD PTR _column_padding$[ebp]
  0061e	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00621	f3 0f 11 81 fc
	01 00 00	 movss	 DWORD PTR [ecx+508], xmm0

; 7483 : }

  00629	52		 push	 edx
  0062a	8b cd		 mov	 ecx, ebp
  0062c	50		 push	 eax
  0062d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@BeginColum
  00633	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00638	58		 pop	 eax
  00639	5a		 pop	 edx
  0063a	5f		 pop	 edi
  0063b	5e		 pop	 esi
  0063c	5b		 pop	 ebx
  0063d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00640	33 cd		 xor	 ecx, ebp
  00642	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00647	81 c4 c8 01 00
	00		 add	 esp, 456		; 000001c8H
  0064d	3b ec		 cmp	 ebp, esp
  0064f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00654	8b e5		 mov	 esp, ebp
  00656	5d		 pop	 ebp
  00657	c3		 ret	 0
$LN19@BeginColum:
  00658	01 00 00 00	 DD	 1
  0065c	00 00 00 00	 DD	 $LN18@BeginColum
$LN18@BeginColum:
  00660	70 ff ff ff	 DD	 -144			; ffffff70H
  00664	1c 00 00 00	 DD	 28			; 0000001cH
  00668	00 00 00 00	 DD	 $LN17@BeginColum
$LN17@BeginColum:
  0066c	63		 DB	 99			; 00000063H
  0066d	6f		 DB	 111			; 0000006fH
  0066e	6c		 DB	 108			; 0000006cH
  0066f	75		 DB	 117			; 00000075H
  00670	6d		 DB	 109			; 0000006dH
  00671	6e		 DB	 110			; 0000006eH
  00672	00		 DB	 0
?BeginColumns@ImGui@@YAXPBDHH@Z ENDP			; ImGui::BeginColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?IsNavInputTest@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z
_TEXT	SEGMENT
tv68 = -200						; size = 4
tv76 = -196						; size = 4
_n$ = 8							; size = 4
_rm$ = 12						; size = 4
?IsNavInputTest@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z PROC ; ImGui::IsNavInputTest, COMDAT

; 1697 :     inline bool             IsNavInputTest(ImGuiNavInput n, ImGuiInputReadMode rm)      { return (GetNavInputAmount(n, rm) > 0.0f); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _rm$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z ; ImGui::GetNavInputAmount
  00035	83 c4 08	 add	 esp, 8
  00038	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv76[ebp]
  0003e	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv76[ebp]
  00046	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0004d	76 0c		 jbe	 SHORT $LN3@IsNavInput
  0004f	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
  00059	eb 0a		 jmp	 SHORT $LN4@IsNavInput
$LN3@IsNavInput:
  0005b	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN4@IsNavInput:
  00065	8a 85 38 ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?IsNavInputTest@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z ENDP ; ImGui::IsNavInputTest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?IsNavInputDown@ImGui@@YA_NH@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_g$ = -8						; size = 4
_n$ = 8							; size = 4
?IsNavInputDown@ImGui@@YA_NH@Z PROC			; ImGui::IsNavInputDown, COMDAT

; 1696 :     inline bool             IsNavInputDown(ImGuiNavInput n)                             { ImGuiContext& g = *GImGui; return g.IO.NavInputs[n] > 0.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax
  00030	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00036	f3 0f 10 84 81
	04 03 00 00	 movss	 xmm0, DWORD PTR [ecx+eax*4+772]
  0003f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00046	76 0c		 jbe	 SHORT $LN3@IsNavInput
  00048	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  00052	eb 0a		 jmp	 SHORT $LN4@IsNavInput
$LN3@IsNavInput:
  00054	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@IsNavInput:
  0005e	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?IsNavInputDown@ImGui@@YA_NH@Z ENDP			; ImGui::IsNavInputDown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?IsKeyPressedMap@ImGui@@YA_NH_N@Z
_TEXT	SEGMENT
tv72 = -217						; size = 1
_key_index$ = -20					; size = 4
_g$ = -8						; size = 4
_key$ = 8						; size = 4
_repeat$ = 12						; size = 1
?IsKeyPressedMap@ImGui@@YA_NH_N@Z PROC			; ImGui::IsKeyPressedMap, COMDAT

; 1695 :     inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { ImGuiContext& g = *GImGui; const int key_index = g.IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax
  00030	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00036	8b 54 81 34	 mov	 edx, DWORD PTR [ecx+eax*4+52]
  0003a	89 55 ec	 mov	 DWORD PTR _key_index$[ebp], edx
  0003d	83 7d ec 00	 cmp	 DWORD PTR _key_index$[ebp], 0
  00041	7c 19		 jl	 SHORT $LN3@IsKeyPress
  00043	0f b6 45 0c	 movzx	 eax, BYTE PTR _repeat$[ebp]
  00047	50		 push	 eax
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _key_index$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?IsKeyPressed@ImGui@@YA_NH_N@Z ; ImGui::IsKeyPressed
  00051	83 c4 08	 add	 esp, 8
  00054	88 85 27 ff ff
	ff		 mov	 BYTE PTR tv72[ebp], al
  0005a	eb 07		 jmp	 SHORT $LN4@IsKeyPress
$LN3@IsKeyPress:
  0005c	c6 85 27 ff ff
	ff 00		 mov	 BYTE PTR tv72[ebp], 0
$LN4@IsKeyPress:
  00063	8a 85 27 ff ff
	ff		 mov	 al, BYTE PTR tv72[ebp]
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?IsKeyPressedMap@ImGui@@YA_NH_N@Z ENDP			; ImGui::IsKeyPressedMap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ShrinkWidths@ImGui@@YAXPAUImGuiShrinkWidthItem@@HM@Z
_TEXT	SEGMENT
tv136 = -280						; size = 4
_n$1 = -80						; size = 4
_width_rounded$2 = -68					; size = 4
_n$3 = -56						; size = 4
_item_n$4 = -44						; size = 4
_width_to_remove_per_item$5 = -32			; size = 4
_max_width_to_remove_per_item$6 = -20			; size = 4
_count_same_width$ = -8					; size = 4
_items$ = 8						; size = 4
_count$ = 12						; size = 4
_width_excess$ = 16					; size = 4
?ShrinkWidths@ImGui@@YAXPAUImGuiShrinkWidthItem@@HM@Z PROC ; ImGui::ShrinkWidths, COMDAT

; 1367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1368 :     if (count == 1)

  00028	83 7d 0c 01	 cmp	 DWORD PTR _count$[ebp], 1
  0002c	75 46		 jne	 SHORT $LN15@ShrinkWidt

; 1369 :     {
; 1370 :         items[0].Width = ImMax(items[0].Width - width_excess, 1.0f);

  0002e	51		 push	 ecx
  0002f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00037	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003c	b8 08 00 00 00	 mov	 eax, 8
  00041	6b c8 00	 imul	 ecx, eax, 0
  00044	8b 55 08	 mov	 edx, DWORD PTR _items$[ebp]
  00047	f3 0f 10 44 0a
	04		 movss	 xmm0, DWORD PTR [edx+ecx+4]
  0004d	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _width_excess$[ebp]
  00052	51		 push	 ecx
  00053	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00058	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0005d	83 c4 08	 add	 esp, 8
  00060	b8 08 00 00 00	 mov	 eax, 8
  00065	6b c8 00	 imul	 ecx, eax, 0
  00068	8b 55 08	 mov	 edx, DWORD PTR _items$[ebp]
  0006b	d9 5c 0a 04	 fstp	 DWORD PTR [edx+ecx+4]

; 1371 :         return;

  0006f	e9 27 02 00 00	 jmp	 $LN1@ShrinkWidt
$LN15@ShrinkWidt:

; 1372 :     }
; 1373 :     ImQsort(items, (size_t)count, sizeof(ImGuiShrinkWidthItem), ShrinkWidthItemComparer);

  00074	8b f4		 mov	 esi, esp
  00076	68 00 00 00 00	 push	 OFFSET ?ShrinkWidthItemComparer@@YAHPBX0@Z ; ShrinkWidthItemComparer
  0007b	6a 08		 push	 8
  0007d	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _items$[ebp]
  00084	51		 push	 ecx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__qsort
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1374 :     int count_same_width = 1;

  00095	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _count_same_width$[ebp], 1
$LN2@ShrinkWidt:

; 1375 :     while (width_excess > 0.0f && count_same_width < count)

  0009c	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _width_excess$[ebp]
  000a1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000a8	0f 86 1a 01 00
	00		 jbe	 $LN3@ShrinkWidt
  000ae	8b 45 f8	 mov	 eax, DWORD PTR _count_same_width$[ebp]
  000b1	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  000b4	0f 8d 0e 01 00
	00		 jge	 $LN3@ShrinkWidt
$LN4@ShrinkWidt:

; 1376 :     {
; 1377 :         while (count_same_width < count && items[0].Width <= items[count_same_width].Width)

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _count_same_width$[ebp]
  000bd	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  000c0	7d 29		 jge	 SHORT $LN5@ShrinkWidt
  000c2	b8 08 00 00 00	 mov	 eax, 8
  000c7	6b c8 00	 imul	 ecx, eax, 0
  000ca	8b 55 f8	 mov	 edx, DWORD PTR _count_same_width$[ebp]
  000cd	8b 45 08	 mov	 eax, DWORD PTR _items$[ebp]
  000d0	8b 75 08	 mov	 esi, DWORD PTR _items$[ebp]
  000d3	f3 0f 10 44 d0
	04		 movss	 xmm0, DWORD PTR [eax+edx*8+4]
  000d9	0f 2f 44 0e 04	 comiss	 xmm0, DWORD PTR [esi+ecx+4]
  000de	72 0b		 jb	 SHORT $LN5@ShrinkWidt

; 1378 :             count_same_width++;

  000e0	8b 45 f8	 mov	 eax, DWORD PTR _count_same_width$[ebp]
  000e3	83 c0 01	 add	 eax, 1
  000e6	89 45 f8	 mov	 DWORD PTR _count_same_width$[ebp], eax
  000e9	eb cf		 jmp	 SHORT $LN4@ShrinkWidt
$LN5@ShrinkWidt:

; 1379 :         float max_width_to_remove_per_item = (count_same_width < count) ? (items[0].Width - items[count_same_width].Width) : (items[0].Width - 1.0f);

  000eb	8b 45 f8	 mov	 eax, DWORD PTR _count_same_width$[ebp]
  000ee	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  000f1	7d 27		 jge	 SHORT $LN19@ShrinkWidt
  000f3	b9 08 00 00 00	 mov	 ecx, 8
  000f8	6b d1 00	 imul	 edx, ecx, 0
  000fb	8b 45 08	 mov	 eax, DWORD PTR _items$[ebp]
  000fe	8b 4d f8	 mov	 ecx, DWORD PTR _count_same_width$[ebp]
  00101	8b 75 08	 mov	 esi, DWORD PTR _items$[ebp]
  00104	f3 0f 10 44 10
	04		 movss	 xmm0, DWORD PTR [eax+edx+4]
  0010a	f3 0f 5c 44 ce
	04		 subss	 xmm0, DWORD PTR [esi+ecx*8+4]
  00110	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR tv136[ebp], xmm0
  00118	eb 21		 jmp	 SHORT $LN20@ShrinkWidt
$LN19@ShrinkWidt:
  0011a	ba 08 00 00 00	 mov	 edx, 8
  0011f	6b c2 00	 imul	 eax, edx, 0
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _items$[ebp]
  00125	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [ecx+eax+4]
  0012b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00133	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR tv136[ebp], xmm0
$LN20@ShrinkWidt:
  0013b	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR tv136[ebp]
  00143	f3 0f 11 45 ec	 movss	 DWORD PTR _max_width_to_remove_per_item$6[ebp], xmm0

; 1380 :         float width_to_remove_per_item = ImMin(width_excess / count_same_width, max_width_to_remove_per_item);

  00148	51		 push	 ecx
  00149	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _max_width_to_remove_per_item$6[ebp]
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _count_same_width$[ebp]
  00158	f3 0f 10 4d 10	 movss	 xmm1, DWORD PTR _width_excess$[ebp]
  0015d	f3 0f 5e c8	 divss	 xmm1, xmm0
  00161	51		 push	 ecx
  00162	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00167	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0016c	83 c4 08	 add	 esp, 8
  0016f	d9 5d e0	 fstp	 DWORD PTR _width_to_remove_per_item$5[ebp]

; 1381 :         for (int item_n = 0; item_n < count_same_width; item_n++)

  00172	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _item_n$4[ebp], 0
  00179	eb 09		 jmp	 SHORT $LN8@ShrinkWidt
$LN6@ShrinkWidt:
  0017b	8b 45 d4	 mov	 eax, DWORD PTR _item_n$4[ebp]
  0017e	83 c0 01	 add	 eax, 1
  00181	89 45 d4	 mov	 DWORD PTR _item_n$4[ebp], eax
$LN8@ShrinkWidt:
  00184	8b 45 d4	 mov	 eax, DWORD PTR _item_n$4[ebp]
  00187	3b 45 f8	 cmp	 eax, DWORD PTR _count_same_width$[ebp]
  0018a	7d 1f		 jge	 SHORT $LN7@ShrinkWidt

; 1382 :             items[item_n].Width -= width_to_remove_per_item;

  0018c	8b 45 d4	 mov	 eax, DWORD PTR _item_n$4[ebp]
  0018f	8b 4d 08	 mov	 ecx, DWORD PTR _items$[ebp]
  00192	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00198	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _width_to_remove_per_item$5[ebp]
  0019d	8b 55 d4	 mov	 edx, DWORD PTR _item_n$4[ebp]
  001a0	8b 45 08	 mov	 eax, DWORD PTR _items$[ebp]
  001a3	f3 0f 11 44 d0
	04		 movss	 DWORD PTR [eax+edx*8+4], xmm0
  001a9	eb d0		 jmp	 SHORT $LN6@ShrinkWidt
$LN7@ShrinkWidt:

; 1383 :         width_excess -= width_to_remove_per_item * count_same_width;

  001ab	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _count_same_width$[ebp]
  001b0	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _width_to_remove_per_item$5[ebp]
  001b5	f3 0f 10 4d 10	 movss	 xmm1, DWORD PTR _width_excess$[ebp]
  001ba	f3 0f 5c c8	 subss	 xmm1, xmm0
  001be	f3 0f 11 4d 10	 movss	 DWORD PTR _width_excess$[ebp], xmm1

; 1384 :     }

  001c3	e9 d4 fe ff ff	 jmp	 $LN2@ShrinkWidt
$LN3@ShrinkWidt:

; 1385 : 
; 1386 :     // Round width and redistribute remainder left-to-right (could make it an option of the function?)
; 1387 :     // Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.
; 1388 :     width_excess = 0.0f;

  001c8	0f 57 c0	 xorps	 xmm0, xmm0
  001cb	f3 0f 11 45 10	 movss	 DWORD PTR _width_excess$[ebp], xmm0

; 1389 :     for (int n = 0; n < count; n++)

  001d0	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _n$3[ebp], 0
  001d7	eb 09		 jmp	 SHORT $LN11@ShrinkWidt
$LN9@ShrinkWidt:
  001d9	8b 45 c8	 mov	 eax, DWORD PTR _n$3[ebp]
  001dc	83 c0 01	 add	 eax, 1
  001df	89 45 c8	 mov	 DWORD PTR _n$3[ebp], eax
$LN11@ShrinkWidt:
  001e2	8b 45 c8	 mov	 eax, DWORD PTR _n$3[ebp]
  001e5	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  001e8	7d 4b		 jge	 SHORT $LN10@ShrinkWidt

; 1390 :     {
; 1391 :         float width_rounded = ImFloor(items[n].Width);

  001ea	8b 45 c8	 mov	 eax, DWORD PTR _n$3[ebp]
  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _items$[ebp]
  001f0	51		 push	 ecx
  001f1	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  001f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fc	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  00201	83 c4 04	 add	 esp, 4
  00204	d9 5d bc	 fstp	 DWORD PTR _width_rounded$2[ebp]

; 1392 :         width_excess += items[n].Width - width_rounded;

  00207	8b 45 c8	 mov	 eax, DWORD PTR _n$3[ebp]
  0020a	8b 4d 08	 mov	 ecx, DWORD PTR _items$[ebp]
  0020d	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00213	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _width_rounded$2[ebp]
  00218	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _width_excess$[ebp]
  0021d	f3 0f 11 45 10	 movss	 DWORD PTR _width_excess$[ebp], xmm0

; 1393 :         items[n].Width = width_rounded;

  00222	8b 45 c8	 mov	 eax, DWORD PTR _n$3[ebp]
  00225	8b 4d 08	 mov	 ecx, DWORD PTR _items$[ebp]
  00228	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _width_rounded$2[ebp]
  0022d	f3 0f 11 44 c1
	04		 movss	 DWORD PTR [ecx+eax*8+4], xmm0

; 1394 :     }

  00233	eb a4		 jmp	 SHORT $LN9@ShrinkWidt
$LN10@ShrinkWidt:

; 1395 :     if (width_excess > 0.0f)

  00235	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _width_excess$[ebp]
  0023a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00241	76 58		 jbe	 SHORT $LN13@ShrinkWidt

; 1396 :         for (int n = 0; n < count; n++)

  00243	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0024a	eb 09		 jmp	 SHORT $LN14@ShrinkWidt
$LN12@ShrinkWidt:
  0024c	8b 45 b0	 mov	 eax, DWORD PTR _n$1[ebp]
  0024f	83 c0 01	 add	 eax, 1
  00252	89 45 b0	 mov	 DWORD PTR _n$1[ebp], eax
$LN14@ShrinkWidt:
  00255	8b 45 b0	 mov	 eax, DWORD PTR _n$1[ebp]
  00258	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  0025b	7d 3e		 jge	 SHORT $LN13@ShrinkWidt

; 1397 :             if (items[n].Index < (int)(width_excess + 0.01f))

  0025d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _width_excess$[ebp]
  00262	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3c23d70a
  0026a	f3 0f 2c c0	 cvttss2si eax, xmm0
  0026e	8b 4d b0	 mov	 ecx, DWORD PTR _n$1[ebp]
  00271	8b 55 08	 mov	 edx, DWORD PTR _items$[ebp]
  00274	39 04 ca	 cmp	 DWORD PTR [edx+ecx*8], eax
  00277	7d 20		 jge	 SHORT $LN17@ShrinkWidt

; 1398 :                 items[n].Width += 1.0f;

  00279	8b 45 b0	 mov	 eax, DWORD PTR _n$1[ebp]
  0027c	8b 4d 08	 mov	 ecx, DWORD PTR _items$[ebp]
  0027f	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00285	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0028d	8b 55 b0	 mov	 edx, DWORD PTR _n$1[ebp]
  00290	8b 45 08	 mov	 eax, DWORD PTR _items$[ebp]
  00293	f3 0f 11 44 d0
	04		 movss	 DWORD PTR [eax+edx*8+4], xmm0
$LN17@ShrinkWidt:
  00299	eb b1		 jmp	 SHORT $LN12@ShrinkWidt
$LN13@ShrinkWidt:
$LN1@ShrinkWidt:

; 1399 : }

  0029b	5f		 pop	 edi
  0029c	5e		 pop	 esi
  0029d	5b		 pop	 ebx
  0029e	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  002a4	3b ec		 cmp	 ebp, esp
  002a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c3		 ret	 0
?ShrinkWidths@ImGui@@YAXPAUImGuiShrinkWidthItem@@HM@Z ENDP ; ImGui::ShrinkWidths
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ
_TEXT	SEGMENT
_g$ = -8						; size = 4
?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindow, COMDAT

; 1583 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax
  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	c6 41 7c 01	 mov	 BYTE PTR [ecx+124], 1
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00040	8b 80 b0 19 00
	00		 mov	 eax, DWORD PTR [eax+6576]
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ
_TEXT	SEGMENT
_g$ = -8						; size = 4
?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindowRead, COMDAT

; 1582 :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax
  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 80 b0 19 00
	00		 mov	 eax, DWORD PTR [eax+6576]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindowRead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetTabName@ImGuiTabBar@@QBEPBDPBUImGuiTabItem@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_tab$ = 8						; size = 4
?GetTabName@ImGuiTabBar@@QBEPBDPBUImGuiTabItem@@@Z PROC	; ImGuiTabBar::GetTabName, COMDAT
; _this$ = ecx

; 1565 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1566 :         IM_ASSERT(tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _tab$[ebp]
  00030	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  00034	74 0e		 je	 SHORT $LN3@GetTabName
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _tab$[ebp]
  00039	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0003f	3b 42 6c	 cmp	 eax, DWORD PTR [edx+108]
  00042	7c 21		 jl	 SHORT $LN4@GetTabName
$LN3@GetTabName:
  00044	8b f4		 mov	 esi, esp
  00046	68 1e 06 00 00	 push	 1566			; 0000061eH
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@HAMNIKDF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1HM@PJKJLKEH@?$AAt?$AAa?$AAb?$AA?9?$AA?$DO?$AAN?$AAa?$AAm?$AAe?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@GetTabName:

; 1567 :         return TabsNames.Buf.Data + tab->NameOffset;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 40 74	 mov	 eax, DWORD PTR [eax+116]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _tab$[ebp]
  0006e	03 41 10	 add	 eax, DWORD PTR [ecx+16]

; 1568 :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?GetTabName@ImGuiTabBar@@QBEPBDPBUImGuiTabItem@@@Z ENDP	; ImGuiTabBar::GetTabName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetTabOrder@ImGuiTabBar@@QBEHPBUImGuiTabItem@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_tab$ = 8						; size = 4
?GetTabOrder@ImGuiTabBar@@QBEHPBUImGuiTabItem@@@Z PROC	; ImGuiTabBar::GetTabOrder, COMDAT
; _this$ = ecx

; 1563 :     int                 GetTabOrder(const ImGuiTabItem* tab) const  { return Tabs.index_from_ptr(tab); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _tab$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QBEHPBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::index_from_ptr
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?GetTabOrder@ImGuiTabBar@@QBEHPBUImGuiTabItem@@@Z ENDP	; ImGuiTabBar::GetTabOrder
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiTabBar@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ImGuiTabBar@@QAE@XZ PROC				; ImGuiTabBar::ImGuiTabBar, COMDAT
; _this$ = ecx

; 6368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImGuiTabBar@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??0?$ImVector@UImGuiTabItem@@@@QAE@XZ ; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 24	 add	 ecx, 36			; 00000024H
  00061	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  00066	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	83 c1 64	 add	 ecx, 100		; 00000064H
  0006c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00071	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00077	e8 00 00 00 00	 call	 ??0ImGuiTextBuffer@@QAE@XZ ; ImGuiTextBuffer::ImGuiTextBuffer

; 6369 :     ID = 0;

  0007c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 6370 :     SelectedTabId = NextSelectedTabId = VisibleTabId = 0;

  00086	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00089	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00090	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0009a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0009d	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 6371 :     CurrFrameVisible = PrevFrameVisible = -1;

  000a4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [eax+32], -1
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	c7 41 1c ff ff
	ff ff		 mov	 DWORD PTR [ecx+28], -1

; 6372 :     LastTabContentHeight = 0.0f;

  000b8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	f3 0f 11 40 34	 movss	 DWORD PTR [eax+52], xmm0

; 6373 :     OffsetMax = OffsetMaxIdeal = OffsetNextTab = 0.0f;

  000c3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	0f 57 c0	 xorps	 xmm0, xmm0
  000c9	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0
  000ce	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	0f 57 c0	 xorps	 xmm0, xmm0
  000d4	f3 0f 11 41 3c	 movss	 DWORD PTR [ecx+60], xmm0
  000d9	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000dc	0f 57 c0	 xorps	 xmm0, xmm0
  000df	f3 0f 11 42 38	 movss	 DWORD PTR [edx+56], xmm0

; 6374 :     ScrollingAnim = ScrollingTarget = ScrollingTargetDistToVisibility = ScrollingSpeed = 0.0f;

  000e4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	0f 57 c0	 xorps	 xmm0, xmm0
  000ea	f3 0f 11 40 50	 movss	 DWORD PTR [eax+80], xmm0
  000ef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	0f 57 c0	 xorps	 xmm0, xmm0
  000f5	f3 0f 11 41 4c	 movss	 DWORD PTR [ecx+76], xmm0
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	0f 57 c0	 xorps	 xmm0, xmm0
  00100	f3 0f 11 42 48	 movss	 DWORD PTR [edx+72], xmm0
  00105	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00108	0f 57 c0	 xorps	 xmm0, xmm0
  0010b	f3 0f 11 40 44	 movss	 DWORD PTR [eax+68], xmm0

; 6375 :     Flags = ImGuiTabBarFlags_None;

  00110	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00113	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 6376 :     ReorderRequestTabId = 0;

  0011a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 6377 :     ReorderRequestDir = 0;

  00124	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00127	c6 40 5c 00	 mov	 BYTE PTR [eax+92], 0

; 6378 :     WantLayout = VisibleTabWasSubmitted = false;

  0012b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012e	c6 40 5e 00	 mov	 BYTE PTR [eax+94], 0
  00132	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	c6 41 5d 00	 mov	 BYTE PTR [ecx+93], 0

; 6379 :     LastTabItemIdx = -1;

  00139	83 c8 ff	 or	 eax, -1
  0013c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	66 89 41 60	 mov	 WORD PTR [ecx+96], ax

; 6380 : }

  00143	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0014a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00150	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00157	59		 pop	 ecx
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
  0015b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00161	3b ec		 cmp	 ebp, esp
  00163	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImGuiTabBar@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImGuiTabItem@@@@QAE@XZ ; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0ImGuiTabBar@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImGuiTabBar@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImGuiTabBar@@QAE@XZ ENDP				; ImGuiTabBar::ImGuiTabBar
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QBEHPBUImGuiTabItem@@@Z
_TEXT	SEGMENT
_off$ = -20						; size = 4
_this$ = -8						; size = 4
_it$ = 8						; size = 4
?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QBEHPBUImGuiTabItem@@@Z PROC ; ImVector<ImGuiTabItem>::index_from_ptr, COMDAT
; _this$ = ecx

; 1305 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _it$[ebp]
  00033	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00036	72 13		 jb	 SHORT $LN3@index_from
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	c1 e0 05	 shl	 eax, 5
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00046	39 45 08	 cmp	 DWORD PTR _it$[ebp], eax
  00049	72 21		 jb	 SHORT $LN4@index_from
$LN3@index_from:
  0004b	8b f4		 mov	 esi, esp
  0004d	68 19 05 00 00	 push	 1305			; 00000519H
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1DO@NPHOAPAC@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@index_from:
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _it$[ebp]
  00072	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  00075	c1 f9 05	 sar	 ecx, 5
  00078	89 4d ec	 mov	 DWORD PTR _off$[ebp], ecx
  0007b	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?index_from_ptr@?$ImVector@UImGuiTabItem@@@@QBEHPBUImGuiTabItem@@@Z ENDP ; ImVector<ImGuiTabItem>::index_from_ptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?erase@?$ImVector@UImGuiTabItem@@@@QAEPAUImGuiTabItem@@PBU2@@Z
_TEXT	SEGMENT
_off$ = -20						; size = 4
_this$ = -8						; size = 4
_it$ = 8						; size = 4
?erase@?$ImVector@UImGuiTabItem@@@@QAEPAUImGuiTabItem@@PBU2@@Z PROC ; ImVector<ImGuiTabItem>::erase, COMDAT
; _this$ = ecx

; 1296 :     inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _it$[ebp]
  00033	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00036	72 13		 jb	 SHORT $LN3@erase
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	c1 e0 05	 shl	 eax, 5
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00046	39 45 08	 cmp	 DWORD PTR _it$[ebp], eax
  00049	72 21		 jb	 SHORT $LN4@erase
$LN3@erase:
  0004b	8b f4		 mov	 esi, esp
  0004d	68 10 05 00 00	 push	 1296			; 00000510H
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@erase:
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _it$[ebp]
  00072	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  00075	c1 f9 05	 sar	 ecx, 5
  00078	89 4d ec	 mov	 DWORD PTR _off$[ebp], ecx
  0007b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	2b 4d ec	 sub	 ecx, DWORD PTR _off$[ebp]
  00083	83 e9 01	 sub	 ecx, 1
  00086	c1 e1 05	 shl	 ecx, 5
  00089	51		 push	 ecx
  0008a	8b 55 ec	 mov	 edx, DWORD PTR _off$[ebp]
  0008d	c1 e2 05	 shl	 edx, 5
  00090	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00096	8d 54 11 20	 lea	 edx, DWORD PTR [ecx+edx+32]
  0009a	52		 push	 edx
  0009b	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  0009e	c1 e0 05	 shl	 eax, 5
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _memmove
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	83 e9 01	 sub	 ecx, 1
  000b8	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	89 0a		 mov	 DWORD PTR [edx], ecx
  000bd	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  000c0	c1 e0 05	 shl	 eax, 5
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
?erase@?$ImVector@UImGuiTabItem@@@@QAEPAUImGuiTabItem@@PBU2@@Z ENDP ; ImVector<ImGuiTabItem>::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiTabItem@@@@QAEXABUImGuiTabItem@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImGuiTabItem@@@@QAEXABUImGuiTabItem@@@Z PROC ; ImVector<ImGuiTabItem>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QBEHH@Z ; ImVector<ImGuiTabItem>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiTabItem@@@@QAEXH@Z ; ImVector<ImGuiTabItem>::reserve
$LN2@push_back:
  00054	6a 20		 push	 32			; 00000020H
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	c1 e2 05	 shl	 edx, 5
  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@UImGuiTabItem@@@@QAEXABUImGuiTabItem@@@Z ENDP ; ImVector<ImGuiTabItem>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTabItem@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiTabItem@@@@QAEXH@Z PROC	; ImVector<ImGuiTabItem>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 05	 shl	 eax, 5
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 05	 shl	 ecx, 5
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@UImGuiTabItem@@@@QAEXH@Z ENDP	; ImVector<ImGuiTabItem>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTabItem@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiTabItem@@@@QAEXH@Z PROC	; ImVector<ImGuiTabItem>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QBEHH@Z ; ImVector<ImGuiTabItem>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiTabItem@@@@QAEXH@Z ; ImVector<ImGuiTabItem>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImGuiTabItem@@@@QAEXH@Z ENDP	; ImVector<ImGuiTabItem>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QBEHH@Z PROC ; ImVector<ImGuiTabItem>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QBEHH@Z ENDP ; ImVector<ImGuiTabItem>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@XZ PROC ; ImVector<ImGuiTabItem>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 e8 01	 sub	 eax, 1
  0005e	c1 e0 05	 shl	 eax, 5
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?back@?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@XZ ENDP ; ImVector<ImGuiTabItem>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z PROC ; ImVector<ImGuiTabItem>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0005b	c1 e0 05	 shl	 eax, 5
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ENDP ; ImVector<ImGuiTabItem>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiTabItem@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiTabItem@@@@QAE@XZ PROC		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImGuiTabItem@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiTabItem@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiTabItem@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiTabItem@@@@QAE@XZ ENDP		; ImVector<ImGuiTabItem>::~ImVector<ImGuiTabItem>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiTabItem@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImGuiTabItem@@@@QAE@XZ PROC		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImGuiTabItem@@@@QAE@XZ ENDP		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTabItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImGuiTabItem@@QAE@XZ PROC				; ImGuiTabItem::ImGuiTabItem, COMDAT
; _this$ = ecx

; 1531 :     ImGuiTabItem()      { ID = 0; Flags = 0; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = ContentWidth = 0.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1
  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0
  00074	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00077	0f 57 c0	 xorps	 xmm0, xmm0
  0007a	f3 0f 11 42 14	 movss	 DWORD PTR [edx+20], xmm0
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
??0ImGuiTabItem@@QAE@XZ ENDP				; ImGuiTabItem::ImGuiTabItem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Restore@ImGuiItemHoveredDataBackup@@QBEXXZ
_TEXT	SEGMENT
_window$ = -20						; size = 4
_this$ = -8						; size = 4
?Restore@ImGuiItemHoveredDataBackup@@QBEXXZ PROC	; ImGuiItemHoveredDataBackup::Restore, COMDAT
; _this$ = ecx

; 1498 :     void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00032	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00038	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx
  0003b	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	89 90 08 01 00
	00		 mov	 DWORD PTR [eax+264], edx
  00049	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00052	89 90 0c 01 00
	00		 mov	 DWORD PTR [eax+268], edx
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 08	 add	 eax, 8
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  00061	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  00067	8b 10		 mov	 edx, DWORD PTR [eax]
  00069	89 11		 mov	 DWORD PTR [ecx], edx
  0006b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00071	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00074	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00077	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0007a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0007d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00080	83 c0 18	 add	 eax, 24			; 00000018H
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  00086	81 c1 20 01 00
	00		 add	 ecx, 288		; 00000120H
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	89 11		 mov	 DWORD PTR [ecx], edx
  00090	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00093	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00096	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00099	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0009c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0009f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ab	3b ec		 cmp	 ebp, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
?Restore@ImGuiItemHoveredDataBackup@@QBEXXZ ENDP	; ImGuiItemHoveredDataBackup::Restore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Backup@ImGuiItemHoveredDataBackup@@QAEXXZ
_TEXT	SEGMENT
_window$ = -20						; size = 4
_this$ = -8						; size = 4
?Backup@ImGuiItemHoveredDataBackup@@QAEXXZ PROC		; ImGuiItemHoveredDataBackup::Backup, COMDAT
; _this$ = ecx

; 1497 :     void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00032	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00038	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  00041	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR [ecx+264]
  00047	89 10		 mov	 DWORD PTR [eax], edx
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  0004f	8b 91 0c 01 00
	00		 mov	 edx, DWORD PTR [ecx+268]
  00055	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00058	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0005b	05 10 01 00 00	 add	 eax, 272		; 00000110H
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	83 c1 08	 add	 ecx, 8
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	89 11		 mov	 DWORD PTR [ecx], edx
  0006a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00070	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00073	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00076	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00079	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0007c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0007f	05 20 01 00 00	 add	 eax, 288		; 00000120H
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	83 c1 18	 add	 ecx, 24			; 00000018H
  0008a	8b 10		 mov	 edx, DWORD PTR [eax]
  0008c	89 11		 mov	 DWORD PTR [ecx], edx
  0008e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00091	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00094	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00097	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0009a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0009d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?Backup@ImGuiItemHoveredDataBackup@@QAEXXZ ENDP		; ImGuiItemHoveredDataBackup::Backup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImGuiItemHoveredDataBackup@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImGuiItemHoveredDataBackup@@QAE@XZ PROC		; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup, COMDAT
; _this$ = ecx

; 1496 :     ImGuiItemHoveredDataBackup() { Backup(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 08	 add	 ecx, 8
  00033	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 18	 add	 ecx, 24			; 00000018H
  0003e	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?Backup@ImGuiItemHoveredDataBackup@@QAEXXZ ; ImGuiItemHoveredDataBackup::Backup
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??0ImGuiItemHoveredDataBackup@@QAE@XZ ENDP		; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
tv95 = -220						; size = 4
tv89 = -220						; size = 4
_y1$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ PROC		; ImGuiWindow::MenuBarRect, COMDAT
; _this$ = ecx

; 1485 :     ImRect      MenuBarRect() const         { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?TitleBarHeight@ImGuiWindow@@QBEMXZ ; ImGuiWindow::TitleBarHeight
  00035	d9 9d 24 ff ff
	ff		 fstp	 DWORD PTR tv89[ebp]
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv89[ebp]
  00046	f3 0f 58 40 10	 addss	 xmm0, DWORD PTR [eax+16]
  0004b	f3 0f 11 45 ec	 movss	 DWORD PTR _y1$[ebp], xmm0
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?MenuBarHeight@ImGuiWindow@@QBEMXZ ; ImGuiWindow::MenuBarHeight
  00058	d9 9d 24 ff ff
	ff		 fstp	 DWORD PTR tv95[ebp]
  0005e	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv95[ebp]
  00066	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _y1$[ebp]
  0006b	51		 push	 ecx
  0006c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0007c	f3 0f 58 41 1c	 addss	 xmm0, DWORD PTR [ecx+28]
  00081	51		 push	 ecx
  00082	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00087	51		 push	 ecx
  00088	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _y1$[ebp]
  0008d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00092	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00095	51		 push	 ecx
  00096	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  0009b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a3	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 04 00	 ret	 4
?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP		; ImGuiWindow::MenuBarRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?MenuBarHeight@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
tv78 = -224						; size = 4
tv87 = -220						; size = 4
_g$ = -20						; size = 4
_this$ = -8						; size = 4
?MenuBarHeight@ImGuiWindow@@QBEMXZ PROC			; ImGuiWindow::MenuBarHeight, COMDAT
; _this$ = ecx

; 1484 :     float       MenuBarHeight() const       { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00013	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00032	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003b	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00041	74 42		 je	 SHORT $LN3@MenuBarHei
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?CalcFontSize@ImGuiWindow@@QBEMXZ ; ImGuiWindow::CalcFontSize
  0004b	d9 9d 24 ff ff
	ff		 fstp	 DWORD PTR tv87[ebp]
  00051	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00054	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv87[ebp]
  0005c	f3 0f 58 82 48
	01 00 00	 addss	 xmm0, DWORD PTR [edx+328]
  00064	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00067	f3 0f 10 88 4c
	15 00 00	 movss	 xmm1, DWORD PTR [eax+5452]
  0006f	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  00077	f3 0f 58 c1	 addss	 xmm0, xmm1
  0007b	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
  00083	eb 0b		 jmp	 SHORT $LN4@MenuBarHei
$LN3@MenuBarHei:
  00085	0f 57 c0	 xorps	 xmm0, xmm0
  00088	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
$LN4@MenuBarHei:
  00090	d9 85 20 ff ff
	ff		 fld	 DWORD PTR tv78[ebp]
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
?MenuBarHeight@ImGuiWindow@@QBEMXZ ENDP			; ImGuiWindow::MenuBarHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?TitleBarHeight@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
tv84 = -224						; size = 4
tv74 = -220						; size = 4
_g$ = -20						; size = 4
_this$ = -8						; size = 4
?TitleBarHeight@ImGuiWindow@@QBEMXZ PROC		; ImGuiWindow::TitleBarHeight, COMDAT
; _this$ = ecx

; 1482 :     float       TitleBarHeight() const      { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00013	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00032	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003b	83 e1 01	 and	 ecx, 1
  0003e	74 0d		 je	 SHORT $LN3@TitleBarHe
  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
  0004b	eb 35		 jmp	 SHORT $LN4@TitleBarHe
$LN3@TitleBarHe:
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?CalcFontSize@ImGuiWindow@@QBEMXZ ; ImGuiWindow::CalcFontSize
  00055	d9 9d 20 ff ff
	ff		 fstp	 DWORD PTR tv84[ebp]
  0005b	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR tv84[ebp]
  00063	8b 55 ec	 mov	 edx, DWORD PTR _g$[ebp]
  00066	f3 0f 10 8a 4c
	15 00 00	 movss	 xmm1, DWORD PTR [edx+5452]
  0006e	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  00076	f3 0f 58 c1	 addss	 xmm0, xmm1
  0007a	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
$LN4@TitleBarHe:
  00082	d9 85 24 ff ff
	ff		 fld	 DWORD PTR tv74[ebp]
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00091	3b ec		 cmp	 ebp, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?TitleBarHeight@ImGuiWindow@@QBEMXZ ENDP		; ImGuiWindow::TitleBarHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?CalcFontSize@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
_scale$ = -32						; size = 4
_g$ = -20						; size = 4
_this$ = -8						; size = 4
?CalcFontSize@ImGuiWindow@@QBEMXZ PROC			; ImGuiWindow::CalcFontSize, COMDAT
; _this$ = ecx

; 1481 :     float       CalcFontSize() const        { ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00032	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax
  00035	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	f3 0f 10 80 c8
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6344]
  00043	f3 0f 59 81 6c
	02 00 00	 mulss	 xmm0, DWORD PTR [ecx+620]
  0004b	f3 0f 11 45 e0	 movss	 DWORD PTR _scale$[ebp], xmm0
  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 b8 f0 02 00
	00 00		 cmp	 DWORD PTR [eax+752], 0
  0005a	74 1b		 je	 SHORT $LN2@CalcFontSi
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 88 f0 02 00
	00		 mov	 ecx, DWORD PTR [eax+752]
  00065	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0006a	f3 0f 59 81 6c
	02 00 00	 mulss	 xmm0, DWORD PTR [ecx+620]
  00072	f3 0f 11 45 e0	 movss	 DWORD PTR _scale$[ebp], xmm0
$LN2@CalcFontSi:
  00077	d9 45 e0	 fld	 DWORD PTR _scale$[ebp]
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?CalcFontSize@ImGuiWindow@@QBEMXZ ENDP			; ImGuiWindow::CalcFontSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Rect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Rect@ImGuiWindow@@QBE?AUImRect@@XZ PROC		; ImGuiWindow::Rect, COMDAT
; _this$ = ecx

; 1480 :     ImRect      Rect() const                { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00038	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  0003d	51		 push	 ecx
  0003e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  0004e	f3 0f 58 40 14	 addss	 xmm0, DWORD PTR [eax+20]
  00053	51		 push	 ecx
  00054	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	51		 push	 ecx
  0005d	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  00062	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00067	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	51		 push	 ecx
  0006b	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  00070	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00075	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00078	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect
  0007d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?Rect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP		; ImGuiWindow::Rect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiColumns@@@@QAEXABUImGuiColumns@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImGuiColumns@@@@QAEXABUImGuiColumns@@@Z PROC ; ImVector<ImGuiColumns>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiColumns@@@@QBEHH@Z ; ImVector<ImGuiColumns>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiColumns@@@@QAEXH@Z ; ImVector<ImGuiColumns>::reserve
$LN2@push_back:
  00054	6a 58		 push	 88			; 00000058H
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	6b 11 58	 imul	 edx, DWORD PTR [ecx], 88
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	83 c1 01	 add	 ecx, 1
  00077	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 0a		 mov	 DWORD PTR [edx], ecx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?push_back@?$ImVector@UImGuiColumns@@@@QAEXABUImGuiColumns@@@Z ENDP ; ImVector<ImGuiColumns>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiColumns@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiColumns@@@@QAEXH@Z PROC	; ImVector<ImGuiColumns>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 58	 imul	 eax, DWORD PTR _new_capacity$[ebp], 88
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 58	 imul	 ecx, DWORD PTR [eax], 88
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImGuiColumns@@@@QAEXH@Z ENDP	; ImVector<ImGuiColumns>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiColumns@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiColumns@@@@QBEHH@Z PROC ; ImVector<ImGuiColumns>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImGuiColumns@@@@QBEHH@Z ENDP ; ImVector<ImGuiColumns>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@XZ PROC ; ImVector<ImGuiColumns>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	6b c1 58	 imul	 eax, ecx, 88
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?back@?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@XZ ENDP ; ImVector<ImGuiColumns>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@H@Z PROC ; ImVector<ImGuiColumns>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 58	 imul	 eax, DWORD PTR _i$[ebp], 88
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImGuiColumns@@@@QAEAAUImGuiColumns@@H@Z ENDP ; ImVector<ImGuiColumns>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ PROC ; ImVector<ImGuiGroupData>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	6b c1 2c	 imul	 eax, ecx, 44
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ ENDP ; ImVector<ImGuiGroupData>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ PROC	; ImVector<ImGuiGroupData>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ ENDP	; ImVector<ImGuiGroupData>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z PROC ; ImVector<ImGuiShrinkWidthItem>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 03	 shl	 eax, 3
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 03	 shl	 ecx, 3
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z PROC ; ImVector<ImGuiShrinkWidthItem>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QBEHH@Z ; ImVector<ImGuiShrinkWidthItem>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z ; ImVector<ImGuiShrinkWidthItem>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QAEXH@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QBEHH@Z PROC ; ImVector<ImGuiShrinkWidthItem>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QBEHH@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z PROC ; ImVector<ImGuiShrinkWidthItem>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@UImGuiShrinkWidthItem@@@@QAEAAUImGuiShrinkWidthItem@@H@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXXZ PROC	; ImVector<ImGuiPtrOrIndex>::pop_back, COMDAT
; _this$ = ecx

; 1294 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@pop_back
  00035	8b f4		 mov	 esi, esp
  00037	68 0e 05 00 00	 push	 1294			; 0000050eH
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@pop_back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	89 0a		 mov	 DWORD PTR [edx], ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXXZ ENDP	; ImVector<ImGuiPtrOrIndex>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXABUImGuiPtrOrIndex@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXABUImGuiPtrOrIndex@@@Z PROC ; ImVector<ImGuiPtrOrIndex>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QBEHH@Z ; ImVector<ImGuiPtrOrIndex>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QAEXH@Z ; ImVector<ImGuiPtrOrIndex>::reserve
$LN2@push_back:
  00054	6a 08		 push	 8
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXABUImGuiPtrOrIndex@@@Z ENDP ; ImVector<ImGuiPtrOrIndex>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QAEXH@Z PROC	; ImVector<ImGuiPtrOrIndex>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 03	 shl	 eax, 3
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 03	 shl	 ecx, 3
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QAEXH@Z ENDP	; ImVector<ImGuiPtrOrIndex>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QBEHH@Z PROC ; ImVector<ImGuiPtrOrIndex>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QBEHH@Z ENDP ; ImVector<ImGuiPtrOrIndex>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiPtrOrIndex@@@@QAEAAUImGuiPtrOrIndex@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImGuiPtrOrIndex@@@@QAEAAUImGuiPtrOrIndex@@XZ PROC ; ImVector<ImGuiPtrOrIndex>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00061	8d 44 c8 f8	 lea	 eax, DWORD PTR [eax+ecx*8-8]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?back@?$ImVector@UImGuiPtrOrIndex@@@@QAEAAUImGuiPtrOrIndex@@XZ ENDP ; ImVector<ImGuiPtrOrIndex>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImGuiPtrOrIndex@@@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@UImGuiPtrOrIndex@@@@QBE_NXZ PROC	; ImVector<ImGuiPtrOrIndex>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@UImGuiPtrOrIndex@@@@QBE_NXZ ENDP	; ImVector<ImGuiPtrOrIndex>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ
_TEXT	SEGMENT
tv133 = -292						; size = 4
$T2 = -281						; size = 1
$T3 = -272						; size = 4
$T4 = -260						; size = 4
$T5 = -248						; size = 4
$T6 = -236						; size = 4
_idx$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ PROC ; ImPool<ImGuiTabBar>::Add, COMDAT
; _this$ = ecx

; 379  :     T*          Add()                               { int idx = FreeIdx; if (idx == Buf.Size) { Buf.resize(Buf.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Buf[idx]; } IM_PLACEMENT_NEW(&Buf[idx]) T(); return &Buf[idx]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00021	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00052	89 4d e0	 mov	 DWORD PTR _idx$[ebp], ecx
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d e0	 mov	 ecx, DWORD PTR _idx$[ebp]
  0005b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005d	75 22		 jne	 SHORT $LN2@Add
  0005f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	83 c1 01	 add	 ecx, 1
  00067	51		 push	 ecx
  00068	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImGuiTabBar@@@@QAEXH@Z ; ImVector<ImGuiTabBar>::resize
  00070	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  0007f	eb 14		 jmp	 SHORT $LN3@Add
$LN2@Add:
  00081	8b 45 e0	 mov	 eax, DWORD PTR _idx$[ebp]
  00084	50		 push	 eax
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	8b 10		 mov	 edx, DWORD PTR [eax]
  00092	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$LN3@Add:
  00095	8b 45 e0	 mov	 eax, DWORD PTR _idx$[ebp]
  00098	50		 push	 eax
  00099	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
  000a1	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  000a7	8d 8d e7 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000ad	89 8d f0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  000b3	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  000b9	52		 push	 edx
  000ba	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  000c0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c3	51		 push	 ecx
  000c4	6a 78		 push	 120			; 00000078H
  000c6	e8 00 00 00 00	 call	 ??2@YAPAXIUImNewDummy@@PAX@Z ; operator new
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  000d4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000db	83 bd 08 ff ff
	ff 00		 cmp	 DWORD PTR $T5[ebp], 0
  000e2	74 13		 je	 SHORT $LN5@Add
  000e4	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  000ea	e8 00 00 00 00	 call	 ??0ImGuiTabBar@@QAE@XZ	; ImGuiTabBar::ImGuiTabBar
  000ef	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv133[ebp], eax
  000f5	eb 0a		 jmp	 SHORT $LN6@Add
$LN5@Add:
  000f7	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv133[ebp], 0
$LN6@Add:
  00101	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv133[ebp]
  00107	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], edx
  0010d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00114	8b 45 e0	 mov	 eax, DWORD PTR _idx$[ebp]
  00117	50		 push	 eax
  00118	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
  00120	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00123	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012a	59		 pop	 ecx
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  00134	3b ec		 cmp	 ebp, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ$0:
  00000	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00006	50		 push	 eax
  00007	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00010	50		 push	 eax
  00011	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXUImNewDummy@@0@Z ; operator delete
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	c3		 ret	 0
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a d8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-296]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ ENDP ; ImPool<ImGuiTabBar>::Add
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Contains@?$ImPool@UImGuiTabBar@@@@QBE_NPBUImGuiTabBar@@@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
_p$ = 8							; size = 4
?Contains@?$ImPool@UImGuiTabBar@@@@QBE_NPBUImGuiTabBar@@@Z PROC ; ImPool<ImGuiTabBar>::Contains, COMDAT
; _this$ = ecx

; 377  :     bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00033	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00036	72 1d		 jb	 SHORT $LN3@Contains
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	6b 02 78	 imul	 eax, DWORD PTR [edx], 120
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00044	39 45 08	 cmp	 DWORD PTR _p$[ebp], eax
  00047	73 0c		 jae	 SHORT $LN3@Contains
  00049	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv74[ebp], 1
  00053	eb 0a		 jmp	 SHORT $LN4@Contains
$LN3@Contains:
  00055	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN4@Contains:
  0005f	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv74[ebp]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
?Contains@?$ImPool@UImGuiTabBar@@@@QBE_NPBUImGuiTabBar@@@Z ENDP ; ImPool<ImGuiTabBar>::Contains
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@I@Z
_TEXT	SEGMENT
_p_idx$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@I@Z PROC ; ImPool<ImGuiTabBar>::GetOrAddByKey, COMDAT
; _this$ = ecx

; 376  :     T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Buf[*p_idx]; *p_idx = FreeIdx; return Add(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	6a ff		 push	 -1
  0002f	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00032	50		 push	 eax
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00039	e8 00 00 00 00	 call	 ?GetIntRef@ImGuiStorage@@QAEPAHIH@Z ; ImGuiStorage::GetIntRef
  0003e	89 45 ec	 mov	 DWORD PTR _p_idx$[ebp], eax
  00041	8b 45 ec	 mov	 eax, DWORD PTR _p_idx$[ebp]
  00044	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00047	74 10		 je	 SHORT $LN2@GetOrAddBy
  00049	8b 45 ec	 mov	 eax, DWORD PTR _p_idx$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	51		 push	 ecx
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
  00057	eb 13		 jmp	 SHORT $LN1@GetOrAddBy
$LN2@GetOrAddBy:
  00059	8b 45 ec	 mov	 eax, DWORD PTR _p_idx$[ebp]
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00062	89 10		 mov	 DWORD PTR [eax], edx
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?Add@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@XZ ; ImPool<ImGuiTabBar>::Add
$LN1@GetOrAddBy:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@I@Z ENDP ; ImPool<ImGuiTabBar>::GetOrAddByKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetIndex@?$ImPool@UImGuiTabBar@@@@QBEHPBUImGuiTabBar@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p$ = 8							; size = 4
?GetIndex@?$ImPool@UImGuiTabBar@@@@QBEHPBUImGuiTabBar@@@Z PROC ; ImPool<ImGuiTabBar>::GetIndex, COMDAT
; _this$ = ecx

; 375  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00033	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00036	72 11		 jb	 SHORT $LN3@GetIndex
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	6b 02 78	 imul	 eax, DWORD PTR [edx], 120
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00044	39 45 08	 cmp	 DWORD PTR _p$[ebp], eax
  00047	72 21		 jb	 SHORT $LN4@GetIndex
$LN3@GetIndex:
  00049	8b f4		 mov	 esi, esp
  0004b	68 77 01 00 00	 push	 375			; 00000177H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@HAMNIKDF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_1FC@BIEMKEOL@?$AAp?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAB?$AAu?$AAf?$AA?4?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@GetIndex:
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00070	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  00073	8b c1		 mov	 eax, ecx
  00075	99		 cdq
  00076	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  0007b	f7 f9		 idiv	 ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
?GetIndex@?$ImPool@UImGuiTabBar@@@@QBEHPBUImGuiTabBar@@@Z ENDP ; ImPool<ImGuiTabBar>::GetIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetByIndex@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_n$ = 8							; size = 4
?GetByIndex@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@H@Z PROC ; ImPool<ImGuiTabBar>::GetByIndex, COMDAT
; _this$ = ecx

; 374  :     T*          GetByIndex(ImPoolIdx n)             { return &Buf[n]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z ; ImVector<ImGuiTabBar>::operator[]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?GetByIndex@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@H@Z ENDP ; ImPool<ImGuiTabBar>::GetByIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTabBar@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiTabBar@@@@QAEXH@Z PROC	; ImVector<ImGuiTabBar>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 78	 imul	 eax, DWORD PTR _new_capacity$[ebp], 120
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 78	 imul	 ecx, DWORD PTR [eax], 120
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImGuiTabBar@@@@QAEXH@Z ENDP	; ImVector<ImGuiTabBar>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTabBar@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiTabBar@@@@QAEXH@Z PROC		; ImVector<ImGuiTabBar>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QBEHH@Z ; ImVector<ImGuiTabBar>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiTabBar@@@@QAEXH@Z ; ImVector<ImGuiTabBar>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImGuiTabBar@@@@QAEXH@Z ENDP		; ImVector<ImGuiTabBar>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QBEHH@Z PROC	; ImVector<ImGuiTabBar>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImGuiTabBar@@@@QBEHH@Z ENDP	; ImVector<ImGuiTabBar>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z PROC ; ImVector<ImGuiTabBar>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 78	 imul	 eax, DWORD PTR _i$[ebp], 120
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImGuiTabBar@@@@QAEAAUImGuiTabBar@@H@Z ENDP ; ImVector<ImGuiTabBar>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiPopupData@@@@QAEAAUImGuiPopupData@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImGuiPopupData@@@@QAEAAUImGuiPopupData@@H@Z PROC ; ImVector<ImGuiPopupData>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 24	 imul	 eax, DWORD PTR _i$[ebp], 36
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImGuiPopupData@@@@QAEAAUImGuiPopupData@@H@Z ENDP ; ImVector<ImGuiPopupData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImGuiPtrOrIndex@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
??0ImGuiPtrOrIndex@@QAE@H@Z PROC			; ImGuiPtrOrIndex::ImGuiPtrOrIndex, COMDAT
; _this$ = ecx

; 953  :     ImGuiPtrOrIndex(int index)          { Ptr = NULL; Index = index; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  0003c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??0ImGuiPtrOrIndex@@QAE@H@Z ENDP			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImGuiPtrOrIndex@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ptr$ = 8						; size = 4
??0ImGuiPtrOrIndex@@QAE@PAX@Z PROC			; ImGuiPtrOrIndex::ImGuiPtrOrIndex, COMDAT
; _this$ = ecx

; 952  :     ImGuiPtrOrIndex(void* ptr)          { Ptr = ptr; Index = -1; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00033	89 08		 mov	 DWORD PTR [eax], ecx
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??0ImGuiPtrOrIndex@@QAE@PAX@Z ENDP			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ClearFlags@ImGuiNextItemData@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ClearFlags@ImGuiNextItemData@@QAEXXZ PROC		; ImGuiNextItemData::ClearFlags, COMDAT
; _this$ = ecx

; 934  :     inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?ClearFlags@ImGuiNextItemData@@QAEXXZ ENDP		; ImGuiNextItemData::ClearFlags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1ImGuiColumns@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1ImGuiColumns@@QAE@XZ PROC				; ImGuiColumns::~ImGuiColumns, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00029	e8 00 00 00 00	 call	 ??1?$ImVector@UImGuiColumnData@@@@QAE@XZ ; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??1ImGuiColumns@@QAE@XZ ENDP				; ImGuiColumns::~ImGuiColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Clear@ImGuiColumns@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@ImGuiColumns@@QAEXXZ PROC			; ImGuiColumns::Clear, COMDAT
; _this$ = ecx

; 830  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 831  :         ID = 0;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 832  :         Flags = ImGuiColumnsFlags_None;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 833  :         IsFirstFrame = false;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c6 40 08 00	 mov	 BYTE PTR [eax+8], 0

; 834  :         IsBeingResized = false;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c6 40 09 00	 mov	 BYTE PTR [eax+9], 0

; 835  :         Current = 0;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 836  :         Count = 1;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 837  :         OffMinX = OffMaxX = 0.0f;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 838  :         LineMinY = LineMaxY = 0.0f;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	0f 57 c0	 xorps	 xmm0, xmm0
  00089	f3 0f 11 41 1c	 movss	 DWORD PTR [ecx+28], xmm0

; 839  :         HostCursorPosY = 0.0f;

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00091	0f 57 c0	 xorps	 xmm0, xmm0
  00094	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 840  :         HostCursorMaxPosX = 0.0f;

  00099	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	0f 57 c0	 xorps	 xmm0, xmm0
  0009f	f3 0f 11 40 28	 movss	 DWORD PTR [eax+40], xmm0

; 841  :         Columns.clear();

  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000aa	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImGuiColumnData@@@@QAEXXZ ; ImVector<ImGuiColumnData>::clear

; 842  :     }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
?Clear@ImGuiColumns@@QAEXXZ ENDP			; ImGuiColumns::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImGuiColumns@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ImGuiColumns@@QAE@XZ PROC				; ImGuiColumns::ImGuiColumns, COMDAT
; _this$ = ecx

; 828  :     ImGuiColumns()      { Clear(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImGuiColumns@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00052	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0005d	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  00062	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00068	e8 00 00 00 00	 call	 ??0?$ImVector@UImGuiColumnData@@@@QAE@XZ ; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?Clear@ImGuiColumns@@QAEXXZ ; ImGuiColumns::Clear
  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00083	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImGuiColumns@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00006	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImGuiColumnData@@@@QAE@XZ ; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0ImGuiColumns@@QAE@XZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImGuiColumns@@QAE@XZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImGuiColumns@@QAE@XZ ENDP				; ImGuiColumns::ImGuiColumns
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiColumnData@@@@QAEXABUImGuiColumnData@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImGuiColumnData@@@@QAEXABUImGuiColumnData@@@Z PROC ; ImVector<ImGuiColumnData>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QBEHH@Z ; ImVector<ImGuiColumnData>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ; ImVector<ImGuiColumnData>::reserve
$LN2@push_back:
  00054	6a 1c		 push	 28			; 0000001cH
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	6b 11 1c	 imul	 edx, DWORD PTR [ecx], 28
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	83 c1 01	 add	 ecx, 1
  00077	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 0a		 mov	 DWORD PTR [edx], ecx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?push_back@?$ImVector@UImGuiColumnData@@@@QAEXABUImGuiColumnData@@@Z ENDP ; ImVector<ImGuiColumnData>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z PROC	; ImVector<ImGuiColumnData>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 1c	 imul	 eax, DWORD PTR _new_capacity$[ebp], 28
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ENDP	; ImVector<ImGuiColumnData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z PROC	; ImVector<ImGuiColumnData>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QBEHH@Z ; ImVector<ImGuiColumnData>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ; ImVector<ImGuiColumnData>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ENDP	; ImVector<ImGuiColumnData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QBEHH@Z PROC ; ImVector<ImGuiColumnData>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QBEHH@Z ENDP ; ImVector<ImGuiColumnData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiColumnData@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImGuiColumnData@@@@QAEXXZ PROC	; ImVector<ImGuiColumnData>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImGuiColumnData@@@@QAEXXZ ENDP	; ImVector<ImGuiColumnData>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z PROC ; ImVector<ImGuiColumnData>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ENDP ; ImVector<ImGuiColumnData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiColumnData@@@@QAE@XZ PROC		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiColumnData@@@@QAE@XZ ENDP		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiColumnData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImGuiColumnData@@@@QAE@XZ PROC		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImGuiColumnData@@@@QAE@XZ ENDP		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImGuiColumnData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImGuiColumnData@@QAE@XZ PROC				; ImGuiColumnData::ImGuiColumnData, COMDAT
; _this$ = ecx

; 809  :     ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = ImGuiColumnsFlags_None; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00033	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	0f 57 c0	 xorps	 xmm0, xmm0
  00049	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??0ImGuiColumnData@@QAE@XZ ENDP				; ImGuiColumnData::ImGuiColumnData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMin@H@@YAHHH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMin@H@@YAHHH@Z PROC				; ImMin<int>, COMDAT

; 314  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _rhs$[ebp]
  0002e	7d 0b		 jge	 SHORT $LN3@ImMin
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00033	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00039	eb 09		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _rhs$[ebp]
  0003e	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
$LN4@ImMin:
  00044	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImMin@H@@YAHHH@Z ENDP				; ImMin<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?SelectAll@ImGuiInputTextState@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?SelectAll@ImGuiInputTextState@@QAEXXZ PROC		; ImGuiInputTextState::SelectAll, COMDAT
; _this$ = ecx

; 759  :     void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0
  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00040	89 50 44	 mov	 DWORD PTR [eax+68], edx
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0004c	89 50 3c	 mov	 DWORD PTR [eax+60], edx
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c6 40 4b 00	 mov	 BYTE PTR [eax+75], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?SelectAll@ImGuiInputTextState@@QAEXXZ ENDP		; ImGuiInputTextState::SelectAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ClearSelection@ImGuiInputTextState@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ClearSelection@ImGuiInputTextState@@QAEXXZ PROC	; ImGuiInputTextState::ClearSelection, COMDAT
; _this$ = ecx

; 758  :     void        ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00036	89 50 44	 mov	 DWORD PTR [eax+68], edx
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00042	89 50 40	 mov	 DWORD PTR [eax+64], edx
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?ClearSelection@ImGuiInputTextState@@QAEXXZ ENDP	; ImGuiInputTextState::ClearSelection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?HasSelection@ImGuiInputTextState@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?HasSelection@ImGuiInputTextState@@QBE_NXZ PROC		; ImGuiInputTextState::HasSelection, COMDAT
; _this$ = ecx

; 757  :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  00036	3b 51 44	 cmp	 edx, DWORD PTR [ecx+68]
  00039	74 0c		 je	 SHORT $LN3@HasSelecti
  0003b	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv69[ebp], 1
  00045	eb 0a		 jmp	 SHORT $LN4@HasSelecti
$LN3@HasSelecti:
  00047	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@HasSelecti:
  00051	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv69[ebp]
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?HasSelection@ImGuiInputTextState@@QBE_NXZ ENDP		; ImGuiInputTextState::HasSelection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?CursorClamp@ImGuiInputTextState@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?CursorClamp@ImGuiInputTextState@@QAEXXZ PROC		; ImGuiInputTextState::CursorClamp, COMDAT
; _this$ = ecx

; 756  :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  00040	83 c4 08	 add	 esp, 8
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004f	51		 push	 ecx
  00050	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  0005c	83 c4 08	 add	 esp, 8
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006b	51		 push	 ecx
  0006c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  00078	83 c4 08	 add	 esp, 8
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?CursorClamp@ImGuiInputTextState@@QAEXXZ ENDP		; ImGuiInputTextState::CursorClamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?CursorAnimReset@ImGuiInputTextState@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?CursorAnimReset@ImGuiInputTextState@@QAEXXZ PROC	; ImGuiInputTextState::CursorAnimReset, COMDAT
; _this$ = ecx

; 755  :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@be99999a
  00038	f3 0f 11 80 60
	0e 00 00	 movss	 DWORD PTR [eax+3680], xmm0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?CursorAnimReset@ImGuiInputTextState@@QAEXXZ ENDP	; ImGuiInputTextState::CursorAnimReset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z PROC		; ImGuiInputTextState::OnKeyPressed, COMDAT
; _this$ = ecx

; 3256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3257 :     stb_textedit_key(this, &Stb, key);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00037	51		 push	 ecx
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?stb_textedit_key@ImStb@@YAXPAUImGuiInputTextState@@PAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3258 :     CursorFollow = true;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c6 80 64 0e 00
	00 01		 mov	 BYTE PTR [eax+3684], 1

; 3259 :     CursorAnimReset();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?CursorAnimReset@ImGuiInputTextState@@QAEXXZ ; ImGuiInputTextState::CursorAnimReset

; 3260 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
?OnKeyPressed@ImGuiInputTextState@@QAEXH@Z ENDP		; ImGuiInputTextState::OnKeyPressed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?CalcExtraSpace@ImGuiMenuColumns@@QBEMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_avail_w$ = 8						; size = 4
?CalcExtraSpace@ImGuiMenuColumns@@QBEMM@Z PROC		; ImGuiMenuColumns::CalcExtraSpace, COMDAT
; _this$ = ecx

; 6007 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6008 :     return ImMax(0.0f, avail_w - Width);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _avail_w$[ebp]
  00035	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  0003a	51		 push	 ecx
  0003b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00040	51		 push	 ecx
  00041	0f 57 c0	 xorps	 xmm0, xmm0
  00044	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00049	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0004e	83 c4 08	 add	 esp, 8

; 6009 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?CalcExtraSpace@ImGuiMenuColumns@@QBEMM@Z ENDP		; ImGuiMenuColumns::CalcExtraSpace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DeclColumns@ImGuiMenuColumns@@QAEMMMM@Z
_TEXT	SEGMENT
tv136 = -220						; size = 4
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_w0$ = 8						; size = 4
_w1$ = 12						; size = 4
_w2$ = 16						; size = 4
?DeclColumns@ImGuiMenuColumns@@QAEMMMM@Z PROC		; ImGuiMenuColumns::DeclColumns, COMDAT
; _this$ = ecx

; 5996 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5997 :     NextWidth = 0.0f;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 5998 :     NextWidths[0] = ImMax(NextWidths[0], w0);

  00038	51		 push	 ecx
  00039	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _w0$[ebp]
  0003e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00043	b8 04 00 00 00	 mov	 eax, 4
  00048	6b c8 00	 imul	 ecx, eax, 0
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	51		 push	 ecx
  0004f	f3 0f 10 44 0a
	18		 movss	 xmm0, DWORD PTR [edx+ecx+24]
  00055	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005a	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0005f	83 c4 08	 add	 esp, 8
  00062	b8 04 00 00 00	 mov	 eax, 4
  00067	6b c8 00	 imul	 ecx, eax, 0
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	d9 5c 0a 18	 fstp	 DWORD PTR [edx+ecx+24]

; 5999 :     NextWidths[1] = ImMax(NextWidths[1], w1);

  00071	51		 push	 ecx
  00072	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _w1$[ebp]
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	b8 04 00 00 00	 mov	 eax, 4
  00081	c1 e0 00	 shl	 eax, 0
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	51		 push	 ecx
  00088	f3 0f 10 44 01
	18		 movss	 xmm0, DWORD PTR [ecx+eax+24]
  0008e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00093	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00098	83 c4 08	 add	 esp, 8
  0009b	ba 04 00 00 00	 mov	 edx, 4
  000a0	c1 e2 00	 shl	 edx, 0
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	d9 5c 10 18	 fstp	 DWORD PTR [eax+edx+24]

; 6000 :     NextWidths[2] = ImMax(NextWidths[2], w2);

  000aa	51		 push	 ecx
  000ab	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _w2$[ebp]
  000b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	d1 e0		 shl	 eax, 1
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	51		 push	 ecx
  000c0	f3 0f 10 44 01
	18		 movss	 xmm0, DWORD PTR [ecx+eax+24]
  000c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cb	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000d0	83 c4 08	 add	 esp, 8
  000d3	ba 04 00 00 00	 mov	 edx, 4
  000d8	d1 e2		 shl	 edx, 1
  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	d9 5c 10 18	 fstp	 DWORD PTR [eax+edx+24]

; 6001 :     for (int i = 0; i < IM_ARRAYSIZE(Pos); i++)

  000e1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  000e8	eb 09		 jmp	 SHORT $LN4@DeclColumn
$LN2@DeclColumn:
  000ea	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@DeclColumn:
  000f3	83 7d ec 03	 cmp	 DWORD PTR _i$1[ebp], 3
  000f7	7d 5d		 jge	 SHORT $LN3@DeclColumn

; 6002 :         NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);

  000f9	83 7d ec 00	 cmp	 DWORD PTR _i$1[ebp], 0
  000fd	7e 26		 jle	 SHORT $LN6@DeclColumn
  000ff	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	f3 0f 10 44 81
	18		 movss	 xmm0, DWORD PTR [ecx+eax*4+24]
  0010b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00112	76 11		 jbe	 SHORT $LN6@DeclColumn
  00114	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00117	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0011b	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv136[ebp], xmm0
  00123	eb 0b		 jmp	 SHORT $LN7@DeclColumn
$LN6@DeclColumn:
  00125	0f 57 c0	 xorps	 xmm0, xmm0
  00128	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv136[ebp], xmm0
$LN7@DeclColumn:
  00130	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00133	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	f3 0f 10 44 81
	18		 movss	 xmm0, DWORD PTR [ecx+eax*4+24]
  0013c	f3 0f 58 85 24
	ff ff ff	 addss	 xmm0, DWORD PTR tv136[ebp]
  00144	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00147	f3 0f 58 42 08	 addss	 xmm0, DWORD PTR [edx+8]
  0014c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00154	eb 94		 jmp	 SHORT $LN2@DeclColumn
$LN3@DeclColumn:

; 6003 :     return ImMax(Width, NextWidth);

  00156	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00159	51		 push	 ecx
  0015a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0015f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00164	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	51		 push	 ecx
  00168	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0016d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00172	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00177	83 c4 08	 add	 esp, 8

; 6004 : }

  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00183	3b ec		 cmp	 ebp, esp
  00185	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 0c 00	 ret	 12			; 0000000cH
?DeclColumns@ImGuiMenuColumns@@QAEMMMM@Z ENDP		; ImGuiMenuColumns::DeclColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Update@ImGuiMenuColumns@@QAEXHM_N@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_count$ = 8						; size = 4
_spacing$ = 12						; size = 4
_clear$ = 16						; size = 1
?Update@ImGuiMenuColumns@@QAEXHM_N@Z PROC		; ImGuiMenuColumns::Update, COMDAT
; _this$ = ecx

; 5978 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5979 :     IM_ASSERT(count == IM_ARRAYSIZE(Pos));

  0002d	83 7d 08 03	 cmp	 DWORD PTR _count$[ebp], 3
  00031	74 25		 je	 SHORT $LN8@Update
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??Update@ImGuiMenuColumns@@QAEXHM_N@Z@4JA
  00038	83 c0 01	 add	 eax, 1
  0003b	8b f4		 mov	 esi, esp
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1FK@BNPKANMO@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@Update:

; 5980 :     IM_UNUSED(count);
; 5981 :     Width = NextWidth = 0.0f;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	0f 57 c0	 xorps	 xmm0, xmm0
  0005e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	0f 57 c0	 xorps	 xmm0, xmm0
  00069	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 5982 :     Spacing = spacing;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _spacing$[ebp]
  00076	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 5983 :     if (clear)

  0007a	0f b6 45 10	 movzx	 eax, BYTE PTR _clear$[ebp]
  0007e	85 c0		 test	 eax, eax
  00080	74 13		 je	 SHORT $LN5@Update

; 5984 :         memset(NextWidths, 0, sizeof(NextWidths));

  00082	6a 0c		 push	 12			; 0000000cH
  00084	6a 00		 push	 0
  00086	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 c0 18	 add	 eax, 24			; 00000018H
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _memset
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@Update:

; 5985 :     for (int i = 0; i < IM_ARRAYSIZE(Pos); i++)

  00095	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0009c	eb 09		 jmp	 SHORT $LN4@Update
$LN2@Update:
  0009e	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Update:
  000a7	83 7d ec 03	 cmp	 DWORD PTR _i$1[ebp], 3
  000ab	7d 7a		 jge	 SHORT $LN3@Update

; 5986 :     {
; 5987 :         if (i > 0 && NextWidths[i] > 0.0f)

  000ad	83 7d ec 00	 cmp	 DWORD PTR _i$1[ebp], 0
  000b1	7e 2c		 jle	 SHORT $LN6@Update
  000b3	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	f3 0f 10 44 81
	18		 movss	 xmm0, DWORD PTR [ecx+eax*4+24]
  000bf	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000c6	76 17		 jbe	 SHORT $LN6@Update

; 5988 :             Width += Spacing;

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000d3	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  000d7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000da	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
$LN6@Update:

; 5989 :         Pos[i] = IM_FLOOR(Width);

  000df	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	f3 0f 2c 48 04	 cvttss2si ecx, DWORD PTR [eax+4]
  000e7	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000eb	8b 55 ec	 mov	 edx, DWORD PTR _i$1[ebp]
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	f3 0f 11 44 90
	0c		 movss	 DWORD PTR [eax+edx*4+12], xmm0

; 5990 :         Width += NextWidths[i];

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  000fd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00100	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00105	f3 0f 58 44 8a
	18		 addss	 xmm0, DWORD PTR [edx+ecx*4+24]
  0010b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010e	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 5991 :         NextWidths[i] = 0.0f;

  00113	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00116	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	0f 57 c0	 xorps	 xmm0, xmm0
  0011c	f3 0f 11 44 81
	18		 movss	 DWORD PTR [ecx+eax*4+24], xmm0

; 5992 :     }

  00122	e9 77 ff ff ff	 jmp	 $LN2@Update
$LN3@Update:

; 5993 : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00130	3b ec		 cmp	 ebp, esp
  00132	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 0c 00	 ret	 12			; 0000000cH
?Update@ImGuiMenuColumns@@QAEXHM_N@Z ENDP		; ImGuiMenuColumns::Update
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiMenuColumns@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImGuiMenuColumns@@QAE@XZ PROC			; ImGuiMenuColumns::ImGuiMenuColumns, COMDAT
; _this$ = ecx

; 5971 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5972 :     Spacing = Width = NextWidth = 0.0f;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	0f 57 c0	 xorps	 xmm0, xmm0
  00049	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 5973 :     memset(Pos, 0, sizeof(Pos));

  0004d	6a 0c		 push	 12			; 0000000cH
  0004f	6a 00		 push	 0
  00051	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00054	83 c0 0c	 add	 eax, 12			; 0000000cH
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _memset
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5974 :     memset(NextWidths, 0, sizeof(NextWidths));

  00060	6a 0c		 push	 12			; 0000000cH
  00062	6a 00		 push	 0
  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 c0 18	 add	 eax, 24			; 00000018H
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _memset
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5975 : }

  00073	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
??0ImGuiMenuColumns@@QAE@XZ ENDP			; ImGuiMenuColumns::ImGuiMenuColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ClipWith@ImRect@@QAEXABU1@@Z
_TEXT	SEGMENT
$T1 = -232						; size = 8
$T2 = -216						; size = 8
_this$ = -8						; size = 4
_r$ = 8							; size = 4
?ClipWith@ImRect@@QAEXABU1@@Z PROC			; ImRect::ClipWith, COMDAT
; _this$ = ecx

; 670  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00013	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	51		 push	 ecx
  00035	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?ImMax@@YA?AUImVec2@@ABU1@0@Z ; ImMax
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
  0004e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00051	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00054	83 c0 08	 add	 eax, 8
  00057	50		 push	 eax
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 08	 add	 ecx, 8
  0005e	51		 push	 ecx
  0005f	8d 95 18 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ?ImMin@@YA?AUImVec2@@ABU1@0@Z ; ImMin
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00073	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00076	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00079	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?ClipWith@ImRect@@QAEXABU1@@Z ENDP			; ImRect::ClipWith
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Translate@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_d$ = 8							; size = 4
?Translate@ImRect@@QAEXABUImVec2@@@Z PROC		; ImRect::Translate, COMDAT
; _this$ = ecx

; 667  :     void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00033	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00037	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00048	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004d	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00052	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00055	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00060	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00065	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	f3 0f 11 42 08	 movss	 DWORD PTR [edx+8], xmm0
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _d$[ebp]
  00077	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0007c	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00081	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00084	f3 0f 11 42 0c	 movss	 DWORD PTR [edx+12], xmm0
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 04 00	 ret	 4
?Translate@ImRect@@QAEXABUImVec2@@@Z ENDP		; ImRect::Translate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_amount$ = 8						; size = 4
?Expand@ImRect@@QAEXABUImVec2@@@Z PROC			; ImRect::Expand, COMDAT
; _this$ = ecx

; 666  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _amount$[ebp]
  00033	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00037	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _amount$[ebp]
  00048	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004d	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00052	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00055	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _amount$[ebp]
  00060	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00065	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	f3 0f 11 42 08	 movss	 DWORD PTR [edx+8], xmm0
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _amount$[ebp]
  00077	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0007c	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00081	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00084	f3 0f 11 42 0c	 movss	 DWORD PTR [edx+12], xmm0
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 04 00	 ret	 4
?Expand@ImRect@@QAEXABUImVec2@@@Z ENDP			; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_amount$ = 8						; size = 4
?Expand@ImRect@@QAEXM@Z PROC				; ImRect::Expand, COMDAT
; _this$ = ecx

; 665  :     void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _amount$[ebp]
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00048	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _amount$[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0005d	f3 0f 58 45 08	 addss	 xmm0, DWORD PTR _amount$[ebp]
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00072	f3 0f 58 45 08	 addss	 xmm0, DWORD PTR _amount$[ebp]
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
?Expand@ImRect@@QAEXM@Z ENDP				; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Overlaps@ImRect@@QBE_NABU1@@Z
_TEXT	SEGMENT
tv84 = -208						; size = 4
_this$ = -8						; size = 4
_r$ = 8							; size = 4
?Overlaps@ImRect@@QBE_NABU1@@Z PROC			; ImRect::Overlaps, COMDAT
; _this$ = ecx

; 662  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00033	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00038	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  0003c	76 3d		 jbe	 SHORT $LN3@Overlaps
  0003e	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  00049	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  0004d	76 2c		 jbe	 SHORT $LN3@Overlaps
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00055	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0005a	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  0005d	76 1c		 jbe	 SHORT $LN3@Overlaps
  0005f	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0006a	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  0006d	76 0c		 jbe	 SHORT $LN3@Overlaps
  0006f	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv84[ebp], 1
  00079	eb 0a		 jmp	 SHORT $LN4@Overlaps
$LN3@Overlaps:
  0007b	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN4@Overlaps:
  00085	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv84[ebp]
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
?Overlaps@ImRect@@QBE_NABU1@@Z ENDP			; ImRect::Overlaps
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QBE_NABU1@@Z
_TEXT	SEGMENT
tv84 = -208						; size = 4
_this$ = -8						; size = 4
_r$ = 8							; size = 4
?Contains@ImRect@@QBE_NABU1@@Z PROC			; ImRect::Contains, COMDAT
; _this$ = ecx

; 661  :     bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00037	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  0003a	72 3f		 jb	 SHORT $LN3@Contains
  0003c	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00047	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  0004b	72 2e		 jb	 SHORT $LN3@Contains
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00053	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00058	0f 2f 42 08	 comiss	 xmm0, DWORD PTR [edx+8]
  0005c	72 1d		 jb	 SHORT $LN3@Contains
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _r$[ebp]
  00064	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00069	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [ecx+12]
  0006d	72 0c		 jb	 SHORT $LN3@Contains
  0006f	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv84[ebp], 1
  00079	eb 0a		 jmp	 SHORT $LN4@Contains
$LN3@Contains:
  0007b	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN4@Contains:
  00085	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv84[ebp]
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
?Contains@ImRect@@QBE_NABU1@@Z ENDP			; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QBE_NABUImVec2@@@Z
_TEXT	SEGMENT
tv80 = -208						; size = 4
_this$ = -8						; size = 4
_p$ = 8							; size = 4
?Contains@ImRect@@QBE_NABUImVec2@@@Z PROC		; ImRect::Contains, COMDAT
; _this$ = ecx

; 660  :     bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00037	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  0003a	72 3e		 jb	 SHORT $LN3@Contains
  0003c	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00047	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  0004b	72 2d		 jb	 SHORT $LN3@Contains
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00053	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00058	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  0005b	76 1d		 jbe	 SHORT $LN3@Contains
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00063	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00068	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  0006c	76 0c		 jbe	 SHORT $LN3@Contains
  0006e	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv80[ebp], 1
  00078	eb 0a		 jmp	 SHORT $LN4@Contains
$LN3@Contains:
  0007a	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv80[ebp], 0
$LN4@Contains:
  00084	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv80[ebp]
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
?Contains@ImRect@@QBE_NABUImVec2@@@Z ENDP		; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetBR@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetBR@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetBR, COMDAT
; _this$ = ecx

; 659  :     ImVec2      GetBR() const                       { return Max; }                   // Bottom-right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00033	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00036	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?GetBR@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetBR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetBL@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetBL@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetBL, COMDAT
; _this$ = ecx

; 658  :     ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	51		 push	 ecx
  00031	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	51		 push	 ecx
  0003f	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00050	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
?GetBL@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetBL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetTR@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTR@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetTR, COMDAT
; _this$ = ecx

; 657  :     ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	51		 push	 ecx
  00031	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	51		 push	 ecx
  0003f	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00044	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00049	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?GetTR@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetTR
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetTL@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTL@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetTL, COMDAT
; _this$ = ecx

; 656  :     ImVec2      GetTL() const                       { return Min; }                   // Top-left

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00035	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?GetTL@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetTL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetHeight@ImRect@@QBEMXZ
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
?GetHeight@ImRect@@QBEMXZ PROC				; ImRect::GetHeight, COMDAT
; _this$ = ecx

; 655  :     float       GetHeight() const                   { return Max.y - Min.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00038	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0003d	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
  00045	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv74[ebp]
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GetHeight@ImRect@@QBEMXZ ENDP				; ImRect::GetHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetWidth@ImRect@@QBEMXZ
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
?GetWidth@ImRect@@QBEMXZ PROC				; ImRect::GetWidth, COMDAT
; _this$ = ecx

; 654  :     float       GetWidth() const                    { return Max.x - Min.x; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00038	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0003c	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
  00044	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv74[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?GetWidth@ImRect@@QBEMXZ ENDP				; ImRect::GetWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetSize@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetSize@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetSize, COMDAT
; _this$ = ecx

; 653  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00038	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0003d	51		 push	 ecx
  0003e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  0004e	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00058	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
?GetSize@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetCenter@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetCenter@ImRect@@QBE?AUImVec2@@XZ PROC		; ImRect::GetCenter, COMDAT
; _this$ = ecx

; 652  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00038	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  0003d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00045	51		 push	 ecx
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00055	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  0005a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00062	51		 push	 ecx
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00070	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?GetCenter@ImRect@@QBE?AUImVec2@@XZ ENDP		; ImRect::GetCenter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
??0ImRect@@QAE@MMMM@Z PROC				; ImRect::ImRect, COMDAT
; _this$ = ecx

; 650  :     ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	51		 push	 ecx
  0002e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	51		 push	 ecx
  00039	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x1$[ebp]
  0003e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0004b	51		 push	 ecx
  0004c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y2$[ebp]
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	51		 push	 ecx
  00057	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x2$[ebp]
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	83 c1 08	 add	 ecx, 8
  00067	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
??0ImRect@@QAE@MMMM@Z ENDP				; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@ABUImVec4@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??0ImRect@@QAE@ABUImVec4@@@Z PROC			; ImRect::ImRect, COMDAT
; _this$ = ecx

; 649  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00030	51		 push	 ecx
  00031	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  0003e	51		 push	 ecx
  0003f	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00050	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00053	51		 push	 ecx
  00054	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00059	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00061	51		 push	 ecx
  00062	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00067	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	83 c1 08	 add	 ecx, 8
  00072	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00077	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
??0ImRect@@QAE@ABUImVec4@@@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@ABUImVec2@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_min$ = 8						; size = 4
_max$ = 12						; size = 4
??0ImRect@@QAE@ABUImVec2@@0@Z PROC			; ImRect::ImRect, COMDAT
; _this$ = ecx

; 648  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _min$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _max$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0004b	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
??0ImRect@@QAE@ABUImVec2@@0@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImRect@@QAE@XZ PROC					; ImRect::ImRect, COMDAT
; _this$ = ecx

; 647  :     ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)              {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	51		 push	 ecx
  0002e	0f 57 c0	 xorps	 xmm0, xmm0
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	51		 push	 ecx
  00037	0f 57 c0	 xorps	 xmm0, xmm0
  0003a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00047	51		 push	 ecx
  00048	0f 57 c0	 xorps	 xmm0, xmm0
  0004b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00050	51		 push	 ecx
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 08	 add	 ecx, 8
  0005f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
??0ImRect@@QAE@XZ ENDP					; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@M@@YAMMM@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _lhs$[ebp]
  0002d	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _rhs$[ebp]
  00031	72 0f		 jb	 SHORT $LN3@ImMax
  00033	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _lhs$[ebp]
  00038	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
  00040	eb 0d		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  00042	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rhs$[ebp]
  00047	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
$LN4@ImMax:
  0004f	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv65[ebp]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMin@M@@YAMMM@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>, COMDAT

; 314  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rhs$[ebp]
  0002d	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _lhs$[ebp]
  00031	76 0f		 jbe	 SHORT $LN3@ImMin
  00033	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _lhs$[ebp]
  00038	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
  00040	eb 0d		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  00042	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rhs$[ebp]
  00047	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
$LN4@ImMin:
  0004f	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv65[ebp]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImLinearSweep@@YAMMMM@Z
_TEXT	SEGMENT
_current$ = 8						; size = 4
_target$ = 12						; size = 4
_speed$ = 16						; size = 4
?ImLinearSweep@@YAMMMM@Z PROC				; ImLinearSweep, COMDAT

; 337  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _target$[ebp]
  0002d	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _current$[ebp]
  00031	76 25		 jbe	 SHORT $LN2@ImLinearSw
  00033	51		 push	 ecx
  00034	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _target$[ebp]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _current$[ebp]
  00043	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _speed$[ebp]
  00048	51		 push	 ecx
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00053	83 c4 08	 add	 esp, 8
  00056	eb 33		 jmp	 SHORT $LN1@ImLinearSw
$LN2@ImLinearSw:
  00058	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _current$[ebp]
  0005d	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _target$[ebp]
  00061	76 25		 jbe	 SHORT $LN3@ImLinearSw
  00063	51		 push	 ecx
  00064	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _target$[ebp]
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _current$[ebp]
  00073	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _speed$[ebp]
  00078	51		 push	 ecx
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00083	83 c4 08	 add	 esp, 8
  00086	eb 03		 jmp	 SHORT $LN1@ImLinearSw
$LN3@ImLinearSw:
  00088	d9 45 08	 fld	 DWORD PTR _current$[ebp]
$LN1@ImLinearSw:
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00094	3b ec		 cmp	 ebp, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?ImLinearSweep@@YAMMMM@Z ENDP				; ImLinearSweep
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImRotate@@YA?AUImVec2@@ABU1@MM@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
_cos_a$ = 16						; size = 4
_sin_a$ = 20						; size = 4
?ImRotate@@YA?AUImVec2@@ABU1@MM@Z PROC			; ImRotate, COMDAT

; 336  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _sin_a$[ebp]
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  00037	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0003c	f3 0f 59 4d 10	 mulss	 xmm1, DWORD PTR _cos_a$[ebp]
  00041	f3 0f 58 c1	 addss	 xmm0, xmm1
  00045	51		 push	 ecx
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  0004e	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00052	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _cos_a$[ebp]
  00057	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0005a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0005f	f3 0f 59 4d 14	 mulss	 xmm1, DWORD PTR _sin_a$[ebp]
  00064	f3 0f 5c c1	 subss	 xmm0, xmm1
  00068	51		 push	 ecx
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00071	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00076	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?ImRotate@@YA?AUImVec2@@ABU1@MM@Z ENDP			; ImRotate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImFloor@@YAMM@Z
_TEXT	SEGMENT
tv68 = -200						; size = 4
tv67 = -196						; size = 4
_f$ = 8							; size = 4
?ImFloor@@YAMM@Z PROC					; ImFloor, COMDAT

; 332  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 2c 45 08	 cvttss2si eax, DWORD PTR _f$[ebp]
  0002d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  00033	db 85 3c ff ff
	ff		 fild	 DWORD PTR tv67[ebp]
  00039	d9 9d 38 ff ff
	ff		 fstp	 DWORD PTR tv68[ebp]
  0003f	d9 85 38 ff ff
	ff		 fld	 DWORD PTR tv68[ebp]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImLengthSqr@@YAMABUImVec2@@@Z
_TEXT	SEGMENT
tv79 = -196						; size = 4
_lhs$ = 8						; size = 4
?ImLengthSqr@@YAMABUImVec2@@@Z PROC			; ImLengthSqr, COMDAT

; 329  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00032	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  00036	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00039	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0003c	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00041	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00046	f3 0f 58 c1	 addss	 xmm0, xmm1
  0004a	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv79[ebp], xmm0
  00052	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv79[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?ImLengthSqr@@YAMABUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImSaturate@@YAMM@Z
_TEXT	SEGMENT
tv66 = -200						; size = 4
tv67 = -196						; size = 4
_f$ = 8							; size = 4
?ImSaturate@@YAMM@Z PROC				; ImSaturate, COMDAT

; 328  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _f$[ebp]
  0002f	76 0d		 jbe	 SHORT $LN5@ImSaturate
  00031	0f 57 c0	 xorps	 xmm0, xmm0
  00034	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv67[ebp], xmm0
  0003c	eb 3d		 jmp	 SHORT $LN6@ImSaturate
$LN5@ImSaturate:
  0003e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _f$[ebp]
  00043	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0004a	76 12		 jbe	 SHORT $LN3@ImSaturate
  0004c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00054	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
  0005c	eb 0d		 jmp	 SHORT $LN4@ImSaturate
$LN3@ImSaturate:
  0005e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _f$[ebp]
  00063	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
$LN4@ImSaturate:
  0006b	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv66[ebp]
  00073	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv67[ebp], xmm0
$LN6@ImSaturate:
  0007b	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv67[ebp]
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?ImSaturate@@YAMM@Z ENDP				; ImSaturate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImLerp@@YA?AUImVec2@@ABU1@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
_t$ = 20						; size = 4
?ImLerp@@YA?AUImVec2@@ABU1@00@Z PROC			; ImLerp, COMDAT

; 326  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00038	8b 55 14	 mov	 edx, DWORD PTR _t$[ebp]
  0003b	f3 0f 59 42 04	 mulss	 xmm0, DWORD PTR [edx+4]
  00040	8b 45 0c	 mov	 eax, DWORD PTR _a$[ebp]
  00043	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  00048	51		 push	 ecx
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _b$[ebp]
  00051	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]
  00054	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00058	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]
  0005c	8b 45 14	 mov	 eax, DWORD PTR _t$[ebp]
  0005f	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00066	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  0006a	51		 push	 ecx
  0006b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00070	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00073	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00078	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?ImLerp@@YA?AUImVec2@@ABU1@00@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImLerp@@YA?AUImVec2@@ABU1@0M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
_t$ = 20						; size = 4
?ImLerp@@YA?AUImVec2@@ABU1@0M@Z PROC			; ImLerp, COMDAT

; 325  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00038	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _t$[ebp]
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]
  00040	f3 0f 58 42 04	 addss	 xmm0, DWORD PTR [edx+4]
  00045	51		 push	 ecx
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00051	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00055	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00059	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _t$[ebp]
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]
  00061	f3 0f 58 02	 addss	 xmm0, DWORD PTR [edx]
  00065	51		 push	 ecx
  00066	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00073	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?ImLerp@@YA?AUImVec2@@ABU1@0M@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImMax@@YA?AUImVec2@@ABU1@0@Z
_TEXT	SEGMENT
tv78 = -200						; size = 4
tv71 = -196						; size = 4
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
?ImMax@@YA?AUImVec2@@ABU1@0@Z PROC			; ImMax, COMDAT

; 323  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  00037	72 12		 jb	 SHORT $LN3@ImMax
  00039	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003c	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00041	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
  00049	eb 10		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0004b	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  0004e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00053	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
$LN4@ImMax:
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0005e	8b 55 10	 mov	 edx, DWORD PTR _rhs$[ebp]
  00061	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00065	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  00068	72 11		 jb	 SHORT $LN5@ImMax
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0006d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00071	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
  00079	eb 0f		 jmp	 SHORT $LN6@ImMax
$LN5@ImMax:
  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0007e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00082	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
$LN6@ImMax:
  0008a	51		 push	 ecx
  0008b	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv71[ebp]
  00093	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00098	51		 push	 ecx
  00099	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv78[ebp]
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ae	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?ImMax@@YA?AUImVec2@@ABU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImMin@@YA?AUImVec2@@ABU1@0@Z
_TEXT	SEGMENT
tv78 = -200						; size = 4
tv71 = -196						; size = 4
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
?ImMin@@YA?AUImVec2@@ABU1@0@Z PROC			; ImMin, COMDAT

; 322  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  00037	76 12		 jbe	 SHORT $LN3@ImMin
  00039	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003c	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00041	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
  00049	eb 10		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0004b	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  0004e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00053	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
$LN4@ImMin:
  0005b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00061	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00065	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  00068	76 11		 jbe	 SHORT $LN5@ImMin
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0006d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00071	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
  00079	eb 0f		 jmp	 SHORT $LN6@ImMin
$LN5@ImMin:
  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0007e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00082	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
$LN6@ImMin:
  0008a	51		 push	 ecx
  0008b	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv71[ebp]
  00093	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00098	51		 push	 ecx
  00099	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv78[ebp]
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ae	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?ImMin@@YA?AUImVec2@@ABU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImAtof@@YANPBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?ImAtof@@YANPBD@Z PROC					; ImAtof, COMDAT

; 308  : static inline double ImAtof(const char* s)                                      { return atof(s); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atof
  00034	83 c4 04	 add	 esp, 4
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?ImAtof@@YANPBD@Z ENDP					; ImAtof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImAtan2@@YAMMM@Z
_TEXT	SEGMENT
_y$ = 8							; size = 4
_x$ = 12						; size = 4
?ImAtan2@@YAMMM@Z PROC					; ImAtan2, COMDAT

; 307  : static inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	51		 push	 ecx
  00034	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _y$[ebp]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	e8 00 00 00 00	 call	 _atan2f
  00043	83 c4 08	 add	 esp, 8
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?ImAtan2@@YAMMM@Z ENDP					; ImAtan2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImSin@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImSin@@YAMM@Z PROC					; ImSin, COMDAT

; 305  : static inline float  ImSin(float x)                                             { return sinf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _sinf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImSin@@YAMM@Z ENDP					; ImSin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImCos@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImCos@@YAMM@Z PROC					; ImCos, COMDAT

; 304  : static inline float  ImCos(float x)                                             { return cosf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _cosf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImCos@@YAMM@Z ENDP					; ImCos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImFmod@@YAMMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?ImFmod@@YAMMM@Z PROC					; ImFmod, COMDAT

; 302  : static inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	51		 push	 ecx
  00034	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	e8 00 00 00 00	 call	 _fmodf
  00043	83 c4 08	 add	 esp, 8
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?ImFmod@@YAMMM@Z ENDP					; ImFmod
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImPow@@YANNN@Z
_TEXT	SEGMENT
_x$ = 8							; size = 8
_y$ = 16						; size = 8
?ImPow@@YANNN@Z PROC					; ImPow, COMDAT

; 301  : static inline double ImPow(double x, double y)                                  { return pow(x, y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 ec 08	 sub	 esp, 8
  0002b	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _y$[ebp]
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	83 ec 08	 sub	 esp, 8
  00038	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR _x$[ebp]
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	e8 00 00 00 00	 call	 _pow
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?ImPow@@YANNN@Z ENDP					; ImPow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImPow@@YAMMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?ImPow@@YAMMM@Z PROC					; ImPow, COMDAT

; 300  : static inline float  ImPow(float x, float y)                                    { return powf(x, y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	51		 push	 ecx
  00034	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	e8 00 00 00 00	 call	 _powf
  00043	83 c4 08	 add	 esp, 8
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?ImPow@@YAMMM@Z ENDP					; ImPow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImFabs@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImFabs@@YAMM@Z PROC					; ImFabs, COMDAT

; 298  : static inline float  ImFabs(float x)                                            { return fabsf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _fabsf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImFabs@@YAMM@Z ENDP					; ImFabs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??Z@YAAAUImVec2@@AAU0@ABU0@@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??Z@YAAAUImVec2@@AAU0@ABU0@@Z PROC			; operator-=, COMDAT

; 261  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00032	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00036	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00039	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
  0003d	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00043	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00048	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00050	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
  00055	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??Z@YAAAUImVec2@@AAU0@ABU0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??Y@YAAAUImVec2@@AAU0@ABU0@@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??Y@YAAAUImVec2@@AAU0@ABU0@@Z PROC			; operator+=, COMDAT

; 260  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00032	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00036	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00039	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
  0003d	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00043	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00048	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00050	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
  00055	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??Y@YAAAUImVec2@@AAU0@ABU0@@Z ENDP			; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??G@YA?AUImVec2@@ABU0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??G@YA?AUImVec2@@ABU0@0@Z PROC				; operator-, COMDAT

; 257  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00038	51		 push	 ecx
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00041	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00044	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00048	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
??G@YA?AUImVec2@@ABU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??H@YA?AUImVec2@@ABU0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??H@YA?AUImVec2@@ABU0@0@Z PROC				; operator+, COMDAT

; 256  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00038	51		 push	 ecx
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00041	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00044	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00048	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
??H@YA?AUImVec2@@ABU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??D@YA?AUImVec2@@ABU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??D@YA?AUImVec2@@ABU0@M@Z PROC				; operator*, COMDAT

; 254  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00030	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _rhs$[ebp]
  00035	51		 push	 ecx
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0003e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00042	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _rhs$[ebp]
  00047	51		 push	 ecx
  00048	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??D@YA?AUImVec2@@ABU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankW@@YA_NI@Z
_TEXT	SEGMENT
tv67 = -196						; size = 4
_c$ = 8							; size = 4
?ImCharIsBlankW@@YA_NI@Z PROC				; ImCharIsBlankW, COMDAT

; 240  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 08 20	 cmp	 DWORD PTR _c$[ebp], 32	; 00000020H
  0002c	74 1b		 je	 SHORT $LN3@ImCharIsBl
  0002e	83 7d 08 09	 cmp	 DWORD PTR _c$[ebp], 9
  00032	74 15		 je	 SHORT $LN3@ImCharIsBl
  00034	81 7d 08 00 30
	00 00		 cmp	 DWORD PTR _c$[ebp], 12288 ; 00003000H
  0003b	74 0c		 je	 SHORT $LN3@ImCharIsBl
  0003d	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00047	eb 0a		 jmp	 SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
  00049	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
$LN4@ImCharIsBl:
  00053	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv67[ebp]
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?ImCharIsBlankW@@YA_NI@Z ENDP				; ImCharIsBlankW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankA@@YA_ND@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_c$ = 8							; size = 1
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA, COMDAT

; 239  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f be 45 08	 movsx	 eax, BYTE PTR _c$[ebp]
  0002c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0002f	74 15		 je	 SHORT $LN3@ImCharIsBl
  00031	0f be 4d 08	 movsx	 ecx, BYTE PTR _c$[ebp]
  00035	83 f9 09	 cmp	 ecx, 9
  00038	74 0c		 je	 SHORT $LN3@ImCharIsBl
  0003a	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00044	eb 0a		 jmp	 SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
  00046	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
$LN4@ImCharIsBl:
  00050	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatPrecision@@YAHPBDH@Z
_TEXT	SEGMENT
tv94 = -212						; size = 4
_precision$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_fmt$ = 8						; size = 4
_default_precision$ = 12				; size = 4
?ImParseFormatPrecision@@YAHPBDH@Z PROC			; ImParseFormatPrecision, COMDAT

; 2817 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2818 :     fmt = ImParseFormatFindStart(fmt);

  00032	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 08	 mov	 DWORD PTR _fmt$[ebp], eax

; 2819 :     if (fmt[0] != '%')

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	6b c8 00	 imul	 ecx, eax, 0
  00049	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  0004c	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00050	83 f8 25	 cmp	 eax, 37			; 00000025H
  00053	74 08		 je	 SHORT $LN4@ImParseFor

; 2820 :         return default_precision;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _default_precision$[ebp]
  00058	e9 ca 00 00 00	 jmp	 $LN1@ImParseFor
$LN4@ImParseFor:

; 2821 :     fmt++;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00060	83 c0 01	 add	 eax, 1
  00063	89 45 08	 mov	 DWORD PTR _fmt$[ebp], eax
$LN2@ImParseFor:

; 2822 :     while (*fmt >= '0' && *fmt <= '9')

  00066	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00069	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006c	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0006f	7c 16		 jl	 SHORT $LN3@ImParseFor
  00071	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00074	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00077	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0007a	7f 0b		 jg	 SHORT $LN3@ImParseFor

; 2823 :         fmt++;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 08	 mov	 DWORD PTR _fmt$[ebp], eax
  00085	eb df		 jmp	 SHORT $LN2@ImParseFor
$LN3@ImParseFor:

; 2824 :     int precision = INT_MAX;

  00087	c7 45 f4 ff ff
	ff 7f		 mov	 DWORD PTR _precision$[ebp], 2147483647 ; 7fffffffH

; 2825 :     if (*fmt == '.')

  0008e	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00091	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00094	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  00097	75 28		 jne	 SHORT $LN5@ImParseFor

; 2826 :     {
; 2827 :         fmt = ImAtoi<int>(fmt + 1, &precision);

  00099	8d 45 f4	 lea	 eax, DWORD PTR _precision$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  000a0	83 c1 01	 add	 ecx, 1
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ??$ImAtoi@H@@YAPBDPBDPAH@Z ; ImAtoi<int>
  000a9	83 c4 08	 add	 esp, 8
  000ac	89 45 08	 mov	 DWORD PTR _fmt$[ebp], eax

; 2828 :         if (precision < 0 || precision > 99)

  000af	83 7d f4 00	 cmp	 DWORD PTR _precision$[ebp], 0
  000b3	7c 06		 jl	 SHORT $LN7@ImParseFor
  000b5	83 7d f4 63	 cmp	 DWORD PTR _precision$[ebp], 99 ; 00000063H
  000b9	7e 06		 jle	 SHORT $LN5@ImParseFor
$LN7@ImParseFor:

; 2829 :             precision = default_precision;

  000bb	8b 45 0c	 mov	 eax, DWORD PTR _default_precision$[ebp]
  000be	89 45 f4	 mov	 DWORD PTR _precision$[ebp], eax
$LN5@ImParseFor:

; 2830 :     }
; 2831 :     if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation

  000c1	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  000c4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c7	83 f9 65	 cmp	 ecx, 101		; 00000065H
  000ca	74 0b		 je	 SHORT $LN9@ImParseFor
  000cc	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  000cf	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d2	83 f9 45	 cmp	 ecx, 69			; 00000045H
  000d5	75 07		 jne	 SHORT $LN8@ImParseFor
$LN9@ImParseFor:

; 2832 :         precision = -1;

  000d7	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _precision$[ebp], -1
$LN8@ImParseFor:

; 2833 :     if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)

  000de	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  000e1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000e4	83 f9 67	 cmp	 ecx, 103		; 00000067H
  000e7	74 0b		 je	 SHORT $LN11@ImParseFor
  000e9	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  000ec	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ef	83 f9 47	 cmp	 ecx, 71			; 00000047H
  000f2	75 10		 jne	 SHORT $LN10@ImParseFor
$LN11@ImParseFor:
  000f4	81 7d f4 ff ff
	ff 7f		 cmp	 DWORD PTR _precision$[ebp], 2147483647 ; 7fffffffH
  000fb	75 07		 jne	 SHORT $LN10@ImParseFor

; 2834 :         precision = -1;

  000fd	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _precision$[ebp], -1
$LN10@ImParseFor:

; 2835 :     return (precision == INT_MAX) ? default_precision : precision;

  00104	81 7d f4 ff ff
	ff 7f		 cmp	 DWORD PTR _precision$[ebp], 2147483647 ; 7fffffffH
  0010b	75 0b		 jne	 SHORT $LN13@ImParseFor
  0010d	8b 45 0c	 mov	 eax, DWORD PTR _default_precision$[ebp]
  00110	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv94[ebp], eax
  00116	eb 09		 jmp	 SHORT $LN14@ImParseFor
$LN13@ImParseFor:
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _precision$[ebp]
  0011b	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv94[ebp], ecx
$LN14@ImParseFor:
  00121	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv94[ebp]
$LN1@ImParseFor:

; 2836 : }

  00127	52		 push	 edx
  00128	8b cd		 mov	 ecx, ebp
  0012a	50		 push	 eax
  0012b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@ImParseFor
  00131	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00136	58		 pop	 eax
  00137	5a		 pop	 edx
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013e	33 cd		 xor	 ecx, ebp
  00140	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00145	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0014b	3b ec		 cmp	 ebp, esp
  0014d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
  00156	66 90		 npad	 2
$LN17@ImParseFor:
  00158	01 00 00 00	 DD	 1
  0015c	00 00 00 00	 DD	 $LN16@ImParseFor
$LN16@ImParseFor:
  00160	f4 ff ff ff	 DD	 -12			; fffffff4H
  00164	04 00 00 00	 DD	 4
  00168	00 00 00 00	 DD	 $LN15@ImParseFor
$LN15@ImParseFor:
  0016c	70		 DB	 112			; 00000070H
  0016d	72		 DB	 114			; 00000072H
  0016e	65		 DB	 101			; 00000065H
  0016f	63		 DB	 99			; 00000063H
  00170	69		 DB	 105			; 00000069H
  00171	73		 DB	 115			; 00000073H
  00172	69		 DB	 105			; 00000069H
  00173	6f		 DB	 111			; 0000006fH
  00174	6e		 DB	 110			; 0000006eH
  00175	00		 DB	 0
?ImParseFormatPrecision@@YAHPBDH@Z ENDP			; ImParseFormatPrecision
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatTrimDecorations@@YAPBDPBDPADI@Z
_TEXT	SEGMENT
_fmt_end$ = -20						; size = 4
_fmt_start$ = -8					; size = 4
_fmt$ = 8						; size = 4
_buf$ = 12						; size = 4
_buf_size$ = 16						; size = 4
?ImParseFormatTrimDecorations@@YAPBDPBDPADI@Z PROC	; ImParseFormatTrimDecorations, COMDAT

; 2803 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2804 :     const char* fmt_start = ImParseFormatFindStart(fmt);

  00028	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?ImParseFormatFindStart@@YAPBDPBD@Z ; ImParseFormatFindStart
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 f8	 mov	 DWORD PTR _fmt_start$[ebp], eax

; 2805 :     if (fmt_start[0] != '%')

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	6b c8 00	 imul	 ecx, eax, 0
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  00042	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00046	83 f8 25	 cmp	 eax, 37			; 00000025H
  00049	74 05		 je	 SHORT $LN2@ImParseFor

; 2806 :         return fmt;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  0004e	eb 51		 jmp	 SHORT $LN1@ImParseFor
$LN2@ImParseFor:

; 2807 :     const char* fmt_end = ImParseFormatFindEnd(fmt_start);

  00050	8b 45 f8	 mov	 eax, DWORD PTR _fmt_start$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?ImParseFormatFindEnd@@YAPBDPBD@Z ; ImParseFormatFindEnd
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 ec	 mov	 DWORD PTR _fmt_end$[ebp], eax

; 2808 :     if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	6b c8 00	 imul	 ecx, eax, 0
  00067	8b 55 ec	 mov	 edx, DWORD PTR _fmt_end$[ebp]
  0006a	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0006e	85 c0		 test	 eax, eax
  00070	75 05		 jne	 SHORT $LN3@ImParseFor

; 2809 :         return fmt_start;

  00072	8b 45 f8	 mov	 eax, DWORD PTR _fmt_start$[ebp]
  00075	eb 2a		 jmp	 SHORT $LN1@ImParseFor
$LN3@ImParseFor:

; 2810 :     ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));

  00077	8b 45 10	 mov	 eax, DWORD PTR _buf_size$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _fmt_end$[ebp]
  0007e	2b 4d f8	 sub	 ecx, DWORD PTR _fmt_start$[ebp]
  00081	83 c1 01	 add	 ecx, 1
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 ??$ImMin@I@@YAIII@Z	; ImMin<unsigned int>
  0008a	83 c4 08	 add	 esp, 8
  0008d	50		 push	 eax
  0008e	8b 55 f8	 mov	 edx, DWORD PTR _fmt_start$[ebp]
  00091	52		 push	 edx
  00092	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?ImStrncpy@@YAXPADPBDI@Z ; ImStrncpy
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2811 :     return buf;

  0009e	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
$LN1@ImParseFor:

; 2812 : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000aa	3b ec		 cmp	 ebp, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?ImParseFormatTrimDecorations@@YAPBDPBDPADI@Z ENDP	; ImParseFormatTrimDecorations
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatFindEnd@@YAPBDPBD@Z
_TEXT	SEGMENT
_c$1 = -29						; size = 1
_ignored_lowercase_mask$ = -20				; size = 4
_ignored_uppercase_mask$ = -8				; size = 4
_fmt$ = 8						; size = 4
?ImParseFormatFindEnd@@YAPBDPBD@Z PROC			; ImParseFormatFindEnd, COMDAT

; 2781 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2782 :     // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
; 2783 :     if (fmt[0] != '%')

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  00033	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00037	83 f8 25	 cmp	 eax, 37			; 00000025H
  0003a	74 08		 je	 SHORT $LN5@ImParseFor

; 2784 :         return fmt;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  0003f	e9 8c 00 00 00	 jmp	 $LN1@ImParseFor
$LN5@ImParseFor:

; 2785 :     const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));

  00044	c7 45 f8 00 09
	00 00		 mov	 DWORD PTR _ignored_uppercase_mask$[ebp], 2304 ; 00000900H

; 2786 :     const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));

  0004b	c7 45 ec 80 0a
	48 02		 mov	 DWORD PTR _ignored_lowercase_mask$[ebp], 38275712 ; 02480a80H

; 2787 :     for (char c; (c = *fmt) != 0; fmt++)

  00052	eb 09		 jmp	 SHORT $LN4@ImParseFor
$LN2@ImParseFor:
  00054	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 08	 mov	 DWORD PTR _fmt$[ebp], eax
$LN4@ImParseFor:
  0005d	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	88 4d e3	 mov	 BYTE PTR _c$1[ebp], cl
  00065	0f be 55 e3	 movsx	 edx, BYTE PTR _c$1[ebp]
  00069	85 d2		 test	 edx, edx
  0006b	74 60		 je	 SHORT $LN3@ImParseFor

; 2788 :     {
; 2789 :         if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)

  0006d	0f be 45 e3	 movsx	 eax, BYTE PTR _c$1[ebp]
  00071	83 f8 41	 cmp	 eax, 65			; 00000041H
  00074	7c 26		 jl	 SHORT $LN6@ImParseFor
  00076	0f be 45 e3	 movsx	 eax, BYTE PTR _c$1[ebp]
  0007a	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  0007d	7f 1d		 jg	 SHORT $LN6@ImParseFor
  0007f	0f be 4d e3	 movsx	 ecx, BYTE PTR _c$1[ebp]
  00083	83 e9 41	 sub	 ecx, 65			; 00000041H
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	d3 e0		 shl	 eax, cl
  0008d	25 00 09 00 00	 and	 eax, 2304		; 00000900H
  00092	75 08		 jne	 SHORT $LN6@ImParseFor

; 2790 :             return fmt + 1;

  00094	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00097	83 c0 01	 add	 eax, 1
  0009a	eb 34		 jmp	 SHORT $LN1@ImParseFor
$LN6@ImParseFor:

; 2791 :         if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)

  0009c	0f be 45 e3	 movsx	 eax, BYTE PTR _c$1[ebp]
  000a0	83 f8 61	 cmp	 eax, 97			; 00000061H
  000a3	7c 26		 jl	 SHORT $LN7@ImParseFor
  000a5	0f be 45 e3	 movsx	 eax, BYTE PTR _c$1[ebp]
  000a9	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  000ac	7f 1d		 jg	 SHORT $LN7@ImParseFor
  000ae	0f be 4d e3	 movsx	 ecx, BYTE PTR _c$1[ebp]
  000b2	83 e9 61	 sub	 ecx, 97			; 00000061H
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	d3 e0		 shl	 eax, cl
  000bc	25 80 0a 48 02	 and	 eax, 38275712		; 02480a80H
  000c1	75 08		 jne	 SHORT $LN7@ImParseFor

; 2792 :             return fmt + 1;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  000c6	83 c0 01	 add	 eax, 1
  000c9	eb 05		 jmp	 SHORT $LN1@ImParseFor
$LN7@ImParseFor:

; 2793 :     }

  000cb	eb 87		 jmp	 SHORT $LN2@ImParseFor
$LN3@ImParseFor:

; 2794 :     return fmt;

  000cd	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
$LN1@ImParseFor:

; 2795 : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000d9	3b ec		 cmp	 ebp, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
?ImParseFormatFindEnd@@YAPBDPBD@Z ENDP			; ImParseFormatFindEnd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatFindStart@@YAPBDPBD@Z
_TEXT	SEGMENT
_c$1 = -5						; size = 1
_fmt$ = 8						; size = 4
?ImParseFormatFindStart@@YAPBDPBD@Z PROC		; ImParseFormatFindStart, COMDAT

; 2768 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@ImParseFor:

; 2769 :     while (char c = fmt[0])

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  00033	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  00036	88 45 fb	 mov	 BYTE PTR _c$1[ebp], al
  00039	0f be 45 fb	 movsx	 eax, BYTE PTR _c$1[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	74 41		 je	 SHORT $LN3@ImParseFor

; 2770 :     {
; 2771 :         if (c == '%' && fmt[1] != '%')

  00041	0f be 45 fb	 movsx	 eax, BYTE PTR _c$1[ebp]
  00045	83 f8 25	 cmp	 eax, 37			; 00000025H
  00048	75 1b		 jne	 SHORT $LN4@ImParseFor
  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	c1 e0 00	 shl	 eax, 0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00055	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  00059	83 fa 25	 cmp	 edx, 37			; 00000025H
  0005c	74 07		 je	 SHORT $LN4@ImParseFor

; 2772 :             return fmt;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00061	eb 22		 jmp	 SHORT $LN1@ImParseFor
  00063	eb 12		 jmp	 SHORT $LN5@ImParseFor
$LN4@ImParseFor:

; 2773 :         else if (c == '%')

  00065	0f be 45 fb	 movsx	 eax, BYTE PTR _c$1[ebp]
  00069	83 f8 25	 cmp	 eax, 37			; 00000025H
  0006c	75 09		 jne	 SHORT $LN5@ImParseFor

; 2774 :             fmt++;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 08	 mov	 DWORD PTR _fmt$[ebp], eax
$LN5@ImParseFor:

; 2775 :         fmt++;

  00077	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  0007a	83 c0 01	 add	 eax, 1
  0007d	89 45 08	 mov	 DWORD PTR _fmt$[ebp], eax

; 2776 :     }

  00080	eb a6		 jmp	 SHORT $LN2@ImParseFor
$LN3@ImParseFor:

; 2777 :     return fmt;

  00082	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
$LN1@ImParseFor:

; 2778 : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?ImParseFormatFindStart@@YAPBDPBD@Z ENDP		; ImParseFormatFindStart
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImIsPowerOfTwo@@YA_NH@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_v$ = 8							; size = 4
?ImIsPowerOfTwo@@YA_NH@Z PROC				; ImIsPowerOfTwo, COMDAT

; 217  : static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 08 00	 cmp	 DWORD PTR _v$[ebp], 0
  0002c	74 17		 je	 SHORT $LN3@ImIsPowerO
  0002e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00031	83 e8 01	 sub	 eax, 1
  00034	23 45 08	 and	 eax, DWORD PTR _v$[ebp]
  00037	75 0c		 jne	 SHORT $LN3@ImIsPowerO
  00039	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
  00043	eb 0a		 jmp	 SHORT $LN4@ImIsPowerO
$LN3@ImIsPowerO:
  00045	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN4@ImIsPowerO:
  0004f	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?ImIsPowerOfTwo@@YA_NH@Z ENDP				; ImIsPowerOfTwo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 749  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 750  :             return (float)sin(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sin
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 751  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _powf
_TEXT	SEGMENT
tv75 = -196						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_powf	PROC						; COMDAT

; 744  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 745  :             return (float)pow(_X, _Y);

  00028	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR __Y$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0003a	83 ec 08	 sub	 esp, 8
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	e8 00 00 00 00	 call	 _pow
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv75[ebp]
  00050	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv75[ebp]

; 746  :         }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_powf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
tv75 = -196						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 690  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 691  :             return (float)fmod(_X, _Y);

  00028	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR __Y$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0003a	83 ec 08	 sub	 esp, 8
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	e8 00 00 00 00	 call	 _fmod
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv75[ebp]
  00050	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv75[ebp]

; 692  :         }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 671  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 672  :             return (float)fabs(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _fabs
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 673  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 648  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 649  :             return (float)cos(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _cos
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 650  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _atan2f
_TEXT	SEGMENT
tv75 = -196						; size = 4
__Y$ = 8						; size = 4
__X$ = 12						; size = 4
_atan2f	PROC						; COMDAT

; 633  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 634  :             return (float)atan2(_Y, _X);

  00028	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __Y$[ebp]
  0003a	83 ec 08	 sub	 esp, 8
  0003d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00042	e8 00 00 00 00	 call	 _atan2
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv75[ebp]
  00050	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv75[ebp]

; 635  :         }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_atan2f	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __9FF75F13_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);

  00028	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0002b	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 __vsscanf_l
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2275 :         __crt_va_end(_ArgList);

  00047	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 2276 :         return _Result;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2277 :     }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2175 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __9FF75F13_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2176 :         return __stdio_common_vsscanf(

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00035	52		 push	 edx
  00036	6a ff		 push	 -1
  00038	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00041	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00044	51		 push	 ecx
  00045	8b 10		 mov	 edx, DWORD PTR [eax]
  00047	52		 push	 edx
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsscanf
  0004e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2177 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2178 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2179 :     }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 96   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1850469A_corecrt_stdio_config@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

  00028	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?GetCharAdvance@ImFont@@QBEMG@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
_c$ = 8							; size = 2
?GetCharAdvance@ImFont@@QBEMG@Z PROC			; ImFont::GetCharAdvance, COMDAT
; _this$ = ecx

; 2226 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	0f b7 45 08	 movzx	 eax, WORD PTR _c$[ebp]
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00036	7d 1b		 jge	 SHORT $LN3@GetCharAdv
  00038	0f b7 55 08	 movzx	 edx, WORD PTR _c$[ebp]
  0003c	52		 push	 edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QBEABMH@Z ; ImVector<float>::operator[]
  00045	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00049	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
  00051	eb 10		 jmp	 SHORT $LN4@GetCharAdv
$LN3@GetCharAdv:
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0005b	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
$LN4@GetCharAdv:
  00063	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv74[ebp]
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
?GetCharAdvance@ImFont@@QBEMG@Z ENDP			; ImFont::GetCharAdvance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImFontGlyph@@@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@UImFontGlyph@@@@QBE_NXZ PROC		; ImVector<ImFontGlyph>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@UImFontGlyph@@@@QBE_NXZ ENDP		; ImVector<ImFontGlyph>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QBEABMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@M@@QBEABMH@Z PROC				; ImVector<float>::operator[], COMDAT
; _this$ = ecx

; 1273 :     inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f9 04 00 00	 push	 1273			; 000004f9H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@M@@QBEABMH@Z ENDP				; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@M@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@M@@QBE_NXZ PROC			; ImVector<float>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@M@@QBE_NXZ ENDP			; ImVector<float>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@I@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?pop_back@?$ImVector@I@@QAEXXZ PROC			; ImVector<unsigned int>::pop_back, COMDAT
; _this$ = ecx

; 1294 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@pop_back
  00035	8b f4		 mov	 esi, esp
  00037	68 0e 05 00 00	 push	 1294			; 0000050eH
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@pop_back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	89 0a		 mov	 DWORD PTR [edx], ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?pop_back@?$ImVector@I@@QAEXXZ ENDP			; ImVector<unsigned int>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@I@@QAEXABI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@I@@QAEXABI@Z PROC			; ImVector<unsigned int>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@I@@QBEHH@Z ; ImVector<unsigned int>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@I@@QAEXH@Z ; ImVector<unsigned int>::reserve
$LN2@push_back:
  00054	6a 04		 push	 4
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@I@@QAEXABI@Z ENDP			; ImVector<unsigned int>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@I@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@I@@QAEXH@Z PROC			; ImVector<unsigned int>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 02	 shl	 eax, 2
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 02	 shl	 ecx, 2
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@I@@QAEXH@Z ENDP			; ImVector<unsigned int>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@I@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@I@@QBEHH@Z PROC		; ImVector<unsigned int>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@I@@QBEHH@Z ENDP		; ImVector<unsigned int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@I@@QAEAAIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@I@@QAEAAIXZ PROC			; ImVector<unsigned int>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00061	8d 44 88 fc	 lea	 eax, DWORD PTR [eax+ecx*4-4]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?back@?$ImVector@I@@QAEAAIXZ ENDP			; ImVector<unsigned int>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
_uv$ = 12						; size = 4
_col$ = 16						; size = 4
?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z PROC		; ImDrawList::PrimVtx, COMDAT
; _this$ = ecx

; 1988 :     inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  00034	51		 push	 ecx
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?PrimWriteIdx@ImDrawList@@QAEXG@Z ; ImDrawList::PrimWriteIdx
  0003d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _uv$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _pos$[ebp]
  00048	52		 push	 edx
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ENDP		; ImDrawList::PrimVtx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PrimWriteIdx@ImDrawList@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_idx$ = 8						; size = 2
?PrimWriteIdx@ImDrawList@@QAEXG@Z PROC			; ImDrawList::PrimWriteIdx, COMDAT
; _this$ = ecx

; 1987 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00033	66 8b 55 08	 mov	 dx, WORD PTR _idx$[ebp]
  00037	66 89 11	 mov	 WORD PTR [ecx], dx
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00040	83 c1 02	 add	 ecx, 2
  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?PrimWriteIdx@ImDrawList@@QAEXG@Z ENDP			; ImDrawList::PrimWriteIdx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
_uv$ = 12						; size = 4
_col$ = 16						; size = 4
?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z PROC	; ImDrawList::PrimWriteVtx, COMDAT
; _this$ = ecx

; 1986 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0003b	89 08		 mov	 DWORD PTR [eax], ecx
  0003d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00040	8b 45 0c	 mov	 eax, DWORD PTR _uv$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0004e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00051	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005a	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  0005d	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00066	83 c1 14	 add	 ecx, 20			; 00000014H
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00075	83 c1 01	 add	 ecx, 1
  00078	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 0c 00	 ret	 12			; 0000000cH
?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ENDP	; ImDrawList::PrimWriteVtx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?ChannelsSetCurrent@ImDrawList@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_n$ = 8							; size = 4
?ChannelsSetCurrent@ImDrawList@@QAEXH@Z PROC		; ImDrawList::ChannelsSetCurrent, COMDAT
; _this$ = ecx

; 1975 :     inline void     ChannelsSetCurrent(int n)   { _Splitter.SetCurrentChannel(this, n); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	51		 push	 ecx
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 64	 add	 ecx, 100		; 00000064H
  0003b	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?ChannelsSetCurrent@ImDrawList@@QAEXH@Z ENDP		; ImDrawList::ChannelsSetCurrent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?ChannelsMerge@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ChannelsMerge@ImDrawList@@QAEXXZ PROC			; ImDrawList::ChannelsMerge, COMDAT
; _this$ = ecx

; 1974 :     inline void     ChannelsMerge()             { _Splitter.Merge(this); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 64	 add	 ecx, 100		; 00000064H
  00037	e8 00 00 00 00	 call	 ?Merge@ImDrawListSplitter@@QAEXPAUImDrawList@@@Z ; ImDrawListSplitter::Merge
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?ChannelsMerge@ImDrawList@@QAEXXZ ENDP			; ImDrawList::ChannelsMerge
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?ChannelsSplit@ImDrawList@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_count$ = 8						; size = 4
?ChannelsSplit@ImDrawList@@QAEXH@Z PROC			; ImDrawList::ChannelsSplit, COMDAT
; _this$ = ecx

; 1973 :     inline void     ChannelsSplit(int count)    { _Splitter.Split(this, count); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _count$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	51		 push	 ecx
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 64	 add	 ecx, 100		; 00000064H
  0003b	e8 00 00 00 00	 call	 ?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z ; ImDrawListSplitter::Split
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?ChannelsSplit@ImDrawList@@QAEXH@Z ENDP			; ImDrawList::ChannelsSplit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QAEXI_NM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_col$ = 8						; size = 4
_closed$ = 12						; size = 1
_thickness$ = 16					; size = 4
?PathStroke@ImDrawList@@QAEXI_NM@Z PROC			; ImDrawList::PathStroke, COMDAT
; _this$ = ecx

; 1959 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	51		 push	 ecx
  0002e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	0f b6 45 0c	 movzx	 eax, BYTE PTR _closed$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _col$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00047	50		 push	 eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0004e	52		 push	 edx
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM@Z ; ImDrawList::AddPolyline
  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 0c 00	 ret	 12			; 0000000cH
?PathStroke@ImDrawList@@QAEXI_NM@Z ENDP			; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PathFillConvex@ImDrawList@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_col$ = 8						; size = 4
?PathFillConvex@ImDrawList@@QAEXI@Z PROC		; ImDrawList::PathFillConvex, COMDAT
; _this$ = ecx

; 1958 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _col$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00037	52		 push	 edx
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0003e	51		 push	 ecx
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?PathFillConvex@ImDrawList@@QAEXI@Z ENDP		; ImDrawList::PathFillConvex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z PROC		; ImDrawList::PathLineTo, COMDAT
; _this$ = ecx

; 1956 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 58	 add	 ecx, 88			; 00000058H
  00037	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ENDP		; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z PROC	; ImVector<ImVec2>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z ; ImVector<ImVec2>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ; ImVector<ImVec2>::reserve
$LN2@push_back:
  00054	6a 08		 push	 8
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ENDP	; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 03	 shl	 eax, 3
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 03	 shl	 ecx, 3
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1ImGuiListClipper@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ImGuiListClipper@@QAE@XZ PROC			; ImGuiListClipper::~ImGuiListClipper, COMDAT
; _this$ = ecx

; 1733 :     ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ImGuiListClipper@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 ff	 cmp	 DWORD PTR [eax+8], -1
  00053	74 21		 je	 SHORT $LN2@ImGuiListC
  00055	8b f4		 mov	 esi, esp
  00057	68 c5 06 00 00	 push	 1733			; 000006c5H
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@IHACEFEE@?$AAI?$AAt?$AAe?$AAm?$AAs?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9@
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@ImGuiListC:
  00076	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00080	59		 pop	 ecx
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
  00095	cc		 int	 3
  00096	cc		 int	 3
  00097	cc		 int	 3
  00098	cc		 int	 3
  00099	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiListClipper@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ImGuiListClipper@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ImGuiListClipper@@QAE@XZ ENDP			; ImGuiListClipper::~ImGuiListClipper
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImGuiListClipper@@QAE@HM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_items_count$ = 8					; size = 4
_items_height$ = 12					; size = 4
??0ImGuiListClipper@@QAE@HM@Z PROC			; ImGuiListClipper::ImGuiListClipper, COMDAT
; _this$ = ecx

; 1732 :     ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	51		 push	 ecx
  0002e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _items_height$[ebp]
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	8b 45 08	 mov	 eax, DWORD PTR _items_count$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Begin@ImGuiListClipper@@QAEXHM@Z ; ImGuiListClipper::Begin
  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
??0ImGuiListClipper@@QAE@HM@Z ENDP			; ImGuiListClipper::ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?size@ImGuiTextBuffer@@QBEHXZ
_TEXT	SEGMENT
tv70 = -208						; size = 4
_this$ = -8						; size = 4
?size@ImGuiTextBuffer@@QBEHXZ PROC			; ImGuiTextBuffer::size, COMDAT
; _this$ = ecx

; 1649 :     int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	74 10		 je	 SHORT $LN3@size
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	83 ea 01	 sub	 edx, 1
  0003d	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
  00043	eb 0a		 jmp	 SHORT $LN4@size
$LN3@size:
  00045	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN4@size:
  0004f	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?size@ImGuiTextBuffer@@QBEHXZ ENDP			; ImGuiTextBuffer::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImGuiTextBuffer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImGuiTextBuffer@@QAE@XZ PROC				; ImGuiTextBuffer::ImGuiTextBuffer, COMDAT
; _this$ = ecx

; 1645 :     ImGuiTextBuffer()   { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$ImVector@D@@QAE@XZ	; ImVector<char>::ImVector<char>
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??0ImGuiTextBuffer@@QAE@XZ ENDP				; ImGuiTextBuffer::ImGuiTextBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@D@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@D@@QAEXH@Z PROC			; ImVector<char>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 52		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00043	83 c4 04	 add	 esp, 4
  00046	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00050	74 28		 je	 SHORT $LN3@reserve
  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	51		 push	 ecx
  00058	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	50		 push	 eax
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _memcpy
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00077	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00080	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00083	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00089	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
?reserve@?$ImVector@D@@QAEXH@Z ENDP			; ImVector<char>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@D@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@D@@QAEXH@Z PROC			; ImVector<char>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@D@@QBEHH@Z ; ImVector<char>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@D@@QAEXH@Z ; ImVector<char>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@D@@QAEXH@Z ENDP			; ImVector<char>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@D@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@D@@QBEHH@Z PROC		; ImVector<char>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@D@@QBEHH@Z ENDP		; ImVector<char>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@D@@QAE@XZ PROC				; ImVector<char>::ImVector<char>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@D@@QAE@XZ ENDP				; ImVector<char>::ImVector<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat4@ImGui@@YA_NPBDQAMHH@Z
_TEXT	SEGMENT
_format$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_decimal_precision$ = 16				; size = 4
_flags$ = 20						; size = 4
?InputFloat4@ImGui@@YA_NPBDQAMHH@Z PROC			; ImGui::InputFloat4, COMDAT

; 3032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3033 :     char format[16] = "%f";

  00032	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02NJPGOMH@?$CFf@
  00038	66 89 45 e8	 mov	 WORD PTR _format$[ebp], ax
  0003c	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ??_C@_02NJPGOMH@?$CFf@+2
  00042	88 4d ea	 mov	 BYTE PTR _format$[ebp+2], cl
  00045	33 c0		 xor	 eax, eax
  00047	89 45 eb	 mov	 DWORD PTR _format$[ebp+3], eax
  0004a	89 45 ef	 mov	 DWORD PTR _format$[ebp+7], eax
  0004d	89 45 f3	 mov	 DWORD PTR _format$[ebp+11], eax
  00050	88 45 f7	 mov	 BYTE PTR _format$[ebp+15], al

; 3034 :     if (decimal_precision >= 0)

  00053	83 7d 10 00	 cmp	 DWORD PTR _decimal_precision$[ebp], 0
  00057	7c 17		 jl	 SHORT $LN2@InputFloat

; 3035 :         ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);

  00059	8b 45 10	 mov	 eax, DWORD PTR _decimal_precision$[ebp]
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
  00062	6a 10		 push	 16			; 00000010H
  00064	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@InputFloat:

; 3036 :     return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);

  00070	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00073	50		 push	 eax
  00074	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00077	51		 push	 ecx
  00078	6a 00		 push	 0
  0007a	6a 00		 push	 0
  0007c	6a 04		 push	 4
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00081	52		 push	 edx
  00082	6a 08		 push	 8
  00084	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  0008d	83 c4 20	 add	 esp, 32			; 00000020H

; 3037 : }

  00090	52		 push	 edx
  00091	8b cd		 mov	 ecx, ebp
  00093	50		 push	 eax
  00094	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@InputFloat
  0009a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009f	58		 pop	 eax
  000a0	5a		 pop	 edx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a7	33 cd		 xor	 ecx, ebp
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
  000bf	90		 npad	 1
$LN6@InputFloat:
  000c0	01 00 00 00	 DD	 1
  000c4	00 00 00 00	 DD	 $LN5@InputFloat
$LN5@InputFloat:
  000c8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000cc	10 00 00 00	 DD	 16			; 00000010H
  000d0	00 00 00 00	 DD	 $LN4@InputFloat
$LN4@InputFloat:
  000d4	66		 DB	 102			; 00000066H
  000d5	6f		 DB	 111			; 0000006fH
  000d6	72		 DB	 114			; 00000072H
  000d7	6d		 DB	 109			; 0000006dH
  000d8	61		 DB	 97			; 00000061H
  000d9	74		 DB	 116			; 00000074H
  000da	00		 DB	 0
?InputFloat4@ImGui@@YA_NPBDQAMHH@Z ENDP			; ImGui::InputFloat4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat3@ImGui@@YA_NPBDQAMHH@Z
_TEXT	SEGMENT
_format$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_decimal_precision$ = 16				; size = 4
_flags$ = 20						; size = 4
?InputFloat3@ImGui@@YA_NPBDQAMHH@Z PROC			; ImGui::InputFloat3, COMDAT

; 3024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3025 :     char format[16] = "%f";

  00032	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02NJPGOMH@?$CFf@
  00038	66 89 45 e8	 mov	 WORD PTR _format$[ebp], ax
  0003c	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ??_C@_02NJPGOMH@?$CFf@+2
  00042	88 4d ea	 mov	 BYTE PTR _format$[ebp+2], cl
  00045	33 c0		 xor	 eax, eax
  00047	89 45 eb	 mov	 DWORD PTR _format$[ebp+3], eax
  0004a	89 45 ef	 mov	 DWORD PTR _format$[ebp+7], eax
  0004d	89 45 f3	 mov	 DWORD PTR _format$[ebp+11], eax
  00050	88 45 f7	 mov	 BYTE PTR _format$[ebp+15], al

; 3026 :     if (decimal_precision >= 0)

  00053	83 7d 10 00	 cmp	 DWORD PTR _decimal_precision$[ebp], 0
  00057	7c 17		 jl	 SHORT $LN2@InputFloat

; 3027 :         ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);

  00059	8b 45 10	 mov	 eax, DWORD PTR _decimal_precision$[ebp]
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
  00062	6a 10		 push	 16			; 00000010H
  00064	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@InputFloat:

; 3028 :     return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);

  00070	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00073	50		 push	 eax
  00074	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00077	51		 push	 ecx
  00078	6a 00		 push	 0
  0007a	6a 00		 push	 0
  0007c	6a 03		 push	 3
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00081	52		 push	 edx
  00082	6a 08		 push	 8
  00084	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  0008d	83 c4 20	 add	 esp, 32			; 00000020H

; 3029 : }

  00090	52		 push	 edx
  00091	8b cd		 mov	 ecx, ebp
  00093	50		 push	 eax
  00094	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@InputFloat
  0009a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009f	58		 pop	 eax
  000a0	5a		 pop	 edx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a7	33 cd		 xor	 ecx, ebp
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
  000bf	90		 npad	 1
$LN6@InputFloat:
  000c0	01 00 00 00	 DD	 1
  000c4	00 00 00 00	 DD	 $LN5@InputFloat
$LN5@InputFloat:
  000c8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000cc	10 00 00 00	 DD	 16			; 00000010H
  000d0	00 00 00 00	 DD	 $LN4@InputFloat
$LN4@InputFloat:
  000d4	66		 DB	 102			; 00000066H
  000d5	6f		 DB	 111			; 0000006fH
  000d6	72		 DB	 114			; 00000072H
  000d7	6d		 DB	 109			; 0000006dH
  000d8	61		 DB	 97			; 00000061H
  000d9	74		 DB	 116			; 00000074H
  000da	00		 DB	 0
?InputFloat3@ImGui@@YA_NPBDQAMHH@Z ENDP			; ImGui::InputFloat3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat2@ImGui@@YA_NPBDQAMHH@Z
_TEXT	SEGMENT
_format$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_decimal_precision$ = 16				; size = 4
_flags$ = 20						; size = 4
?InputFloat2@ImGui@@YA_NPBDQAMHH@Z PROC			; ImGui::InputFloat2, COMDAT

; 3016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3017 :     char format[16] = "%f";

  00032	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02NJPGOMH@?$CFf@
  00038	66 89 45 e8	 mov	 WORD PTR _format$[ebp], ax
  0003c	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ??_C@_02NJPGOMH@?$CFf@+2
  00042	88 4d ea	 mov	 BYTE PTR _format$[ebp+2], cl
  00045	33 c0		 xor	 eax, eax
  00047	89 45 eb	 mov	 DWORD PTR _format$[ebp+3], eax
  0004a	89 45 ef	 mov	 DWORD PTR _format$[ebp+7], eax
  0004d	89 45 f3	 mov	 DWORD PTR _format$[ebp+11], eax
  00050	88 45 f7	 mov	 BYTE PTR _format$[ebp+15], al

; 3018 :     if (decimal_precision >= 0)

  00053	83 7d 10 00	 cmp	 DWORD PTR _decimal_precision$[ebp], 0
  00057	7c 17		 jl	 SHORT $LN2@InputFloat

; 3019 :         ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);

  00059	8b 45 10	 mov	 eax, DWORD PTR _decimal_precision$[ebp]
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
  00062	6a 10		 push	 16			; 00000010H
  00064	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@InputFloat:

; 3020 :     return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);

  00070	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  00073	50		 push	 eax
  00074	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00077	51		 push	 ecx
  00078	6a 00		 push	 0
  0007a	6a 00		 push	 0
  0007c	6a 02		 push	 2
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00081	52		 push	 edx
  00082	6a 08		 push	 8
  00084	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  0008d	83 c4 20	 add	 esp, 32			; 00000020H

; 3021 : }

  00090	52		 push	 edx
  00091	8b cd		 mov	 ecx, ebp
  00093	50		 push	 eax
  00094	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@InputFloat
  0009a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009f	58		 pop	 eax
  000a0	5a		 pop	 edx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a7	33 cd		 xor	 ecx, ebp
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
  000bf	90		 npad	 1
$LN6@InputFloat:
  000c0	01 00 00 00	 DD	 1
  000c4	00 00 00 00	 DD	 $LN5@InputFloat
$LN5@InputFloat:
  000c8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000cc	10 00 00 00	 DD	 16			; 00000010H
  000d0	00 00 00 00	 DD	 $LN4@InputFloat
$LN4@InputFloat:
  000d4	66		 DB	 102			; 00000066H
  000d5	6f		 DB	 111			; 0000006fH
  000d6	72		 DB	 114			; 00000072H
  000d7	6d		 DB	 109			; 0000006dH
  000d8	61		 DB	 97			; 00000061H
  000d9	74		 DB	 116			; 00000074H
  000da	00		 DB	 0
?InputFloat2@ImGui@@YA_NPBDQAMHH@Z ENDP			; ImGui::InputFloat2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z
_TEXT	SEGMENT
_format$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_step$ = 16						; size = 4
_step_fast$ = 20					; size = 4
_decimal_precision$ = 24				; size = 4
_flags$ = 28						; size = 4
?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z PROC		; ImGui::InputFloat, COMDAT

; 3008 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3009 :     char format[16] = "%f";

  00032	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02NJPGOMH@?$CFf@
  00038	66 89 45 e8	 mov	 WORD PTR _format$[ebp], ax
  0003c	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ??_C@_02NJPGOMH@?$CFf@+2
  00042	88 4d ea	 mov	 BYTE PTR _format$[ebp+2], cl
  00045	33 c0		 xor	 eax, eax
  00047	89 45 eb	 mov	 DWORD PTR _format$[ebp+3], eax
  0004a	89 45 ef	 mov	 DWORD PTR _format$[ebp+7], eax
  0004d	89 45 f3	 mov	 DWORD PTR _format$[ebp+11], eax
  00050	88 45 f7	 mov	 BYTE PTR _format$[ebp+15], al

; 3010 :     if (decimal_precision >= 0)

  00053	83 7d 18 00	 cmp	 DWORD PTR _decimal_precision$[ebp], 0
  00057	7c 17		 jl	 SHORT $LN2@InputFloat

; 3011 :         ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);

  00059	8b 45 18	 mov	 eax, DWORD PTR _decimal_precision$[ebp]
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_06DNBDMDIL@?$CF?$CF?4?$CFdf@
  00062	6a 10		 push	 16			; 00000010H
  00064	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@InputFloat:

; 3012 :     return InputFloat(label, v, step, step_fast, format, flags);

  00070	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  00073	50		 push	 eax
  00074	8d 4d e8	 lea	 ecx, DWORD PTR _format$[ebp]
  00077	51		 push	 ecx
  00078	51		 push	 ecx
  00079	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _step_fast$[ebp]
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	51		 push	 ecx
  00084	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _step$[ebp]
  00089	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008e	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00091	52		 push	 edx
  00092	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?InputFloat@ImGui@@YA_NPBDPAMMM0H@Z ; ImGui::InputFloat
  0009b	83 c4 18	 add	 esp, 24			; 00000018H

; 3013 : }

  0009e	52		 push	 edx
  0009f	8b cd		 mov	 ecx, ebp
  000a1	50		 push	 eax
  000a2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@InputFloat
  000a8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ad	58		 pop	 eax
  000ae	5a		 pop	 edx
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000c2	3b ec		 cmp	 ebp, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
  000cd	0f 1f 00	 npad	 3
$LN6@InputFloat:
  000d0	01 00 00 00	 DD	 1
  000d4	00 00 00 00	 DD	 $LN5@InputFloat
$LN5@InputFloat:
  000d8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000dc	10 00 00 00	 DD	 16			; 00000010H
  000e0	00 00 00 00	 DD	 $LN4@InputFloat
$LN4@InputFloat:
  000e4	66		 DB	 102			; 00000066H
  000e5	6f		 DB	 111			; 0000006fH
  000e6	72		 DB	 114			; 00000072H
  000e7	6d		 DB	 109			; 0000006dH
  000e8	61		 DB	 97			; 00000061H
  000e9	74		 DB	 116			; 00000074H
  000ea	00		 DB	 0
?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z ENDP		; ImGui::InputFloat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z
_TEXT	SEGMENT
tv72 = -268						; size = 4
tv67 = -265						; size = 1
_new_buf_size$1 = -68					; size = 4
_edit_state$2 = -56					; size = 4
_g$3 = -44						; size = 4
_new_text_len$ = -32					; size = 4
_is_resizable$ = -17					; size = 1
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
_new_text$ = 12						; size = 4
_new_text_end$ = 16					; size = 4
?InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z PROC ; ImGuiInputTextCallbackData::InsertChars, COMDAT
; _this$ = ecx

; 3289 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00013	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3290 :     const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00033	81 e1 00 00 04
	00		 and	 ecx, 262144		; 00040000H
  00039	74 09		 je	 SHORT $LN7@InsertChar
  0003b	c6 85 f7 fe ff
	ff 01		 mov	 BYTE PTR tv67[ebp], 1
  00042	eb 07		 jmp	 SHORT $LN8@InsertChar
$LN7@InsertChar:
  00044	c6 85 f7 fe ff
	ff 00		 mov	 BYTE PTR tv67[ebp], 0
$LN8@InsertChar:
  0004b	8a 95 f7 fe ff
	ff		 mov	 dl, BYTE PTR tv67[ebp]
  00051	88 55 ef	 mov	 BYTE PTR _is_resizable$[ebp], dl

; 3291 :     const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);

  00054	83 7d 10 00	 cmp	 DWORD PTR _new_text_end$[ebp], 0
  00058	74 0e		 je	 SHORT $LN9@InsertChar
  0005a	8b 45 10	 mov	 eax, DWORD PTR _new_text_end$[ebp]
  0005d	2b 45 0c	 sub	 eax, DWORD PTR _new_text$[ebp]
  00060	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00066	eb 12		 jmp	 SHORT $LN10@InsertChar
$LN9@InsertChar:
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _new_text$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 _strlen
  00071	83 c4 04	 add	 esp, 4
  00074	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
$LN10@InsertChar:
  0007a	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  00080	89 55 e0	 mov	 DWORD PTR _new_text_len$[ebp], edx

; 3292 :     if (new_text_len + BufTextLen >= BufSize)

  00083	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR _new_text_len$[ebp]
  00089	03 48 18	 add	 ecx, DWORD PTR [eax+24]
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	3b 4a 1c	 cmp	 ecx, DWORD PTR [edx+28]
  00092	0f 8c f1 00 00
	00		 jl	 $LN2@InsertChar

; 3293 :     {
; 3294 :         if (!is_resizable)

  00098	0f b6 45 ef	 movzx	 eax, BYTE PTR _is_resizable$[ebp]
  0009c	85 c0		 test	 eax, eax
  0009e	75 05		 jne	 SHORT $LN3@InsertChar

; 3295 :             return;

  000a0	e9 8d 01 00 00	 jmp	 $LN1@InsertChar
$LN3@InsertChar:

; 3296 : 
; 3297 :         // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)
; 3298 :         ImGuiContext& g = *GImGui;

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  000aa	89 45 d4	 mov	 DWORD PTR _g$3[ebp], eax

; 3299 :         ImGuiInputTextState* edit_state = &g.InputTextState;

  000ad	8b 45 d4	 mov	 eax, DWORD PTR _g$3[ebp]
  000b0	05 00 1e 00 00	 add	 eax, 7680		; 00001e00H
  000b5	89 45 c8	 mov	 DWORD PTR _edit_state$2[ebp], eax

; 3300 :         IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);

  000b8	8b 45 c8	 mov	 eax, DWORD PTR _edit_state$2[ebp]
  000bb	83 38 00	 cmp	 DWORD PTR [eax], 0
  000be	74 10		 je	 SHORT $LN11@InsertChar
  000c0	8b 4d d4	 mov	 ecx, DWORD PTR _g$3[ebp]
  000c3	8b 55 c8	 mov	 edx, DWORD PTR _edit_state$2[ebp]
  000c6	8b 81 e4 19 00
	00		 mov	 eax, DWORD PTR [ecx+6628]
  000cc	3b 02		 cmp	 eax, DWORD PTR [edx]
  000ce	74 26		 je	 SHORT $LN12@InsertChar
$LN11@InsertChar:
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z@4JA
  000d6	83 c1 0b	 add	 ecx, 11			; 0000000bH
  000d9	8b f4		 mov	 esi, esp
  000db	51		 push	 ecx
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@EFFMAEBL@?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAI?$AAD?$AA?5@
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ef	3b f4		 cmp	 esi, esp
  000f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@InsertChar:

; 3301 :         IM_ASSERT(Buf == edit_state->TextA.Data);

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	8b 4d c8	 mov	 ecx, DWORD PTR _edit_state$2[ebp]
  000fc	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000ff	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  00102	74 25		 je	 SHORT $LN13@InsertChar
  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z@4JA
  00109	83 c0 0c	 add	 eax, 12			; 0000000cH
  0010c	8b f4		 mov	 esi, esp
  0010e	50		 push	 eax
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@LDGOBGNL@?$AAB?$AAu?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAe?$AAd?$AAi?$AAt?$AA_?$AAs?$AAt?$AAa@
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00122	3b f4		 cmp	 esi, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@InsertChar:

; 3302 :         int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;

  00129	8b 45 e0	 mov	 eax, DWORD PTR _new_text_len$[ebp]
  0012c	50		 push	 eax
  0012d	68 00 01 00 00	 push	 256			; 00000100H
  00132	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  00137	83 c4 08	 add	 esp, 8
  0013a	50		 push	 eax
  0013b	6a 20		 push	 32			; 00000020H
  0013d	8b 4d e0	 mov	 ecx, DWORD PTR _new_text_len$[ebp]
  00140	c1 e1 02	 shl	 ecx, 2
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0014f	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00152	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00156	89 55 bc	 mov	 DWORD PTR _new_buf_size$1[ebp], edx

; 3303 :         edit_state->TextA.reserve(new_buf_size + 1);

  00159	8b 45 bc	 mov	 eax, DWORD PTR _new_buf_size$1[ebp]
  0015c	83 c0 01	 add	 eax, 1
  0015f	50		 push	 eax
  00160	8b 4d c8	 mov	 ecx, DWORD PTR _edit_state$2[ebp]
  00163	83 c1 18	 add	 ecx, 24			; 00000018H
  00166	e8 00 00 00 00	 call	 ?reserve@?$ImVector@D@@QAEXH@Z ; ImVector<char>::reserve

; 3304 :         Buf = edit_state->TextA.Data;

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0016e	8b 4d c8	 mov	 ecx, DWORD PTR _edit_state$2[ebp]
  00171	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00174	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 3305 :         BufSize = edit_state->BufCapacityA = new_buf_size;

  00177	8b 45 c8	 mov	 eax, DWORD PTR _edit_state$2[ebp]
  0017a	8b 4d bc	 mov	 ecx, DWORD PTR _new_buf_size$1[ebp]
  0017d	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  00180	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00183	8b 45 bc	 mov	 eax, DWORD PTR _new_buf_size$1[ebp]
  00186	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN2@InsertChar:

; 3306 :     }
; 3307 : 
; 3308 :     if (BufTextLen != pos)

  00189	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0018c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0018f	3b 4d 08	 cmp	 ecx, DWORD PTR _pos$[ebp]
  00192	74 29		 je	 SHORT $LN4@InsertChar

; 3309 :         memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));

  00194	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00197	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0019a	2b 4d 08	 sub	 ecx, DWORD PTR _pos$[ebp]
  0019d	51		 push	 ecx
  0019e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001a1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001a4	03 45 08	 add	 eax, DWORD PTR _pos$[ebp]
  001a7	50		 push	 eax
  001a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  001ae	03 55 08	 add	 edx, DWORD PTR _pos$[ebp]
  001b1	03 55 e0	 add	 edx, DWORD PTR _new_text_len$[ebp]
  001b4	52		 push	 edx
  001b5	e8 00 00 00 00	 call	 _memmove
  001ba	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@InsertChar:

; 3310 :     memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));

  001bd	8b 45 e0	 mov	 eax, DWORD PTR _new_text_len$[ebp]
  001c0	50		 push	 eax
  001c1	8b 4d 0c	 mov	 ecx, DWORD PTR _new_text$[ebp]
  001c4	51		 push	 ecx
  001c5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001c8	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001cb	03 45 08	 add	 eax, DWORD PTR _pos$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _memcpy
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3311 :     Buf[BufTextLen + new_text_len] = '\0';

  001d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001da	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001dd	03 4d e0	 add	 ecx, DWORD PTR _new_text_len$[ebp]
  001e0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001e3	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  001e6	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 3312 : 
; 3313 :     if (CursorPos >= pos)

  001ea	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001ed	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001f0	3b 4d 08	 cmp	 ecx, DWORD PTR _pos$[ebp]
  001f3	7c 0f		 jl	 SHORT $LN5@InsertChar

; 3314 :         CursorPos += new_text_len;

  001f5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001f8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001fb	03 4d e0	 add	 ecx, DWORD PTR _new_text_len$[ebp]
  001fe	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00201	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
$LN5@InsertChar:

; 3315 :     SelectionStart = SelectionEnd = CursorPos;

  00204	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00207	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020a	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0020d	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  00210	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00213	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00216	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00219	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 3316 :     BufDirty = true;

  0021c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0021f	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 3317 :     BufTextLen += new_text_len;

  00223	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00226	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00229	03 4d e0	 add	 ecx, DWORD PTR _new_text_len$[ebp]
  0022c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0022f	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
$LN1@InsertChar:

; 3318 : }

  00232	5f		 pop	 edi
  00233	5e		 pop	 esi
  00234	5b		 pop	 ebx
  00235	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  0023b	3b ec		 cmp	 ebp, esp
  0023d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00242	8b e5		 mov	 esp, ebp
  00244	5d		 pop	 ebp
  00245	c2 0c 00	 ret	 12			; 0000000cH
?InsertChars@ImGuiInputTextCallbackData@@QAEXHPBD0@Z ENDP ; ImGuiInputTextCallbackData::InsertChars
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z
_TEXT	SEGMENT
_c$1 = -41						; size = 1
_src$ = -32						; size = 4
_dst$ = -20						; size = 4
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
_bytes_count$ = 12					; size = 4
?DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z PROC	; ImGuiInputTextCallbackData::DeleteChars, COMDAT
; _this$ = ecx

; 3271 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3272 :     IM_ASSERT(pos + bytes_count <= BufTextLen);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00030	03 45 0c	 add	 eax, DWORD PTR _bytes_count$[ebp]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00039	7e 26		 jle	 SHORT $LN8@DeleteChar
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z@4JA
  00041	83 c2 01	 add	 edx, 1
  00044	8b f4		 mov	 esi, esp
  00046	52		 push	 edx
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@OOMMGKHM@?$AAp?$AAo?$AAs?$AA?5?$AA?$CL?$AA?5?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAc?$AAo?$AAu@
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@DeleteChar:

; 3273 :     char* dst = Buf + pos;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00067	03 4d 08	 add	 ecx, DWORD PTR _pos$[ebp]
  0006a	89 4d ec	 mov	 DWORD PTR _dst$[ebp], ecx

; 3274 :     const char* src = Buf + pos + bytes_count;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00073	03 4d 08	 add	 ecx, DWORD PTR _pos$[ebp]
  00076	03 4d 0c	 add	 ecx, DWORD PTR _bytes_count$[ebp]
  00079	89 4d e0	 mov	 DWORD PTR _src$[ebp], ecx
$LN2@DeleteChar:

; 3275 :     while (char c = *src++)

  0007c	8b 45 e0	 mov	 eax, DWORD PTR _src$[ebp]
  0007f	8a 08		 mov	 cl, BYTE PTR [eax]
  00081	88 4d d7	 mov	 BYTE PTR _c$1[ebp], cl
  00084	8b 55 e0	 mov	 edx, DWORD PTR _src$[ebp]
  00087	83 c2 01	 add	 edx, 1
  0008a	89 55 e0	 mov	 DWORD PTR _src$[ebp], edx
  0008d	0f be 45 d7	 movsx	 eax, BYTE PTR _c$1[ebp]
  00091	85 c0		 test	 eax, eax
  00093	74 13		 je	 SHORT $LN3@DeleteChar

; 3276 :         *dst++ = c;

  00095	8b 45 ec	 mov	 eax, DWORD PTR _dst$[ebp]
  00098	8a 4d d7	 mov	 cl, BYTE PTR _c$1[ebp]
  0009b	88 08		 mov	 BYTE PTR [eax], cl
  0009d	8b 55 ec	 mov	 edx, DWORD PTR _dst$[ebp]
  000a0	83 c2 01	 add	 edx, 1
  000a3	89 55 ec	 mov	 DWORD PTR _dst$[ebp], edx
  000a6	eb d4		 jmp	 SHORT $LN2@DeleteChar
$LN3@DeleteChar:

; 3277 :     *dst = '\0';

  000a8	8b 45 ec	 mov	 eax, DWORD PTR _dst$[ebp]
  000ab	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3278 : 
; 3279 :     if (CursorPos + bytes_count >= pos)

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000b4	03 4d 0c	 add	 ecx, DWORD PTR _bytes_count$[ebp]
  000b7	3b 4d 08	 cmp	 ecx, DWORD PTR _pos$[ebp]
  000ba	7c 11		 jl	 SHORT $LN4@DeleteChar

; 3280 :         CursorPos -= bytes_count;

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c2	2b 4d 0c	 sub	 ecx, DWORD PTR _bytes_count$[ebp]
  000c5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c8	89 4a 24	 mov	 DWORD PTR [edx+36], ecx
  000cb	eb 14		 jmp	 SHORT $LN5@DeleteChar
$LN4@DeleteChar:

; 3281 :     else if (CursorPos >= pos)

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000d3	3b 4d 08	 cmp	 ecx, DWORD PTR _pos$[ebp]
  000d6	7c 09		 jl	 SHORT $LN5@DeleteChar

; 3282 :         CursorPos = pos;

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000db	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  000de	89 48 24	 mov	 DWORD PTR [eax+36], ecx
$LN5@DeleteChar:

; 3283 :     SelectionStart = SelectionEnd = CursorPos;

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000ea	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  000ed	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000f6	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 3284 :     BufDirty = true;

  000f9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 3285 :     BufTextLen -= bytes_count;

  00100	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00103	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00106	2b 4d 0c	 sub	 ecx, DWORD PTR _bytes_count$[ebp]
  00109	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010c	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 3286 : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00118	3b ec		 cmp	 ebp, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 08 00	 ret	 8
?DeleteChars@ImGuiInputTextCallbackData@@QAEXHH@Z ENDP	; ImGuiInputTextCallbackData::DeleteChars
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiInputTextCallbackData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImGuiInputTextCallbackData@@QAE@XZ PROC		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData, COMDAT
; _this$ = ecx

; 3263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3264 :     memset(this, 0, sizeof(*this));

  0002d	6a 30		 push	 48			; 00000030H
  0002f	6a 00		 push	 0
  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3265 : }

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??0ImGuiInputTextCallbackData@@QAE@XZ ENDP		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?contains@?$ImVector@G@@QBE_NABG@Z
_TEXT	SEGMENT
tv76 = -240						; size = 4
tv75 = -236						; size = 4
tv74 = -232						; size = 4
_data_end$ = -32					; size = 4
_data$ = -20						; size = 4
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?contains@?$ImVector@G@@QBE_NABG@Z PROC			; ImVector<unsigned short>::contains, COMDAT
; _this$ = ecx

; 1300 :     inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00033	89 4d ec	 mov	 DWORD PTR _data$[ebp], ecx
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00041	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00044	89 4d e0	 mov	 DWORD PTR _data_end$[ebp], ecx
$LN2@contains:
  00047	8b 45 ec	 mov	 eax, DWORD PTR _data$[ebp]
  0004a	3b 45 e0	 cmp	 eax, DWORD PTR _data_end$[ebp]
  0004d	73 54		 jae	 SHORT $LN3@contains
  0004f	8b 45 ec	 mov	 eax, DWORD PTR _data$[ebp]
  00052	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00055	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], ecx
  0005b	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0005e	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00061	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00067	8b 4d ec	 mov	 ecx, DWORD PTR _data$[ebp]
  0006a	83 c1 02	 add	 ecx, 2
  0006d	89 4d ec	 mov	 DWORD PTR _data$[ebp], ecx
  00070	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  00076	3b 95 14 ff ff
	ff		 cmp	 edx, DWORD PTR tv75[ebp]
  0007c	75 0c		 jne	 SHORT $LN6@contains
  0007e	c7 85 10 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv76[ebp], 1
  00088	eb 0a		 jmp	 SHORT $LN7@contains
$LN6@contains:
  0008a	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN7@contains:
  00094	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR tv76[ebp], 0
  0009b	74 04		 je	 SHORT $LN4@contains
  0009d	b0 01		 mov	 al, 1
  0009f	eb 04		 jmp	 SHORT $LN1@contains
$LN4@contains:
  000a1	eb a4		 jmp	 SHORT $LN2@contains
$LN3@contains:
  000a3	32 c0		 xor	 al, al
$LN1@contains:
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000ae	3b ec		 cmp	 ebp, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
?contains@?$ImVector@G@@QBE_NABG@Z ENDP			; ImVector<unsigned short>::contains
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 56		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	d1 e0		 shl	 eax, 1
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00052	74 2a		 je	 SHORT $LN3@reserve
  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	d1 e1		 shl	 ecx, 1
  0005b	51		 push	 ecx
  0005c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00062	50		 push	 eax
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007b	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00084	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00087	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
?reserve@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@G@@QBEHH@Z ; ImVector<unsigned short>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@G@@QBEHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@G@@QBEHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QBEABGH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@G@@QBEABGH@Z PROC				; ImVector<unsigned short>::operator[], COMDAT
; _this$ = ecx

; 1273 :     inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f9 04 00 00	 push	 1273			; 000004f9H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@G@@QBEABGH@Z ENDP				; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@G@@QAEAAGH@Z PROC				; ImVector<unsigned short>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@G@@QAEAAGH@Z ENDP				; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@G@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@G@@QBE_NXZ PROC			; ImVector<unsigned short>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@G@@QBE_NXZ ENDP			; ImVector<unsigned short>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??3@YAXPAXUImNewDummy@@0@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 4
??3@YAXPAXUImNewDummy@@0@Z PROC				; operator delete, COMDAT

; 1232 : inline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symmetrical new()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3@YAXPAXUImNewDummy@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00020	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3@YAXPAXUImNewDummy@@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3@YAXPAXUImNewDummy@@0@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3@YAXPAXUImNewDummy@@0@Z ENDP				; operator delete
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??2@YAPAXIUImNewDummy@@PAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
_ptr$ = 16						; size = 4
??2@YAPAXIUImNewDummy@@PAX@Z PROC			; operator new, COMDAT

; 1231 : inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _ptr$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??2@YAPAXIUImNewDummy@@PAX@Z ENDP			; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SetTabItemClosed@ImGui@@YAXPBD@Z
_TEXT	SEGMENT
tv70 = -244						; size = 4
_tab_id$1 = -44						; size = 4
_tab_bar$2 = -32					; size = 4
_is_within_manual_tab_bar$ = -17			; size = 1
_g$ = -8						; size = 4
_label$ = 8						; size = 4
?SetTabItemClosed@ImGui@@YAXPBD@Z PROC			; ImGui::SetTabItemClosed, COMDAT

; 7108 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7109 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 7110 :     bool is_within_manual_tab_bar = g.CurrentTabBar && !(g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode);

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	83 b8 c0 1d 00
	00 00		 cmp	 DWORD PTR [eax+7616], 0
  0003a	74 1f		 je	 SHORT $LN4@SetTabItem
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0003f	8b 91 c0 1d 00
	00		 mov	 edx, DWORD PTR [ecx+7616]
  00045	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00048	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  0004d	75 0c		 jne	 SHORT $LN4@SetTabItem
  0004f	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv70[ebp], 1
  00059	eb 0a		 jmp	 SHORT $LN5@SetTabItem
$LN4@SetTabItem:
  0005b	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN5@SetTabItem:
  00065	8a 8d 0c ff ff
	ff		 mov	 cl, BYTE PTR tv70[ebp]
  0006b	88 4d ef	 mov	 BYTE PTR _is_within_manual_tab_bar$[ebp], cl

; 7111 :     if (is_within_manual_tab_bar)

  0006e	0f b6 45 ef	 movzx	 eax, BYTE PTR _is_within_manual_tab_bar$[ebp]
  00072	85 c0		 test	 eax, eax
  00074	74 60		 je	 SHORT $LN1@SetTabItem

; 7112 :     {
; 7113 :         ImGuiTabBar* tab_bar = g.CurrentTabBar;

  00076	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00079	8b 88 c0 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7616]
  0007f	89 4d e0	 mov	 DWORD PTR _tab_bar$2[ebp], ecx

; 7114 :         IM_ASSERT(tab_bar->WantLayout);         // Needs to be called AFTER BeginTabBar() and BEFORE the first call to BeginTabItem()

  00082	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$2[ebp]
  00085	0f b6 48 5d	 movzx	 ecx, BYTE PTR [eax+93]
  00089	85 c9		 test	 ecx, ecx
  0008b	75 26		 jne	 SHORT $LN6@SetTabItem
  0008d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SetTabItemClosed@ImGui@@YAXPBD@Z@4JA
  00093	83 c2 06	 add	 edx, 6
  00096	8b f4		 mov	 esi, esp
  00098	52		 push	 edx
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_1CI@FDDNDGMG@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAW?$AAa?$AAn?$AAt?$AAL?$AAa@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	3b f4		 cmp	 esi, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@SetTabItem:

; 7115 :         ImGuiID tab_id = TabBarCalcTabID(tab_bar, label);

  000b3	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d e0	 mov	 ecx, DWORD PTR _tab_bar$2[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ?TabBarCalcTabID@ImGui@@YAIPAUImGuiTabBar@@PBD@Z ; ImGui::TabBarCalcTabID
  000c0	83 c4 08	 add	 esp, 8
  000c3	89 45 d4	 mov	 DWORD PTR _tab_id$1[ebp], eax

; 7116 :         TabBarRemoveTab(tab_bar, tab_id);

  000c6	8b 45 d4	 mov	 eax, DWORD PTR _tab_id$1[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d e0	 mov	 ecx, DWORD PTR _tab_bar$2[ebp]
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ?TabBarRemoveTab@ImGui@@YAXPAUImGuiTabBar@@I@Z ; ImGui::TabBarRemoveTab
  000d3	83 c4 08	 add	 esp, 8
$LN1@SetTabItem:

; 7117 :     }
; 7118 : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000df	3b ec		 cmp	 ebp, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?SetTabItemClosed@ImGui@@YAXPBD@Z ENDP			; ImGui::SetTabItemClosed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?EndTabItem@ImGui@@YAXXZ
_TEXT	SEGMENT
_tab$ = -44						; size = 4
_tab_bar$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
?EndTabItem@ImGui@@YAXXZ PROC				; ImGui::EndTabItem, COMDAT

; 6889 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6890 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6891 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 6892 :     if (window->SkipItems)

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003f	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00043	85 c9		 test	 ecx, ecx
  00045	74 05		 je	 SHORT $LN2@EndTabItem

; 6893 :         return;

  00047	e9 a6 00 00 00	 jmp	 $LN1@EndTabItem
$LN2@EndTabItem:

; 6894 : 
; 6895 :     ImGuiTabBar* tab_bar = g.CurrentTabBar;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0004f	8b 88 c0 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7616]
  00055	89 4d e0	 mov	 DWORD PTR _tab_bar$[ebp], ecx

; 6896 :     if (tab_bar == NULL)

  00058	83 7d e0 00	 cmp	 DWORD PTR _tab_bar$[ebp], 0
  0005c	75 37		 jne	 SHORT $LN3@EndTabItem

; 6897 :     {
; 6898 :         IM_ASSERT(tab_bar != NULL && "Needs to be called between BeginTabBar() and EndTabBar()!");

  0005e	83 7d e0 00	 cmp	 DWORD PTR _tab_bar$[ebp], 0
  00062	74 09		 je	 SHORT $LN6@EndTabItem
  00064	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DK@EHILAJFJ@Needs?5to?5be?5called?5between?5Begi@
  00069	85 c0		 test	 eax, eax
  0006b	75 26		 jne	 SHORT $LN7@EndTabItem
$LN6@EndTabItem:
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??EndTabItem@ImGui@@YAXXZ@4JA
  00073	83 c1 09	 add	 ecx, 9
  00076	8b f4		 mov	 esi, esp
  00078	51		 push	 ecx
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_1JI@HFPIFMIP@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@EndTabItem:

; 6899 :         return;

  00093	eb 5d		 jmp	 SHORT $LN1@EndTabItem
$LN3@EndTabItem:

; 6900 :     }
; 6901 :     IM_ASSERT(tab_bar->LastTabItemIdx >= 0);

  00095	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00098	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  0009c	85 c9		 test	 ecx, ecx
  0009e	7d 26		 jge	 SHORT $LN8@EndTabItem
  000a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??EndTabItem@ImGui@@YAXXZ@4JA
  000a6	83 c2 0c	 add	 edx, 12			; 0000000cH
  000a9	8b f4		 mov	 esi, esp
  000ab	52		 push	 edx
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@HGEILAOB@?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?9?$AA?$DO?$AAL?$AAa?$AAs?$AAt?$AAT?$AAa@
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@EndTabItem:

; 6902 :     ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];

  000c6	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000c9	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  000cd	51		 push	 ecx
  000ce	8b 4d e0	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  000d1	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  000d6	89 45 d4	 mov	 DWORD PTR _tab$[ebp], eax

; 6903 :     if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))

  000d9	8b 45 d4	 mov	 eax, DWORD PTR _tab$[ebp]
  000dc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000df	83 e1 08	 and	 ecx, 8
  000e2	75 0e		 jne	 SHORT $LN1@EndTabItem

; 6904 :         window->IDStack.pop_back();

  000e4	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  000e7	81 c1 bc 00 00
	00		 add	 ecx, 188		; 000000bcH
  000ed	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@I@@QAEXXZ ; ImVector<unsigned int>::pop_back
$LN1@EndTabItem:

; 6905 : }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000fb	3b ec		 cmp	 ebp, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
?EndTabItem@ImGui@@YAXXZ ENDP				; ImGui::EndTabItem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginTabItem@ImGui@@YA_NPBDPA_NH@Z
_TEXT	SEGMENT
_tab$1 = -56						; size = 4
_ret$ = -41						; size = 1
_tab_bar$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
_label$ = 8						; size = 4
_p_open$ = 12						; size = 4
_flags$ = 16						; size = 4
?BeginTabItem@ImGui@@YA_NPBDPA_NH@Z PROC		; ImGui::BeginTabItem, COMDAT

; 6867 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6868 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6869 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 6870 :     if (window->SkipItems)

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003f	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00043	85 c9		 test	 ecx, ecx
  00045	74 07		 je	 SHORT $LN2@BeginTabIt

; 6871 :         return false;

  00047	32 c0		 xor	 al, al
  00049	e9 9a 00 00 00	 jmp	 $LN1@BeginTabIt
$LN2@BeginTabIt:

; 6872 : 
; 6873 :     ImGuiTabBar* tab_bar = g.CurrentTabBar;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00051	8b 88 c0 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7616]
  00057	89 4d e0	 mov	 DWORD PTR _tab_bar$[ebp], ecx

; 6874 :     if (tab_bar == NULL)

  0005a	83 7d e0 00	 cmp	 DWORD PTR _tab_bar$[ebp], 0
  0005e	75 39		 jne	 SHORT $LN3@BeginTabIt

; 6875 :     {
; 6876 :         IM_ASSERT_USER_ERROR(tab_bar, "BeginTabItem() Needs to be called between BeginTabBar() and EndTabBar()!");

  00060	83 7d e0 00	 cmp	 DWORD PTR _tab_bar$[ebp], 0
  00064	74 09		 je	 SHORT $LN6@BeginTabIt
  00066	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EJ@BGGEHPHF@BeginTabItem?$CI?$CJ?5Needs?5to?5be?5call@
  0006b	85 c0		 test	 eax, eax
  0006d	75 26		 jne	 SHORT $LN7@BeginTabIt
$LN6@BeginTabIt:
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??BeginTabItem@ImGui@@YA_NPBDPA_NH@Z@4JA
  00075	83 c1 09	 add	 ecx, 9
  00078	8b f4		 mov	 esi, esp
  0007a	51		 push	 ecx
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@GNEGANEK@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAB@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@BeginTabIt:

; 6877 :         return false;

  00095	32 c0		 xor	 al, al
  00097	eb 4f		 jmp	 SHORT $LN1@BeginTabIt
$LN3@BeginTabIt:

; 6878 :     }
; 6879 :     bool ret = TabItemEx(tab_bar, label, p_open, flags);

  00099	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _p_open$[ebp]
  000a0	51		 push	 ecx
  000a1	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  000a4	52		 push	 edx
  000a5	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?TabItemEx@ImGui@@YA_NPAUImGuiTabBar@@PBDPA_NH@Z ; ImGui::TabItemEx
  000ae	83 c4 10	 add	 esp, 16			; 00000010H
  000b1	88 45 d7	 mov	 BYTE PTR _ret$[ebp], al

; 6880 :     if (ret && !(flags & ImGuiTabItemFlags_NoPushId))

  000b4	0f b6 45 d7	 movzx	 eax, BYTE PTR _ret$[ebp]
  000b8	85 c0		 test	 eax, eax
  000ba	74 29		 je	 SHORT $LN4@BeginTabIt
  000bc	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000bf	83 e0 08	 and	 eax, 8
  000c2	75 21		 jne	 SHORT $LN4@BeginTabIt

; 6881 :     {
; 6882 :         ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];

  000c4	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000c7	0f bf 48 60	 movsx	 ecx, WORD PTR [eax+96]
  000cb	51		 push	 ecx
  000cc	8b 4d e0	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  000cf	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiTabItem@@@@QAEAAUImGuiTabItem@@H@Z ; ImVector<ImGuiTabItem>::operator[]
  000d4	89 45 c8	 mov	 DWORD PTR _tab$1[ebp], eax

; 6883 :         PushOverrideID(tab->ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)

  000d7	8b 45 c8	 mov	 eax, DWORD PTR _tab$1[ebp]
  000da	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ?PushOverrideID@ImGui@@YAXI@Z ; ImGui::PushOverrideID
  000e2	83 c4 04	 add	 esp, 4
$LN4@BeginTabIt:

; 6884 :     }
; 6885 :     return ret;

  000e5	8a 45 d7	 mov	 al, BYTE PTR _ret$[ebp]
$LN1@BeginTabIt:

; 6886 : }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000f1	3b ec		 cmp	 ebp, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
?BeginTabItem@ImGui@@YA_NPBDPA_NH@Z ENDP		; ImGui::BeginTabItem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?EndTabBar@ImGui@@YAXXZ
_TEXT	SEGMENT
tv160 = -244						; size = 4
tv85 = -241						; size = 1
_tab_bar_appearing$ = -41				; size = 1
_tab_bar$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
?EndTabBar@ImGui@@YAXXZ PROC				; ImGui::EndTabBar, COMDAT

; 6470 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6471 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6472 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 6473 :     if (window->SkipItems)

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003f	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00043	85 c9		 test	 ecx, ecx
  00045	74 05		 je	 SHORT $LN2@EndTabBar

; 6474 :         return;

  00047	e9 67 01 00 00	 jmp	 $LN1@EndTabBar
$LN2@EndTabBar:

; 6475 : 
; 6476 :     ImGuiTabBar* tab_bar = g.CurrentTabBar;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0004f	8b 88 c0 1d 00
	00		 mov	 ecx, DWORD PTR [eax+7616]
  00055	89 4d e0	 mov	 DWORD PTR _tab_bar$[ebp], ecx

; 6477 :     if (tab_bar == NULL)

  00058	83 7d e0 00	 cmp	 DWORD PTR _tab_bar$[ebp], 0
  0005c	75 3a		 jne	 SHORT $LN3@EndTabBar

; 6478 :     {
; 6479 :         IM_ASSERT_USER_ERROR(tab_bar != NULL, "Mismatched BeginTabBar()/EndTabBar()!");

  0005e	83 7d e0 00	 cmp	 DWORD PTR _tab_bar$[ebp], 0
  00062	74 09		 je	 SHORT $LN10@EndTabBar
  00064	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CG@DPIPLNLI@Mismatched?5BeginTabBar?$CI?$CJ?1EndTab@
  00069	85 c0		 test	 eax, eax
  0006b	75 26		 jne	 SHORT $LN11@EndTabBar
$LN10@EndTabBar:
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??EndTabBar@ImGui@@YAXXZ@4JA
  00073	83 c1 09	 add	 ecx, 9
  00076	8b f4		 mov	 esi, esp
  00078	51		 push	 ecx
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_1HE@HMPOLDED@?$AA?$CI?$AAt?$AAa?$AAb?$AA_?$AAb?$AAa?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CJ?$AA?5@
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@EndTabBar:

; 6480 :         return;

  00093	e9 1b 01 00 00	 jmp	 $LN1@EndTabBar
$LN3@EndTabBar:

; 6481 :     }
; 6482 :     if (tab_bar->WantLayout)

  00098	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0009b	0f b6 48 5d	 movzx	 ecx, BYTE PTR [eax+93]
  0009f	85 c9		 test	 ecx, ecx
  000a1	74 0c		 je	 SHORT $LN4@EndTabBar

; 6483 :         TabBarLayout(tab_bar);

  000a3	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?TabBarLayout@ImGui@@YAXPAUImGuiTabBar@@@Z ; ImGui::TabBarLayout
  000ac	83 c4 04	 add	 esp, 4
$LN4@EndTabBar:

; 6484 : 
; 6485 :     // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
; 6486 :     const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);

  000af	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000b2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b5	83 c1 01	 add	 ecx, 1
  000b8	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  000bb	3b 8a 60 19 00
	00		 cmp	 ecx, DWORD PTR [edx+6496]
  000c1	7d 09		 jge	 SHORT $LN12@EndTabBar
  000c3	c6 85 0f ff ff
	ff 01		 mov	 BYTE PTR tv85[ebp], 1
  000ca	eb 07		 jmp	 SHORT $LN13@EndTabBar
$LN12@EndTabBar:
  000cc	c6 85 0f ff ff
	ff 00		 mov	 BYTE PTR tv85[ebp], 0
$LN13@EndTabBar:
  000d3	8a 85 0f ff ff
	ff		 mov	 al, BYTE PTR tv85[ebp]
  000d9	88 45 d7	 mov	 BYTE PTR _tab_bar_appearing$[ebp], al

; 6487 :     if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)

  000dc	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000df	0f b6 48 5e	 movzx	 ecx, BYTE PTR [eax+94]
  000e3	85 c9		 test	 ecx, ecx
  000e5	75 11		 jne	 SHORT $LN7@EndTabBar
  000e7	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000ea	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000ee	74 08		 je	 SHORT $LN7@EndTabBar
  000f0	0f b6 45 d7	 movzx	 eax, BYTE PTR _tab_bar_appearing$[ebp]
  000f4	85 c0		 test	 eax, eax
  000f6	74 32		 je	 SHORT $LN5@EndTabBar
$LN7@EndTabBar:

; 6488 :         tab_bar->LastTabContentHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, 0.0f);

  000f8	51		 push	 ecx
  000f9	0f 57 c0	 xorps	 xmm0, xmm0
  000fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00101	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00104	8b 4d e0	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00107	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  0010f	f3 0f 5c 41 30	 subss	 xmm0, DWORD PTR [ecx+48]
  00114	51		 push	 ecx
  00115	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011a	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0011f	83 c4 08	 add	 esp, 8
  00122	8b 55 e0	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  00125	d9 5a 34	 fstp	 DWORD PTR [edx+52]
  00128	eb 1b		 jmp	 SHORT $LN6@EndTabBar
$LN5@EndTabBar:

; 6489 :     else
; 6490 :         window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->LastTabContentHeight;

  0012a	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  0012d	8b 4d e0	 mov	 ecx, DWORD PTR _tab_bar$[ebp]
  00130	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  00135	f3 0f 58 41 34	 addss	 xmm0, DWORD PTR [ecx+52]
  0013a	8b 55 ec	 mov	 edx, DWORD PTR _window$[ebp]
  0013d	f3 0f 11 82 cc
	00 00 00	 movss	 DWORD PTR [edx+204], xmm0
$LN6@EndTabBar:

; 6491 : 
; 6492 :     if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)

  00145	8b 45 e0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  00148	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0014b	81 e1 00 00 10
	00		 and	 ecx, 1048576		; 00100000H
  00151	75 05		 jne	 SHORT $LN8@EndTabBar

; 6493 :         PopID();

  00153	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID
$LN8@EndTabBar:

; 6494 : 
; 6495 :     g.CurrentTabBarStack.pop_back();

  00158	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0015b	81 c1 e0 1d 00
	00		 add	 ecx, 7648		; 00001de0H
  00161	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QAEXXZ ; ImVector<ImGuiPtrOrIndex>::pop_back

; 6496 :     g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());

  00166	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00169	81 c1 e0 1d 00
	00		 add	 ecx, 7648		; 00001de0H
  0016f	e8 00 00 00 00	 call	 ?empty@?$ImVector@UImGuiPtrOrIndex@@@@QBE_NXZ ; ImVector<ImGuiPtrOrIndex>::empty
  00174	0f b6 c0	 movzx	 eax, al
  00177	85 c0		 test	 eax, eax
  00179	74 0c		 je	 SHORT $LN14@EndTabBar
  0017b	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv160[ebp], 0
  00185	eb 1d		 jmp	 SHORT $LN15@EndTabBar
$LN14@EndTabBar:
  00187	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0018a	81 c1 e0 1d 00
	00		 add	 ecx, 7648		; 00001de0H
  00190	e8 00 00 00 00	 call	 ?back@?$ImVector@UImGuiPtrOrIndex@@@@QAEAAUImGuiPtrOrIndex@@XZ ; ImVector<ImGuiPtrOrIndex>::back
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 ?GetTabBarFromTabBarRef@@YAPAUImGuiTabBar@@ABUImGuiPtrOrIndex@@@Z ; GetTabBarFromTabBarRef
  0019b	83 c4 04	 add	 esp, 4
  0019e	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv160[ebp], eax
$LN15@EndTabBar:
  001a4	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  001a7	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv160[ebp]
  001ad	89 91 c0 1d 00
	00		 mov	 DWORD PTR [ecx+7616], edx
$LN1@EndTabBar:

; 6497 : }

  001b3	5f		 pop	 edi
  001b4	5e		 pop	 esi
  001b5	5b		 pop	 ebx
  001b6	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  001bc	3b ec		 cmp	 ebp, esp
  001be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c3		 ret	 0
?EndTabBar@ImGui@@YAXXZ ENDP				; ImGui::EndTabBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginTabBar@ImGui@@YA_NPBDH@Z
_TEXT	SEGMENT
_tab_bar_bb$ = -72					; size = 16
_tab_bar$ = -48						; size = 4
_id$ = -36						; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_str_id$ = 8						; size = 4
_flags$ = 12						; size = 4
?BeginTabBar@ImGui@@YA_NPBDH@Z PROC			; ImGui::BeginTabBar, COMDAT

; 6404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6405 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 6406 :     ImGuiWindow* window = g.CurrentWindow;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00043	89 4d e8	 mov	 DWORD PTR _window$[ebp], ecx

; 6407 :     if (window->SkipItems)

  00046	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00049	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 07		 je	 SHORT $LN2@BeginTabBa

; 6408 :         return false;

  00051	32 c0		 xor	 al, al
  00053	e9 b6 00 00 00	 jmp	 $LN1@BeginTabBa
$LN2@BeginTabBa:

; 6409 : 
; 6410 :     ImGuiID id = window->GetID(str_id);

  00058	6a 00		 push	 0
  0005a	8b 45 08	 mov	 eax, DWORD PTR _str_id$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00061	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00066	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 6411 :     ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);

  00069	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00070	81 c1 c4 1d 00
	00		 add	 ecx, 7620		; 00001dc4H
  00076	e8 00 00 00 00	 call	 ?GetOrAddByKey@?$ImPool@UImGuiTabBar@@@@QAEPAUImGuiTabBar@@I@Z ; ImPool<ImGuiTabBar>::GetOrAddByKey
  0007b	89 45 d0	 mov	 DWORD PTR _tab_bar$[ebp], eax

; 6412 :     ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->WorkRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);

  0007e	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00081	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  00084	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  0008c	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  00094	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00097	f3 0f 10 8a 4c
	15 00 00	 movss	 xmm1, DWORD PTR [edx+5452]
  0009f	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  000a7	f3 0f 58 c1	 addss	 xmm0, xmm1
  000ab	51		 push	 ecx
  000ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b1	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  000b4	51		 push	 ecx
  000b5	f3 0f 10 80 fc
	01 00 00	 movss	 xmm0, DWORD PTR [eax+508]
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  000c5	51		 push	 ecx
  000c6	f3 0f 10 81 cc
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+204]
  000ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d3	8b 55 e8	 mov	 edx, DWORD PTR _window$[ebp]
  000d6	51		 push	 ecx
  000d7	f3 0f 10 82 c8
	00 00 00	 movss	 xmm0, DWORD PTR [edx+200]
  000df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e4	8d 4d b8	 lea	 ecx, DWORD PTR _tab_bar_bb$[ebp]
  000e7	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect

; 6413 :     tab_bar->ID = id;

  000ec	8b 45 d0	 mov	 eax, DWORD PTR _tab_bar$[ebp]
  000ef	8b 4d dc	 mov	 ecx, DWORD PTR _id$[ebp]
  000f2	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 6414 :     return BeginTabBarEx(tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused);

  000f5	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  000f8	0d 00 00 20 00	 or	 eax, 2097152		; 00200000H
  000fd	50		 push	 eax
  000fe	8d 4d b8	 lea	 ecx, DWORD PTR _tab_bar_bb$[ebp]
  00101	51		 push	 ecx
  00102	8b 55 d0	 mov	 edx, DWORD PTR _tab_bar$[ebp]
  00105	52		 push	 edx
  00106	e8 00 00 00 00	 call	 ?BeginTabBarEx@ImGui@@YA_NPAUImGuiTabBar@@ABUImRect@@H@Z ; ImGui::BeginTabBarEx
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@BeginTabBa:

; 6415 : }

  0010e	52		 push	 edx
  0010f	8b cd		 mov	 ecx, ebp
  00111	50		 push	 eax
  00112	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@BeginTabBa
  00118	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0011d	58		 pop	 eax
  0011e	5a		 pop	 edx
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx
  00122	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00125	33 cd		 xor	 ecx, ebp
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00132	3b ec		 cmp	 ebp, esp
  00134	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
  0013d	0f 1f 00	 npad	 3
$LN6@BeginTabBa:
  00140	01 00 00 00	 DD	 1
  00144	00 00 00 00	 DD	 $LN5@BeginTabBa
$LN5@BeginTabBa:
  00148	b8 ff ff ff	 DD	 -72			; ffffffb8H
  0014c	10 00 00 00	 DD	 16			; 00000010H
  00150	00 00 00 00	 DD	 $LN4@BeginTabBa
$LN4@BeginTabBa:
  00154	74		 DB	 116			; 00000074H
  00155	61		 DB	 97			; 00000061H
  00156	62		 DB	 98			; 00000062H
  00157	5f		 DB	 95			; 0000005fH
  00158	62		 DB	 98			; 00000062H
  00159	61		 DB	 97			; 00000061H
  0015a	72		 DB	 114			; 00000072H
  0015b	5f		 DB	 95			; 0000005fH
  0015c	62		 DB	 98			; 00000062H
  0015d	62		 DB	 98			; 00000062H
  0015e	00		 DB	 0
?BeginTabBar@ImGui@@YA_NPBDH@Z ENDP			; ImGui::BeginTabBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnsCount@ImGui@@YAHXZ
_TEXT	SEGMENT
tv71 = -208						; size = 4
_window$ = -8						; size = 4
?GetColumnsCount@ImGui@@YAHXZ PROC			; ImGui::GetColumnsCount, COMDAT

; 7239 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7240 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7241 :     return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  0003a	74 14		 je	 SHORT $LN3@GetColumns
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0003f	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [ecx+448]
  00045	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00048	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  0004e	eb 0a		 jmp	 SHORT $LN4@GetColumns
$LN3@GetColumns:
  00050	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
$LN4@GetColumns:
  0005a	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]

; 7242 : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?GetColumnsCount@ImGui@@YAHXZ ENDP			; ImGui::GetColumnsCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SetColumnOffset@ImGui@@YAXHM@Z
_TEXT	SEGMENT
tv233 = -256						; size = 4
tv228 = -256						; size = 4
tv129 = -256						; size = 4
tv89 = -253						; size = 1
_width$ = -56						; size = 4
_preserve_width$ = -41					; size = 1
_columns$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
_column_index$ = 8					; size = 4
_offset$ = 12						; size = 4
?SetColumnOffset@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnOffset, COMDAT

; 7316 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7317 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 7318 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 7319 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003f	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  00045	89 4d e0	 mov	 DWORD PTR _columns$[ebp], ecx

; 7320 :     IM_ASSERT(columns != NULL);

  00048	83 7d e0 00	 cmp	 DWORD PTR _columns$[ebp], 0
  0004c	75 25		 jne	 SHORT $LN6@SetColumnO
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA
  00053	83 c0 04	 add	 eax, 4
  00056	8b f4		 mov	 esi, esp
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@SetColumnO:

; 7321 : 
; 7322 :     if (column_index < 0)

  00073	83 7d 08 00	 cmp	 DWORD PTR _column_index$[ebp], 0
  00077	7d 09		 jge	 SHORT $LN2@SetColumnO

; 7323 :         column_index = columns->Current;

  00079	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  0007c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007f	89 4d 08	 mov	 DWORD PTR _column_index$[ebp], ecx
$LN2@SetColumnO:

; 7324 :     IM_ASSERT(column_index < columns->Columns.Size);

  00082	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _column_index$[ebp]
  00088	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  0008b	7c 26		 jl	 SHORT $LN7@SetColumnO
  0008d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SetColumnOffset@ImGui@@YAXHM@Z@4JA
  00093	83 c2 08	 add	 edx, 8
  00096	8b f4		 mov	 esi, esp
  00098	52		 push	 edx
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	3b f4		 cmp	 esi, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@SetColumnO:

; 7325 : 
; 7326 :     const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);

  000b3	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  000b6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b9	83 e1 04	 and	 ecx, 4
  000bc	75 17		 jne	 SHORT $LN8@SetColumnO
  000be	8b 55 e0	 mov	 edx, DWORD PTR _columns$[ebp]
  000c1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000c4	83 e8 01	 sub	 eax, 1
  000c7	39 45 08	 cmp	 DWORD PTR _column_index$[ebp], eax
  000ca	7d 09		 jge	 SHORT $LN8@SetColumnO
  000cc	c6 85 03 ff ff
	ff 01		 mov	 BYTE PTR tv89[ebp], 1
  000d3	eb 07		 jmp	 SHORT $LN9@SetColumnO
$LN8@SetColumnO:
  000d5	c6 85 03 ff ff
	ff 00		 mov	 BYTE PTR tv89[ebp], 0
$LN9@SetColumnO:
  000dc	8a 8d 03 ff ff
	ff		 mov	 cl, BYTE PTR tv89[ebp]
  000e2	88 4d d7	 mov	 BYTE PTR _preserve_width$[ebp], cl

; 7327 :     const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

  000e5	0f b6 45 d7	 movzx	 eax, BYTE PTR _preserve_width$[ebp]
  000e9	85 c0		 test	 eax, eax
  000eb	74 20		 je	 SHORT $LN10@SetColumnO
  000ed	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  000f0	0f b6 51 09	 movzx	 edx, BYTE PTR [ecx+9]
  000f4	52		 push	 edx
  000f5	8b 45 08	 mov	 eax, DWORD PTR _column_index$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 ?GetColumnWidthEx@@YAMPAUImGuiColumns@@H_N@Z ; GetColumnWidthEx
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv129[ebp]
  0010b	eb 0b		 jmp	 SHORT $LN11@SetColumnO
$LN10@SetColumnO:
  0010d	0f 57 c0	 xorps	 xmm0, xmm0
  00110	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR tv129[ebp], xmm0
$LN11@SetColumnO:
  00118	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR tv129[ebp]
  00120	f3 0f 11 45 c8	 movss	 DWORD PTR _width$[ebp], xmm0

; 7328 : 
; 7329 :     if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))

  00125	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	83 e1 08	 and	 ecx, 8
  0012e	75 40		 jne	 SHORT $LN3@SetColumnO

; 7330 :         offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));

  00130	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00133	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00136	2b 4d 08	 sub	 ecx, DWORD PTR _column_index$[ebp]
  00139	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0013d	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00140	f3 0f 59 82 74
	15 00 00	 mulss	 xmm0, DWORD PTR [edx+5492]
  00148	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  0014b	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [eax+24]
  00150	f3 0f 5c c8	 subss	 xmm1, xmm0
  00154	51		 push	 ecx
  00155	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0015a	51		 push	 ecx
  0015b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _offset$[ebp]
  00160	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00165	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0016a	83 c4 08	 add	 esp, 8
  0016d	d9 5d 0c	 fstp	 DWORD PTR _offset$[ebp]
$LN3@SetColumnO:

; 7331 :     columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

  00170	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00173	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _offset$[ebp]
  00178	f3 0f 5c 40 14	 subss	 xmm0, DWORD PTR [eax+20]
  0017d	51		 push	 ecx
  0017e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00183	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00186	51		 push	 ecx
  00187	e8 00 00 00 00	 call	 ?GetColumnNormFromOffset@ImGui@@YAMPBUImGuiColumns@@M@Z ; ImGui::GetColumnNormFromOffset
  0018c	83 c4 08	 add	 esp, 8
  0018f	8b 55 08	 mov	 edx, DWORD PTR _column_index$[ebp]
  00192	52		 push	 edx
  00193	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00196	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00199	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv233[ebp]
  0019f	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  001a4	d9 85 00 ff ff
	ff		 fld	 DWORD PTR tv233[ebp]
  001aa	d9 18		 fstp	 DWORD PTR [eax]

; 7332 : 
; 7333 :     if (preserve_width)

  001ac	0f b6 45 d7	 movzx	 eax, BYTE PTR _preserve_width$[ebp]
  001b0	85 c0		 test	 eax, eax
  001b2	74 4c		 je	 SHORT $LN4@SetColumnO

; 7334 :         SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));

  001b4	51		 push	 ecx
  001b5	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _width$[ebp]
  001ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bf	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001c2	51		 push	 ecx
  001c3	f3 0f 10 80 74
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5492]
  001cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001d5	83 c4 08	 add	 esp, 8
  001d8	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv228[ebp]
  001de	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR tv228[ebp]
  001e6	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _offset$[ebp]
  001eb	51		 push	 ecx
  001ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _column_index$[ebp]
  001f4	83 c1 01	 add	 ecx, 1
  001f7	51		 push	 ecx
  001f8	e8 00 00 00 00	 call	 ?SetColumnOffset@ImGui@@YAXHM@Z ; ImGui::SetColumnOffset
  001fd	83 c4 08	 add	 esp, 8
$LN4@SetColumnO:

; 7335 : }

  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx
  00203	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  00209	3b ec		 cmp	 ebp, esp
  0020b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
?SetColumnOffset@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnOffset@ImGui@@YAMH@Z
_TEXT	SEGMENT
_x_offset$ = -44					; size = 4
_t$ = -32						; size = 4
_columns$ = -20						; size = 4
_window$ = -8						; size = 4
_column_index$ = 8					; size = 4
?GetColumnOffset@ImGui@@YAMH@Z PROC			; ImGui::GetColumnOffset, COMDAT

; 7274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7275 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7276 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  00039	89 4d ec	 mov	 DWORD PTR _columns$[ebp], ecx

; 7277 :     if (columns == NULL)

  0003c	83 7d ec 00	 cmp	 DWORD PTR _columns$[ebp], 0
  00040	75 07		 jne	 SHORT $LN2@GetColumnO

; 7278 :         return 0.0f;

  00042	d9 ee		 fldz
  00044	e9 8d 00 00 00	 jmp	 $LN1@GetColumnO
$LN2@GetColumnO:

; 7279 : 
; 7280 :     if (column_index < 0)

  00049	83 7d 08 00	 cmp	 DWORD PTR _column_index$[ebp], 0
  0004d	7d 09		 jge	 SHORT $LN3@GetColumnO

; 7281 :         column_index = columns->Current;

  0004f	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  00052	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00055	89 4d 08	 mov	 DWORD PTR _column_index$[ebp], ecx
$LN3@GetColumnO:

; 7282 :     IM_ASSERT(column_index < columns->Columns.Size);

  00058	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _column_index$[ebp]
  0005e	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00061	7c 26		 jl	 SHORT $LN5@GetColumnO
  00063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??GetColumnOffset@ImGui@@YAMH@Z@4JA
  00069	83 c2 08	 add	 edx, 8
  0006c	8b f4		 mov	 esi, esp
  0006e	52		 push	 edx
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@FCGFMMCK@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@GetColumnO:

; 7283 : 
; 7284 :     const float t = columns->Columns[column_index].OffsetNorm;

  00089	8b 45 08	 mov	 eax, DWORD PTR _column_index$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d ec	 mov	 ecx, DWORD PTR _columns$[ebp]
  00090	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00093	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00098	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0009c	f3 0f 11 45 e0	 movss	 DWORD PTR _t$[ebp], xmm0

; 7285 :     const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);

  000a1	51		 push	 ecx
  000a2	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _t$[ebp]
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  000af	51		 push	 ecx
  000b0	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _columns$[ebp]
  000bd	51		 push	 ecx
  000be	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [ecx+20]
  000c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c8	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	d9 5d d4	 fstp	 DWORD PTR _x_offset$[ebp]

; 7286 :     return x_offset;

  000d3	d9 45 d4	 fld	 DWORD PTR _x_offset$[ebp]
$LN1@GetColumnO:

; 7287 : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000df	3b ec		 cmp	 ebp, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?GetColumnOffset@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SetColumnWidth@ImGui@@YAXHM@Z
_TEXT	SEGMENT
tv95 = -220						; size = 4
_columns$ = -20						; size = 4
_window$ = -8						; size = 4
_column_index$ = 8					; size = 4
_width$ = 12						; size = 4
?SetColumnWidth@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnWidth, COMDAT

; 7338 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7339 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7340 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  00039	89 4d ec	 mov	 DWORD PTR _columns$[ebp], ecx

; 7341 :     IM_ASSERT(columns != NULL);

  0003c	83 7d ec 00	 cmp	 DWORD PTR _columns$[ebp], 0
  00040	75 25		 jne	 SHORT $LN4@SetColumnW
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??SetColumnWidth@ImGui@@YAXHM@Z@4JA
  00047	83 c0 03	 add	 eax, 3
  0004a	8b f4		 mov	 esi, esp
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@FLGDBJKG@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@SetColumnW:

; 7342 : 
; 7343 :     if (column_index < 0)

  00067	83 7d 08 00	 cmp	 DWORD PTR _column_index$[ebp], 0
  0006b	7d 09		 jge	 SHORT $LN2@SetColumnW

; 7344 :         column_index = columns->Current;

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _columns$[ebp]
  00070	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00073	89 4d 08	 mov	 DWORD PTR _column_index$[ebp], ecx
$LN2@SetColumnW:

; 7345 :     SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);

  00076	8b 45 08	 mov	 eax, DWORD PTR _column_index$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  0007f	83 c4 04	 add	 esp, 4
  00082	d9 9d 24 ff ff
	ff		 fstp	 DWORD PTR tv95[ebp]
  00088	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv95[ebp]
  00090	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _width$[ebp]
  00095	51		 push	 ecx
  00096	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _column_index$[ebp]
  0009e	83 c1 01	 add	 ecx, 1
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ?SetColumnOffset@ImGui@@YAXHM@Z ; ImGui::SetColumnOffset
  000a7	83 c4 08	 add	 esp, 8

; 7346 : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?SetColumnWidth@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnWidth@ImGui@@YAMH@Z
_TEXT	SEGMENT
$T1 = -240						; size = 8
_columns$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
_column_index$ = 8					; size = 4
?GetColumnWidth@ImGui@@YAMH@Z PROC			; ImGui::GetColumnWidth, COMDAT

; 7303 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7304 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 7305 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 7306 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003f	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  00045	89 4d e0	 mov	 DWORD PTR _columns$[ebp], ecx

; 7307 :     if (columns == NULL)

  00048	83 7d e0 00	 cmp	 DWORD PTR _columns$[ebp], 0
  0004c	75 13		 jne	 SHORT $LN2@GetColumnW

; 7308 :         return GetContentRegionAvail().x;

  0004e	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
  0005a	83 c4 04	 add	 esp, 4
  0005d	d9 00		 fld	 DWORD PTR [eax]
  0005f	eb 4c		 jmp	 SHORT $LN1@GetColumnW
$LN2@GetColumnW:

; 7309 : 
; 7310 :     if (column_index < 0)

  00061	83 7d 08 00	 cmp	 DWORD PTR _column_index$[ebp], 0
  00065	7d 09		 jge	 SHORT $LN3@GetColumnW

; 7311 :         column_index = columns->Current;

  00067	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  0006a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006d	89 4d 08	 mov	 DWORD PTR _column_index$[ebp], ecx
$LN3@GetColumnW:

; 7312 :     return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

  00070	8b 45 08	 mov	 eax, DWORD PTR _column_index$[ebp]
  00073	83 c0 01	 add	 eax, 1
  00076	50		 push	 eax
  00077	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  0007a	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0007d	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00082	8b f0		 mov	 esi, eax
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _column_index$[ebp]
  00087	51		 push	 ecx
  00088	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  0008b	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0008e	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
  00093	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00097	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0009b	51		 push	 ecx
  0009c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a1	8b 55 e0	 mov	 edx, DWORD PTR _columns$[ebp]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ?GetColumnOffsetFromNorm@ImGui@@YAMPBUImGuiColumns@@M@Z ; ImGui::GetColumnOffsetFromNorm
  000aa	83 c4 08	 add	 esp, 8
$LN1@GetColumnW:

; 7313 : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?GetColumnWidth@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetColumnIndex@ImGui@@YAHXZ
_TEXT	SEGMENT
tv71 = -208						; size = 4
_window$ = -8						; size = 4
?GetColumnIndex@ImGui@@YAHXZ PROC			; ImGui::GetColumnIndex, COMDAT

; 7233 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7234 :     ImGuiWindow* window = GetCurrentWindowRead();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7235 :     return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  0003a	74 14		 je	 SHORT $LN3@GetColumnI
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0003f	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [ecx+448]
  00045	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00048	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  0004e	eb 0a		 jmp	 SHORT $LN4@GetColumnI
$LN3@GetColumnI:
  00050	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN4@GetColumnI:
  0005a	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]

; 7236 : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?GetColumnIndex@ImGui@@YAHXZ ENDP			; ImGui::GetColumnIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?NextColumn@ImGui@@YAXXZ
_TEXT	SEGMENT
tv269 = -296						; size = 4
tv143 = -296						; size = 4
$T1 = -288						; size = 8
_width$ = -80						; size = 4
_offset_1$ = -68					; size = 4
_offset_0$ = -56					; size = 4
_column_padding$ = -44					; size = 4
_columns$ = -32						; size = 4
_g$ = -20						; size = 4
_window$ = -8						; size = 4
?NextColumn@ImGui@@YAXXZ PROC				; ImGui::NextColumn, COMDAT

; 7486 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7487 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7488 :     if (window->SkipItems || window->DC.CurrentColumns == NULL)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	75 0c		 jne	 SHORT $LN3@NextColumn
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0003e	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  00045	75 05		 jne	 SHORT $LN2@NextColumn
$LN3@NextColumn:

; 7489 :         return;

  00047	e9 93 02 00 00	 jmp	 $LN1@NextColumn
$LN2@NextColumn:

; 7490 : 
; 7491 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 7492 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00057	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  0005d	89 4d e0	 mov	 DWORD PTR _columns$[ebp], ecx

; 7493 : 
; 7494 :     if (columns->Count == 1)

  00060	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00063	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00067	75 65		 jne	 SHORT $LN4@NextColumn

; 7495 :     {
; 7496 :         window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  00069	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0006f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00074	f3 0f 58 81 b4
	01 00 00	 addss	 xmm0, DWORD PTR [ecx+436]
  0007c	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  0007f	f3 0f 58 82 bc
	01 00 00	 addss	 xmm0, DWORD PTR [edx+444]
  00087	f3 0f 2c c0	 cvttss2si eax, xmm0
  0008b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  00092	f3 0f 11 81 c8
	00 00 00	 movss	 DWORD PTR [ecx+200], xmm0

; 7497 :         IM_ASSERT(columns->Current == 0);

  0009a	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  0009d	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000a1	74 26		 je	 SHORT $LN8@NextColumn
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??NextColumn@ImGui@@YAXXZ@4JA
  000a9	83 c1 0b	 add	 ecx, 11			; 0000000bH
  000ac	8b f4		 mov	 esi, esp
  000ae	51		 push	 ecx
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@HCFAHNAF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn@
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	3b f4		 cmp	 esi, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@NextColumn:

; 7498 :         return;

  000c9	e9 11 02 00 00	 jmp	 $LN1@NextColumn
$LN4@NextColumn:

; 7499 :     }
; 7500 :     PopItemWidth();

  000ce	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 7501 :     PopClipRect();

  000d3	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect

; 7502 : 
; 7503 :     const float column_padding = g.Style.ItemSpacing.x;

  000d8	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  000db	f3 0f 10 80 58
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5464]
  000e3	f3 0f 11 45 d4	 movss	 DWORD PTR _column_padding$[ebp], xmm0

; 7504 :     columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);

  000e8	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  000eb	51		 push	 ecx
  000ec	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  000f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f9	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  000fc	51		 push	 ecx
  000fd	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [ecx+32]
  00102	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00107	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0010c	83 c4 08	 add	 esp, 8
  0010f	8b 55 e0	 mov	 edx, DWORD PTR _columns$[ebp]
  00112	d9 5a 20	 fstp	 DWORD PTR [edx+32]

; 7505 :     if (++columns->Current < columns->Count)

  00115	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00118	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0011b	83 c1 01	 add	 ecx, 1
  0011e	89 8d d8 fe ff
	ff		 mov	 DWORD PTR tv143[ebp], ecx
  00124	8b 55 e0	 mov	 edx, DWORD PTR _columns$[ebp]
  00127	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  0012d	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00130	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  00133	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv143[ebp]
  00139	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0013c	7d 52		 jge	 SHORT $LN5@NextColumn

; 7506 :     {
; 7507 :         // Columns 1+ ignore IndentX (by canceling it out)
; 7508 :         // FIXME-COLUMNS: Unnecessary, could be locked?
; 7509 :         window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;

  0013e	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00141	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  0014a	83 c4 04	 add	 esp, 4
  0014d	d9 9d d8 fe ff
	ff		 fstp	 DWORD PTR tv269[ebp]
  00153	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR tv269[ebp]
  0015b	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  0015e	f3 0f 5c 82 b4
	01 00 00	 subss	 xmm0, DWORD PTR [edx+436]
  00166	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _column_padding$[ebp]
  0016b	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0016e	f3 0f 11 80 bc
	01 00 00	 movss	 DWORD PTR [eax+444], xmm0

; 7510 :         window->DrawList->ChannelsSetCurrent(columns->Current + 1);

  00176	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00179	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0017c	83 c1 01	 add	 ecx, 1
  0017f	51		 push	 ecx
  00180	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  00183	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  00189	e8 00 00 00 00	 call	 ?ChannelsSetCurrent@ImDrawList@@QAEXH@Z ; ImDrawList::ChannelsSetCurrent

; 7511 :     }

  0018e	eb 53		 jmp	 SHORT $LN6@NextColumn
$LN5@NextColumn:

; 7512 :     else
; 7513 :     {
; 7514 :         // New row/line
; 7515 :         // Column 0 honor IndentX
; 7516 :         window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);

  00190	51		 push	 ecx
  00191	0f 57 c0	 xorps	 xmm0, xmm0
  00194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00199	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0019c	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _column_padding$[ebp]
  001a1	f3 0f 5c 40 34	 subss	 xmm0, DWORD PTR [eax+52]
  001a6	51		 push	 ecx
  001a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ac	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001b1	83 c4 08	 add	 esp, 8
  001b4	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  001b7	d9 99 bc 01 00
	00		 fstp	 DWORD PTR [ecx+444]

; 7517 :         window->DrawList->ChannelsSetCurrent(1);

  001bd	6a 01		 push	 1
  001bf	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  001c2	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  001c8	e8 00 00 00 00	 call	 ?ChannelsSetCurrent@ImDrawList@@QAEXH@Z ; ImDrawList::ChannelsSetCurrent

; 7518 :         columns->Current = 0;

  001cd	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  001d0	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 7519 :         columns->LineMinY = columns->LineMaxY;

  001d7	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  001da	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  001dd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001e0	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN6@NextColumn:

; 7520 :     }
; 7521 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

  001e3	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  001e6	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  001e9	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001ee	f3 0f 58 81 b4
	01 00 00	 addss	 xmm0, DWORD PTR [ecx+436]
  001f6	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  001f9	f3 0f 58 82 bc
	01 00 00	 addss	 xmm0, DWORD PTR [edx+444]
  00201	f3 0f 2c c0	 cvttss2si eax, xmm0
  00205	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00209	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0020c	f3 0f 11 81 c8
	00 00 00	 movss	 DWORD PTR [ecx+200], xmm0

; 7522 :     window->DC.CursorPos.y = columns->LineMinY;

  00214	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00217	8b 4d e0	 mov	 ecx, DWORD PTR _columns$[ebp]
  0021a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0021d	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 7523 :     window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

  00223	51		 push	 ecx
  00224	0f 57 c0	 xorps	 xmm0, xmm0
  00227	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022c	51		 push	 ecx
  0022d	0f 57 c0	 xorps	 xmm0, xmm0
  00230	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00235	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0023b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00240	8b 08		 mov	 ecx, DWORD PTR [eax]
  00242	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00245	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00248	89 88 e8 00 00
	00		 mov	 DWORD PTR [eax+232], ecx
  0024e	89 90 ec 00 00
	00		 mov	 DWORD PTR [eax+236], edx

; 7524 :     window->DC.CurrLineTextBaseOffset = 0.0f;

  00254	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00257	0f 57 c0	 xorps	 xmm0, xmm0
  0025a	f3 0f 11 80 f8
	00 00 00	 movss	 DWORD PTR [eax+248], xmm0

; 7525 : 
; 7526 :     PushColumnClipRect(columns->Current);     // FIXME-COLUMNS: Could it be an overwrite?

  00262	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00265	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00268	51		 push	 ecx
  00269	e8 00 00 00 00	 call	 ?PushColumnClipRect@ImGui@@YAXH@Z ; ImGui::PushColumnClipRect
  0026e	83 c4 04	 add	 esp, 4

; 7527 : 
; 7528 :     // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
; 7529 :     float offset_0 = GetColumnOffset(columns->Current);

  00271	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00274	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00277	51		 push	 ecx
  00278	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  0027d	83 c4 04	 add	 esp, 4
  00280	d9 5d c8	 fstp	 DWORD PTR _offset_0$[ebp]

; 7530 :     float offset_1 = GetColumnOffset(columns->Current + 1);

  00283	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00286	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00289	83 c1 01	 add	 ecx, 1
  0028c	51		 push	 ecx
  0028d	e8 00 00 00 00	 call	 ?GetColumnOffset@ImGui@@YAMH@Z ; ImGui::GetColumnOffset
  00292	83 c4 04	 add	 esp, 4
  00295	d9 5d bc	 fstp	 DWORD PTR _offset_1$[ebp]

; 7531 :     float width = offset_1 - offset_0;

  00298	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _offset_1$[ebp]
  0029d	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _offset_0$[ebp]
  002a2	f3 0f 11 45 b0	 movss	 DWORD PTR _width$[ebp], xmm0

; 7532 :     PushItemWidth(width * 0.65f);

  002a7	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _width$[ebp]
  002ac	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f266666
  002b4	51		 push	 ecx
  002b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ba	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth
  002bf	83 c4 04	 add	 esp, 4

; 7533 :     window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;

  002c2	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  002c5	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  002ca	f3 0f 58 45 bc	 addss	 xmm0, DWORD PTR _offset_1$[ebp]
  002cf	f3 0f 5c 45 d4	 subss	 xmm0, DWORD PTR _column_padding$[ebp]
  002d4	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  002d7	f3 0f 11 81 fc
	01 00 00	 movss	 DWORD PTR [ecx+508], xmm0
$LN1@NextColumn:

; 7534 : }

  002df	5f		 pop	 edi
  002e0	5e		 pop	 esi
  002e1	5b		 pop	 ebx
  002e2	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  002e8	3b ec		 cmp	 ebp, esp
  002ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ef	8b e5		 mov	 esp, ebp
  002f1	5d		 pop	 ebp
  002f2	c3		 ret	 0
?NextColumn@ImGui@@YAXXZ ENDP				; ImGui::NextColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Columns@ImGui@@YAXHPBD_N@Z
_TEXT	SEGMENT
tv73 = -232						; size = 4
_columns$ = -32						; size = 4
_flags$ = -20						; size = 4
_window$ = -8						; size = 4
_columns_count$ = 8					; size = 4
_id$ = 12						; size = 4
_border$ = 16						; size = 1
?Columns@ImGui@@YAXHPBD_N@Z PROC			; ImGui::Columns, COMDAT

; 7613 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7614 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 7615 :     IM_ASSERT(columns_count >= 1);

  00030	83 7d 08 01	 cmp	 DWORD PTR _columns_count$[ebp], 1
  00034	7d 25		 jge	 SHORT $LN6@Columns
  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??Columns@ImGui@@YAXHPBD_N@Z@4JA
  0003b	83 c0 02	 add	 eax, 2
  0003e	8b f4		 mov	 esi, esp
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@GDAJJGIO@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA_?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	3b f4		 cmp	 esi, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@Columns:

; 7616 : 
; 7617 :     ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);

  0005b	0f b6 45 10	 movzx	 eax, BYTE PTR _border$[ebp]
  0005f	85 c0		 test	 eax, eax
  00061	74 0c		 je	 SHORT $LN7@Columns
  00063	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
  0006d	eb 0a		 jmp	 SHORT $LN8@Columns
$LN7@Columns:
  0006f	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv73[ebp], 1
$LN8@Columns:
  00079	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0007f	89 4d ec	 mov	 DWORD PTR _flags$[ebp], ecx

; 7618 :     //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
; 7619 :     ImGuiColumns* columns = window->DC.CurrentColumns;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00085	8b 88 c0 01 00
	00		 mov	 ecx, DWORD PTR [eax+448]
  0008b	89 4d e0	 mov	 DWORD PTR _columns$[ebp], ecx

; 7620 :     if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)

  0008e	83 7d e0 00	 cmp	 DWORD PTR _columns$[ebp], 0
  00092	74 18		 je	 SHORT $LN2@Columns
  00094	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  00097	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0009a	3b 4d 08	 cmp	 ecx, DWORD PTR _columns_count$[ebp]
  0009d	75 0d		 jne	 SHORT $LN2@Columns
  0009f	8b 45 e0	 mov	 eax, DWORD PTR _columns$[ebp]
  000a2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a5	3b 4d ec	 cmp	 ecx, DWORD PTR _flags$[ebp]
  000a8	75 02		 jne	 SHORT $LN2@Columns

; 7621 :         return;

  000aa	eb 25		 jmp	 SHORT $LN1@Columns
$LN2@Columns:

; 7622 : 
; 7623 :     if (columns != NULL)

  000ac	83 7d e0 00	 cmp	 DWORD PTR _columns$[ebp], 0
  000b0	74 05		 je	 SHORT $LN3@Columns

; 7624 :         EndColumns();

  000b2	e8 00 00 00 00	 call	 ?EndColumns@ImGui@@YAXXZ ; ImGui::EndColumns
$LN3@Columns:

; 7625 : 
; 7626 :     if (columns_count != 1)

  000b7	83 7d 08 01	 cmp	 DWORD PTR _columns_count$[ebp], 1
  000bb	74 14		 je	 SHORT $LN1@Columns

; 7627 :         BeginColumns(id, columns_count, flags);

  000bd	8b 45 ec	 mov	 eax, DWORD PTR _flags$[ebp]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _columns_count$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 55 0c	 mov	 edx, DWORD PTR _id$[ebp]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 ?BeginColumns@ImGui@@YAXPBDHH@Z ; ImGui::BeginColumns
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Columns:

; 7628 : }

  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000da	3b ec		 cmp	 ebp, esp
  000dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?Columns@ImGui@@YAXHPBD_N@Z ENDP			; ImGui::Columns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z
_TEXT	SEGMENT
tv76 = -196						; size = 4
tv67 = -193						; size = 1
_label$ = 8						; size = 4
_shortcut$ = 12						; size = 4
_p_selected$ = 16					; size = 4
_enabled$ = 20						; size = 1
?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z PROC			; ImGui::MenuItem, COMDAT

; 6324 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6325 :     if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))

  00028	83 7d 10 00	 cmp	 DWORD PTR _p_selected$[ebp], 0
  0002c	74 0d		 je	 SHORT $LN5@MenuItem
  0002e	8b 45 10	 mov	 eax, DWORD PTR _p_selected$[ebp]
  00031	8a 08		 mov	 cl, BYTE PTR [eax]
  00033	88 8d 3f ff ff
	ff		 mov	 BYTE PTR tv67[ebp], cl
  00039	eb 07		 jmp	 SHORT $LN6@MenuItem
$LN5@MenuItem:
  0003b	c6 85 3f ff ff
	ff 00		 mov	 BYTE PTR tv67[ebp], 0
$LN6@MenuItem:
  00042	0f b6 55 14	 movzx	 edx, BYTE PTR _enabled$[ebp]
  00046	52		 push	 edx
  00047	0f b6 85 3f ff
	ff ff		 movzx	 eax, BYTE PTR tv67[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _shortcut$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?MenuItem@ImGui@@YA_NPBD0_N1@Z ; ImGui::MenuItem
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	0f b6 c0	 movzx	 eax, al
  00062	85 c0		 test	 eax, eax
  00064	74 35		 je	 SHORT $LN2@MenuItem

; 6326 :     {
; 6327 :         if (p_selected)

  00066	83 7d 10 00	 cmp	 DWORD PTR _p_selected$[ebp], 0
  0006a	74 2b		 je	 SHORT $LN3@MenuItem

; 6328 :             *p_selected = !*p_selected;

  0006c	8b 45 10	 mov	 eax, DWORD PTR _p_selected$[ebp]
  0006f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00072	85 c9		 test	 ecx, ecx
  00074	75 0c		 jne	 SHORT $LN7@MenuItem
  00076	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv76[ebp], 1
  00080	eb 0a		 jmp	 SHORT $LN8@MenuItem
$LN7@MenuItem:
  00082	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN8@MenuItem:
  0008c	8b 55 10	 mov	 edx, DWORD PTR _p_selected$[ebp]
  0008f	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv76[ebp]
  00095	88 02		 mov	 BYTE PTR [edx], al
$LN3@MenuItem:

; 6329 :         return true;

  00097	b0 01		 mov	 al, 1
  00099	eb 02		 jmp	 SHORT $LN1@MenuItem
$LN2@MenuItem:

; 6330 :     }
; 6331 :     return false;

  0009b	32 c0		 xor	 al, al
$LN1@MenuItem:

; 6332 : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z ENDP			; ImGui::MenuItem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?MenuItem@ImGui@@YA_NPBD0_N1@Z
_TEXT	SEGMENT
tv239 = -516						; size = 4
tv174 = -516						; size = 4
tv79 = -516						; size = 4
$T1 = -508						; size = 8
$T2 = -492						; size = 8
$T3 = -476						; size = 8
$T4 = -460						; size = 8
$T5 = -444						; size = 8
$T6 = -428						; size = 8
$T7 = -412						; size = 8
$T8 = -396						; size = 8
$T9 = -380						; size = 4
$T10 = -368						; size = 8
$T11 = -352						; size = 8
_extra_w$12 = -144					; size = 4
_w$13 = -132						; size = 4
_shortcut_size$14 = -120				; size = 8
_w$15 = -104						; size = 4
_pressed$ = -89						; size = 1
_flags$ = -80						; size = 4
_label_size$ = -68					; size = 8
_pos$ = -52						; size = 8
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_shortcut$ = 12						; size = 4
_selected$ = 16						; size = 1
_enabled$ = 20						; size = 1
?MenuItem@ImGui@@YA_NPBD0_N1@Z PROC			; ImGui::MenuItem, COMDAT

; 6278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR [ebp-516]
  00012	b9 81 00 00 00	 mov	 ecx, 129		; 00000081H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6279 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 6280 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN5@MenuItem

; 6281 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 27 04 00 00	 jmp	 $LN1@MenuItem
$LN5@MenuItem:

; 6282 : 
; 6283 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 6284 :     ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 6285 :     ImVec2 pos = window->DC.CursorPos;

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00062	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00068	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  0006e	89 4d cc	 mov	 DWORD PTR _pos$[ebp], ecx
  00071	89 55 d0	 mov	 DWORD PTR _pos$[ebp+4], edx

; 6286 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

  00074	51		 push	 ecx
  00075	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0007d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00082	6a 01		 push	 1
  00084	6a 00		 push	 0
  00086	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00089	50		 push	 eax
  0008a	8d 4d bc	 lea	 ecx, DWORD PTR _label_size$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00093	83 c4 14	 add	 esp, 20			; 00000014H

; 6287 : 
; 6288 :     // We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),
; 6289 :     // but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.
; 6290 :     ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | ImGuiSelectableFlags_SetNavIdOnHover | (enabled ? 0 : ImGuiSelectableFlags_Disabled);

  00096	0f b6 45 14	 movzx	 eax, BYTE PTR _enabled$[ebp]
  0009a	85 c0		 test	 eax, eax
  0009c	74 0c		 je	 SHORT $LN11@MenuItem
  0009e	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
  000a8	eb 0a		 jmp	 SHORT $LN12@MenuItem
$LN11@MenuItem:
  000aa	c7 85 fc fd ff
	ff 08 00 00 00	 mov	 DWORD PTR tv79[ebp], 8
$LN12@MenuItem:
  000b4	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  000ba	81 c9 00 00 40
	02		 or	 ecx, 37748736		; 02400000H
  000c0	89 4d b0	 mov	 DWORD PTR _flags$[ebp], ecx

; 6291 :     bool pressed;
; 6292 :     if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000c6	83 b8 5c 01 00
	00 00		 cmp	 DWORD PTR [eax+348], 0
  000cd	0f 85 e4 00 00
	00		 jne	 $LN6@MenuItem

; 6293 :     {
; 6294 :         // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
; 6295 :         // Note that in this situation we render neither the shortcut neither the selected tick mark
; 6296 :         float w = label_size.x;

  000d3	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  000d8	f3 0f 11 45 98	 movss	 DWORD PTR _w$15[ebp], xmm0

; 6297 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * 0.5f);

  000dd	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000e0	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  000e5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000ed	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000f1	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000f5	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  000f8	f3 0f 58 82 c8
	00 00 00	 addss	 xmm0, DWORD PTR [edx+200]
  00100	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00103	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0

; 6298 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));

  0010b	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0010e	51		 push	 ecx
  0010f	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [eax+76]
  00114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00119	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  0011c	f3 0f 10 41 48	 movss	 xmm0, DWORD PTR [ecx+72]
  00121	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00129	51		 push	 ecx
  0012a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012f	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00135	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0013a	50		 push	 eax
  0013b	6a 0d		 push	 13			; 0000000dH
  0013d	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z ; ImGui::PushStyleVar
  00142	83 c4 08	 add	 esp, 8

; 6299 :         pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));

  00145	51		 push	 ecx
  00146	0f 57 c0	 xorps	 xmm0, xmm0
  00149	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014e	51		 push	 ecx
  0014f	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _w$15[ebp]
  00154	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00159	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0015f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00164	50		 push	 eax
  00165	8b 45 b0	 mov	 eax, DWORD PTR _flags$[ebp]
  00168	50		 push	 eax
  00169	6a 00		 push	 0
  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0016e	51		 push	 ecx
  0016f	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  00174	83 c4 10	 add	 esp, 16			; 00000010H
  00177	88 45 a7	 mov	 BYTE PTR _pressed$[ebp], al

; 6300 :         PopStyleVar();

  0017a	6a 01		 push	 1
  0017c	e8 00 00 00 00	 call	 ?PopStyleVar@ImGui@@YAXH@Z ; ImGui::PopStyleVar
  00181	83 c4 04	 add	 esp, 4

; 6301 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().

  00184	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00187	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  0018c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf000000
  00194	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00198	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0019c	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  0019f	f3 0f 58 82 c8
	00 00 00	 addss	 xmm0, DWORD PTR [edx+200]
  001a7	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  001aa	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0

; 6302 :     }

  001b2	e9 b5 02 00 00	 jmp	 $LN9@MenuItem
$LN6@MenuItem:

; 6303 :     else
; 6304 :     {
; 6305 :         ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);

  001b7	83 7d 0c 00	 cmp	 DWORD PTR _shortcut$[ebp], 0
  001bb	74 2d		 je	 SHORT $LN13@MenuItem
  001bd	51		 push	 ecx
  001be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001cb	6a 00		 push	 0
  001cd	6a 00		 push	 0
  001cf	8b 45 0c	 mov	 eax, DWORD PTR _shortcut$[ebp]
  001d2	50		 push	 eax
  001d3	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  001d9	51		 push	 ecx
  001da	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  001df	83 c4 14	 add	 esp, 20			; 00000014H
  001e2	89 85 fc fd ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  001e8	eb 23		 jmp	 SHORT $LN14@MenuItem
$LN13@MenuItem:
  001ea	51		 push	 ecx
  001eb	0f 57 c0	 xorps	 xmm0, xmm0
  001ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f3	51		 push	 ecx
  001f4	0f 57 c0	 xorps	 xmm0, xmm0
  001f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fc	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00202	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00207	89 85 fc fd ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
$LN14@MenuItem:
  0020d	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR tv174[ebp]
  00213	89 95 84 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], edx
  00219	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  0021f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00221	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00224	89 4d 88	 mov	 DWORD PTR _shortcut_size$14[ebp], ecx
  00227	89 55 8c	 mov	 DWORD PTR _shortcut_size$14[ebp+4], edx

; 6306 :         float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, IM_FLOOR(g.FontSize * 1.20f)); // Feedback for next frame

  0022a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0022d	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00235	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f99999a
  0023d	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00241	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00245	51		 push	 ecx
  00246	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0024b	51		 push	 ecx
  0024c	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _shortcut_size$14[ebp]
  00251	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00256	51		 push	 ecx
  00257	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  0025c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00261	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00264	81 c1 30 02 00
	00		 add	 ecx, 560		; 00000230H
  0026a	e8 00 00 00 00	 call	 ?DeclColumns@ImGuiMenuColumns@@QAEMMMM@Z ; ImGuiMenuColumns::DeclColumns
  0026f	d9 9d 7c ff ff
	ff		 fstp	 DWORD PTR _w$13[ebp]

; 6307 :         float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);

  00275	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0027b	50		 push	 eax
  0027c	e8 00 00 00 00	 call	 ?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
  00281	83 c4 04	 add	 esp, 4
  00284	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00288	f3 0f 5c 85 7c
	ff ff ff	 subss	 xmm0, DWORD PTR _w$13[ebp]
  00290	51		 push	 ecx
  00291	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00296	51		 push	 ecx
  00297	0f 57 c0	 xorps	 xmm0, xmm0
  0029a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029f	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002a4	83 c4 08	 add	 esp, 8
  002a7	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _extra_w$12[ebp]

; 6308 :         pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));

  002ad	51		 push	 ecx
  002ae	0f 57 c0	 xorps	 xmm0, xmm0
  002b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b6	51		 push	 ecx
  002b7	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _w$13[ebp]
  002bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c4	8d 8d 44 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002ca	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002cf	50		 push	 eax
  002d0	8b 45 b0	 mov	 eax, DWORD PTR _flags$[ebp]
  002d3	0d 00 00 80 00	 or	 eax, 8388608		; 00800000H
  002d8	50		 push	 eax
  002d9	6a 00		 push	 0
  002db	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  002de	51		 push	 ecx
  002df	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  002e4	83 c4 10	 add	 esp, 16			; 00000010H
  002e7	88 45 a7	 mov	 BYTE PTR _pressed$[ebp], al

; 6309 :         if (shortcut_size.x > 0.0f)

  002ea	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _shortcut_size$14[ebp]
  002ef	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002f6	0f 86 88 00 00
	00		 jbe	 $LN8@MenuItem

; 6310 :         {
; 6311 :             PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

  002fc	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00301	c1 e0 00	 shl	 eax, 0
  00304	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00307	8d 94 01 c0 15
	00 00		 lea	 edx, DWORD PTR [ecx+eax+5568]
  0030e	52		 push	 edx
  0030f	6a 00		 push	 0
  00311	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  00316	83 c4 08	 add	 esp, 8

; 6312 :             RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);

  00319	6a 00		 push	 0
  0031b	6a 00		 push	 0
  0031d	8b 45 0c	 mov	 eax, DWORD PTR _shortcut$[ebp]
  00320	50		 push	 eax
  00321	51		 push	 ecx
  00322	0f 57 c0	 xorps	 xmm0, xmm0
  00325	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032a	b9 04 00 00 00	 mov	 ecx, 4
  0032f	c1 e1 00	 shl	 ecx, 0
  00332	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00335	f3 0f 10 84 0a
	3c 02 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+572]
  0033e	f3 0f 58 85 70
	ff ff ff	 addss	 xmm0, DWORD PTR _extra_w$12[ebp]
  00346	51		 push	 ecx
  00347	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034c	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00352	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00357	50		 push	 eax
  00358	8d 45 cc	 lea	 eax, DWORD PTR _pos$[ebp]
  0035b	50		 push	 eax
  0035c	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00362	51		 push	 ecx
  00363	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00368	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0036e	52		 push	 edx
  0036f	8b 00		 mov	 eax, DWORD PTR [eax]
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  00377	83 c4 14	 add	 esp, 20			; 00000014H

; 6313 :             PopStyleColor();

  0037a	6a 01		 push	 1
  0037c	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor
  00381	83 c4 04	 add	 esp, 4
$LN8@MenuItem:

; 6314 :         }
; 6315 :         if (selected)

  00384	0f b6 45 10	 movzx	 eax, BYTE PTR _selected$[ebp]
  00388	85 c0		 test	 eax, eax
  0038a	0f 84 dc 00 00
	00		 je	 $LN9@MenuItem

; 6316 :             RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);

  00390	0f b6 45 14	 movzx	 eax, BYTE PTR _enabled$[ebp]
  00394	85 c0		 test	 eax, eax
  00396	74 0c		 je	 SHORT $LN15@MenuItem
  00398	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv239[ebp], 0
  003a2	eb 0a		 jmp	 SHORT $LN16@MenuItem
$LN15@MenuItem:
  003a4	c7 85 fc fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv239[ebp], 1
$LN16@MenuItem:
  003ae	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  003b1	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  003b9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f5db22d
  003c1	51		 push	 ecx
  003c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c7	51		 push	 ecx
  003c8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d5	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR tv239[ebp]
  003db	52		 push	 edx
  003dc	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  003e1	83 c4 08	 add	 esp, 8
  003e4	50		 push	 eax
  003e5	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  003e8	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  003f0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e09374c
  003f8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00400	51		 push	 ecx
  00401	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00406	b9 04 00 00 00	 mov	 ecx, 4
  0040b	d1 e1		 shl	 ecx, 1
  0040d	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00410	f3 0f 10 84 0a
	3c 02 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+572]
  00419	f3 0f 58 85 70
	ff ff ff	 addss	 xmm0, DWORD PTR _extra_w$12[ebp]
  00421	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00424	f3 0f 10 88 c4
	18 00 00	 movss	 xmm1, DWORD PTR [eax+6340]
  0042c	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3ecccccd
  00434	f3 0f 58 c1	 addss	 xmm0, xmm1
  00438	51		 push	 ecx
  00439	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0043e	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00444	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00449	50		 push	 eax
  0044a	8d 4d cc	 lea	 ecx, DWORD PTR _pos$[ebp]
  0044d	51		 push	 ecx
  0044e	8d 95 04 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00454	52		 push	 edx
  00455	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0045a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0045d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00460	51		 push	 ecx
  00461	8b 10		 mov	 edx, DWORD PTR [eax]
  00463	52		 push	 edx
  00464	e8 00 00 00 00	 call	 ?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z ; ImGui::RenderCheckMark
  00469	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@MenuItem:

; 6317 :     }
; 6318 : 
; 6319 :     IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));

  0046c	33 c0		 xor	 eax, eax
  0046e	75 fc		 jne	 SHORT $LN9@MenuItem

; 6320 :     return pressed;

  00470	8a 45 a7	 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@MenuItem:

; 6321 : }

  00473	52		 push	 edx
  00474	8b cd		 mov	 ecx, ebp
  00476	50		 push	 eax
  00477	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@MenuItem
  0047d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00482	58		 pop	 eax
  00483	5a		 pop	 edx
  00484	5f		 pop	 edi
  00485	5e		 pop	 esi
  00486	5b		 pop	 ebx
  00487	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0048a	33 cd		 xor	 ecx, ebp
  0048c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00491	81 c4 04 02 00
	00		 add	 esp, 516		; 00000204H
  00497	3b ec		 cmp	 ebp, esp
  00499	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0049e	8b e5		 mov	 esp, ebp
  004a0	5d		 pop	 ebp
  004a1	c3		 ret	 0
  004a2	66 90		 npad	 2
$LN21@MenuItem:
  004a4	03 00 00 00	 DD	 3
  004a8	00 00 00 00	 DD	 $LN20@MenuItem
$LN20@MenuItem:
  004ac	cc ff ff ff	 DD	 -52			; ffffffccH
  004b0	08 00 00 00	 DD	 8
  004b4	00 00 00 00	 DD	 $LN17@MenuItem
  004b8	bc ff ff ff	 DD	 -68			; ffffffbcH
  004bc	08 00 00 00	 DD	 8
  004c0	00 00 00 00	 DD	 $LN18@MenuItem
  004c4	88 ff ff ff	 DD	 -120			; ffffff88H
  004c8	08 00 00 00	 DD	 8
  004cc	00 00 00 00	 DD	 $LN19@MenuItem
$LN19@MenuItem:
  004d0	73		 DB	 115			; 00000073H
  004d1	68		 DB	 104			; 00000068H
  004d2	6f		 DB	 111			; 0000006fH
  004d3	72		 DB	 114			; 00000072H
  004d4	74		 DB	 116			; 00000074H
  004d5	63		 DB	 99			; 00000063H
  004d6	75		 DB	 117			; 00000075H
  004d7	74		 DB	 116			; 00000074H
  004d8	5f		 DB	 95			; 0000005fH
  004d9	73		 DB	 115			; 00000073H
  004da	69		 DB	 105			; 00000069H
  004db	7a		 DB	 122			; 0000007aH
  004dc	65		 DB	 101			; 00000065H
  004dd	00		 DB	 0
$LN18@MenuItem:
  004de	6c		 DB	 108			; 0000006cH
  004df	61		 DB	 97			; 00000061H
  004e0	62		 DB	 98			; 00000062H
  004e1	65		 DB	 101			; 00000065H
  004e2	6c		 DB	 108			; 0000006cH
  004e3	5f		 DB	 95			; 0000005fH
  004e4	73		 DB	 115			; 00000073H
  004e5	69		 DB	 105			; 00000069H
  004e6	7a		 DB	 122			; 0000007aH
  004e7	65		 DB	 101			; 00000065H
  004e8	00		 DB	 0
$LN17@MenuItem:
  004e9	70		 DB	 112			; 00000070H
  004ea	6f		 DB	 111			; 0000006fH
  004eb	73		 DB	 115			; 00000073H
  004ec	00		 DB	 0
?MenuItem@ImGui@@YA_NPBD0_N1@Z ENDP			; ImGui::MenuItem
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?EndMenu@ImGui@@YAXXZ
_TEXT	SEGMENT
_window$ = -20						; size = 4
_g$ = -8						; size = 4
?EndMenu@ImGui@@YAXXZ PROC				; ImGui::EndMenu, COMDAT

; 6262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6263 :     // Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
; 6264 :     // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
; 6265 :     // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
; 6266 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6267 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 6268 :     if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0003f	83 b8 d0 1a 00
	00 00		 cmp	 DWORD PTR [eax+6864], 0
  00046	74 51		 je	 SHORT $LN2@EndMenu
  00048	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0004b	8b 88 d0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6864]
  00051	8b 91 f0 02 00
	00		 mov	 edx, DWORD PTR [ecx+752]
  00057	3b 55 ec	 cmp	 edx, DWORD PTR _window$[ebp]
  0005a	75 3d		 jne	 SHORT $LN2@EndMenu
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0005f	83 b8 58 1b 00
	00 00		 cmp	 DWORD PTR [eax+7000], 0
  00066	75 31		 jne	 SHORT $LN2@EndMenu
  00068	e8 00 00 00 00	 call	 ?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ; ImGui::NavMoveRequestButNoResultYet
  0006d	0f b6 c0	 movzx	 eax, al
  00070	85 c0		 test	 eax, eax
  00072	74 25		 je	 SHORT $LN2@EndMenu
  00074	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00077	83 b8 5c 01 00
	00 01		 cmp	 DWORD PTR [eax+348], 1
  0007e	75 19		 jne	 SHORT $LN2@EndMenu

; 6269 :     {
; 6270 :         ClosePopupToLevel(g.BeginPopupStack.Size, true);

  00080	6a 01		 push	 1
  00082	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00085	8b 88 c4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6852]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ?ClosePopupToLevel@ImGui@@YAXH_N@Z ; ImGui::ClosePopupToLevel
  00091	83 c4 08	 add	 esp, 8

; 6271 :         NavMoveRequestCancel();

  00094	e8 00 00 00 00	 call	 ?NavMoveRequestCancel@ImGui@@YAXXZ ; ImGui::NavMoveRequestCancel
$LN2@EndMenu:

; 6272 :     }
; 6273 : 
; 6274 :     EndPopup();

  00099	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup

; 6275 : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?EndMenu@ImGui@@YAXXZ ENDP				; ImGui::EndMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginMenu@ImGui@@YA_NPBD_N@Z
_TEXT	SEGMENT
tv607 = -976						; size = 4
tv846 = -972						; size = 4
tv796 = -972						; size = 4
tv787 = -972						; size = 4
tv766 = -972						; size = 4
tv454 = -972						; size = 4
tv405 = -972						; size = 4
tv390 = -972						; size = 4
tv377 = -972						; size = 4
tv318 = -972						; size = 4
tv258 = -972						; size = 4
tv249 = -972						; size = 4
tv195 = -972						; size = 4
tv131 = -972						; size = 4
tv291 = -969						; size = 1
$T1 = -964						; size = 8
$T2 = -948						; size = 8
$T3 = -932						; size = 8
$T4 = -916						; size = 4
$T5 = -904						; size = 8
$T6 = -888						; size = 8
$T7 = -872						; size = 4
$T8 = -860						; size = 8
$T9 = -844						; size = 8
$T10 = -828						; size = 8
$T11 = -812						; size = 8
$T12 = -796						; size = 8
$T13 = -780						; size = 8
$T14 = -764						; size = 8
$T15 = -748						; size = 8
_flags$16 = -348					; size = 4
_extra$17 = -336					; size = 4
_tc$18 = -324						; size = 8
_tb$19 = -308						; size = 8
_ta$20 = -292						; size = 8
_next_window_rect$21 = -276				; size = 16
_child_menu_window$22 = -252				; size = 4
_moving_toward_other_child_menu$23 = -237		; size = 1
_want_close$ = -225					; size = 1
_want_open$ = -213					; size = 1
_hovered$ = -201					; size = 1
_text_col$24 = -192					; size = 4
_extra_w$25 = -180					; size = 4
_w$26 = -168						; size = 4
_w$27 = -156						; size = 4
_pos$ = -144						; size = 8
_popup_pos$ = -128					; size = 8
_backed_nav_window$ = -112				; size = 4
_menuset_is_open$ = -97					; size = 1
_menu_is_open$ = -85					; size = 1
_pressed$ = -73						; size = 1
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_enabled$ = 12						; size = 1
?BeginMenu@ImGui@@YA_NPBD_N@Z PROC			; ImGui::BeginMenu, COMDAT

; 6119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 03 00
	00		 sub	 esp, 976		; 000003d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 fc ff
	ff		 lea	 edi, DWORD PTR [ebp-976]
  00012	b9 f4 00 00 00	 mov	 ecx, 244		; 000000f4H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6120 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 6121 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN5@BeginMenu

; 6122 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 fb 0a 00 00	 jmp	 $LN1@BeginMenu
$LN5@BeginMenu:

; 6123 : 
; 6124 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 6125 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 6126 :     const ImGuiID id = window->GetID(label);

  0005f	6a 00		 push	 0
  00061	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00068	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0006d	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 6127 : 
; 6128 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

  00070	51		 push	 ecx
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	6a 01		 push	 1
  00080	6a 00		 push	 0
  00082	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00085	50		 push	 eax
  00086	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0008f	83 c4 14	 add	 esp, 20			; 00000014H

; 6129 : 
; 6130 :     bool pressed;
; 6131 :     bool menu_is_open = IsPopupOpen(id);

  00092	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?IsPopupOpen@ImGui@@YA_NI@Z ; ImGui::IsPopupOpen
  0009b	83 c4 04	 add	 esp, 4
  0009e	88 45 ab	 mov	 BYTE PTR _menu_is_open$[ebp], al

; 6132 :     bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].OpenParentId == window->IDStack.back());

  000a1	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a7	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  000ad	75 4f		 jne	 SHORT $LN32@BeginMenu
  000af	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  000b2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  000b5	8b 8a b8 1a 00
	00		 mov	 ecx, DWORD PTR [edx+6840]
  000bb	3b 88 c4 1a 00
	00		 cmp	 ecx, DWORD PTR [eax+6852]
  000c1	7e 3b		 jle	 SHORT $LN32@BeginMenu
  000c3	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  000c6	8b 82 c4 1a 00
	00		 mov	 eax, DWORD PTR [edx+6852]
  000cc	50		 push	 eax
  000cd	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  000d0	81 c1 b8 1a 00
	00		 add	 ecx, 6840		; 00001ab8H
  000d6	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiPopupData@@@@QAEAAUImGuiPopupData@@H@Z ; ImVector<ImGuiPopupData>::operator[]
  000db	8b f0		 mov	 esi, eax
  000dd	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000e0	81 c1 bc 00 00
	00		 add	 ecx, 188		; 000000bcH
  000e6	e8 00 00 00 00	 call	 ?back@?$ImVector@I@@QAEAAIXZ ; ImVector<unsigned int>::back
  000eb	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000ee	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000f0	75 0c		 jne	 SHORT $LN32@BeginMenu
  000f2	c7 85 34 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv131[ebp], 1
  000fc	eb 0a		 jmp	 SHORT $LN33@BeginMenu
$LN32@BeginMenu:
  000fe	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv131[ebp], 0
$LN33@BeginMenu:
  00108	8a 95 34 fc ff
	ff		 mov	 dl, BYTE PTR tv131[ebp]
  0010e	88 55 9f	 mov	 BYTE PTR _menuset_is_open$[ebp], dl

; 6133 :     ImGuiWindow* backed_nav_window = g.NavWindow;

  00111	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00114	8b 88 d0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6864]
  0011a	89 4d 90	 mov	 DWORD PTR _backed_nav_window$[ebp], ecx

; 6134 :     if (menuset_is_open)

  0011d	0f b6 45 9f	 movzx	 eax, BYTE PTR _menuset_is_open$[ebp]
  00121	85 c0		 test	 eax, eax
  00123	74 0c		 je	 SHORT $LN6@BeginMenu

; 6135 :         g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

  00125	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00128	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0012b	89 88 d0 1a 00
	00		 mov	 DWORD PTR [eax+6864], ecx
$LN6@BeginMenu:

; 6136 : 
; 6137 :     // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
; 6138 :     // However the final position is going to be different! It is choosen by FindBestWindowPosForPopup().
; 6139 :     // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
; 6140 :     ImVec2 popup_pos, pos = window->DC.CursorPos;

  00131	8d 4d 80	 lea	 ecx, DWORD PTR _popup_pos$[ebp]
  00134	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00139	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0013c	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00142	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00148	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _pos$[ebp], ecx
  0014e	89 95 74 ff ff
	ff		 mov	 DWORD PTR _pos$[ebp+4], edx

; 6141 :     if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

  00154	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00157	83 b8 5c 01 00
	00 00		 cmp	 DWORD PTR [eax+348], 0
  0015e	0f 85 98 01 00
	00		 jne	 $LN7@BeginMenu

; 6142 :     {
; 6143 :         // Menu inside an horizontal menu bar
; 6144 :         // Selectable extend their highlight by half ItemSpacing in each direction.
; 6145 :         // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
; 6146 :         popup_pos = ImVec2(pos.x - 1.0f - IM_FLOOR(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());

  00164	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00167	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  0016f	f3 0f 5c 40 3c	 subss	 xmm0, DWORD PTR [eax+60]
  00174	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00177	f3 0f 11 85 34
	fc ff ff	 movss	 DWORD PTR tv846[ebp], xmm0
  0017f	e8 00 00 00 00	 call	 ?MenuBarHeight@ImGuiWindow@@QBEMXZ ; ImGuiWindow::MenuBarHeight
  00184	d9 9d 30 fc ff
	ff		 fstp	 DWORD PTR tv607[ebp]
  0018a	f3 0f 10 85 34
	fc ff ff	 movss	 xmm0, DWORD PTR tv846[ebp]
  00192	f3 0f 58 85 30
	fc ff ff	 addss	 xmm0, DWORD PTR tv607[ebp]
  0019a	51		 push	 ecx
  0019b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a0	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp]
  001a8	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  001b0	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  001b3	f3 0f 10 49 48	 movss	 xmm1, DWORD PTR [ecx+72]
  001b8	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  001c0	f3 0f 2c d1	 cvttss2si edx, xmm1
  001c4	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  001c8	f3 0f 5c c1	 subss	 xmm0, xmm1
  001cc	51		 push	 ecx
  001cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d2	8d 8d 14 fd ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  001d8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001df	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e2	89 4d 80	 mov	 DWORD PTR _popup_pos$[ebp], ecx
  001e5	89 55 84	 mov	 DWORD PTR _popup_pos$[ebp+4], edx

; 6147 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * 0.5f);

  001e8	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  001eb	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  001f0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001f8	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001fc	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00200	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00203	f3 0f 58 82 c8
	00 00 00	 addss	 xmm0, DWORD PTR [edx+200]
  0020b	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0020e	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0

; 6148 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));

  00216	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00219	51		 push	 ecx
  0021a	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [eax+76]
  0021f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00224	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00227	f3 0f 10 41 48	 movss	 xmm0, DWORD PTR [ecx+72]
  0022c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00234	51		 push	 ecx
  00235	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023a	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00240	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00245	50		 push	 eax
  00246	6a 0d		 push	 13			; 0000000dH
  00248	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z ; ImGui::PushStyleVar
  0024d	83 c4 08	 add	 esp, 8

; 6149 :         float w = label_size.x;

  00250	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00255	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _w$27[ebp], xmm0

; 6150 :         pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

  0025d	0f b6 45 0c	 movzx	 eax, BYTE PTR _enabled$[ebp]
  00261	85 c0		 test	 eax, eax
  00263	75 0c		 jne	 SHORT $LN34@BeginMenu
  00265	c7 85 34 fc ff
	ff 08 00 00 00	 mov	 DWORD PTR tv195[ebp], 8
  0026f	eb 0a		 jmp	 SHORT $LN35@BeginMenu
$LN34@BeginMenu:
  00271	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv195[ebp], 0
$LN35@BeginMenu:
  0027b	51		 push	 ecx
  0027c	0f 57 c0	 xorps	 xmm0, xmm0
  0027f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00284	51		 push	 ecx
  00285	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _w$27[ebp]
  0028d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00292	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00298	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0029d	50		 push	 eax
  0029e	8b 8d 34 fc ff
	ff		 mov	 ecx, DWORD PTR tv195[ebp]
  002a4	81 c9 01 00 30
	00		 or	 ecx, 3145729		; 00300001H
  002aa	51		 push	 ecx
  002ab	0f b6 55 ab	 movzx	 edx, BYTE PTR _menu_is_open$[ebp]
  002af	52		 push	 edx
  002b0	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  002b9	83 c4 10	 add	 esp, 16			; 00000010H
  002bc	88 45 b7	 mov	 BYTE PTR _pressed$[ebp], al

; 6151 :         PopStyleVar();

  002bf	6a 01		 push	 1
  002c1	e8 00 00 00 00	 call	 ?PopStyleVar@ImGui@@YAXH@Z ; ImGui::PopStyleVar
  002c6	83 c4 04	 add	 esp, 4

; 6152 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().

  002c9	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  002cc	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  002d1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf000000
  002d9	f3 0f 2c c8	 cvttss2si ecx, xmm0
  002dd	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  002e1	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  002e4	f3 0f 58 82 c8
	00 00 00	 addss	 xmm0, DWORD PTR [edx+200]
  002ec	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002ef	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0

; 6153 :     }

  002f7	e9 f1 01 00 00	 jmp	 $LN8@BeginMenu
$LN7@BeginMenu:

; 6154 :     else
; 6155 :     {
; 6156 :         // Menu inside a menu
; 6157 :         popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);

  002fc	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  002ff	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00307	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  0030c	51		 push	 ecx
  0030d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00312	51		 push	 ecx
  00313	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp]
  0031b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00320	8d 8d e4 fc ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00326	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0032b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00330	89 4d 80	 mov	 DWORD PTR _popup_pos$[ebp], ecx
  00333	89 55 84	 mov	 DWORD PTR _popup_pos$[ebp+4], edx

; 6158 :         float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, IM_FLOOR(g.FontSize * 1.20f)); // Feedback to next frame

  00336	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00339	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00341	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f99999a
  00349	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0034d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00351	51		 push	 ecx
  00352	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00357	51		 push	 ecx
  00358	0f 57 c0	 xorps	 xmm0, xmm0
  0035b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00360	51		 push	 ecx
  00361	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00366	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036b	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0036e	81 c1 30 02 00
	00		 add	 ecx, 560		; 00000230H
  00374	e8 00 00 00 00	 call	 ?DeclColumns@ImGuiMenuColumns@@QAEMMMM@Z ; ImGuiMenuColumns::DeclColumns
  00379	d9 9d 58 ff ff
	ff		 fstp	 DWORD PTR _w$26[ebp]

; 6159 :         float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);

  0037f	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00385	50		 push	 eax
  00386	e8 00 00 00 00	 call	 ?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
  0038b	83 c4 04	 add	 esp, 4
  0038e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00392	f3 0f 5c 85 58
	ff ff ff	 subss	 xmm0, DWORD PTR _w$26[ebp]
  0039a	51		 push	 ecx
  0039b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a0	51		 push	 ecx
  003a1	0f 57 c0	 xorps	 xmm0, xmm0
  003a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a9	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  003ae	83 c4 08	 add	 esp, 8
  003b1	d9 9d 4c ff ff
	ff		 fstp	 DWORD PTR _extra_w$25[ebp]

; 6160 :         pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

  003b7	0f b6 45 0c	 movzx	 eax, BYTE PTR _enabled$[ebp]
  003bb	85 c0		 test	 eax, eax
  003bd	75 0c		 jne	 SHORT $LN36@BeginMenu
  003bf	c7 85 34 fc ff
	ff 08 00 00 00	 mov	 DWORD PTR tv249[ebp], 8
  003c9	eb 0a		 jmp	 SHORT $LN37@BeginMenu
$LN36@BeginMenu:
  003cb	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv249[ebp], 0
$LN37@BeginMenu:
  003d5	51		 push	 ecx
  003d6	0f 57 c0	 xorps	 xmm0, xmm0
  003d9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003de	51		 push	 ecx
  003df	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _w$26[ebp]
  003e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ec	8d 8d c4 fc ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  003f2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003f7	50		 push	 eax
  003f8	8b 8d 34 fc ff
	ff		 mov	 ecx, DWORD PTR tv249[ebp]
  003fe	81 c9 01 00 b0
	00		 or	 ecx, 11534337		; 00b00001H
  00404	51		 push	 ecx
  00405	0f b6 55 ab	 movzx	 edx, BYTE PTR _menu_is_open$[ebp]
  00409	52		 push	 edx
  0040a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  00413	83 c4 10	 add	 esp, 16			; 00000010H
  00416	88 45 b7	 mov	 BYTE PTR _pressed$[ebp], al

; 6161 :         ImU32 text_col = GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled);

  00419	0f b6 45 0c	 movzx	 eax, BYTE PTR _enabled$[ebp]
  0041d	85 c0		 test	 eax, eax
  0041f	74 0c		 je	 SHORT $LN38@BeginMenu
  00421	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv258[ebp], 0
  0042b	eb 0a		 jmp	 SHORT $LN39@BeginMenu
$LN38@BeginMenu:
  0042d	c7 85 34 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv258[ebp], 1
$LN39@BeginMenu:
  00437	51		 push	 ecx
  00438	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00440	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00445	8b 8d 34 fc ff
	ff		 mov	 ecx, DWORD PTR tv258[ebp]
  0044b	51		 push	 ecx
  0044c	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00451	83 c4 08	 add	 esp, 8
  00454	89 85 40 ff ff
	ff		 mov	 DWORD PTR _text_col$24[ebp], eax

; 6162 :         RenderArrow(window->DrawList, pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), text_col, ImGuiDir_Right);

  0045a	51		 push	 ecx
  0045b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00463	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00468	6a 01		 push	 1
  0046a	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _text_col$24[ebp]
  00470	50		 push	 eax
  00471	51		 push	 ecx
  00472	0f 57 c0	 xorps	 xmm0, xmm0
  00475	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0047a	b9 04 00 00 00	 mov	 ecx, 4
  0047f	d1 e1		 shl	 ecx, 1
  00481	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00484	f3 0f 10 84 0a
	3c 02 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+572]
  0048d	f3 0f 58 85 4c
	ff ff ff	 addss	 xmm0, DWORD PTR _extra_w$25[ebp]
  00495	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00498	f3 0f 10 88 c4
	18 00 00	 movss	 xmm1, DWORD PTR [eax+6340]
  004a0	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3e99999a
  004a8	f3 0f 58 c1	 addss	 xmm0, xmm1
  004ac	51		 push	 ecx
  004ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b2	8d 8d b4 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  004b8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  004bd	50		 push	 eax
  004be	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _pos$[ebp]
  004c4	51		 push	 ecx
  004c5	8d 95 a4 fc ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  004cb	52		 push	 edx
  004cc	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  004d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004d7	51		 push	 ecx
  004d8	8b 10		 mov	 edx, DWORD PTR [eax]
  004da	52		 push	 edx
  004db	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  004de	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  004e4	51		 push	 ecx
  004e5	e8 00 00 00 00	 call	 ?RenderArrow@ImGui@@YAXPAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
  004ea	83 c4 18	 add	 esp, 24			; 00000018H
$LN8@BeginMenu:

; 6163 :     }
; 6164 : 
; 6165 :     const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);

  004ed	0f b6 45 0c	 movzx	 eax, BYTE PTR _enabled$[ebp]
  004f1	85 c0		 test	 eax, eax
  004f3	74 26		 je	 SHORT $LN40@BeginMenu
  004f5	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  004f8	51		 push	 ecx
  004f9	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  004fc	81 c2 10 01 00
	00		 add	 edx, 272		; 00000110H
  00502	52		 push	 edx
  00503	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z ; ImGui::ItemHoverable
  00508	83 c4 08	 add	 esp, 8
  0050b	0f b6 c0	 movzx	 eax, al
  0050e	85 c0		 test	 eax, eax
  00510	74 09		 je	 SHORT $LN40@BeginMenu
  00512	c6 85 37 fc ff
	ff 01		 mov	 BYTE PTR tv291[ebp], 1
  00519	eb 07		 jmp	 SHORT $LN41@BeginMenu
$LN40@BeginMenu:
  0051b	c6 85 37 fc ff
	ff 00		 mov	 BYTE PTR tv291[ebp], 0
$LN41@BeginMenu:
  00522	8a 8d 37 fc ff
	ff		 mov	 cl, BYTE PTR tv291[ebp]
  00528	88 8d 37 ff ff
	ff		 mov	 BYTE PTR _hovered$[ebp], cl

; 6166 :     if (menuset_is_open)

  0052e	0f b6 45 9f	 movzx	 eax, BYTE PTR _menuset_is_open$[ebp]
  00532	85 c0		 test	 eax, eax
  00534	74 0c		 je	 SHORT $LN9@BeginMenu

; 6167 :         g.NavWindow = backed_nav_window;

  00536	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00539	8b 4d 90	 mov	 ecx, DWORD PTR _backed_nav_window$[ebp]
  0053c	89 88 d0 1a 00
	00		 mov	 DWORD PTR [eax+6864], ecx
$LN9@BeginMenu:

; 6168 : 
; 6169 :     bool want_open = false;

  00542	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _want_open$[ebp], 0

; 6170 :     bool want_close = false;

  00549	c6 85 1f ff ff
	ff 00		 mov	 BYTE PTR _want_close$[ebp], 0

; 6171 :     if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))

  00550	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00553	83 b8 5c 01 00
	00 01		 cmp	 DWORD PTR [eax+348], 1
  0055a	0f 85 3d 04 00
	00		 jne	 $LN10@BeginMenu

; 6172 :     {
; 6173 :         // Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
; 6174 :         // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
; 6175 :         bool moving_toward_other_child_menu = false;

  00560	c6 85 13 ff ff
	ff 00		 mov	 BYTE PTR _moving_toward_other_child_menu$23[ebp], 0

; 6176 : 
; 6177 :         ImGuiWindow* child_menu_window = (g.BeginPopupStack.Size < g.OpenPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].SourceWindow == window) ? g.OpenPopupStack[g.BeginPopupStack.Size].Window : NULL;

  00567	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0056a	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  0056d	8b 90 c4 1a 00
	00		 mov	 edx, DWORD PTR [eax+6852]
  00573	3b 91 b8 1a 00
	00		 cmp	 edx, DWORD PTR [ecx+6840]
  00579	7d 43		 jge	 SHORT $LN42@BeginMenu
  0057b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0057e	8b 88 c4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6852]
  00584	51		 push	 ecx
  00585	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00588	81 c1 b8 1a 00
	00		 add	 ecx, 6840		; 00001ab8H
  0058e	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiPopupData@@@@QAEAAUImGuiPopupData@@H@Z ; ImVector<ImGuiPopupData>::operator[]
  00593	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00596	3b 55 f4	 cmp	 edx, DWORD PTR _window$[ebp]
  00599	75 23		 jne	 SHORT $LN42@BeginMenu
  0059b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0059e	8b 88 c4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6852]
  005a4	51		 push	 ecx
  005a5	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  005a8	81 c1 b8 1a 00
	00		 add	 ecx, 6840		; 00001ab8H
  005ae	e8 00 00 00 00	 call	 ??A?$ImVector@UImGuiPopupData@@@@QAEAAUImGuiPopupData@@H@Z ; ImVector<ImGuiPopupData>::operator[]
  005b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  005b6	89 95 34 fc ff
	ff		 mov	 DWORD PTR tv318[ebp], edx
  005bc	eb 0a		 jmp	 SHORT $LN43@BeginMenu
$LN42@BeginMenu:
  005be	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv318[ebp], 0
$LN43@BeginMenu:
  005c8	8b 85 34 fc ff
	ff		 mov	 eax, DWORD PTR tv318[ebp]
  005ce	89 85 04 ff ff
	ff		 mov	 DWORD PTR _child_menu_window$22[ebp], eax

; 6178 :         if (g.HoveredWindow == window && child_menu_window != NULL && !(window->Flags & ImGuiWindowFlags_MenuBar))

  005d4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005d7	8b 88 b4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6580]
  005dd	3b 4d f4	 cmp	 ecx, DWORD PTR _window$[ebp]
  005e0	0f 85 a7 02 00
	00		 jne	 $LN12@BeginMenu
  005e6	83 bd 04 ff ff
	ff 00		 cmp	 DWORD PTR _child_menu_window$22[ebp], 0
  005ed	0f 84 9a 02 00
	00		 je	 $LN12@BeginMenu
  005f3	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  005f6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005f9	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  005ff	0f 85 88 02 00
	00		 jne	 $LN12@BeginMenu

; 6179 :         {
; 6180 :             // FIXME-DPI: Values should be derived from a master "scale" factor.
; 6181 :             ImRect next_window_rect = child_menu_window->Rect();

  00605	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _next_window_rect$21[ebp]
  0060b	50		 push	 eax
  0060c	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _child_menu_window$22[ebp]
  00612	e8 00 00 00 00	 call	 ?Rect@ImGuiWindow@@QBE?AUImRect@@XZ ; ImGuiWindow::Rect

; 6182 :             ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;

  00617	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0061a	05 78 03 00 00	 add	 eax, 888		; 00000378H
  0061f	50		 push	 eax
  00620	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00623	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  00629	51		 push	 ecx
  0062a	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _ta$20[ebp]
  00630	52		 push	 edx
  00631	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00636	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6183 :             ImVec2 tb = (window->Pos.x < child_menu_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();

  00639	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _child_menu_window$22[ebp]
  0063f	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00642	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00647	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [ecx+12]
  0064b	76 1a		 jbe	 SHORT $LN44@BeginMenu
  0064d	8d 95 88 fc ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00653	52		 push	 edx
  00654	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _next_window_rect$21[ebp]
  0065a	e8 00 00 00 00	 call	 ?GetTL@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetTL
  0065f	89 85 34 fc ff
	ff		 mov	 DWORD PTR tv377[ebp], eax
  00665	eb 18		 jmp	 SHORT $LN45@BeginMenu
$LN44@BeginMenu:
  00667	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0066d	50		 push	 eax
  0066e	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _next_window_rect$21[ebp]
  00674	e8 00 00 00 00	 call	 ?GetTR@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetTR
  00679	89 85 34 fc ff
	ff		 mov	 DWORD PTR tv377[ebp], eax
$LN45@BeginMenu:
  0067f	8b 8d 34 fc ff
	ff		 mov	 ecx, DWORD PTR tv377[ebp]
  00685	89 8d 98 fc ff
	ff		 mov	 DWORD PTR $T7[ebp], ecx
  0068b	8b 95 98 fc ff
	ff		 mov	 edx, DWORD PTR $T7[ebp]
  00691	8b 02		 mov	 eax, DWORD PTR [edx]
  00693	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00696	89 85 cc fe ff
	ff		 mov	 DWORD PTR _tb$19[ebp], eax
  0069c	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _tb$19[ebp+4], ecx

; 6184 :             ImVec2 tc = (window->Pos.x < child_menu_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();

  006a2	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _child_menu_window$22[ebp]
  006a8	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  006ab	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  006b0	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [ecx+12]
  006b4	76 1a		 jbe	 SHORT $LN46@BeginMenu
  006b6	8d 95 5c fc ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  006bc	52		 push	 edx
  006bd	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _next_window_rect$21[ebp]
  006c3	e8 00 00 00 00	 call	 ?GetBL@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetBL
  006c8	89 85 34 fc ff
	ff		 mov	 DWORD PTR tv390[ebp], eax
  006ce	eb 18		 jmp	 SHORT $LN47@BeginMenu
$LN46@BeginMenu:
  006d0	8d 85 4c fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  006d6	50		 push	 eax
  006d7	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _next_window_rect$21[ebp]
  006dd	e8 00 00 00 00	 call	 ?GetBR@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetBR
  006e2	89 85 34 fc ff
	ff		 mov	 DWORD PTR tv390[ebp], eax
$LN47@BeginMenu:
  006e8	8b 8d 34 fc ff
	ff		 mov	 ecx, DWORD PTR tv390[ebp]
  006ee	89 8d 6c fc ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  006f4	8b 95 6c fc ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  006fa	8b 02		 mov	 eax, DWORD PTR [edx]
  006fc	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  006ff	89 85 bc fe ff
	ff		 mov	 DWORD PTR _tc$18[ebp], eax
  00705	89 8d c0 fe ff
	ff		 mov	 DWORD PTR _tc$18[ebp+4], ecx

; 6185 :             float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f);    // add a bit of extra slack.

  0070b	51		 push	 ecx
  0070c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41f00000
  00714	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00719	51		 push	 ecx
  0071a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40a00000
  00722	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00727	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _ta$20[ebp]
  0072f	f3 0f 5c 85 cc
	fe ff ff	 subss	 xmm0, DWORD PTR _tb$19[ebp]
  00737	51		 push	 ecx
  00738	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0073d	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  00742	83 c4 04	 add	 esp, 4
  00745	d9 9d 34 fc ff
	ff		 fstp	 DWORD PTR tv766[ebp]
  0074b	f3 0f 10 85 34
	fc ff ff	 movss	 xmm0, DWORD PTR tv766[ebp]
  00753	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e99999a
  0075b	51		 push	 ecx
  0075c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00761	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  00766	83 c4 0c	 add	 esp, 12			; 0000000cH
  00769	d9 9d b0 fe ff
	ff		 fstp	 DWORD PTR _extra$17[ebp]

; 6186 :             ta.x += (window->Pos.x < child_menu_window->Pos.x) ? -0.5f : +0.5f; // to avoid numerical issues

  0076f	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _child_menu_window$22[ebp]
  00775	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00778	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0077d	0f 2f 41 0c	 comiss	 xmm0, DWORD PTR [ecx+12]
  00781	76 12		 jbe	 SHORT $LN48@BeginMenu
  00783	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf000000
  0078b	f3 0f 11 85 34
	fc ff ff	 movss	 DWORD PTR tv405[ebp], xmm0
  00793	eb 10		 jmp	 SHORT $LN49@BeginMenu
$LN48@BeginMenu:
  00795	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0079d	f3 0f 11 85 34
	fc ff ff	 movss	 DWORD PTR tv405[ebp], xmm0
$LN49@BeginMenu:
  007a5	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _ta$20[ebp]
  007ad	f3 0f 58 85 34
	fc ff ff	 addss	 xmm0, DWORD PTR tv405[ebp]
  007b5	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _ta$20[ebp], xmm0

; 6187 :             tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);                // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?

  007bd	51		 push	 ecx
  007be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2c80000
  007c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007cb	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _tb$19[ebp+4]
  007d3	f3 0f 5c 85 b0
	fe ff ff	 subss	 xmm0, DWORD PTR _extra$17[ebp]
  007db	f3 0f 5c 85 e0
	fe ff ff	 subss	 xmm0, DWORD PTR _ta$20[ebp+4]
  007e3	51		 push	 ecx
  007e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007e9	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  007ee	83 c4 08	 add	 esp, 8
  007f1	d9 9d 34 fc ff
	ff		 fstp	 DWORD PTR tv787[ebp]
  007f7	f3 0f 10 85 34
	fc ff ff	 movss	 xmm0, DWORD PTR tv787[ebp]
  007ff	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _ta$20[ebp+4]
  00807	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _tb$19[ebp+4], xmm0

; 6188 :             tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);

  0080f	51		 push	 ecx
  00810	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00818	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0081d	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _tc$18[ebp+4]
  00825	f3 0f 58 85 b0
	fe ff ff	 addss	 xmm0, DWORD PTR _extra$17[ebp]
  0082d	f3 0f 5c 85 e0
	fe ff ff	 subss	 xmm0, DWORD PTR _ta$20[ebp+4]
  00835	51		 push	 ecx
  00836	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0083b	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00840	83 c4 08	 add	 esp, 8
  00843	d9 9d 34 fc ff
	ff		 fstp	 DWORD PTR tv796[ebp]
  00849	f3 0f 10 85 34
	fc ff ff	 movss	 xmm0, DWORD PTR tv796[ebp]
  00851	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _ta$20[ebp+4]
  00859	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _tc$18[ebp+4], xmm0

; 6189 :             moving_toward_other_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);

  00861	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00864	05 e8 00 00 00	 add	 eax, 232		; 000000e8H
  00869	50		 push	 eax
  0086a	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _tc$18[ebp]
  00870	51		 push	 ecx
  00871	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _tb$19[ebp]
  00877	52		 push	 edx
  00878	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _ta$20[ebp]
  0087e	50		 push	 eax
  0087f	e8 00 00 00 00	 call	 ?ImTriangleContainsPoint@@YA_NABUImVec2@@000@Z ; ImTriangleContainsPoint
  00884	83 c4 10	 add	 esp, 16			; 00000010H
  00887	88 85 13 ff ff
	ff		 mov	 BYTE PTR _moving_toward_other_child_menu$23[ebp], al
$LN12@BeginMenu:

; 6190 :             //GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]
; 6191 :         }
; 6192 :         if (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_toward_other_child_menu)

  0088d	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  00891	85 c0		 test	 eax, eax
  00893	74 45		 je	 SHORT $LN13@BeginMenu
  00895	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  0089c	85 c0		 test	 eax, eax
  0089e	75 3a		 jne	 SHORT $LN13@BeginMenu
  008a0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  008a3	8b 88 b4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6580]
  008a9	3b 4d f4	 cmp	 ecx, DWORD PTR _window$[ebp]
  008ac	75 2c		 jne	 SHORT $LN13@BeginMenu
  008ae	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  008b1	83 b8 d8 19 00
	00 00		 cmp	 DWORD PTR [eax+6616], 0
  008b8	74 20		 je	 SHORT $LN13@BeginMenu
  008ba	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  008bd	8b 88 d8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6616]
  008c3	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  008c6	74 12		 je	 SHORT $LN13@BeginMenu
  008c8	0f b6 85 13 ff
	ff ff		 movzx	 eax, BYTE PTR _moving_toward_other_child_menu$23[ebp]
  008cf	85 c0		 test	 eax, eax
  008d1	75 07		 jne	 SHORT $LN13@BeginMenu

; 6193 :             want_close = true;

  008d3	c6 85 1f ff ff
	ff 01		 mov	 BYTE PTR _want_close$[ebp], 1
$LN13@BeginMenu:

; 6194 : 
; 6195 :         if (!menu_is_open && hovered && pressed) // Click to open

  008da	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  008de	85 c0		 test	 eax, eax
  008e0	75 1c		 jne	 SHORT $LN14@BeginMenu
  008e2	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  008e9	85 c0		 test	 eax, eax
  008eb	74 11		 je	 SHORT $LN14@BeginMenu
  008ed	0f b6 45 b7	 movzx	 eax, BYTE PTR _pressed$[ebp]
  008f1	85 c0		 test	 eax, eax
  008f3	74 09		 je	 SHORT $LN14@BeginMenu

; 6196 :             want_open = true;

  008f5	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _want_open$[ebp], 1
  008fc	eb 25		 jmp	 SHORT $LN16@BeginMenu
$LN14@BeginMenu:

; 6197 :         else if (!menu_is_open && hovered && !moving_toward_other_child_menu) // Hover to open

  008fe	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  00902	85 c0		 test	 eax, eax
  00904	75 1d		 jne	 SHORT $LN16@BeginMenu
  00906	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  0090d	85 c0		 test	 eax, eax
  0090f	74 12		 je	 SHORT $LN16@BeginMenu
  00911	0f b6 85 13 ff
	ff ff		 movzx	 eax, BYTE PTR _moving_toward_other_child_menu$23[ebp]
  00918	85 c0		 test	 eax, eax
  0091a	75 07		 jne	 SHORT $LN16@BeginMenu

; 6198 :             want_open = true;

  0091c	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _want_open$[ebp], 1
$LN16@BeginMenu:

; 6199 : 
; 6200 :         if (g.NavActivateId == id)

  00923	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00926	8b 88 d8 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6872]
  0092c	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0092f	75 33		 jne	 SHORT $LN17@BeginMenu

; 6201 :         {
; 6202 :             want_close = menu_is_open;

  00931	8a 45 ab	 mov	 al, BYTE PTR _menu_is_open$[ebp]
  00934	88 85 1f ff ff
	ff		 mov	 BYTE PTR _want_close$[ebp], al

; 6203 :             want_open = !menu_is_open;

  0093a	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  0093e	85 c0		 test	 eax, eax
  00940	75 0c		 jne	 SHORT $LN50@BeginMenu
  00942	c7 85 34 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv454[ebp], 1
  0094c	eb 0a		 jmp	 SHORT $LN51@BeginMenu
$LN50@BeginMenu:
  0094e	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv454[ebp], 0
$LN51@BeginMenu:
  00958	8a 8d 34 fc ff
	ff		 mov	 cl, BYTE PTR tv454[ebp]
  0095e	88 8d 2b ff ff
	ff		 mov	 BYTE PTR _want_open$[ebp], cl
$LN17@BeginMenu:

; 6204 :         }
; 6205 :         if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open

  00964	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00967	8b 88 d4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6868]
  0096d	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  00970	75 26		 jne	 SHORT $LN18@BeginMenu
  00972	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00975	0f b6 88 4d 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6989]
  0097c	85 c9		 test	 ecx, ecx
  0097e	74 18		 je	 SHORT $LN18@BeginMenu
  00980	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00983	83 b8 58 1b 00
	00 01		 cmp	 DWORD PTR [eax+7000], 1
  0098a	75 0c		 jne	 SHORT $LN18@BeginMenu

; 6206 :         {
; 6207 :             want_open = true;

  0098c	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _want_open$[ebp], 1

; 6208 :             NavMoveRequestCancel();

  00993	e8 00 00 00 00	 call	 ?NavMoveRequestCancel@ImGui@@YAXXZ ; ImGui::NavMoveRequestCancel
$LN18@BeginMenu:

; 6209 :         }
; 6210 :     }

  00998	e9 8e 00 00 00	 jmp	 $LN24@BeginMenu
$LN10@BeginMenu:

; 6211 :     else
; 6212 :     {
; 6213 :         // Menu bar
; 6214 :         if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it

  0099d	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  009a1	85 c0		 test	 eax, eax
  009a3	74 26		 je	 SHORT $LN19@BeginMenu
  009a5	0f b6 45 b7	 movzx	 eax, BYTE PTR _pressed$[ebp]
  009a9	85 c0		 test	 eax, eax
  009ab	74 1e		 je	 SHORT $LN19@BeginMenu
  009ad	0f b6 45 9f	 movzx	 eax, BYTE PTR _menuset_is_open$[ebp]
  009b1	85 c0		 test	 eax, eax
  009b3	74 16		 je	 SHORT $LN19@BeginMenu

; 6215 :         {
; 6216 :             want_close = true;

  009b5	c6 85 1f ff ff
	ff 01		 mov	 BYTE PTR _want_close$[ebp], 1

; 6217 :             want_open = menu_is_open = false;

  009bc	c6 45 ab 00	 mov	 BYTE PTR _menu_is_open$[ebp], 0
  009c0	8a 45 ab	 mov	 al, BYTE PTR _menu_is_open$[ebp]
  009c3	88 85 2b ff ff
	ff		 mov	 BYTE PTR _want_open$[ebp], al

; 6218 :         }

  009c9	eb 60		 jmp	 SHORT $LN24@BeginMenu
$LN19@BeginMenu:

; 6219 :         else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others

  009cb	0f b6 45 b7	 movzx	 eax, BYTE PTR _pressed$[ebp]
  009cf	85 c0		 test	 eax, eax
  009d1	75 1b		 jne	 SHORT $LN23@BeginMenu
  009d3	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  009da	85 c0		 test	 eax, eax
  009dc	74 19		 je	 SHORT $LN21@BeginMenu
  009de	0f b6 45 9f	 movzx	 eax, BYTE PTR _menuset_is_open$[ebp]
  009e2	85 c0		 test	 eax, eax
  009e4	74 11		 je	 SHORT $LN21@BeginMenu
  009e6	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  009ea	85 c0		 test	 eax, eax
  009ec	75 09		 jne	 SHORT $LN21@BeginMenu
$LN23@BeginMenu:

; 6220 :         {
; 6221 :             want_open = true;

  009ee	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _want_open$[ebp], 1

; 6222 :         }

  009f5	eb 34		 jmp	 SHORT $LN24@BeginMenu
$LN21@BeginMenu:

; 6223 :         else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open

  009f7	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  009fa	8b 88 d4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6868]
  00a00	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  00a03	75 26		 jne	 SHORT $LN24@BeginMenu
  00a05	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a08	0f b6 88 4d 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6989]
  00a0f	85 c9		 test	 ecx, ecx
  00a11	74 18		 je	 SHORT $LN24@BeginMenu
  00a13	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a16	83 b8 58 1b 00
	00 03		 cmp	 DWORD PTR [eax+7000], 3
  00a1d	75 0c		 jne	 SHORT $LN24@BeginMenu

; 6224 :         {
; 6225 :             want_open = true;

  00a1f	c6 85 2b ff ff
	ff 01		 mov	 BYTE PTR _want_open$[ebp], 1

; 6226 :             NavMoveRequestCancel();

  00a26	e8 00 00 00 00	 call	 ?NavMoveRequestCancel@ImGui@@YAXXZ ; ImGui::NavMoveRequestCancel
$LN24@BeginMenu:

; 6227 :         }
; 6228 :     }
; 6229 : 
; 6230 :     if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'

  00a2b	0f b6 45 0c	 movzx	 eax, BYTE PTR _enabled$[ebp]
  00a2f	85 c0		 test	 eax, eax
  00a31	75 07		 jne	 SHORT $LN25@BeginMenu

; 6231 :         want_close = true;

  00a33	c6 85 1f ff ff
	ff 01		 mov	 BYTE PTR _want_close$[ebp], 1
$LN25@BeginMenu:

; 6232 :     if (want_close && IsPopupOpen(id))

  00a3a	0f b6 85 1f ff
	ff ff		 movzx	 eax, BYTE PTR _want_close$[ebp]
  00a41	85 c0		 test	 eax, eax
  00a43	74 27		 je	 SHORT $LN26@BeginMenu
  00a45	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00a48	50		 push	 eax
  00a49	e8 00 00 00 00	 call	 ?IsPopupOpen@ImGui@@YA_NI@Z ; ImGui::IsPopupOpen
  00a4e	83 c4 04	 add	 esp, 4
  00a51	0f b6 c8	 movzx	 ecx, al
  00a54	85 c9		 test	 ecx, ecx
  00a56	74 14		 je	 SHORT $LN26@BeginMenu

; 6233 :         ClosePopupToLevel(g.BeginPopupStack.Size, true);

  00a58	6a 01		 push	 1
  00a5a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a5d	8b 88 c4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6852]
  00a63	51		 push	 ecx
  00a64	e8 00 00 00 00	 call	 ?ClosePopupToLevel@ImGui@@YAXH_N@Z ; ImGui::ClosePopupToLevel
  00a69	83 c4 08	 add	 esp, 8
$LN26@BeginMenu:

; 6234 : 
; 6235 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));

  00a6c	33 c0		 xor	 eax, eax
  00a6e	75 fc		 jne	 SHORT $LN26@BeginMenu

; 6236 : 
; 6237 :     if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)

  00a70	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  00a74	85 c0		 test	 eax, eax
  00a76	75 32		 jne	 SHORT $LN27@BeginMenu
  00a78	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _want_open$[ebp]
  00a7f	85 c0		 test	 eax, eax
  00a81	74 27		 je	 SHORT $LN27@BeginMenu
  00a83	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00a86	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00a89	8b 90 b8 1a 00
	00		 mov	 edx, DWORD PTR [eax+6840]
  00a8f	3b 91 c4 1a 00
	00		 cmp	 edx, DWORD PTR [ecx+6852]
  00a95	7e 13		 jle	 SHORT $LN27@BeginMenu

; 6238 :     {
; 6239 :         // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
; 6240 :         OpenPopup(label);

  00a97	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00a9a	50		 push	 eax
  00a9b	e8 00 00 00 00	 call	 ?OpenPopup@ImGui@@YAXPBD@Z ; ImGui::OpenPopup
  00aa0	83 c4 04	 add	 esp, 4

; 6241 :         return false;

  00aa3	32 c0		 xor	 al, al
  00aa5	e9 9d 00 00 00	 jmp	 $LN1@BeginMenu
$LN27@BeginMenu:

; 6242 :     }
; 6243 : 
; 6244 :     menu_is_open |= want_open;

  00aaa	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  00aae	0f b6 8d 2b ff
	ff ff		 movzx	 ecx, BYTE PTR _want_open$[ebp]
  00ab5	0b c1		 or	 eax, ecx
  00ab7	88 45 ab	 mov	 BYTE PTR _menu_is_open$[ebp], al

; 6245 :     if (want_open)

  00aba	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _want_open$[ebp]
  00ac1	85 c0		 test	 eax, eax
  00ac3	74 0c		 je	 SHORT $LN28@BeginMenu

; 6246 :         OpenPopup(label);

  00ac5	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00ac8	50		 push	 eax
  00ac9	e8 00 00 00 00	 call	 ?OpenPopup@ImGui@@YAXPBD@Z ; ImGui::OpenPopup
  00ace	83 c4 04	 add	 esp, 4
$LN28@BeginMenu:

; 6247 : 
; 6248 :     if (menu_is_open)

  00ad1	0f b6 45 ab	 movzx	 eax, BYTE PTR _menu_is_open$[ebp]
  00ad5	85 c0		 test	 eax, eax
  00ad7	74 6b		 je	 SHORT $LN29@BeginMenu

; 6249 :     {
; 6250 :         // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
; 6251 :         SetNextWindowPos(popup_pos, ImGuiCond_Always);

  00ad9	51		 push	 ecx
  00ada	0f 57 c0	 xorps	 xmm0, xmm0
  00add	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ae2	51		 push	 ecx
  00ae3	0f 57 c0	 xorps	 xmm0, xmm0
  00ae6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aeb	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00af1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00af6	50		 push	 eax
  00af7	6a 01		 push	 1
  00af9	8d 45 80	 lea	 eax, DWORD PTR _popup_pos$[ebp]
  00afc	50		 push	 eax
  00afd	e8 00 00 00 00	 call	 ?SetNextWindowPos@ImGui@@YAXABUImVec2@@H0@Z ; ImGui::SetNextWindowPos
  00b02	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6252 :         ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;

  00b05	c7 85 a4 fe ff
	ff 45 01 08 10	 mov	 DWORD PTR _flags$16[ebp], 268960069 ; 10080145H

; 6253 :         if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))

  00b0f	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00b12	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b15	81 e1 00 00 00
	14		 and	 ecx, 335544320		; 14000000H
  00b1b	74 11		 je	 SHORT $LN30@BeginMenu

; 6254 :             flags |= ImGuiWindowFlags_ChildWindow;

  00b1d	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _flags$16[ebp]
  00b23	0d 00 00 00 01	 or	 eax, 16777216		; 01000000H
  00b28	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _flags$16[ebp], eax
$LN30@BeginMenu:

; 6255 :         menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

  00b2e	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _flags$16[ebp]
  00b34	50		 push	 eax
  00b35	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00b38	51		 push	 ecx
  00b39	e8 00 00 00 00	 call	 ?BeginPopupEx@ImGui@@YA_NIH@Z ; ImGui::BeginPopupEx
  00b3e	83 c4 08	 add	 esp, 8
  00b41	88 45 ab	 mov	 BYTE PTR _menu_is_open$[ebp], al
$LN29@BeginMenu:

; 6256 :     }
; 6257 : 
; 6258 :     return menu_is_open;

  00b44	8a 45 ab	 mov	 al, BYTE PTR _menu_is_open$[ebp]
$LN1@BeginMenu:

; 6259 : }

  00b47	52		 push	 edx
  00b48	8b cd		 mov	 ecx, ebp
  00b4a	50		 push	 eax
  00b4b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN60@BeginMenu
  00b51	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00b56	58		 pop	 eax
  00b57	5a		 pop	 edx
  00b58	5f		 pop	 edi
  00b59	5e		 pop	 esi
  00b5a	5b		 pop	 ebx
  00b5b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b5e	33 cd		 xor	 ecx, ebp
  00b60	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b65	81 c4 d0 03 00
	00		 add	 esp, 976		; 000003d0H
  00b6b	3b ec		 cmp	 ebp, esp
  00b6d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b72	8b e5		 mov	 esp, ebp
  00b74	5d		 pop	 ebp
  00b75	c3		 ret	 0
  00b76	66 90		 npad	 2
$LN60@BeginMenu:
  00b78	07 00 00 00	 DD	 7
  00b7c	00 00 00 00	 DD	 $LN59@BeginMenu
$LN59@BeginMenu:
  00b80	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00b84	08 00 00 00	 DD	 8
  00b88	00 00 00 00	 DD	 $LN52@BeginMenu
  00b8c	80 ff ff ff	 DD	 -128			; ffffff80H
  00b90	08 00 00 00	 DD	 8
  00b94	00 00 00 00	 DD	 $LN53@BeginMenu
  00b98	70 ff ff ff	 DD	 -144			; ffffff70H
  00b9c	08 00 00 00	 DD	 8
  00ba0	00 00 00 00	 DD	 $LN54@BeginMenu
  00ba4	ec fe ff ff	 DD	 -276			; fffffeecH
  00ba8	10 00 00 00	 DD	 16			; 00000010H
  00bac	00 00 00 00	 DD	 $LN55@BeginMenu
  00bb0	dc fe ff ff	 DD	 -292			; fffffedcH
  00bb4	08 00 00 00	 DD	 8
  00bb8	00 00 00 00	 DD	 $LN56@BeginMenu
  00bbc	cc fe ff ff	 DD	 -308			; fffffeccH
  00bc0	08 00 00 00	 DD	 8
  00bc4	00 00 00 00	 DD	 $LN57@BeginMenu
  00bc8	bc fe ff ff	 DD	 -324			; fffffebcH
  00bcc	08 00 00 00	 DD	 8
  00bd0	00 00 00 00	 DD	 $LN58@BeginMenu
$LN58@BeginMenu:
  00bd4	74		 DB	 116			; 00000074H
  00bd5	63		 DB	 99			; 00000063H
  00bd6	00		 DB	 0
$LN57@BeginMenu:
  00bd7	74		 DB	 116			; 00000074H
  00bd8	62		 DB	 98			; 00000062H
  00bd9	00		 DB	 0
$LN56@BeginMenu:
  00bda	74		 DB	 116			; 00000074H
  00bdb	61		 DB	 97			; 00000061H
  00bdc	00		 DB	 0
$LN55@BeginMenu:
  00bdd	6e		 DB	 110			; 0000006eH
  00bde	65		 DB	 101			; 00000065H
  00bdf	78		 DB	 120			; 00000078H
  00be0	74		 DB	 116			; 00000074H
  00be1	5f		 DB	 95			; 0000005fH
  00be2	77		 DB	 119			; 00000077H
  00be3	69		 DB	 105			; 00000069H
  00be4	6e		 DB	 110			; 0000006eH
  00be5	64		 DB	 100			; 00000064H
  00be6	6f		 DB	 111			; 0000006fH
  00be7	77		 DB	 119			; 00000077H
  00be8	5f		 DB	 95			; 0000005fH
  00be9	72		 DB	 114			; 00000072H
  00bea	65		 DB	 101			; 00000065H
  00beb	63		 DB	 99			; 00000063H
  00bec	74		 DB	 116			; 00000074H
  00bed	00		 DB	 0
$LN54@BeginMenu:
  00bee	70		 DB	 112			; 00000070H
  00bef	6f		 DB	 111			; 0000006fH
  00bf0	73		 DB	 115			; 00000073H
  00bf1	00		 DB	 0
$LN53@BeginMenu:
  00bf2	70		 DB	 112			; 00000070H
  00bf3	6f		 DB	 111			; 0000006fH
  00bf4	70		 DB	 112			; 00000070H
  00bf5	75		 DB	 117			; 00000075H
  00bf6	70		 DB	 112			; 00000070H
  00bf7	5f		 DB	 95			; 0000005fH
  00bf8	70		 DB	 112			; 00000070H
  00bf9	6f		 DB	 111			; 0000006fH
  00bfa	73		 DB	 115			; 00000073H
  00bfb	00		 DB	 0
$LN52@BeginMenu:
  00bfc	6c		 DB	 108			; 0000006cH
  00bfd	61		 DB	 97			; 00000061H
  00bfe	62		 DB	 98			; 00000062H
  00bff	65		 DB	 101			; 00000065H
  00c00	6c		 DB	 108			; 0000006cH
  00c01	5f		 DB	 95			; 0000005fH
  00c02	73		 DB	 115			; 00000073H
  00c03	69		 DB	 105			; 00000069H
  00c04	7a		 DB	 122			; 0000007aH
  00c05	65		 DB	 101			; 00000065H
  00c06	00		 DB	 0
?BeginMenu@ImGui@@YA_NPBD_N@Z ENDP			; ImGui::BeginMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?EndMainMenuBar@ImGui@@YAXXZ
_TEXT	SEGMENT
_g$ = -8						; size = 4
?EndMainMenuBar@ImGui@@YAXXZ PROC			; ImGui::EndMainMenuBar, COMDAT

; 6106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6107 :     EndMenuBar();

  00028	e8 00 00 00 00	 call	 ?EndMenuBar@ImGui@@YAXXZ ; ImGui::EndMenuBar

; 6108 : 
; 6109 :     // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
; 6110 :     // FIXME: With this strategy we won't be able to restore a NULL focus.
; 6111 :     ImGuiContext& g = *GImGui;

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00032	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6112 :     if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0 && !g.NavAnyRequest)

  00035	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0003b	8b 90 b0 19 00
	00		 mov	 edx, DWORD PTR [eax+6576]
  00041	3b 91 d0 1a 00
	00		 cmp	 edx, DWORD PTR [ecx+6864]
  00047	75 2e		 jne	 SHORT $LN2@EndMainMen
  00049	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0004c	83 b8 28 1b 00
	00 00		 cmp	 DWORD PTR [eax+6952], 0
  00053	75 22		 jne	 SHORT $LN2@EndMainMen
  00055	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00058	0f b6 88 34 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6964]
  0005f	85 c9		 test	 ecx, ecx
  00061	75 14		 jne	 SHORT $LN2@EndMainMen

; 6113 :         FocusTopMostWindowUnderOne(g.NavWindow, NULL);

  00063	6a 00		 push	 0
  00065	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00068	8b 88 d0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6864]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?FocusTopMostWindowUnderOne@ImGui@@YAXPAUImGuiWindow@@0@Z ; ImGui::FocusTopMostWindowUnderOne
  00074	83 c4 08	 add	 esp, 8
$LN2@EndMainMen:

; 6114 : 
; 6115 :     End();

  00077	e8 00 00 00 00	 call	 ?End@ImGui@@YAXXZ	; ImGui::End

; 6116 : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?EndMainMenuBar@ImGui@@YAXXZ ENDP			; ImGui::EndMainMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginMainMenuBar@ImGui@@YA_NXZ
_TEXT	SEGMENT
tv162 = -328						; size = 4
$T1 = -320						; size = 8
$T2 = -304						; size = 8
$T3 = -288						; size = 8
$T4 = -272						; size = 8
$T5 = -256						; size = 8
$T6 = -240						; size = 8
_is_open$ = -29						; size = 1
_window_flags$ = -20					; size = 4
_g$ = -8						; size = 4
?BeginMainMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMainMenuBar, COMDAT

; 6086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00012	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6087 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 6088 :     g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));

  00030	51		 push	 ecx
  00031	0f 57 c0	 xorps	 xmm0, xmm0
  00034	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  0003f	f3 0f 10 80 b0
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5552]
  00047	f3 0f 5c 81 4c
	15 00 00	 subss	 xmm0, DWORD PTR [ecx+5452]
  0004f	51		 push	 ecx
  00050	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00055	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0005a	83 c4 04	 add	 esp, 4
  0005d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00060	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00063	51		 push	 ecx
  00064	f3 0f 10 82 ac
	15 00 00	 movss	 xmm0, DWORD PTR [edx+5548]
  0006c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00071	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00077	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00081	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00084	89 88 7c 1a 00
	00		 mov	 DWORD PTR [eax+6780], ecx
  0008a	89 90 80 1a 00
	00		 mov	 DWORD PTR [eax+6784], edx

; 6089 :     SetNextWindowPos(ImVec2(0.0f, 0.0f));

  00090	51		 push	 ecx
  00091	0f 57 c0	 xorps	 xmm0, xmm0
  00094	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00099	51		 push	 ecx
  0009a	0f 57 c0	 xorps	 xmm0, xmm0
  0009d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a2	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000a8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ad	50		 push	 eax
  000ae	6a 00		 push	 0
  000b0	51		 push	 ecx
  000b1	0f 57 c0	 xorps	 xmm0, xmm0
  000b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b9	51		 push	 ecx
  000ba	0f 57 c0	 xorps	 xmm0, xmm0
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000c8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?SetNextWindowPos@ImGui@@YAXABUImVec2@@H0@Z ; ImGui::SetNextWindowPos
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6090 :     SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));

  000d6	6a 00		 push	 0
  000d8	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  000db	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  000de	f3 0f 10 80 80
	1a 00 00	 movss	 xmm0, DWORD PTR [eax+6784]
  000e6	f3 0f 58 81 c8
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6344]
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  000f1	f3 0f 58 82 4c
	15 00 00	 addss	 xmm0, DWORD PTR [edx+5452]
  000f9	51		 push	 ecx
  000fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ff	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00102	51		 push	 ecx
  00103	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00108	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010d	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00113	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize
  0011e	83 c4 08	 add	 esp, 8

; 6091 :     PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

  00121	51		 push	 ecx
  00122	0f 57 c0	 xorps	 xmm0, xmm0
  00125	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012a	6a 02		 push	 2
  0012c	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHM@Z ; ImGui::PushStyleVar
  00131	83 c4 08	 add	 esp, 8

; 6092 :     PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0, 0));

  00134	51		 push	 ecx
  00135	0f 57 c0	 xorps	 xmm0, xmm0
  00138	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013d	51		 push	 ecx
  0013e	0f 57 c0	 xorps	 xmm0, xmm0
  00141	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00146	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0014c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00151	50		 push	 eax
  00152	6a 04		 push	 4
  00154	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z ; ImGui::PushStyleVar
  00159	83 c4 08	 add	 esp, 8

; 6093 :     ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;

  0015c	c7 45 ec 0f 05
	00 00		 mov	 DWORD PTR _window_flags$[ebp], 1295 ; 0000050fH

; 6094 :     bool is_open = Begin("##MainMenuBar", NULL, window_flags) && BeginMenuBar();

  00163	8b 45 ec	 mov	 eax, DWORD PTR _window_flags$[ebp]
  00166	50		 push	 eax
  00167	6a 00		 push	 0
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@
  0016e	e8 00 00 00 00	 call	 ?Begin@ImGui@@YA_NPBDPA_NH@Z ; ImGui::Begin
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH
  00176	0f b6 c8	 movzx	 ecx, al
  00179	85 c9		 test	 ecx, ecx
  0017b	74 18		 je	 SHORT $LN4@BeginMainM
  0017d	e8 00 00 00 00	 call	 ?BeginMenuBar@ImGui@@YA_NXZ ; ImGui::BeginMenuBar
  00182	0f b6 d0	 movzx	 edx, al
  00185	85 d2		 test	 edx, edx
  00187	74 0c		 je	 SHORT $LN4@BeginMainM
  00189	c7 85 b8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv162[ebp], 1
  00193	eb 0a		 jmp	 SHORT $LN5@BeginMainM
$LN4@BeginMainM:
  00195	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv162[ebp], 0
$LN5@BeginMainM:
  0019f	8a 85 b8 fe ff
	ff		 mov	 al, BYTE PTR tv162[ebp]
  001a5	88 45 e3	 mov	 BYTE PTR _is_open$[ebp], al

; 6095 :     PopStyleVar(2);

  001a8	6a 02		 push	 2
  001aa	e8 00 00 00 00	 call	 ?PopStyleVar@ImGui@@YAXH@Z ; ImGui::PopStyleVar
  001af	83 c4 04	 add	 esp, 4

; 6096 :     g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);

  001b2	51		 push	 ecx
  001b3	0f 57 c0	 xorps	 xmm0, xmm0
  001b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bb	51		 push	 ecx
  001bc	0f 57 c0	 xorps	 xmm0, xmm0
  001bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c4	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001ca	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001d4	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  001d7	89 88 7c 1a 00
	00		 mov	 DWORD PTR [eax+6780], ecx
  001dd	89 90 80 1a 00
	00		 mov	 DWORD PTR [eax+6784], edx

; 6097 :     if (!is_open)

  001e3	0f b6 45 e3	 movzx	 eax, BYTE PTR _is_open$[ebp]
  001e7	85 c0		 test	 eax, eax
  001e9	75 09		 jne	 SHORT $LN2@BeginMainM

; 6098 :     {
; 6099 :         End();

  001eb	e8 00 00 00 00	 call	 ?End@ImGui@@YAXXZ	; ImGui::End

; 6100 :         return false;

  001f0	32 c0		 xor	 al, al
  001f2	eb 02		 jmp	 SHORT $LN1@BeginMainM
$LN2@BeginMainM:

; 6101 :     }
; 6102 :     return true; //-V1020

  001f4	b0 01		 mov	 al, 1
$LN1@BeginMainM:

; 6103 : }

  001f6	5f		 pop	 edi
  001f7	5e		 pop	 esi
  001f8	5b		 pop	 ebx
  001f9	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  001ff	3b ec		 cmp	 ebp, esp
  00201	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
?BeginMainMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMainMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?EndMenuBar@ImGui@@YAXXZ
_TEXT	SEGMENT
$T1 = -260						; size = 16
_layer$2 = -44						; size = 4
_nav_earliest_child$3 = -32				; size = 4
_g$ = -20						; size = 4
_window$ = -8						; size = 4
?EndMenuBar@ImGui@@YAXXZ PROC				; ImGui::EndMenuBar, COMDAT

; 6044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6045 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 6046 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 05		 je	 SHORT $LN4@EndMenuBar

; 6047 :         return;

  0003b	e9 3b 02 00 00	 jmp	 $LN1@EndMenuBar
$LN4@EndMenuBar:

; 6048 :     ImGuiContext& g = *GImGui;

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00045	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 6049 : 
; 6050 :     // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
; 6051 :     if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))

  00048	e8 00 00 00 00	 call	 ?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ; ImGui::NavMoveRequestButNoResultYet
  0004d	0f b6 c0	 movzx	 eax, al
  00050	85 c0		 test	 eax, eax
  00052	0f 84 40 01 00
	00		 je	 $LN7@EndMenuBar
  00058	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  0005b	83 b8 58 1b 00
	00 00		 cmp	 DWORD PTR [eax+7000], 0
  00062	74 10		 je	 SHORT $LN6@EndMenuBar
  00064	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00067	83 b8 58 1b 00
	00 01		 cmp	 DWORD PTR [eax+7000], 1
  0006e	0f 85 24 01 00
	00		 jne	 $LN7@EndMenuBar
$LN6@EndMenuBar:
  00074	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00077	8b 88 d0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6864]
  0007d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00080	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  00086	0f 84 0c 01 00
	00		 je	 $LN7@EndMenuBar

; 6052 :     {
; 6053 :         ImGuiWindow* nav_earliest_child = g.NavWindow;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  0008f	8b 88 d0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6864]
  00095	89 4d e0	 mov	 DWORD PTR _nav_earliest_child$3[ebp], ecx
$LN2@EndMenuBar:

; 6054 :         while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))

  00098	8b 45 e0	 mov	 eax, DWORD PTR _nav_earliest_child$3[ebp]
  0009b	83 b8 f0 02 00
	00 00		 cmp	 DWORD PTR [eax+752], 0
  000a2	74 22		 je	 SHORT $LN3@EndMenuBar
  000a4	8b 45 e0	 mov	 eax, DWORD PTR _nav_earliest_child$3[ebp]
  000a7	8b 88 f0 02 00
	00		 mov	 ecx, DWORD PTR [eax+752]
  000ad	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000b0	81 e2 00 00 00
	10		 and	 edx, 268435456		; 10000000H
  000b6	74 0e		 je	 SHORT $LN3@EndMenuBar

; 6055 :             nav_earliest_child = nav_earliest_child->ParentWindow;

  000b8	8b 45 e0	 mov	 eax, DWORD PTR _nav_earliest_child$3[ebp]
  000bb	8b 88 f0 02 00
	00		 mov	 ecx, DWORD PTR [eax+752]
  000c1	89 4d e0	 mov	 DWORD PTR _nav_earliest_child$3[ebp], ecx
  000c4	eb d2		 jmp	 SHORT $LN2@EndMenuBar
$LN3@EndMenuBar:

; 6056 :         if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)

  000c6	8b 45 e0	 mov	 eax, DWORD PTR _nav_earliest_child$3[ebp]
  000c9	8b 88 f0 02 00
	00		 mov	 ecx, DWORD PTR [eax+752]
  000cf	3b 4d f8	 cmp	 ecx, DWORD PTR _window$[ebp]
  000d2	0f 85 c0 00 00
	00		 jne	 $LN7@EndMenuBar
  000d8	8b 45 e0	 mov	 eax, DWORD PTR _nav_earliest_child$3[ebp]
  000db	83 b8 60 01 00
	00 00		 cmp	 DWORD PTR [eax+352], 0
  000e2	0f 85 b0 00 00
	00		 jne	 $LN7@EndMenuBar
  000e8	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  000eb	83 b8 54 1b 00
	00 00		 cmp	 DWORD PTR [eax+6996], 0
  000f2	0f 85 a0 00 00
	00		 jne	 $LN7@EndMenuBar

; 6057 :         {
; 6058 :             // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
; 6059 :             // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
; 6060 :             const ImGuiNavLayer layer = ImGuiNavLayer_Menu;

  000f8	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _layer$2[ebp], 1

; 6061 :             IM_ASSERT(window->DC.NavLayerActiveMaskNext & (1 << layer)); // Sanity check

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00102	8b 88 3c 01 00
	00		 mov	 ecx, DWORD PTR [eax+316]
  00108	83 e1 02	 and	 ecx, 2
  0010b	75 26		 jne	 SHORT $LN9@EndMenuBar
  0010d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??EndMenuBar@ImGui@@YAXXZ@4JA
  00113	83 c2 11	 add	 edx, 17			; 00000011H
  00116	8b f4		 mov	 esi, esp
  00118	52		 push	 edx
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_1GC@NKCHGHAD@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAN?$AAa?$AAv?$AAL@
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012c	3b f4		 cmp	 esi, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@EndMenuBar:

; 6062 :             FocusWindow(window);

  00133	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  0013c	83 c4 04	 add	 esp, 4

; 6063 :             SetNavIDWithRectRel(window->NavLastIds[layer], layer, window->NavRectRel[layer]);

  0013f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00144	c1 e0 00	 shl	 eax, 0
  00147	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0014a	8d 94 01 0c 03
	00 00		 lea	 edx, DWORD PTR [ecx+eax+780]
  00151	52		 push	 edx
  00152	6a 01		 push	 1
  00154	b8 04 00 00 00	 mov	 eax, 4
  00159	c1 e0 00	 shl	 eax, 0
  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0015f	8b 94 01 04 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+772]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 ?SetNavIDWithRectRel@ImGui@@YAXIHABUImRect@@@Z ; ImGui::SetNavIDWithRectRel
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6064 :             g.NavLayer = layer;

  0016f	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00172	c7 80 28 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+6952], 1

; 6065 :             g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.

  0017c	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  0017f	c6 80 32 1b 00
	00 01		 mov	 BYTE PTR [eax+6962], 1

; 6066 :             g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;

  00186	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00189	c7 80 54 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+6996], 1

; 6067 :             NavMoveRequestCancel();

  00193	e8 00 00 00 00	 call	 ?NavMoveRequestCancel@ImGui@@YAXXZ ; ImGui::NavMoveRequestCancel
$LN7@EndMenuBar:

; 6068 :         }
; 6069 :     }
; 6070 : 
; 6071 :     IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);

  00198	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0019b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0019e	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  001a4	75 26		 jne	 SHORT $LN10@EndMenuBar
  001a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??EndMenuBar@ImGui@@YAXXZ@4JA
  001ac	83 c2 1b	 add	 edx, 27			; 0000001bH
  001af	8b f4		 mov	 esi, esp
  001b1	52		 push	 edx
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001b7	68 00 00 00 00	 push	 OFFSET ??_C@_1FC@MMAFNJJP@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAF?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG@
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c5	3b f4		 cmp	 esi, esp
  001c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@EndMenuBar:

; 6072 :     IM_ASSERT(window->DC.MenuBarAppending);

  001cc	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  001cf	0f b6 88 42 01
	00 00		 movzx	 ecx, BYTE PTR [eax+322]
  001d6	85 c9		 test	 ecx, ecx
  001d8	75 26		 jne	 SHORT $LN11@EndMenuBar
  001da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??EndMenuBar@ImGui@@YAXXZ@4JA
  001e0	83 c2 1c	 add	 edx, 28			; 0000001cH
  001e3	8b f4		 mov	 esi, esp
  001e5	52		 push	 edx
  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_1DI@HJHPMKIH@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn?$AAu@
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f9	3b f4		 cmp	 esi, esp
  001fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@EndMenuBar:

; 6073 :     PopClipRect();

  00200	e8 00 00 00 00	 call	 ?PopClipRect@ImGui@@YAXXZ ; ImGui::PopClipRect

; 6074 :     PopID();

  00205	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 6075 :     window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.

  0020a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00210	50		 push	 eax
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  00214	e8 00 00 00 00	 call	 ?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ ; ImGuiWindow::MenuBarRect
  00219	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0021c	f3 0f 10 81 c8
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+200]
  00224	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00228	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  0022b	f3 0f 11 82 44
	01 00 00	 movss	 DWORD PTR [edx+324], xmm0

; 6076 :     window->DC.GroupStack.back().EmitItem = false;

  00233	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  00236	81 c1 9c 01 00
	00		 add	 ecx, 412		; 0000019cH
  0023c	e8 00 00 00 00	 call	 ?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
  00241	c6 40 29 00	 mov	 BYTE PTR [eax+41], 0

; 6077 :     EndGroup(); // Restore position on layer 0

  00245	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 6078 :     window->DC.LayoutType = ImGuiLayoutType_Vertical;

  0024a	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0024d	c7 80 5c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+348], 1

; 6079 :     window->DC.NavLayerCurrent = ImGuiNavLayer_Main;

  00257	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0025a	c7 80 30 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+304], 0

; 6080 :     window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);

  00264	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00267	c7 80 34 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+308], 1

; 6081 :     window->DC.MenuBarAppending = false;

  00271	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00274	c6 80 42 01 00
	00 00		 mov	 BYTE PTR [eax+322], 0
$LN1@EndMenuBar:

; 6082 : }

  0027b	5f		 pop	 edi
  0027c	5e		 pop	 esi
  0027d	5b		 pop	 ebx
  0027e	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00284	3b ec		 cmp	 ebp, esp
  00286	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028b	8b e5		 mov	 esp, ebp
  0028d	5d		 pop	 ebp
  0028e	c3		 ret	 0
?EndMenuBar@ImGui@@YAXXZ ENDP				; ImGui::EndMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginMenuBar@ImGui@@YA_NXZ
_TEXT	SEGMENT
tv198 = -276						; size = 4
$T1 = -268						; size = 8
_clip_rect$ = -60					; size = 16
_bar_rect$ = -36					; size = 16
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?BeginMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMenuBar, COMDAT

; 6016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 6017 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 6018 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@BeginMenuB

; 6019 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 b8 01 00 00	 jmp	 $LN1@BeginMenuB
$LN2@BeginMenuB:

; 6020 :     if (!(window->Flags & ImGuiWindowFlags_MenuBar))

  0004c	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0004f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00052	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00058	75 07		 jne	 SHORT $LN3@BeginMenuB

; 6021 :         return false;

  0005a	32 c0		 xor	 al, al
  0005c	e9 a3 01 00 00	 jmp	 $LN1@BeginMenuB
$LN3@BeginMenuB:

; 6022 : 
; 6023 :     IM_ASSERT(!window->DC.MenuBarAppending);

  00061	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00064	0f b6 88 42 01
	00 00		 movzx	 ecx, BYTE PTR [eax+322]
  0006b	85 c9		 test	 ecx, ecx
  0006d	74 26		 je	 SHORT $LN5@BeginMenuB
  0006f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??BeginMenuBar@ImGui@@YA_NXZ@4JA
  00075	83 c2 07	 add	 edx, 7
  00078	8b f4		 mov	 esi, esp
  0007a	52		 push	 edx
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@MIADNLCN@?$AA?$CB?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAD?$AAC?$AA?4?$AAM?$AAe?$AAn@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	3b f4		 cmp	 esi, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@BeginMenuB:

; 6024 :     BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore

  00095	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 6025 :     PushID("##menubar");

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_09FHPMMDGK@?$CD?$CDmenubar@
  0009f	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  000a4	83 c4 04	 add	 esp, 4

; 6026 : 
; 6027 :     // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
; 6028 :     // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
; 6029 :     ImRect bar_rect = window->MenuBarRect();

  000a7	8d 45 dc	 lea	 eax, DWORD PTR _bar_rect$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000ae	e8 00 00 00 00	 call	 ?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ ; ImGuiWindow::MenuBarRect

; 6030 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding)), IM_ROUND(bar_rect.Max.y));

  000b3	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _bar_rect$[ebp+12]
  000b8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000c0	f3 0f 2c c0	 cvttss2si eax, xmm0
  000c4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000c8	51		 push	 ecx
  000c9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ce	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000d1	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _bar_rect$[ebp+8]
  000d6	f3 0f 5c 41 3c	 subss	 xmm0, DWORD PTR [ecx+60]
  000db	51		 push	 ecx
  000dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e1	51		 push	 ecx
  000e2	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _bar_rect$[ebp]
  000e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ec	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000f1	83 c4 08	 add	 esp, 8
  000f4	d9 9d ec fe ff
	ff		 fstp	 DWORD PTR tv198[ebp]
  000fa	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR tv198[ebp]
  00102	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0010a	f3 0f 2c d0	 cvttss2si edx, xmm0
  0010e	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00112	51		 push	 ecx
  00113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00118	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0011b	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _bar_rect$[ebp+4]
  00120	f3 0f 58 40 40	 addss	 xmm0, DWORD PTR [eax+64]
  00125	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0012d	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00131	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00135	51		 push	 ecx
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _bar_rect$[ebp]
  00140	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00148	f3 0f 2c d0	 cvttss2si edx, xmm0
  0014c	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00150	51		 push	 ecx
  00151	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00156	8d 4d c4	 lea	 ecx, DWORD PTR _clip_rect$[ebp]
  00159	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect

; 6031 :     clip_rect.ClipWith(window->OuterRectClipped);

  0015e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00161	05 c4 01 00 00	 add	 eax, 452		; 000001c4H
  00166	50		 push	 eax
  00167	8d 4d c4	 lea	 ecx, DWORD PTR _clip_rect$[ebp]
  0016a	e8 00 00 00 00	 call	 ?ClipWith@ImRect@@QAEXABU1@@Z ; ImRect::ClipWith

; 6032 :     PushClipRect(clip_rect.Min, clip_rect.Max, false);

  0016f	6a 00		 push	 0
  00171	8d 45 cc	 lea	 eax, DWORD PTR _clip_rect$[ebp+8]
  00174	50		 push	 eax
  00175	8d 4d c4	 lea	 ecx, DWORD PTR _clip_rect$[ebp]
  00178	51		 push	 ecx
  00179	e8 00 00 00 00	 call	 ?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6033 : 
; 6034 :     window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);

  00181	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00184	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _bar_rect$[ebp+4]
  00189	f3 0f 58 80 48
	01 00 00	 addss	 xmm0, DWORD PTR [eax+328]
  00191	51		 push	 ecx
  00192	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00197	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0019a	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _bar_rect$[ebp]
  0019f	f3 0f 58 81 44
	01 00 00	 addss	 xmm0, DWORD PTR [ecx+324]
  001a7	51		 push	 ecx
  001a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ad	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001b3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001b8	8b 10		 mov	 edx, DWORD PTR [eax]
  001ba	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001bd	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  001c0	89 91 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], edx
  001c6	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax

; 6035 :     window->DC.LayoutType = ImGuiLayoutType_Horizontal;

  001cc	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  001cf	c7 80 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+348], 0

; 6036 :     window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

  001d9	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  001dc	c7 80 30 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+304], 1

; 6037 :     window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  001e9	c7 80 34 01 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+308], 2

; 6038 :     window->DC.MenuBarAppending = true;

  001f3	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  001f6	c6 80 42 01 00
	00 01		 mov	 BYTE PTR [eax+322], 1

; 6039 :     AlignTextToFramePadding();

  001fd	e8 00 00 00 00	 call	 ?AlignTextToFramePadding@ImGui@@YAXXZ ; ImGui::AlignTextToFramePadding

; 6040 :     return true;

  00202	b0 01		 mov	 al, 1
$LN1@BeginMenuB:

; 6041 : }

  00204	52		 push	 edx
  00205	8b cd		 mov	 ecx, ebp
  00207	50		 push	 eax
  00208	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@BeginMenuB
  0020e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00213	58		 pop	 eax
  00214	5a		 pop	 edx
  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	5b		 pop	 ebx
  00218	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021b	33 cd		 xor	 ecx, ebp
  0021d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00222	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  00228	3b ec		 cmp	 ebp, esp
  0022a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
  00233	90		 npad	 1
$LN9@BeginMenuB:
  00234	02 00 00 00	 DD	 2
  00238	00 00 00 00	 DD	 $LN8@BeginMenuB
$LN8@BeginMenuB:
  0023c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00240	10 00 00 00	 DD	 16			; 00000010H
  00244	00 00 00 00	 DD	 $LN6@BeginMenuB
  00248	c4 ff ff ff	 DD	 -60			; ffffffc4H
  0024c	10 00 00 00	 DD	 16			; 00000010H
  00250	00 00 00 00	 DD	 $LN7@BeginMenuB
$LN7@BeginMenuB:
  00254	63		 DB	 99			; 00000063H
  00255	6c		 DB	 108			; 0000006cH
  00256	69		 DB	 105			; 00000069H
  00257	70		 DB	 112			; 00000070H
  00258	5f		 DB	 95			; 0000005fH
  00259	72		 DB	 114			; 00000072H
  0025a	65		 DB	 101			; 00000065H
  0025b	63		 DB	 99			; 00000063H
  0025c	74		 DB	 116			; 00000074H
  0025d	00		 DB	 0
$LN6@BeginMenuB:
  0025e	62		 DB	 98			; 00000062H
  0025f	61		 DB	 97			; 00000061H
  00260	72		 DB	 114			; 00000072H
  00261	5f		 DB	 95			; 0000005fH
  00262	72		 DB	 114			; 00000072H
  00263	65		 DB	 101			; 00000065H
  00264	63		 DB	 99			; 00000063H
  00265	74		 DB	 116			; 00000074H
  00266	00		 DB	 0
?BeginMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMenuBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Value@ImGui@@YAXPBDM0@Z
_TEXT	SEGMENT
_fmt$1 = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
_float_format$ = 16					; size = 4
?Value@ImGui@@YAXPBDM0@Z PROC				; ImGui::Value, COMDAT

; 5943 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5944 :     if (float_format)

  00032	83 7d 10 00	 cmp	 DWORD PTR _float_format$[ebp], 0
  00036	74 36		 je	 SHORT $LN2@Value

; 5945 :     {
; 5946 :         char fmt[64];
; 5947 :         ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);

  00038	8b 45 10	 mov	 eax, DWORD PTR _float_format$[ebp]
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@
  00041	6a 40		 push	 64			; 00000040H
  00043	8d 4d b8	 lea	 ecx, DWORD PTR _fmt$1[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 5948 :         Text(fmt, prefix, v);

  0004f	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR _v$[ebp]
  00054	83 ec 08	 sub	 esp, 8
  00057	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0005c	8b 45 08	 mov	 eax, DWORD PTR _prefix$[ebp]
  0005f	50		 push	 eax
  00060	8d 4d b8	 lea	 ecx, DWORD PTR _fmt$1[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00069	83 c4 10	 add	 esp, 16			; 00000010H

; 5949 :     }

  0006c	eb 1e		 jmp	 SHORT $LN3@Value
$LN2@Value:

; 5950 :     else
; 5951 :     {
; 5952 :         Text("%s: %.3f", prefix, v);

  0006e	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR _v$[ebp]
  00073	83 ec 08	 sub	 esp, 8
  00076	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007b	8b 45 08	 mov	 eax, DWORD PTR _prefix$[ebp]
  0007e	50		 push	 eax
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@
  00084	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00089	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@Value:

; 5953 :     }
; 5954 : }

  0008c	52		 push	 edx
  0008d	8b cd		 mov	 ecx, ebp
  0008f	50		 push	 eax
  00090	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@Value
  00096	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009b	58		 pop	 eax
  0009c	5a		 pop	 edx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a3	33 cd		 xor	 ecx, ebp
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  000b0	3b ec		 cmp	 ebp, esp
  000b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
  000bb	90		 npad	 1
$LN7@Value:
  000bc	01 00 00 00	 DD	 1
  000c0	00 00 00 00	 DD	 $LN6@Value
$LN6@Value:
  000c4	b8 ff ff ff	 DD	 -72			; ffffffb8H
  000c8	40 00 00 00	 DD	 64			; 00000040H
  000cc	00 00 00 00	 DD	 $LN5@Value
$LN5@Value:
  000d0	66		 DB	 102			; 00000066H
  000d1	6d		 DB	 109			; 0000006dH
  000d2	74		 DB	 116			; 00000074H
  000d3	00		 DB	 0
?Value@ImGui@@YAXPBDM0@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Value@ImGui@@YAXPBDI@Z
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
?Value@ImGui@@YAXPBDI@Z PROC				; ImGui::Value, COMDAT

; 5938 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5939 :     Text("%s: %d", prefix, v);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _prefix$[ebp]
  0002f	51		 push	 ecx
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_06GBEGMGE@?$CFs?3?5?$CFd@
  00035	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5940 : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?Value@ImGui@@YAXPBDI@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Value@ImGui@@YAXPBDH@Z
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
?Value@ImGui@@YAXPBDH@Z PROC				; ImGui::Value, COMDAT

; 5933 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5934 :     Text("%s: %d", prefix, v);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _prefix$[ebp]
  0002f	51		 push	 ecx
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_06GBEGMGE@?$CFs?3?5?$CFd@
  00035	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5935 : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?Value@ImGui@@YAXPBDH@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Value@ImGui@@YAXPBD_N@Z
_TEXT	SEGMENT
tv66 = -196						; size = 4
_prefix$ = 8						; size = 4
_b$ = 12						; size = 1
?Value@ImGui@@YAXPBD_N@Z PROC				; ImGui::Value, COMDAT

; 5928 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5929 :     Text("%s: %s", prefix, (b ? "true" : "false"));

  00028	0f b6 45 0c	 movzx	 eax, BYTE PTR _b$[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	74 0c		 je	 SHORT $LN3@Value
  00030	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], OFFSET ??_C@_04LOAJBDKD@true@
  0003a	eb 0a		 jmp	 SHORT $LN4@Value
$LN3@Value:
  0003c	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], OFFSET ??_C@_05LAPONLG@false@
$LN4@Value:
  00046	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 08	 mov	 edx, DWORD PTR _prefix$[ebp]
  00050	52		 push	 edx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_06DJHOIPC@?$CFs?3?5?$CFs@
  00056	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5930 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?Value@ImGui@@YAXPBD_N@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_values_getter$ = 12					; size = 4
_data$ = 16						; size = 4
_values_count$ = 20					; size = 4
_values_offset$ = 24					; size = 4
_overlay_text$ = 28					; size = 4
_scale_min$ = 32					; size = 4
_scale_max$ = 36					; size = 4
_graph_size$ = 40					; size = 8
?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z PROC ; ImGui::PlotHistogram, COMDAT

; 5916 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5917 :     PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

  00028	8b 45 2c	 mov	 eax, DWORD PTR _graph_size$[ebp+4]
  0002b	50		 push	 eax
  0002c	8b 4d 28	 mov	 ecx, DWORD PTR _graph_size$[ebp]
  0002f	51		 push	 ecx
  00030	51		 push	 ecx
  00031	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _scale_max$[ebp]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	51		 push	 ecx
  0003c	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  00041	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00046	8b 55 1c	 mov	 edx, DWORD PTR _overlay_text$[ebp]
  00049	52		 push	 edx
  0004a	8b 45 18	 mov	 eax, DWORD PTR _values_offset$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 14	 mov	 ecx, DWORD PTR _values_count$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  00055	52		 push	 edx
  00056	8b 45 0c	 mov	 eax, DWORD PTR _values_getter$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	e8 00 00 00 00	 call	 ?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
  00065	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5918 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ENDP ; ImGui::PlotHistogram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z
_TEXT	SEGMENT
_data$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_values$ = 12						; size = 4
_values_count$ = 16					; size = 4
_values_offset$ = 20					; size = 4
_overlay_text$ = 24					; size = 4
_scale_min$ = 28					; size = 4
_scale_max$ = 32					; size = 4
_graph_size$ = 36					; size = 8
_stride$ = 44						; size = 4
?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z PROC	; ImGui::PlotHistogram, COMDAT

; 5910 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5911 :     ImGuiPlotArrayGetterData data(values, stride);

  00032	8b 45 2c	 mov	 eax, DWORD PTR _stride$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _values$[ebp]
  00039	51		 push	 ecx
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR _data$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z ; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData

; 5912 :     PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

  00042	8b 45 28	 mov	 eax, DWORD PTR _graph_size$[ebp+4]
  00045	50		 push	 eax
  00046	8b 4d 24	 mov	 ecx, DWORD PTR _graph_size$[ebp]
  00049	51		 push	 ecx
  0004a	51		 push	 ecx
  0004b	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _scale_max$[ebp]
  00050	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00055	51		 push	 ecx
  00056	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  0005b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00060	8b 55 18	 mov	 edx, DWORD PTR _overlay_text$[ebp]
  00063	52		 push	 edx
  00064	8b 45 14	 mov	 eax, DWORD PTR _values_offset$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _values_count$[ebp]
  0006b	51		 push	 ecx
  0006c	8d 55 f0	 lea	 edx, DWORD PTR _data$[ebp]
  0006f	52		 push	 edx
  00070	68 00 00 00 00	 push	 OFFSET ?Plot_ArrayGetter@@YAMPAXH@Z ; Plot_ArrayGetter
  00075	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00078	50		 push	 eax
  00079	6a 01		 push	 1
  0007b	e8 00 00 00 00	 call	 ?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
  00080	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5913 : }

  00083	52		 push	 edx
  00084	8b cd		 mov	 ecx, ebp
  00086	50		 push	 eax
  00087	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@PlotHistog
  0008d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00092	58		 pop	 eax
  00093	5a		 pop	 edx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
  000b2	66 90		 npad	 2
$LN5@PlotHistog:
  000b4	01 00 00 00	 DD	 1
  000b8	00 00 00 00	 DD	 $LN4@PlotHistog
$LN4@PlotHistog:
  000bc	f0 ff ff ff	 DD	 -16			; fffffff0H
  000c0	08 00 00 00	 DD	 8
  000c4	00 00 00 00	 DD	 $LN3@PlotHistog
$LN3@PlotHistog:
  000c8	64		 DB	 100			; 00000064H
  000c9	61		 DB	 97			; 00000061H
  000ca	74		 DB	 116			; 00000074H
  000cb	61		 DB	 97			; 00000061H
  000cc	00		 DB	 0
?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ENDP	; ImGui::PlotHistogram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_values_getter$ = 12					; size = 4
_data$ = 16						; size = 4
_values_count$ = 20					; size = 4
_values_offset$ = 24					; size = 4
_overlay_text$ = 28					; size = 4
_scale_min$ = 32					; size = 4
_scale_max$ = 36					; size = 4
_graph_size$ = 40					; size = 8
?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z PROC ; ImGui::PlotLines, COMDAT

; 5905 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5906 :     PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

  00028	8b 45 2c	 mov	 eax, DWORD PTR _graph_size$[ebp+4]
  0002b	50		 push	 eax
  0002c	8b 4d 28	 mov	 ecx, DWORD PTR _graph_size$[ebp]
  0002f	51		 push	 ecx
  00030	51		 push	 ecx
  00031	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _scale_max$[ebp]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	51		 push	 ecx
  0003c	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  00041	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00046	8b 55 1c	 mov	 edx, DWORD PTR _overlay_text$[ebp]
  00049	52		 push	 edx
  0004a	8b 45 18	 mov	 eax, DWORD PTR _values_offset$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 14	 mov	 ecx, DWORD PTR _values_count$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 10	 mov	 edx, DWORD PTR _data$[ebp]
  00055	52		 push	 edx
  00056	8b 45 0c	 mov	 eax, DWORD PTR _values_getter$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	e8 00 00 00 00	 call	 ?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
  00065	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5907 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ENDP ; ImGui::PlotLines
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z
_TEXT	SEGMENT
_data$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_values$ = 12						; size = 4
_values_count$ = 16					; size = 4
_values_offset$ = 20					; size = 4
_overlay_text$ = 24					; size = 4
_scale_min$ = 28					; size = 4
_scale_max$ = 32					; size = 4
_graph_size$ = 36					; size = 8
_stride$ = 44						; size = 4
?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z PROC	; ImGui::PlotLines, COMDAT

; 5899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5900 :     ImGuiPlotArrayGetterData data(values, stride);

  00032	8b 45 2c	 mov	 eax, DWORD PTR _stride$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _values$[ebp]
  00039	51		 push	 ecx
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR _data$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z ; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData

; 5901 :     PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

  00042	8b 45 28	 mov	 eax, DWORD PTR _graph_size$[ebp+4]
  00045	50		 push	 eax
  00046	8b 4d 24	 mov	 ecx, DWORD PTR _graph_size$[ebp]
  00049	51		 push	 ecx
  0004a	51		 push	 ecx
  0004b	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _scale_max$[ebp]
  00050	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00055	51		 push	 ecx
  00056	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_min$[ebp]
  0005b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00060	8b 55 18	 mov	 edx, DWORD PTR _overlay_text$[ebp]
  00063	52		 push	 edx
  00064	8b 45 14	 mov	 eax, DWORD PTR _values_offset$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 10	 mov	 ecx, DWORD PTR _values_count$[ebp]
  0006b	51		 push	 ecx
  0006c	8d 55 f0	 lea	 edx, DWORD PTR _data$[ebp]
  0006f	52		 push	 edx
  00070	68 00 00 00 00	 push	 OFFSET ?Plot_ArrayGetter@@YAMPAXH@Z ; Plot_ArrayGetter
  00075	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00078	50		 push	 eax
  00079	6a 00		 push	 0
  0007b	e8 00 00 00 00	 call	 ?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
  00080	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5902 : }

  00083	52		 push	 edx
  00084	8b cd		 mov	 ecx, ebp
  00086	50		 push	 eax
  00087	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@PlotLines
  0008d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00092	58		 pop	 eax
  00093	5a		 pop	 edx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
  000b2	66 90		 npad	 2
$LN5@PlotLines:
  000b4	01 00 00 00	 DD	 1
  000b8	00 00 00 00	 DD	 $LN4@PlotLines
$LN4@PlotLines:
  000bc	f0 ff ff ff	 DD	 -16			; fffffff0H
  000c0	08 00 00 00	 DD	 8
  000c4	00 00 00 00	 DD	 $LN3@PlotLines
$LN3@PlotLines:
  000c8	64		 DB	 100			; 00000064H
  000c9	61		 DB	 97			; 00000061H
  000ca	74		 DB	 116			; 00000074H
  000cb	61		 DB	 97			; 00000061H
  000cc	00		 DB	 0
?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ENDP	; ImGui::PlotLines
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ListBoxFooter@ImGui@@YAXXZ
_TEXT	SEGMENT
_style$ = -48						; size = 4
_bb$ = -36						; size = 16
_parent_window$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
?ListBoxFooter@ImGui@@YAXXZ PROC			; ImGui::ListBoxFooter, COMDAT

; 5706 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5707 :     ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	8b 80 f0 02 00
	00		 mov	 eax, DWORD PTR [eax+752]
  0003d	89 45 f4	 mov	 DWORD PTR _parent_window$[ebp], eax

; 5708 :     const ImRect bb = parent_window->DC.LastItemRect;

  00040	8b 45 f4	 mov	 eax, DWORD PTR _parent_window$[ebp]
  00043	05 10 01 00 00	 add	 eax, 272		; 00000110H
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	89 4d dc	 mov	 DWORD PTR _bb$[ebp], ecx
  0004d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00050	89 55 e0	 mov	 DWORD PTR _bb$[ebp+4], edx
  00053	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00056	89 4d e4	 mov	 DWORD PTR _bb$[ebp+8], ecx
  00059	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0005c	89 55 e8	 mov	 DWORD PTR _bb$[ebp+12], edx

; 5709 :     const ImGuiStyle& style = GetStyle();

  0005f	e8 00 00 00 00	 call	 ?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ ; ImGui::GetStyle
  00064	89 45 d0	 mov	 DWORD PTR _style$[ebp], eax

; 5710 : 
; 5711 :     EndChildFrame();

  00067	e8 00 00 00 00	 call	 ?EndChildFrame@ImGui@@YAXXZ ; ImGui::EndChildFrame

; 5712 : 
; 5713 :     // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
; 5714 :     // We call SameLine() to restore DC.CurrentLine* data
; 5715 :     SameLine();

  0006c	51		 push	 ecx
  0006d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00075	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007a	51		 push	 ecx
  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00088	83 c4 08	 add	 esp, 8

; 5716 :     parent_window->DC.CursorPos = bb.Min;

  0008b	8b 45 f4	 mov	 eax, DWORD PTR _parent_window$[ebp]
  0008e	8b 4d dc	 mov	 ecx, DWORD PTR _bb$[ebp]
  00091	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  00097	8b 55 e0	 mov	 edx, DWORD PTR _bb$[ebp+4]
  0009a	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 5717 :     ItemSize(bb, style.FramePadding.y);

  000a0	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  000a3	51		 push	 ecx
  000a4	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  000a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ae	8d 4d dc	 lea	 ecx, DWORD PTR _bb$[ebp]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  000b7	83 c4 08	 add	 esp, 8

; 5718 :     EndGroup();

  000ba	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 5719 : }

  000bf	52		 push	 edx
  000c0	8b cd		 mov	 ecx, ebp
  000c2	50		 push	 eax
  000c3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@ListBoxFoo
  000c9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ce	58		 pop	 eax
  000cf	5a		 pop	 edx
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000e3	3b ec		 cmp	 ebp, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
  000ee	66 90		 npad	 2
$LN5@ListBoxFoo:
  000f0	01 00 00 00	 DD	 1
  000f4	00 00 00 00	 DD	 $LN4@ListBoxFoo
$LN4@ListBoxFoo:
  000f8	dc ff ff ff	 DD	 -36			; ffffffdcH
  000fc	10 00 00 00	 DD	 16			; 00000010H
  00100	00 00 00 00	 DD	 $LN3@ListBoxFoo
$LN3@ListBoxFoo:
  00104	62		 DB	 98			; 00000062H
  00105	62		 DB	 98			; 00000062H
  00106	00		 DB	 0
?ListBoxFooter@ImGui@@YAXXZ ENDP			; ImGui::ListBoxFooter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ListBoxHeader@ImGui@@YA_NPBDHH@Z
_TEXT	SEGMENT
tv132 = -240						; size = 4
tv76 = -240						; size = 4
_size$ = -40						; size = 8
_height_in_items_f$ = -24				; size = 4
_style$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_items_count$ = 12					; size = 4
_height_in_items$ = 16					; size = 4
?ListBoxHeader@ImGui@@YA_NPBDHH@Z PROC			; ImGui::ListBoxHeader, COMDAT

; 5687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5688 :     // Size default to hold ~7.25 items.
; 5689 :     // We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.
; 5690 :     // We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
; 5691 :     // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
; 5692 :     if (height_in_items < 0)

  00032	83 7d 10 00	 cmp	 DWORD PTR _height_in_items$[ebp], 0
  00036	7d 11		 jge	 SHORT $LN2@ListBoxHea

; 5693 :         height_in_items = ImMin(items_count, 7);

  00038	6a 07		 push	 7
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _items_count$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  00043	83 c4 08	 add	 esp, 8
  00046	89 45 10	 mov	 DWORD PTR _height_in_items$[ebp], eax
$LN2@ListBoxHea:

; 5694 :     const ImGuiStyle& style = GetStyle();

  00049	e8 00 00 00 00	 call	 ?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ ; ImGui::GetStyle
  0004e	89 45 f4	 mov	 DWORD PTR _style$[ebp], eax

; 5695 :     float height_in_items_f = (height_in_items < items_count) ? (height_in_items + 0.25f) : (height_in_items + 0.00f);

  00051	8b 45 10	 mov	 eax, DWORD PTR _height_in_items$[ebp]
  00054	3b 45 0c	 cmp	 eax, DWORD PTR _items_count$[ebp]
  00057	7d 17		 jge	 SHORT $LN4@ListBoxHea
  00059	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _height_in_items$[ebp]
  0005e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3e800000
  00066	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR tv76[ebp], xmm0
  0006e	eb 15		 jmp	 SHORT $LN5@ListBoxHea
$LN4@ListBoxHea:
  00070	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _height_in_items$[ebp]
  00075	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@00000000
  0007d	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR tv76[ebp], xmm0
$LN5@ListBoxHea:
  00085	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR tv76[ebp]
  0008d	f3 0f 11 45 e8	 movss	 DWORD PTR _height_in_items_f$[ebp], xmm0

; 5696 : 
; 5697 :     // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
; 5698 :     ImVec2 size;

  00092	8d 4d d8	 lea	 ecx, DWORD PTR _size$[ebp]
  00095	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2

; 5699 :     size.x = 0.0f;

  0009a	0f 57 c0	 xorps	 xmm0, xmm0
  0009d	f3 0f 11 45 d8	 movss	 DWORD PTR _size$[ebp], xmm0

; 5700 :     size.y = ImFloor(GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f);

  000a2	e8 00 00 00 00	 call	 ?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
  000a7	d9 9d 10 ff ff
	ff		 fstp	 DWORD PTR tv132[ebp]
  000ad	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR tv132[ebp]
  000b5	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _height_in_items_f$[ebp]
  000ba	8b 45 f4	 mov	 eax, DWORD PTR _style$[ebp]
  000bd	f3 0f 10 48 3c	 movss	 xmm1, DWORD PTR [eax+60]
  000c2	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  000ca	f3 0f 58 c1	 addss	 xmm0, xmm1
  000ce	51		 push	 ecx
  000cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d4	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  000d9	83 c4 04	 add	 esp, 4
  000dc	d9 5d dc	 fstp	 DWORD PTR _size$[ebp+4]

; 5701 :     return ListBoxHeader(label, size);

  000df	8d 45 d8	 lea	 eax, DWORD PTR _size$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::ListBoxHeader
  000ec	83 c4 08	 add	 esp, 8

; 5702 : }

  000ef	52		 push	 edx
  000f0	8b cd		 mov	 ecx, ebp
  000f2	50		 push	 eax
  000f3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@ListBoxHea
  000f9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fe	58		 pop	 eax
  000ff	5a		 pop	 edx
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00113	3b ec		 cmp	 ebp, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
  0011e	66 90		 npad	 2
$LN8@ListBoxHea:
  00120	01 00 00 00	 DD	 1
  00124	00 00 00 00	 DD	 $LN7@ListBoxHea
$LN7@ListBoxHea:
  00128	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0012c	08 00 00 00	 DD	 8
  00130	00 00 00 00	 DD	 $LN6@ListBoxHea
$LN6@ListBoxHea:
  00134	73		 DB	 115			; 00000073H
  00135	69		 DB	 105			; 00000069H
  00136	7a		 DB	 122			; 0000007aH
  00137	65		 DB	 101			; 00000065H
  00138	00		 DB	 0
?ListBoxHeader@ImGui@@YA_NPBDHH@Z ENDP			; ImGui::ListBoxHeader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z
_TEXT	SEGMENT
tv207 = -440						; size = 4
tv145 = -440						; size = 4
$T1 = -432						; size = 8
$T2 = -416						; size = 8
$T3 = -400						; size = 8
$T4 = -384						; size = 8
$T5 = -368						; size = 8
$T6 = -352						; size = 8
_bb$ = -144						; size = 16
_frame_bb$ = -120					; size = 16
_frame_size$ = -96					; size = 8
_size$ = -80						; size = 8
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_size_arg$ = 12						; size = 4
?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z PROC		; ImGui::ListBoxHeader, COMDAT

; 5652 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 01 00
	00		 sub	 esp, 440		; 000001b8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 48 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-440]
  00012	b9 6e 00 00 00	 mov	 ecx, 110		; 0000006eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5653 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 5654 :     ImGuiWindow* window = GetCurrentWindow();

  0003a	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0003f	89 45 e8	 mov	 DWORD PTR _window$[ebp], eax

; 5655 :     if (window->SkipItems)

  00042	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00045	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00049	85 c9		 test	 ecx, ecx
  0004b	74 07		 je	 SHORT $LN2@ListBoxHea

; 5656 :         return false;

  0004d	32 c0		 xor	 al, al
  0004f	e9 70 02 00 00	 jmp	 $LN1@ListBoxHea
$LN2@ListBoxHea:

; 5657 : 
; 5658 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 5659 :     const ImGuiID id = GetID(label);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?GetID@ImGui@@YAIPBD@Z	; ImGui::GetID
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 5660 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  0006e	51		 push	 ecx
  0006f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	6a 01		 push	 1
  0007e	6a 00		 push	 0
  00080	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00083	50		 push	 eax
  00084	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0008d	83 c4 14	 add	 esp, 20			; 00000014H

; 5661 : 
; 5662 :     // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
; 5663 :     ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);

  00090	e8 00 00 00 00	 call	 ?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
  00095	d9 9d 48 fe ff
	ff		 fstp	 DWORD PTR tv207[ebp]
  0009b	f3 0f 10 85 48
	fe ff ff	 movss	 xmm0, DWORD PTR tv207[ebp]
  000a3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40eccccd
  000ab	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000ae	f3 0f 58 40 4c	 addss	 xmm0, DWORD PTR [eax+76]
  000b3	51		 push	 ecx
  000b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b9	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  000be	51		 push	 ecx
  000bf	d9 1c 24	 fstp	 DWORD PTR [esp]
  000c2	8b 4d 0c	 mov	 ecx, DWORD PTR _size_arg$[ebp]
  000c5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c8	52		 push	 edx
  000c9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cb	50		 push	 eax
  000cc	8d 4d b0	 lea	 ecx, DWORD PTR _size$[ebp]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 ?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
  000d5	83 c4 14	 add	 esp, 20			; 00000014H

; 5664 :     ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));

  000d8	51		 push	 ecx
  000d9	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e3	51		 push	 ecx
  000e4	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  000e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ee	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000f3	83 c4 04	 add	 esp, 4
  000f6	d9 1c 24	 fstp	 DWORD PTR [esp]
  000f9	51		 push	 ecx
  000fa	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _size$[ebp]
  000ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00104	8d 4d a0	 lea	 ecx, DWORD PTR _frame_size$[ebp]
  00107	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 5665 :     ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);

  0010c	8d 45 a0	 lea	 eax, DWORD PTR _frame_size$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  00113	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  00119	51		 push	 ecx
  0011a	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH
  00129	50		 push	 eax
  0012a	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0012d	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  00132	50		 push	 eax
  00133	8d 4d 88	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00136	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 5666 :     ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

  0013b	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00140	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00147	76 17		 jbe	 SHORT $LN6@ListBoxHea
  00149	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0014c	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00151	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  00156	f3 0f 11 85 48
	fe ff ff	 movss	 DWORD PTR tv145[ebp], xmm0
  0015e	eb 0b		 jmp	 SHORT $LN7@ListBoxHea
$LN6@ListBoxHea:
  00160	0f 57 c0	 xorps	 xmm0, xmm0
  00163	f3 0f 11 85 48
	fe ff ff	 movss	 DWORD PTR tv145[ebp], xmm0
$LN7@ListBoxHea:
  0016b	51		 push	 ecx
  0016c	0f 57 c0	 xorps	 xmm0, xmm0
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	51		 push	 ecx
  00175	f3 0f 10 85 48
	fe ff ff	 movss	 xmm0, DWORD PTR tv145[ebp]
  0017d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00182	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00188	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0018d	50		 push	 eax
  0018e	8d 4d 90	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  00191	51		 push	 ecx
  00192	8d 95 80 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00198	52		 push	 edx
  00199	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0019e	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a1	50		 push	 eax
  001a2	8d 45 88	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  001a5	50		 push	 eax
  001a6	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  001ac	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 5667 :     window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

  001b1	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  001b4	05 10 01 00 00	 add	 eax, 272		; 00000110H
  001b9	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _bb$[ebp]
  001bf	89 08		 mov	 DWORD PTR [eax], ecx
  001c1	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _bb$[ebp+4]
  001c7	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001ca	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _bb$[ebp+8]
  001d0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001d3	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _bb$[ebp+12]
  001d9	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 5668 :     g.NextItemData.ClearFlags();

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  001df	81 c1 84 1a 00
	00		 add	 ecx, 6788		; 00001a84H
  001e5	e8 00 00 00 00	 call	 ?ClearFlags@ImGuiNextItemData@@QAEXXZ ; ImGuiNextItemData::ClearFlags

; 5669 : 
; 5670 :     if (!IsRectVisible(bb.Min, bb.Max))

  001ea	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _bb$[ebp+8]
  001f0	50		 push	 eax
  001f1	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  001f7	51		 push	 ecx
  001f8	e8 00 00 00 00	 call	 ?IsRectVisible@ImGui@@YA_NABUImVec2@@0@Z ; ImGui::IsRectVisible
  001fd	83 c4 08	 add	 esp, 8
  00200	0f b6 d0	 movzx	 edx, al
  00203	85 d2		 test	 edx, edx
  00205	75 42		 jne	 SHORT $LN3@ListBoxHea

; 5671 :     {
; 5672 :         ItemSize(bb.GetSize(), style.FramePadding.y);

  00207	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0020a	51		 push	 ecx
  0020b	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00210	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00215	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0021b	51		 push	 ecx
  0021c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  00222	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetSize
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  0022d	83 c4 08	 add	 esp, 8

; 5673 :         ItemAdd(bb, 0, &frame_bb);

  00230	8d 45 88	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00233	50		 push	 eax
  00234	6a 00		 push	 0
  00236	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  0023c	51		 push	 ecx
  0023d	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5674 :         return false;

  00245	32 c0		 xor	 al, al
  00247	eb 7b		 jmp	 SHORT $LN1@ListBoxHea
$LN3@ListBoxHea:

; 5675 :     }
; 5676 : 
; 5677 :     BeginGroup();

  00249	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 5678 :     if (label_size.x > 0)

  0024e	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00253	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0025a	76 48		 jbe	 SHORT $LN4@ListBoxHea

; 5679 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

  0025c	6a 01		 push	 1
  0025e	6a 00		 push	 0
  00260	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00263	50		 push	 eax
  00264	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00267	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  0026c	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  00271	51		 push	 ecx
  00272	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00277	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  0027a	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  0027f	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  00284	51		 push	 ecx
  00285	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028a	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00290	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00295	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00298	51		 push	 ecx
  00299	8b 10		 mov	 edx, DWORD PTR [eax]
  0029b	52		 push	 edx
  0029c	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  002a1	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@ListBoxHea:

; 5680 : 
; 5681 :     BeginChildFrame(id, frame_bb.GetSize());

  002a4	6a 00		 push	 0
  002a6	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  002ac	50		 push	 eax
  002ad	8d 4d 88	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  002b0	e8 00 00 00 00	 call	 ?GetSize@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetSize
  002b5	50		 push	 eax
  002b6	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  002b9	51		 push	 ecx
  002ba	e8 00 00 00 00	 call	 ?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z ; ImGui::BeginChildFrame
  002bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5682 :     return true;

  002c2	b0 01		 mov	 al, 1
$LN1@ListBoxHea:

; 5683 : }

  002c4	52		 push	 edx
  002c5	8b cd		 mov	 ecx, ebp
  002c7	50		 push	 eax
  002c8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@ListBoxHea
  002ce	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002d3	58		 pop	 eax
  002d4	5a		 pop	 edx
  002d5	5f		 pop	 edi
  002d6	5e		 pop	 esi
  002d7	5b		 pop	 ebx
  002d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002db	33 cd		 xor	 ecx, ebp
  002dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e2	81 c4 b8 01 00
	00		 add	 esp, 440		; 000001b8H
  002e8	3b ec		 cmp	 ebp, esp
  002ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ef	8b e5		 mov	 esp, ebp
  002f1	5d		 pop	 ebp
  002f2	c3		 ret	 0
  002f3	90		 npad	 1
$LN14@ListBoxHea:
  002f4	05 00 00 00	 DD	 5
  002f8	00 00 00 00	 DD	 $LN13@ListBoxHea
$LN13@ListBoxHea:
  002fc	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00300	08 00 00 00	 DD	 8
  00304	00 00 00 00	 DD	 $LN8@ListBoxHea
  00308	b0 ff ff ff	 DD	 -80			; ffffffb0H
  0030c	08 00 00 00	 DD	 8
  00310	00 00 00 00	 DD	 $LN9@ListBoxHea
  00314	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00318	08 00 00 00	 DD	 8
  0031c	00 00 00 00	 DD	 $LN10@ListBoxHea
  00320	88 ff ff ff	 DD	 -120			; ffffff88H
  00324	10 00 00 00	 DD	 16			; 00000010H
  00328	00 00 00 00	 DD	 $LN11@ListBoxHea
  0032c	70 ff ff ff	 DD	 -144			; ffffff70H
  00330	10 00 00 00	 DD	 16			; 00000010H
  00334	00 00 00 00	 DD	 $LN12@ListBoxHea
$LN12@ListBoxHea:
  00338	62		 DB	 98			; 00000062H
  00339	62		 DB	 98			; 00000062H
  0033a	00		 DB	 0
$LN11@ListBoxHea:
  0033b	66		 DB	 102			; 00000066H
  0033c	72		 DB	 114			; 00000072H
  0033d	61		 DB	 97			; 00000061H
  0033e	6d		 DB	 109			; 0000006dH
  0033f	65		 DB	 101			; 00000065H
  00340	5f		 DB	 95			; 0000005fH
  00341	62		 DB	 98			; 00000062H
  00342	62		 DB	 98			; 00000062H
  00343	00		 DB	 0
$LN10@ListBoxHea:
  00344	66		 DB	 102			; 00000066H
  00345	72		 DB	 114			; 00000072H
  00346	61		 DB	 97			; 00000061H
  00347	6d		 DB	 109			; 0000006dH
  00348	65		 DB	 101			; 00000065H
  00349	5f		 DB	 95			; 0000005fH
  0034a	73		 DB	 115			; 00000073H
  0034b	69		 DB	 105			; 00000069H
  0034c	7a		 DB	 122			; 0000007aH
  0034d	65		 DB	 101			; 00000065H
  0034e	00		 DB	 0
$LN9@ListBoxHea:
  0034f	73		 DB	 115			; 00000073H
  00350	69		 DB	 105			; 00000069H
  00351	7a		 DB	 122			; 0000007aH
  00352	65		 DB	 101			; 00000065H
  00353	00		 DB	 0
$LN8@ListBoxHea:
  00354	6c		 DB	 108			; 0000006cH
  00355	61		 DB	 97			; 00000061H
  00356	62		 DB	 98			; 00000062H
  00357	65		 DB	 101			; 00000065H
  00358	6c		 DB	 108			; 0000006cH
  00359	5f		 DB	 95			; 0000005fH
  0035a	73		 DB	 115			; 00000073H
  0035b	69		 DB	 105			; 00000069H
  0035c	7a		 DB	 122			; 0000007aH
  0035d	65		 DB	 101			; 00000065H
  0035e	00		 DB	 0
?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z ENDP		; ImGui::ListBoxHeader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z
_TEXT	SEGMENT
tv83 = -329						; size = 1
$T2 = -321						; size = 1
$T3 = -312						; size = 8
_item_text$4 = -104					; size = 4
_item_selected$5 = -89					; size = 1
_i$6 = -80						; size = 4
_clipper$ = -68						; size = 24
_value_changed$ = -33					; size = 1
_g$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items_getter$ = 16					; size = 4
_data$ = 20						; size = 4
_items_count$ = 24					; size = 4
_height_in_items$ = 28					; size = 4
?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z PROC	; ImGui::ListBox, COMDAT

; 5728 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00020	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5729 :     if (!ListBoxHeader(label, items_count, height_in_items))

  0004a	8b 45 1c	 mov	 eax, DWORD PTR _height_in_items$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 18	 mov	 ecx, DWORD PTR _items_count$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?ListBoxHeader@ImGui@@YA_NPBDHH@Z ; ImGui::ListBoxHeader
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	0f b6 c0	 movzx	 eax, al
  00061	85 c0		 test	 eax, eax
  00063	75 07		 jne	 SHORT $LN7@ListBox

; 5730 :         return false;

  00065	32 c0		 xor	 al, al
  00067	e9 53 01 00 00	 jmp	 $LN1@ListBox
$LN7@ListBox:

; 5731 : 
; 5732 :     // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
; 5733 :     ImGuiContext& g = *GImGui;

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00071	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 5734 :     bool value_changed = false;

  00074	c6 45 df 00	 mov	 BYTE PTR _value_changed$[ebp], 0

; 5735 :     ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.

  00078	e8 00 00 00 00	 call	 ?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
  0007d	51		 push	 ecx
  0007e	d9 1c 24	 fstp	 DWORD PTR [esp]
  00081	8b 45 18	 mov	 eax, DWORD PTR _items_count$[ebp]
  00084	50		 push	 eax
  00085	8d 4d bc	 lea	 ecx, DWORD PTR _clipper$[ebp]
  00088	e8 00 00 00 00	 call	 ??0ImGuiListClipper@@QAE@HM@Z ; ImGuiListClipper::ImGuiListClipper
  0008d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$LN2@ListBox:

; 5736 :     while (clipper.Step())

  00094	8d 4d bc	 lea	 ecx, DWORD PTR _clipper$[ebp]
  00097	e8 00 00 00 00	 call	 ?Step@ImGuiListClipper@@QAE_NXZ ; ImGuiListClipper::Step
  0009c	0f b6 c0	 movzx	 eax, al
  0009f	85 c0		 test	 eax, eax
  000a1	0f 84 d5 00 00
	00		 je	 $LN3@ListBox

; 5737 :         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)

  000a7	8b 45 cc	 mov	 eax, DWORD PTR _clipper$[ebp+16]
  000aa	89 45 b0	 mov	 DWORD PTR _i$6[ebp], eax
  000ad	eb 09		 jmp	 SHORT $LN6@ListBox
$LN4@ListBox:
  000af	8b 45 b0	 mov	 eax, DWORD PTR _i$6[ebp]
  000b2	83 c0 01	 add	 eax, 1
  000b5	89 45 b0	 mov	 DWORD PTR _i$6[ebp], eax
$LN6@ListBox:
  000b8	8b 45 b0	 mov	 eax, DWORD PTR _i$6[ebp]
  000bb	3b 45 d0	 cmp	 eax, DWORD PTR _clipper$[ebp+20]
  000be	0f 8d b3 00 00
	00		 jge	 $LN5@ListBox

; 5738 :         {
; 5739 :             const bool item_selected = (i == *current_item);

  000c4	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  000c7	8b 4d b0	 mov	 ecx, DWORD PTR _i$6[ebp]
  000ca	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000cc	75 09		 jne	 SHORT $LN13@ListBox
  000ce	c6 85 b7 fe ff
	ff 01		 mov	 BYTE PTR tv83[ebp], 1
  000d5	eb 07		 jmp	 SHORT $LN14@ListBox
$LN13@ListBox:
  000d7	c6 85 b7 fe ff
	ff 00		 mov	 BYTE PTR tv83[ebp], 0
$LN14@ListBox:
  000de	8a 95 b7 fe ff
	ff		 mov	 dl, BYTE PTR tv83[ebp]
  000e4	88 55 a7	 mov	 BYTE PTR _item_selected$5[ebp], dl

; 5740 :             const char* item_text;
; 5741 :             if (!items_getter(data, i, &item_text))

  000e7	8b f4		 mov	 esi, esp
  000e9	8d 45 98	 lea	 eax, DWORD PTR _item_text$4[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d b0	 mov	 ecx, DWORD PTR _i$6[ebp]
  000f0	51		 push	 ecx
  000f1	8b 55 14	 mov	 edx, DWORD PTR _data$[ebp]
  000f4	52		 push	 edx
  000f5	ff 55 10	 call	 DWORD PTR _items_getter$[ebp]
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fb	3b f4		 cmp	 esi, esp
  000fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00102	0f b6 c0	 movzx	 eax, al
  00105	85 c0		 test	 eax, eax
  00107	75 07		 jne	 SHORT $LN8@ListBox

; 5742 :                 item_text = "*Unknown item*";

  00109	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _item_text$4[ebp], OFFSET ??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
$LN8@ListBox:

; 5743 : 
; 5744 :             PushID(i);

  00110	8b 45 b0	 mov	 eax, DWORD PTR _i$6[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID
  00119	83 c4 04	 add	 esp, 4

; 5745 :             if (Selectable(item_text, item_selected))

  0011c	51		 push	 ecx
  0011d	0f 57 c0	 xorps	 xmm0, xmm0
  00120	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00125	51		 push	 ecx
  00126	0f 57 c0	 xorps	 xmm0, xmm0
  00129	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012e	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00134	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00139	50		 push	 eax
  0013a	6a 00		 push	 0
  0013c	0f b6 45 a7	 movzx	 eax, BYTE PTR _item_selected$5[ebp]
  00140	50		 push	 eax
  00141	8b 4d 98	 mov	 ecx, DWORD PTR _item_text$4[ebp]
  00144	51		 push	 ecx
  00145	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  0014a	83 c4 10	 add	 esp, 16			; 00000010H
  0014d	0f b6 d0	 movzx	 edx, al
  00150	85 d2		 test	 edx, edx
  00152	74 0c		 je	 SHORT $LN9@ListBox

; 5746 :             {
; 5747 :                 *current_item = i;

  00154	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  00157	8b 4d b0	 mov	 ecx, DWORD PTR _i$6[ebp]
  0015a	89 08		 mov	 DWORD PTR [eax], ecx

; 5748 :                 value_changed = true;

  0015c	c6 45 df 01	 mov	 BYTE PTR _value_changed$[ebp], 1
$LN9@ListBox:

; 5749 :             }
; 5750 :             if (item_selected)

  00160	0f b6 45 a7	 movzx	 eax, BYTE PTR _item_selected$5[ebp]
  00164	85 c0		 test	 eax, eax
  00166	74 05		 je	 SHORT $LN10@ListBox

; 5751 :                 SetItemDefaultFocus();

  00168	e8 00 00 00 00	 call	 ?SetItemDefaultFocus@ImGui@@YAXXZ ; ImGui::SetItemDefaultFocus
$LN10@ListBox:

; 5752 :             PopID();

  0016d	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 5753 :         }

  00172	e9 38 ff ff ff	 jmp	 $LN4@ListBox
$LN5@ListBox:
  00177	e9 18 ff ff ff	 jmp	 $LN2@ListBox
$LN3@ListBox:

; 5754 :     ListBoxFooter();

  0017c	e8 00 00 00 00	 call	 ?ListBoxFooter@ImGui@@YAXXZ ; ImGui::ListBoxFooter

; 5755 :     if (value_changed)

  00181	0f b6 45 df	 movzx	 eax, BYTE PTR _value_changed$[ebp]
  00185	85 c0		 test	 eax, eax
  00187	74 18		 je	 SHORT $LN11@ListBox

; 5756 :         MarkItemEdited(g.CurrentWindow->DC.LastItemId);

  00189	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0018c	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00192	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR [ecx+264]
  00198	52		 push	 edx
  00199	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  0019e	83 c4 04	 add	 esp, 4
$LN11@ListBox:

; 5757 : 
; 5758 :     return value_changed;

  001a1	8a 45 df	 mov	 al, BYTE PTR _value_changed$[ebp]
  001a4	88 85 bf fe ff
	ff		 mov	 BYTE PTR $T2[ebp], al
  001aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001b1	8d 4d bc	 lea	 ecx, DWORD PTR _clipper$[ebp]
  001b4	e8 00 00 00 00	 call	 ??1ImGuiListClipper@@QAE@XZ ; ImGuiListClipper::~ImGuiListClipper
  001b9	8a 85 bf fe ff
	ff		 mov	 al, BYTE PTR $T2[ebp]
$LN1@ListBox:

; 5759 : }

  001bf	52		 push	 edx
  001c0	8b cd		 mov	 ecx, ebp
  001c2	50		 push	 eax
  001c3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@ListBox
  001c9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ce	58		 pop	 eax
  001cf	5a		 pop	 edx
  001d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001da	59		 pop	 ecx
  001db	5f		 pop	 edi
  001dc	5e		 pop	 esi
  001dd	5b		 pop	 ebx
  001de	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e1	33 cd		 xor	 ecx, ebp
  001e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e8	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  001ee	3b ec		 cmp	 ebp, esp
  001f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f5	8b e5		 mov	 esp, ebp
  001f7	5d		 pop	 ebp
  001f8	c3		 ret	 0
  001f9	0f 1f 00	 npad	 3
$LN20@ListBox:
  001fc	02 00 00 00	 DD	 2
  00200	00 00 00 00	 DD	 $LN19@ListBox
$LN19@ListBox:
  00204	bc ff ff ff	 DD	 -68			; ffffffbcH
  00208	18 00 00 00	 DD	 24			; 00000018H
  0020c	00 00 00 00	 DD	 $LN16@ListBox
  00210	98 ff ff ff	 DD	 -104			; ffffff98H
  00214	04 00 00 00	 DD	 4
  00218	00 00 00 00	 DD	 $LN17@ListBox
$LN17@ListBox:
  0021c	69		 DB	 105			; 00000069H
  0021d	74		 DB	 116			; 00000074H
  0021e	65		 DB	 101			; 00000065H
  0021f	6d		 DB	 109			; 0000006dH
  00220	5f		 DB	 95			; 0000005fH
  00221	74		 DB	 116			; 00000074H
  00222	65		 DB	 101			; 00000065H
  00223	78		 DB	 120			; 00000078H
  00224	74		 DB	 116			; 00000074H
  00225	00		 DB	 0
$LN16@ListBox:
  00226	63		 DB	 99			; 00000063H
  00227	6c		 DB	 108			; 0000006cH
  00228	69		 DB	 105			; 00000069H
  00229	70		 DB	 112			; 00000070H
  0022a	70		 DB	 112			; 00000070H
  0022b	65		 DB	 101			; 00000065H
  0022c	72		 DB	 114			; 00000072H
  0022d	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR _clipper$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ImGuiListClipper@@QAE@XZ ; ImGuiListClipper::~ImGuiListClipper
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a b0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-336]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ENDP	; ImGui::ListBox
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ListBox@ImGui@@YA_NPBDPAHQBQBDHH@Z
_TEXT	SEGMENT
_value_changed$ = -5					; size = 1
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items$ = 16						; size = 4
_items_count$ = 20					; size = 4
_height_items$ = 24					; size = 4
?ListBox@ImGui@@YA_NPBDPAHQBQBDHH@Z PROC		; ImGui::ListBox, COMDAT

; 5722 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5723 :     const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);

  00028	8b 45 18	 mov	 eax, DWORD PTR _height_items$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _items_count$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 10	 mov	 edx, DWORD PTR _items$[ebp]
  00033	52		 push	 edx
  00034	68 00 00 00 00	 push	 OFFSET ?Items_ArrayGetter@@YA_NPAXHPAPBD@Z ; Items_ArrayGetter
  00039	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ; ImGui::ListBox
  00046	83 c4 18	 add	 esp, 24			; 00000018H
  00049	88 45 fb	 mov	 BYTE PTR _value_changed$[ebp], al

; 5724 :     return value_changed;

  0004c	8a 45 fb	 mov	 al, BYTE PTR _value_changed$[ebp]

; 5725 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?ListBox@ImGui@@YA_NPBDPAHQBQBDHH@Z ENDP		; ImGui::ListBox
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z
_TEXT	SEGMENT
tv73 = -196						; size = 4
_label$ = 8						; size = 4
_p_selected$ = 12					; size = 4
_flags$ = 16						; size = 4
_size_arg$ = 20						; size = 4
?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z PROC	; ImGui::Selectable, COMDAT

; 5628 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5629 :     if (Selectable(label, *p_selected, flags, size_arg))

  00028	8b 45 14	 mov	 eax, DWORD PTR _size_arg$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _p_selected$[ebp]
  00033	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	0f b6 d0	 movzx	 edx, al
  00046	85 d2		 test	 edx, edx
  00048	74 2f		 je	 SHORT $LN2@Selectable

; 5630 :     {
; 5631 :         *p_selected = !*p_selected;

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _p_selected$[ebp]
  0004d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00050	85 c9		 test	 ecx, ecx
  00052	75 0c		 jne	 SHORT $LN4@Selectable
  00054	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv73[ebp], 1
  0005e	eb 0a		 jmp	 SHORT $LN5@Selectable
$LN4@Selectable:
  00060	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN5@Selectable:
  0006a	8b 55 0c	 mov	 edx, DWORD PTR _p_selected$[ebp]
  0006d	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv73[ebp]
  00073	88 02		 mov	 BYTE PTR [edx], al

; 5632 :         return true;

  00075	b0 01		 mov	 al, 1
  00077	eb 02		 jmp	 SHORT $LN1@Selectable
$LN2@Selectable:

; 5633 :     }
; 5634 :     return false;

  00079	32 c0		 xor	 al, al
$LN1@Selectable:

; 5635 : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ENDP	; ImGui::Selectable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z
_TEXT	SEGMENT
tv336 = -628						; size = 4
tv172 = -628						; size = 4
tv93 = -628						; size = 4
tv337 = -624						; size = 4
tv165 = -624						; size = 4
tv151 = -624						; size = 4
tv88 = -624						; size = 4
$T1 = -616						; size = 8
$T2 = -600						; size = 8
$T3 = -584						; size = 8
$T4 = -568						; size = 8
$T5 = -552						; size = 8
_col$6 = -344						; size = 4
_pressed$ = -329					; size = 1
_held$ = -317						; size = 1
_hovered$ = -305					; size = 1
_was_selected$ = -293					; size = 1
_button_flags$ = -284					; size = 4
_backup_item_flags$7 = -272				; size = 4
_item_add$ = -257					; size = 1
_spacing_U$ = -248					; size = 4
_spacing_L$ = -236					; size = 4
_spacing_y$ = -224					; size = 4
_spacing_x$ = -212					; size = 4
_bb$ = -200						; size = 16
_size_draw$ = -176					; size = 8
_w_draw$ = -160						; size = 4
_max_x$ = -148						; size = 4
_window_padding$ = -136					; size = 8
_bb_inner$ = -120					; size = 16
_pos$ = -96						; size = 8
_size$ = -80						; size = 8
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_selected$ = 12						; size = 1
_flags$ = 16						; size = 4
_size_arg$ = 20						; size = 4
?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z PROC		; ImGui::Selectable, COMDAT

; 5507 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 02 00
	00		 sub	 esp, 628		; 00000274H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 8c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-628]
  00012	b9 9d 00 00 00	 mov	 ecx, 157		; 0000009dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5508 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 5509 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN5@Selectable

; 5510 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 c6 07 00 00	 jmp	 $LN1@Selectable
$LN5@Selectable:

; 5511 : 
; 5512 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 5513 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 5514 : 
; 5515 :     if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns) // FIXME-OPT: Avoid if vertically clipped.

  0005f	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00062	83 e0 02	 and	 eax, 2
  00065	74 11		 je	 SHORT $LN6@Selectable
  00067	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0006a	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  00071	74 05		 je	 SHORT $LN6@Selectable

; 5516 :         PushColumnsBackground();

  00073	e8 00 00 00 00	 call	 ?PushColumnsBackground@ImGui@@YAXXZ ; ImGui::PushColumnsBackground
$LN6@Selectable:

; 5517 : 
; 5518 :     ImGuiID id = window->GetID(label);

  00078	6a 00		 push	 0
  0007a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00081	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00086	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 5519 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

  00089	51		 push	 ecx
  0008a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00092	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00097	6a 01		 push	 1
  00099	6a 00		 push	 0
  0009b	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0009e	50		 push	 eax
  0009f	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  000a8	83 c4 14	 add	 esp, 20			; 00000014H

; 5520 :     ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);

  000ab	8b 45 14	 mov	 eax, DWORD PTR _size_arg$[ebp]
  000ae	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000b3	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000ba	9f		 lahf
  000bb	f6 c4 44	 test	 ah, 68			; 00000044H
  000be	7b 12		 jnp	 SHORT $LN34@Selectable
  000c0	8b 4d 14	 mov	 ecx, DWORD PTR _size_arg$[ebp]
  000c3	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  000c8	f3 0f 11 85 90
	fd ff ff	 movss	 DWORD PTR tv88[ebp], xmm0
  000d0	eb 0d		 jmp	 SHORT $LN35@Selectable
$LN34@Selectable:
  000d2	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000d7	f3 0f 11 85 90
	fd ff ff	 movss	 DWORD PTR tv88[ebp], xmm0
$LN35@Selectable:
  000df	8b 55 14	 mov	 edx, DWORD PTR _size_arg$[ebp]
  000e2	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  000e6	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000ed	9f		 lahf
  000ee	f6 c4 44	 test	 ah, 68			; 00000044H
  000f1	7b 11		 jnp	 SHORT $LN36@Selectable
  000f3	8b 45 14	 mov	 eax, DWORD PTR _size_arg$[ebp]
  000f6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000fa	f3 0f 11 85 8c
	fd ff ff	 movss	 DWORD PTR tv93[ebp], xmm0
  00102	eb 0d		 jmp	 SHORT $LN37@Selectable
$LN36@Selectable:
  00104	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00109	f3 0f 11 85 8c
	fd ff ff	 movss	 DWORD PTR tv93[ebp], xmm0
$LN37@Selectable:
  00111	51		 push	 ecx
  00112	f3 0f 10 85 90
	fd ff ff	 movss	 xmm0, DWORD PTR tv88[ebp]
  0011a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011f	51		 push	 ecx
  00120	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR tv93[ebp]
  00128	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012d	8d 4d b0	 lea	 ecx, DWORD PTR _size$[ebp]
  00130	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 5521 :     ImVec2 pos = window->DC.CursorPos;

  00135	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00138	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0013e	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00144	89 4d a0	 mov	 DWORD PTR _pos$[ebp], ecx
  00147	89 55 a4	 mov	 DWORD PTR _pos$[ebp+4], edx

; 5522 :     pos.y += window->DC.CurrLineTextBaseOffset;

  0014a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0014d	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00152	f3 0f 58 80 f8
	00 00 00	 addss	 xmm0, DWORD PTR [eax+248]
  0015a	f3 0f 11 45 a4	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 5523 :     ImRect bb_inner(pos, pos + size);

  0015f	8d 45 b0	 lea	 eax, DWORD PTR _size$[ebp]
  00162	50		 push	 eax
  00163	8d 4d a0	 lea	 ecx, DWORD PTR _pos$[ebp]
  00166	51		 push	 ecx
  00167	8d 95 d8 fd ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0016d	52		 push	 edx
  0016e	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH
  00176	50		 push	 eax
  00177	8d 45 a0	 lea	 eax, DWORD PTR _pos$[ebp]
  0017a	50		 push	 eax
  0017b	8d 4d 88	 lea	 ecx, DWORD PTR _bb_inner$[ebp]
  0017e	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 5524 :     ItemSize(size, 0.0f);

  00183	51		 push	 ecx
  00184	0f 57 c0	 xorps	 xmm0, xmm0
  00187	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018c	8d 45 b0	 lea	 eax, DWORD PTR _size$[ebp]
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  00195	83 c4 08	 add	 esp, 8

; 5525 : 
; 5526 :     // Fill horizontal space.
; 5527 :     ImVec2 window_padding = window->WindowPadding;

  00198	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0019b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0019e	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  001a1	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _window_padding$[ebp], ecx
  001a7	89 95 7c ff ff
	ff		 mov	 DWORD PTR _window_padding$[ebp+4], edx

; 5528 :     float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;

  001ad	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001b0	83 e0 02	 and	 eax, 2
  001b3	74 1d		 je	 SHORT $LN38@Selectable
  001b5	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetWindowContentRegionMax
  001c1	83 c4 04	 add	 esp, 4
  001c4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001c8	f3 0f 11 85 90
	fd ff ff	 movss	 DWORD PTR tv151[ebp], xmm0
  001d0	eb 1b		 jmp	 SHORT $LN39@Selectable
$LN38@Selectable:
  001d2	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001d8	52		 push	 edx
  001d9	e8 00 00 00 00	 call	 ?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
  001de	83 c4 04	 add	 esp, 4
  001e1	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001e5	f3 0f 11 85 90
	fd ff ff	 movss	 DWORD PTR tv151[ebp], xmm0
$LN39@Selectable:
  001ed	f3 0f 10 85 90
	fd ff ff	 movss	 xmm0, DWORD PTR tv151[ebp]
  001f5	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _max_x$[ebp], xmm0

; 5529 :     float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - pos.x);

  001fd	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00200	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00205	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _max_x$[ebp]
  0020d	f3 0f 5c 85 78
	ff ff ff	 subss	 xmm0, DWORD PTR _window_padding$[ebp]
  00215	f3 0f 5c 45 a0	 subss	 xmm0, DWORD PTR _pos$[ebp]
  0021a	51		 push	 ecx
  0021b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00220	51		 push	 ecx
  00221	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  00226	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022b	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00230	83 c4 08	 add	 esp, 8
  00233	d9 9d 60 ff ff
	ff		 fstp	 DWORD PTR _w_draw$[ebp]

; 5530 :     ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);

  00239	8b 45 14	 mov	 eax, DWORD PTR _size_arg$[ebp]
  0023c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00241	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00248	9f		 lahf
  00249	f6 c4 44	 test	 ah, 68			; 00000044H
  0024c	7b 12		 jnp	 SHORT $LN40@Selectable
  0024e	8b 4d 14	 mov	 ecx, DWORD PTR _size_arg$[ebp]
  00251	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00256	f3 0f 11 85 90
	fd ff ff	 movss	 DWORD PTR tv165[ebp], xmm0
  0025e	eb 0d		 jmp	 SHORT $LN41@Selectable
$LN40@Selectable:
  00260	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  00265	f3 0f 11 85 90
	fd ff ff	 movss	 DWORD PTR tv165[ebp], xmm0
$LN41@Selectable:
  0026d	8b 55 14	 mov	 edx, DWORD PTR _size_arg$[ebp]
  00270	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00274	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0027b	9f		 lahf
  0027c	f6 c4 44	 test	 ah, 68			; 00000044H
  0027f	7b 1b		 jnp	 SHORT $LN42@Selectable
  00281	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00284	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00289	75 11		 jne	 SHORT $LN42@Selectable
  0028b	8b 4d 14	 mov	 ecx, DWORD PTR _size_arg$[ebp]
  0028e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00292	f3 0f 11 85 8c
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
  0029a	eb 10		 jmp	 SHORT $LN43@Selectable
$LN42@Selectable:
  0029c	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _w_draw$[ebp]
  002a4	f3 0f 11 85 8c
	fd ff ff	 movss	 DWORD PTR tv172[ebp], xmm0
$LN43@Selectable:
  002ac	51		 push	 ecx
  002ad	f3 0f 10 85 90
	fd ff ff	 movss	 xmm0, DWORD PTR tv165[ebp]
  002b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ba	51		 push	 ecx
  002bb	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR tv172[ebp]
  002c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c8	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _size_draw$[ebp]
  002ce	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 5531 :     ImRect bb(pos, pos + size_draw);

  002d3	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _size_draw$[ebp]
  002d9	50		 push	 eax
  002da	8d 4d a0	 lea	 ecx, DWORD PTR _pos$[ebp]
  002dd	51		 push	 ecx
  002de	8d 95 a8 fd ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  002e4	52		 push	 edx
  002e5	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  002ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ed	50		 push	 eax
  002ee	8d 45 a0	 lea	 eax, DWORD PTR _pos$[ebp]
  002f1	50		 push	 eax
  002f2	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  002f8	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 5532 :     if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))

  002fd	8b 45 14	 mov	 eax, DWORD PTR _size_arg$[ebp]
  00300	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00304	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0030b	9f		 lahf
  0030c	f6 c4 44	 test	 ah, 68			; 00000044H
  0030f	7b 0a		 jnp	 SHORT $LN8@Selectable
  00311	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00314	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00319	74 18		 je	 SHORT $LN7@Selectable
$LN8@Selectable:

; 5533 :         bb.Max.x += window_padding.x;

  0031b	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp+8]
  00323	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _window_padding$[ebp]
  0032b	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _bb$[ebp+8], xmm0
$LN7@Selectable:

; 5534 : 
; 5535 :     // Selectables are tightly packed together so we extend the box to cover spacing between selectable.
; 5536 :     const float spacing_x = style.ItemSpacing.x;

  00333	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00336	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
  0033b	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _spacing_x$[ebp], xmm0

; 5537 :     const float spacing_y = style.ItemSpacing.y;

  00343	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00346	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [eax+76]
  0034b	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _spacing_y$[ebp], xmm0

; 5538 :     const float spacing_L = IM_FLOOR(spacing_x * 0.50f);

  00353	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _spacing_x$[ebp]
  0035b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00363	f3 0f 2c c0	 cvttss2si eax, xmm0
  00367	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0036b	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _spacing_L$[ebp], xmm0

; 5539 :     const float spacing_U = IM_FLOOR(spacing_y * 0.50f);

  00373	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _spacing_y$[ebp]
  0037b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00383	f3 0f 2c c0	 cvttss2si eax, xmm0
  00387	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0038b	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _spacing_U$[ebp], xmm0

; 5540 :     bb.Min.x -= spacing_L;

  00393	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp]
  0039b	f3 0f 5c 85 14
	ff ff ff	 subss	 xmm0, DWORD PTR _spacing_L$[ebp]
  003a3	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _bb$[ebp], xmm0

; 5541 :     bb.Min.y -= spacing_U;

  003ab	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _bb$[ebp+4]
  003b3	f3 0f 5c 85 08
	ff ff ff	 subss	 xmm0, DWORD PTR _spacing_U$[ebp]
  003bb	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _bb$[ebp+4], xmm0

; 5542 :     bb.Max.x += (spacing_x - spacing_L);

  003c3	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _spacing_x$[ebp]
  003cb	f3 0f 5c 85 14
	ff ff ff	 subss	 xmm0, DWORD PTR _spacing_L$[ebp]
  003d3	f3 0f 58 85 40
	ff ff ff	 addss	 xmm0, DWORD PTR _bb$[ebp+8]
  003db	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _bb$[ebp+8], xmm0

; 5543 :     bb.Max.y += (spacing_y - spacing_U);

  003e3	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _spacing_y$[ebp]
  003eb	f3 0f 5c 85 08
	ff ff ff	 subss	 xmm0, DWORD PTR _spacing_U$[ebp]
  003f3	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _bb$[ebp+12]
  003fb	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _bb$[ebp+12], xmm0

; 5544 : 
; 5545 :     bool item_add;
; 5546 :     if (flags & ImGuiSelectableFlags_Disabled)

  00403	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00406	83 e0 08	 and	 eax, 8
  00409	74 50		 je	 SHORT $LN9@Selectable

; 5547 :     {
; 5548 :         ImGuiItemFlags backup_item_flags = window->DC.ItemFlags;

  0040b	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0040e	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00414	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _backup_item_flags$7[ebp], ecx

; 5549 :         window->DC.ItemFlags |= ImGuiItemFlags_Disabled | ImGuiItemFlags_NoNavDefaultFocus;

  0041a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0041d	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  00423	83 c9 14	 or	 ecx, 20			; 00000014H
  00426	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00429	89 8a 6c 01 00
	00		 mov	 DWORD PTR [edx+364], ecx

; 5550 :         item_add = ItemAdd(bb, id);

  0042f	6a 00		 push	 0
  00431	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00434	50		 push	 eax
  00435	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  0043b	51		 push	 ecx
  0043c	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00441	83 c4 0c	 add	 esp, 12			; 0000000cH
  00444	88 85 ff fe ff
	ff		 mov	 BYTE PTR _item_add$[ebp], al

; 5551 :         window->DC.ItemFlags = backup_item_flags;

  0044a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0044d	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _backup_item_flags$7[ebp]
  00453	89 88 6c 01 00
	00		 mov	 DWORD PTR [eax+364], ecx

; 5552 :     }

  00459	eb 1b		 jmp	 SHORT $LN10@Selectable
$LN9@Selectable:

; 5553 :     else
; 5554 :     {
; 5555 :         item_add = ItemAdd(bb, id);

  0045b	6a 00		 push	 0
  0045d	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00460	50		 push	 eax
  00461	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  00467	51		 push	 ecx
  00468	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0046d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00470	88 85 ff fe ff
	ff		 mov	 BYTE PTR _item_add$[ebp], al
$LN10@Selectable:

; 5556 :     }
; 5557 :     if (!item_add)

  00476	0f b6 85 ff fe
	ff ff		 movzx	 eax, BYTE PTR _item_add$[ebp]
  0047d	85 c0		 test	 eax, eax
  0047f	75 20		 jne	 SHORT $LN11@Selectable

; 5558 :     {
; 5559 :         if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns)

  00481	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00484	83 e0 02	 and	 eax, 2
  00487	74 11		 je	 SHORT $LN12@Selectable
  00489	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0048c	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  00493	74 05		 je	 SHORT $LN12@Selectable

; 5560 :             PopColumnsBackground();

  00495	e8 00 00 00 00	 call	 ?PopColumnsBackground@ImGui@@YAXXZ ; ImGui::PopColumnsBackground
$LN12@Selectable:

; 5561 :         return false;

  0049a	32 c0		 xor	 al, al
  0049c	e9 71 03 00 00	 jmp	 $LN1@Selectable
$LN11@Selectable:

; 5562 :     }
; 5563 : 
; 5564 :     // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
; 5565 :     ImGuiButtonFlags button_flags = 0;

  004a1	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _button_flags$[ebp], 0

; 5566 :     if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;

  004ab	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  004ae	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  004b3	74 11		 je	 SHORT $LN13@Selectable
  004b5	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  004bb	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  004c0	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN13@Selectable:

; 5567 :     if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;

  004c6	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  004c9	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  004ce	74 0f		 je	 SHORT $LN14@Selectable
  004d0	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  004d6	83 c8 04	 or	 eax, 4
  004d9	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN14@Selectable:

; 5568 :     if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;

  004df	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  004e2	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  004e7	74 0f		 je	 SHORT $LN15@Selectable
  004e9	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  004ef	83 c8 08	 or	 eax, 8
  004f2	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN15@Selectable:

; 5569 :     if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;

  004f8	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  004fb	83 e0 08	 and	 eax, 8
  004fe	74 11		 je	 SHORT $LN16@Selectable
  00500	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  00506	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  0050b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN16@Selectable:

; 5570 :     if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;

  00511	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00514	83 e0 04	 and	 eax, 4
  00517	74 0f		 je	 SHORT $LN17@Selectable
  00519	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  0051f	83 c8 12	 or	 eax, 18			; 00000012H
  00522	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN17@Selectable:

; 5571 :     if (flags & ImGuiSelectableFlags_AllowItemOverlap) button_flags |= ImGuiButtonFlags_AllowItemOverlap;

  00528	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0052b	83 e0 10	 and	 eax, 16			; 00000010H
  0052e	74 0f		 je	 SHORT $LN18@Selectable
  00530	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  00536	83 c8 40	 or	 eax, 64			; 00000040H
  00539	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _button_flags$[ebp], eax
$LN18@Selectable:

; 5572 : 
; 5573 :     if (flags & ImGuiSelectableFlags_Disabled)

  0053f	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00542	83 e0 08	 and	 eax, 8
  00545	74 04		 je	 SHORT $LN19@Selectable

; 5574 :         selected = false;

  00547	c6 45 0c 00	 mov	 BYTE PTR _selected$[ebp], 0
$LN19@Selectable:

; 5575 : 
; 5576 :     const bool was_selected = selected;

  0054b	8a 45 0c	 mov	 al, BYTE PTR _selected$[ebp]
  0054e	88 85 db fe ff
	ff		 mov	 BYTE PTR _was_selected$[ebp], al

; 5577 :     bool hovered, held;
; 5578 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

  00554	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _button_flags$[ebp]
  0055a	50		 push	 eax
  0055b	8d 8d c3 fe ff
	ff		 lea	 ecx, DWORD PTR _held$[ebp]
  00561	51		 push	 ecx
  00562	8d 95 cf fe ff
	ff		 lea	 edx, DWORD PTR _hovered$[ebp]
  00568	52		 push	 edx
  00569	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0056c	50		 push	 eax
  0056d	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  00573	51		 push	 ecx
  00574	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  00579	83 c4 14	 add	 esp, 20			; 00000014H
  0057c	88 85 b7 fe ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 5579 : 
; 5580 :     // Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard
; 5581 :     if (pressed || (hovered && (flags & ImGuiSelectableFlags_SetNavIdOnHover)))

  00582	0f b6 85 b7 fe
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  00589	85 c0		 test	 eax, eax
  0058b	75 15		 jne	 SHORT $LN21@Selectable
  0058d	0f b6 85 cf fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  00594	85 c0		 test	 eax, eax
  00596	74 5a		 je	 SHORT $LN22@Selectable
  00598	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0059b	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  005a0	74 50		 je	 SHORT $LN22@Selectable
$LN21@Selectable:

; 5582 :     {
; 5583 :         if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)

  005a2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005a5	0f b6 88 33 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6963]
  005ac	85 c9		 test	 ecx, ecx
  005ae	75 42		 jne	 SHORT $LN22@Selectable
  005b0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005b3	8b 88 d0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6864]
  005b9	3b 4d f4	 cmp	 ecx, DWORD PTR _window$[ebp]
  005bc	75 34		 jne	 SHORT $LN22@Selectable
  005be	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005c1	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  005c4	8b 90 28 1b 00
	00		 mov	 edx, DWORD PTR [eax+6952]
  005ca	3b 91 30 01 00
	00		 cmp	 edx, DWORD PTR [ecx+304]
  005d0	75 20		 jne	 SHORT $LN22@Selectable

; 5584 :         {
; 5585 :             g.NavDisableHighlight = true;

  005d2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005d5	c6 80 32 1b 00
	00 01		 mov	 BYTE PTR [eax+6962], 1

; 5586 :             SetNavID(id, window->DC.NavLayerCurrent);

  005dc	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  005df	8b 88 30 01 00
	00		 mov	 ecx, DWORD PTR [eax+304]
  005e5	51		 push	 ecx
  005e6	8b 55 d0	 mov	 edx, DWORD PTR _id$[ebp]
  005e9	52		 push	 edx
  005ea	e8 00 00 00 00	 call	 ?SetNavID@ImGui@@YAXIH@Z ; ImGui::SetNavID
  005ef	83 c4 08	 add	 esp, 8
$LN22@Selectable:

; 5587 :         }
; 5588 :     }
; 5589 :     if (pressed)

  005f2	0f b6 85 b7 fe
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  005f9	85 c0		 test	 eax, eax
  005fb	74 0c		 je	 SHORT $LN23@Selectable

; 5590 :         MarkItemEdited(id);

  005fd	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00600	50		 push	 eax
  00601	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  00606	83 c4 04	 add	 esp, 4
$LN23@Selectable:

; 5591 : 
; 5592 :     if (flags & ImGuiSelectableFlags_AllowItemOverlap)

  00609	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0060c	83 e0 10	 and	 eax, 16			; 00000010H
  0060f	74 05		 je	 SHORT $LN24@Selectable

; 5593 :         SetItemAllowOverlap();

  00611	e8 00 00 00 00	 call	 ?SetItemAllowOverlap@ImGui@@YAXXZ ; ImGui::SetItemAllowOverlap
$LN24@Selectable:

; 5594 : 
; 5595 :     // In this branch, Selectable() cannot toggle the selection so this will never trigger.
; 5596 :     if (selected != was_selected) //-V547

  00616	0f b6 45 0c	 movzx	 eax, BYTE PTR _selected$[ebp]
  0061a	0f b6 8d db fe
	ff ff		 movzx	 ecx, BYTE PTR _was_selected$[ebp]
  00621	3b c1		 cmp	 eax, ecx
  00623	74 15		 je	 SHORT $LN25@Selectable

; 5597 :         window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

  00625	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00628	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  0062e	83 c9 08	 or	 ecx, 8
  00631	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00634	89 8a 0c 01 00
	00		 mov	 DWORD PTR [edx+268], ecx
$LN25@Selectable:

; 5598 : 
; 5599 :     // Render
; 5600 :     if (held && (flags & ImGuiSelectableFlags_DrawHoveredWhenHeld))

  0063a	0f b6 85 c3 fe
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  00641	85 c0		 test	 eax, eax
  00643	74 11		 je	 SHORT $LN26@Selectable
  00645	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00648	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0064d	74 07		 je	 SHORT $LN26@Selectable

; 5601 :         hovered = true;

  0064f	c6 85 cf fe ff
	ff 01		 mov	 BYTE PTR _hovered$[ebp], 1
$LN26@Selectable:

; 5602 :     if (hovered || selected)

  00656	0f b6 85 cf fe
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  0065d	85 c0		 test	 eax, eax
  0065f	75 0c		 jne	 SHORT $LN28@Selectable
  00661	0f b6 45 0c	 movzx	 eax, BYTE PTR _selected$[ebp]
  00665	85 c0		 test	 eax, eax
  00667	0f 84 bd 00 00
	00		 je	 $LN27@Selectable
$LN28@Selectable:

; 5603 :     {
; 5604 :         const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

  0066d	0f b6 85 c3 fe
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  00674	85 c0		 test	 eax, eax
  00676	74 17		 je	 SHORT $LN44@Selectable
  00678	0f b6 8d cf fe
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  0067f	85 c9		 test	 ecx, ecx
  00681	74 0c		 je	 SHORT $LN44@Selectable
  00683	c7 85 90 fd ff
	ff 1a 00 00 00	 mov	 DWORD PTR tv337[ebp], 26 ; 0000001aH
  0068d	eb 2d		 jmp	 SHORT $LN47@Selectable
$LN44@Selectable:
  0068f	0f b6 95 cf fe
	ff ff		 movzx	 edx, BYTE PTR _hovered$[ebp]
  00696	85 d2		 test	 edx, edx
  00698	74 0c		 je	 SHORT $LN45@Selectable
  0069a	c7 85 8c fd ff
	ff 19 00 00 00	 mov	 DWORD PTR tv336[ebp], 25 ; 00000019H
  006a4	eb 0a		 jmp	 SHORT $LN46@Selectable
$LN45@Selectable:
  006a6	c7 85 8c fd ff
	ff 18 00 00 00	 mov	 DWORD PTR tv336[ebp], 24 ; 00000018H
$LN46@Selectable:
  006b0	8b 85 8c fd ff
	ff		 mov	 eax, DWORD PTR tv336[ebp]
  006b6	89 85 90 fd ff
	ff		 mov	 DWORD PTR tv337[ebp], eax
$LN47@Selectable:
  006bc	51		 push	 ecx
  006bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ca	8b 8d 90 fd ff
	ff		 mov	 ecx, DWORD PTR tv337[ebp]
  006d0	51		 push	 ecx
  006d1	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  006d6	83 c4 08	 add	 esp, 8
  006d9	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _col$6[ebp], eax

; 5605 :         RenderFrame(bb.Min, bb.Max, col, false, 0.0f);

  006df	51		 push	 ecx
  006e0	0f 57 c0	 xorps	 xmm0, xmm0
  006e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006e8	6a 00		 push	 0
  006ea	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _col$6[ebp]
  006f0	50		 push	 eax
  006f1	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _bb$[ebp+12]
  006f7	51		 push	 ecx
  006f8	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _bb$[ebp+8]
  006fe	52		 push	 edx
  006ff	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _bb$[ebp+4]
  00705	50		 push	 eax
  00706	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _bb$[ebp]
  0070c	51		 push	 ecx
  0070d	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  00712	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5606 :         RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);

  00715	6a 0a		 push	 10			; 0000000aH
  00717	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0071a	50		 push	 eax
  0071b	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  00721	51		 push	 ecx
  00722	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  00727	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@Selectable:

; 5607 :     }
; 5608 : 
; 5609 :     if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns)

  0072a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0072d	83 e0 02	 and	 eax, 2
  00730	74 40		 je	 SHORT $LN29@Selectable
  00732	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00735	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  0073c	74 34		 je	 SHORT $LN29@Selectable

; 5610 :     {
; 5611 :         PopColumnsBackground();

  0073e	e8 00 00 00 00	 call	 ?PopColumnsBackground@ImGui@@YAXXZ ; ImGui::PopColumnsBackground

; 5612 :         bb.Max.x -= (GetContentRegionMax().x - max_x);

  00743	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00749	50		 push	 eax
  0074a	e8 00 00 00 00	 call	 ?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
  0074f	83 c4 04	 add	 esp, 4
  00752	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00756	f3 0f 5c 85 6c
	ff ff ff	 subss	 xmm0, DWORD PTR _max_x$[ebp]
  0075e	f3 0f 10 8d 40
	ff ff ff	 movss	 xmm1, DWORD PTR _bb$[ebp+8]
  00766	f3 0f 5c c8	 subss	 xmm1, xmm0
  0076a	f3 0f 11 8d 40
	ff ff ff	 movss	 DWORD PTR _bb$[ebp+8], xmm1
$LN29@Selectable:

; 5613 :     }
; 5614 : 
; 5615 :     if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);

  00772	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00775	83 e0 08	 and	 eax, 8
  00778	74 1d		 je	 SHORT $LN30@Selectable
  0077a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0077f	c1 e0 00	 shl	 eax, 0
  00782	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00785	8d 94 01 b0 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+176]
  0078c	52		 push	 edx
  0078d	6a 00		 push	 0
  0078f	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  00794	83 c4 08	 add	 esp, 8
$LN30@Selectable:

; 5616 :     RenderTextClipped(bb_inner.Min, bb_inner.Max, label, NULL, &label_size, style.SelectableTextAlign, &bb);

  00797	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _bb$[ebp]
  0079d	50		 push	 eax
  0079e	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  007a1	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  007a7	51		 push	 ecx
  007a8	8d 55 c0	 lea	 edx, DWORD PTR _label_size$[ebp]
  007ab	52		 push	 edx
  007ac	6a 00		 push	 0
  007ae	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  007b1	50		 push	 eax
  007b2	8d 4d 90	 lea	 ecx, DWORD PTR _bb_inner$[ebp+8]
  007b5	51		 push	 ecx
  007b6	8d 55 88	 lea	 edx, DWORD PTR _bb_inner$[ebp]
  007b9	52		 push	 edx
  007ba	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  007bf	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5617 :     if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();

  007c2	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  007c5	83 e0 08	 and	 eax, 8
  007c8	74 0a		 je	 SHORT $LN31@Selectable
  007ca	6a 01		 push	 1
  007cc	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor
  007d1	83 c4 04	 add	 esp, 4
$LN31@Selectable:

; 5618 : 
; 5619 :     // Automatically close popups
; 5620 :     if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))

  007d4	0f b6 85 b7 fe
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  007db	85 c0		 test	 eax, eax
  007dd	74 29		 je	 SHORT $LN32@Selectable
  007df	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  007e2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  007e5	81 e1 00 00 00
	04		 and	 ecx, 67108864		; 04000000H
  007eb	74 1b		 je	 SHORT $LN32@Selectable
  007ed	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  007f0	83 e0 01	 and	 eax, 1
  007f3	75 13		 jne	 SHORT $LN32@Selectable
  007f5	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  007f8	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  007fe	83 e1 20	 and	 ecx, 32			; 00000020H
  00801	75 05		 jne	 SHORT $LN32@Selectable

; 5621 :         CloseCurrentPopup();

  00803	e8 00 00 00 00	 call	 ?CloseCurrentPopup@ImGui@@YAXXZ ; ImGui::CloseCurrentPopup
$LN32@Selectable:

; 5622 : 
; 5623 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);

  00808	33 c0		 xor	 eax, eax
  0080a	75 fc		 jne	 SHORT $LN32@Selectable

; 5624 :     return pressed;

  0080c	8a 85 b7 fe ff
	ff		 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@Selectable:

; 5625 : }

  00812	52		 push	 edx
  00813	8b cd		 mov	 ecx, ebp
  00815	50		 push	 eax
  00816	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN58@Selectable
  0081c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00821	58		 pop	 eax
  00822	5a		 pop	 edx
  00823	5f		 pop	 edi
  00824	5e		 pop	 esi
  00825	5b		 pop	 ebx
  00826	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00829	33 cd		 xor	 ecx, ebp
  0082b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00830	81 c4 74 02 00
	00		 add	 esp, 628		; 00000274H
  00836	3b ec		 cmp	 ebp, esp
  00838	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0083d	8b e5		 mov	 esp, ebp
  0083f	5d		 pop	 ebp
  00840	c3		 ret	 0
  00841	0f 1f 00	 npad	 3
$LN58@Selectable:
  00844	09 00 00 00	 DD	 9
  00848	00 00 00 00	 DD	 $LN57@Selectable
$LN57@Selectable:
  0084c	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00850	08 00 00 00	 DD	 8
  00854	00 00 00 00	 DD	 $LN48@Selectable
  00858	b0 ff ff ff	 DD	 -80			; ffffffb0H
  0085c	08 00 00 00	 DD	 8
  00860	00 00 00 00	 DD	 $LN49@Selectable
  00864	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00868	08 00 00 00	 DD	 8
  0086c	00 00 00 00	 DD	 $LN50@Selectable
  00870	88 ff ff ff	 DD	 -120			; ffffff88H
  00874	10 00 00 00	 DD	 16			; 00000010H
  00878	00 00 00 00	 DD	 $LN51@Selectable
  0087c	78 ff ff ff	 DD	 -136			; ffffff78H
  00880	08 00 00 00	 DD	 8
  00884	00 00 00 00	 DD	 $LN52@Selectable
  00888	50 ff ff ff	 DD	 -176			; ffffff50H
  0088c	08 00 00 00	 DD	 8
  00890	00 00 00 00	 DD	 $LN53@Selectable
  00894	38 ff ff ff	 DD	 -200			; ffffff38H
  00898	10 00 00 00	 DD	 16			; 00000010H
  0089c	00 00 00 00	 DD	 $LN54@Selectable
  008a0	cf fe ff ff	 DD	 -305			; fffffecfH
  008a4	01 00 00 00	 DD	 1
  008a8	00 00 00 00	 DD	 $LN55@Selectable
  008ac	c3 fe ff ff	 DD	 -317			; fffffec3H
  008b0	01 00 00 00	 DD	 1
  008b4	00 00 00 00	 DD	 $LN56@Selectable
$LN56@Selectable:
  008b8	68		 DB	 104			; 00000068H
  008b9	65		 DB	 101			; 00000065H
  008ba	6c		 DB	 108			; 0000006cH
  008bb	64		 DB	 100			; 00000064H
  008bc	00		 DB	 0
$LN55@Selectable:
  008bd	68		 DB	 104			; 00000068H
  008be	6f		 DB	 111			; 0000006fH
  008bf	76		 DB	 118			; 00000076H
  008c0	65		 DB	 101			; 00000065H
  008c1	72		 DB	 114			; 00000072H
  008c2	65		 DB	 101			; 00000065H
  008c3	64		 DB	 100			; 00000064H
  008c4	00		 DB	 0
$LN54@Selectable:
  008c5	62		 DB	 98			; 00000062H
  008c6	62		 DB	 98			; 00000062H
  008c7	00		 DB	 0
$LN53@Selectable:
  008c8	73		 DB	 115			; 00000073H
  008c9	69		 DB	 105			; 00000069H
  008ca	7a		 DB	 122			; 0000007aH
  008cb	65		 DB	 101			; 00000065H
  008cc	5f		 DB	 95			; 0000005fH
  008cd	64		 DB	 100			; 00000064H
  008ce	72		 DB	 114			; 00000072H
  008cf	61		 DB	 97			; 00000061H
  008d0	77		 DB	 119			; 00000077H
  008d1	00		 DB	 0
$LN52@Selectable:
  008d2	77		 DB	 119			; 00000077H
  008d3	69		 DB	 105			; 00000069H
  008d4	6e		 DB	 110			; 0000006eH
  008d5	64		 DB	 100			; 00000064H
  008d6	6f		 DB	 111			; 0000006fH
  008d7	77		 DB	 119			; 00000077H
  008d8	5f		 DB	 95			; 0000005fH
  008d9	70		 DB	 112			; 00000070H
  008da	61		 DB	 97			; 00000061H
  008db	64		 DB	 100			; 00000064H
  008dc	64		 DB	 100			; 00000064H
  008dd	69		 DB	 105			; 00000069H
  008de	6e		 DB	 110			; 0000006eH
  008df	67		 DB	 103			; 00000067H
  008e0	00		 DB	 0
$LN51@Selectable:
  008e1	62		 DB	 98			; 00000062H
  008e2	62		 DB	 98			; 00000062H
  008e3	5f		 DB	 95			; 0000005fH
  008e4	69		 DB	 105			; 00000069H
  008e5	6e		 DB	 110			; 0000006eH
  008e6	6e		 DB	 110			; 0000006eH
  008e7	65		 DB	 101			; 00000065H
  008e8	72		 DB	 114			; 00000072H
  008e9	00		 DB	 0
$LN50@Selectable:
  008ea	70		 DB	 112			; 00000070H
  008eb	6f		 DB	 111			; 0000006fH
  008ec	73		 DB	 115			; 00000073H
  008ed	00		 DB	 0
$LN49@Selectable:
  008ee	73		 DB	 115			; 00000073H
  008ef	69		 DB	 105			; 00000069H
  008f0	7a		 DB	 122			; 0000007aH
  008f1	65		 DB	 101			; 00000065H
  008f2	00		 DB	 0
$LN48@Selectable:
  008f3	6c		 DB	 108			; 0000006cH
  008f4	61		 DB	 97			; 00000061H
  008f5	62		 DB	 98			; 00000062H
  008f6	65		 DB	 101			; 00000065H
  008f7	6c		 DB	 108			; 0000006cH
  008f8	5f		 DB	 95			; 0000005fH
  008f9	73		 DB	 115			; 00000073H
  008fa	69		 DB	 105			; 00000069H
  008fb	7a		 DB	 122			; 0000007aH
  008fc	65		 DB	 101			; 00000065H
  008fd	00		 DB	 0
?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ENDP		; ImGui::Selectable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SetNextItemOpen@ImGui@@YAX_NH@Z
_TEXT	SEGMENT
tv78 = -208						; size = 4
_g$ = -8						; size = 4
_is_open$ = 8						; size = 1
_cond$ = 12						; size = 4
?SetNextItemOpen@ImGui@@YAX_NH@Z PROC			; ImGui::SetNextItemOpen, COMDAT

; 5448 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5449 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 5450 :     if (g.CurrentWindow->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	0f b6 51 7f	 movzx	 edx, BYTE PTR [ecx+127]
  0003d	85 d2		 test	 edx, edx
  0003f	74 02		 je	 SHORT $LN2@SetNextIte

; 5451 :         return;

  00041	eb 4b		 jmp	 SHORT $LN1@SetNextIte
$LN2@SetNextIte:

; 5452 :     g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasOpen;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00046	8b 88 84 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6788]
  0004c	83 c9 02	 or	 ecx, 2
  0004f	8b 55 f8	 mov	 edx, DWORD PTR _g$[ebp]
  00052	89 8a 84 1a 00
	00		 mov	 DWORD PTR [edx+6788], ecx

; 5453 :     g.NextItemData.OpenVal = is_open;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0005b	8a 4d 08	 mov	 cl, BYTE PTR _is_open$[ebp]
  0005e	88 88 8c 1a 00
	00		 mov	 BYTE PTR [eax+6796], cl

; 5454 :     g.NextItemData.OpenCond = cond ? cond : ImGuiCond_Always;

  00064	83 7d 0c 00	 cmp	 DWORD PTR _cond$[ebp], 0
  00068	74 0b		 je	 SHORT $LN4@SetNextIte
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _cond$[ebp]
  0006d	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00073	eb 0a		 jmp	 SHORT $LN5@SetNextIte
$LN4@SetNextIte:
  00075	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
$LN5@SetNextIte:
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00082	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  00088	89 91 90 1a 00
	00		 mov	 DWORD PTR [ecx+6800], edx
$LN1@SetNextIte:

; 5455 : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?SetNextItemOpen@ImGui@@YAX_NH@Z ENDP			; ImGui::SetNextItemOpen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z
_TEXT	SEGMENT
tv76 = -348						; size = 4
$T1 = -340						; size = 8
_button_y$2 = -132					; size = 4
_button_x$3 = -120					; size = 4
_button_size$4 = -108					; size = 4
_last_item_backup$5 = -96				; size = 40
_g$6 = -48						; size = 4
_is_open$ = -33						; size = 1
_id$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_p_open$ = 12						; size = 4
_flags$ = 16						; size = 4
?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z PROC		; ImGui::CollapsingHeader, COMDAT

; 5469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-348]
  00012	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5470 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 5471 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@Collapsing

; 5472 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 47 01 00 00	 jmp	 $LN1@Collapsing
$LN2@Collapsing:

; 5473 : 
; 5474 :     if (p_open && !*p_open)

  0004c	83 7d 0c 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  00050	74 11		 je	 SHORT $LN3@Collapsing
  00052	8b 45 0c	 mov	 eax, DWORD PTR _p_open$[ebp]
  00055	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00058	85 c9		 test	 ecx, ecx
  0005a	75 07		 jne	 SHORT $LN3@Collapsing

; 5475 :         return false;

  0005c	32 c0		 xor	 al, al
  0005e	e9 30 01 00 00	 jmp	 $LN1@Collapsing
$LN3@Collapsing:

; 5476 : 
; 5477 :     ImGuiID id = window->GetID(label);

  00063	6a 00		 push	 0
  00065	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00068	50		 push	 eax
  00069	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0006c	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00071	89 45 e8	 mov	 DWORD PTR _id$[ebp], eax

; 5478 :     flags |= ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_ClipLabelForTrailingButton : 0);

  00074	83 7d 0c 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  00078	74 0c		 je	 SHORT $LN7@Collapsing
  0007a	c7 85 a4 fe ff
	ff 04 00 10 00	 mov	 DWORD PTR tv76[ebp], 1048580 ; 00100004H
  00084	eb 0a		 jmp	 SHORT $LN8@Collapsing
$LN7@Collapsing:
  00086	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN8@Collapsing:
  00090	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv76[ebp]
  00096	83 c8 1a	 or	 eax, 26			; 0000001aH
  00099	0b 45 10	 or	 eax, DWORD PTR _flags$[ebp]
  0009c	89 45 10	 mov	 DWORD PTR _flags$[ebp], eax

; 5479 :     bool is_open = TreeNodeBehavior(id, flags, label);

  0009f	6a 00		 push	 0
  000a1	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 55 e8	 mov	 edx, DWORD PTR _id$[ebp]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 ?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ; ImGui::TreeNodeBehavior
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	88 45 df	 mov	 BYTE PTR _is_open$[ebp], al

; 5480 :     if (p_open)

  000b8	83 7d 0c 00	 cmp	 DWORD PTR _p_open$[ebp], 0
  000bc	0f 84 ce 00 00
	00		 je	 $LN4@Collapsing

; 5481 :     {
; 5482 :         // Create a small overlapping close button
; 5483 :         // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
; 5484 :         // FIXME: CloseButton can overlap into text, need find a way to clip the text somehow.
; 5485 :         ImGuiContext& g = *GImGui;

  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  000c7	89 45 d0	 mov	 DWORD PTR _g$6[ebp], eax

; 5486 :         ImGuiItemHoveredDataBackup last_item_backup;

  000ca	8d 4d a0	 lea	 ecx, DWORD PTR _last_item_backup$5[ebp]
  000cd	e8 00 00 00 00	 call	 ??0ImGuiItemHoveredDataBackup@@QAE@XZ ; ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup

; 5487 :         float button_size = g.FontSize;

  000d2	8b 45 d0	 mov	 eax, DWORD PTR _g$6[ebp]
  000d5	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  000dd	f3 0f 11 45 94	 movss	 DWORD PTR _button_size$4[ebp], xmm0

; 5488 :         float button_x = ImMax(window->DC.LastItemRect.Min.x, window->DC.LastItemRect.Max.x - g.Style.FramePadding.x * 2.0f - button_size);

  000e2	8b 45 d0	 mov	 eax, DWORD PTR _g$6[ebp]
  000e5	f3 0f 10 80 48
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5448]
  000ed	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000f5	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000f8	f3 0f 10 89 18
	01 00 00	 movss	 xmm1, DWORD PTR [ecx+280]
  00100	f3 0f 5c c8	 subss	 xmm1, xmm0
  00104	f3 0f 5c 4d 94	 subss	 xmm1, DWORD PTR _button_size$4[ebp]
  00109	51		 push	 ecx
  0010a	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0010f	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00112	51		 push	 ecx
  00113	f3 0f 10 82 10
	01 00 00	 movss	 xmm0, DWORD PTR [edx+272]
  0011b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00120	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00125	83 c4 08	 add	 esp, 8
  00128	d9 5d 88	 fstp	 DWORD PTR _button_x$3[ebp]

; 5489 :         float button_y = window->DC.LastItemRect.Min.y;

  0012b	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0012e	f3 0f 10 80 14
	01 00 00	 movss	 xmm0, DWORD PTR [eax+276]
  00136	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _button_y$2[ebp], xmm0

; 5490 :         if (CloseButton(window->GetID((void*)((intptr_t)id + 1)), ImVec2(button_x, button_y)))

  0013e	51		 push	 ecx
  0013f	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _button_y$2[ebp]
  00147	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014c	51		 push	 ecx
  0014d	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _button_x$3[ebp]
  00152	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00157	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0015d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00162	50		 push	 eax
  00163	8b 45 e8	 mov	 eax, DWORD PTR _id$[ebp]
  00166	83 c0 01	 add	 eax, 1
  00169	50		 push	 eax
  0016a	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0016d	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBX@Z ; ImGuiWindow::GetID
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?CloseButton@ImGui@@YA_NIABUImVec2@@@Z ; ImGui::CloseButton
  00178	83 c4 08	 add	 esp, 8
  0017b	0f b6 c8	 movzx	 ecx, al
  0017e	85 c9		 test	 ecx, ecx
  00180	74 06		 je	 SHORT $LN5@Collapsing

; 5491 :             *p_open = false;

  00182	8b 45 0c	 mov	 eax, DWORD PTR _p_open$[ebp]
  00185	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN5@Collapsing:

; 5492 :         last_item_backup.Restore();

  00188	8d 4d a0	 lea	 ecx, DWORD PTR _last_item_backup$5[ebp]
  0018b	e8 00 00 00 00	 call	 ?Restore@ImGuiItemHoveredDataBackup@@QBEXXZ ; ImGuiItemHoveredDataBackup::Restore
$LN4@Collapsing:

; 5493 :     }
; 5494 : 
; 5495 :     return is_open;

  00190	8a 45 df	 mov	 al, BYTE PTR _is_open$[ebp]
$LN1@Collapsing:

; 5496 : }

  00193	52		 push	 edx
  00194	8b cd		 mov	 ecx, ebp
  00196	50		 push	 eax
  00197	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Collapsing
  0019d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001a2	58		 pop	 eax
  001a3	5a		 pop	 edx
  001a4	5f		 pop	 edi
  001a5	5e		 pop	 esi
  001a6	5b		 pop	 ebx
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001aa	33 cd		 xor	 ecx, ebp
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	81 c4 5c 01 00
	00		 add	 esp, 348		; 0000015cH
  001b7	3b ec		 cmp	 ebp, esp
  001b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c3		 ret	 0
  001c2	66 90		 npad	 2
$LN11@Collapsing:
  001c4	01 00 00 00	 DD	 1
  001c8	00 00 00 00	 DD	 $LN10@Collapsing
$LN10@Collapsing:
  001cc	a0 ff ff ff	 DD	 -96			; ffffffa0H
  001d0	28 00 00 00	 DD	 40			; 00000028H
  001d4	00 00 00 00	 DD	 $LN9@Collapsing
$LN9@Collapsing:
  001d8	6c		 DB	 108			; 0000006cH
  001d9	61		 DB	 97			; 00000061H
  001da	73		 DB	 115			; 00000073H
  001db	74		 DB	 116			; 00000074H
  001dc	5f		 DB	 95			; 0000005fH
  001dd	69		 DB	 105			; 00000069H
  001de	74		 DB	 116			; 00000074H
  001df	65		 DB	 101			; 00000065H
  001e0	6d		 DB	 109			; 0000006dH
  001e1	5f		 DB	 95			; 0000005fH
  001e2	62		 DB	 98			; 00000062H
  001e3	61		 DB	 97			; 00000061H
  001e4	63		 DB	 99			; 00000063H
  001e5	6b		 DB	 107			; 0000006bH
  001e6	75		 DB	 117			; 00000075H
  001e7	70		 DB	 112			; 00000070H
  001e8	00		 DB	 0
?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z ENDP		; ImGui::CollapsingHeader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?CollapsingHeader@ImGui@@YA_NPBDH@Z
_TEXT	SEGMENT
_window$ = -8						; size = 4
_label$ = 8						; size = 4
_flags$ = 12						; size = 4
?CollapsingHeader@ImGui@@YA_NPBDH@Z PROC		; ImGui::CollapsingHeader, COMDAT

; 5460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5461 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5462 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 04		 je	 SHORT $LN2@Collapsing

; 5463 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	eb 24		 jmp	 SHORT $LN1@Collapsing
$LN2@Collapsing:

; 5464 : 
; 5465 :     return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);

  0003f	6a 00		 push	 0
  00041	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00048	83 c9 1a	 or	 ecx, 26			; 0000001aH
  0004b	51		 push	 ecx
  0004c	6a 00		 push	 0
  0004e	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00051	52		 push	 edx
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  00055	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ; ImGui::TreeNodeBehavior
  00060	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Collapsing:

; 5466 : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?CollapsingHeader@ImGui@@YA_NPBDH@Z ENDP		; ImGui::CollapsingHeader
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ
_TEXT	SEGMENT
tv77 = -208						; size = 4
_g$ = -8						; size = 4
?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ PROC		; ImGui::GetTreeNodeToLabelSpacing, COMDAT

; 5441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5442 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 5443 :     return g.FontSize + (g.Style.FramePadding.x * 2.0f);

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	f3 0f 10 80 48
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5448]
  0003b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _g$[ebp]
  00046	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  0004e	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv77[ebp], xmm0
  00056	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv77[ebp]

; 5444 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ ENDP		; ImGui::GetTreeNodeToLabelSpacing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreePop@ImGui@@YAXXZ
_TEXT	SEGMENT
_tree_depth_mask$ = -32					; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
?TreePop@ImGui@@YAXXZ PROC				; ImGui::TreePop, COMDAT

; 5418 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5419 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 5420 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 5421 :     Unindent();

  0003c	51		 push	 ecx
  0003d	0f 57 c0	 xorps	 xmm0, xmm0
  00040	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00045	e8 00 00 00 00	 call	 ?Unindent@ImGui@@YAXM@Z	; ImGui::Unindent
  0004a	83 c4 04	 add	 esp, 4

; 5422 : 
; 5423 :     window->DC.TreeDepth--;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00050	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  00056	83 e9 01	 sub	 ecx, 1
  00059	8b 55 ec	 mov	 edx, DWORD PTR _window$[ebp]
  0005c	89 8a 00 01 00
	00		 mov	 DWORD PTR [edx+256], ecx

; 5424 :     ImU32 tree_depth_mask = (1 << window->DC.TreeDepth);

  00062	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  00065	ba 01 00 00 00	 mov	 edx, 1
  0006a	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  00070	d3 e2		 shl	 edx, cl
  00072	89 55 e0	 mov	 DWORD PTR _tree_depth_mask$[ebp], edx

; 5425 : 
; 5426 :     // Handle Left arrow to move to parent tree node (when ImGuiTreeNodeFlags_NavLeftJumpsBackHere is enabled)
; 5427 :     if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())

  00075	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00078	83 b8 58 1b 00
	00 00		 cmp	 DWORD PTR [eax+7000], 0
  0007f	75 5e		 jne	 SHORT $LN3@TreePop
  00081	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00084	8b 88 d0 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6864]
  0008a	3b 4d ec	 cmp	 ecx, DWORD PTR _window$[ebp]
  0008d	75 50		 jne	 SHORT $LN3@TreePop
  0008f	e8 00 00 00 00	 call	 ?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ ; ImGui::NavMoveRequestButNoResultYet
  00094	0f b6 c0	 movzx	 eax, al
  00097	85 c0		 test	 eax, eax
  00099	74 44		 je	 SHORT $LN3@TreePop

; 5428 :         if (g.NavIdIsAlive && (window->DC.TreeMayJumpToParentOnPopMask & tree_depth_mask))

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0009e	0f b6 88 30 1b
	00 00		 movzx	 ecx, BYTE PTR [eax+6960]
  000a5	85 c9		 test	 ecx, ecx
  000a7	74 36		 je	 SHORT $LN3@TreePop
  000a9	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  000ac	8b 88 04 01 00
	00		 mov	 ecx, DWORD PTR [eax+260]
  000b2	23 4d e0	 and	 ecx, DWORD PTR _tree_depth_mask$[ebp]
  000b5	74 28		 je	 SHORT $LN3@TreePop

; 5429 :         {
; 5430 :             SetNavID(window->IDStack.back(), g.NavLayer);

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  000ba	8b 88 28 1b 00
	00		 mov	 ecx, DWORD PTR [eax+6952]
  000c0	51		 push	 ecx
  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  000c4	81 c1 bc 00 00
	00		 add	 ecx, 188		; 000000bcH
  000ca	e8 00 00 00 00	 call	 ?back@?$ImVector@I@@QAEAAIXZ ; ImVector<unsigned int>::back
  000cf	8b 10		 mov	 edx, DWORD PTR [eax]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 ?SetNavID@ImGui@@YAXIH@Z ; ImGui::SetNavID
  000d7	83 c4 08	 add	 esp, 8

; 5431 :             NavMoveRequestCancel();

  000da	e8 00 00 00 00	 call	 ?NavMoveRequestCancel@ImGui@@YAXXZ ; ImGui::NavMoveRequestCancel
$LN3@TreePop:

; 5432 :         }
; 5433 :     window->DC.TreeMayJumpToParentOnPopMask &= tree_depth_mask - 1;

  000df	8b 45 e0	 mov	 eax, DWORD PTR _tree_depth_mask$[ebp]
  000e2	83 e8 01	 sub	 eax, 1
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR _window$[ebp]
  000e8	23 81 04 01 00
	00		 and	 eax, DWORD PTR [ecx+260]
  000ee	8b 55 ec	 mov	 edx, DWORD PTR _window$[ebp]
  000f1	89 82 04 01 00
	00		 mov	 DWORD PTR [edx+260], eax

; 5434 : 
; 5435 :     IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.

  000f7	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  000fa	83 b8 bc 00 00
	00 01		 cmp	 DWORD PTR [eax+188], 1
  00101	7f 26		 jg	 SHORT $LN5@TreePop
  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??TreePop@ImGui@@YAXXZ@4JA
  00109	83 c1 11	 add	 ecx, 17			; 00000011H
  0010c	8b f4		 mov	 esi, esp
  0010e	51		 push	 ecx
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@KOOPJPAL@?$AAw?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?9?$AA?$DO?$AAI?$AAD?$AAS?$AAt?$AAa?$AAc?$AAk@
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00122	3b f4		 cmp	 esi, esp
  00124	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@TreePop:

; 5436 :     PopID();

  00129	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 5437 : }

  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00137	3b ec		 cmp	 ebp, esp
  00139	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
?TreePop@ImGui@@YAXXZ ENDP				; ImGui::TreePop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreePush@ImGui@@YAXPBX@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_window$ = -8						; size = 4
_ptr_id$ = 8						; size = 4
?TreePush@ImGui@@YAXPBX@Z PROC				; ImGui::TreePush, COMDAT

; 5402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5403 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5404 :     Indent();

  00030	51		 push	 ecx
  00031	0f 57 c0	 xorps	 xmm0, xmm0
  00034	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00039	e8 00 00 00 00	 call	 ?Indent@ImGui@@YAXM@Z	; ImGui::Indent
  0003e	83 c4 04	 add	 esp, 4

; 5405 :     window->DC.TreeDepth++;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00044	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  0004a	83 c1 01	 add	 ecx, 1
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  00050	89 8a 00 01 00
	00		 mov	 DWORD PTR [edx+256], ecx

; 5406 :     PushID(ptr_id ? ptr_id : (const void*)"#TreePush");

  00056	83 7d 08 00	 cmp	 DWORD PTR _ptr_id$[ebp], 0
  0005a	74 0b		 je	 SHORT $LN3@TreePush
  0005c	8b 45 08	 mov	 eax, DWORD PTR _ptr_id$[ebp]
  0005f	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00065	eb 0a		 jmp	 SHORT $LN4@TreePush
$LN3@TreePush:
  00067	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], OFFSET ??_C@_09GHACPMKF@?$CDTreePush@
$LN4@TreePush:
  00071	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBX@Z	; ImGui::PushID
  0007d	83 c4 04	 add	 esp, 4

; 5407 : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?TreePush@ImGui@@YAXPBX@Z ENDP				; ImGui::TreePush
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreePush@ImGui@@YAXPBD@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_window$ = -8						; size = 4
_str_id$ = 8						; size = 4
?TreePush@ImGui@@YAXPBD@Z PROC				; ImGui::TreePush, COMDAT

; 5394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5395 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5396 :     Indent();

  00030	51		 push	 ecx
  00031	0f 57 c0	 xorps	 xmm0, xmm0
  00034	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00039	e8 00 00 00 00	 call	 ?Indent@ImGui@@YAXM@Z	; ImGui::Indent
  0003e	83 c4 04	 add	 esp, 4

; 5397 :     window->DC.TreeDepth++;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00044	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  0004a	83 c1 01	 add	 ecx, 1
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  00050	89 8a 00 01 00
	00		 mov	 DWORD PTR [edx+256], ecx

; 5398 :     PushID(str_id ? str_id : "#TreePush");

  00056	83 7d 08 00	 cmp	 DWORD PTR _str_id$[ebp], 0
  0005a	74 0b		 je	 SHORT $LN3@TreePush
  0005c	8b 45 08	 mov	 eax, DWORD PTR _str_id$[ebp]
  0005f	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00065	eb 0a		 jmp	 SHORT $LN4@TreePush
$LN3@TreePush:
  00067	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], OFFSET ??_C@_09GHACPMKF@?$CDTreePush@
$LN4@TreePush:
  00071	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  0007d	83 c4 04	 add	 esp, 4

; 5399 : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?TreePush@ImGui@@YAXPBD@Z ENDP				; ImGui::TreePush
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z
_TEXT	SEGMENT
_label_end$ = -32					; size = 4
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_ptr_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
_args$ = 20						; size = 4
?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z PROC		; ImGui::TreeNodeExV, COMDAT

; 5154 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5155 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5156 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 04		 je	 SHORT $LN2@TreeNodeEx

; 5157 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	eb 5b		 jmp	 SHORT $LN1@TreeNodeEx
$LN2@TreeNodeEx:

; 5158 : 
; 5159 :     ImGuiContext& g = *GImGui;

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00044	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 5160 :     const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

  00047	8b 45 14	 mov	 eax, DWORD PTR _args$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0004e	51		 push	 ecx
  0004f	68 01 0c 00 00	 push	 3073			; 00000c01H
  00054	8b 55 ec	 mov	 edx, DWORD PTR _g$[ebp]
  00057	81 c2 80 2f 00
	00		 add	 edx, 12160		; 00002f80H
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?ImFormatStringV@@YAHPADIPBD0@Z ; ImFormatStringV
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  00069	8d 94 01 80 2f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+12160]
  00070	89 55 e0	 mov	 DWORD PTR _label_end$[ebp], edx

; 5161 :     return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);

  00073	8b 45 e0	 mov	 eax, DWORD PTR _label_end$[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  0007a	81 c1 80 2f 00
	00		 add	 ecx, 12160		; 00002f80H
  00080	51		 push	 ecx
  00081	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00084	52		 push	 edx
  00085	8b 45 08	 mov	 eax, DWORD PTR _ptr_id$[ebp]
  00088	50		 push	 eax
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0008c	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBX@Z ; ImGuiWindow::GetID
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ; ImGui::TreeNodeBehavior
  00097	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@TreeNodeEx:

; 5162 : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z ENDP		; ImGui::TreeNodeExV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z
_TEXT	SEGMENT
_label_end$ = -32					; size = 4
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_str_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
_args$ = 20						; size = 4
?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z PROC			; ImGui::TreeNodeExV, COMDAT

; 5143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5144 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5145 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 04		 je	 SHORT $LN2@TreeNodeEx

; 5146 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	eb 5d		 jmp	 SHORT $LN1@TreeNodeEx
$LN2@TreeNodeEx:

; 5147 : 
; 5148 :     ImGuiContext& g = *GImGui;

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00044	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 5149 :     const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

  00047	8b 45 14	 mov	 eax, DWORD PTR _args$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0004e	51		 push	 ecx
  0004f	68 01 0c 00 00	 push	 3073			; 00000c01H
  00054	8b 55 ec	 mov	 edx, DWORD PTR _g$[ebp]
  00057	81 c2 80 2f 00
	00		 add	 edx, 12160		; 00002f80H
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?ImFormatStringV@@YAHPADIPBD0@Z ; ImFormatStringV
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  00069	8d 94 01 80 2f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+12160]
  00070	89 55 e0	 mov	 DWORD PTR _label_end$[ebp], edx

; 5150 :     return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);

  00073	8b 45 e0	 mov	 eax, DWORD PTR _label_end$[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  0007a	81 c1 80 2f 00
	00		 add	 ecx, 12160		; 00002f80H
  00080	51		 push	 ecx
  00081	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00084	52		 push	 edx
  00085	6a 00		 push	 0
  00087	8b 45 08	 mov	 eax, DWORD PTR _str_id$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  0008e	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ; ImGui::TreeNodeBehavior
  00099	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@TreeNodeEx:

; 5151 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z ENDP			; ImGui::TreeNodeExV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ
_TEXT	SEGMENT
_is_open$ = -17						; size = 1
_args$ = -8						; size = 4
_ptr_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ PROC			; ImGui::TreeNodeEx, COMDAT

; 5134 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5135 :     va_list args;
; 5136 :     va_start(args, fmt);

  00028	8d 45 14	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 5137 :     bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 08	 mov	 eax, DWORD PTR _ptr_id$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z ; ImGui::TreeNodeExV
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	88 45 ef	 mov	 BYTE PTR _is_open$[ebp], al

; 5138 :     va_end(args);

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 5139 :     return is_open;

  00050	8a 45 ef	 mov	 al, BYTE PTR _is_open$[ebp]

; 5140 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeEx@ImGui@@YA_NPBDH0ZZ
_TEXT	SEGMENT
_is_open$ = -17						; size = 1
_args$ = -8						; size = 4
_str_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
?TreeNodeEx@ImGui@@YA_NPBDH0ZZ PROC			; ImGui::TreeNodeEx, COMDAT

; 5125 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5126 :     va_list args;
; 5127 :     va_start(args, fmt);

  00028	8d 45 14	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 5128 :     bool is_open = TreeNodeExV(str_id, flags, fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 10	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 08	 mov	 eax, DWORD PTR _str_id$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z ; ImGui::TreeNodeExV
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	88 45 ef	 mov	 BYTE PTR _is_open$[ebp], al

; 5129 :     va_end(args);

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 5130 :     return is_open;

  00050	8a 45 ef	 mov	 al, BYTE PTR _is_open$[ebp]

; 5131 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?TreeNodeEx@ImGui@@YA_NPBDH0ZZ ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeEx@ImGui@@YA_NPBDH@Z
_TEXT	SEGMENT
_window$ = -8						; size = 4
_label$ = 8						; size = 4
_flags$ = 12						; size = 4
?TreeNodeEx@ImGui@@YA_NPBDH@Z PROC			; ImGui::TreeNodeEx, COMDAT

; 5116 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5117 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5118 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 04		 je	 SHORT $LN2@TreeNodeEx

; 5119 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	eb 21		 jmp	 SHORT $LN1@TreeNodeEx
$LN2@TreeNodeEx:

; 5120 : 
; 5121 :     return TreeNodeBehavior(window->GetID(label), flags, label, NULL);

  0003f	6a 00		 push	 0
  00041	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00048	51		 push	 ecx
  00049	6a 00		 push	 0
  0004b	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  0004e	52		 push	 edx
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  00052	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ; ImGui::TreeNodeBehavior
  0005d	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@TreeNodeEx:

; 5122 : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?TreeNodeEx@ImGui@@YA_NPBDH@Z ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeV@ImGui@@YA_NPBXPBDPAD@Z
_TEXT	SEGMENT
_ptr_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?TreeNodeV@ImGui@@YA_NPBXPBDPAD@Z PROC			; ImGui::TreeNodeV, COMDAT

; 5111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5112 :     return TreeNodeExV(ptr_id, 0, fmt, args);

  00028	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	8b 55 08	 mov	 edx, DWORD PTR _ptr_id$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z ; ImGui::TreeNodeExV
  0003b	83 c4 10	 add	 esp, 16			; 00000010H

; 5113 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?TreeNodeV@ImGui@@YA_NPBXPBDPAD@Z ENDP			; ImGui::TreeNodeV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeV@ImGui@@YA_NPBD0PAD@Z
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?TreeNodeV@ImGui@@YA_NPBD0PAD@Z PROC			; ImGui::TreeNodeV, COMDAT

; 5106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5107 :     return TreeNodeExV(str_id, 0, fmt, args);

  00028	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	8b 55 08	 mov	 edx, DWORD PTR _str_id$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z ; ImGui::TreeNodeExV
  0003b	83 c4 10	 add	 esp, 16			; 00000010H

; 5108 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?TreeNodeV@ImGui@@YA_NPBD0PAD@Z ENDP			; ImGui::TreeNodeV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNode@ImGui@@YA_NPBXPBDZZ
_TEXT	SEGMENT
_is_open$ = -17						; size = 1
_args$ = -8						; size = 4
_ptr_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
?TreeNode@ImGui@@YA_NPBXPBDZZ PROC			; ImGui::TreeNode, COMDAT

; 5089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5090 :     va_list args;
; 5091 :     va_start(args, fmt);

  00028	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 5092 :     bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	6a 00		 push	 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _ptr_id$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z ; ImGui::TreeNodeExV
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	88 45 ef	 mov	 BYTE PTR _is_open$[ebp], al

; 5093 :     va_end(args);

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 5094 :     return is_open;

  0004e	8a 45 ef	 mov	 al, BYTE PTR _is_open$[ebp]

; 5095 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?TreeNode@ImGui@@YA_NPBXPBDZZ ENDP			; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNode@ImGui@@YA_NPBD0ZZ
_TEXT	SEGMENT
_is_open$ = -17						; size = 1
_args$ = -8						; size = 4
_str_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
?TreeNode@ImGui@@YA_NPBD0ZZ PROC			; ImGui::TreeNode, COMDAT

; 5080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5081 :     va_list args;
; 5082 :     va_start(args, fmt);

  00028	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 5083 :     bool is_open = TreeNodeExV(str_id, 0, fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	6a 00		 push	 0
  00038	8b 55 08	 mov	 edx, DWORD PTR _str_id$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z ; ImGui::TreeNodeExV
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	88 45 ef	 mov	 BYTE PTR _is_open$[ebp], al

; 5084 :     va_end(args);

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 5085 :     return is_open;

  0004e	8a 45 ef	 mov	 al, BYTE PTR _is_open$[ebp]

; 5086 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?TreeNode@ImGui@@YA_NPBD0ZZ ENDP			; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNode@ImGui@@YA_NPBD@Z
_TEXT	SEGMENT
_window$ = -8						; size = 4
_label$ = 8						; size = 4
?TreeNode@ImGui@@YA_NPBD@Z PROC				; ImGui::TreeNode, COMDAT

; 5098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5099 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 5100 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 04		 je	 SHORT $LN2@TreeNode

; 5101 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	eb 1f		 jmp	 SHORT $LN1@TreeNode
$LN2@TreeNode:

; 5102 :     return TreeNodeBehavior(window->GetID(label), 0, label, NULL);

  0003f	6a 00		 push	 0
  00041	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00044	50		 push	 eax
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  00050	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ; ImGui::TreeNodeBehavior
  0005b	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@TreeNode:

; 5103 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?TreeNode@ImGui@@YA_NPBD@Z ENDP				; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SetColorEditOptions@ImGui@@YAXH@Z
_TEXT	SEGMENT
_g$ = -8						; size = 4
_flags$ = 8						; size = 4
?SetColorEditOptions@ImGui@@YAXH@Z PROC			; ImGui::SetColorEditOptions, COMDAT

; 4926 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4927 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 4928 :     if ((flags & ImGuiColorEditFlags__DisplayMask) == 0)

  00030	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00033	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  00038	75 0b		 jne	 SHORT $LN2@SetColorEd

; 4929 :         flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DisplayMask;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  0003d	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  00042	89 45 08	 mov	 DWORD PTR _flags$[ebp], eax
$LN2@SetColorEd:

; 4930 :     if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)

  00045	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00048	25 00 00 80 01	 and	 eax, 25165824		; 01800000H
  0004d	75 0b		 jne	 SHORT $LN3@SetColorEd

; 4931 :         flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;

  0004f	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00052	0d 00 00 80 00	 or	 eax, 8388608		; 00800000H
  00057	89 45 08	 mov	 DWORD PTR _flags$[ebp], eax
$LN3@SetColorEd:

; 4932 :     if ((flags & ImGuiColorEditFlags__PickerMask) == 0)

  0005a	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  0005d	25 00 00 00 06	 and	 eax, 100663296		; 06000000H
  00062	75 0b		 jne	 SHORT $LN4@SetColorEd

; 4933 :         flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;

  00064	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00067	0d 00 00 00 02	 or	 eax, 33554432		; 02000000H
  0006c	89 45 08	 mov	 DWORD PTR _flags$[ebp], eax
$LN4@SetColorEd:

; 4934 :     if ((flags & ImGuiColorEditFlags__InputMask) == 0)

  0006f	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00072	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  00077	75 0b		 jne	 SHORT $LN5@SetColorEd

; 4935 :         flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputMask;

  00079	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  0007c	0d 00 00 00 08	 or	 eax, 134217728		; 08000000H
  00081	89 45 08	 mov	 DWORD PTR _flags$[ebp], eax
$LN5@SetColorEd:

; 4936 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DisplayMask));    // Check only 1 option is selected

  00084	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00087	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  00092	83 c4 04	 add	 esp, 4
  00095	0f b6 c8	 movzx	 ecx, al
  00098	85 c9		 test	 ecx, ecx
  0009a	75 26		 jne	 SHORT $LN7@SetColorEd
  0009c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SetColorEditOptions@ImGui@@YAXH@Z@4JA
  000a2	83 c2 0a	 add	 edx, 10			; 0000000aH
  000a5	8b f4		 mov	 esi, esp
  000a7	52		 push	 edx
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_1HC@IFIJNDDD@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	3b f4		 cmp	 esi, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@SetColorEd:

; 4937 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DataTypeMask));   // Check only 1 option is selected

  000c2	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  000c5	25 00 00 80 01	 and	 eax, 25165824		; 01800000H
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  000d0	83 c4 04	 add	 esp, 4
  000d3	0f b6 c8	 movzx	 ecx, al
  000d6	85 c9		 test	 ecx, ecx
  000d8	75 26		 jne	 SHORT $LN8@SetColorEd
  000da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SetColorEditOptions@ImGui@@YAXH@Z@4JA
  000e0	83 c2 0b	 add	 edx, 11			; 0000000bH
  000e3	8b f4		 mov	 esi, esp
  000e5	52		 push	 edx
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_1HE@ECJOEGME@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@SetColorEd:

; 4938 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__PickerMask));     // Check only 1 option is selected

  00100	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00103	25 00 00 00 06	 and	 eax, 100663296		; 06000000H
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  0010e	83 c4 04	 add	 esp, 4
  00111	0f b6 c8	 movzx	 ecx, al
  00114	85 c9		 test	 ecx, ecx
  00116	75 26		 jne	 SHORT $LN9@SetColorEd
  00118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SetColorEditOptions@ImGui@@YAXH@Z@4JA
  0011e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00121	8b f4		 mov	 esi, esp
  00123	52		 push	 edx
  00124	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@IEGAFBEB@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH
  00137	3b f4		 cmp	 esi, esp
  00139	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@SetColorEd:

; 4939 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));      // Check only 1 option is selected

  0013e	8b 45 08	 mov	 eax, DWORD PTR _flags$[ebp]
  00141	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  0014c	83 c4 04	 add	 esp, 4
  0014f	0f b6 c8	 movzx	 ecx, al
  00152	85 c9		 test	 ecx, ecx
  00154	75 26		 jne	 SHORT $LN10@SetColorEd
  00156	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SetColorEditOptions@ImGui@@YAXH@Z@4JA
  0015c	83 c2 0d	 add	 edx, 13			; 0000000dH
  0015f	8b f4		 mov	 esi, esp
  00161	52		 push	 edx
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00167	68 00 00 00 00	 push	 OFFSET ??_C@_1GO@CDHIBPHM@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH
  00175	3b f4		 cmp	 esi, esp
  00177	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@SetColorEd:

; 4940 :     g.ColorEditOptions = flags;

  0017c	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  0017f	8b 4d 08	 mov	 ecx, DWORD PTR _flags$[ebp]
  00182	89 88 d4 2c 00
	00		 mov	 DWORD PTR [eax+11476], ecx

; 4941 : }

  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	5b		 pop	 ebx
  0018b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00191	3b ec		 cmp	 ebp, esp
  00193	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
?SetColorEditOptions@ImGui@@YAXH@Z ENDP			; ImGui::SetColorEditOptions
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z
_TEXT	SEGMENT
tv436 = -560						; size = 4
tv242 = -560						; size = 4
tv90 = -560						; size = 4
$T1 = -552						; size = 8
$T2 = -536						; size = 8
$T3 = -520						; size = 4
$T4 = -508						; size = 8
$T5 = -492						; size = 8
$T6 = -476						; size = 8
$T7 = -460						; size = 8
_col_source$8 = -252					; size = 16
_mid_x$9 = -228						; size = 4
_off$ = -216						; size = 4
_bb_inner$ = -204					; size = 16
_rounding$ = -180					; size = 4
_grid_step$ = -168					; size = 4
_col_rgb_without_alpha$ = -156				; size = 16
_col_rgb$ = -132					; size = 16
_pressed$ = -105					; size = 1
_held$ = -93						; size = 1
_hovered$ = -81						; size = 1
_bb$ = -72						; size = 16
_default_size$ = -48					; size = 4
_id$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_desc_id$ = 8						; size = 4
_col$ = 12						; size = 4
_flags$ = 16						; size = 4
_size$ = 20						; size = 8
?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z PROC	; ImGui::ColorButton, COMDAT

; 4849 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 02 00
	00		 sub	 esp, 560		; 00000230H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-560]
  00012	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4850 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 4851 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@ColorButto

; 4852 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 b2 06 00 00	 jmp	 $LN1@ColorButto
$LN2@ColorButto:

; 4853 : 
; 4854 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 4855 :     const ImGuiID id = window->GetID(desc_id);

  00054	6a 00		 push	 0
  00056	8b 45 08	 mov	 eax, DWORD PTR _desc_id$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0005d	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  00062	89 45 dc	 mov	 DWORD PTR _id$[ebp], eax

; 4856 :     float default_size = GetFrameHeight();

  00065	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  0006a	d9 5d d0	 fstp	 DWORD PTR _default_size$[ebp]

; 4857 :     if (size.x == 0.0f)

  0006d	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _size$[ebp]
  00072	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00079	9f		 lahf
  0007a	f6 c4 44	 test	 ah, 68			; 00000044H
  0007d	7a 0a		 jp	 SHORT $LN3@ColorButto

; 4858 :         size.x = default_size;

  0007f	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _default_size$[ebp]
  00084	f3 0f 11 45 14	 movss	 DWORD PTR _size$[ebp], xmm0
$LN3@ColorButto:

; 4859 :     if (size.y == 0.0f)

  00089	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  0008e	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00095	9f		 lahf
  00096	f6 c4 44	 test	 ah, 68			; 00000044H
  00099	7a 0a		 jp	 SHORT $LN4@ColorButto

; 4860 :         size.y = default_size;

  0009b	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _default_size$[ebp]
  000a0	f3 0f 11 45 18	 movss	 DWORD PTR _size$[ebp+4], xmm0
$LN4@ColorButto:

; 4861 :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

  000a5	8d 45 14	 lea	 eax, DWORD PTR _size$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000ac	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  000b2	51		 push	 ecx
  000b3	8d 95 34 fe ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	50		 push	 eax
  000c3	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000c6	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000cb	50		 push	 eax
  000cc	8d 4d b8	 lea	 ecx, DWORD PTR _bb$[ebp]
  000cf	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 4862 :     ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);

  000d4	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  000d9	0f 2f 45 d0	 comiss	 xmm0, DWORD PTR _default_size$[ebp]
  000dd	72 15		 jb	 SHORT $LN19@ColorButto
  000df	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  000e2	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  000ea	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR tv90[ebp], xmm0
  000f2	eb 0b		 jmp	 SHORT $LN20@ColorButto
$LN19@ColorButto:
  000f4	0f 57 c0	 xorps	 xmm0, xmm0
  000f7	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR tv90[ebp], xmm0
$LN20@ColorButto:
  000ff	51		 push	 ecx
  00100	f3 0f 10 85 d0
	fd ff ff	 movss	 xmm0, DWORD PTR tv90[ebp]
  00108	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010d	8d 4d b8	 lea	 ecx, DWORD PTR _bb$[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  00116	83 c4 08	 add	 esp, 8

; 4863 :     if (!ItemAdd(bb, id))

  00119	6a 00		 push	 0
  0011b	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  0011e	50		 push	 eax
  0011f	8d 4d b8	 lea	 ecx, DWORD PTR _bb$[ebp]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012b	0f b6 d0	 movzx	 edx, al
  0012e	85 d2		 test	 edx, edx
  00130	75 07		 jne	 SHORT $LN5@ColorButto

; 4864 :         return false;

  00132	32 c0		 xor	 al, al
  00134	e9 c5 05 00 00	 jmp	 $LN1@ColorButto
$LN5@ColorButto:

; 4865 : 
; 4866 :     bool hovered, held;
; 4867 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

  00139	6a 00		 push	 0
  0013b	8d 45 a3	 lea	 eax, DWORD PTR _held$[ebp]
  0013e	50		 push	 eax
  0013f	8d 4d af	 lea	 ecx, DWORD PTR _hovered$[ebp]
  00142	51		 push	 ecx
  00143	8b 55 dc	 mov	 edx, DWORD PTR _id$[ebp]
  00146	52		 push	 edx
  00147	8d 45 b8	 lea	 eax, DWORD PTR _bb$[ebp]
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  00150	83 c4 14	 add	 esp, 20			; 00000014H
  00153	88 45 97	 mov	 BYTE PTR _pressed$[ebp], al

; 4868 : 
; 4869 :     if (flags & ImGuiColorEditFlags_NoAlpha)

  00156	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00159	83 e0 02	 and	 eax, 2
  0015c	74 0b		 je	 SHORT $LN6@ColorButto

; 4870 :         flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

  0015e	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00161	25 ff ff f9 ff	 and	 eax, -393217		; fff9ffffH
  00166	89 45 10	 mov	 DWORD PTR _flags$[ebp], eax
$LN6@ColorButto:

; 4871 : 
; 4872 :     ImVec4 col_rgb = col;

  00169	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0016c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016e	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _col_rgb$[ebp], ecx
  00174	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00177	89 55 80	 mov	 DWORD PTR _col_rgb$[ebp+4], edx
  0017a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017d	89 4d 84	 mov	 DWORD PTR _col_rgb$[ebp+8], ecx
  00180	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00183	89 55 88	 mov	 DWORD PTR _col_rgb$[ebp+12], edx

; 4873 :     if (flags & ImGuiColorEditFlags_InputHSV)

  00186	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00189	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0018e	74 3b		 je	 SHORT $LN7@ColorButto

; 4874 :         ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);

  00190	8d 45 84	 lea	 eax, DWORD PTR _col_rgb$[ebp+8]
  00193	50		 push	 eax
  00194	8d 4d 80	 lea	 ecx, DWORD PTR _col_rgb$[ebp+4]
  00197	51		 push	 ecx
  00198	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _col_rgb$[ebp]
  0019e	52		 push	 edx
  0019f	51		 push	 ecx
  001a0	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _col_rgb$[ebp+8]
  001a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001aa	51		 push	 ecx
  001ab	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _col_rgb$[ebp+4]
  001b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b5	51		 push	 ecx
  001b6	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _col_rgb$[ebp]
  001be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c3	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  001c8	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@ColorButto:

; 4875 : 
; 4876 :     ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);

  001cb	51		 push	 ecx
  001cc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d9	51		 push	 ecx
  001da	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _col_rgb$[ebp+8]
  001df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e4	51		 push	 ecx
  001e5	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _col_rgb$[ebp+4]
  001ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ef	51		 push	 ecx
  001f0	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _col_rgb$[ebp]
  001f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _col_rgb_without_alpha$[ebp]
  00203	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4

; 4877 :     float grid_step = ImMin(size.x, size.y) / 2.99f;

  00208	51		 push	 ecx
  00209	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  0020e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00213	51		 push	 ecx
  00214	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _size$[ebp]
  00219	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021e	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00223	83 c4 08	 add	 esp, 8
  00226	d9 9d d0 fd ff
	ff		 fstp	 DWORD PTR tv436[ebp]
  0022c	f3 0f 10 85 d0
	fd ff ff	 movss	 xmm0, DWORD PTR tv436[ebp]
  00234	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@403f5c29
  0023c	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _grid_step$[ebp], xmm0

; 4878 :     float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);

  00244	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _grid_step$[ebp]
  0024c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00254	51		 push	 ecx
  00255	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0025d	51		 push	 ecx
  0025e	f3 0f 10 80 50
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5456]
  00266	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026b	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00270	83 c4 08	 add	 esp, 8
  00273	d9 9d 4c ff ff
	ff		 fstp	 DWORD PTR _rounding$[ebp]

; 4879 :     ImRect bb_inner = bb;

  00279	8b 45 b8	 mov	 eax, DWORD PTR _bb$[ebp]
  0027c	89 85 34 ff ff
	ff		 mov	 DWORD PTR _bb_inner$[ebp], eax
  00282	8b 4d bc	 mov	 ecx, DWORD PTR _bb$[ebp+4]
  00285	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _bb_inner$[ebp+4], ecx
  0028b	8b 55 c0	 mov	 edx, DWORD PTR _bb$[ebp+8]
  0028e	89 95 3c ff ff
	ff		 mov	 DWORD PTR _bb_inner$[ebp+8], edx
  00294	8b 45 c4	 mov	 eax, DWORD PTR _bb$[ebp+12]
  00297	89 85 40 ff ff
	ff		 mov	 DWORD PTR _bb_inner$[ebp+12], eax

; 4880 :     float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.

  0029d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf400000
  002a5	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _off$[ebp], xmm0

; 4881 :     bb_inner.Expand(off);

  002ad	51		 push	 ecx
  002ae	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _off$[ebp]
  002b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bb	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _bb_inner$[ebp]
  002c1	e8 00 00 00 00	 call	 ?Expand@ImRect@@QAEXM@Z	; ImRect::Expand

; 4882 :     if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f)

  002c6	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  002c9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  002ce	0f 84 5b 01 00
	00		 je	 $LN8@ColorButto
  002d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002dc	0f 2f 45 88	 comiss	 xmm0, DWORD PTR _col_rgb$[ebp+12]
  002e0	0f 86 49 01 00
	00		 jbe	 $LN8@ColorButto

; 4883 :     {
; 4884 :         float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);

  002e6	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _bb_inner$[ebp]
  002ee	f3 0f 58 85 3c
	ff ff ff	 addss	 xmm0, DWORD PTR _bb_inner$[ebp+8]
  002f6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  002fe	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00306	f3 0f 2c c0	 cvttss2si eax, xmm0
  0030a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0030e	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _mid_x$9[ebp], xmm0

; 4885 :         RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);

  00316	6a 0a		 push	 10			; 0000000aH
  00318	51		 push	 ecx
  00319	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00321	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00326	51		 push	 ecx
  00327	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _off$[ebp]
  0032f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00334	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _grid_step$[ebp]
  0033c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00343	f3 0f 58 85 28
	ff ff ff	 addss	 xmm0, DWORD PTR _off$[ebp]
  0034b	51		 push	 ecx
  0034c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00351	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00357	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0035c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0035f	51		 push	 ecx
  00360	8b 10		 mov	 edx, DWORD PTR [eax]
  00362	52		 push	 edx
  00363	51		 push	 ecx
  00364	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _grid_step$[ebp]
  0036c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00371	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _col_rgb$[ebp]
  00377	50		 push	 eax
  00378	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  0037d	83 c4 04	 add	 esp, 4
  00380	50		 push	 eax
  00381	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _bb_inner$[ebp+12]
  00387	51		 push	 ecx
  00388	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _bb_inner$[ebp+8]
  0038e	52		 push	 edx
  0038f	51		 push	 ecx
  00390	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _bb_inner$[ebp+4]
  00398	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039d	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _bb_inner$[ebp]
  003a5	f3 0f 58 85 58
	ff ff ff	 addss	 xmm0, DWORD PTR _grid_step$[ebp]
  003ad	51		 push	 ecx
  003ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b3	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  003b9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003c1	51		 push	 ecx
  003c2	8b 10		 mov	 edx, DWORD PTR [eax]
  003c4	52		 push	 edx
  003c5	e8 00 00 00 00	 call	 ?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
  003ca	83 c4 28	 add	 esp, 40			; 00000028H

; 4886 :         window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);

  003cd	6a 05		 push	 5
  003cf	51		 push	 ecx
  003d0	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  003d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003dd	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _col_rgb_without_alpha$[ebp]
  003e3	50		 push	 eax
  003e4	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  003e9	83 c4 04	 add	 esp, 4
  003ec	50		 push	 eax
  003ed	51		 push	 ecx
  003ee	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _bb_inner$[ebp+12]
  003f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fb	51		 push	 ecx
  003fc	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _mid_x$9[ebp]
  00404	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00409	8d 8d 04 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0040f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00414	50		 push	 eax
  00415	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _bb_inner$[ebp]
  0041b	51		 push	 ecx
  0041c	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  0041f	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  00425	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 4887 :     }

  0042a	e9 2c 01 00 00	 jmp	 $LN11@ColorButto
$LN8@ColorButto:

; 4888 :     else
; 4889 :     {
; 4890 :         // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
; 4891 :         ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;

  0042f	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00432	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00437	74 0e		 je	 SHORT $LN21@ColorButto
  00439	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _col_rgb$[ebp]
  0043f	89 8d d0 fd ff
	ff		 mov	 DWORD PTR tv242[ebp], ecx
  00445	eb 0c		 jmp	 SHORT $LN22@ColorButto
$LN21@ColorButto:
  00447	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _col_rgb_without_alpha$[ebp]
  0044d	89 95 d0 fd ff
	ff		 mov	 DWORD PTR tv242[ebp], edx
$LN22@ColorButto:
  00453	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR tv242[ebp]
  00459	89 85 f8 fd ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0045f	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00465	8b 11		 mov	 edx, DWORD PTR [ecx]
  00467	89 95 04 ff ff
	ff		 mov	 DWORD PTR _col_source$8[ebp], edx
  0046d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00470	89 85 08 ff ff
	ff		 mov	 DWORD PTR _col_source$8[ebp+4], eax
  00476	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00479	89 95 0c ff ff
	ff		 mov	 DWORD PTR _col_source$8[ebp+8], edx
  0047f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00482	89 85 10 ff ff
	ff		 mov	 DWORD PTR _col_source$8[ebp+12], eax

; 4892 :         if (col_source.w < 1.0f)

  00488	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00490	0f 2f 85 10 ff
	ff ff		 comiss	 xmm0, DWORD PTR _col_source$8[ebp+12]
  00497	0f 86 82 00 00
	00		 jbe	 $LN10@ColorButto

; 4893 :             RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);

  0049d	6a ff		 push	 -1
  0049f	51		 push	 ecx
  004a0	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  004a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ad	51		 push	 ecx
  004ae	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _off$[ebp]
  004b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004bb	51		 push	 ecx
  004bc	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _off$[ebp]
  004c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c9	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  004cf	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  004d4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004d7	51		 push	 ecx
  004d8	8b 10		 mov	 edx, DWORD PTR [eax]
  004da	52		 push	 edx
  004db	51		 push	 ecx
  004dc	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _grid_step$[ebp]
  004e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e9	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _col_source$8[ebp]
  004ef	50		 push	 eax
  004f0	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  004f5	83 c4 04	 add	 esp, 4
  004f8	50		 push	 eax
  004f9	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _bb_inner$[ebp+12]
  004ff	51		 push	 ecx
  00500	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _bb_inner$[ebp+8]
  00506	52		 push	 edx
  00507	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _bb_inner$[ebp+4]
  0050d	50		 push	 eax
  0050e	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _bb_inner$[ebp]
  00514	51		 push	 ecx
  00515	e8 00 00 00 00	 call	 ?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
  0051a	83 c4 28	 add	 esp, 40			; 00000028H
  0051d	eb 3c		 jmp	 SHORT $LN11@ColorButto
$LN10@ColorButto:

; 4894 :         else
; 4895 :             window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);

  0051f	6a 0f		 push	 15			; 0000000fH
  00521	51		 push	 ecx
  00522	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0052a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0052f	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _col_source$8[ebp]
  00535	50		 push	 eax
  00536	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  0053b	83 c4 04	 add	 esp, 4
  0053e	50		 push	 eax
  0053f	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _bb_inner$[ebp+8]
  00545	51		 push	 ecx
  00546	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _bb_inner$[ebp]
  0054c	52		 push	 edx
  0054d	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00550	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00556	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN11@ColorButto:

; 4896 :     }
; 4897 :     RenderNavHighlight(bb, id);

  0055b	6a 01		 push	 1
  0055d	8b 45 dc	 mov	 eax, DWORD PTR _id$[ebp]
  00560	50		 push	 eax
  00561	8d 4d b8	 lea	 ecx, DWORD PTR _bb$[ebp]
  00564	51		 push	 ecx
  00565	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  0056a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4898 :     if (g.Style.FrameBorderSize > 0.0f)

  0056d	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00570	f3 0f 10 80 54
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5460]
  00578	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0057f	76 28		 jbe	 SHORT $LN12@ColorButto

; 4899 :         RenderFrameBorder(bb.Min, bb.Max, rounding);

  00581	51		 push	 ecx
  00582	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0058a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0058f	8b 45 c4	 mov	 eax, DWORD PTR _bb$[ebp+12]
  00592	50		 push	 eax
  00593	8b 4d c0	 mov	 ecx, DWORD PTR _bb$[ebp+8]
  00596	51		 push	 ecx
  00597	8b 55 bc	 mov	 edx, DWORD PTR _bb$[ebp+4]
  0059a	52		 push	 edx
  0059b	8b 45 b8	 mov	 eax, DWORD PTR _bb$[ebp]
  0059e	50		 push	 eax
  0059f	e8 00 00 00 00	 call	 ?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
  005a4	83 c4 14	 add	 esp, 20			; 00000014H
  005a7	eb 4d		 jmp	 SHORT $LN13@ColorButto
$LN12@ColorButto:

; 4900 :     else
; 4901 :         window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

  005a9	51		 push	 ecx
  005aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b7	6a 0f		 push	 15			; 0000000fH
  005b9	51		 push	 ecx
  005ba	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  005c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c7	51		 push	 ecx
  005c8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005d5	6a 07		 push	 7
  005d7	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  005dc	83 c4 08	 add	 esp, 8
  005df	50		 push	 eax
  005e0	8d 45 c0	 lea	 eax, DWORD PTR _bb$[ebp+8]
  005e3	50		 push	 eax
  005e4	8d 4d b8	 lea	 ecx, DWORD PTR _bb$[ebp]
  005e7	51		 push	 ecx
  005e8	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  005eb	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  005f1	e8 00 00 00 00	 call	 ?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
$LN13@ColorButto:

; 4902 : 
; 4903 :     // Drag and Drop Source
; 4904 :     // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
; 4905 :     if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())

  005f6	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  005f9	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  005ff	3b 4d dc	 cmp	 ecx, DWORD PTR _id$[ebp]
  00602	0f 85 ca 00 00
	00		 jne	 $LN14@ColorButto
  00608	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0060b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00610	0f 85 bc 00 00
	00		 jne	 $LN14@ColorButto
  00616	6a 00		 push	 0
  00618	e8 00 00 00 00	 call	 ?BeginDragDropSource@ImGui@@YA_NH@Z ; ImGui::BeginDragDropSource
  0061d	83 c4 04	 add	 esp, 4
  00620	0f b6 c0	 movzx	 eax, al
  00623	85 c0		 test	 eax, eax
  00625	0f 84 a7 00 00
	00		 je	 $LN14@ColorButto

; 4906 :     {
; 4907 :         if (flags & ImGuiColorEditFlags_NoAlpha)

  0062b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0062e	83 e0 02	 and	 eax, 2
  00631	74 1a		 je	 SHORT $LN15@ColorButto

; 4908 :             SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);

  00633	6a 02		 push	 2
  00635	6a 0c		 push	 12			; 0000000cH
  00637	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _col_rgb$[ebp]
  0063d	50		 push	 eax
  0063e	68 00 00 00 00	 push	 OFFSET ??_C@_06LFKNFKEK@_COL3F@
  00643	e8 00 00 00 00	 call	 ?SetDragDropPayload@ImGui@@YA_NPBDPBXIH@Z ; ImGui::SetDragDropPayload
  00648	83 c4 10	 add	 esp, 16			; 00000010H
  0064b	eb 18		 jmp	 SHORT $LN16@ColorButto
$LN15@ColorButto:

; 4909 :         else
; 4910 :             SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4, ImGuiCond_Once);

  0064d	6a 02		 push	 2
  0064f	6a 10		 push	 16			; 00000010H
  00651	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _col_rgb$[ebp]
  00657	50		 push	 eax
  00658	68 00 00 00 00	 push	 OFFSET ??_C@_06LAOCEMMP@_COL4F@
  0065d	e8 00 00 00 00	 call	 ?SetDragDropPayload@ImGui@@YA_NPBDPBXIH@Z ; ImGui::SetDragDropPayload
  00662	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@ColorButto:

; 4911 :         ColorButton(desc_id, col, flags);

  00665	51		 push	 ecx
  00666	0f 57 c0	 xorps	 xmm0, xmm0
  00669	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0066e	51		 push	 ecx
  0066f	0f 57 c0	 xorps	 xmm0, xmm0
  00672	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00677	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0067d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00682	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00685	51		 push	 ecx
  00686	8b 10		 mov	 edx, DWORD PTR [eax]
  00688	52		 push	 edx
  00689	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0068c	50		 push	 eax
  0068d	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00690	51		 push	 ecx
  00691	8b 55 08	 mov	 edx, DWORD PTR _desc_id$[ebp]
  00694	52		 push	 edx
  00695	e8 00 00 00 00	 call	 ?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
  0069a	83 c4 14	 add	 esp, 20			; 00000014H

; 4912 :         SameLine();

  0069d	51		 push	 ecx
  0069e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  006a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ab	51		 push	 ecx
  006ac	0f 57 c0	 xorps	 xmm0, xmm0
  006af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006b4	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  006b9	83 c4 08	 add	 esp, 8

; 4913 :         TextEx("Color");

  006bc	6a 00		 push	 0
  006be	6a 00		 push	 0
  006c0	68 00 00 00 00	 push	 OFFSET ??_C@_05PDOBBJNA@Color@
  006c5	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  006ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4914 :         EndDragDropSource();

  006cd	e8 00 00 00 00	 call	 ?EndDragDropSource@ImGui@@YAXXZ ; ImGui::EndDragDropSource
$LN14@ColorButto:

; 4915 :     }
; 4916 : 
; 4917 :     // Tooltip
; 4918 :     if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)

  006d2	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  006d5	83 e0 40	 and	 eax, 64			; 00000040H
  006d8	75 21		 jne	 SHORT $LN17@ColorButto
  006da	0f b6 45 af	 movzx	 eax, BYTE PTR _hovered$[ebp]
  006de	85 c0		 test	 eax, eax
  006e0	74 19		 je	 SHORT $LN17@ColorButto

; 4919 :         ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

  006e2	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  006e5	25 02 00 06 18	 and	 eax, 403046402		; 18060002H
  006ea	50		 push	 eax
  006eb	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  006ee	51		 push	 ecx
  006ef	8b 55 08	 mov	 edx, DWORD PTR _desc_id$[ebp]
  006f2	52		 push	 edx
  006f3	e8 00 00 00 00	 call	 ?ColorTooltip@ImGui@@YAXPBDPBMH@Z ; ImGui::ColorTooltip
  006f8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@ColorButto:

; 4920 : 
; 4921 :     return pressed;

  006fb	8a 45 97	 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@ColorButto:

; 4922 : }

  006fe	52		 push	 edx
  006ff	8b cd		 mov	 ecx, ebp
  00701	50		 push	 eax
  00702	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN31@ColorButto
  00708	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0070d	58		 pop	 eax
  0070e	5a		 pop	 edx
  0070f	5f		 pop	 edi
  00710	5e		 pop	 esi
  00711	5b		 pop	 ebx
  00712	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00715	33 cd		 xor	 ecx, ebp
  00717	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0071c	81 c4 30 02 00
	00		 add	 esp, 560		; 00000230H
  00722	3b ec		 cmp	 ebp, esp
  00724	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00729	8b e5		 mov	 esp, ebp
  0072b	5d		 pop	 ebp
  0072c	c3		 ret	 0
  0072d	0f 1f 00	 npad	 3
$LN31@ColorButto:
  00730	07 00 00 00	 DD	 7
  00734	00 00 00 00	 DD	 $LN30@ColorButto
$LN30@ColorButto:
  00738	b8 ff ff ff	 DD	 -72			; ffffffb8H
  0073c	10 00 00 00	 DD	 16			; 00000010H
  00740	00 00 00 00	 DD	 $LN23@ColorButto
  00744	af ff ff ff	 DD	 -81			; ffffffafH
  00748	01 00 00 00	 DD	 1
  0074c	00 00 00 00	 DD	 $LN24@ColorButto
  00750	a3 ff ff ff	 DD	 -93			; ffffffa3H
  00754	01 00 00 00	 DD	 1
  00758	00 00 00 00	 DD	 $LN25@ColorButto
  0075c	7c ff ff ff	 DD	 -132			; ffffff7cH
  00760	10 00 00 00	 DD	 16			; 00000010H
  00764	00 00 00 00	 DD	 $LN26@ColorButto
  00768	64 ff ff ff	 DD	 -156			; ffffff64H
  0076c	10 00 00 00	 DD	 16			; 00000010H
  00770	00 00 00 00	 DD	 $LN27@ColorButto
  00774	34 ff ff ff	 DD	 -204			; ffffff34H
  00778	10 00 00 00	 DD	 16			; 00000010H
  0077c	00 00 00 00	 DD	 $LN28@ColorButto
  00780	04 ff ff ff	 DD	 -252			; ffffff04H
  00784	10 00 00 00	 DD	 16			; 00000010H
  00788	00 00 00 00	 DD	 $LN29@ColorButto
$LN29@ColorButto:
  0078c	63		 DB	 99			; 00000063H
  0078d	6f		 DB	 111			; 0000006fH
  0078e	6c		 DB	 108			; 0000006cH
  0078f	5f		 DB	 95			; 0000005fH
  00790	73		 DB	 115			; 00000073H
  00791	6f		 DB	 111			; 0000006fH
  00792	75		 DB	 117			; 00000075H
  00793	72		 DB	 114			; 00000072H
  00794	63		 DB	 99			; 00000063H
  00795	65		 DB	 101			; 00000065H
  00796	00		 DB	 0
$LN28@ColorButto:
  00797	62		 DB	 98			; 00000062H
  00798	62		 DB	 98			; 00000062H
  00799	5f		 DB	 95			; 0000005fH
  0079a	69		 DB	 105			; 00000069H
  0079b	6e		 DB	 110			; 0000006eH
  0079c	6e		 DB	 110			; 0000006eH
  0079d	65		 DB	 101			; 00000065H
  0079e	72		 DB	 114			; 00000072H
  0079f	00		 DB	 0
$LN27@ColorButto:
  007a0	63		 DB	 99			; 00000063H
  007a1	6f		 DB	 111			; 0000006fH
  007a2	6c		 DB	 108			; 0000006cH
  007a3	5f		 DB	 95			; 0000005fH
  007a4	72		 DB	 114			; 00000072H
  007a5	67		 DB	 103			; 00000067H
  007a6	62		 DB	 98			; 00000062H
  007a7	5f		 DB	 95			; 0000005fH
  007a8	77		 DB	 119			; 00000077H
  007a9	69		 DB	 105			; 00000069H
  007aa	74		 DB	 116			; 00000074H
  007ab	68		 DB	 104			; 00000068H
  007ac	6f		 DB	 111			; 0000006fH
  007ad	75		 DB	 117			; 00000075H
  007ae	74		 DB	 116			; 00000074H
  007af	5f		 DB	 95			; 0000005fH
  007b0	61		 DB	 97			; 00000061H
  007b1	6c		 DB	 108			; 0000006cH
  007b2	70		 DB	 112			; 00000070H
  007b3	68		 DB	 104			; 00000068H
  007b4	61		 DB	 97			; 00000061H
  007b5	00		 DB	 0
$LN26@ColorButto:
  007b6	63		 DB	 99			; 00000063H
  007b7	6f		 DB	 111			; 0000006fH
  007b8	6c		 DB	 108			; 0000006cH
  007b9	5f		 DB	 95			; 0000005fH
  007ba	72		 DB	 114			; 00000072H
  007bb	67		 DB	 103			; 00000067H
  007bc	62		 DB	 98			; 00000062H
  007bd	00		 DB	 0
$LN25@ColorButto:
  007be	68		 DB	 104			; 00000068H
  007bf	65		 DB	 101			; 00000065H
  007c0	6c		 DB	 108			; 0000006cH
  007c1	64		 DB	 100			; 00000064H
  007c2	00		 DB	 0
$LN24@ColorButto:
  007c3	68		 DB	 104			; 00000068H
  007c4	6f		 DB	 111			; 0000006fH
  007c5	76		 DB	 118			; 00000076H
  007c6	65		 DB	 101			; 00000065H
  007c7	72		 DB	 114			; 00000072H
  007c8	65		 DB	 101			; 00000065H
  007c9	64		 DB	 100			; 00000064H
  007ca	00		 DB	 0
$LN23@ColorButto:
  007cb	62		 DB	 98			; 00000062H
  007cc	62		 DB	 98			; 00000062H
  007cd	00		 DB	 0
?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z ENDP	; ImGui::ColorButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z
_TEXT	SEGMENT
tv626 = -2456						; size = 4
tv2069 = -2452						; size = 4
tv2053 = -2452						; size = 4
tv622 = -2452						; size = 4
tv2456 = -2448						; size = 4
tv2454 = -2448						; size = 4
tv2385 = -2448						; size = 4
tv2265 = -2448						; size = 4
tv2251 = -2448						; size = 4
tv2062 = -2448						; size = 4
tv2046 = -2448						; size = 4
tv1975 = -2448						; size = 4
tv1729 = -2448						; size = 4
tv1689 = -2448						; size = 4
tv1601 = -2448						; size = 4
tv1250 = -2448						; size = 4
tv967 = -2448						; size = 4
tv743 = -2448						; size = 4
tv726 = -2448						; size = 4
tv667 = -2448						; size = 4
tv645 = -2448						; size = 4
tv619 = -2448						; size = 4
tv543 = -2448						; size = 4
tv511 = -2448						; size = 4
tv173 = -2448						; size = 4
tv164 = -2448						; size = 4
tv159 = -2448						; size = 4
tv129 = -2448						; size = 4
tv88 = -2448						; size = 4
$T1 = -2440						; size = 8
$T2 = -2424						; size = 8
$T3 = -2408						; size = 8
$T4 = -2392						; size = 8
$T5 = -2376						; size = 8
$T6 = -2360						; size = 8
$T7 = -2344						; size = 8
$T8 = -2328						; size = 8
$T9 = -2312						; size = 8
$T10 = -2296						; size = 8
$T11 = -2280						; size = 8
$T12 = -2264						; size = 8
$T13 = -2248						; size = 8
$T14 = -2232						; size = 8
$T15 = -2216						; size = 8
$T16 = -2200						; size = 8
$T17 = -2184						; size = 8
$T18 = -2168						; size = 8
$T19 = -2152						; size = 8
$T20 = -2136						; size = 8
$T21 = -2120						; size = 16
$T22 = -2096						; size = 8
$T23 = -2080						; size = 8
$T24 = -2064						; size = 8
$T25 = -2048						; size = 8
$T26 = -2032						; size = 8
$T27 = -2016						; size = 8
$T28 = -2000						; size = 8
$T29 = -1984						; size = 8
$T30 = -1968						; size = 8
$T31 = -1952						; size = 8
_bar1_line_y$32 = -1168					; size = 4
_bar1_bb$33 = -1156					; size = 16
_alpha$34 = -1132					; size = 4
_sv_cursor_rad$ = -1120					; size = 4
_bar0_line_y$35 = -1108					; size = 4
_i$36 = -1096						; size = 4
_uv_white$37 = -1084					; size = 8
_trc$38 = -1068						; size = 8
_trb$39 = -1052						; size = 8
_tra$40 = -1036						; size = 8
_hue_cursor_segments$41 = -1020				; size = 4
_hue_cursor_rad$42 = -1008				; size = 4
_hue_cursor_pos$43 = -996				; size = 8
_sin_hue_angle$44 = -980				; size = 4
_cos_hue_angle$45 = -968				; size = 4
_gradient_p1$46 = -956					; size = 8
_gradient_p0$47 = -940					; size = 8
_vert_end_idx$48 = -924					; size = 4
_vert_start_idx$49 = -912				; size = 4
_a1$50 = -900						; size = 4
_a0$51 = -888						; size = 4
_n$52 = -876						; size = 4
_segment_per_arc$53 = -864				; size = 4
_aeps$54 = -852						; size = 4
_sv_cursor_pos$ = -840					; size = 8
_user_col32_striped_of_alpha$ = -824			; size = 4
_hue_color32$ = -812					; size = 4
_hue_color_f$ = -800					; size = 16
_col_hues$ = -776					; size = 28
_col_midgrey$ = -740					; size = 4
_col_white$ = -728					; size = 4
_col_black$ = -716					; size = 4
_style_alpha8$ = -704					; size = 4
_new_V$55 = -692					; size = 4
_new_S$56 = -680					; size = 4
_new_H$57 = -668					; size = 4
_sub_flags$58 = -656					; size = 4
_sub_flags_to_forward$59 = -644				; size = 4
_value_changed_fix_hue_wrap$ = -629			; size = 1
_ref_col_v4$60 = -620					; size = 16
_sub_flags_to_forward$61 = -596				; size = 4
_col_v4$62 = -584					; size = 16
_label_display_end$63 = -560				; size = 4
_ww$64 = -548						; size = 4
_vv$65 = -536						; size = 4
_uu$66 = -524						; size = 4
_current_off_unrotated$67 = -512			; size = 8
_sin_hue_angle$68 = -496				; size = 4
_cos_hue_angle$69 = -484				; size = 4
_initial_dist2$70 = -472				; size = 4
_current_off$71 = -460					; size = 8
_initial_off$72 = -444					; size = 8
_value_changed_sv$ = -425				; size = 1
_value_changed_h$ = -413				; size = 1
_value_changed$ = -401					; size = 1
_B$ = -392						; size = 4
_G$ = -380						; size = 4
_R$ = -368						; size = 4
_V$ = -356						; size = 4
_S$ = -344						; size = 4
_H$ = -332						; size = 4
_triangle_pc$ = -320					; size = 8
_triangle_pb$ = -304					; size = 8
_triangle_pa$ = -288					; size = 8
_triangle_r$ = -272					; size = 4
_wheel_center$ = -260					; size = 8
_wheel_r_inner$ = -244					; size = 4
_wheel_r_outer$ = -232					; size = 4
_wheel_thickness$ = -220				; size = 4
_backup_initial_col$ = -208				; size = 16
_bars_triangles_half_sz$ = -184				; size = 4
_bar1_pos_x$ = -172					; size = 4
_bar0_pos_x$ = -160					; size = 4
_sv_picker_size$ = -148					; size = 4
_bars_width$ = -136					; size = 4
_square_sz$ = -124					; size = 4
_picker_pos$ = -112					; size = 8
_alpha_bar$ = -93					; size = 1
_components$ = -84					; size = 4
_width$ = -72						; size = 4
_io$ = -60						; size = 4
_style$ = -48						; size = 4
_draw_list$ = -36					; size = 4
_window$ = -24						; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_col$ = 12						; size = 4
_flags$ = 16						; size = 4
_ref_col$ = 20						; size = 4
?ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z PROC		; ImGui::ColorPicker4, COMDAT

; 4481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 09 00
	00		 sub	 esp, 2456		; 00000998H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 68 f6 ff
	ff		 lea	 edi, DWORD PTR [ebp-2456]
  00012	b9 66 02 00 00	 mov	 ecx, 614		; 00000266H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4482 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 4483 :     ImGuiWindow* window = GetCurrentWindow();

  0003a	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0003f	89 45 e8	 mov	 DWORD PTR _window$[ebp], eax

; 4484 :     if (window->SkipItems)

  00042	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00045	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00049	85 c9		 test	 ecx, ecx
  0004b	74 07		 je	 SHORT $LN8@ColorPicke

; 4485 :         return false;

  0004d	32 c0		 xor	 al, al
  0004f	e9 ca 26 00 00	 jmp	 $LN1@ColorPicke
$LN8@ColorPicke:

; 4486 : 
; 4487 :     ImDrawList* draw_list = window->DrawList;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00057	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  0005d	89 4d dc	 mov	 DWORD PTR _draw_list$[ebp], ecx

; 4488 :     ImGuiStyle& style = g.Style;

  00060	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00063	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  00068	89 45 d0	 mov	 DWORD PTR _style$[ebp], eax

; 4489 :     ImGuiIO& io = g.IO;

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0006e	83 c0 08	 add	 eax, 8
  00071	89 45 c4	 mov	 DWORD PTR _io$[ebp], eax

; 4490 : 
; 4491 :     const float width = CalcItemWidth();

  00074	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00079	d9 5d b8	 fstp	 DWORD PTR _width$[ebp]

; 4492 :     g.NextItemData.ClearFlags();

  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  0007f	81 c1 84 1a 00
	00		 add	 ecx, 6788		; 00001a84H
  00085	e8 00 00 00 00	 call	 ?ClearFlags@ImGuiNextItemData@@QAEXXZ ; ImGuiNextItemData::ClearFlags

; 4493 : 
; 4494 :     PushID(label);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  00093	83 c4 04	 add	 esp, 4

; 4495 :     BeginGroup();

  00096	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 4496 : 
; 4497 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))

  0009b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0009e	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000a3	75 09		 jne	 SHORT $LN9@ColorPicke

; 4498 :         flags |= ImGuiColorEditFlags_NoSmallPreview;

  000a5	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000a8	83 c8 10	 or	 eax, 16			; 00000010H
  000ab	89 45 10	 mov	 DWORD PTR _flags$[ebp], eax
$LN9@ColorPicke:

; 4499 : 
; 4500 :     // Context menu: display and store options.
; 4501 :     if (!(flags & ImGuiColorEditFlags_NoOptions))

  000ae	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000b1	83 e0 08	 and	 eax, 8
  000b4	75 10		 jne	 SHORT $LN10@ColorPicke

; 4502 :         ColorPickerOptionsPopup(col, flags);

  000b6	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ?ColorPickerOptionsPopup@ImGui@@YAXPBMH@Z ; ImGui::ColorPickerOptionsPopup
  000c3	83 c4 08	 add	 esp, 8
$LN10@ColorPicke:

; 4503 : 
; 4504 :     // Read stored options
; 4505 :     if (!(flags & ImGuiColorEditFlags__PickerMask))

  000c6	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000c9	25 00 00 00 06	 and	 eax, 100663296		; 06000000H
  000ce	75 3e		 jne	 SHORT $LN11@ColorPicke

; 4506 :         flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000d3	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  000d9	81 e1 00 00 00
	06		 and	 ecx, 100663296		; 06000000H
  000df	74 11		 je	 SHORT $LN70@ColorPicke
  000e1	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  000e4	8b 82 d4 2c 00
	00		 mov	 eax, DWORD PTR [edx+11476]
  000ea	89 85 70 f6 ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  000f0	eb 0a		 jmp	 SHORT $LN71@ColorPicke
$LN70@ColorPicke:
  000f2	c7 85 70 f6 ff
	ff 00 00 90 0a	 mov	 DWORD PTR tv88[ebp], 177209344 ; 0a900000H
$LN71@ColorPicke:
  000fc	8b 8d 70 f6 ff
	ff		 mov	 ecx, DWORD PTR tv88[ebp]
  00102	81 e1 00 00 00
	06		 and	 ecx, 100663296		; 06000000H
  00108	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  0010b	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx
$LN11@ColorPicke:

; 4507 :     if (!(flags & ImGuiColorEditFlags__InputMask))

  0010e	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00111	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  00116	75 3e		 jne	 SHORT $LN12@ColorPicke

; 4508 :         flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__InputMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__InputMask;

  00118	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0011b	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  00121	81 e1 00 00 00
	18		 and	 ecx, 402653184		; 18000000H
  00127	74 11		 je	 SHORT $LN72@ColorPicke
  00129	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  0012c	8b 82 d4 2c 00
	00		 mov	 eax, DWORD PTR [edx+11476]
  00132	89 85 70 f6 ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  00138	eb 0a		 jmp	 SHORT $LN73@ColorPicke
$LN72@ColorPicke:
  0013a	c7 85 70 f6 ff
	ff 00 00 90 0a	 mov	 DWORD PTR tv129[ebp], 177209344 ; 0a900000H
$LN73@ColorPicke:
  00144	8b 8d 70 f6 ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  0014a	81 e1 00 00 00
	18		 and	 ecx, 402653184		; 18000000H
  00150	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  00153	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx
$LN12@ColorPicke:

; 4509 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__PickerMask)); // Check that only 1 is selected

  00156	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00159	25 00 00 00 06	 and	 eax, 100663296		; 06000000H
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  00164	83 c4 04	 add	 esp, 4
  00167	0f b6 c8	 movzx	 ecx, al
  0016a	85 c9		 test	 ecx, ecx
  0016c	75 26		 jne	 SHORT $LN74@ColorPicke
  0016e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z@4JA
  00174	83 c2 1c	 add	 edx, 28			; 0000001cH
  00177	8b f4		 mov	 esi, esp
  00179	52		 push	 edx
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@IEGAFBEB@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0018a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018d	3b f4		 cmp	 esi, esp
  0018f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN74@ColorPicke:

; 4510 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));  // Check that only 1 is selected

  00194	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00197	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  001a2	83 c4 04	 add	 esp, 4
  001a5	0f b6 c8	 movzx	 ecx, al
  001a8	85 c9		 test	 ecx, ecx
  001aa	75 26		 jne	 SHORT $LN75@ColorPicke
  001ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z@4JA
  001b2	83 c2 1d	 add	 edx, 29			; 0000001dH
  001b5	8b f4		 mov	 esi, esp
  001b7	52		 push	 edx
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_1GO@CDHIBPHM@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cb	3b f4		 cmp	 esi, esp
  001cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN75@ColorPicke:

; 4511 :     if (!(flags & ImGuiColorEditFlags_NoOptions))

  001d2	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001d5	83 e0 08	 and	 eax, 8
  001d8	75 15		 jne	 SHORT $LN13@ColorPicke

; 4512 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

  001da	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  001dd	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  001e3	81 e1 00 00 01
	00		 and	 ecx, 65536		; 00010000H
  001e9	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  001ec	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx
$LN13@ColorPicke:

; 4513 : 
; 4514 :     // Setup
; 4515 :     int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;

  001ef	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001f2	83 e0 02	 and	 eax, 2
  001f5	74 0c		 je	 SHORT $LN76@ColorPicke
  001f7	c7 85 70 f6 ff
	ff 03 00 00 00	 mov	 DWORD PTR tv159[ebp], 3
  00201	eb 0a		 jmp	 SHORT $LN77@ColorPicke
$LN76@ColorPicke:
  00203	c7 85 70 f6 ff
	ff 04 00 00 00	 mov	 DWORD PTR tv159[ebp], 4
$LN77@ColorPicke:
  0020d	8b 8d 70 f6 ff
	ff		 mov	 ecx, DWORD PTR tv159[ebp]
  00213	89 4d ac	 mov	 DWORD PTR _components$[ebp], ecx

; 4516 :     bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);

  00216	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00219	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  0021e	74 14		 je	 SHORT $LN78@ColorPicke
  00220	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  00223	83 e1 02	 and	 ecx, 2
  00226	75 0c		 jne	 SHORT $LN78@ColorPicke
  00228	c7 85 70 f6 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv164[ebp], 1
  00232	eb 0a		 jmp	 SHORT $LN79@ColorPicke
$LN78@ColorPicke:
  00234	c7 85 70 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv164[ebp], 0
$LN79@ColorPicke:
  0023e	8a 95 70 f6 ff
	ff		 mov	 dl, BYTE PTR tv164[ebp]
  00244	88 55 a3	 mov	 BYTE PTR _alpha_bar$[ebp], dl

; 4517 :     ImVec2 picker_pos = window->DC.CursorPos;

  00247	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  0024a	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00250	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00256	89 4d 90	 mov	 DWORD PTR _picker_pos$[ebp], ecx
  00259	89 55 94	 mov	 DWORD PTR _picker_pos$[ebp+4], edx

; 4518 :     float square_sz = GetFrameHeight();

  0025c	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  00261	d9 5d 84	 fstp	 DWORD PTR _square_sz$[ebp]

; 4519 :     float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars

  00264	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00269	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _bars_width$[ebp], xmm0

; 4520 :     float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

  00271	0f b6 45 a3	 movzx	 eax, BYTE PTR _alpha_bar$[ebp]
  00275	85 c0		 test	 eax, eax
  00277	74 0c		 je	 SHORT $LN80@ColorPicke
  00279	c7 85 70 f6 ff
	ff 02 00 00 00	 mov	 DWORD PTR tv173[ebp], 2
  00283	eb 0a		 jmp	 SHORT $LN81@ColorPicke
$LN80@ColorPicke:
  00285	c7 85 70 f6 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv173[ebp], 1
$LN81@ColorPicke:
  0028f	f3 0f 2a 85 70
	f6 ff ff	 cvtsi2ss xmm0, DWORD PTR tv173[ebp]
  00297	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  0029a	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _bars_width$[ebp]
  002a2	f3 0f 58 49 50	 addss	 xmm1, DWORD PTR [ecx+80]
  002a7	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002ab	f3 0f 10 4d b8	 movss	 xmm1, DWORD PTR _width$[ebp]
  002b0	f3 0f 5c c8	 subss	 xmm1, xmm0
  002b4	51		 push	 ecx
  002b5	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  002ba	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_width$[ebp]
  002c2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  002ca	51		 push	 ecx
  002cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  002d5	83 c4 08	 add	 esp, 8
  002d8	d9 9d 6c ff ff
	ff		 fstp	 DWORD PTR _sv_picker_size$[ebp]

; 4521 :     float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;

  002de	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _picker_pos$[ebp]
  002e3	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  002eb	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  002ee	f3 0f 58 40 50	 addss	 xmm0, DWORD PTR [eax+80]
  002f3	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _bar0_pos_x$[ebp], xmm0

; 4522 :     float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;

  002fb	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  00303	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _bars_width$[ebp]
  0030b	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0030e	f3 0f 58 40 50	 addss	 xmm0, DWORD PTR [eax+80]
  00313	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _bar1_pos_x$[ebp], xmm0

; 4523 :     float bars_triangles_half_sz = IM_FLOOR(bars_width * 0.20f);

  0031b	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_width$[ebp]
  00323	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e4ccccd
  0032b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0032f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00333	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _bars_triangles_half_sz$[ebp], xmm0

; 4524 : 
; 4525 :     float backup_initial_col[4];
; 4526 :     memcpy(backup_initial_col, col, components * sizeof(float));

  0033b	8b 45 ac	 mov	 eax, DWORD PTR _components$[ebp]
  0033e	c1 e0 02	 shl	 eax, 2
  00341	50		 push	 eax
  00342	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00345	51		 push	 ecx
  00346	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _backup_initial_col$[ebp]
  0034c	52		 push	 edx
  0034d	e8 00 00 00 00	 call	 _memcpy
  00352	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4527 : 
; 4528 :     float wheel_thickness = sv_picker_size * 0.08f;

  00355	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  0035d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3da3d70a
  00365	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _wheel_thickness$[ebp], xmm0

; 4529 :     float wheel_r_outer = sv_picker_size * 0.50f;

  0036d	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  00375	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0037d	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _wheel_r_outer$[ebp], xmm0

; 4530 :     float wheel_r_inner = wheel_r_outer - wheel_thickness;

  00385	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_r_outer$[ebp]
  0038d	f3 0f 5c 85 24
	ff ff ff	 subss	 xmm0, DWORD PTR _wheel_thickness$[ebp]
  00395	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _wheel_r_inner$[ebp], xmm0

; 4531 :     ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);

  0039d	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  003a5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  003ad	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  003b2	51		 push	 ecx
  003b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b8	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  003c0	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _bars_width$[ebp]
  003c8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  003d0	f3 0f 58 45 90	 addss	 xmm0, DWORD PTR _picker_pos$[ebp]
  003d5	51		 push	 ecx
  003d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003db	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _wheel_center$[ebp]
  003e1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4532 : 
; 4533 :     // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
; 4534 :     float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);

  003e6	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  003ee	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3cdd2f1b
  003f6	f3 0f 2c c0	 cvttss2si eax, xmm0
  003fa	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003fe	f3 0f 10 8d 0c
	ff ff ff	 movss	 xmm1, DWORD PTR _wheel_r_inner$[ebp]
  00406	f3 0f 5c c8	 subss	 xmm1, xmm0
  0040a	f3 0f 11 8d f0
	fe ff ff	 movss	 DWORD PTR _triangle_r$[ebp], xmm1

; 4535 :     ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.

  00412	51		 push	 ecx
  00413	0f 57 c0	 xorps	 xmm0, xmm0
  00416	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0041b	51		 push	 ecx
  0041c	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _triangle_r$[ebp]
  00424	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00429	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _triangle_pa$[ebp]
  0042f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4536 :     ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.

  00434	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _triangle_r$[ebp]
  0043c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf5db3d0
  00444	51		 push	 ecx
  00445	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0044a	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _triangle_r$[ebp]
  00452	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf000000
  0045a	51		 push	 ecx
  0045b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00460	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _triangle_pb$[ebp]
  00466	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4537 :     ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

  0046b	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _triangle_r$[ebp]
  00473	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f5db3d0
  0047b	51		 push	 ecx
  0047c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00481	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _triangle_r$[ebp]
  00489	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf000000
  00491	51		 push	 ecx
  00492	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00497	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _triangle_pc$[ebp]
  0049d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4538 : 
; 4539 :     float H = col[0], S = col[1], V = col[2];

  004a2	b8 04 00 00 00	 mov	 eax, 4
  004a7	6b c8 00	 imul	 ecx, eax, 0
  004aa	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  004ad	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  004b2	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _H$[ebp], xmm0
  004ba	b8 04 00 00 00	 mov	 eax, 4
  004bf	c1 e0 00	 shl	 eax, 0
  004c2	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  004c5	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  004ca	f3 0f 11 85 a8
	fe ff ff	 movss	 DWORD PTR _S$[ebp], xmm0
  004d2	b8 04 00 00 00	 mov	 eax, 4
  004d7	d1 e0		 shl	 eax, 1
  004d9	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  004dc	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  004e1	f3 0f 11 85 9c
	fe ff ff	 movss	 DWORD PTR _V$[ebp], xmm0

; 4540 :     float R = col[0], G = col[1], B = col[2];

  004e9	b8 04 00 00 00	 mov	 eax, 4
  004ee	6b c8 00	 imul	 ecx, eax, 0
  004f1	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  004f4	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  004f9	f3 0f 11 85 90
	fe ff ff	 movss	 DWORD PTR _R$[ebp], xmm0
  00501	b8 04 00 00 00	 mov	 eax, 4
  00506	c1 e0 00	 shl	 eax, 0
  00509	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  0050c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00511	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR _G$[ebp], xmm0
  00519	b8 04 00 00 00	 mov	 eax, 4
  0051e	d1 e0		 shl	 eax, 1
  00520	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00523	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00528	f3 0f 11 85 78
	fe ff ff	 movss	 DWORD PTR _B$[ebp], xmm0

; 4541 :     if (flags & ImGuiColorEditFlags_InputRGB)

  00530	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00533	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00538	0f 84 8d 00 00
	00		 je	 $LN14@ColorPicke

; 4542 :     {
; 4543 :         // Hue is lost when converting from greyscale rgb (saturation=0). Restore it.
; 4544 :         ColorConvertRGBtoHSV(R, G, B, H, S, V);

  0053e	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _V$[ebp]
  00544	50		 push	 eax
  00545	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _S$[ebp]
  0054b	51		 push	 ecx
  0054c	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _H$[ebp]
  00552	52		 push	 edx
  00553	51		 push	 ecx
  00554	f3 0f 10 85 78
	fe ff ff	 movss	 xmm0, DWORD PTR _B$[ebp]
  0055c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00561	51		 push	 ecx
  00562	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _G$[ebp]
  0056a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0056f	51		 push	 ecx
  00570	f3 0f 10 85 90
	fe ff ff	 movss	 xmm0, DWORD PTR _R$[ebp]
  00578	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0057d	e8 00 00 00 00	 call	 ?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertRGBtoHSV
  00582	83 c4 18	 add	 esp, 24			; 00000018H

; 4545 :         if (S == 0 && memcmp(g.ColorEditLastColor, col, sizeof(float) * 3) == 0)

  00585	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  0058d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00594	9f		 lahf
  00595	f6 c4 44	 test	 ah, 68			; 00000044H
  00598	7a 2f		 jp	 SHORT $LN16@ColorPicke
  0059a	6a 0c		 push	 12			; 0000000cH
  0059c	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0059f	50		 push	 eax
  005a0	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  005a3	81 c1 dc 2c 00
	00		 add	 ecx, 11484		; 00002cdcH
  005a9	51		 push	 ecx
  005aa	e8 00 00 00 00	 call	 _memcmp
  005af	83 c4 0c	 add	 esp, 12			; 0000000cH
  005b2	85 c0		 test	 eax, eax
  005b4	75 13		 jne	 SHORT $LN16@ColorPicke

; 4546 :             H = g.ColorEditLastHue;

  005b6	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  005b9	f3 0f 10 80 d8
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11480]
  005c1	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _H$[ebp], xmm0
$LN16@ColorPicke:

; 4547 :     }

  005c9	eb 51		 jmp	 SHORT $LN17@ColorPicke
$LN14@ColorPicke:

; 4548 :     else if (flags & ImGuiColorEditFlags_InputHSV)

  005cb	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  005ce	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005d3	74 47		 je	 SHORT $LN17@ColorPicke

; 4549 :     {
; 4550 :         ColorConvertHSVtoRGB(H, S, V, R, G, B);

  005d5	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR _B$[ebp]
  005db	50		 push	 eax
  005dc	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _G$[ebp]
  005e2	51		 push	 ecx
  005e3	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _R$[ebp]
  005e9	52		 push	 edx
  005ea	51		 push	 ecx
  005eb	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _V$[ebp]
  005f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005f8	51		 push	 ecx
  005f9	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  00601	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00606	51		 push	 ecx
  00607	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  0060f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00614	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  00619	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@ColorPicke:

; 4551 :     }
; 4552 : 
; 4553 :     bool value_changed = false, value_changed_h = false, value_changed_sv = false;

  0061c	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0
  00623	c6 85 63 fe ff
	ff 00		 mov	 BYTE PTR _value_changed_h$[ebp], 0
  0062a	c6 85 57 fe ff
	ff 00		 mov	 BYTE PTR _value_changed_sv$[ebp], 0

; 4554 : 
; 4555 :     PushItemFlag(ImGuiItemFlags_NoNav, true);

  00631	6a 01		 push	 1
  00633	6a 08		 push	 8
  00635	e8 00 00 00 00	 call	 ?PushItemFlag@ImGui@@YAXH_N@Z ; ImGui::PushItemFlag
  0063a	83 c4 08	 add	 esp, 8

; 4556 :     if (flags & ImGuiColorEditFlags_PickerHueWheel)

  0063d	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00640	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00645	0f 84 dc 03 00
	00		 je	 $LN18@ColorPicke

; 4557 :     {
; 4558 :         // Hue wheel + SV triangle logic
; 4559 :         InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));

  0064b	51		 push	 ecx
  0064c	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  00654	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00659	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0065c	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  00664	f3 0f 58 40 50	 addss	 xmm0, DWORD PTR [eax+80]
  00669	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _bars_width$[ebp]
  00671	51		 push	 ecx
  00672	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00677	8d 8d 60 f8 ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  0067d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00682	50		 push	 eax
  00683	68 00 00 00 00	 push	 OFFSET ??_C@_03PPLPHHG@hsv@
  00688	e8 00 00 00 00	 call	 ?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::InvisibleButton
  0068d	83 c4 08	 add	 esp, 8

; 4560 :         if (IsItemActive())

  00690	e8 00 00 00 00	 call	 ?IsItemActive@ImGui@@YA_NXZ ; ImGui::IsItemActive
  00695	0f b6 c0	 movzx	 eax, al
  00698	85 c0		 test	 eax, eax
  0069a	0f 84 6b 03 00
	00		 je	 $LN23@ColorPicke

; 4561 :         {
; 4562 :             ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;

  006a0	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _wheel_center$[ebp]
  006a6	50		 push	 eax
  006a7	b9 08 00 00 00	 mov	 ecx, 8
  006ac	6b d1 00	 imul	 edx, ecx, 0
  006af	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  006b2	8d 8c 10 88 03
	00 00		 lea	 ecx, DWORD PTR [eax+edx+904]
  006b9	51		 push	 ecx
  006ba	8d 95 44 fe ff
	ff		 lea	 edx, DWORD PTR _initial_off$72[ebp]
  006c0	52		 push	 edx
  006c1	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  006c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4563 :             ImVec2 current_off = g.IO.MousePos - wheel_center;

  006c9	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _wheel_center$[ebp]
  006cf	50		 push	 eax
  006d0	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  006d3	81 c1 e8 00 00
	00		 add	 ecx, 232		; 000000e8H
  006d9	51		 push	 ecx
  006da	8d 95 34 fe ff
	ff		 lea	 edx, DWORD PTR _current_off$71[ebp]
  006e0	52		 push	 edx
  006e1	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  006e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4564 :             float initial_dist2 = ImLengthSqr(initial_off);

  006e9	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR _initial_off$72[ebp]
  006ef	50		 push	 eax
  006f0	e8 00 00 00 00	 call	 ?ImLengthSqr@@YAMABUImVec2@@@Z ; ImLengthSqr
  006f5	83 c4 04	 add	 esp, 4
  006f8	d9 9d 28 fe ff
	ff		 fstp	 DWORD PTR _initial_dist2$70[ebp]

; 4565 :             if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))

  006fe	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  00706	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0070e	f3 0f 10 8d 0c
	ff ff ff	 movss	 xmm1, DWORD PTR _wheel_r_inner$[ebp]
  00716	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  0071e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00722	f3 0f 10 8d 28
	fe ff ff	 movss	 xmm1, DWORD PTR _initial_dist2$70[ebp]
  0072a	0f 2f c8	 comiss	 xmm1, xmm0
  0072d	0f 82 b2 00 00
	00		 jb	 $LN21@ColorPicke
  00733	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_r_outer$[ebp]
  0073b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00743	f3 0f 10 8d 18
	ff ff ff	 movss	 xmm1, DWORD PTR _wheel_r_outer$[ebp]
  0074b	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
  00753	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00757	0f 2f 85 28 fe
	ff ff		 comiss	 xmm0, DWORD PTR _initial_dist2$70[ebp]
  0075e	0f 82 81 00 00
	00		 jb	 $LN21@ColorPicke

; 4566 :             {
; 4567 :                 // Interactive with Hue wheel
; 4568 :                 H = ImAtan2(current_off.y, current_off.x) / IM_PI*0.5f;

  00764	51		 push	 ecx
  00765	f3 0f 10 85 34
	fe ff ff	 movss	 xmm0, DWORD PTR _current_off$71[ebp]
  0076d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00772	51		 push	 ecx
  00773	f3 0f 10 85 38
	fe ff ff	 movss	 xmm0, DWORD PTR _current_off$71[ebp+4]
  0077b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00780	e8 00 00 00 00	 call	 ?ImAtan2@@YAMMM@Z	; ImAtan2
  00785	83 c4 08	 add	 esp, 8
  00788	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv1601[ebp]
  0078e	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv1601[ebp]
  00796	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40490fdb
  0079e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  007a6	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _H$[ebp], xmm0

; 4569 :                 if (H < 0.0f)

  007ae	0f 57 c0	 xorps	 xmm0, xmm0
  007b1	0f 2f 85 b4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _H$[ebp]
  007b8	76 18		 jbe	 SHORT $LN22@ColorPicke

; 4570 :                     H += 1.0f;

  007ba	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  007c2	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  007ca	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _H$[ebp], xmm0
$LN22@ColorPicke:

; 4571 :                 value_changed = value_changed_h = true;

  007d2	c6 85 63 fe ff
	ff 01		 mov	 BYTE PTR _value_changed_h$[ebp], 1
  007d9	8a 85 63 fe ff
	ff		 mov	 al, BYTE PTR _value_changed_h$[ebp]
  007df	88 85 6f fe ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al
$LN21@ColorPicke:

; 4572 :             }
; 4573 :             float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);

  007e5	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  007ed	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  007f4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  007fc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  00804	51		 push	 ecx
  00805	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0080a	e8 00 00 00 00	 call	 ?ImCos@@YAMM@Z		; ImCos
  0080f	83 c4 04	 add	 esp, 4
  00812	d9 9d 1c fe ff
	ff		 fstp	 DWORD PTR _cos_hue_angle$69[ebp]

; 4574 :             float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);

  00818	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  00820	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00827	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0082f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  00837	51		 push	 ecx
  00838	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0083d	e8 00 00 00 00	 call	 ?ImSin@@YAMM@Z		; ImSin
  00842	83 c4 04	 add	 esp, 4
  00845	d9 9d 10 fe ff
	ff		 fstp	 DWORD PTR _sin_hue_angle$68[ebp]

; 4575 :             if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))

  0084b	51		 push	 ecx
  0084c	f3 0f 10 85 10
	fe ff ff	 movss	 xmm0, DWORD PTR _sin_hue_angle$68[ebp]
  00854	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00859	51		 push	 ecx
  0085a	f3 0f 10 85 1c
	fe ff ff	 movss	 xmm0, DWORD PTR _cos_hue_angle$69[ebp]
  00862	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00867	8d 85 44 fe ff
	ff		 lea	 eax, DWORD PTR _initial_off$72[ebp]
  0086d	50		 push	 eax
  0086e	8d 8d 50 f8 ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  00874	51		 push	 ecx
  00875	e8 00 00 00 00	 call	 ?ImRotate@@YA?AUImVec2@@ABU1@MM@Z ; ImRotate
  0087a	83 c4 10	 add	 esp, 16			; 00000010H
  0087d	50		 push	 eax
  0087e	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR _triangle_pc$[ebp]
  00884	52		 push	 edx
  00885	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _triangle_pb$[ebp]
  0088b	50		 push	 eax
  0088c	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _triangle_pa$[ebp]
  00892	51		 push	 ecx
  00893	e8 00 00 00 00	 call	 ?ImTriangleContainsPoint@@YA_NABUImVec2@@000@Z ; ImTriangleContainsPoint
  00898	83 c4 10	 add	 esp, 16			; 00000010H
  0089b	0f b6 d0	 movzx	 edx, al
  0089e	85 d2		 test	 edx, edx
  008a0	0f 84 65 01 00
	00		 je	 $LN23@ColorPicke

; 4576 :             {
; 4577 :                 // Interacting with SV triangle
; 4578 :                 ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);

  008a6	51		 push	 ecx
  008a7	f3 0f 10 85 10
	fe ff ff	 movss	 xmm0, DWORD PTR _sin_hue_angle$68[ebp]
  008af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008b4	51		 push	 ecx
  008b5	f3 0f 10 85 1c
	fe ff ff	 movss	 xmm0, DWORD PTR _cos_hue_angle$69[ebp]
  008bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c2	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _current_off$71[ebp]
  008c8	50		 push	 eax
  008c9	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _current_off_unrotated$67[ebp]
  008cf	51		 push	 ecx
  008d0	e8 00 00 00 00	 call	 ?ImRotate@@YA?AUImVec2@@ABU1@MM@Z ; ImRotate
  008d5	83 c4 10	 add	 esp, 16			; 00000010H

; 4579 :                 if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))

  008d8	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _current_off_unrotated$67[ebp]
  008de	50		 push	 eax
  008df	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _triangle_pc$[ebp]
  008e5	51		 push	 ecx
  008e6	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _triangle_pb$[ebp]
  008ec	52		 push	 edx
  008ed	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _triangle_pa$[ebp]
  008f3	50		 push	 eax
  008f4	e8 00 00 00 00	 call	 ?ImTriangleContainsPoint@@YA_NABUImVec2@@000@Z ; ImTriangleContainsPoint
  008f9	83 c4 10	 add	 esp, 16			; 00000010H
  008fc	0f b6 c8	 movzx	 ecx, al
  008ff	85 c9		 test	 ecx, ecx
  00901	75 3c		 jne	 SHORT $LN24@ColorPicke

; 4580 :                     current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);

  00903	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _current_off_unrotated$67[ebp]
  00909	50		 push	 eax
  0090a	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _triangle_pc$[ebp]
  00910	51		 push	 ecx
  00911	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _triangle_pb$[ebp]
  00917	52		 push	 edx
  00918	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _triangle_pa$[ebp]
  0091e	50		 push	 eax
  0091f	8d 8d 40 f8 ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00925	51		 push	 ecx
  00926	e8 00 00 00 00	 call	 ?ImTriangleClosestPoint@@YA?AUImVec2@@ABU1@000@Z ; ImTriangleClosestPoint
  0092b	83 c4 14	 add	 esp, 20			; 00000014H
  0092e	8b 10		 mov	 edx, DWORD PTR [eax]
  00930	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00933	89 95 00 fe ff
	ff		 mov	 DWORD PTR _current_off_unrotated$67[ebp], edx
  00939	89 85 04 fe ff
	ff		 mov	 DWORD PTR _current_off_unrotated$67[ebp+4], eax
$LN24@ColorPicke:

; 4581 :                 float uu, vv, ww;
; 4582 :                 ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);

  0093f	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _ww$64[ebp]
  00945	50		 push	 eax
  00946	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _vv$65[ebp]
  0094c	51		 push	 ecx
  0094d	8d 95 f4 fd ff
	ff		 lea	 edx, DWORD PTR _uu$66[ebp]
  00953	52		 push	 edx
  00954	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _current_off_unrotated$67[ebp]
  0095a	50		 push	 eax
  0095b	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _triangle_pc$[ebp]
  00961	51		 push	 ecx
  00962	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _triangle_pb$[ebp]
  00968	52		 push	 edx
  00969	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _triangle_pa$[ebp]
  0096f	50		 push	 eax
  00970	e8 00 00 00 00	 call	 ?ImTriangleBarycentricCoords@@YAXABUImVec2@@000AAM11@Z ; ImTriangleBarycentricCoords
  00975	83 c4 1c	 add	 esp, 28			; 0000001cH

; 4583 :                 V = ImClamp(1.0f - vv, 0.0001f, 1.0f);

  00978	51		 push	 ecx
  00979	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00981	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00986	51		 push	 ecx
  00987	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  0098f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00994	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0099c	f3 0f 5c 85 e8
	fd ff ff	 subss	 xmm0, DWORD PTR _vv$65[ebp]
  009a4	51		 push	 ecx
  009a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009aa	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  009af	83 c4 0c	 add	 esp, 12			; 0000000cH
  009b2	d9 9d 9c fe ff
	ff		 fstp	 DWORD PTR _V$[ebp]

; 4584 :                 S = ImClamp(uu / V, 0.0001f, 1.0f);

  009b8	51		 push	 ecx
  009b9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009c6	51		 push	 ecx
  009c7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  009cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009d4	f3 0f 10 85 f4
	fd ff ff	 movss	 xmm0, DWORD PTR _uu$66[ebp]
  009dc	f3 0f 5e 85 9c
	fe ff ff	 divss	 xmm0, DWORD PTR _V$[ebp]
  009e4	51		 push	 ecx
  009e5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009ea	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  009ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  009f2	d9 9d a8 fe ff
	ff		 fstp	 DWORD PTR _S$[ebp]

; 4585 :                 value_changed = value_changed_sv = true;

  009f8	c6 85 57 fe ff
	ff 01		 mov	 BYTE PTR _value_changed_sv$[ebp], 1
  009ff	8a 85 57 fe ff
	ff		 mov	 al, BYTE PTR _value_changed_sv$[ebp]
  00a05	88 85 6f fe ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al
$LN23@ColorPicke:

; 4586 :             }
; 4587 :         }
; 4588 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

  00a0b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00a0e	83 e0 08	 and	 eax, 8
  00a11	75 0f		 jne	 SHORT $LN25@ColorPicke

; 4589 :             OpenPopupOnItemClick("context");

  00a13	6a 01		 push	 1
  00a15	68 00 00 00 00	 push	 OFFSET ??_C@_07JKKCBBMM@context@
  00a1a	e8 00 00 00 00	 call	 ?OpenPopupOnItemClick@ImGui@@YA_NPBDH@Z ; ImGui::OpenPopupOnItemClick
  00a1f	83 c4 08	 add	 esp, 8
$LN25@ColorPicke:

; 4590 :     }

  00a22	e9 be 01 00 00	 jmp	 $LN29@ColorPicke
$LN18@ColorPicke:

; 4591 :     else if (flags & ImGuiColorEditFlags_PickerHueBar)

  00a27	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00a2a	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00a2f	0f 84 b0 01 00
	00		 je	 $LN29@ColorPicke

; 4592 :     {
; 4593 :         // SV rectangle logic
; 4594 :         InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));

  00a35	51		 push	 ecx
  00a36	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  00a3e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a43	51		 push	 ecx
  00a44	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  00a4c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a51	8d 8d 30 f8 ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00a57	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00a5c	50		 push	 eax
  00a5d	68 00 00 00 00	 push	 OFFSET ??_C@_02CPGMCOJE@sv@
  00a62	e8 00 00 00 00	 call	 ?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::InvisibleButton
  00a67	83 c4 08	 add	 esp, 8

; 4595 :         if (IsItemActive())

  00a6a	e8 00 00 00 00	 call	 ?IsItemActive@ImGui@@YA_NXZ ; ImGui::IsItemActive
  00a6f	0f b6 c0	 movzx	 eax, al
  00a72	85 c0		 test	 eax, eax
  00a74	0f 84 9b 00 00
	00		 je	 $LN27@ColorPicke

; 4596 :         {
; 4597 :             S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));

  00a7a	8b 45 c4	 mov	 eax, DWORD PTR _io$[ebp]
  00a7d	f3 0f 10 80 e0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+224]
  00a85	f3 0f 5c 45 90	 subss	 xmm0, DWORD PTR _picker_pos$[ebp]
  00a8a	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _sv_picker_size$[ebp]
  00a92	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  00a9a	f3 0f 5e c1	 divss	 xmm0, xmm1
  00a9e	51		 push	 ecx
  00a9f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aa4	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00aa9	83 c4 04	 add	 esp, 4
  00aac	d9 9d a8 fe ff
	ff		 fstp	 DWORD PTR _S$[ebp]

; 4598 :             V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));

  00ab2	8b 45 c4	 mov	 eax, DWORD PTR _io$[ebp]
  00ab5	f3 0f 10 80 e4
	00 00 00	 movss	 xmm0, DWORD PTR [eax+228]
  00abd	f3 0f 5c 45 94	 subss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  00ac2	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _sv_picker_size$[ebp]
  00aca	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  00ad2	f3 0f 5e c1	 divss	 xmm0, xmm1
  00ad6	51		 push	 ecx
  00ad7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00adc	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00ae1	83 c4 04	 add	 esp, 4
  00ae4	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv1689[ebp]
  00aea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00af2	f3 0f 5c 85 70
	f6 ff ff	 subss	 xmm0, DWORD PTR tv1689[ebp]
  00afa	f3 0f 11 85 9c
	fe ff ff	 movss	 DWORD PTR _V$[ebp], xmm0

; 4599 :             value_changed = value_changed_sv = true;

  00b02	c6 85 57 fe ff
	ff 01		 mov	 BYTE PTR _value_changed_sv$[ebp], 1
  00b09	8a 85 57 fe ff
	ff		 mov	 al, BYTE PTR _value_changed_sv$[ebp]
  00b0f	88 85 6f fe ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al
$LN27@ColorPicke:

; 4600 :         }
; 4601 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

  00b15	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00b18	83 e0 08	 and	 eax, 8
  00b1b	75 0f		 jne	 SHORT $LN28@ColorPicke

; 4602 :             OpenPopupOnItemClick("context");

  00b1d	6a 01		 push	 1
  00b1f	68 00 00 00 00	 push	 OFFSET ??_C@_07JKKCBBMM@context@
  00b24	e8 00 00 00 00	 call	 ?OpenPopupOnItemClick@ImGui@@YA_NPBDH@Z ; ImGui::OpenPopupOnItemClick
  00b29	83 c4 08	 add	 esp, 8
$LN28@ColorPicke:

; 4603 : 
; 4604 :         // Hue bar logic
; 4605 :         SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));

  00b2c	51		 push	 ecx
  00b2d	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  00b32	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b37	51		 push	 ecx
  00b38	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  00b40	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b45	8d 8d 20 f8 ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  00b4b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00b50	50		 push	 eax
  00b51	e8 00 00 00 00	 call	 ?SetCursorScreenPos@ImGui@@YAXABUImVec2@@@Z ; ImGui::SetCursorScreenPos
  00b56	83 c4 04	 add	 esp, 4

; 4606 :         InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));

  00b59	51		 push	 ecx
  00b5a	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  00b62	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b67	51		 push	 ecx
  00b68	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_width$[ebp]
  00b70	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b75	8d 8d 10 f8 ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  00b7b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00b80	50		 push	 eax
  00b81	68 00 00 00 00	 push	 OFFSET ??_C@_03GKJJMKFG@hue@
  00b86	e8 00 00 00 00	 call	 ?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::InvisibleButton
  00b8b	83 c4 08	 add	 esp, 8

; 4607 :         if (IsItemActive())

  00b8e	e8 00 00 00 00	 call	 ?IsItemActive@ImGui@@YA_NXZ ; ImGui::IsItemActive
  00b93	0f b6 c0	 movzx	 eax, al
  00b96	85 c0		 test	 eax, eax
  00b98	74 4b		 je	 SHORT $LN29@ColorPicke

; 4608 :         {
; 4609 :             H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));

  00b9a	8b 45 c4	 mov	 eax, DWORD PTR _io$[ebp]
  00b9d	f3 0f 10 80 e4
	00 00 00	 movss	 xmm0, DWORD PTR [eax+228]
  00ba5	f3 0f 5c 45 94	 subss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  00baa	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _sv_picker_size$[ebp]
  00bb2	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  00bba	f3 0f 5e c1	 divss	 xmm0, xmm1
  00bbe	51		 push	 ecx
  00bbf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bc4	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00bc9	83 c4 04	 add	 esp, 4
  00bcc	d9 9d b4 fe ff
	ff		 fstp	 DWORD PTR _H$[ebp]

; 4610 :             value_changed = value_changed_h = true;

  00bd2	c6 85 63 fe ff
	ff 01		 mov	 BYTE PTR _value_changed_h$[ebp], 1
  00bd9	8a 85 63 fe ff
	ff		 mov	 al, BYTE PTR _value_changed_h$[ebp]
  00bdf	88 85 6f fe ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al
$LN29@ColorPicke:

; 4611 :         }
; 4612 :     }
; 4613 : 
; 4614 :     // Alpha bar logic
; 4615 :     if (alpha_bar)

  00be5	0f b6 45 a3	 movzx	 eax, BYTE PTR _alpha_bar$[ebp]
  00be9	85 c0		 test	 eax, eax
  00beb	0f 84 cd 00 00
	00		 je	 $LN31@ColorPicke

; 4616 :     {
; 4617 :         SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));

  00bf1	51		 push	 ecx
  00bf2	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  00bf7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bfc	51		 push	 ecx
  00bfd	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _bar1_pos_x$[ebp]
  00c05	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c0a	8d 8d 00 f8 ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00c10	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00c15	50		 push	 eax
  00c16	e8 00 00 00 00	 call	 ?SetCursorScreenPos@ImGui@@YAXABUImVec2@@@Z ; ImGui::SetCursorScreenPos
  00c1b	83 c4 04	 add	 esp, 4

; 4618 :         InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));

  00c1e	51		 push	 ecx
  00c1f	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  00c27	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c2c	51		 push	 ecx
  00c2d	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_width$[ebp]
  00c35	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c3a	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  00c40	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00c45	50		 push	 eax
  00c46	68 00 00 00 00	 push	 OFFSET ??_C@_05IAEKHIAN@alpha@
  00c4b	e8 00 00 00 00	 call	 ?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::InvisibleButton
  00c50	83 c4 08	 add	 esp, 8

; 4619 :         if (IsItemActive())

  00c53	e8 00 00 00 00	 call	 ?IsItemActive@ImGui@@YA_NXZ ; ImGui::IsItemActive
  00c58	0f b6 c0	 movzx	 eax, al
  00c5b	85 c0		 test	 eax, eax
  00c5d	74 5f		 je	 SHORT $LN31@ColorPicke

; 4620 :         {
; 4621 :             col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));

  00c5f	8b 45 c4	 mov	 eax, DWORD PTR _io$[ebp]
  00c62	f3 0f 10 80 e4
	00 00 00	 movss	 xmm0, DWORD PTR [eax+228]
  00c6a	f3 0f 5c 45 94	 subss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  00c6f	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _sv_picker_size$[ebp]
  00c77	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  00c7f	f3 0f 5e c1	 divss	 xmm0, xmm1
  00c83	51		 push	 ecx
  00c84	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c89	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  00c8e	83 c4 04	 add	 esp, 4
  00c91	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv1729[ebp]
  00c97	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c9f	f3 0f 5c 85 70
	f6 ff ff	 subss	 xmm0, DWORD PTR tv1729[ebp]
  00ca7	b9 04 00 00 00	 mov	 ecx, 4
  00cac	6b d1 03	 imul	 edx, ecx, 3
  00caf	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00cb2	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 4622 :             value_changed = true;

  00cb7	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN31@ColorPicke:

; 4623 :         }
; 4624 :     }
; 4625 :     PopItemFlag(); // ImGuiItemFlags_NoNav

  00cbe	e8 00 00 00 00	 call	 ?PopItemFlag@ImGui@@YAXXZ ; ImGui::PopItemFlag

; 4626 : 
; 4627 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))

  00cc3	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00cc6	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00ccb	75 24		 jne	 SHORT $LN32@ColorPicke

; 4628 :     {
; 4629 :         SameLine(0, style.ItemInnerSpacing.x);

  00ccd	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  00cd0	51		 push	 ecx
  00cd1	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00cd6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cdb	51		 push	 ecx
  00cdc	0f 57 c0	 xorps	 xmm0, xmm0
  00cdf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ce4	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00ce9	83 c4 08	 add	 esp, 8

; 4630 :         BeginGroup();

  00cec	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup
$LN32@ColorPicke:

; 4631 :     }
; 4632 : 
; 4633 :     if (!(flags & ImGuiColorEditFlags_NoLabel))

  00cf1	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00cf4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00cf9	75 5d		 jne	 SHORT $LN34@ColorPicke

; 4634 :     {
; 4635 :         const char* label_display_end = FindRenderedTextEnd(label);

  00cfb	6a 00		 push	 0
  00cfd	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00d00	50		 push	 eax
  00d01	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  00d06	83 c4 08	 add	 esp, 8
  00d09	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _label_display_end$63[ebp], eax

; 4636 :         if (label != label_display_end)

  00d0f	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00d12	3b 85 d0 fd ff
	ff		 cmp	 eax, DWORD PTR _label_display_end$63[ebp]
  00d18	74 3e		 je	 SHORT $LN34@ColorPicke

; 4637 :         {
; 4638 :             if ((flags & ImGuiColorEditFlags_NoSidePreview))

  00d1a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00d1d	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00d22	74 1f		 je	 SHORT $LN35@ColorPicke

; 4639 :                 SameLine(0, style.ItemInnerSpacing.x);

  00d24	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  00d27	51		 push	 ecx
  00d28	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00d2d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d32	51		 push	 ecx
  00d33	0f 57 c0	 xorps	 xmm0, xmm0
  00d36	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d3b	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00d40	83 c4 08	 add	 esp, 8
$LN35@ColorPicke:

; 4640 :             TextEx(label, label_display_end);

  00d43	6a 00		 push	 0
  00d45	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _label_display_end$63[ebp]
  00d4b	50		 push	 eax
  00d4c	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00d4f	51		 push	 ecx
  00d50	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  00d55	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@ColorPicke:

; 4641 :         }
; 4642 :     }
; 4643 : 
; 4644 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))

  00d58	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00d5b	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00d60	0f 85 37 02 00
	00		 jne	 $LN36@ColorPicke

; 4645 :     {
; 4646 :         PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);

  00d66	6a 01		 push	 1
  00d68	6a 10		 push	 16			; 00000010H
  00d6a	e8 00 00 00 00	 call	 ?PushItemFlag@ImGui@@YAXH_N@Z ; ImGui::PushItemFlag
  00d6f	83 c4 08	 add	 esp, 8

; 4647 :         ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

  00d72	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00d75	83 e0 02	 and	 eax, 2
  00d78	74 12		 je	 SHORT $LN82@ColorPicke
  00d7a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00d82	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv511[ebp], xmm0
  00d8a	eb 18		 jmp	 SHORT $LN83@ColorPicke
$LN82@ColorPicke:
  00d8c	b9 04 00 00 00	 mov	 ecx, 4
  00d91	6b d1 03	 imul	 edx, ecx, 3
  00d94	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00d97	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00d9c	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv511[ebp], xmm0
$LN83@ColorPicke:
  00da4	51		 push	 ecx
  00da5	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv511[ebp]
  00dad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00db2	b9 04 00 00 00	 mov	 ecx, 4
  00db7	d1 e1		 shl	 ecx, 1
  00db9	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  00dbc	51		 push	 ecx
  00dbd	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00dc2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dc7	b8 04 00 00 00	 mov	 eax, 4
  00dcc	c1 e0 00	 shl	 eax, 0
  00dcf	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00dd2	51		 push	 ecx
  00dd3	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00dd8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ddd	ba 04 00 00 00	 mov	 edx, 4
  00de2	6b c2 00	 imul	 eax, edx, 0
  00de5	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00de8	51		 push	 ecx
  00de9	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00dee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00df3	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _col_v4$62[ebp]
  00df9	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4

; 4648 :         if ((flags & ImGuiColorEditFlags_NoLabel))

  00dfe	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00e01	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00e06	74 0d		 je	 SHORT $LN37@ColorPicke

; 4649 :             Text("Current");

  00e08	68 00 00 00 00	 push	 OFFSET ??_C@_07EDIFFIJI@Current@
  00e0d	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00e12	83 c4 04	 add	 esp, 4
$LN37@ColorPicke:

; 4650 : 
; 4651 :         ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;

  00e15	c7 85 ac fd ff
	ff 40 00 0e 18	 mov	 DWORD PTR _sub_flags_to_forward$61[ebp], 403570752 ; 180e0040H

; 4652 :         ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));

  00e1f	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00e24	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00e2c	51		 push	 ecx
  00e2d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e32	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00e37	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  00e3f	51		 push	 ecx
  00e40	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e45	8d 8d e0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  00e4b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00e50	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00e53	51		 push	 ecx
  00e54	8b 10		 mov	 edx, DWORD PTR [eax]
  00e56	52		 push	 edx
  00e57	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00e5a	23 85 ac fd ff
	ff		 and	 eax, DWORD PTR _sub_flags_to_forward$61[ebp]
  00e60	50		 push	 eax
  00e61	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR _col_v4$62[ebp]
  00e67	51		 push	 ecx
  00e68	68 00 00 00 00	 push	 OFFSET ??_C@_09CDENILGE@?$CD?$CDcurrent@
  00e6d	e8 00 00 00 00	 call	 ?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
  00e72	83 c4 14	 add	 esp, 20			; 00000014H

; 4653 :         if (ref_col != NULL)

  00e75	83 7d 14 00	 cmp	 DWORD PTR _ref_col$[ebp], 0
  00e79	0f 84 14 01 00
	00		 je	 $LN39@ColorPicke

; 4654 :         {
; 4655 :             Text("Original");

  00e7f	68 00 00 00 00	 push	 OFFSET ??_C@_08DCPBJHAO@Original@
  00e84	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPBDZZ	; ImGui::Text
  00e89	83 c4 04	 add	 esp, 4

; 4656 :             ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);

  00e8c	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00e8f	83 e0 02	 and	 eax, 2
  00e92	74 12		 je	 SHORT $LN84@ColorPicke
  00e94	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e9c	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv543[ebp], xmm0
  00ea4	eb 18		 jmp	 SHORT $LN85@ColorPicke
$LN84@ColorPicke:
  00ea6	b9 04 00 00 00	 mov	 ecx, 4
  00eab	6b d1 03	 imul	 edx, ecx, 3
  00eae	8b 45 14	 mov	 eax, DWORD PTR _ref_col$[ebp]
  00eb1	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00eb6	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv543[ebp], xmm0
$LN85@ColorPicke:
  00ebe	51		 push	 ecx
  00ebf	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv543[ebp]
  00ec7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ecc	b9 04 00 00 00	 mov	 ecx, 4
  00ed1	d1 e1		 shl	 ecx, 1
  00ed3	8b 55 14	 mov	 edx, DWORD PTR _ref_col$[ebp]
  00ed6	51		 push	 ecx
  00ed7	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00edc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ee1	b8 04 00 00 00	 mov	 eax, 4
  00ee6	c1 e0 00	 shl	 eax, 0
  00ee9	8b 4d 14	 mov	 ecx, DWORD PTR _ref_col$[ebp]
  00eec	51		 push	 ecx
  00eed	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00ef2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ef7	ba 04 00 00 00	 mov	 edx, 4
  00efc	6b c2 00	 imul	 eax, edx, 0
  00eff	8b 4d 14	 mov	 ecx, DWORD PTR _ref_col$[ebp]
  00f02	51		 push	 ecx
  00f03	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00f08	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f0d	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR _ref_col_v4$60[ebp]
  00f13	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4

; 4657 :             if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))

  00f18	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00f1d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00f25	51		 push	 ecx
  00f26	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f2b	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00f30	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  00f38	51		 push	 ecx
  00f39	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f3e	8d 8d d0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00f44	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00f49	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f4c	51		 push	 ecx
  00f4d	8b 10		 mov	 edx, DWORD PTR [eax]
  00f4f	52		 push	 edx
  00f50	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00f53	23 85 ac fd ff
	ff		 and	 eax, DWORD PTR _sub_flags_to_forward$61[ebp]
  00f59	50		 push	 eax
  00f5a	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR _ref_col_v4$60[ebp]
  00f60	51		 push	 ecx
  00f61	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@
  00f66	e8 00 00 00 00	 call	 ?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
  00f6b	83 c4 14	 add	 esp, 20			; 00000014H
  00f6e	0f b6 d0	 movzx	 edx, al
  00f71	85 d2		 test	 edx, edx
  00f73	74 1e		 je	 SHORT $LN39@ColorPicke

; 4658 :             {
; 4659 :                 memcpy(col, ref_col, components * sizeof(float));

  00f75	8b 45 ac	 mov	 eax, DWORD PTR _components$[ebp]
  00f78	c1 e0 02	 shl	 eax, 2
  00f7b	50		 push	 eax
  00f7c	8b 4d 14	 mov	 ecx, DWORD PTR _ref_col$[ebp]
  00f7f	51		 push	 ecx
  00f80	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  00f83	52		 push	 edx
  00f84	e8 00 00 00 00	 call	 _memcpy
  00f89	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4660 :                 value_changed = true;

  00f8c	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN39@ColorPicke:

; 4661 :             }
; 4662 :         }
; 4663 :         PopItemFlag();

  00f93	e8 00 00 00 00	 call	 ?PopItemFlag@ImGui@@YAXXZ ; ImGui::PopItemFlag

; 4664 :         EndGroup();

  00f98	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup
$LN36@ColorPicke:

; 4665 :     }
; 4666 : 
; 4667 :     // Convert back color to RGB
; 4668 :     if (value_changed_h || value_changed_sv)

  00f9d	0f b6 85 63 fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed_h$[ebp]
  00fa4	85 c0		 test	 eax, eax
  00fa6	75 0f		 jne	 SHORT $LN41@ColorPicke
  00fa8	0f b6 85 57 fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed_sv$[ebp]
  00faf	85 c0		 test	 eax, eax
  00fb1	0f 84 82 01 00
	00		 je	 $LN44@ColorPicke
$LN41@ColorPicke:

; 4669 :     {
; 4670 :         if (flags & ImGuiColorEditFlags_InputRGB)

  00fb7	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00fba	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00fbf	0f 84 23 01 00
	00		 je	 $LN42@ColorPicke

; 4671 :         {
; 4672 :             ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);

  00fc5	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _V$[ebp]
  00fcd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00fd4	76 12		 jbe	 SHORT $LN86@ColorPicke
  00fd6	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _V$[ebp]
  00fde	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv619[ebp], xmm0
  00fe6	eb 10		 jmp	 SHORT $LN87@ColorPicke
$LN86@ColorPicke:
  00fe8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@358637bd
  00ff0	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv619[ebp], xmm0
$LN87@ColorPicke:
  00ff8	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  01000	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  01007	76 12		 jbe	 SHORT $LN88@ColorPicke
  01009	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  01011	f3 0f 11 85 6c
	f6 ff ff	 movss	 DWORD PTR tv622[ebp], xmm0
  01019	eb 10		 jmp	 SHORT $LN89@ColorPicke
$LN88@ColorPicke:
  0101b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3727c5ac
  01023	f3 0f 11 85 6c
	f6 ff ff	 movss	 DWORD PTR tv622[ebp], xmm0
$LN89@ColorPicke:
  0102b	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  01033	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0103a	72 1a		 jb	 SHORT $LN90@ColorPicke
  0103c	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  01044	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3727c5ac
  0104c	f3 0f 11 85 68
	f6 ff ff	 movss	 DWORD PTR tv626[ebp], xmm0
  01054	eb 10		 jmp	 SHORT $LN91@ColorPicke
$LN90@ColorPicke:
  01056	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  0105e	f3 0f 11 85 68
	f6 ff ff	 movss	 DWORD PTR tv626[ebp], xmm0
$LN91@ColorPicke:
  01066	b8 04 00 00 00	 mov	 eax, 4
  0106b	d1 e0		 shl	 eax, 1
  0106d	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  01070	50		 push	 eax
  01071	b9 04 00 00 00	 mov	 ecx, 4
  01076	c1 e1 00	 shl	 ecx, 0
  01079	03 4d 0c	 add	 ecx, DWORD PTR _col$[ebp]
  0107c	51		 push	 ecx
  0107d	ba 04 00 00 00	 mov	 edx, 4
  01082	6b c2 00	 imul	 eax, edx, 0
  01085	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  01088	50		 push	 eax
  01089	51		 push	 ecx
  0108a	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv619[ebp]
  01092	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01097	51		 push	 ecx
  01098	f3 0f 10 85 6c
	f6 ff ff	 movss	 xmm0, DWORD PTR tv622[ebp]
  010a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010a5	51		 push	 ecx
  010a6	f3 0f 10 85 68
	f6 ff ff	 movss	 xmm0, DWORD PTR tv626[ebp]
  010ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010b3	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  010b8	83 c4 18	 add	 esp, 24			; 00000018H

; 4673 :             g.ColorEditLastHue = H;

  010bb	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  010be	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  010c6	f3 0f 11 80 d8
	2c 00 00	 movss	 DWORD PTR [eax+11480], xmm0

; 4674 :             memcpy(g.ColorEditLastColor, col, sizeof(float) * 3);

  010ce	6a 0c		 push	 12			; 0000000cH
  010d0	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  010d3	50		 push	 eax
  010d4	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  010d7	81 c1 dc 2c 00
	00		 add	 ecx, 11484		; 00002cdcH
  010dd	51		 push	 ecx
  010de	e8 00 00 00 00	 call	 _memcpy
  010e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4675 :         }

  010e6	eb 51		 jmp	 SHORT $LN44@ColorPicke
$LN42@ColorPicke:

; 4676 :         else if (flags & ImGuiColorEditFlags_InputHSV)

  010e8	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  010eb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  010f0	74 47		 je	 SHORT $LN44@ColorPicke

; 4677 :         {
; 4678 :             col[0] = H;

  010f2	b8 04 00 00 00	 mov	 eax, 4
  010f7	6b c8 00	 imul	 ecx, eax, 0
  010fa	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  010fd	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  01105	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0

; 4679 :             col[1] = S;

  0110a	b8 04 00 00 00	 mov	 eax, 4
  0110f	c1 e0 00	 shl	 eax, 0
  01112	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  01115	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  0111d	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 4680 :             col[2] = V;

  01122	b8 04 00 00 00	 mov	 eax, 4
  01127	d1 e0		 shl	 eax, 1
  01129	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  0112c	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _V$[ebp]
  01134	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
$LN44@ColorPicke:

; 4681 :         }
; 4682 :     }
; 4683 : 
; 4684 :     // R,G,B and H,S,V slider color editor
; 4685 :     bool value_changed_fix_hue_wrap = false;

  01139	c6 85 8b fd ff
	ff 00		 mov	 BYTE PTR _value_changed_fix_hue_wrap$[ebp], 0

; 4686 :     if ((flags & ImGuiColorEditFlags_NoInputs) == 0)

  01140	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  01143	83 e0 20	 and	 eax, 32			; 00000020H
  01146	0f 85 89 01 00
	00		 jne	 $LN45@ColorPicke

; 4687 :     {
; 4688 :         PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);

  0114c	0f b6 45 a3	 movzx	 eax, BYTE PTR _alpha_bar$[ebp]
  01150	85 c0		 test	 eax, eax
  01152	74 12		 je	 SHORT $LN92@ColorPicke
  01154	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _bar1_pos_x$[ebp]
  0115c	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv645[ebp], xmm0
  01164	eb 10		 jmp	 SHORT $LN93@ColorPicke
$LN92@ColorPicke:
  01166	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  0116e	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv645[ebp], xmm0
$LN93@ColorPicke:
  01176	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv645[ebp]
  0117e	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _bars_width$[ebp]
  01186	f3 0f 5c 45 90	 subss	 xmm0, DWORD PTR _picker_pos$[ebp]
  0118b	51		 push	 ecx
  0118c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01191	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth
  01196	83 c4 04	 add	 esp, 4

; 4689 :         ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;

  01199	c7 85 7c fd ff
	ff 1a 00 8e 19	 mov	 DWORD PTR _sub_flags_to_forward$59[ebp], 428736538 ; 198e001aH

; 4690 :         ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;

  011a3	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  011a6	23 85 7c fd ff
	ff		 and	 eax, DWORD PTR _sub_flags_to_forward$59[ebp]
  011ac	83 c8 04	 or	 eax, 4
  011af	89 85 70 fd ff
	ff		 mov	 DWORD PTR _sub_flags$58[ebp], eax

; 4691 :         if (flags & ImGuiColorEditFlags_DisplayRGB || (flags & ImGuiColorEditFlags__DisplayMask) == 0)

  011b5	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  011b8	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  011bd	75 0a		 jne	 SHORT $LN47@ColorPicke
  011bf	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  011c2	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  011c7	75 67		 jne	 SHORT $LN48@ColorPicke
$LN47@ColorPicke:

; 4692 :             if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_DisplayRGB))

  011c9	8b 85 70 fd ff
	ff		 mov	 eax, DWORD PTR _sub_flags$58[ebp]
  011cf	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  011d4	50		 push	 eax
  011d5	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  011d8	51		 push	 ecx
  011d9	68 00 00 00 00	 push	 OFFSET ??_C@_05JCABMAIH@?$CD?$CDrgb@
  011de	e8 00 00 00 00	 call	 ?ColorEdit4@ImGui@@YA_NPBDQAMH@Z ; ImGui::ColorEdit4
  011e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  011e6	0f b6 d0	 movzx	 edx, al
  011e9	85 d2		 test	 edx, edx
  011eb	74 43		 je	 SHORT $LN48@ColorPicke

; 4693 :             {
; 4694 :                 // FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
; 4695 :                 // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
; 4696 :                 value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);

  011ed	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  011f0	83 b8 e4 19 00
	00 00		 cmp	 DWORD PTR [eax+6628], 0
  011f7	74 1a		 je	 SHORT $LN94@ColorPicke
  011f9	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  011fc	0f b6 91 f1 19
	00 00		 movzx	 edx, BYTE PTR [ecx+6641]
  01203	85 d2		 test	 edx, edx
  01205	75 0c		 jne	 SHORT $LN94@ColorPicke
  01207	c7 85 70 f6 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv667[ebp], 1
  01211	eb 0a		 jmp	 SHORT $LN95@ColorPicke
$LN94@ColorPicke:
  01213	c7 85 70 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv667[ebp], 0
$LN95@ColorPicke:
  0121d	8a 85 70 f6 ff
	ff		 mov	 al, BYTE PTR tv667[ebp]
  01223	88 85 8b fd ff
	ff		 mov	 BYTE PTR _value_changed_fix_hue_wrap$[ebp], al

; 4697 :                 value_changed = true;

  01229	c6 85 6f fe ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1
$LN48@ColorPicke:

; 4698 :             }
; 4699 :         if (flags & ImGuiColorEditFlags_DisplayHSV || (flags & ImGuiColorEditFlags__DisplayMask) == 0)

  01230	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  01233	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01238	75 0a		 jne	 SHORT $LN50@ColorPicke
  0123a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0123d	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  01242	75 3c		 jne	 SHORT $LN49@ColorPicke
$LN50@ColorPicke:

; 4700 :             value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);

  01244	0f b6 85 6f fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  0124b	8b 8d 70 fd ff
	ff		 mov	 ecx, DWORD PTR _sub_flags$58[ebp]
  01251	81 c9 00 00 20
	00		 or	 ecx, 2097152		; 00200000H
  01257	51		 push	 ecx
  01258	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  0125b	52		 push	 edx
  0125c	68 00 00 00 00	 push	 OFFSET ??_C@_05JICEKLIF@?$CD?$CDhsv@
  01261	89 85 70 f6 ff
	ff		 mov	 DWORD PTR tv2454[ebp], eax
  01267	e8 00 00 00 00	 call	 ?ColorEdit4@ImGui@@YA_NPBDQAMH@Z ; ImGui::ColorEdit4
  0126c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0126f	0f b6 c0	 movzx	 eax, al
  01272	8b 8d 70 f6 ff
	ff		 mov	 ecx, DWORD PTR tv2454[ebp]
  01278	0b c8		 or	 ecx, eax
  0127a	88 8d 6f fe ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], cl
$LN49@ColorPicke:

; 4701 :         if (flags & ImGuiColorEditFlags_DisplayHex || (flags & ImGuiColorEditFlags__DisplayMask) == 0)

  01280	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  01283	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  01288	75 0a		 jne	 SHORT $LN52@ColorPicke
  0128a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0128d	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  01292	75 3c		 jne	 SHORT $LN51@ColorPicke
$LN52@ColorPicke:

; 4702 :             value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_DisplayHex);

  01294	0f b6 85 6f fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  0129b	8b 8d 70 fd ff
	ff		 mov	 ecx, DWORD PTR _sub_flags$58[ebp]
  012a1	81 c9 00 00 40
	00		 or	 ecx, 4194304		; 00400000H
  012a7	51		 push	 ecx
  012a8	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  012ab	52		 push	 edx
  012ac	68 00 00 00 00	 push	 OFFSET ??_C@_05BOAMFJMJ@?$CD?$CDhex@
  012b1	89 85 70 f6 ff
	ff		 mov	 DWORD PTR tv2456[ebp], eax
  012b7	e8 00 00 00 00	 call	 ?ColorEdit4@ImGui@@YA_NPBDQAMH@Z ; ImGui::ColorEdit4
  012bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  012bf	0f b6 c0	 movzx	 eax, al
  012c2	8b 8d 70 f6 ff
	ff		 mov	 ecx, DWORD PTR tv2456[ebp]
  012c8	0b c8		 or	 ecx, eax
  012ca	88 8d 6f fe ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], cl
$LN51@ColorPicke:

; 4703 :         PopItemWidth();

  012d0	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth
$LN45@ColorPicke:

; 4704 :     }
; 4705 : 
; 4706 :     // Try to cancel hue wrap (after ColorEdit4 call), if any
; 4707 :     if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))

  012d5	0f b6 85 8b fd
	ff ff		 movzx	 eax, BYTE PTR _value_changed_fix_hue_wrap$[ebp]
  012dc	85 c0		 test	 eax, eax
  012de	0f 84 e5 01 00
	00		 je	 $LN57@ColorPicke
  012e4	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  012e7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  012ec	0f 84 d7 01 00
	00		 je	 $LN57@ColorPicke

; 4708 :     {
; 4709 :         float new_H, new_S, new_V;
; 4710 :         ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);

  012f2	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _new_V$55[ebp]
  012f8	50		 push	 eax
  012f9	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR _new_S$56[ebp]
  012ff	51		 push	 ecx
  01300	8d 95 64 fd ff
	ff		 lea	 edx, DWORD PTR _new_H$57[ebp]
  01306	52		 push	 edx
  01307	b8 04 00 00 00	 mov	 eax, 4
  0130c	d1 e0		 shl	 eax, 1
  0130e	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  01311	51		 push	 ecx
  01312	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  01317	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0131c	ba 04 00 00 00	 mov	 edx, 4
  01321	c1 e2 00	 shl	 edx, 0
  01324	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  01327	51		 push	 ecx
  01328	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  0132d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01332	b9 04 00 00 00	 mov	 ecx, 4
  01337	6b d1 00	 imul	 edx, ecx, 0
  0133a	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0133d	51		 push	 ecx
  0133e	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  01343	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01348	e8 00 00 00 00	 call	 ?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertRGBtoHSV
  0134d	83 c4 18	 add	 esp, 24			; 00000018H

; 4711 :         if (new_H <= 0 && H > 0)

  01350	0f 57 c0	 xorps	 xmm0, xmm0
  01353	0f 2f 85 64 fd
	ff ff		 comiss	 xmm0, DWORD PTR _new_H$57[ebp]
  0135a	0f 82 69 01 00
	00		 jb	 $LN57@ColorPicke
  01360	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  01368	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0136f	0f 86 54 01 00
	00		 jbe	 $LN57@ColorPicke

; 4712 :         {
; 4713 :             if (new_V <= 0 && V != new_V)

  01375	0f 57 c0	 xorps	 xmm0, xmm0
  01378	0f 2f 85 4c fd
	ff ff		 comiss	 xmm0, DWORD PTR _new_V$55[ebp]
  0137f	0f 82 a9 00 00
	00		 jb	 $LN55@ColorPicke
  01385	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _V$[ebp]
  0138d	0f 2e 85 4c fd
	ff ff		 ucomiss xmm0, DWORD PTR _new_V$55[ebp]
  01394	9f		 lahf
  01395	f6 c4 44	 test	 ah, 68			; 00000044H
  01398	0f 8b 90 00 00
	00		 jnp	 $LN55@ColorPicke

; 4714 :                 ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);

  0139e	0f 57 c0	 xorps	 xmm0, xmm0
  013a1	0f 2f 85 4c fd
	ff ff		 comiss	 xmm0, DWORD PTR _new_V$55[ebp]
  013a8	72 1a		 jb	 SHORT $LN96@ColorPicke
  013aa	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _V$[ebp]
  013b2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  013ba	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv726[ebp], xmm0
  013c2	eb 10		 jmp	 SHORT $LN97@ColorPicke
$LN96@ColorPicke:
  013c4	f3 0f 10 85 4c
	fd ff ff	 movss	 xmm0, DWORD PTR _new_V$55[ebp]
  013cc	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv726[ebp], xmm0
$LN97@ColorPicke:
  013d4	b8 04 00 00 00	 mov	 eax, 4
  013d9	d1 e0		 shl	 eax, 1
  013db	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  013de	50		 push	 eax
  013df	b9 04 00 00 00	 mov	 ecx, 4
  013e4	c1 e1 00	 shl	 ecx, 0
  013e7	03 4d 0c	 add	 ecx, DWORD PTR _col$[ebp]
  013ea	51		 push	 ecx
  013eb	ba 04 00 00 00	 mov	 edx, 4
  013f0	6b c2 00	 imul	 eax, edx, 0
  013f3	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  013f6	50		 push	 eax
  013f7	51		 push	 ecx
  013f8	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv726[ebp]
  01400	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01405	51		 push	 ecx
  01406	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  0140e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01413	51		 push	 ecx
  01414	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  0141c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01421	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  01426	83 c4 18	 add	 esp, 24			; 00000018H
  01429	e9 9b 00 00 00	 jmp	 $LN57@ColorPicke
$LN55@ColorPicke:

; 4715 :             else if (new_S <= 0)

  0142e	0f 57 c0	 xorps	 xmm0, xmm0
  01431	0f 2f 85 58 fd
	ff ff		 comiss	 xmm0, DWORD PTR _new_S$56[ebp]
  01438	0f 82 8b 00 00
	00		 jb	 $LN57@ColorPicke

; 4716 :                 ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);

  0143e	0f 57 c0	 xorps	 xmm0, xmm0
  01441	0f 2f 85 58 fd
	ff ff		 comiss	 xmm0, DWORD PTR _new_S$56[ebp]
  01448	72 1a		 jb	 SHORT $LN98@ColorPicke
  0144a	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  01452	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0145a	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv743[ebp], xmm0
  01462	eb 10		 jmp	 SHORT $LN99@ColorPicke
$LN98@ColorPicke:
  01464	f3 0f 10 85 58
	fd ff ff	 movss	 xmm0, DWORD PTR _new_S$56[ebp]
  0146c	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv743[ebp], xmm0
$LN99@ColorPicke:
  01474	b8 04 00 00 00	 mov	 eax, 4
  01479	d1 e0		 shl	 eax, 1
  0147b	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  0147e	50		 push	 eax
  0147f	b9 04 00 00 00	 mov	 ecx, 4
  01484	c1 e1 00	 shl	 ecx, 0
  01487	03 4d 0c	 add	 ecx, DWORD PTR _col$[ebp]
  0148a	51		 push	 ecx
  0148b	ba 04 00 00 00	 mov	 edx, 4
  01490	6b c2 00	 imul	 eax, edx, 0
  01493	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  01496	50		 push	 eax
  01497	51		 push	 ecx
  01498	f3 0f 10 85 4c
	fd ff ff	 movss	 xmm0, DWORD PTR _new_V$55[ebp]
  014a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014a5	51		 push	 ecx
  014a6	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv743[ebp]
  014ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014b3	51		 push	 ecx
  014b4	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  014bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014c1	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  014c6	83 c4 18	 add	 esp, 24			; 00000018H
$LN57@ColorPicke:

; 4717 :         }
; 4718 :     }
; 4719 : 
; 4720 :     if (value_changed)

  014c9	0f b6 85 6f fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  014d0	85 c0		 test	 eax, eax
  014d2	0f 84 81 01 00
	00		 je	 $LN62@ColorPicke

; 4721 :     {
; 4722 :         if (flags & ImGuiColorEditFlags_InputRGB)

  014d8	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  014db	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  014e0	0f 84 d7 00 00
	00		 je	 $LN59@ColorPicke

; 4723 :         {
; 4724 :             R = col[0];

  014e6	b8 04 00 00 00	 mov	 eax, 4
  014eb	6b c8 00	 imul	 ecx, eax, 0
  014ee	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  014f1	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  014f6	f3 0f 11 85 90
	fe ff ff	 movss	 DWORD PTR _R$[ebp], xmm0

; 4725 :             G = col[1];

  014fe	b8 04 00 00 00	 mov	 eax, 4
  01503	c1 e0 00	 shl	 eax, 0
  01506	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  01509	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0150e	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR _G$[ebp], xmm0

; 4726 :             B = col[2];

  01516	b8 04 00 00 00	 mov	 eax, 4
  0151b	d1 e0		 shl	 eax, 1
  0151d	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  01520	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  01525	f3 0f 11 85 78
	fe ff ff	 movss	 DWORD PTR _B$[ebp], xmm0

; 4727 :             ColorConvertRGBtoHSV(R, G, B, H, S, V);

  0152d	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _V$[ebp]
  01533	50		 push	 eax
  01534	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _S$[ebp]
  0153a	51		 push	 ecx
  0153b	8d 95 b4 fe ff
	ff		 lea	 edx, DWORD PTR _H$[ebp]
  01541	52		 push	 edx
  01542	51		 push	 ecx
  01543	f3 0f 10 85 78
	fe ff ff	 movss	 xmm0, DWORD PTR _B$[ebp]
  0154b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01550	51		 push	 ecx
  01551	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _G$[ebp]
  01559	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0155e	51		 push	 ecx
  0155f	f3 0f 10 85 90
	fe ff ff	 movss	 xmm0, DWORD PTR _R$[ebp]
  01567	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0156c	e8 00 00 00 00	 call	 ?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertRGBtoHSV
  01571	83 c4 18	 add	 esp, 24			; 00000018H

; 4728 :             if (S == 0 && memcmp(g.ColorEditLastColor, col, sizeof(float) * 3) == 0) // Fix local Hue as display below will use it immediately.

  01574	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  0157c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  01583	9f		 lahf
  01584	f6 c4 44	 test	 ah, 68			; 00000044H
  01587	7a 2f		 jp	 SHORT $LN61@ColorPicke
  01589	6a 0c		 push	 12			; 0000000cH
  0158b	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0158e	50		 push	 eax
  0158f	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  01592	81 c1 dc 2c 00
	00		 add	 ecx, 11484		; 00002cdcH
  01598	51		 push	 ecx
  01599	e8 00 00 00 00	 call	 _memcmp
  0159e	83 c4 0c	 add	 esp, 12			; 0000000cH
  015a1	85 c0		 test	 eax, eax
  015a3	75 13		 jne	 SHORT $LN61@ColorPicke

; 4729 :                 H = g.ColorEditLastHue;

  015a5	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  015a8	f3 0f 10 80 d8
	2c 00 00	 movss	 xmm0, DWORD PTR [eax+11480]
  015b0	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _H$[ebp], xmm0
$LN61@ColorPicke:

; 4730 :         }

  015b8	e9 9c 00 00 00	 jmp	 $LN62@ColorPicke
$LN59@ColorPicke:

; 4731 :         else if (flags & ImGuiColorEditFlags_InputHSV)

  015bd	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  015c0	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  015c5	0f 84 8e 00 00
	00		 je	 $LN62@ColorPicke

; 4732 :         {
; 4733 :             H = col[0];

  015cb	b8 04 00 00 00	 mov	 eax, 4
  015d0	6b c8 00	 imul	 ecx, eax, 0
  015d3	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  015d6	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  015db	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _H$[ebp], xmm0

; 4734 :             S = col[1];

  015e3	b8 04 00 00 00	 mov	 eax, 4
  015e8	c1 e0 00	 shl	 eax, 0
  015eb	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  015ee	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  015f3	f3 0f 11 85 a8
	fe ff ff	 movss	 DWORD PTR _S$[ebp], xmm0

; 4735 :             V = col[2];

  015fb	b8 04 00 00 00	 mov	 eax, 4
  01600	d1 e0		 shl	 eax, 1
  01602	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  01605	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0160a	f3 0f 11 85 9c
	fe ff ff	 movss	 DWORD PTR _V$[ebp], xmm0

; 4736 :             ColorConvertHSVtoRGB(H, S, V, R, G, B);

  01612	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR _B$[ebp]
  01618	50		 push	 eax
  01619	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _G$[ebp]
  0161f	51		 push	 ecx
  01620	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR _R$[ebp]
  01626	52		 push	 edx
  01627	51		 push	 ecx
  01628	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _V$[ebp]
  01630	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01635	51		 push	 ecx
  01636	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  0163e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01643	51		 push	 ecx
  01644	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  0164c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01651	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  01656	83 c4 18	 add	 esp, 24			; 00000018H
$LN62@ColorPicke:

; 4737 :         }
; 4738 :     }
; 4739 : 
; 4740 :     const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);

  01659	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0165c	51		 push	 ecx
  0165d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01661	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01666	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0166b	83 c4 04	 add	 esp, 4
  0166e	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv1975[ebp]
  01674	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv1975[ebp]
  0167c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01684	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0168c	f3 0f 2c c8	 cvttss2si ecx, xmm0
  01690	89 8d 40 fd ff
	ff		 mov	 DWORD PTR _style_alpha8$[ebp], ecx

; 4741 :     const ImU32 col_black = IM_COL32(0,0,0,style_alpha8);

  01696	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  0169c	c1 e0 18	 shl	 eax, 24			; 00000018H
  0169f	89 85 34 fd ff
	ff		 mov	 DWORD PTR _col_black$[ebp], eax

; 4742 :     const ImU32 col_white = IM_COL32(255,255,255,style_alpha8);

  016a5	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  016ab	c1 e0 18	 shl	 eax, 24			; 00000018H
  016ae	0d 00 00 ff 00	 or	 eax, 16711680		; 00ff0000H
  016b3	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  016b8	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  016bd	89 85 28 fd ff
	ff		 mov	 DWORD PTR _col_white$[ebp], eax

; 4743 :     const ImU32 col_midgrey = IM_COL32(128,128,128,style_alpha8);

  016c3	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  016c9	c1 e0 18	 shl	 eax, 24			; 00000018H
  016cc	0d 00 00 80 00	 or	 eax, 8388608		; 00800000H
  016d1	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  016d6	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  016db	89 85 1c fd ff
	ff		 mov	 DWORD PTR _col_midgrey$[ebp], eax

; 4744 :     const ImU32 col_hues[6 + 1] = { IM_COL32(255,0,0,style_alpha8), IM_COL32(255,255,0,style_alpha8), IM_COL32(0,255,0,style_alpha8), IM_COL32(0,255,255,style_alpha8), IM_COL32(0,0,255,style_alpha8), IM_COL32(255,0,255,style_alpha8), IM_COL32(255,0,0,style_alpha8) };

  016e1	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  016e7	c1 e0 18	 shl	 eax, 24			; 00000018H
  016ea	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  016ef	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _col_hues$[ebp], eax
  016f5	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  016fb	c1 e0 18	 shl	 eax, 24			; 00000018H
  016fe	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  01703	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  01708	89 85 fc fc ff
	ff		 mov	 DWORD PTR _col_hues$[ebp+4], eax
  0170e	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  01714	c1 e0 18	 shl	 eax, 24			; 00000018H
  01717	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  0171c	89 85 00 fd ff
	ff		 mov	 DWORD PTR _col_hues$[ebp+8], eax
  01722	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  01728	c1 e0 18	 shl	 eax, 24			; 00000018H
  0172b	0d 00 00 ff 00	 or	 eax, 16711680		; 00ff0000H
  01730	0d 00 ff 00 00	 or	 eax, 65280		; 0000ff00H
  01735	89 85 04 fd ff
	ff		 mov	 DWORD PTR _col_hues$[ebp+12], eax
  0173b	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  01741	c1 e0 18	 shl	 eax, 24			; 00000018H
  01744	0d 00 00 ff 00	 or	 eax, 16711680		; 00ff0000H
  01749	89 85 08 fd ff
	ff		 mov	 DWORD PTR _col_hues$[ebp+16], eax
  0174f	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  01755	c1 e0 18	 shl	 eax, 24			; 00000018H
  01758	0d 00 00 ff 00	 or	 eax, 16711680		; 00ff0000H
  0175d	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  01762	89 85 0c fd ff
	ff		 mov	 DWORD PTR _col_hues$[ebp+20], eax
  01768	8b 85 40 fd ff
	ff		 mov	 eax, DWORD PTR _style_alpha8$[ebp]
  0176e	c1 e0 18	 shl	 eax, 24			; 00000018H
  01771	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  01776	89 85 10 fd ff
	ff		 mov	 DWORD PTR _col_hues$[ebp+24], eax

; 4745 : 
; 4746 :     ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);

  0177c	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0177f	51		 push	 ecx
  01780	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01784	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01789	51		 push	 ecx
  0178a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01792	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01797	51		 push	 ecx
  01798	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  017a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  017a5	51		 push	 ecx
  017a6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  017ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  017b3	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR _hue_color_f$[ebp]
  017b9	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  017be	8d 85 e8 fc ff
	ff		 lea	 eax, DWORD PTR _hue_color_f$[ebp+8]
  017c4	50		 push	 eax
  017c5	8d 8d e4 fc ff
	ff		 lea	 ecx, DWORD PTR _hue_color_f$[ebp+4]
  017cb	51		 push	 ecx
  017cc	8d 95 e0 fc ff
	ff		 lea	 edx, DWORD PTR _hue_color_f$[ebp]
  017d2	52		 push	 edx
  017d3	51		 push	 ecx
  017d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  017dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  017e1	51		 push	 ecx
  017e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  017ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  017ef	51		 push	 ecx
  017f0	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  017f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  017fd	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  01802	83 c4 18	 add	 esp, 24			; 00000018H

; 4747 :     ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);

  01805	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _hue_color_f$[ebp]
  0180b	50		 push	 eax
  0180c	e8 00 00 00 00	 call	 ?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
  01811	83 c4 04	 add	 esp, 4
  01814	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _hue_color32$[ebp], eax

; 4748 :     ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, style.Alpha)); // Important: this is still including the main rendering/style alpha!!

  0181a	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0181d	51		 push	 ecx
  0181e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01822	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01827	51		 push	 ecx
  01828	f3 0f 10 85 78
	fe ff ff	 movss	 xmm0, DWORD PTR _B$[ebp]
  01830	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01835	51		 push	 ecx
  01836	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _G$[ebp]
  0183e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01843	51		 push	 ecx
  01844	f3 0f 10 85 90
	fe ff ff	 movss	 xmm0, DWORD PTR _R$[ebp]
  0184c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01851	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  01857	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0185c	50		 push	 eax
  0185d	e8 00 00 00 00	 call	 ?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
  01862	83 c4 04	 add	 esp, 4
  01865	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _user_col32_striped_of_alpha$[ebp], eax

; 4749 : 
; 4750 :     ImVec2 sv_cursor_pos;

  0186b	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _sv_cursor_pos$[ebp]
  01871	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2

; 4751 : 
; 4752 :     if (flags & ImGuiColorEditFlags_PickerHueWheel)

  01876	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  01879	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0187e	0f 84 c7 06 00
	00		 je	 $LN63@ColorPicke

; 4753 :     {
; 4754 :         // Render Hue Wheel
; 4755 :         const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).

  01884	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0188c	f3 0f 5e 85 18
	ff ff ff	 divss	 xmm0, DWORD PTR _wheel_r_outer$[ebp]
  01894	f3 0f 11 85 ac
	fc ff ff	 movss	 DWORD PTR _aeps$54[ebp], xmm0

; 4756 :         const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);

  0189c	f3 0f 2c 85 18
	ff ff ff	 cvttss2si eax, DWORD PTR _wheel_r_outer$[ebp]
  018a4	99		 cdq
  018a5	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  018aa	f7 f9		 idiv	 ecx
  018ac	50		 push	 eax
  018ad	6a 04		 push	 4
  018af	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  018b4	83 c4 08	 add	 esp, 8
  018b7	89 85 a0 fc ff
	ff		 mov	 DWORD PTR _segment_per_arc$53[ebp], eax

; 4757 :         for (int n = 0; n < 6; n++)

  018bd	c7 85 94 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$52[ebp], 0
  018c7	eb 0f		 jmp	 SHORT $LN4@ColorPicke
$LN2@ColorPicke:
  018c9	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR _n$52[ebp]
  018cf	83 c0 01	 add	 eax, 1
  018d2	89 85 94 fc ff
	ff		 mov	 DWORD PTR _n$52[ebp], eax
$LN4@ColorPicke:
  018d8	83 bd 94 fc ff
	ff 06		 cmp	 DWORD PTR _n$52[ebp], 6
  018df	0f 8d 44 02 00
	00		 jge	 $LN3@ColorPicke

; 4758 :         {
; 4759 :             const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;

  018e5	f3 0f 2a 85 94
	fc ff ff	 cvtsi2ss xmm0, DWORD PTR _n$52[ebp]
  018ed	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40c00000
  018f5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  018fd	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  01905	f3 0f 5c 85 ac
	fc ff ff	 subss	 xmm0, DWORD PTR _aeps$54[ebp]
  0190d	f3 0f 11 85 88
	fc ff ff	 movss	 DWORD PTR _a0$51[ebp], xmm0

; 4760 :             const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;

  01915	f3 0f 2a 85 94
	fc ff ff	 cvtsi2ss xmm0, DWORD PTR _n$52[ebp]
  0191d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  01925	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40c00000
  0192d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  01935	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  0193d	f3 0f 58 85 ac
	fc ff ff	 addss	 xmm0, DWORD PTR _aeps$54[ebp]
  01945	f3 0f 11 85 7c
	fc ff ff	 movss	 DWORD PTR _a1$50[ebp], xmm0

; 4761 :             const int vert_start_idx = draw_list->VtxBuffer.Size;

  0194d	8b 45 dc	 mov	 eax, DWORD PTR _draw_list$[ebp]
  01950	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01953	89 8d 70 fc ff
	ff		 mov	 DWORD PTR _vert_start_idx$49[ebp], ecx

; 4762 :             draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);

  01959	8b 85 a0 fc ff
	ff		 mov	 eax, DWORD PTR _segment_per_arc$53[ebp]
  0195f	50		 push	 eax
  01960	51		 push	 ecx
  01961	f3 0f 10 85 7c
	fc ff ff	 movss	 xmm0, DWORD PTR _a1$50[ebp]
  01969	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0196e	51		 push	 ecx
  0196f	f3 0f 10 85 88
	fc ff ff	 movss	 xmm0, DWORD PTR _a0$51[ebp]
  01977	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0197c	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  01984	f3 0f 58 85 18
	ff ff ff	 addss	 xmm0, DWORD PTR _wheel_r_outer$[ebp]
  0198c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  01994	51		 push	 ecx
  01995	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0199a	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _wheel_center$[ebp]
  019a0	51		 push	 ecx
  019a1	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  019a4	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 4763 :             draw_list->PathStroke(col_white, false, wheel_thickness);

  019a9	51		 push	 ecx
  019aa	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_thickness$[ebp]
  019b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  019b7	6a 00		 push	 0
  019b9	8b 85 28 fd ff
	ff		 mov	 eax, DWORD PTR _col_white$[ebp]
  019bf	50		 push	 eax
  019c0	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  019c3	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke

; 4764 :             const int vert_end_idx = draw_list->VtxBuffer.Size;

  019c8	8b 45 dc	 mov	 eax, DWORD PTR _draw_list$[ebp]
  019cb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  019ce	89 8d 64 fc ff
	ff		 mov	 DWORD PTR _vert_end_idx$48[ebp], ecx

; 4765 : 
; 4766 :             // Paint colors over existing vertices
; 4767 :             ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);

  019d4	51		 push	 ecx
  019d5	f3 0f 10 85 88
	fc ff ff	 movss	 xmm0, DWORD PTR _a0$51[ebp]
  019dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  019e2	e8 00 00 00 00	 call	 ?ImSin@@YAMM@Z		; ImSin
  019e7	83 c4 04	 add	 esp, 4
  019ea	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv2046[ebp]
  019f0	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv2046[ebp]
  019f8	f3 0f 59 85 0c
	ff ff ff	 mulss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  01a00	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _wheel_center$[ebp+4]
  01a08	51		 push	 ecx
  01a09	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a0e	51		 push	 ecx
  01a0f	f3 0f 10 85 88
	fc ff ff	 movss	 xmm0, DWORD PTR _a0$51[ebp]
  01a17	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a1c	e8 00 00 00 00	 call	 ?ImCos@@YAMM@Z		; ImCos
  01a21	83 c4 04	 add	 esp, 4
  01a24	d9 9d 6c f6 ff
	ff		 fstp	 DWORD PTR tv2053[ebp]
  01a2a	f3 0f 10 85 6c
	f6 ff ff	 movss	 xmm0, DWORD PTR tv2053[ebp]
  01a32	f3 0f 59 85 0c
	ff ff ff	 mulss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  01a3a	f3 0f 58 85 fc
	fe ff ff	 addss	 xmm0, DWORD PTR _wheel_center$[ebp]
  01a42	51		 push	 ecx
  01a43	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a48	8d 8d 54 fc ff
	ff		 lea	 ecx, DWORD PTR _gradient_p0$47[ebp]
  01a4e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4768 :             ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);

  01a53	51		 push	 ecx
  01a54	f3 0f 10 85 7c
	fc ff ff	 movss	 xmm0, DWORD PTR _a1$50[ebp]
  01a5c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a61	e8 00 00 00 00	 call	 ?ImSin@@YAMM@Z		; ImSin
  01a66	83 c4 04	 add	 esp, 4
  01a69	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv2062[ebp]
  01a6f	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv2062[ebp]
  01a77	f3 0f 59 85 0c
	ff ff ff	 mulss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  01a7f	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _wheel_center$[ebp+4]
  01a87	51		 push	 ecx
  01a88	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a8d	51		 push	 ecx
  01a8e	f3 0f 10 85 7c
	fc ff ff	 movss	 xmm0, DWORD PTR _a1$50[ebp]
  01a96	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01a9b	e8 00 00 00 00	 call	 ?ImCos@@YAMM@Z		; ImCos
  01aa0	83 c4 04	 add	 esp, 4
  01aa3	d9 9d 6c f6 ff
	ff		 fstp	 DWORD PTR tv2069[ebp]
  01aa9	f3 0f 10 85 6c
	f6 ff ff	 movss	 xmm0, DWORD PTR tv2069[ebp]
  01ab1	f3 0f 59 85 0c
	ff ff ff	 mulss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  01ab9	f3 0f 58 85 fc
	fe ff ff	 addss	 xmm0, DWORD PTR _wheel_center$[ebp]
  01ac1	51		 push	 ecx
  01ac2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01ac7	8d 8d 44 fc ff
	ff		 lea	 ecx, DWORD PTR _gradient_p1$46[ebp]
  01acd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4769 :             ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[n], col_hues[n+1]);

  01ad2	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR _n$52[ebp]
  01ad8	8b 8c 85 fc fc
	ff ff		 mov	 ecx, DWORD PTR _col_hues$[ebp+eax*4+4]
  01adf	51		 push	 ecx
  01ae0	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR _n$52[ebp]
  01ae6	8b 84 95 f8 fc
	ff ff		 mov	 eax, DWORD PTR _col_hues$[ebp+edx*4]
  01aed	50		 push	 eax
  01aee	8b 8d 48 fc ff
	ff		 mov	 ecx, DWORD PTR _gradient_p1$46[ebp+4]
  01af4	51		 push	 ecx
  01af5	8b 95 44 fc ff
	ff		 mov	 edx, DWORD PTR _gradient_p1$46[ebp]
  01afb	52		 push	 edx
  01afc	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _gradient_p0$47[ebp+4]
  01b02	50		 push	 eax
  01b03	8b 8d 54 fc ff
	ff		 mov	 ecx, DWORD PTR _gradient_p0$47[ebp]
  01b09	51		 push	 ecx
  01b0a	8b 95 64 fc ff
	ff		 mov	 edx, DWORD PTR _vert_end_idx$48[ebp]
  01b10	52		 push	 edx
  01b11	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _vert_start_idx$49[ebp]
  01b17	50		 push	 eax
  01b18	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01b1b	51		 push	 ecx
  01b1c	e8 00 00 00 00	 call	 ?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPAUImDrawList@@HHUImVec2@@1II@Z ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
  01b21	83 c4 24	 add	 esp, 36			; 00000024H

; 4770 :         }

  01b24	e9 a0 fd ff ff	 jmp	 $LN2@ColorPicke
$LN3@ColorPicke:

; 4771 : 
; 4772 :         // Render Cursor + preview on Hue Wheel
; 4773 :         float cos_hue_angle = ImCos(H * 2.0f * IM_PI);

  01b29	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  01b31	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  01b39	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  01b41	51		 push	 ecx
  01b42	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01b47	e8 00 00 00 00	 call	 ?ImCos@@YAMM@Z		; ImCos
  01b4c	83 c4 04	 add	 esp, 4
  01b4f	d9 9d 38 fc ff
	ff		 fstp	 DWORD PTR _cos_hue_angle$45[ebp]

; 4774 :         float sin_hue_angle = ImSin(H * 2.0f * IM_PI);

  01b55	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  01b5d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  01b65	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  01b6d	51		 push	 ecx
  01b6e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01b73	e8 00 00 00 00	 call	 ?ImSin@@YAMM@Z		; ImSin
  01b78	83 c4 04	 add	 esp, 4
  01b7b	d9 9d 2c fc ff
	ff		 fstp	 DWORD PTR _sin_hue_angle$44[ebp]

; 4775 :         ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);

  01b81	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  01b89	f3 0f 58 85 18
	ff ff ff	 addss	 xmm0, DWORD PTR _wheel_r_outer$[ebp]
  01b91	f3 0f 59 85 2c
	fc ff ff	 mulss	 xmm0, DWORD PTR _sin_hue_angle$44[ebp]
  01b99	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  01ba1	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _wheel_center$[ebp+4]
  01ba9	51		 push	 ecx
  01baa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01baf	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_r_inner$[ebp]
  01bb7	f3 0f 58 85 18
	ff ff ff	 addss	 xmm0, DWORD PTR _wheel_r_outer$[ebp]
  01bbf	f3 0f 59 85 38
	fc ff ff	 mulss	 xmm0, DWORD PTR _cos_hue_angle$45[ebp]
  01bc7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  01bcf	f3 0f 58 85 fc
	fe ff ff	 addss	 xmm0, DWORD PTR _wheel_center$[ebp]
  01bd7	51		 push	 ecx
  01bd8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01bdd	8d 8d 1c fc ff
	ff		 lea	 ecx, DWORD PTR _hue_cursor_pos$43[ebp]
  01be3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 4776 :         float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;

  01be8	0f b6 85 63 fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed_h$[ebp]
  01bef	85 c0		 test	 eax, eax
  01bf1	74 1a		 je	 SHORT $LN100@ColorPicke
  01bf3	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_thickness$[ebp]
  01bfb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f266666
  01c03	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv967[ebp], xmm0
  01c0b	eb 18		 jmp	 SHORT $LN101@ColorPicke
$LN100@ColorPicke:
  01c0d	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _wheel_thickness$[ebp]
  01c15	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f0ccccd
  01c1d	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv967[ebp], xmm0
$LN101@ColorPicke:
  01c25	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv967[ebp]
  01c2d	f3 0f 11 85 10
	fc ff ff	 movss	 DWORD PTR _hue_cursor_rad$42[ebp], xmm0

; 4777 :         int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);

  01c35	6a 20		 push	 32			; 00000020H
  01c37	6a 09		 push	 9
  01c39	f3 0f 10 85 10
	fc ff ff	 movss	 xmm0, DWORD PTR _hue_cursor_rad$42[ebp]
  01c41	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@3fb33333
  01c49	f3 0f 2c c0	 cvttss2si eax, xmm0
  01c4d	50		 push	 eax
  01c4e	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  01c53	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c56	89 85 04 fc ff
	ff		 mov	 DWORD PTR _hue_cursor_segments$41[ebp], eax

; 4778 :         draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);

  01c5c	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR _hue_cursor_segments$41[ebp]
  01c62	50		 push	 eax
  01c63	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _hue_color32$[ebp]
  01c69	51		 push	 ecx
  01c6a	51		 push	 ecx
  01c6b	f3 0f 10 85 10
	fc ff ff	 movss	 xmm0, DWORD PTR _hue_cursor_rad$42[ebp]
  01c73	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01c78	8d 95 1c fc ff
	ff		 lea	 edx, DWORD PTR _hue_cursor_pos$43[ebp]
  01c7e	52		 push	 edx
  01c7f	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01c82	e8 00 00 00 00	 call	 ?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 4779 :         draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, col_midgrey, hue_cursor_segments);

  01c87	51		 push	 ecx
  01c88	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01c90	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01c95	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR _hue_cursor_segments$41[ebp]
  01c9b	50		 push	 eax
  01c9c	8b 8d 1c fd ff
	ff		 mov	 ecx, DWORD PTR _col_midgrey$[ebp]
  01ca2	51		 push	 ecx
  01ca3	f3 0f 10 85 10
	fc ff ff	 movss	 xmm0, DWORD PTR _hue_cursor_rad$42[ebp]
  01cab	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  01cb3	51		 push	 ecx
  01cb4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01cb9	8d 95 1c fc ff
	ff		 lea	 edx, DWORD PTR _hue_cursor_pos$43[ebp]
  01cbf	52		 push	 edx
  01cc0	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01cc3	e8 00 00 00 00	 call	 ?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 4780 :         draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments);

  01cc8	51		 push	 ecx
  01cc9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01cd1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01cd6	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR _hue_cursor_segments$41[ebp]
  01cdc	50		 push	 eax
  01cdd	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR _col_white$[ebp]
  01ce3	51		 push	 ecx
  01ce4	51		 push	 ecx
  01ce5	f3 0f 10 85 10
	fc ff ff	 movss	 xmm0, DWORD PTR _hue_cursor_rad$42[ebp]
  01ced	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01cf2	8d 95 1c fc ff
	ff		 lea	 edx, DWORD PTR _hue_cursor_pos$43[ebp]
  01cf8	52		 push	 edx
  01cf9	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01cfc	e8 00 00 00 00	 call	 ?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 4781 : 
; 4782 :         // Render SV triangle (rotated according to hue)
; 4783 :         ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);

  01d01	51		 push	 ecx
  01d02	f3 0f 10 85 2c
	fc ff ff	 movss	 xmm0, DWORD PTR _sin_hue_angle$44[ebp]
  01d0a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01d0f	51		 push	 ecx
  01d10	f3 0f 10 85 38
	fc ff ff	 movss	 xmm0, DWORD PTR _cos_hue_angle$45[ebp]
  01d18	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01d1d	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _triangle_pa$[ebp]
  01d23	50		 push	 eax
  01d24	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  01d2a	51		 push	 ecx
  01d2b	e8 00 00 00 00	 call	 ?ImRotate@@YA?AUImVec2@@ABU1@MM@Z ; ImRotate
  01d30	83 c4 10	 add	 esp, 16			; 00000010H
  01d33	50		 push	 eax
  01d34	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _wheel_center$[ebp]
  01d3a	52		 push	 edx
  01d3b	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _tra$40[ebp]
  01d41	50		 push	 eax
  01d42	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  01d47	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4784 :         ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);

  01d4a	51		 push	 ecx
  01d4b	f3 0f 10 85 2c
	fc ff ff	 movss	 xmm0, DWORD PTR _sin_hue_angle$44[ebp]
  01d53	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01d58	51		 push	 ecx
  01d59	f3 0f 10 85 38
	fc ff ff	 movss	 xmm0, DWORD PTR _cos_hue_angle$45[ebp]
  01d61	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01d66	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _triangle_pb$[ebp]
  01d6c	50		 push	 eax
  01d6d	8d 8d 98 f7 ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  01d73	51		 push	 ecx
  01d74	e8 00 00 00 00	 call	 ?ImRotate@@YA?AUImVec2@@ABU1@MM@Z ; ImRotate
  01d79	83 c4 10	 add	 esp, 16			; 00000010H
  01d7c	50		 push	 eax
  01d7d	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _wheel_center$[ebp]
  01d83	52		 push	 edx
  01d84	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _trb$39[ebp]
  01d8a	50		 push	 eax
  01d8b	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  01d90	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4785 :         ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);

  01d93	51		 push	 ecx
  01d94	f3 0f 10 85 2c
	fc ff ff	 movss	 xmm0, DWORD PTR _sin_hue_angle$44[ebp]
  01d9c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01da1	51		 push	 ecx
  01da2	f3 0f 10 85 38
	fc ff ff	 movss	 xmm0, DWORD PTR _cos_hue_angle$45[ebp]
  01daa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01daf	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _triangle_pc$[ebp]
  01db5	50		 push	 eax
  01db6	8d 8d 88 f7 ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  01dbc	51		 push	 ecx
  01dbd	e8 00 00 00 00	 call	 ?ImRotate@@YA?AUImVec2@@ABU1@MM@Z ; ImRotate
  01dc2	83 c4 10	 add	 esp, 16			; 00000010H
  01dc5	50		 push	 eax
  01dc6	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _wheel_center$[ebp]
  01dcc	52		 push	 edx
  01dcd	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _trc$38[ebp]
  01dd3	50		 push	 eax
  01dd4	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  01dd9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4786 :         ImVec2 uv_white = GetFontTexUvWhitePixel();

  01ddc	8d 85 c4 fb ff
	ff		 lea	 eax, DWORD PTR _uv_white$37[ebp]
  01de2	50		 push	 eax
  01de3	e8 00 00 00 00	 call	 ?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetFontTexUvWhitePixel
  01de8	83 c4 04	 add	 esp, 4

; 4787 :         draw_list->PrimReserve(6, 6);

  01deb	6a 06		 push	 6
  01ded	6a 06		 push	 6
  01def	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01df2	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 4788 :         draw_list->PrimVtx(tra, uv_white, hue_color32);

  01df7	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _hue_color32$[ebp]
  01dfd	50		 push	 eax
  01dfe	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR _uv_white$37[ebp]
  01e04	51		 push	 ecx
  01e05	8d 95 f4 fb ff
	ff		 lea	 edx, DWORD PTR _tra$40[ebp]
  01e0b	52		 push	 edx
  01e0c	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01e0f	e8 00 00 00 00	 call	 ?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4789 :         draw_list->PrimVtx(trb, uv_white, hue_color32);

  01e14	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _hue_color32$[ebp]
  01e1a	50		 push	 eax
  01e1b	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR _uv_white$37[ebp]
  01e21	51		 push	 ecx
  01e22	8d 95 e4 fb ff
	ff		 lea	 edx, DWORD PTR _trb$39[ebp]
  01e28	52		 push	 edx
  01e29	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01e2c	e8 00 00 00 00	 call	 ?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4790 :         draw_list->PrimVtx(trc, uv_white, col_white);

  01e31	8b 85 28 fd ff
	ff		 mov	 eax, DWORD PTR _col_white$[ebp]
  01e37	50		 push	 eax
  01e38	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR _uv_white$37[ebp]
  01e3e	51		 push	 ecx
  01e3f	8d 95 d4 fb ff
	ff		 lea	 edx, DWORD PTR _trc$38[ebp]
  01e45	52		 push	 edx
  01e46	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01e49	e8 00 00 00 00	 call	 ?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4791 :         draw_list->PrimVtx(tra, uv_white, 0);

  01e4e	6a 00		 push	 0
  01e50	8d 85 c4 fb ff
	ff		 lea	 eax, DWORD PTR _uv_white$37[ebp]
  01e56	50		 push	 eax
  01e57	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _tra$40[ebp]
  01e5d	51		 push	 ecx
  01e5e	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01e61	e8 00 00 00 00	 call	 ?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4792 :         draw_list->PrimVtx(trb, uv_white, col_black);

  01e66	8b 85 34 fd ff
	ff		 mov	 eax, DWORD PTR _col_black$[ebp]
  01e6c	50		 push	 eax
  01e6d	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR _uv_white$37[ebp]
  01e73	51		 push	 ecx
  01e74	8d 95 e4 fb ff
	ff		 lea	 edx, DWORD PTR _trb$39[ebp]
  01e7a	52		 push	 edx
  01e7b	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01e7e	e8 00 00 00 00	 call	 ?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4793 :         draw_list->PrimVtx(trc, uv_white, 0);

  01e83	6a 00		 push	 0
  01e85	8d 85 c4 fb ff
	ff		 lea	 eax, DWORD PTR _uv_white$37[ebp]
  01e8b	50		 push	 eax
  01e8c	8d 8d d4 fb ff
	ff		 lea	 ecx, DWORD PTR _trc$38[ebp]
  01e92	51		 push	 ecx
  01e93	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01e96	e8 00 00 00 00	 call	 ?PrimVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimVtx

; 4794 :         draw_list->AddTriangle(tra, trb, trc, col_midgrey, 1.5f);

  01e9b	51		 push	 ecx
  01e9c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fc00000
  01ea4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01ea9	8b 85 1c fd ff
	ff		 mov	 eax, DWORD PTR _col_midgrey$[ebp]
  01eaf	50		 push	 eax
  01eb0	8d 8d d4 fb ff
	ff		 lea	 ecx, DWORD PTR _trc$38[ebp]
  01eb6	51		 push	 ecx
  01eb7	8d 95 e4 fb ff
	ff		 lea	 edx, DWORD PTR _trb$39[ebp]
  01ebd	52		 push	 edx
  01ebe	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _tra$40[ebp]
  01ec4	50		 push	 eax
  01ec5	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01ec8	e8 00 00 00 00	 call	 ?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z ; ImDrawList::AddTriangle

; 4795 :         sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));

  01ecd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01ed5	f3 0f 5c 85 9c
	fe ff ff	 subss	 xmm0, DWORD PTR _V$[ebp]
  01edd	51		 push	 ecx
  01ede	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01ee3	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  01ee8	d9 1c 24	 fstp	 DWORD PTR [esp]
  01eeb	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _trb$39[ebp]
  01ef1	50		 push	 eax
  01ef2	51		 push	 ecx
  01ef3	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  01efb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01f00	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  01f05	d9 1c 24	 fstp	 DWORD PTR [esp]
  01f08	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _tra$40[ebp]
  01f0e	51		 push	 ecx
  01f0f	8d 95 d4 fb ff
	ff		 lea	 edx, DWORD PTR _trc$38[ebp]
  01f15	52		 push	 edx
  01f16	8d 85 78 f7 ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  01f1c	50		 push	 eax
  01f1d	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec2@@ABU1@0M@Z ; ImLerp
  01f22	83 c4 10	 add	 esp, 16			; 00000010H
  01f25	50		 push	 eax
  01f26	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  01f2c	51		 push	 ecx
  01f2d	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec2@@ABU1@0M@Z ; ImLerp
  01f32	83 c4 10	 add	 esp, 16			; 00000010H
  01f35	8b 10		 mov	 edx, DWORD PTR [eax]
  01f37	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01f3a	89 95 b8 fc ff
	ff		 mov	 DWORD PTR _sv_cursor_pos$[ebp], edx
  01f40	89 85 bc fc ff
	ff		 mov	 DWORD PTR _sv_cursor_pos$[ebp+4], eax

; 4796 :     }

  01f46	e9 70 04 00 00	 jmp	 $LN65@ColorPicke
$LN63@ColorPicke:

; 4797 :     else if (flags & ImGuiColorEditFlags_PickerHueBar)

  01f4b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  01f4e	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  01f53	0f 84 62 04 00
	00		 je	 $LN65@ColorPicke

; 4798 :     {
; 4799 :         // Render SV Square
; 4800 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);

  01f59	8b 85 28 fd ff
	ff		 mov	 eax, DWORD PTR _col_white$[ebp]
  01f5f	50		 push	 eax
  01f60	8b 8d d4 fc ff
	ff		 mov	 ecx, DWORD PTR _hue_color32$[ebp]
  01f66	51		 push	 ecx
  01f67	8b 95 d4 fc ff
	ff		 mov	 edx, DWORD PTR _hue_color32$[ebp]
  01f6d	52		 push	 edx
  01f6e	8b 85 28 fd ff
	ff		 mov	 eax, DWORD PTR _col_white$[ebp]
  01f74	50		 push	 eax
  01f75	51		 push	 ecx
  01f76	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  01f7e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01f83	51		 push	 ecx
  01f84	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  01f8c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01f91	8d 8d 58 f7 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  01f97	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  01f9c	50		 push	 eax
  01f9d	8d 4d 90	 lea	 ecx, DWORD PTR _picker_pos$[ebp]
  01fa0	51		 push	 ecx
  01fa1	8d 95 48 f7 ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  01fa7	52		 push	 edx
  01fa8	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  01fad	83 c4 0c	 add	 esp, 12			; 0000000cH
  01fb0	50		 push	 eax
  01fb1	8d 45 90	 lea	 eax, DWORD PTR _picker_pos$[ebp]
  01fb4	50		 push	 eax
  01fb5	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  01fb8	e8 00 00 00 00	 call	 ?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 4801 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0, 0, col_black, col_black);

  01fbd	8b 85 34 fd ff
	ff		 mov	 eax, DWORD PTR _col_black$[ebp]
  01fc3	50		 push	 eax
  01fc4	8b 8d 34 fd ff
	ff		 mov	 ecx, DWORD PTR _col_black$[ebp]
  01fca	51		 push	 ecx
  01fcb	6a 00		 push	 0
  01fcd	6a 00		 push	 0
  01fcf	51		 push	 ecx
  01fd0	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  01fd8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01fdd	51		 push	 ecx
  01fde	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  01fe6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01feb	8d 8d 38 f7 ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  01ff1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  01ff6	50		 push	 eax
  01ff7	8d 55 90	 lea	 edx, DWORD PTR _picker_pos$[ebp]
  01ffa	52		 push	 edx
  01ffb	8d 85 28 f7 ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  02001	50		 push	 eax
  02002	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  02007	83 c4 0c	 add	 esp, 12			; 0000000cH
  0200a	50		 push	 eax
  0200b	8d 4d 90	 lea	 ecx, DWORD PTR _picker_pos$[ebp]
  0200e	51		 push	 ecx
  0200f	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  02012	e8 00 00 00 00	 call	 ?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 4802 :         RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);

  02017	51		 push	 ecx
  02018	0f 57 c0	 xorps	 xmm0, xmm0
  0201b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02020	51		 push	 ecx
  02021	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  02029	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0202e	51		 push	 ecx
  0202f	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  02037	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0203c	8d 8d 18 f7 ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  02042	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  02047	50		 push	 eax
  02048	8d 45 90	 lea	 eax, DWORD PTR _picker_pos$[ebp]
  0204b	50		 push	 eax
  0204c	8d 8d 08 f7 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  02052	51		 push	 ecx
  02053	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  02058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0205b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0205e	52		 push	 edx
  0205f	8b 00		 mov	 eax, DWORD PTR [eax]
  02061	50		 push	 eax
  02062	8b 4d 94	 mov	 ecx, DWORD PTR _picker_pos$[ebp+4]
  02065	51		 push	 ecx
  02066	8b 55 90	 mov	 edx, DWORD PTR _picker_pos$[ebp]
  02069	52		 push	 edx
  0206a	e8 00 00 00 00	 call	 ?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
  0206f	83 c4 14	 add	 esp, 20			; 00000014H

; 4803 :         sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S)     * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much

  02072	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _picker_pos$[ebp]
  02077	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  0207f	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  02087	51		 push	 ecx
  02088	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0208d	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _picker_pos$[ebp]
  02092	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0209a	51		 push	 ecx
  0209b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  020a0	51		 push	 ecx
  020a1	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _S$[ebp]
  020a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  020ae	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  020b3	83 c4 04	 add	 esp, 4
  020b6	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv2251[ebp]
  020bc	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv2251[ebp]
  020c4	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  020cc	f3 0f 58 45 90	 addss	 xmm0, DWORD PTR _picker_pos$[ebp]
  020d1	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  020d9	f3 0f 2c c0	 cvttss2si eax, xmm0
  020dd	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  020e1	51		 push	 ecx
  020e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  020e7	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  020ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  020ef	d9 9d b8 fc ff
	ff		 fstp	 DWORD PTR _sv_cursor_pos$[ebp]

; 4804 :         sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

  020f5	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  020fa	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  02102	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  0210a	51		 push	 ecx
  0210b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02110	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  02115	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0211d	51		 push	 ecx
  0211e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02123	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0212b	f3 0f 5c 85 9c
	fe ff ff	 subss	 xmm0, DWORD PTR _V$[ebp]
  02133	51		 push	 ecx
  02134	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02139	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0213e	83 c4 04	 add	 esp, 4
  02141	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv2265[ebp]
  02147	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv2265[ebp]
  0214f	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  02157	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  0215c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  02164	f3 0f 2c c0	 cvttss2si eax, xmm0
  02168	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0216c	51		 push	 ecx
  0216d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02172	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  02177	83 c4 0c	 add	 esp, 12			; 0000000cH
  0217a	d9 9d bc fc ff
	ff		 fstp	 DWORD PTR _sv_cursor_pos$[ebp+4]

; 4805 : 
; 4806 :         // Render Hue Bar
; 4807 :         for (int i = 0; i < 6; ++i)

  02180	c7 85 b8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$36[ebp], 0
  0218a	eb 0f		 jmp	 SHORT $LN7@ColorPicke
$LN5@ColorPicke:
  0218c	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _i$36[ebp]
  02192	83 c0 01	 add	 eax, 1
  02195	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _i$36[ebp], eax
$LN7@ColorPicke:
  0219b	83 bd b8 fb ff
	ff 06		 cmp	 DWORD PTR _i$36[ebp], 6
  021a2	0f 8d d4 00 00
	00		 jge	 $LN6@ColorPicke

; 4808 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

  021a8	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _i$36[ebp]
  021ae	8b 8c 85 fc fc
	ff ff		 mov	 ecx, DWORD PTR _col_hues$[ebp+eax*4+4]
  021b5	51		 push	 ecx
  021b6	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR _i$36[ebp]
  021bc	8b 84 95 fc fc
	ff ff		 mov	 eax, DWORD PTR _col_hues$[ebp+edx*4+4]
  021c3	50		 push	 eax
  021c4	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _i$36[ebp]
  021ca	8b 94 8d f8 fc
	ff ff		 mov	 edx, DWORD PTR _col_hues$[ebp+ecx*4]
  021d1	52		 push	 edx
  021d2	8b 85 b8 fb ff
	ff		 mov	 eax, DWORD PTR _i$36[ebp]
  021d8	8b 8c 85 f8 fc
	ff ff		 mov	 ecx, DWORD PTR _col_hues$[ebp+eax*4]
  021df	51		 push	 ecx
  021e0	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR _i$36[ebp]
  021e6	83 c2 01	 add	 edx, 1
  021e9	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  021ed	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _sv_picker_size$[ebp]
  021f5	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40c00000
  021fd	f3 0f 59 c1	 mulss	 xmm0, xmm1
  02201	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  02206	51		 push	 ecx
  02207	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0220c	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  02214	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _bars_width$[ebp]
  0221c	51		 push	 ecx
  0221d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02222	8d 8d f8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  02228	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0222d	50		 push	 eax
  0222e	f3 0f 2a 85 b8
	fb ff ff	 cvtsi2ss xmm0, DWORD PTR _i$36[ebp]
  02236	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _sv_picker_size$[ebp]
  0223e	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40c00000
  02246	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0224a	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  0224f	51		 push	 ecx
  02250	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02255	51		 push	 ecx
  02256	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  0225e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02263	8d 8d e8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  02269	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0226e	50		 push	 eax
  0226f	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  02272	e8 00 00 00 00	 call	 ?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
  02277	e9 10 ff ff ff	 jmp	 $LN5@ColorPicke
$LN6@ColorPicke:

; 4809 :         float bar0_line_y = IM_ROUND(picker_pos.y + H * sv_picker_size);

  0227c	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _H$[ebp]
  02284	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  0228c	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  02291	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  02299	f3 0f 2c c0	 cvttss2si eax, xmm0
  0229d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  022a1	f3 0f 11 85 ac
	fb ff ff	 movss	 DWORD PTR _bar0_line_y$35[ebp], xmm0

; 4810 :         RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);

  022a9	51		 push	 ecx
  022aa	0f 57 c0	 xorps	 xmm0, xmm0
  022ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  022b2	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  022b7	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  022bf	51		 push	 ecx
  022c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  022c5	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  022cd	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _bars_width$[ebp]
  022d5	51		 push	 ecx
  022d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  022db	8d 8d d8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  022e1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  022e6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  022e9	51		 push	 ecx
  022ea	8b 10		 mov	 edx, DWORD PTR [eax]
  022ec	52		 push	 edx
  022ed	51		 push	 ecx
  022ee	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  022f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  022f8	51		 push	 ecx
  022f9	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  02301	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02306	8d 8d c8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0230c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  02311	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02314	51		 push	 ecx
  02315	8b 10		 mov	 edx, DWORD PTR [eax]
  02317	52		 push	 edx
  02318	e8 00 00 00 00	 call	 ?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
  0231d	83 c4 14	 add	 esp, 20			; 00000014H

; 4811 :         RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);

  02320	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  02323	51		 push	 ecx
  02324	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  02328	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0232d	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_width$[ebp]
  02335	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0233d	51		 push	 ecx
  0233e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02343	51		 push	 ecx
  02344	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_triangles_half_sz$[ebp]
  0234c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02351	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_triangles_half_sz$[ebp]
  02359	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  02361	51		 push	 ecx
  02362	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02367	8d 8d b8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0236d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  02372	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02375	51		 push	 ecx
  02376	8b 10		 mov	 edx, DWORD PTR [eax]
  02378	52		 push	 edx
  02379	51		 push	 ecx
  0237a	f3 0f 10 85 ac
	fb ff ff	 movss	 xmm0, DWORD PTR _bar0_line_y$35[ebp]
  02382	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02387	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _bar0_pos_x$[ebp]
  0238f	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  02397	51		 push	 ecx
  02398	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0239d	8d 8d a8 f6 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  023a3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  023a8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  023ab	51		 push	 ecx
  023ac	8b 10		 mov	 edx, DWORD PTR [eax]
  023ae	52		 push	 edx
  023af	8b 45 dc	 mov	 eax, DWORD PTR _draw_list$[ebp]
  023b2	50		 push	 eax
  023b3	e8 00 00 00 00	 call	 ?RenderArrowsForVerticalBar@@YAXPAUImDrawList@@UImVec2@@1MM@Z ; RenderArrowsForVerticalBar
  023b8	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN65@ColorPicke:

; 4812 :     }
; 4813 : 
; 4814 :     // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
; 4815 :     float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;

  023bb	0f b6 85 57 fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed_sv$[ebp]
  023c2	85 c0		 test	 eax, eax
  023c4	74 12		 je	 SHORT $LN102@ColorPicke
  023c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  023ce	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv1250[ebp], xmm0
  023d6	eb 10		 jmp	 SHORT $LN103@ColorPicke
$LN102@ColorPicke:
  023d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40c00000
  023e0	f3 0f 11 85 70
	f6 ff ff	 movss	 DWORD PTR tv1250[ebp], xmm0
$LN103@ColorPicke:
  023e8	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv1250[ebp]
  023f0	f3 0f 11 85 a0
	fb ff ff	 movss	 DWORD PTR _sv_cursor_rad$[ebp], xmm0

; 4816 :     draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, 12);

  023f8	6a 0c		 push	 12			; 0000000cH
  023fa	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _user_col32_striped_of_alpha$[ebp]
  02400	50		 push	 eax
  02401	51		 push	 ecx
  02402	f3 0f 10 85 a0
	fb ff ff	 movss	 xmm0, DWORD PTR _sv_cursor_rad$[ebp]
  0240a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0240f	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _sv_cursor_pos$[ebp]
  02415	51		 push	 ecx
  02416	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  02419	e8 00 00 00 00	 call	 ?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 4817 :     draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, col_midgrey, 12);

  0241e	51		 push	 ecx
  0241f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  02427	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0242c	6a 0c		 push	 12			; 0000000cH
  0242e	8b 85 1c fd ff
	ff		 mov	 eax, DWORD PTR _col_midgrey$[ebp]
  02434	50		 push	 eax
  02435	f3 0f 10 85 a0
	fb ff ff	 movss	 xmm0, DWORD PTR _sv_cursor_rad$[ebp]
  0243d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  02445	51		 push	 ecx
  02446	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0244b	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _sv_cursor_pos$[ebp]
  02451	51		 push	 ecx
  02452	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  02455	e8 00 00 00 00	 call	 ?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 4818 :     draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, col_white, 12);

  0245a	51		 push	 ecx
  0245b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  02463	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02468	6a 0c		 push	 12			; 0000000cH
  0246a	8b 85 28 fd ff
	ff		 mov	 eax, DWORD PTR _col_white$[ebp]
  02470	50		 push	 eax
  02471	51		 push	 ecx
  02472	f3 0f 10 85 a0
	fb ff ff	 movss	 xmm0, DWORD PTR _sv_cursor_rad$[ebp]
  0247a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0247f	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _sv_cursor_pos$[ebp]
  02485	51		 push	 ecx
  02486	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  02489	e8 00 00 00 00	 call	 ?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 4819 : 
; 4820 :     // Render alpha bar
; 4821 :     if (alpha_bar)

  0248e	0f b6 45 a3	 movzx	 eax, BYTE PTR _alpha_bar$[ebp]
  02492	85 c0		 test	 eax, eax
  02494	0f 84 27 02 00
	00		 je	 $LN66@ColorPicke

; 4822 :     {
; 4823 :         float alpha = ImSaturate(col[3]);

  0249a	b8 04 00 00 00	 mov	 eax, 4
  0249f	6b c8 03	 imul	 ecx, eax, 3
  024a2	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  024a5	51		 push	 ecx
  024a6	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  024ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  024b0	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  024b5	83 c4 04	 add	 esp, 4
  024b8	d9 9d 94 fb ff
	ff		 fstp	 DWORD PTR _alpha$34[ebp]

; 4824 :         ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);

  024be	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  024c3	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  024cb	51		 push	 ecx
  024cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  024d1	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _bar1_pos_x$[ebp]
  024d9	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR _bars_width$[ebp]
  024e1	51		 push	 ecx
  024e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  024e7	51		 push	 ecx
  024e8	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  024ed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  024f2	51		 push	 ecx
  024f3	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _bar1_pos_x$[ebp]
  024fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02500	8d 8d 7c fb ff
	ff		 lea	 ecx, DWORD PTR _bar1_bb$33[ebp]
  02506	e8 00 00 00 00	 call	 ??0ImRect@@QAE@MMMM@Z	; ImRect::ImRect

; 4825 :         RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));

  0250b	6a ff		 push	 -1
  0250d	51		 push	 ecx
  0250e	0f 57 c0	 xorps	 xmm0, xmm0
  02511	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02516	51		 push	 ecx
  02517	0f 57 c0	 xorps	 xmm0, xmm0
  0251a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0251f	51		 push	 ecx
  02520	0f 57 c0	 xorps	 xmm0, xmm0
  02523	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02528	8d 8d 98 f6 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0252e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  02533	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  02536	51		 push	 ecx
  02537	8b 10		 mov	 edx, DWORD PTR [eax]
  02539	52		 push	 edx
  0253a	8d 8d 7c fb ff
	ff		 lea	 ecx, DWORD PTR _bar1_bb$33[ebp]
  02540	e8 00 00 00 00	 call	 ?GetWidth@ImRect@@QBEMXZ ; ImRect::GetWidth
  02545	d9 9d 70 f6 ff
	ff		 fstp	 DWORD PTR tv2385[ebp]
  0254b	f3 0f 10 85 70
	f6 ff ff	 movss	 xmm0, DWORD PTR tv2385[ebp]
  02553	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0255b	51		 push	 ecx
  0255c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02561	6a 00		 push	 0
  02563	8b 85 88 fb ff
	ff		 mov	 eax, DWORD PTR _bar1_bb$33[ebp+12]
  02569	50		 push	 eax
  0256a	8b 8d 84 fb ff
	ff		 mov	 ecx, DWORD PTR _bar1_bb$33[ebp+8]
  02570	51		 push	 ecx
  02571	8b 95 80 fb ff
	ff		 mov	 edx, DWORD PTR _bar1_bb$33[ebp+4]
  02577	52		 push	 edx
  02578	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _bar1_bb$33[ebp]
  0257e	50		 push	 eax
  0257f	e8 00 00 00 00	 call	 ?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXUImVec2@@0IM0MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
  02584	83 c4 28	 add	 esp, 40			; 00000028H

; 4826 :         draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~IM_COL32_A_MASK, user_col32_striped_of_alpha & ~IM_COL32_A_MASK);

  02587	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _user_col32_striped_of_alpha$[ebp]
  0258d	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  02592	50		 push	 eax
  02593	8b 8d c8 fc ff
	ff		 mov	 ecx, DWORD PTR _user_col32_striped_of_alpha$[ebp]
  02599	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0259f	51		 push	 ecx
  025a0	8b 95 c8 fc ff
	ff		 mov	 edx, DWORD PTR _user_col32_striped_of_alpha$[ebp]
  025a6	52		 push	 edx
  025a7	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _user_col32_striped_of_alpha$[ebp]
  025ad	50		 push	 eax
  025ae	8d 8d 84 fb ff
	ff		 lea	 ecx, DWORD PTR _bar1_bb$33[ebp+8]
  025b4	51		 push	 ecx
  025b5	8d 95 7c fb ff
	ff		 lea	 edx, DWORD PTR _bar1_bb$33[ebp]
  025bb	52		 push	 edx
  025bc	8b 4d dc	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  025bf	e8 00 00 00 00	 call	 ?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 4827 :         float bar1_line_y = IM_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);

  025c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  025cc	f3 0f 5c 85 94
	fb ff ff	 subss	 xmm0, DWORD PTR _alpha$34[ebp]
  025d4	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR _sv_picker_size$[ebp]
  025dc	f3 0f 58 45 94	 addss	 xmm0, DWORD PTR _picker_pos$[ebp+4]
  025e1	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  025e9	f3 0f 2c c0	 cvttss2si eax, xmm0
  025ed	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  025f1	f3 0f 11 85 70
	fb ff ff	 movss	 DWORD PTR _bar1_line_y$32[ebp], xmm0

; 4828 :         RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);

  025f9	51		 push	 ecx
  025fa	0f 57 c0	 xorps	 xmm0, xmm0
  025fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02602	8b 85 88 fb ff
	ff		 mov	 eax, DWORD PTR _bar1_bb$33[ebp+12]
  02608	50		 push	 eax
  02609	8b 8d 84 fb ff
	ff		 mov	 ecx, DWORD PTR _bar1_bb$33[ebp+8]
  0260f	51		 push	 ecx
  02610	8b 95 80 fb ff
	ff		 mov	 edx, DWORD PTR _bar1_bb$33[ebp+4]
  02616	52		 push	 edx
  02617	8b 85 7c fb ff
	ff		 mov	 eax, DWORD PTR _bar1_bb$33[ebp]
  0261d	50		 push	 eax
  0261e	e8 00 00 00 00	 call	 ?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
  02623	83 c4 14	 add	 esp, 20			; 00000014H

; 4829 :         RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);

  02626	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  02629	51		 push	 ecx
  0262a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0262e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02633	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_width$[ebp]
  0263b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  02643	51		 push	 ecx
  02644	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02649	51		 push	 ecx
  0264a	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_triangles_half_sz$[ebp]
  02652	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  02657	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _bars_triangles_half_sz$[ebp]
  0265f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  02667	51		 push	 ecx
  02668	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0266d	8d 8d 88 f6 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  02673	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  02678	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0267b	51		 push	 ecx
  0267c	8b 10		 mov	 edx, DWORD PTR [eax]
  0267e	52		 push	 edx
  0267f	51		 push	 ecx
  02680	f3 0f 10 85 70
	fb ff ff	 movss	 xmm0, DWORD PTR _bar1_line_y$32[ebp]
  02688	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0268d	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _bar1_pos_x$[ebp]
  02695	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0269d	51		 push	 ecx
  0269e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  026a3	8d 8d 78 f6 ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  026a9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  026ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  026b1	51		 push	 ecx
  026b2	8b 10		 mov	 edx, DWORD PTR [eax]
  026b4	52		 push	 edx
  026b5	8b 45 dc	 mov	 eax, DWORD PTR _draw_list$[ebp]
  026b8	50		 push	 eax
  026b9	e8 00 00 00 00	 call	 ?RenderArrowsForVerticalBar@@YAXPAUImDrawList@@UImVec2@@1MM@Z ; RenderArrowsForVerticalBar
  026be	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN66@ColorPicke:

; 4830 :     }
; 4831 : 
; 4832 :     EndGroup();

  026c1	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 4833 : 
; 4834 :     if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)

  026c6	0f b6 85 6f fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  026cd	85 c0		 test	 eax, eax
  026cf	74 25		 je	 SHORT $LN67@ColorPicke
  026d1	8b 45 ac	 mov	 eax, DWORD PTR _components$[ebp]
  026d4	c1 e0 02	 shl	 eax, 2
  026d7	50		 push	 eax
  026d8	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  026db	51		 push	 ecx
  026dc	8d 95 30 ff ff
	ff		 lea	 edx, DWORD PTR _backup_initial_col$[ebp]
  026e2	52		 push	 edx
  026e3	e8 00 00 00 00	 call	 _memcmp
  026e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  026eb	85 c0		 test	 eax, eax
  026ed	75 07		 jne	 SHORT $LN67@ColorPicke

; 4835 :         value_changed = false;

  026ef	c6 85 6f fe ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0
$LN67@ColorPicke:

; 4836 :     if (value_changed)

  026f6	0f b6 85 6f fe
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  026fd	85 c0		 test	 eax, eax
  026ff	74 12		 je	 SHORT $LN68@ColorPicke

; 4837 :         MarkItemEdited(window->DC.LastItemId);

  02701	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  02704	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  0270a	51		 push	 ecx
  0270b	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  02710	83 c4 04	 add	 esp, 4
$LN68@ColorPicke:

; 4838 : 
; 4839 :     PopID();

  02713	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 4840 : 
; 4841 :     return value_changed;

  02718	8a 85 6f fe ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@ColorPicke:

; 4842 : }

  0271e	52		 push	 edx
  0271f	8b cd		 mov	 ecx, ebp
  02721	50		 push	 eax
  02722	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN139@ColorPicke
  02728	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0272d	58		 pop	 eax
  0272e	5a		 pop	 edx
  0272f	5f		 pop	 edi
  02730	5e		 pop	 esi
  02731	5b		 pop	 ebx
  02732	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02735	33 cd		 xor	 ecx, ebp
  02737	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0273c	81 c4 98 09 00
	00		 add	 esp, 2456		; 00000998H
  02742	3b ec		 cmp	 ebp, esp
  02744	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02749	8b e5		 mov	 esp, ebp
  0274b	5d		 pop	 ebp
  0274c	c3		 ret	 0
  0274d	0f 1f 00	 npad	 3
$LN139@ColorPicke:
  02750	22 00 00 00	 DD	 34			; 00000022H
  02754	00 00 00 00	 DD	 $LN138@ColorPicke
$LN138@ColorPicke:
  02758	90 ff ff ff	 DD	 -112			; ffffff90H
  0275c	08 00 00 00	 DD	 8
  02760	00 00 00 00	 DD	 $LN104@ColorPicke
  02764	30 ff ff ff	 DD	 -208			; ffffff30H
  02768	10 00 00 00	 DD	 16			; 00000010H
  0276c	00 00 00 00	 DD	 $LN105@ColorPicke
  02770	fc fe ff ff	 DD	 -260			; fffffefcH
  02774	08 00 00 00	 DD	 8
  02778	00 00 00 00	 DD	 $LN106@ColorPicke
  0277c	e0 fe ff ff	 DD	 -288			; fffffee0H
  02780	08 00 00 00	 DD	 8
  02784	00 00 00 00	 DD	 $LN107@ColorPicke
  02788	d0 fe ff ff	 DD	 -304			; fffffed0H
  0278c	08 00 00 00	 DD	 8
  02790	00 00 00 00	 DD	 $LN108@ColorPicke
  02794	c0 fe ff ff	 DD	 -320			; fffffec0H
  02798	08 00 00 00	 DD	 8
  0279c	00 00 00 00	 DD	 $LN109@ColorPicke
  027a0	b4 fe ff ff	 DD	 -332			; fffffeb4H
  027a4	04 00 00 00	 DD	 4
  027a8	00 00 00 00	 DD	 $LN110@ColorPicke
  027ac	a8 fe ff ff	 DD	 -344			; fffffea8H
  027b0	04 00 00 00	 DD	 4
  027b4	00 00 00 00	 DD	 $LN111@ColorPicke
  027b8	9c fe ff ff	 DD	 -356			; fffffe9cH
  027bc	04 00 00 00	 DD	 4
  027c0	00 00 00 00	 DD	 $LN112@ColorPicke
  027c4	90 fe ff ff	 DD	 -368			; fffffe90H
  027c8	04 00 00 00	 DD	 4
  027cc	00 00 00 00	 DD	 $LN113@ColorPicke
  027d0	84 fe ff ff	 DD	 -380			; fffffe84H
  027d4	04 00 00 00	 DD	 4
  027d8	00 00 00 00	 DD	 $LN114@ColorPicke
  027dc	78 fe ff ff	 DD	 -392			; fffffe78H
  027e0	04 00 00 00	 DD	 4
  027e4	00 00 00 00	 DD	 $LN115@ColorPicke
  027e8	44 fe ff ff	 DD	 -444			; fffffe44H
  027ec	08 00 00 00	 DD	 8
  027f0	00 00 00 00	 DD	 $LN116@ColorPicke
  027f4	34 fe ff ff	 DD	 -460			; fffffe34H
  027f8	08 00 00 00	 DD	 8
  027fc	00 00 00 00	 DD	 $LN117@ColorPicke
  02800	00 fe ff ff	 DD	 -512			; fffffe00H
  02804	08 00 00 00	 DD	 8
  02808	00 00 00 00	 DD	 $LN118@ColorPicke
  0280c	f4 fd ff ff	 DD	 -524			; fffffdf4H
  02810	04 00 00 00	 DD	 4
  02814	00 00 00 00	 DD	 $LN119@ColorPicke
  02818	e8 fd ff ff	 DD	 -536			; fffffde8H
  0281c	04 00 00 00	 DD	 4
  02820	00 00 00 00	 DD	 $LN120@ColorPicke
  02824	dc fd ff ff	 DD	 -548			; fffffddcH
  02828	04 00 00 00	 DD	 4
  0282c	00 00 00 00	 DD	 $LN121@ColorPicke
  02830	b8 fd ff ff	 DD	 -584			; fffffdb8H
  02834	10 00 00 00	 DD	 16			; 00000010H
  02838	00 00 00 00	 DD	 $LN122@ColorPicke
  0283c	94 fd ff ff	 DD	 -620			; fffffd94H
  02840	10 00 00 00	 DD	 16			; 00000010H
  02844	00 00 00 00	 DD	 $LN123@ColorPicke
  02848	64 fd ff ff	 DD	 -668			; fffffd64H
  0284c	04 00 00 00	 DD	 4
  02850	00 00 00 00	 DD	 $LN124@ColorPicke
  02854	58 fd ff ff	 DD	 -680			; fffffd58H
  02858	04 00 00 00	 DD	 4
  0285c	00 00 00 00	 DD	 $LN125@ColorPicke
  02860	4c fd ff ff	 DD	 -692			; fffffd4cH
  02864	04 00 00 00	 DD	 4
  02868	00 00 00 00	 DD	 $LN126@ColorPicke
  0286c	f8 fc ff ff	 DD	 -776			; fffffcf8H
  02870	1c 00 00 00	 DD	 28			; 0000001cH
  02874	00 00 00 00	 DD	 $LN127@ColorPicke
  02878	e0 fc ff ff	 DD	 -800			; fffffce0H
  0287c	10 00 00 00	 DD	 16			; 00000010H
  02880	00 00 00 00	 DD	 $LN128@ColorPicke
  02884	b8 fc ff ff	 DD	 -840			; fffffcb8H
  02888	08 00 00 00	 DD	 8
  0288c	00 00 00 00	 DD	 $LN129@ColorPicke
  02890	54 fc ff ff	 DD	 -940			; fffffc54H
  02894	08 00 00 00	 DD	 8
  02898	00 00 00 00	 DD	 $LN130@ColorPicke
  0289c	44 fc ff ff	 DD	 -956			; fffffc44H
  028a0	08 00 00 00	 DD	 8
  028a4	00 00 00 00	 DD	 $LN131@ColorPicke
  028a8	1c fc ff ff	 DD	 -996			; fffffc1cH
  028ac	08 00 00 00	 DD	 8
  028b0	00 00 00 00	 DD	 $LN132@ColorPicke
  028b4	f4 fb ff ff	 DD	 -1036			; fffffbf4H
  028b8	08 00 00 00	 DD	 8
  028bc	00 00 00 00	 DD	 $LN133@ColorPicke
  028c0	e4 fb ff ff	 DD	 -1052			; fffffbe4H
  028c4	08 00 00 00	 DD	 8
  028c8	00 00 00 00	 DD	 $LN134@ColorPicke
  028cc	d4 fb ff ff	 DD	 -1068			; fffffbd4H
  028d0	08 00 00 00	 DD	 8
  028d4	00 00 00 00	 DD	 $LN135@ColorPicke
  028d8	c4 fb ff ff	 DD	 -1084			; fffffbc4H
  028dc	08 00 00 00	 DD	 8
  028e0	00 00 00 00	 DD	 $LN136@ColorPicke
  028e4	7c fb ff ff	 DD	 -1156			; fffffb7cH
  028e8	10 00 00 00	 DD	 16			; 00000010H
  028ec	00 00 00 00	 DD	 $LN137@ColorPicke
$LN137@ColorPicke:
  028f0	62		 DB	 98			; 00000062H
  028f1	61		 DB	 97			; 00000061H
  028f2	72		 DB	 114			; 00000072H
  028f3	31		 DB	 49			; 00000031H
  028f4	5f		 DB	 95			; 0000005fH
  028f5	62		 DB	 98			; 00000062H
  028f6	62		 DB	 98			; 00000062H
  028f7	00		 DB	 0
$LN136@ColorPicke:
  028f8	75		 DB	 117			; 00000075H
  028f9	76		 DB	 118			; 00000076H
  028fa	5f		 DB	 95			; 0000005fH
  028fb	77		 DB	 119			; 00000077H
  028fc	68		 DB	 104			; 00000068H
  028fd	69		 DB	 105			; 00000069H
  028fe	74		 DB	 116			; 00000074H
  028ff	65		 DB	 101			; 00000065H
  02900	00		 DB	 0
$LN135@ColorPicke:
  02901	74		 DB	 116			; 00000074H
  02902	72		 DB	 114			; 00000072H
  02903	63		 DB	 99			; 00000063H
  02904	00		 DB	 0
$LN134@ColorPicke:
  02905	74		 DB	 116			; 00000074H
  02906	72		 DB	 114			; 00000072H
  02907	62		 DB	 98			; 00000062H
  02908	00		 DB	 0
$LN133@ColorPicke:
  02909	74		 DB	 116			; 00000074H
  0290a	72		 DB	 114			; 00000072H
  0290b	61		 DB	 97			; 00000061H
  0290c	00		 DB	 0
$LN132@ColorPicke:
  0290d	68		 DB	 104			; 00000068H
  0290e	75		 DB	 117			; 00000075H
  0290f	65		 DB	 101			; 00000065H
  02910	5f		 DB	 95			; 0000005fH
  02911	63		 DB	 99			; 00000063H
  02912	75		 DB	 117			; 00000075H
  02913	72		 DB	 114			; 00000072H
  02914	73		 DB	 115			; 00000073H
  02915	6f		 DB	 111			; 0000006fH
  02916	72		 DB	 114			; 00000072H
  02917	5f		 DB	 95			; 0000005fH
  02918	70		 DB	 112			; 00000070H
  02919	6f		 DB	 111			; 0000006fH
  0291a	73		 DB	 115			; 00000073H
  0291b	00		 DB	 0
$LN131@ColorPicke:
  0291c	67		 DB	 103			; 00000067H
  0291d	72		 DB	 114			; 00000072H
  0291e	61		 DB	 97			; 00000061H
  0291f	64		 DB	 100			; 00000064H
  02920	69		 DB	 105			; 00000069H
  02921	65		 DB	 101			; 00000065H
  02922	6e		 DB	 110			; 0000006eH
  02923	74		 DB	 116			; 00000074H
  02924	5f		 DB	 95			; 0000005fH
  02925	70		 DB	 112			; 00000070H
  02926	31		 DB	 49			; 00000031H
  02927	00		 DB	 0
$LN130@ColorPicke:
  02928	67		 DB	 103			; 00000067H
  02929	72		 DB	 114			; 00000072H
  0292a	61		 DB	 97			; 00000061H
  0292b	64		 DB	 100			; 00000064H
  0292c	69		 DB	 105			; 00000069H
  0292d	65		 DB	 101			; 00000065H
  0292e	6e		 DB	 110			; 0000006eH
  0292f	74		 DB	 116			; 00000074H
  02930	5f		 DB	 95			; 0000005fH
  02931	70		 DB	 112			; 00000070H
  02932	30		 DB	 48			; 00000030H
  02933	00		 DB	 0
$LN129@ColorPicke:
  02934	73		 DB	 115			; 00000073H
  02935	76		 DB	 118			; 00000076H
  02936	5f		 DB	 95			; 0000005fH
  02937	63		 DB	 99			; 00000063H
  02938	75		 DB	 117			; 00000075H
  02939	72		 DB	 114			; 00000072H
  0293a	73		 DB	 115			; 00000073H
  0293b	6f		 DB	 111			; 0000006fH
  0293c	72		 DB	 114			; 00000072H
  0293d	5f		 DB	 95			; 0000005fH
  0293e	70		 DB	 112			; 00000070H
  0293f	6f		 DB	 111			; 0000006fH
  02940	73		 DB	 115			; 00000073H
  02941	00		 DB	 0
$LN128@ColorPicke:
  02942	68		 DB	 104			; 00000068H
  02943	75		 DB	 117			; 00000075H
  02944	65		 DB	 101			; 00000065H
  02945	5f		 DB	 95			; 0000005fH
  02946	63		 DB	 99			; 00000063H
  02947	6f		 DB	 111			; 0000006fH
  02948	6c		 DB	 108			; 0000006cH
  02949	6f		 DB	 111			; 0000006fH
  0294a	72		 DB	 114			; 00000072H
  0294b	5f		 DB	 95			; 0000005fH
  0294c	66		 DB	 102			; 00000066H
  0294d	00		 DB	 0
$LN127@ColorPicke:
  0294e	63		 DB	 99			; 00000063H
  0294f	6f		 DB	 111			; 0000006fH
  02950	6c		 DB	 108			; 0000006cH
  02951	5f		 DB	 95			; 0000005fH
  02952	68		 DB	 104			; 00000068H
  02953	75		 DB	 117			; 00000075H
  02954	65		 DB	 101			; 00000065H
  02955	73		 DB	 115			; 00000073H
  02956	00		 DB	 0
$LN126@ColorPicke:
  02957	6e		 DB	 110			; 0000006eH
  02958	65		 DB	 101			; 00000065H
  02959	77		 DB	 119			; 00000077H
  0295a	5f		 DB	 95			; 0000005fH
  0295b	56		 DB	 86			; 00000056H
  0295c	00		 DB	 0
$LN125@ColorPicke:
  0295d	6e		 DB	 110			; 0000006eH
  0295e	65		 DB	 101			; 00000065H
  0295f	77		 DB	 119			; 00000077H
  02960	5f		 DB	 95			; 0000005fH
  02961	53		 DB	 83			; 00000053H
  02962	00		 DB	 0
$LN124@ColorPicke:
  02963	6e		 DB	 110			; 0000006eH
  02964	65		 DB	 101			; 00000065H
  02965	77		 DB	 119			; 00000077H
  02966	5f		 DB	 95			; 0000005fH
  02967	48		 DB	 72			; 00000048H
  02968	00		 DB	 0
$LN123@ColorPicke:
  02969	72		 DB	 114			; 00000072H
  0296a	65		 DB	 101			; 00000065H
  0296b	66		 DB	 102			; 00000066H
  0296c	5f		 DB	 95			; 0000005fH
  0296d	63		 DB	 99			; 00000063H
  0296e	6f		 DB	 111			; 0000006fH
  0296f	6c		 DB	 108			; 0000006cH
  02970	5f		 DB	 95			; 0000005fH
  02971	76		 DB	 118			; 00000076H
  02972	34		 DB	 52			; 00000034H
  02973	00		 DB	 0
$LN122@ColorPicke:
  02974	63		 DB	 99			; 00000063H
  02975	6f		 DB	 111			; 0000006fH
  02976	6c		 DB	 108			; 0000006cH
  02977	5f		 DB	 95			; 0000005fH
  02978	76		 DB	 118			; 00000076H
  02979	34		 DB	 52			; 00000034H
  0297a	00		 DB	 0
$LN121@ColorPicke:
  0297b	77		 DB	 119			; 00000077H
  0297c	77		 DB	 119			; 00000077H
  0297d	00		 DB	 0
$LN120@ColorPicke:
  0297e	76		 DB	 118			; 00000076H
  0297f	76		 DB	 118			; 00000076H
  02980	00		 DB	 0
$LN119@ColorPicke:
  02981	75		 DB	 117			; 00000075H
  02982	75		 DB	 117			; 00000075H
  02983	00		 DB	 0
$LN118@ColorPicke:
  02984	63		 DB	 99			; 00000063H
  02985	75		 DB	 117			; 00000075H
  02986	72		 DB	 114			; 00000072H
  02987	72		 DB	 114			; 00000072H
  02988	65		 DB	 101			; 00000065H
  02989	6e		 DB	 110			; 0000006eH
  0298a	74		 DB	 116			; 00000074H
  0298b	5f		 DB	 95			; 0000005fH
  0298c	6f		 DB	 111			; 0000006fH
  0298d	66		 DB	 102			; 00000066H
  0298e	66		 DB	 102			; 00000066H
  0298f	5f		 DB	 95			; 0000005fH
  02990	75		 DB	 117			; 00000075H
  02991	6e		 DB	 110			; 0000006eH
  02992	72		 DB	 114			; 00000072H
  02993	6f		 DB	 111			; 0000006fH
  02994	74		 DB	 116			; 00000074H
  02995	61		 DB	 97			; 00000061H
  02996	74		 DB	 116			; 00000074H
  02997	65		 DB	 101			; 00000065H
  02998	64		 DB	 100			; 00000064H
  02999	00		 DB	 0
$LN117@ColorPicke:
  0299a	63		 DB	 99			; 00000063H
  0299b	75		 DB	 117			; 00000075H
  0299c	72		 DB	 114			; 00000072H
  0299d	72		 DB	 114			; 00000072H
  0299e	65		 DB	 101			; 00000065H
  0299f	6e		 DB	 110			; 0000006eH
  029a0	74		 DB	 116			; 00000074H
  029a1	5f		 DB	 95			; 0000005fH
  029a2	6f		 DB	 111			; 0000006fH
  029a3	66		 DB	 102			; 00000066H
  029a4	66		 DB	 102			; 00000066H
  029a5	00		 DB	 0
$LN116@ColorPicke:
  029a6	69		 DB	 105			; 00000069H
  029a7	6e		 DB	 110			; 0000006eH
  029a8	69		 DB	 105			; 00000069H
  029a9	74		 DB	 116			; 00000074H
  029aa	69		 DB	 105			; 00000069H
  029ab	61		 DB	 97			; 00000061H
  029ac	6c		 DB	 108			; 0000006cH
  029ad	5f		 DB	 95			; 0000005fH
  029ae	6f		 DB	 111			; 0000006fH
  029af	66		 DB	 102			; 00000066H
  029b0	66		 DB	 102			; 00000066H
  029b1	00		 DB	 0
$LN115@ColorPicke:
  029b2	42		 DB	 66			; 00000042H
  029b3	00		 DB	 0
$LN114@ColorPicke:
  029b4	47		 DB	 71			; 00000047H
  029b5	00		 DB	 0
$LN113@ColorPicke:
  029b6	52		 DB	 82			; 00000052H
  029b7	00		 DB	 0
$LN112@ColorPicke:
  029b8	56		 DB	 86			; 00000056H
  029b9	00		 DB	 0
$LN111@ColorPicke:
  029ba	53		 DB	 83			; 00000053H
  029bb	00		 DB	 0
$LN110@ColorPicke:
  029bc	48		 DB	 72			; 00000048H
  029bd	00		 DB	 0
$LN109@ColorPicke:
  029be	74		 DB	 116			; 00000074H
  029bf	72		 DB	 114			; 00000072H
  029c0	69		 DB	 105			; 00000069H
  029c1	61		 DB	 97			; 00000061H
  029c2	6e		 DB	 110			; 0000006eH
  029c3	67		 DB	 103			; 00000067H
  029c4	6c		 DB	 108			; 0000006cH
  029c5	65		 DB	 101			; 00000065H
  029c6	5f		 DB	 95			; 0000005fH
  029c7	70		 DB	 112			; 00000070H
  029c8	63		 DB	 99			; 00000063H
  029c9	00		 DB	 0
$LN108@ColorPicke:
  029ca	74		 DB	 116			; 00000074H
  029cb	72		 DB	 114			; 00000072H
  029cc	69		 DB	 105			; 00000069H
  029cd	61		 DB	 97			; 00000061H
  029ce	6e		 DB	 110			; 0000006eH
  029cf	67		 DB	 103			; 00000067H
  029d0	6c		 DB	 108			; 0000006cH
  029d1	65		 DB	 101			; 00000065H
  029d2	5f		 DB	 95			; 0000005fH
  029d3	70		 DB	 112			; 00000070H
  029d4	62		 DB	 98			; 00000062H
  029d5	00		 DB	 0
$LN107@ColorPicke:
  029d6	74		 DB	 116			; 00000074H
  029d7	72		 DB	 114			; 00000072H
  029d8	69		 DB	 105			; 00000069H
  029d9	61		 DB	 97			; 00000061H
  029da	6e		 DB	 110			; 0000006eH
  029db	67		 DB	 103			; 00000067H
  029dc	6c		 DB	 108			; 0000006cH
  029dd	65		 DB	 101			; 00000065H
  029de	5f		 DB	 95			; 0000005fH
  029df	70		 DB	 112			; 00000070H
  029e0	61		 DB	 97			; 00000061H
  029e1	00		 DB	 0
$LN106@ColorPicke:
  029e2	77		 DB	 119			; 00000077H
  029e3	68		 DB	 104			; 00000068H
  029e4	65		 DB	 101			; 00000065H
  029e5	65		 DB	 101			; 00000065H
  029e6	6c		 DB	 108			; 0000006cH
  029e7	5f		 DB	 95			; 0000005fH
  029e8	63		 DB	 99			; 00000063H
  029e9	65		 DB	 101			; 00000065H
  029ea	6e		 DB	 110			; 0000006eH
  029eb	74		 DB	 116			; 00000074H
  029ec	65		 DB	 101			; 00000065H
  029ed	72		 DB	 114			; 00000072H
  029ee	00		 DB	 0
$LN105@ColorPicke:
  029ef	62		 DB	 98			; 00000062H
  029f0	61		 DB	 97			; 00000061H
  029f1	63		 DB	 99			; 00000063H
  029f2	6b		 DB	 107			; 0000006bH
  029f3	75		 DB	 117			; 00000075H
  029f4	70		 DB	 112			; 00000070H
  029f5	5f		 DB	 95			; 0000005fH
  029f6	69		 DB	 105			; 00000069H
  029f7	6e		 DB	 110			; 0000006eH
  029f8	69		 DB	 105			; 00000069H
  029f9	74		 DB	 116			; 00000074H
  029fa	69		 DB	 105			; 00000069H
  029fb	61		 DB	 97			; 00000061H
  029fc	6c		 DB	 108			; 0000006cH
  029fd	5f		 DB	 95			; 0000005fH
  029fe	63		 DB	 99			; 00000063H
  029ff	6f		 DB	 111			; 0000006fH
  02a00	6c		 DB	 108			; 0000006cH
  02a01	00		 DB	 0
$LN104@ColorPicke:
  02a02	70		 DB	 112			; 00000070H
  02a03	69		 DB	 105			; 00000069H
  02a04	63		 DB	 99			; 00000063H
  02a05	6b		 DB	 107			; 0000006bH
  02a06	65		 DB	 101			; 00000065H
  02a07	72		 DB	 114			; 00000072H
  02a08	5f		 DB	 95			; 0000005fH
  02a09	70		 DB	 112			; 00000070H
  02a0a	6f		 DB	 111			; 0000006fH
  02a0b	73		 DB	 115			; 00000073H
  02a0c	00		 DB	 0
?ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z ENDP		; ImGui::ColorPicker4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorPicker3@ImGui@@YA_NPBDQAMH@Z
_TEXT	SEGMENT
_col4$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_col$ = 12						; size = 4
_flags$ = 16						; size = 4
?ColorPicker3@ImGui@@YA_NPBDQAMH@Z PROC			; ImGui::ColorPicker3, COMDAT

; 4412 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4413 :     float col4[4] = { col[0], col[1], col[2], 1.0f };

  00032	b8 04 00 00 00	 mov	 eax, 4
  00037	6b c8 00	 imul	 ecx, eax, 0
  0003a	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  0003d	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00042	f3 0f 11 45 e8	 movss	 DWORD PTR _col4$[ebp], xmm0
  00047	b8 04 00 00 00	 mov	 eax, 4
  0004c	c1 e0 00	 shl	 eax, 0
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00052	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00057	f3 0f 11 45 ec	 movss	 DWORD PTR _col4$[ebp+4], xmm0
  0005c	b8 04 00 00 00	 mov	 eax, 4
  00061	d1 e0		 shl	 eax, 1
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00066	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0006b	f3 0f 11 45 f0	 movss	 DWORD PTR _col4$[ebp+8], xmm0
  00070	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00078	f3 0f 11 45 f4	 movss	 DWORD PTR _col4$[ebp+12], xmm0

; 4414 :     if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))

  0007d	6a 00		 push	 0
  0007f	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00082	83 c8 02	 or	 eax, 2
  00085	50		 push	 eax
  00086	8d 4d e8	 lea	 ecx, DWORD PTR _col4$[ebp]
  00089	51		 push	 ecx
  0008a	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 ?ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z ; ImGui::ColorPicker4
  00093	83 c4 10	 add	 esp, 16			; 00000010H
  00096	0f b6 c0	 movzx	 eax, al
  00099	85 c0		 test	 eax, eax
  0009b	75 04		 jne	 SHORT $LN2@ColorPicke

; 4415 :         return false;

  0009d	32 c0		 xor	 al, al
  0009f	eb 4e		 jmp	 SHORT $LN1@ColorPicke
$LN2@ColorPicke:

; 4416 :     col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];

  000a1	b8 04 00 00 00	 mov	 eax, 4
  000a6	6b c8 00	 imul	 ecx, eax, 0
  000a9	ba 04 00 00 00	 mov	 edx, 4
  000ae	6b c2 00	 imul	 eax, edx, 0
  000b1	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  000b4	8b 4c 0d e8	 mov	 ecx, DWORD PTR _col4$[ebp+ecx]
  000b8	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
  000bb	b8 04 00 00 00	 mov	 eax, 4
  000c0	c1 e0 00	 shl	 eax, 0
  000c3	b9 04 00 00 00	 mov	 ecx, 4
  000c8	c1 e1 00	 shl	 ecx, 0
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  000ce	8b 44 05 e8	 mov	 eax, DWORD PTR _col4$[ebp+eax]
  000d2	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  000d5	b8 04 00 00 00	 mov	 eax, 4
  000da	d1 e0		 shl	 eax, 1
  000dc	b9 04 00 00 00	 mov	 ecx, 4
  000e1	d1 e1		 shl	 ecx, 1
  000e3	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  000e6	8b 44 05 e8	 mov	 eax, DWORD PTR _col4$[ebp+eax]
  000ea	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 4417 :     return true;

  000ed	b0 01		 mov	 al, 1
$LN1@ColorPicke:

; 4418 : }

  000ef	52		 push	 edx
  000f0	8b cd		 mov	 ecx, ebp
  000f2	50		 push	 eax
  000f3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@ColorPicke
  000f9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fe	58		 pop	 eax
  000ff	5a		 pop	 edx
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00113	3b ec		 cmp	 ebp, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
  0011e	66 90		 npad	 2
$LN6@ColorPicke:
  00120	01 00 00 00	 DD	 1
  00124	00 00 00 00	 DD	 $LN5@ColorPicke
$LN5@ColorPicke:
  00128	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0012c	10 00 00 00	 DD	 16			; 00000010H
  00130	00 00 00 00	 DD	 $LN4@ColorPicke
$LN4@ColorPicke:
  00134	63		 DB	 99			; 00000063H
  00135	6f		 DB	 111			; 0000006fH
  00136	6c		 DB	 108			; 0000006cH
  00137	34		 DB	 52			; 00000034H
  00138	00		 DB	 0
?ColorPicker3@ImGui@@YA_NPBDQAMH@Z ENDP			; ImGui::ColorPicker3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorEdit4@ImGui@@YA_NPBDQAMH@Z
_TEXT	SEGMENT
tv447 = -1048						; size = 4
tv415 = -1048						; size = 4
tv440 = -1044						; size = 4
tv408 = -1044						; size = 4
tv374 = -1044						; size = 4
tv371 = -1041						; size = 1
tv604 = -1040						; size = 4
tv589 = -1040						; size = 4
tv443 = -1040						; size = 4
tv411 = -1040						; size = 4
tv387 = -1040						; size = 4
tv377 = -1040						; size = 4
tv366 = -1040						; size = 4
tv322 = -1040						; size = 4
tv281 = -1040						; size = 4
tv271 = -1040						; size = 4
tv261 = -1040						; size = 4
tv251 = -1040						; size = 4
tv188 = -1040						; size = 4
tv177 = -1040						; size = 4
tv77 = -1040						; size = 4
tv395 = -1037						; size = 1
tv174 = -1037						; size = 1
tv171 = -1037						; size = 1
$T1 = -1032						; size = 8
$T2 = -1016						; size = 8
$T3 = -1000						; size = 8
$T4 = -984						; size = 8
$T5 = -968						; size = 8
$T6 = -952						; size = 8
$T7 = -936						; size = 8
$T8 = -920						; size = 8
_payload$9 = -520					; size = 4
_payload$10 = -508					; size = 4
_accepted_drag_drop$11 = -493				; size = 1
_n$12 = -484						; size = 4
_picker_flags$13 = -472					; size = 4
_picker_flags_to_forward$14 = -460			; size = 4
_col_v4$15 = -448					; size = 16
_button_offset_x$16 = -424				; size = 4
_picker_active_window$ = -412				; size = 4
_p$17 = -400						; size = 4
_buf$18 = -388						; size = 64
_disable_hue_edit$19 = -313				; size = 1
_n$20 = -304						; size = 4
_fmt_idx$21 = -292					; size = 4
_hide_prefix$22 = -277					; size = 1
_w_item_last$23 = -268					; size = 4
_w_item_one$24 = -256					; size = 4
_inputs_offset_x$ = -244				; size = 4
_pos$ = -232						; size = 8
_value_changed_as_float$ = -213				; size = 1
_value_changed$ = -201					; size = 1
_i$ = -192						; size = 16
_f$ = -168						; size = 16
_components$ = -144					; size = 4
_hdr$ = -129						; size = 1
_alpha$ = -117						; size = 1
_flags_untouched$ = -108				; size = 4
_label_display_end$ = -96				; size = 4
_w_inputs$ = -84					; size = 4
_w_button$ = -72					; size = 4
_w_full$ = -60						; size = 4
_square_sz$ = -48					; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_col$ = 12						; size = 4
_flags$ = 16						; size = 4
?ColorEdit4@ImGui@@YA_NPBDQAMH@Z PROC			; ImGui::ColorEdit4, COMDAT

; 4181 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 04 00
	00		 sub	 esp, 1048		; 00000418H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1048]
  00012	b9 06 01 00 00	 mov	 ecx, 262		; 00000106H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4182 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 4183 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN10@ColorEdit4

; 4184 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 25 15 00 00	 jmp	 $LN1@ColorEdit4
$LN10@ColorEdit4:

; 4185 : 
; 4186 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 4187 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 4188 :     const float square_sz = GetFrameHeight();

  0005f	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  00064	d9 5d d0	 fstp	 DWORD PTR _square_sz$[ebp]

; 4189 :     const float w_full = CalcItemWidth();

  00067	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  0006c	d9 5d c4	 fstp	 DWORD PTR _w_full$[ebp]

; 4190 :     const float w_button = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);

  0006f	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00072	83 e0 10	 and	 eax, 16			; 00000010H
  00075	74 0d		 je	 SHORT $LN54@ColorEdit4
  00077	0f 57 c0	 xorps	 xmm0, xmm0
  0007a	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv77[ebp], xmm0
  00082	eb 15		 jmp	 SHORT $LN55@ColorEdit4
$LN54@ColorEdit4:
  00084	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00087	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  0008c	f3 0f 58 41 50	 addss	 xmm0, DWORD PTR [ecx+80]
  00091	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv77[ebp], xmm0
$LN55@ColorEdit4:
  00099	f3 0f 10 85 f0
	fb ff ff	 movss	 xmm0, DWORD PTR tv77[ebp]
  000a1	f3 0f 11 45 b8	 movss	 DWORD PTR _w_button$[ebp], xmm0

; 4191 :     const float w_inputs = w_full - w_button;

  000a6	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _w_full$[ebp]
  000ab	f3 0f 5c 45 b8	 subss	 xmm0, DWORD PTR _w_button$[ebp]
  000b0	f3 0f 11 45 ac	 movss	 DWORD PTR _w_inputs$[ebp], xmm0

; 4192 :     const char* label_display_end = FindRenderedTextEnd(label);

  000b5	6a 00		 push	 0
  000b7	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  000c0	83 c4 08	 add	 esp, 8
  000c3	89 45 a0	 mov	 DWORD PTR _label_display_end$[ebp], eax

; 4193 :     g.NextItemData.ClearFlags();

  000c6	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  000c9	81 c1 84 1a 00
	00		 add	 ecx, 6788		; 00001a84H
  000cf	e8 00 00 00 00	 call	 ?ClearFlags@ImGuiNextItemData@@QAEXXZ ; ImGuiNextItemData::ClearFlags

; 4194 : 
; 4195 :     BeginGroup();

  000d4	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 4196 :     PushID(label);

  000d9	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  000e2	83 c4 04	 add	 esp, 4

; 4197 : 
; 4198 :     // If we're not showing any slider there's no point in doing any HSV conversions
; 4199 :     const ImGuiColorEditFlags flags_untouched = flags;

  000e5	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000e8	89 45 94	 mov	 DWORD PTR _flags_untouched$[ebp], eax

; 4200 :     if (flags & ImGuiColorEditFlags_NoInputs)

  000eb	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000ee	83 e0 20	 and	 eax, 32			; 00000020H
  000f1	74 13		 je	 SHORT $LN11@ColorEdit4

; 4201 :         flags = (flags & (~ImGuiColorEditFlags__DisplayMask)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;

  000f3	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000f6	25 ff ff 8f ff	 and	 eax, -7340033		; ff8fffffH
  000fb	0d 00 00 10 00	 or	 eax, 1048576		; 00100000H
  00100	83 c8 08	 or	 eax, 8
  00103	89 45 10	 mov	 DWORD PTR _flags$[ebp], eax
$LN11@ColorEdit4:

; 4202 : 
; 4203 :     // Context menu: display and modify options (before defaults are applied)
; 4204 :     if (!(flags & ImGuiColorEditFlags_NoOptions))

  00106	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00109	83 e0 08	 and	 eax, 8
  0010c	75 10		 jne	 SHORT $LN12@ColorEdit4

; 4205 :         ColorEditOptionsPopup(col, flags);

  0010e	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00111	50		 push	 eax
  00112	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 ?ColorEditOptionsPopup@ImGui@@YAXPBMH@Z ; ImGui::ColorEditOptionsPopup
  0011b	83 c4 08	 add	 esp, 8
$LN12@ColorEdit4:

; 4206 : 
; 4207 :     // Read stored options
; 4208 :     if (!(flags & ImGuiColorEditFlags__DisplayMask))

  0011e	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00121	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  00126	75 15		 jne	 SHORT $LN13@ColorEdit4

; 4209 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DisplayMask);

  00128	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0012b	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  00131	81 e1 00 00 70
	00		 and	 ecx, 7340032		; 00700000H
  00137	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  0013a	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx
$LN13@ColorEdit4:

; 4210 :     if (!(flags & ImGuiColorEditFlags__DataTypeMask))

  0013d	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00140	25 00 00 80 01	 and	 eax, 25165824		; 01800000H
  00145	75 15		 jne	 SHORT $LN14@ColorEdit4

; 4211 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);

  00147	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0014a	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  00150	81 e1 00 00 80
	01		 and	 ecx, 25165824		; 01800000H
  00156	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  00159	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx
$LN14@ColorEdit4:

; 4212 :     if (!(flags & ImGuiColorEditFlags__PickerMask))

  0015c	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0015f	25 00 00 00 06	 and	 eax, 100663296		; 06000000H
  00164	75 15		 jne	 SHORT $LN15@ColorEdit4

; 4213 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);

  00166	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00169	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  0016f	81 e1 00 00 00
	06		 and	 ecx, 100663296		; 06000000H
  00175	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  00178	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx
$LN15@ColorEdit4:

; 4214 :     if (!(flags & ImGuiColorEditFlags__InputMask))

  0017b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0017e	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  00183	75 15		 jne	 SHORT $LN16@ColorEdit4

; 4215 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputMask);

  00185	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00188	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  0018e	81 e1 00 00 00
	18		 and	 ecx, 402653184		; 18000000H
  00194	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  00197	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx
$LN16@ColorEdit4:

; 4216 :     flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__DisplayMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask));

  0019a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0019d	8b 88 d4 2c 00
	00		 mov	 ecx, DWORD PTR [eax+11476]
  001a3	81 e1 ff ff 0f
	e0		 and	 ecx, -535822337		; e00fffffH
  001a9	0b 4d 10	 or	 ecx, DWORD PTR _flags$[ebp]
  001ac	89 4d 10	 mov	 DWORD PTR _flags$[ebp], ecx

; 4217 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DisplayMask)); // Check that only 1 is selected

  001af	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001b2	25 00 00 70 00	 and	 eax, 7340032		; 00700000H
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  001bd	83 c4 04	 add	 esp, 4
  001c0	0f b6 c8	 movzx	 ecx, al
  001c3	85 c9		 test	 ecx, ecx
  001c5	75 26		 jne	 SHORT $LN56@ColorEdit4
  001c7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4JA
  001cd	83 c2 24	 add	 edx, 36			; 00000024H
  001d0	8b f4		 mov	 esi, esp
  001d2	52		 push	 edx
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_1HC@IFIJNDDD@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e6	3b f4		 cmp	 esi, esp
  001e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN56@ColorEdit4:

; 4218 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));   // Check that only 1 is selected

  001ed	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  001f0	25 00 00 00 18	 and	 eax, 402653184		; 18000000H
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  001fb	83 c4 04	 add	 esp, 4
  001fe	0f b6 c8	 movzx	 ecx, al
  00201	85 c9		 test	 ecx, ecx
  00203	75 26		 jne	 SHORT $LN57@ColorEdit4
  00205	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4JA
  0020b	83 c2 25	 add	 edx, 37			; 00000025H
  0020e	8b f4		 mov	 esi, esp
  00210	52		 push	 edx
  00211	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00216	68 00 00 00 00	 push	 OFFSET ??_C@_1GO@CDHIBPHM@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH
  00224	3b f4		 cmp	 esi, esp
  00226	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN57@ColorEdit4:

; 4219 : 
; 4220 :     const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;

  0022b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0022e	83 e0 02	 and	 eax, 2
  00231	75 09		 jne	 SHORT $LN58@ColorEdit4
  00233	c6 85 f3 fb ff
	ff 01		 mov	 BYTE PTR tv171[ebp], 1
  0023a	eb 07		 jmp	 SHORT $LN59@ColorEdit4
$LN58@ColorEdit4:
  0023c	c6 85 f3 fb ff
	ff 00		 mov	 BYTE PTR tv171[ebp], 0
$LN59@ColorEdit4:
  00243	8a 8d f3 fb ff
	ff		 mov	 cl, BYTE PTR tv171[ebp]
  00249	88 4d 8b	 mov	 BYTE PTR _alpha$[ebp], cl

; 4221 :     const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;

  0024c	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0024f	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00254	74 09		 je	 SHORT $LN60@ColorEdit4
  00256	c6 85 f3 fb ff
	ff 01		 mov	 BYTE PTR tv174[ebp], 1
  0025d	eb 07		 jmp	 SHORT $LN61@ColorEdit4
$LN60@ColorEdit4:
  0025f	c6 85 f3 fb ff
	ff 00		 mov	 BYTE PTR tv174[ebp], 0
$LN61@ColorEdit4:
  00266	8a 8d f3 fb ff
	ff		 mov	 cl, BYTE PTR tv174[ebp]
  0026c	88 8d 7f ff ff
	ff		 mov	 BYTE PTR _hdr$[ebp], cl

; 4222 :     const int components = alpha ? 4 : 3;

  00272	0f b6 45 8b	 movzx	 eax, BYTE PTR _alpha$[ebp]
  00276	85 c0		 test	 eax, eax
  00278	74 0c		 je	 SHORT $LN62@ColorEdit4
  0027a	c7 85 f0 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR tv177[ebp], 4
  00284	eb 0a		 jmp	 SHORT $LN63@ColorEdit4
$LN62@ColorEdit4:
  00286	c7 85 f0 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR tv177[ebp], 3
$LN63@ColorEdit4:
  00290	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR tv177[ebp]
  00296	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _components$[ebp], ecx

; 4223 : 
; 4224 :     // Convert to the formats we need
; 4225 :     float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };

  0029c	b8 04 00 00 00	 mov	 eax, 4
  002a1	6b c8 00	 imul	 ecx, eax, 0
  002a4	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  002a7	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  002ac	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
  002b4	b8 04 00 00 00	 mov	 eax, 4
  002b9	c1 e0 00	 shl	 eax, 0
  002bc	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  002bf	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002c4	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _f$[ebp+4], xmm0
  002cc	b8 04 00 00 00	 mov	 eax, 4
  002d1	d1 e0		 shl	 eax, 1
  002d3	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  002d6	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002db	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _f$[ebp+8], xmm0
  002e3	0f b6 45 8b	 movzx	 eax, BYTE PTR _alpha$[ebp]
  002e7	85 c0		 test	 eax, eax
  002e9	74 1a		 je	 SHORT $LN64@ColorEdit4
  002eb	b9 04 00 00 00	 mov	 ecx, 4
  002f0	6b d1 03	 imul	 edx, ecx, 3
  002f3	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  002f6	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  002fb	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv188[ebp], xmm0
  00303	eb 10		 jmp	 SHORT $LN65@ColorEdit4
$LN64@ColorEdit4:
  00305	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0030d	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv188[ebp], xmm0
$LN65@ColorEdit4:
  00315	f3 0f 10 85 f0
	fb ff ff	 movss	 xmm0, DWORD PTR tv188[ebp]
  0031d	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _f$[ebp+12], xmm0

; 4226 :     if ((flags & ImGuiColorEditFlags_InputHSV) && (flags & ImGuiColorEditFlags_DisplayRGB))

  00325	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00328	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0032d	0f 84 8e 00 00
	00		 je	 $LN17@ColorEdit4
  00333	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00336	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  0033b	0f 84 80 00 00
	00		 je	 $LN17@ColorEdit4

; 4227 :         ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);

  00341	b8 04 00 00 00	 mov	 eax, 4
  00346	d1 e0		 shl	 eax, 1
  00348	8d 8c 05 58 ff
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+eax]
  0034f	51		 push	 ecx
  00350	ba 04 00 00 00	 mov	 edx, 4
  00355	c1 e2 00	 shl	 edx, 0
  00358	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  0035f	50		 push	 eax
  00360	b9 04 00 00 00	 mov	 ecx, 4
  00365	6b d1 00	 imul	 edx, ecx, 0
  00368	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  0036f	50		 push	 eax
  00370	b9 04 00 00 00	 mov	 ecx, 4
  00375	d1 e1		 shl	 ecx, 1
  00377	51		 push	 ecx
  00378	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  00381	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00386	ba 04 00 00 00	 mov	 edx, 4
  0038b	c1 e2 00	 shl	 edx, 0
  0038e	51		 push	 ecx
  0038f	f3 0f 10 84 15
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+edx]
  00398	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039d	b8 04 00 00 00	 mov	 eax, 4
  003a2	6b c8 00	 imul	 ecx, eax, 0
  003a5	51		 push	 ecx
  003a6	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  003af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b4	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  003b9	83 c4 18	 add	 esp, 24			; 00000018H
  003bc	e9 e9 00 00 00	 jmp	 $LN20@ColorEdit4
$LN17@ColorEdit4:

; 4228 :     else if ((flags & ImGuiColorEditFlags_InputRGB) && (flags & ImGuiColorEditFlags_DisplayHSV))

  003c1	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  003c4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003c9	0f 84 db 00 00
	00		 je	 $LN20@ColorEdit4
  003cf	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  003d2	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  003d7	0f 84 cd 00 00
	00		 je	 $LN20@ColorEdit4

; 4229 :     {
; 4230 :         // Hue is lost when converting from greyscale rgb (saturation=0). Restore it.
; 4231 :         ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

  003dd	b8 04 00 00 00	 mov	 eax, 4
  003e2	d1 e0		 shl	 eax, 1
  003e4	8d 8c 05 58 ff
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+eax]
  003eb	51		 push	 ecx
  003ec	ba 04 00 00 00	 mov	 edx, 4
  003f1	c1 e2 00	 shl	 edx, 0
  003f4	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  003fb	50		 push	 eax
  003fc	b9 04 00 00 00	 mov	 ecx, 4
  00401	6b d1 00	 imul	 edx, ecx, 0
  00404	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  0040b	50		 push	 eax
  0040c	b9 04 00 00 00	 mov	 ecx, 4
  00411	d1 e1		 shl	 ecx, 1
  00413	51		 push	 ecx
  00414	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  0041d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00422	ba 04 00 00 00	 mov	 edx, 4
  00427	c1 e2 00	 shl	 edx, 0
  0042a	51		 push	 ecx
  0042b	f3 0f 10 84 15
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+edx]
  00434	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00439	b8 04 00 00 00	 mov	 eax, 4
  0043e	6b c8 00	 imul	 ecx, eax, 0
  00441	51		 push	 ecx
  00442	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  0044b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00450	e8 00 00 00 00	 call	 ?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertRGBtoHSV
  00455	83 c4 18	 add	 esp, 24			; 00000018H

; 4232 :         if (f[1] == 0 && memcmp(g.ColorEditLastColor, col, sizeof(float) * 3) == 0)

  00458	b8 04 00 00 00	 mov	 eax, 4
  0045d	c1 e0 00	 shl	 eax, 0
  00460	f3 0f 10 84 05
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+eax]
  00469	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00470	9f		 lahf
  00471	f6 c4 44	 test	 ah, 68			; 00000044H
  00474	7a 34		 jp	 SHORT $LN20@ColorEdit4
  00476	6a 0c		 push	 12			; 0000000cH
  00478	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  0047b	50		 push	 eax
  0047c	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  0047f	81 c1 dc 2c 00
	00		 add	 ecx, 11484		; 00002cdcH
  00485	51		 push	 ecx
  00486	e8 00 00 00 00	 call	 _memcmp
  0048b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0048e	85 c0		 test	 eax, eax
  00490	75 18		 jne	 SHORT $LN20@ColorEdit4

; 4233 :             f[0] = g.ColorEditLastHue;

  00492	b8 04 00 00 00	 mov	 eax, 4
  00497	6b c8 00	 imul	 ecx, eax, 0
  0049a	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  0049d	8b 82 d8 2c 00
	00		 mov	 eax, DWORD PTR [edx+11480]
  004a3	89 84 0d 58 ff
	ff ff		 mov	 DWORD PTR _f$[ebp+ecx], eax
$LN20@ColorEdit4:

; 4234 :     }
; 4235 :     int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

  004aa	b8 04 00 00 00	 mov	 eax, 4
  004af	6b c8 00	 imul	 ecx, eax, 0
  004b2	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  004bb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  004c2	72 12		 jb	 SHORT $LN66@ColorEdit4
  004c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  004cc	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv251[ebp], xmm0
  004d4	eb 10		 jmp	 SHORT $LN67@ColorEdit4
$LN66@ColorEdit4:
  004d6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf000000
  004de	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv251[ebp], xmm0
$LN67@ColorEdit4:
  004e6	ba 04 00 00 00	 mov	 edx, 4
  004eb	6b c2 00	 imul	 eax, edx, 0
  004ee	f3 0f 10 84 05
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+eax]
  004f7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  004ff	f3 0f 58 85 f0
	fb ff ff	 addss	 xmm0, DWORD PTR tv251[ebp]
  00507	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0050b	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], ecx
  00511	b8 04 00 00 00	 mov	 eax, 4
  00516	c1 e0 00	 shl	 eax, 0
  00519	f3 0f 10 84 05
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+eax]
  00522	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00529	72 12		 jb	 SHORT $LN68@ColorEdit4
  0052b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00533	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv261[ebp], xmm0
  0053b	eb 10		 jmp	 SHORT $LN69@ColorEdit4
$LN68@ColorEdit4:
  0053d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf000000
  00545	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv261[ebp], xmm0
$LN69@ColorEdit4:
  0054d	b9 04 00 00 00	 mov	 ecx, 4
  00552	c1 e1 00	 shl	 ecx, 0
  00555	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  0055e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00566	f3 0f 58 85 f0
	fb ff ff	 addss	 xmm0, DWORD PTR tv261[ebp]
  0056e	f3 0f 2c d0	 cvttss2si edx, xmm0
  00572	89 95 44 ff ff
	ff		 mov	 DWORD PTR _i$[ebp+4], edx
  00578	b8 04 00 00 00	 mov	 eax, 4
  0057d	d1 e0		 shl	 eax, 1
  0057f	f3 0f 10 84 05
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+eax]
  00588	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0058f	72 12		 jb	 SHORT $LN70@ColorEdit4
  00591	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00599	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv271[ebp], xmm0
  005a1	eb 10		 jmp	 SHORT $LN71@ColorEdit4
$LN70@ColorEdit4:
  005a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf000000
  005ab	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv271[ebp], xmm0
$LN71@ColorEdit4:
  005b3	b9 04 00 00 00	 mov	 ecx, 4
  005b8	d1 e1		 shl	 ecx, 1
  005ba	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  005c3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  005cb	f3 0f 58 85 f0
	fb ff ff	 addss	 xmm0, DWORD PTR tv271[ebp]
  005d3	f3 0f 2c d0	 cvttss2si edx, xmm0
  005d7	89 95 48 ff ff
	ff		 mov	 DWORD PTR _i$[ebp+8], edx
  005dd	b8 04 00 00 00	 mov	 eax, 4
  005e2	6b c8 03	 imul	 ecx, eax, 3
  005e5	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  005ee	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  005f5	72 12		 jb	 SHORT $LN72@ColorEdit4
  005f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  005ff	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv281[ebp], xmm0
  00607	eb 10		 jmp	 SHORT $LN73@ColorEdit4
$LN72@ColorEdit4:
  00609	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf000000
  00611	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv281[ebp], xmm0
$LN73@ColorEdit4:
  00619	ba 04 00 00 00	 mov	 edx, 4
  0061e	6b c2 03	 imul	 eax, edx, 3
  00621	f3 0f 10 84 05
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+eax]
  0062a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00632	f3 0f 58 85 f0
	fb ff ff	 addss	 xmm0, DWORD PTR tv281[ebp]
  0063a	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0063e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _i$[ebp+12], ecx

; 4236 : 
; 4237 :     bool value_changed = false;

  00644	c6 85 37 ff ff
	ff 00		 mov	 BYTE PTR _value_changed$[ebp], 0

; 4238 :     bool value_changed_as_float = false;

  0064b	c6 85 2b ff ff
	ff 00		 mov	 BYTE PTR _value_changed_as_float$[ebp], 0

; 4239 : 
; 4240 :     const ImVec2 pos = window->DC.CursorPos;

  00652	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00655	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0065b	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00661	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _pos$[ebp], ecx
  00667	89 95 1c ff ff
	ff		 mov	 DWORD PTR _pos$[ebp+4], edx

; 4241 :     const float inputs_offset_x = (style.ColorButtonPosition == ImGuiDir_Left) ? w_button : 0.0f;

  0066d	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00670	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [eax+128], 0
  00677	75 0f		 jne	 SHORT $LN74@ColorEdit4
  00679	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _w_button$[ebp]
  0067e	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv322[ebp], xmm0
  00686	eb 0b		 jmp	 SHORT $LN75@ColorEdit4
$LN74@ColorEdit4:
  00688	0f 57 c0	 xorps	 xmm0, xmm0
  0068b	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv322[ebp], xmm0
$LN75@ColorEdit4:
  00693	f3 0f 10 85 f0
	fb ff ff	 movss	 xmm0, DWORD PTR tv322[ebp]
  0069b	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _inputs_offset_x$[ebp], xmm0

; 4242 :     window->DC.CursorPos.x = pos.x + inputs_offset_x;

  006a3	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp]
  006ab	f3 0f 58 85 0c
	ff ff ff	 addss	 xmm0, DWORD PTR _inputs_offset_x$[ebp]
  006b3	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  006b6	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0

; 4243 : 
; 4244 :     if ((flags & (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)

  006be	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  006c1	25 00 00 30 00	 and	 eax, 3145728		; 00300000H
  006c6	0f 84 6e 04 00
	00		 je	 $LN21@ColorEdit4
  006cc	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  006cf	83 e0 20	 and	 eax, 32			; 00000020H
  006d2	0f 85 62 04 00
	00		 jne	 $LN21@ColorEdit4

; 4245 :     {
; 4246 :         // RGB/HSV 0..255 Sliders
; 4247 :         const float w_item_one  = ImMax(1.0f, IM_FLOOR((w_inputs - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));

  006d8	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _components$[ebp]
  006de	83 e8 01	 sub	 eax, 1
  006e1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  006e5	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  006e8	f3 0f 59 41 50	 mulss	 xmm0, DWORD PTR [ecx+80]
  006ed	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _w_inputs$[ebp]
  006f2	f3 0f 5c c8	 subss	 xmm1, xmm0
  006f6	f3 0f 2a 85 70
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _components$[ebp]
  006fe	f3 0f 5e c8	 divss	 xmm1, xmm0
  00702	f3 0f 2c d1	 cvttss2si edx, xmm1
  00706	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0070a	51		 push	 ecx
  0070b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00710	51		 push	 ecx
  00711	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00719	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0071e	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00723	83 c4 08	 add	 esp, 8
  00726	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR _w_item_one$24[ebp]

; 4248 :         const float w_item_last = ImMax(1.0f, IM_FLOOR(w_inputs - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));

  0072c	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0072f	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _w_item_one$24[ebp]
  00737	f3 0f 58 40 50	 addss	 xmm0, DWORD PTR [eax+80]
  0073c	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _components$[ebp]
  00742	83 e9 01	 sub	 ecx, 1
  00745	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00749	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0074d	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _w_inputs$[ebp]
  00752	f3 0f 5c c8	 subss	 xmm1, xmm0
  00756	f3 0f 2c d1	 cvttss2si edx, xmm1
  0075a	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0075e	51		 push	 ecx
  0075f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00764	51		 push	 ecx
  00765	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0076d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00772	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00777	83 c4 08	 add	 esp, 8
  0077a	d9 9d f4 fe ff
	ff		 fstp	 DWORD PTR _w_item_last$23[ebp]

; 4249 : 
; 4250 :         const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);

  00780	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00783	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00788	74 0c		 je	 SHORT $LN76@ColorEdit4
  0078a	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv366[ebp], OFFSET ??_C@_07FFNLLALM@M?30?4000@
  00794	eb 0a		 jmp	 SHORT $LN77@ColorEdit4
$LN76@ColorEdit4:
  00796	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv366[ebp], OFFSET ??_C@_05BNGMMMAL@M?3000@
$LN77@ColorEdit4:
  007a0	51		 push	 ecx
  007a1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  007a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007ae	6a 00		 push	 0
  007b0	6a 00		 push	 0
  007b2	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR tv366[ebp]
  007b8	51		 push	 ecx
  007b9	8d 95 68 fc ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  007bf	52		 push	 edx
  007c0	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  007c5	83 c4 14	 add	 esp, 20			; 00000014H
  007c8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  007cc	0f 2f 85 00 ff
	ff ff		 comiss	 xmm0, DWORD PTR _w_item_one$24[ebp]
  007d3	72 09		 jb	 SHORT $LN78@ColorEdit4
  007d5	c6 85 ef fb ff
	ff 01		 mov	 BYTE PTR tv371[ebp], 1
  007dc	eb 07		 jmp	 SHORT $LN79@ColorEdit4
$LN78@ColorEdit4:
  007de	c6 85 ef fb ff
	ff 00		 mov	 BYTE PTR tv371[ebp], 0
$LN79@ColorEdit4:
  007e5	8a 85 ef fb ff
	ff		 mov	 al, BYTE PTR tv371[ebp]
  007eb	88 85 eb fe ff
	ff		 mov	 BYTE PTR _hide_prefix$22[ebp], al

; 4251 :         static const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
; 4252 :         static const char* fmt_table_int[3][4] =
; 4253 :         {
; 4254 :             {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
; 4255 :             { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
; 4256 :             { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
; 4257 :         };
; 4258 :         static const char* fmt_table_float[3][4] =
; 4259 :         {
; 4260 :             {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
; 4261 :             { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
; 4262 :             { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
; 4263 :         };
; 4264 :         const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;

  007f1	0f b6 85 eb fe
	ff ff		 movzx	 eax, BYTE PTR _hide_prefix$22[ebp]
  007f8	85 c0		 test	 eax, eax
  007fa	74 0c		 je	 SHORT $LN82@ColorEdit4
  007fc	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv377[ebp], 0
  00806	eb 2d		 jmp	 SHORT $LN83@ColorEdit4
$LN82@ColorEdit4:
  00808	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  0080b	81 e1 00 00 20
	00		 and	 ecx, 2097152		; 00200000H
  00811	74 0c		 je	 SHORT $LN80@ColorEdit4
  00813	c7 85 ec fb ff
	ff 02 00 00 00	 mov	 DWORD PTR tv374[ebp], 2
  0081d	eb 0a		 jmp	 SHORT $LN81@ColorEdit4
$LN80@ColorEdit4:
  0081f	c7 85 ec fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv374[ebp], 1
$LN81@ColorEdit4:
  00829	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR tv374[ebp]
  0082f	89 95 f0 fb ff
	ff		 mov	 DWORD PTR tv377[ebp], edx
$LN83@ColorEdit4:
  00835	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR tv377[ebp]
  0083b	89 85 dc fe ff
	ff		 mov	 DWORD PTR _fmt_idx$21[ebp], eax

; 4265 : 
; 4266 :         for (int n = 0; n < components; n++)

  00841	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$20[ebp], 0
  0084b	eb 0f		 jmp	 SHORT $LN4@ColorEdit4
$LN2@ColorEdit4:
  0084d	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _n$20[ebp]
  00853	83 c0 01	 add	 eax, 1
  00856	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _n$20[ebp], eax
$LN4@ColorEdit4:
  0085c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _n$20[ebp]
  00862	3b 85 70 ff ff
	ff		 cmp	 eax, DWORD PTR _components$[ebp]
  00868	0f 8d c7 02 00
	00		 jge	 $LN3@ColorEdit4

; 4267 :         {
; 4268 :             if (n > 0)

  0086e	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _n$20[ebp], 0
  00875	7e 1f		 jle	 SHORT $LN23@ColorEdit4

; 4269 :                 SameLine(0, style.ItemInnerSpacing.x);

  00877	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0087a	51		 push	 ecx
  0087b	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00880	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00885	51		 push	 ecx
  00886	0f 57 c0	 xorps	 xmm0, xmm0
  00889	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0088e	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00893	83 c4 08	 add	 esp, 8
$LN23@ColorEdit4:

; 4270 :             SetNextItemWidth((n + 1 < components) ? w_item_one : w_item_last);

  00896	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _n$20[ebp]
  0089c	83 c0 01	 add	 eax, 1
  0089f	3b 85 70 ff ff
	ff		 cmp	 eax, DWORD PTR _components$[ebp]
  008a5	7d 12		 jge	 SHORT $LN84@ColorEdit4
  008a7	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _w_item_one$24[ebp]
  008af	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv387[ebp], xmm0
  008b7	eb 10		 jmp	 SHORT $LN85@ColorEdit4
$LN84@ColorEdit4:
  008b9	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _w_item_last$23[ebp]
  008c1	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv387[ebp], xmm0
$LN85@ColorEdit4:
  008c9	51		 push	 ecx
  008ca	f3 0f 10 85 f0
	fb ff ff	 movss	 xmm0, DWORD PTR tv387[ebp]
  008d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d7	e8 00 00 00 00	 call	 ?SetNextItemWidth@ImGui@@YAXM@Z ; ImGui::SetNextItemWidth
  008dc	83 c4 04	 add	 esp, 4

; 4271 : 
; 4272 :             // Disable Hue edit when Saturation is zero
; 4273 :             const bool disable_hue_edit = (n == 0 && (flags & ImGuiColorEditFlags_DisplayHSV) && i[1] == 0);

  008df	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _n$20[ebp], 0
  008e6	75 25		 jne	 SHORT $LN86@ColorEdit4
  008e8	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  008eb	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  008f0	74 1b		 je	 SHORT $LN86@ColorEdit4
  008f2	b9 04 00 00 00	 mov	 ecx, 4
  008f7	c1 e1 00	 shl	 ecx, 0
  008fa	83 bc 0d 40 ff
	ff ff 00	 cmp	 DWORD PTR _i$[ebp+ecx], 0
  00902	75 09		 jne	 SHORT $LN86@ColorEdit4
  00904	c6 85 f3 fb ff
	ff 01		 mov	 BYTE PTR tv395[ebp], 1
  0090b	eb 07		 jmp	 SHORT $LN87@ColorEdit4
$LN86@ColorEdit4:
  0090d	c6 85 f3 fb ff
	ff 00		 mov	 BYTE PTR tv395[ebp], 0
$LN87@ColorEdit4:
  00914	8a 95 f3 fb ff
	ff		 mov	 dl, BYTE PTR tv395[ebp]
  0091a	88 95 c7 fe ff
	ff		 mov	 BYTE PTR _disable_hue_edit$19[ebp], dl

; 4274 :             if (flags & ImGuiColorEditFlags_Float)

  00920	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00923	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00928	0f 84 1d 01 00
	00		 je	 $LN24@ColorEdit4

; 4275 :             {
; 4276 :                 value_changed |= DragFloat(ids[n], &f[n], 1.0f/255.0f, disable_hue_edit ? +FLT_MAX : 0.0f, disable_hue_edit ? -FLT_MAX : hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);

  0092e	0f b6 85 c7 fe
	ff ff		 movzx	 eax, BYTE PTR _disable_hue_edit$19[ebp]
  00935	85 c0		 test	 eax, eax
  00937	74 12		 je	 SHORT $LN90@ColorEdit4
  00939	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  00941	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv411[ebp], xmm0
  00949	eb 38		 jmp	 SHORT $LN91@ColorEdit4
$LN90@ColorEdit4:
  0094b	0f b6 8d 7f ff
	ff ff		 movzx	 ecx, BYTE PTR _hdr$[ebp]
  00952	85 c9		 test	 ecx, ecx
  00954	74 0d		 je	 SHORT $LN88@ColorEdit4
  00956	0f 57 c0	 xorps	 xmm0, xmm0
  00959	f3 0f 11 85 ec
	fb ff ff	 movss	 DWORD PTR tv408[ebp], xmm0
  00961	eb 10		 jmp	 SHORT $LN89@ColorEdit4
$LN88@ColorEdit4:
  00963	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0096b	f3 0f 11 85 ec
	fb ff ff	 movss	 DWORD PTR tv408[ebp], xmm0
$LN89@ColorEdit4:
  00973	f3 0f 10 85 ec
	fb ff ff	 movss	 xmm0, DWORD PTR tv408[ebp]
  0097b	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv411[ebp], xmm0
$LN91@ColorEdit4:
  00983	0f b6 95 c7 fe
	ff ff		 movzx	 edx, BYTE PTR _disable_hue_edit$19[ebp]
  0098a	85 d2		 test	 edx, edx
  0098c	74 12		 je	 SHORT $LN92@ColorEdit4
  0098e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00996	f3 0f 11 85 e8
	fb ff ff	 movss	 DWORD PTR tv415[ebp], xmm0
  0099e	eb 0b		 jmp	 SHORT $LN93@ColorEdit4
$LN92@ColorEdit4:
  009a0	0f 57 c0	 xorps	 xmm0, xmm0
  009a3	f3 0f 11 85 e8
	fb ff ff	 movss	 DWORD PTR tv415[ebp], xmm0
$LN93@ColorEdit4:
  009ab	0f b6 9d 37 ff
	ff ff		 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  009b2	51		 push	 ecx
  009b3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009c0	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _fmt_idx$21[ebp]
  009c6	c1 e0 04	 shl	 eax, 4
  009c9	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _n$20[ebp]
  009cf	8b 94 88 00 00
	00 00		 mov	 edx, DWORD PTR ?fmt_table_float@?BL@??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4PAY03PBDA[eax+ecx*4]
  009d6	52		 push	 edx
  009d7	51		 push	 ecx
  009d8	f3 0f 10 85 f0
	fb ff ff	 movss	 xmm0, DWORD PTR tv411[ebp]
  009e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009e5	51		 push	 ecx
  009e6	f3 0f 10 85 e8
	fb ff ff	 movss	 xmm0, DWORD PTR tv415[ebp]
  009ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009f3	51		 push	 ecx
  009f4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3b808081
  009fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a01	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _n$20[ebp]
  00a07	8d 8c 85 58 ff
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+eax*4]
  00a0e	51		 push	 ecx
  00a0f	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _n$20[ebp]
  00a15	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ids@?BL@??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4PAPBDA[edx*4]
  00a1c	50		 push	 eax
  00a1d	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z ; ImGui::DragFloat
  00a22	83 c4 1c	 add	 esp, 28			; 0000001cH
  00a25	0f b6 c8	 movzx	 ecx, al
  00a28	0b d9		 or	 ebx, ecx
  00a2a	88 9d 37 ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], bl

; 4277 :                 value_changed_as_float |= value_changed;

  00a30	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _value_changed_as_float$[ebp]
  00a37	0f b6 8d 37 ff
	ff ff		 movzx	 ecx, BYTE PTR _value_changed$[ebp]
  00a3e	0b c1		 or	 eax, ecx
  00a40	88 85 2b ff ff
	ff		 mov	 BYTE PTR _value_changed_as_float$[ebp], al

; 4278 :             }

  00a46	e9 ce 00 00 00	 jmp	 $LN25@ColorEdit4
$LN24@ColorEdit4:

; 4279 :             else
; 4280 :             {
; 4281 :                 value_changed |= DragInt(ids[n], &i[n], 1.0f, disable_hue_edit ? INT_MAX : 0, disable_hue_edit ? INT_MIN : hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);

  00a4b	0f b6 85 c7 fe
	ff ff		 movzx	 eax, BYTE PTR _disable_hue_edit$19[ebp]
  00a52	85 c0		 test	 eax, eax
  00a54	74 0c		 je	 SHORT $LN96@ColorEdit4
  00a56	c7 85 f0 fb ff
	ff 00 00 00 80	 mov	 DWORD PTR tv443[ebp], -2147483648 ; 80000000H
  00a60	eb 2d		 jmp	 SHORT $LN97@ColorEdit4
$LN96@ColorEdit4:
  00a62	0f b6 8d 7f ff
	ff ff		 movzx	 ecx, BYTE PTR _hdr$[ebp]
  00a69	85 c9		 test	 ecx, ecx
  00a6b	74 0c		 je	 SHORT $LN94@ColorEdit4
  00a6d	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv440[ebp], 0
  00a77	eb 0a		 jmp	 SHORT $LN95@ColorEdit4
$LN94@ColorEdit4:
  00a79	c7 85 ec fb ff
	ff ff 00 00 00	 mov	 DWORD PTR tv440[ebp], 255 ; 000000ffH
$LN95@ColorEdit4:
  00a83	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR tv440[ebp]
  00a89	89 95 f0 fb ff
	ff		 mov	 DWORD PTR tv443[ebp], edx
$LN97@ColorEdit4:
  00a8f	0f b6 85 c7 fe
	ff ff		 movzx	 eax, BYTE PTR _disable_hue_edit$19[ebp]
  00a96	85 c0		 test	 eax, eax
  00a98	74 0c		 je	 SHORT $LN98@ColorEdit4
  00a9a	c7 85 e8 fb ff
	ff ff ff ff 7f	 mov	 DWORD PTR tv447[ebp], 2147483647 ; 7fffffffH
  00aa4	eb 0a		 jmp	 SHORT $LN99@ColorEdit4
$LN98@ColorEdit4:
  00aa6	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv447[ebp], 0
$LN99@ColorEdit4:
  00ab0	0f b6 9d 37 ff
	ff ff		 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  00ab7	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _fmt_idx$21[ebp]
  00abd	c1 e1 04	 shl	 ecx, 4
  00ac0	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _n$20[ebp]
  00ac6	8b 84 91 00 00
	00 00		 mov	 eax, DWORD PTR ?fmt_table_int@?BL@??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4PAY03PBDA[ecx+edx*4]
  00acd	50		 push	 eax
  00ace	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR tv443[ebp]
  00ad4	51		 push	 ecx
  00ad5	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR tv447[ebp]
  00adb	52		 push	 edx
  00adc	51		 push	 ecx
  00add	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ae5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aea	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _n$20[ebp]
  00af0	8d 8c 85 40 ff
	ff ff		 lea	 ecx, DWORD PTR _i$[ebp+eax*4]
  00af7	51		 push	 ecx
  00af8	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _n$20[ebp]
  00afe	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ids@?BL@??ColorEdit4@ImGui@@YA_NPBDQAMH@Z@4PAPBDA[edx*4]
  00b05	50		 push	 eax
  00b06	e8 00 00 00 00	 call	 ?DragInt@ImGui@@YA_NPBDPAHMHH0@Z ; ImGui::DragInt
  00b0b	83 c4 18	 add	 esp, 24			; 00000018H
  00b0e	0f b6 c8	 movzx	 ecx, al
  00b11	0b d9		 or	 ebx, ecx
  00b13	88 9d 37 ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], bl
$LN25@ColorEdit4:

; 4282 :             }
; 4283 :             if (!(flags & ImGuiColorEditFlags_NoOptions))

  00b19	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00b1c	83 e0 08	 and	 eax, 8
  00b1f	75 0f		 jne	 SHORT $LN26@ColorEdit4

; 4284 :                 OpenPopupOnItemClick("context");

  00b21	6a 01		 push	 1
  00b23	68 00 00 00 00	 push	 OFFSET ??_C@_07JKKCBBMM@context@
  00b28	e8 00 00 00 00	 call	 ?OpenPopupOnItemClick@ImGui@@YA_NPBDH@Z ; ImGui::OpenPopupOnItemClick
  00b2d	83 c4 08	 add	 esp, 8
$LN26@ColorEdit4:

; 4285 :         }

  00b30	e9 18 fd ff ff	 jmp	 $LN2@ColorEdit4
$LN3@ColorEdit4:

; 4286 :     }

  00b35	e9 b9 02 00 00	 jmp	 $LN34@ColorEdit4
$LN21@ColorEdit4:

; 4287 :     else if ((flags & ImGuiColorEditFlags_DisplayHex) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)

  00b3a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00b3d	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00b42	0f 84 ab 02 00
	00		 je	 $LN34@ColorEdit4
  00b48	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00b4b	83 e0 20	 and	 eax, 32			; 00000020H
  00b4e	0f 85 9f 02 00
	00		 jne	 $LN34@ColorEdit4

; 4288 :     {
; 4289 :         // RGB Hexadecimal Input
; 4290 :         char buf[64];
; 4291 :         if (alpha)

  00b54	0f b6 45 8b	 movzx	 eax, BYTE PTR _alpha$[ebp]
  00b58	85 c0		 test	 eax, eax
  00b5a	0f 84 97 00 00
	00		 je	 $LN28@ColorEdit4

; 4292 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));

  00b60	68 ff 00 00 00	 push	 255			; 000000ffH
  00b65	6a 00		 push	 0
  00b67	b8 04 00 00 00	 mov	 eax, 4
  00b6c	6b c8 03	 imul	 ecx, eax, 3
  00b6f	8b 94 0d 40 ff
	ff ff		 mov	 edx, DWORD PTR _i$[ebp+ecx]
  00b76	52		 push	 edx
  00b77	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00b7c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b7f	50		 push	 eax
  00b80	68 ff 00 00 00	 push	 255			; 000000ffH
  00b85	6a 00		 push	 0
  00b87	b8 04 00 00 00	 mov	 eax, 4
  00b8c	d1 e0		 shl	 eax, 1
  00b8e	8b 8c 05 40 ff
	ff ff		 mov	 ecx, DWORD PTR _i$[ebp+eax]
  00b95	51		 push	 ecx
  00b96	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00b9b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b9e	50		 push	 eax
  00b9f	68 ff 00 00 00	 push	 255			; 000000ffH
  00ba4	6a 00		 push	 0
  00ba6	ba 04 00 00 00	 mov	 edx, 4
  00bab	c1 e2 00	 shl	 edx, 0
  00bae	8b 84 15 40 ff
	ff ff		 mov	 eax, DWORD PTR _i$[ebp+edx]
  00bb5	50		 push	 eax
  00bb6	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00bbb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bbe	50		 push	 eax
  00bbf	68 ff 00 00 00	 push	 255			; 000000ffH
  00bc4	6a 00		 push	 0
  00bc6	b9 04 00 00 00	 mov	 ecx, 4
  00bcb	6b d1 00	 imul	 edx, ecx, 0
  00bce	8b 84 15 40 ff
	ff ff		 mov	 eax, DWORD PTR _i$[ebp+edx]
  00bd5	50		 push	 eax
  00bd6	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00bdb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bde	50		 push	 eax
  00bdf	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@
  00be4	6a 40		 push	 64			; 00000040H
  00be6	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _buf$18[ebp]
  00bec	51		 push	 ecx
  00bed	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00bf2	83 c4 1c	 add	 esp, 28			; 0000001cH
  00bf5	eb 75		 jmp	 SHORT $LN29@ColorEdit4
$LN28@ColorEdit4:

; 4293 :         else
; 4294 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));

  00bf7	68 ff 00 00 00	 push	 255			; 000000ffH
  00bfc	6a 00		 push	 0
  00bfe	b8 04 00 00 00	 mov	 eax, 4
  00c03	d1 e0		 shl	 eax, 1
  00c05	8b 8c 05 40 ff
	ff ff		 mov	 ecx, DWORD PTR _i$[ebp+eax]
  00c0c	51		 push	 ecx
  00c0d	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00c12	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c15	50		 push	 eax
  00c16	68 ff 00 00 00	 push	 255			; 000000ffH
  00c1b	6a 00		 push	 0
  00c1d	ba 04 00 00 00	 mov	 edx, 4
  00c22	c1 e2 00	 shl	 edx, 0
  00c25	8b 84 15 40 ff
	ff ff		 mov	 eax, DWORD PTR _i$[ebp+edx]
  00c2c	50		 push	 eax
  00c2d	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00c32	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c35	50		 push	 eax
  00c36	68 ff 00 00 00	 push	 255			; 000000ffH
  00c3b	6a 00		 push	 0
  00c3d	b9 04 00 00 00	 mov	 ecx, 4
  00c42	6b d1 00	 imul	 edx, ecx, 0
  00c45	8b 84 15 40 ff
	ff ff		 mov	 eax, DWORD PTR _i$[ebp+edx]
  00c4c	50		 push	 eax
  00c4d	e8 00 00 00 00	 call	 ??$ImClamp@H@@YAHHHH@Z	; ImClamp<int>
  00c52	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c55	50		 push	 eax
  00c56	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@
  00c5b	6a 40		 push	 64			; 00000040H
  00c5d	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _buf$18[ebp]
  00c63	51		 push	 ecx
  00c64	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  00c69	83 c4 18	 add	 esp, 24			; 00000018H
$LN29@ColorEdit4:

; 4295 :         SetNextItemWidth(w_inputs);

  00c6c	51		 push	 ecx
  00c6d	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _w_inputs$[ebp]
  00c72	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c77	e8 00 00 00 00	 call	 ?SetNextItemWidth@ImGui@@YAXM@Z ; ImGui::SetNextItemWidth
  00c7c	83 c4 04	 add	 esp, 4

; 4296 :         if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))

  00c7f	6a 00		 push	 0
  00c81	6a 00		 push	 0
  00c83	6a 06		 push	 6
  00c85	6a 40		 push	 64			; 00000040H
  00c87	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _buf$18[ebp]
  00c8d	50		 push	 eax
  00c8e	68 00 00 00 00	 push	 OFFSET ??_C@_06MNCEJPDI@?$CD?$CDText@
  00c93	e8 00 00 00 00	 call	 ?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputText
  00c98	83 c4 18	 add	 esp, 24			; 00000018H
  00c9b	0f b6 c8	 movzx	 ecx, al
  00c9e	85 c9		 test	 ecx, ecx
  00ca0	0f 84 36 01 00
	00		 je	 $LN33@ColorEdit4

; 4297 :         {
; 4298 :             value_changed = true;

  00ca6	c6 85 37 ff ff
	ff 01		 mov	 BYTE PTR _value_changed$[ebp], 1

; 4299 :             char* p = buf;

  00cad	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _buf$18[ebp]
  00cb3	89 85 70 fe ff
	ff		 mov	 DWORD PTR _p$17[ebp], eax
$LN5@ColorEdit4:

; 4300 :             while (*p == '#' || ImCharIsBlankA(*p))

  00cb9	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _p$17[ebp]
  00cbf	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00cc2	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00cc5	74 19		 je	 SHORT $LN31@ColorEdit4
  00cc7	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _p$17[ebp]
  00ccd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00cd0	51		 push	 ecx
  00cd1	e8 00 00 00 00	 call	 ?ImCharIsBlankA@@YA_ND@Z ; ImCharIsBlankA
  00cd6	83 c4 04	 add	 esp, 4
  00cd9	0f b6 d0	 movzx	 edx, al
  00cdc	85 d2		 test	 edx, edx
  00cde	74 11		 je	 SHORT $LN6@ColorEdit4
$LN31@ColorEdit4:

; 4301 :                 p++;

  00ce0	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _p$17[ebp]
  00ce6	83 c0 01	 add	 eax, 1
  00ce9	89 85 70 fe ff
	ff		 mov	 DWORD PTR _p$17[ebp], eax
  00cef	eb c8		 jmp	 SHORT $LN5@ColorEdit4
$LN6@ColorEdit4:

; 4302 :             i[0] = i[1] = i[2] = i[3] = 0;

  00cf1	b8 04 00 00 00	 mov	 eax, 4
  00cf6	6b c8 03	 imul	 ecx, eax, 3
  00cf9	c7 84 0d 40 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _i$[ebp+ecx], 0
  00d04	ba 04 00 00 00	 mov	 edx, 4
  00d09	d1 e2		 shl	 edx, 1
  00d0b	c7 84 15 40 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _i$[ebp+edx], 0
  00d16	b8 04 00 00 00	 mov	 eax, 4
  00d1b	c1 e0 00	 shl	 eax, 0
  00d1e	c7 84 05 40 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _i$[ebp+eax], 0
  00d29	b9 04 00 00 00	 mov	 ecx, 4
  00d2e	6b d1 00	 imul	 edx, ecx, 0
  00d31	c7 84 15 40 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _i$[ebp+edx], 0

; 4303 :             if (alpha)

  00d3c	0f b6 45 8b	 movzx	 eax, BYTE PTR _alpha$[ebp]
  00d40	85 c0		 test	 eax, eax
  00d42	74 55		 je	 SHORT $LN32@ColorEdit4

; 4304 :                 sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)

  00d44	b8 04 00 00 00	 mov	 eax, 4
  00d49	6b c8 03	 imul	 ecx, eax, 3
  00d4c	8d 94 0d 40 ff
	ff ff		 lea	 edx, DWORD PTR _i$[ebp+ecx]
  00d53	52		 push	 edx
  00d54	b8 04 00 00 00	 mov	 eax, 4
  00d59	d1 e0		 shl	 eax, 1
  00d5b	8d 8c 05 40 ff
	ff ff		 lea	 ecx, DWORD PTR _i$[ebp+eax]
  00d62	51		 push	 ecx
  00d63	ba 04 00 00 00	 mov	 edx, 4
  00d68	c1 e2 00	 shl	 edx, 0
  00d6b	8d 84 15 40 ff
	ff ff		 lea	 eax, DWORD PTR _i$[ebp+edx]
  00d72	50		 push	 eax
  00d73	b9 04 00 00 00	 mov	 ecx, 4
  00d78	6b d1 00	 imul	 edx, ecx, 0
  00d7b	8d 84 15 40 ff
	ff ff		 lea	 eax, DWORD PTR _i$[ebp+edx]
  00d82	50		 push	 eax
  00d83	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@
  00d88	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _p$17[ebp]
  00d8e	51		 push	 ecx
  00d8f	e8 00 00 00 00	 call	 _sscanf
  00d94	83 c4 18	 add	 esp, 24			; 00000018H
  00d97	eb 43		 jmp	 SHORT $LN33@ColorEdit4
$LN32@ColorEdit4:

; 4305 :             else
; 4306 :                 sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);

  00d99	b8 04 00 00 00	 mov	 eax, 4
  00d9e	d1 e0		 shl	 eax, 1
  00da0	8d 8c 05 40 ff
	ff ff		 lea	 ecx, DWORD PTR _i$[ebp+eax]
  00da7	51		 push	 ecx
  00da8	ba 04 00 00 00	 mov	 edx, 4
  00dad	c1 e2 00	 shl	 edx, 0
  00db0	8d 84 15 40 ff
	ff ff		 lea	 eax, DWORD PTR _i$[ebp+edx]
  00db7	50		 push	 eax
  00db8	b9 04 00 00 00	 mov	 ecx, 4
  00dbd	6b d1 00	 imul	 edx, ecx, 0
  00dc0	8d 84 15 40 ff
	ff ff		 lea	 eax, DWORD PTR _i$[ebp+edx]
  00dc7	50		 push	 eax
  00dc8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@
  00dcd	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _p$17[ebp]
  00dd3	51		 push	 ecx
  00dd4	e8 00 00 00 00	 call	 _sscanf
  00dd9	83 c4 14	 add	 esp, 20			; 00000014H
$LN33@ColorEdit4:

; 4307 :         }
; 4308 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

  00ddc	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00ddf	83 e0 08	 and	 eax, 8
  00de2	75 0f		 jne	 SHORT $LN34@ColorEdit4

; 4309 :             OpenPopupOnItemClick("context");

  00de4	6a 01		 push	 1
  00de6	68 00 00 00 00	 push	 OFFSET ??_C@_07JKKCBBMM@context@
  00deb	e8 00 00 00 00	 call	 ?OpenPopupOnItemClick@ImGui@@YA_NPBDH@Z ; ImGui::OpenPopupOnItemClick
  00df0	83 c4 08	 add	 esp, 8
$LN34@ColorEdit4:

; 4310 :     }
; 4311 : 
; 4312 :     ImGuiWindow* picker_active_window = NULL;

  00df3	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _picker_active_window$[ebp], 0

; 4313 :     if (!(flags & ImGuiColorEditFlags_NoSmallPreview))

  00dfd	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00e00	83 e0 10	 and	 eax, 16			; 00000010H
  00e03	0f 85 f0 02 00
	00		 jne	 $LN39@ColorEdit4

; 4314 :     {
; 4315 :         const float button_offset_x = ((flags & ImGuiColorEditFlags_NoInputs) || (style.ColorButtonPosition == ImGuiDir_Left)) ? 0.0f : w_inputs + style.ItemInnerSpacing.x;

  00e09	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00e0c	83 e0 20	 and	 eax, 32			; 00000020H
  00e0f	75 23		 jne	 SHORT $LN100@ColorEdit4
  00e11	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00e14	83 b9 80 00 00
	00 00		 cmp	 DWORD PTR [ecx+128], 0
  00e1b	74 17		 je	 SHORT $LN100@ColorEdit4
  00e1d	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  00e20	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _w_inputs$[ebp]
  00e25	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  00e2a	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv589[ebp], xmm0
  00e32	eb 0b		 jmp	 SHORT $LN101@ColorEdit4
$LN100@ColorEdit4:
  00e34	0f 57 c0	 xorps	 xmm0, xmm0
  00e37	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv589[ebp], xmm0
$LN101@ColorEdit4:
  00e3f	f3 0f 10 85 f0
	fb ff ff	 movss	 xmm0, DWORD PTR tv589[ebp]
  00e47	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR _button_offset_x$16[ebp], xmm0

; 4316 :         window->DC.CursorPos = ImVec2(pos.x + button_offset_x, pos.y);

  00e4f	51		 push	 ecx
  00e50	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00e58	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e5d	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00e65	f3 0f 58 85 58
	fe ff ff	 addss	 xmm0, DWORD PTR _button_offset_x$16[ebp]
  00e6d	51		 push	 ecx
  00e6e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e73	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00e79	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00e7e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e80	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e83	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00e86	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx
  00e8c	89 90 cc 00 00
	00		 mov	 DWORD PTR [eax+204], edx

; 4317 : 
; 4318 :         const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);

  00e92	0f b6 45 8b	 movzx	 eax, BYTE PTR _alpha$[ebp]
  00e96	85 c0		 test	 eax, eax
  00e98	74 1a		 je	 SHORT $LN102@ColorEdit4
  00e9a	b9 04 00 00 00	 mov	 ecx, 4
  00e9f	6b d1 03	 imul	 edx, ecx, 3
  00ea2	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00ea5	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00eaa	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv604[ebp], xmm0
  00eb2	eb 10		 jmp	 SHORT $LN103@ColorEdit4
$LN102@ColorEdit4:
  00eb4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ebc	f3 0f 11 85 f0
	fb ff ff	 movss	 DWORD PTR tv604[ebp], xmm0
$LN103@ColorEdit4:
  00ec4	51		 push	 ecx
  00ec5	f3 0f 10 85 f0
	fb ff ff	 movss	 xmm0, DWORD PTR tv604[ebp]
  00ecd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ed2	b9 04 00 00 00	 mov	 ecx, 4
  00ed7	d1 e1		 shl	 ecx, 1
  00ed9	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  00edc	51		 push	 ecx
  00edd	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  00ee2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ee7	b8 04 00 00 00	 mov	 eax, 4
  00eec	c1 e0 00	 shl	 eax, 0
  00eef	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00ef2	51		 push	 ecx
  00ef3	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00ef8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00efd	ba 04 00 00 00	 mov	 edx, 4
  00f02	6b c2 00	 imul	 eax, edx, 0
  00f05	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00f08	51		 push	 ecx
  00f09	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00f0e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f13	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _col_v4$15[ebp]
  00f19	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4

; 4319 :         if (ColorButton("##ColorButton", col_v4, flags))

  00f1e	51		 push	 ecx
  00f1f	0f 57 c0	 xorps	 xmm0, xmm0
  00f22	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f27	51		 push	 ecx
  00f28	0f 57 c0	 xorps	 xmm0, xmm0
  00f2b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f30	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00f36	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00f3b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f3e	51		 push	 ecx
  00f3f	8b 10		 mov	 edx, DWORD PTR [eax]
  00f41	52		 push	 edx
  00f42	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00f45	50		 push	 eax
  00f46	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _col_v4$15[ebp]
  00f4c	51		 push	 ecx
  00f4d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@
  00f52	e8 00 00 00 00	 call	 ?ColorButton@ImGui@@YA_NPBDABUImVec4@@HUImVec2@@@Z ; ImGui::ColorButton
  00f57	83 c4 14	 add	 esp, 20			; 00000014H
  00f5a	0f b6 d0	 movzx	 edx, al
  00f5d	85 d2		 test	 edx, edx
  00f5f	0f 84 ba 00 00
	00		 je	 $LN37@ColorEdit4

; 4320 :         {
; 4321 :             if (!(flags & ImGuiColorEditFlags_NoPicker))

  00f65	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00f68	83 e0 04	 and	 eax, 4
  00f6b	0f 85 ae 00 00
	00		 jne	 $LN37@ColorEdit4

; 4322 :             {
; 4323 :                 // Store current color and open a picker
; 4324 :                 g.ColorPickerRef = col_v4;

  00f71	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00f74	05 e8 2c 00 00	 add	 eax, 11496		; 00002ce8H
  00f79	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR _col_v4$15[ebp]
  00f7f	89 08		 mov	 DWORD PTR [eax], ecx
  00f81	8b 95 44 fe ff
	ff		 mov	 edx, DWORD PTR _col_v4$15[ebp+4]
  00f87	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00f8a	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR _col_v4$15[ebp+8]
  00f90	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00f93	8b 95 4c fe ff
	ff		 mov	 edx, DWORD PTR _col_v4$15[ebp+12]
  00f99	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 4325 :                 OpenPopup("picker");

  00f9c	68 00 00 00 00	 push	 OFFSET ??_C@_06MAKAMBBI@picker@
  00fa1	e8 00 00 00 00	 call	 ?OpenPopup@ImGui@@YAXPBD@Z ; ImGui::OpenPopup
  00fa6	83 c4 04	 add	 esp, 4

; 4326 :                 SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));

  00fa9	51		 push	 ecx
  00faa	0f 57 c0	 xorps	 xmm0, xmm0
  00fad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fb2	51		 push	 ecx
  00fb3	0f 57 c0	 xorps	 xmm0, xmm0
  00fb6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fbb	8d 8d 38 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00fc1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00fc6	50		 push	 eax
  00fc7	6a 00		 push	 0
  00fc9	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00fcc	51		 push	 ecx
  00fcd	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [eax+76]
  00fd2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fd7	51		 push	 ecx
  00fd8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00fe0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fe5	8d 8d 28 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00feb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00ff0	50		 push	 eax
  00ff1	8d 8d 18 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00ff7	51		 push	 ecx
  00ff8	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00ffb	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  01001	e8 00 00 00 00	 call	 ?GetBL@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetBL
  01006	50		 push	 eax
  01007	8d 95 08 fc ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0100d	52		 push	 edx
  0100e	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  01013	83 c4 0c	 add	 esp, 12			; 0000000cH
  01016	50		 push	 eax
  01017	e8 00 00 00 00	 call	 ?SetNextWindowPos@ImGui@@YAXABUImVec2@@H0@Z ; ImGui::SetNextWindowPos
  0101c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@ColorEdit4:

; 4327 :             }
; 4328 :         }
; 4329 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

  0101f	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  01022	83 e0 08	 and	 eax, 8
  01025	75 0f		 jne	 SHORT $LN38@ColorEdit4

; 4330 :             OpenPopupOnItemClick("context");

  01027	6a 01		 push	 1
  01029	68 00 00 00 00	 push	 OFFSET ??_C@_07JKKCBBMM@context@
  0102e	e8 00 00 00 00	 call	 ?OpenPopupOnItemClick@ImGui@@YA_NPBDH@Z ; ImGui::OpenPopupOnItemClick
  01033	83 c4 08	 add	 esp, 8
$LN38@ColorEdit4:

; 4331 : 
; 4332 :         if (BeginPopup("picker"))

  01036	6a 00		 push	 0
  01038	68 00 00 00 00	 push	 OFFSET ??_C@_06MAKAMBBI@picker@
  0103d	e8 00 00 00 00	 call	 ?BeginPopup@ImGui@@YA_NPBDH@Z ; ImGui::BeginPopup
  01042	83 c4 08	 add	 esp, 8
  01045	0f b6 c0	 movzx	 eax, al
  01048	85 c0		 test	 eax, eax
  0104a	0f 84 a9 00 00
	00		 je	 $LN39@ColorEdit4

; 4333 :         {
; 4334 :             picker_active_window = g.CurrentWindow;

  01050	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  01053	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  01059	89 8d 64 fe ff
	ff		 mov	 DWORD PTR _picker_active_window$[ebp], ecx

; 4335 :             if (label != label_display_end)

  0105f	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  01062	3b 45 a0	 cmp	 eax, DWORD PTR _label_display_end$[ebp]
  01065	74 17		 je	 SHORT $LN40@ColorEdit4

; 4336 :             {
; 4337 :                 TextEx(label, label_display_end);

  01067	6a 00		 push	 0
  01069	8b 45 a0	 mov	 eax, DWORD PTR _label_display_end$[ebp]
  0106c	50		 push	 eax
  0106d	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  01070	51		 push	 ecx
  01071	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  01076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4338 :                 Spacing();

  01079	e8 00 00 00 00	 call	 ?Spacing@ImGui@@YAXXZ	; ImGui::Spacing
$LN40@ColorEdit4:

; 4339 :             }
; 4340 :             ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;

  0107e	c7 85 34 fe ff
	ff 02 00 89 1f	 mov	 DWORD PTR _picker_flags_to_forward$14[ebp], 529072130 ; 1f890002H

; 4341 :             ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__DisplayMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;

  01088	8b 45 94	 mov	 eax, DWORD PTR _flags_untouched$[ebp]
  0108b	23 85 34 fe ff
	ff		 and	 eax, DWORD PTR _picker_flags_to_forward$14[ebp]
  01091	0d 00 00 70 00	 or	 eax, 7340032		; 00700000H
  01096	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0109b	0d 00 00 04 00	 or	 eax, 262144		; 00040000H
  010a0	89 85 28 fe ff
	ff		 mov	 DWORD PTR _picker_flags$13[ebp], eax

; 4342 :             SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?

  010a6	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  010ab	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41400000
  010b3	51		 push	 ecx
  010b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010b9	e8 00 00 00 00	 call	 ?SetNextItemWidth@ImGui@@YAXM@Z ; ImGui::SetNextItemWidth
  010be	83 c4 04	 add	 esp, 4

; 4343 :             value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);

  010c1	0f b6 9d 37 ff
	ff ff		 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  010c8	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  010cb	05 e8 2c 00 00	 add	 eax, 11496		; 00002ce8H
  010d0	50		 push	 eax
  010d1	8b 8d 28 fe ff
	ff		 mov	 ecx, DWORD PTR _picker_flags$13[ebp]
  010d7	51		 push	 ecx
  010d8	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  010db	52		 push	 edx
  010dc	68 00 00 00 00	 push	 OFFSET ??_C@_08HHEANBBL@?$CD?$CDpicker@
  010e1	e8 00 00 00 00	 call	 ?ColorPicker4@ImGui@@YA_NPBDQAMHPBM@Z ; ImGui::ColorPicker4
  010e6	83 c4 10	 add	 esp, 16			; 00000010H
  010e9	0f b6 c0	 movzx	 eax, al
  010ec	0b d8		 or	 ebx, eax
  010ee	88 9d 37 ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], bl

; 4344 :             EndPopup();

  010f4	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup
$LN39@ColorEdit4:

; 4345 :         }
; 4346 :     }
; 4347 : 
; 4348 :     if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))

  010f9	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  010fc	3b 45 a0	 cmp	 eax, DWORD PTR _label_display_end$[ebp]
  010ff	74 6c		 je	 SHORT $LN41@ColorEdit4
  01101	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  01104	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01109	75 62		 jne	 SHORT $LN41@ColorEdit4

; 4349 :     {
; 4350 :         window->DC.CursorPos = ImVec2(pos.x + w_full + style.ItemInnerSpacing.x, pos.y + style.FramePadding.y);

  0110b	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0110e	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  01116	f3 0f 58 40 3c	 addss	 xmm0, DWORD PTR [eax+60]
  0111b	51		 push	 ecx
  0111c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01121	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _pos$[ebp]
  01129	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _w_full$[ebp]
  0112e	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  01131	f3 0f 58 41 50	 addss	 xmm0, DWORD PTR [ecx+80]
  01136	51		 push	 ecx
  01137	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0113c	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  01142	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  01147	8b 10		 mov	 edx, DWORD PTR [eax]
  01149	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0114c	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0114f	89 91 c8 00 00
	00		 mov	 DWORD PTR [ecx+200], edx
  01155	89 81 cc 00 00
	00		 mov	 DWORD PTR [ecx+204], eax

; 4351 :         TextEx(label, label_display_end);

  0115b	6a 00		 push	 0
  0115d	8b 45 a0	 mov	 eax, DWORD PTR _label_display_end$[ebp]
  01160	50		 push	 eax
  01161	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  01164	51		 push	 ecx
  01165	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  0116a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@ColorEdit4:

; 4352 :     }
; 4353 : 
; 4354 :     // Convert back
; 4355 :     if (value_changed && picker_active_window == NULL)

  0116d	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  01174	85 c0		 test	 eax, eax
  01176	0f 84 3b 02 00
	00		 je	 $LN46@ColorEdit4
  0117c	83 bd 64 fe ff
	ff 00		 cmp	 DWORD PTR _picker_active_window$[ebp], 0
  01183	0f 85 2e 02 00
	00		 jne	 $LN46@ColorEdit4

; 4356 :     {
; 4357 :         if (!value_changed_as_float)

  01189	0f b6 85 2b ff
	ff ff		 movzx	 eax, BYTE PTR _value_changed_as_float$[ebp]
  01190	85 c0		 test	 eax, eax
  01192	75 4c		 jne	 SHORT $LN8@ColorEdit4

; 4358 :             for (int n = 0; n < 4; n++)

  01194	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$12[ebp], 0
  0119e	eb 0f		 jmp	 SHORT $LN9@ColorEdit4
$LN7@ColorEdit4:
  011a0	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _n$12[ebp]
  011a6	83 c0 01	 add	 eax, 1
  011a9	89 85 1c fe ff
	ff		 mov	 DWORD PTR _n$12[ebp], eax
$LN9@ColorEdit4:
  011af	83 bd 1c fe ff
	ff 04		 cmp	 DWORD PTR _n$12[ebp], 4
  011b6	7d 28		 jge	 SHORT $LN8@ColorEdit4

; 4359 :                 f[n] = i[n] / 255.0f;

  011b8	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _n$12[ebp]
  011be	f3 0f 2a 84 85
	40 ff ff ff	 cvtsi2ss xmm0, DWORD PTR _i$[ebp+eax*4]
  011c7	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  011cf	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _n$12[ebp]
  011d5	f3 0f 11 84 8d
	58 ff ff ff	 movss	 DWORD PTR _f$[ebp+ecx*4], xmm0
  011de	eb c0		 jmp	 SHORT $LN7@ColorEdit4
$LN8@ColorEdit4:

; 4360 :         if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB))

  011e0	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  011e3	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  011e8	0f 84 bc 00 00
	00		 je	 $LN44@ColorEdit4
  011ee	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  011f1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  011f6	0f 84 ae 00 00
	00		 je	 $LN44@ColorEdit4

; 4361 :         {
; 4362 :             g.ColorEditLastHue = f[0];

  011fc	b8 04 00 00 00	 mov	 eax, 4
  01201	6b c8 00	 imul	 ecx, eax, 0
  01204	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  01207	8b 84 0d 58 ff
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+ecx]
  0120e	89 82 d8 2c 00
	00		 mov	 DWORD PTR [edx+11480], eax

; 4363 :             ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);

  01214	b8 04 00 00 00	 mov	 eax, 4
  01219	d1 e0		 shl	 eax, 1
  0121b	8d 8c 05 58 ff
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+eax]
  01222	51		 push	 ecx
  01223	ba 04 00 00 00	 mov	 edx, 4
  01228	c1 e2 00	 shl	 edx, 0
  0122b	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  01232	50		 push	 eax
  01233	b9 04 00 00 00	 mov	 ecx, 4
  01238	6b d1 00	 imul	 edx, ecx, 0
  0123b	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  01242	50		 push	 eax
  01243	b9 04 00 00 00	 mov	 ecx, 4
  01248	d1 e1		 shl	 ecx, 1
  0124a	51		 push	 ecx
  0124b	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  01254	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01259	ba 04 00 00 00	 mov	 edx, 4
  0125e	c1 e2 00	 shl	 edx, 0
  01261	51		 push	 ecx
  01262	f3 0f 10 84 15
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+edx]
  0126b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01270	b8 04 00 00 00	 mov	 eax, 4
  01275	6b c8 00	 imul	 ecx, eax, 0
  01278	51		 push	 ecx
  01279	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  01282	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01287	e8 00 00 00 00	 call	 ?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
  0128c	83 c4 18	 add	 esp, 24			; 00000018H

; 4364 :             memcpy(g.ColorEditLastColor, f, sizeof(float) * 3);

  0128f	6a 0c		 push	 12			; 0000000cH
  01291	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _f$[ebp]
  01297	50		 push	 eax
  01298	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  0129b	81 c1 dc 2c 00
	00		 add	 ecx, 11484		; 00002cdcH
  012a1	51		 push	 ecx
  012a2	e8 00 00 00 00	 call	 _memcpy
  012a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@ColorEdit4:

; 4365 :         }
; 4366 :         if ((flags & ImGuiColorEditFlags_DisplayRGB) && (flags & ImGuiColorEditFlags_InputHSV))

  012aa	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  012ad	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  012b2	0f 84 85 00 00
	00		 je	 $LN45@ColorEdit4
  012b8	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  012bb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  012c0	74 7b		 je	 SHORT $LN45@ColorEdit4

; 4367 :             ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

  012c2	b8 04 00 00 00	 mov	 eax, 4
  012c7	d1 e0		 shl	 eax, 1
  012c9	8d 8c 05 58 ff
	ff ff		 lea	 ecx, DWORD PTR _f$[ebp+eax]
  012d0	51		 push	 ecx
  012d1	ba 04 00 00 00	 mov	 edx, 4
  012d6	c1 e2 00	 shl	 edx, 0
  012d9	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  012e0	50		 push	 eax
  012e1	b9 04 00 00 00	 mov	 ecx, 4
  012e6	6b d1 00	 imul	 edx, ecx, 0
  012e9	8d 84 15 58 ff
	ff ff		 lea	 eax, DWORD PTR _f$[ebp+edx]
  012f0	50		 push	 eax
  012f1	b9 04 00 00 00	 mov	 ecx, 4
  012f6	d1 e1		 shl	 ecx, 1
  012f8	51		 push	 ecx
  012f9	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  01302	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01307	ba 04 00 00 00	 mov	 edx, 4
  0130c	c1 e2 00	 shl	 edx, 0
  0130f	51		 push	 ecx
  01310	f3 0f 10 84 15
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+edx]
  01319	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0131e	b8 04 00 00 00	 mov	 eax, 4
  01323	6b c8 00	 imul	 ecx, eax, 0
  01326	51		 push	 ecx
  01327	f3 0f 10 84 0d
	58 ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp+ecx]
  01330	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01335	e8 00 00 00 00	 call	 ?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertRGBtoHSV
  0133a	83 c4 18	 add	 esp, 24			; 00000018H
$LN45@ColorEdit4:

; 4368 : 
; 4369 :         col[0] = f[0];

  0133d	b8 04 00 00 00	 mov	 eax, 4
  01342	6b c8 00	 imul	 ecx, eax, 0
  01345	ba 04 00 00 00	 mov	 edx, 4
  0134a	6b c2 00	 imul	 eax, edx, 0
  0134d	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  01350	8b 8c 0d 58 ff
	ff ff		 mov	 ecx, DWORD PTR _f$[ebp+ecx]
  01357	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx

; 4370 :         col[1] = f[1];

  0135a	b8 04 00 00 00	 mov	 eax, 4
  0135f	c1 e0 00	 shl	 eax, 0
  01362	b9 04 00 00 00	 mov	 ecx, 4
  01367	c1 e1 00	 shl	 ecx, 0
  0136a	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  0136d	8b 84 05 58 ff
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+eax]
  01374	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 4371 :         col[2] = f[2];

  01377	b8 04 00 00 00	 mov	 eax, 4
  0137c	d1 e0		 shl	 eax, 1
  0137e	b9 04 00 00 00	 mov	 ecx, 4
  01383	d1 e1		 shl	 ecx, 1
  01385	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  01388	8b 84 05 58 ff
	ff ff		 mov	 eax, DWORD PTR _f$[ebp+eax]
  0138f	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 4372 :         if (alpha)

  01392	0f b6 45 8b	 movzx	 eax, BYTE PTR _alpha$[ebp]
  01396	85 c0		 test	 eax, eax
  01398	74 1d		 je	 SHORT $LN46@ColorEdit4

; 4373 :             col[3] = f[3];

  0139a	b8 04 00 00 00	 mov	 eax, 4
  0139f	6b c8 03	 imul	 ecx, eax, 3
  013a2	ba 04 00 00 00	 mov	 edx, 4
  013a7	6b c2 03	 imul	 eax, edx, 3
  013aa	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  013ad	8b 8c 0d 58 ff
	ff ff		 mov	 ecx, DWORD PTR _f$[ebp+ecx]
  013b4	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
$LN46@ColorEdit4:

; 4374 :     }
; 4375 : 
; 4376 :     PopID();

  013b7	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 4377 :     EndGroup();

  013bc	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 4378 : 
; 4379 :     // Drag and Drop Target
; 4380 :     // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
; 4381 :     if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())

  013c1	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  013c4	8b 88 0c 01 00
	00		 mov	 ecx, DWORD PTR [eax+268]
  013ca	83 e1 01	 and	 ecx, 1
  013cd	0f 84 43 01 00
	00		 je	 $LN47@ColorEdit4
  013d3	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  013d6	25 00 02 00 00	 and	 eax, 512		; 00000200H
  013db	0f 85 35 01 00
	00		 jne	 $LN47@ColorEdit4
  013e1	e8 00 00 00 00	 call	 ?BeginDragDropTarget@ImGui@@YA_NXZ ; ImGui::BeginDragDropTarget
  013e6	0f b6 c0	 movzx	 eax, al
  013e9	85 c0		 test	 eax, eax
  013eb	0f 84 25 01 00
	00		 je	 $LN47@ColorEdit4

; 4382 :     {
; 4383 :         bool accepted_drag_drop = false;

  013f1	c6 85 13 fe ff
	ff 00		 mov	 BYTE PTR _accepted_drag_drop$11[ebp], 0

; 4384 :         if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))

  013f8	6a 00		 push	 0
  013fa	68 00 00 00 00	 push	 OFFSET ??_C@_06LFKNFKEK@_COL3F@
  013ff	e8 00 00 00 00	 call	 ?AcceptDragDropPayload@ImGui@@YAPBUImGuiPayload@@PBDH@Z ; ImGui::AcceptDragDropPayload
  01404	83 c4 08	 add	 esp, 8
  01407	89 85 04 fe ff
	ff		 mov	 DWORD PTR _payload$10[ebp], eax
  0140d	83 bd 04 fe ff
	ff 00		 cmp	 DWORD PTR _payload$10[ebp], 0
  01414	74 2a		 je	 SHORT $LN48@ColorEdit4

; 4385 :         {
; 4386 :             memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512

  01416	6a 0c		 push	 12			; 0000000cH
  01418	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR _payload$10[ebp]
  0141e	8b 08		 mov	 ecx, DWORD PTR [eax]
  01420	51		 push	 ecx
  01421	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  01424	52		 push	 edx
  01425	e8 00 00 00 00	 call	 _memcpy
  0142a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4387 :             value_changed = accepted_drag_drop = true;

  0142d	c6 85 13 fe ff
	ff 01		 mov	 BYTE PTR _accepted_drag_drop$11[ebp], 1
  01434	8a 85 13 fe ff
	ff		 mov	 al, BYTE PTR _accepted_drag_drop$11[ebp]
  0143a	88 85 37 ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al
$LN48@ColorEdit4:

; 4388 :         }
; 4389 :         if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))

  01440	6a 00		 push	 0
  01442	68 00 00 00 00	 push	 OFFSET ??_C@_06LAOCEMMP@_COL4F@
  01447	e8 00 00 00 00	 call	 ?AcceptDragDropPayload@ImGui@@YAPBUImGuiPayload@@PBDH@Z ; ImGui::AcceptDragDropPayload
  0144c	83 c4 08	 add	 esp, 8
  0144f	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _payload$9[ebp], eax
  01455	83 bd f8 fd ff
	ff 00		 cmp	 DWORD PTR _payload$9[ebp], 0
  0145c	74 32		 je	 SHORT $LN49@ColorEdit4

; 4390 :         {
; 4391 :             memcpy((float*)col, payload->Data, sizeof(float) * components);

  0145e	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _components$[ebp]
  01464	c1 e0 02	 shl	 eax, 2
  01467	50		 push	 eax
  01468	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR _payload$9[ebp]
  0146e	8b 11		 mov	 edx, DWORD PTR [ecx]
  01470	52		 push	 edx
  01471	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  01474	50		 push	 eax
  01475	e8 00 00 00 00	 call	 _memcpy
  0147a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4392 :             value_changed = accepted_drag_drop = true;

  0147d	c6 85 13 fe ff
	ff 01		 mov	 BYTE PTR _accepted_drag_drop$11[ebp], 1
  01484	8a 85 13 fe ff
	ff		 mov	 al, BYTE PTR _accepted_drag_drop$11[ebp]
  0148a	88 85 37 ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al
$LN49@ColorEdit4:

; 4393 :         }
; 4394 : 
; 4395 :         // Drag-drop payloads are always RGB
; 4396 :         if (accepted_drag_drop && (flags & ImGuiColorEditFlags_InputHSV))

  01490	0f b6 85 13 fe
	ff ff		 movzx	 eax, BYTE PTR _accepted_drag_drop$11[ebp]
  01497	85 c0		 test	 eax, eax
  01499	74 76		 je	 SHORT $LN50@ColorEdit4
  0149b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0149e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  014a3	74 6c		 je	 SHORT $LN50@ColorEdit4

; 4397 :             ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);

  014a5	b8 04 00 00 00	 mov	 eax, 4
  014aa	d1 e0		 shl	 eax, 1
  014ac	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  014af	50		 push	 eax
  014b0	b9 04 00 00 00	 mov	 ecx, 4
  014b5	c1 e1 00	 shl	 ecx, 0
  014b8	03 4d 0c	 add	 ecx, DWORD PTR _col$[ebp]
  014bb	51		 push	 ecx
  014bc	ba 04 00 00 00	 mov	 edx, 4
  014c1	6b c2 00	 imul	 eax, edx, 0
  014c4	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  014c7	50		 push	 eax
  014c8	b9 04 00 00 00	 mov	 ecx, 4
  014cd	d1 e1		 shl	 ecx, 1
  014cf	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  014d2	51		 push	 ecx
  014d3	f3 0f 10 04 0a	 movss	 xmm0, DWORD PTR [edx+ecx]
  014d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014dd	b8 04 00 00 00	 mov	 eax, 4
  014e2	c1 e0 00	 shl	 eax, 0
  014e5	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  014e8	51		 push	 ecx
  014e9	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  014ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014f3	ba 04 00 00 00	 mov	 edx, 4
  014f8	6b c2 00	 imul	 eax, edx, 0
  014fb	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  014fe	51		 push	 ecx
  014ff	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  01504	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01509	e8 00 00 00 00	 call	 ?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertRGBtoHSV
  0150e	83 c4 18	 add	 esp, 24			; 00000018H
$LN50@ColorEdit4:

; 4398 :         EndDragDropTarget();

  01511	e8 00 00 00 00	 call	 ?EndDragDropTarget@ImGui@@YAXXZ ; ImGui::EndDragDropTarget
$LN47@ColorEdit4:

; 4399 :     }
; 4400 : 
; 4401 :     // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
; 4402 :     if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)

  01516	83 bd 64 fe ff
	ff 00		 cmp	 DWORD PTR _picker_active_window$[ebp], 0
  0151d	74 2f		 je	 SHORT $LN51@ColorEdit4
  0151f	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  01522	83 b8 e4 19 00
	00 00		 cmp	 DWORD PTR [eax+6628], 0
  01529	74 23		 je	 SHORT $LN51@ColorEdit4
  0152b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0152e	8b 88 10 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6672]
  01534	3b 8d 64 fe ff
	ff		 cmp	 ecx, DWORD PTR _picker_active_window$[ebp]
  0153a	75 12		 jne	 SHORT $LN51@ColorEdit4

; 4403 :         window->DC.LastItemId = g.ActiveId;

  0153c	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0153f	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  01542	8b 91 e4 19 00
	00		 mov	 edx, DWORD PTR [ecx+6628]
  01548	89 90 08 01 00
	00		 mov	 DWORD PTR [eax+264], edx
$LN51@ColorEdit4:

; 4404 : 
; 4405 :     if (value_changed)

  0154e	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  01555	85 c0		 test	 eax, eax
  01557	74 12		 je	 SHORT $LN52@ColorEdit4

; 4406 :         MarkItemEdited(window->DC.LastItemId);

  01559	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0155c	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  01562	51		 push	 ecx
  01563	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  01568	83 c4 04	 add	 esp, 4
$LN52@ColorEdit4:

; 4407 : 
; 4408 :     return value_changed;

  0156b	8a 85 37 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@ColorEdit4:

; 4409 : }

  01571	52		 push	 edx
  01572	8b cd		 mov	 ecx, ebp
  01574	50		 push	 eax
  01575	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN110@ColorEdit4
  0157b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01580	58		 pop	 eax
  01581	5a		 pop	 edx
  01582	5f		 pop	 edi
  01583	5e		 pop	 esi
  01584	5b		 pop	 ebx
  01585	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01588	33 cd		 xor	 ecx, ebp
  0158a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0158f	81 c4 18 04 00
	00		 add	 esp, 1048		; 00000418H
  01595	3b ec		 cmp	 ebp, esp
  01597	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0159c	8b e5		 mov	 esp, ebp
  0159e	5d		 pop	 ebp
  0159f	c3		 ret	 0
$LN110@ColorEdit4:
  015a0	05 00 00 00	 DD	 5
  015a4	00 00 00 00	 DD	 $LN109@ColorEdit4
$LN109@ColorEdit4:
  015a8	58 ff ff ff	 DD	 -168			; ffffff58H
  015ac	10 00 00 00	 DD	 16			; 00000010H
  015b0	00 00 00 00	 DD	 $LN104@ColorEdit4
  015b4	40 ff ff ff	 DD	 -192			; ffffff40H
  015b8	10 00 00 00	 DD	 16			; 00000010H
  015bc	00 00 00 00	 DD	 $LN105@ColorEdit4
  015c0	18 ff ff ff	 DD	 -232			; ffffff18H
  015c4	08 00 00 00	 DD	 8
  015c8	00 00 00 00	 DD	 $LN106@ColorEdit4
  015cc	7c fe ff ff	 DD	 -388			; fffffe7cH
  015d0	40 00 00 00	 DD	 64			; 00000040H
  015d4	00 00 00 00	 DD	 $LN107@ColorEdit4
  015d8	40 fe ff ff	 DD	 -448			; fffffe40H
  015dc	10 00 00 00	 DD	 16			; 00000010H
  015e0	00 00 00 00	 DD	 $LN108@ColorEdit4
$LN108@ColorEdit4:
  015e4	63		 DB	 99			; 00000063H
  015e5	6f		 DB	 111			; 0000006fH
  015e6	6c		 DB	 108			; 0000006cH
  015e7	5f		 DB	 95			; 0000005fH
  015e8	76		 DB	 118			; 00000076H
  015e9	34		 DB	 52			; 00000034H
  015ea	00		 DB	 0
$LN107@ColorEdit4:
  015eb	62		 DB	 98			; 00000062H
  015ec	75		 DB	 117			; 00000075H
  015ed	66		 DB	 102			; 00000066H
  015ee	00		 DB	 0
$LN106@ColorEdit4:
  015ef	70		 DB	 112			; 00000070H
  015f0	6f		 DB	 111			; 0000006fH
  015f1	73		 DB	 115			; 00000073H
  015f2	00		 DB	 0
$LN105@ColorEdit4:
  015f3	69		 DB	 105			; 00000069H
  015f4	00		 DB	 0
$LN104@ColorEdit4:
  015f5	66		 DB	 102			; 00000066H
  015f6	00		 DB	 0
?ColorEdit4@ImGui@@YA_NPBDQAMH@Z ENDP			; ImGui::ColorEdit4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ColorEdit3@ImGui@@YA_NPBDQAMH@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_col$ = 12						; size = 4
_flags$ = 16						; size = 4
?ColorEdit3@ImGui@@YA_NPBDQAMH@Z PROC			; ImGui::ColorEdit3, COMDAT

; 4173 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4174 :     return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);

  00028	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	83 c8 02	 or	 eax, 2
  0002e	50		 push	 eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _col$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?ColorEdit4@ImGui@@YA_NPBDQAMH@Z ; ImGui::ColorEdit4
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4175 : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?ColorEdit3@ImGui@@YA_NPBDQAMH@Z ENDP			; ImGui::ColorEdit3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z
_TEXT	SEGMENT
_label_end$ = -68					; size = 4
_i$1 = -56						; size = 4
_type_size$ = -44					; size = 4
_value_changed$ = -29					; size = 1
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_label$ = 8						; size = 4
_data_type$ = 12					; size = 4
_p_data$ = 16						; size = 4
_components$ = 20					; size = 4
_p_step$ = 24						; size = 4
_p_step_fast$ = 28					; size = 4
_format$ = 32						; size = 4
_flags$ = 36						; size = 4
?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z PROC		; ImGui::InputScalarN, COMDAT

; 2950 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2951 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 2952 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 07		 je	 SHORT $LN5@InputScala

; 2953 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	e9 30 01 00 00	 jmp	 $LN1@InputScala
$LN5@InputScala:

; 2954 : 
; 2955 :     ImGuiContext& g = *GImGui;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00047	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 2956 :     bool value_changed = false;

  0004a	c6 45 e3 00	 mov	 BYTE PTR _value_changed$[ebp], 0

; 2957 :     BeginGroup();

  0004e	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 2958 :     PushID(label);

  00053	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  0005c	83 c4 04	 add	 esp, 4

; 2959 :     PushMultiItemsWidths(components, CalcItemWidth());

  0005f	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00064	51		 push	 ecx
  00065	d9 1c 24	 fstp	 DWORD PTR [esp]
  00068	8b 45 14	 mov	 eax, DWORD PTR _components$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?PushMultiItemsWidths@ImGui@@YAXHM@Z ; ImGui::PushMultiItemsWidths
  00071	83 c4 08	 add	 esp, 8

; 2960 :     size_t type_size = GDataTypeInfo[data_type].Size;

  00074	6b 45 0c 0c	 imul	 eax, DWORD PTR _data_type$[ebp], 12
  00078	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B[eax]
  0007e	89 4d d4	 mov	 DWORD PTR _type_size$[ebp], ecx

; 2961 :     for (int i = 0; i < components; i++)

  00081	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00088	eb 09		 jmp	 SHORT $LN4@InputScala
$LN2@InputScala:
  0008a	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  0008d	83 c0 01	 add	 eax, 1
  00090	89 45 c8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@InputScala:
  00093	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  00096	3b 45 14	 cmp	 eax, DWORD PTR _components$[ebp]
  00099	7d 7d		 jge	 SHORT $LN3@InputScala

; 2962 :     {
; 2963 :         PushID(i);

  0009b	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID
  000a4	83 c4 04	 add	 esp, 4

; 2964 :         if (i > 0)

  000a7	83 7d c8 00	 cmp	 DWORD PTR _i$1[ebp], 0
  000ab	7e 22		 jle	 SHORT $LN6@InputScala

; 2965 :             SameLine(0, g.Style.ItemInnerSpacing.x);

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  000b0	51		 push	 ecx
  000b1	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  000b9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000be	51		 push	 ecx
  000bf	0f 57 c0	 xorps	 xmm0, xmm0
  000c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c7	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  000cc	83 c4 08	 add	 esp, 8
$LN6@InputScala:

; 2966 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

  000cf	0f b6 5d e3	 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  000d3	8b 45 24	 mov	 eax, DWORD PTR _flags$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  000da	51		 push	 ecx
  000db	8b 55 1c	 mov	 edx, DWORD PTR _p_step_fast$[ebp]
  000de	52		 push	 edx
  000df	8b 45 18	 mov	 eax, DWORD PTR _p_step$[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  000e6	51		 push	 ecx
  000e7	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  000ea	52		 push	 edx
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000f0	e8 00 00 00 00	 call	 ?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z ; ImGui::InputScalar
  000f5	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f8	0f b6 c0	 movzx	 eax, al
  000fb	0b d8		 or	 ebx, eax
  000fd	88 5d e3	 mov	 BYTE PTR _value_changed$[ebp], bl

; 2967 :         PopID();

  00100	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2968 :         PopItemWidth();

  00105	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 2969 :         p_data = (void*)((char*)p_data + type_size);

  0010a	8b 45 10	 mov	 eax, DWORD PTR _p_data$[ebp]
  0010d	03 45 d4	 add	 eax, DWORD PTR _type_size$[ebp]
  00110	89 45 10	 mov	 DWORD PTR _p_data$[ebp], eax

; 2970 :     }

  00113	e9 72 ff ff ff	 jmp	 $LN2@InputScala
$LN3@InputScala:

; 2971 :     PopID();

  00118	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2972 : 
; 2973 :     const char* label_end = FindRenderedTextEnd(label);

  0011d	6a 00		 push	 0
  0011f	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  00128	83 c4 08	 add	 esp, 8
  0012b	89 45 bc	 mov	 DWORD PTR _label_end$[ebp], eax

; 2974 :     if (label != label_end)

  0012e	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00131	3b 45 bc	 cmp	 eax, DWORD PTR _label_end$[ebp]
  00134	74 34		 je	 SHORT $LN7@InputScala

; 2975 :     {
; 2976 :         SameLine(0.0f, g.Style.ItemInnerSpacing.x);

  00136	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00139	51		 push	 ecx
  0013a	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  00142	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00147	51		 push	 ecx
  00148	0f 57 c0	 xorps	 xmm0, xmm0
  0014b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00150	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00155	83 c4 08	 add	 esp, 8

; 2977 :         TextEx(label, label_end);

  00158	6a 00		 push	 0
  0015a	8b 45 bc	 mov	 eax, DWORD PTR _label_end$[ebp]
  0015d	50		 push	 eax
  0015e	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  00167	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@InputScala:

; 2978 :     }
; 2979 : 
; 2980 :     EndGroup();

  0016a	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 2981 :     return value_changed;

  0016f	8a 45 e3	 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@InputScala:

; 2982 : }

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  0017b	3b ec		 cmp	 ebp, esp
  0017d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ENDP		; ImGui::InputScalarN
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z
_TEXT	SEGMENT
tv263 = -404						; size = 4
tv199 = -404						; size = 4
tv174 = -404						; size = 4
$T1 = -396						; size = 8
$T2 = -380						; size = 8
_label_end$3 = -172					; size = 4
_button_flags$4 = -160					; size = 4
_backup_frame_padding$5 = -148				; size = 8
_button_size$6 = -132					; size = 4
_value_changed$ = -117					; size = 1
_buf$ = -108						; size = 64
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_data_type$ = 12					; size = 4
_p_data$ = 16						; size = 4
_p_step$ = 20						; size = 4
_p_step_fast$ = 24					; size = 4
_format$ = 28						; size = 4
_flags$ = 32						; size = 4
?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z PROC		; ImGui::InputScalar, COMDAT

; 2878 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00012	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2879 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 2880 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@InputScala

; 2881 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 a6 03 00 00	 jmp	 $LN1@InputScala
$LN2@InputScala:

; 2882 : 
; 2883 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 2884 :     ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 2885 : 
; 2886 :     if (format == NULL)

  0005f	83 7d 1c 00	 cmp	 DWORD PTR _format$[ebp], 0
  00063	75 12		 jne	 SHORT $LN3@InputScala

; 2887 :         format = DataTypeGetInfo(data_type)->PrintFmt;

  00065	8b 45 0c	 mov	 eax, DWORD PTR _data_type$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z ; ImGui::DataTypeGetInfo
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00074	89 4d 1c	 mov	 DWORD PTR _format$[ebp], ecx
$LN3@InputScala:

; 2888 : 
; 2889 :     char buf[64];
; 2890 :     DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, p_data, format);

  00077	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  00082	52		 push	 edx
  00083	6a 40		 push	 64			; 00000040H
  00085	8d 45 94	 lea	 eax, DWORD PTR _buf$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z ; ImGui::DataTypeFormatString
  0008e	83 c4 14	 add	 esp, 20			; 00000014H

; 2891 : 
; 2892 :     bool value_changed = false;

  00091	c6 45 8b 00	 mov	 BYTE PTR _value_changed$[ebp], 0

; 2893 :     if ((flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)

  00095	8b 45 20	 mov	 eax, DWORD PTR _flags$[ebp]
  00098	25 02 00 02 00	 and	 eax, 131074		; 00020002H
  0009d	75 09		 jne	 SHORT $LN4@InputScala

; 2894 :         flags |= ImGuiInputTextFlags_CharsDecimal;

  0009f	8b 45 20	 mov	 eax, DWORD PTR _flags$[ebp]
  000a2	83 c8 01	 or	 eax, 1
  000a5	89 45 20	 mov	 DWORD PTR _flags$[ebp], eax
$LN4@InputScala:

; 2895 :     flags |= ImGuiInputTextFlags_AutoSelectAll;

  000a8	8b 45 20	 mov	 eax, DWORD PTR _flags$[ebp]
  000ab	83 c8 10	 or	 eax, 16			; 00000010H
  000ae	89 45 20	 mov	 DWORD PTR _flags$[ebp], eax

; 2896 :     flags |= ImGuiInputTextFlags_NoMarkEdited;  // We call MarkItemEdited() ourselve by comparing the actual data rather than the string.

  000b1	8b 45 20	 mov	 eax, DWORD PTR _flags$[ebp]
  000b4	0d 00 00 20 00	 or	 eax, 2097152		; 00200000H
  000b9	89 45 20	 mov	 DWORD PTR _flags$[ebp], eax

; 2897 : 
; 2898 :     if (p_step != NULL)

  000bc	83 7d 14 00	 cmp	 DWORD PTR _p_step$[ebp], 0
  000c0	0f 84 c9 02 00
	00		 je	 $LN5@InputScala

; 2899 :     {
; 2900 :         const float button_size = GetFrameHeight();

  000c6	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  000cb	d9 9d 7c ff ff
	ff		 fstp	 DWORD PTR _button_size$6[ebp]

; 2901 : 
; 2902 :         BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()

  000d1	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 2903 :         PushID(label);

  000d6	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  000df	83 c4 04	 add	 esp, 4

; 2904 :         SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));

  000e2	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  000e7	d9 9d 6c fe ff
	ff		 fstp	 DWORD PTR tv263[ebp]
  000ed	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR tv263[ebp]
  000f5	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000f8	f3 0f 10 8d 7c
	ff ff ff	 movss	 xmm1, DWORD PTR _button_size$6[ebp]
  00100	f3 0f 58 48 50	 addss	 xmm1, DWORD PTR [eax+80]
  00105	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  0010d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00111	51		 push	 ecx
  00112	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00117	51		 push	 ecx
  00118	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00120	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00125	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0012a	83 c4 04	 add	 esp, 4
  0012d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00130	e8 00 00 00 00	 call	 ?SetNextItemWidth@ImGui@@YAXM@Z ; ImGui::SetNextItemWidth
  00135	83 c4 04	 add	 esp, 4

; 2905 :         if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view

  00138	6a 00		 push	 0
  0013a	6a 00		 push	 0
  0013c	8b 45 20	 mov	 eax, DWORD PTR _flags$[ebp]
  0013f	50		 push	 eax
  00140	6a 40		 push	 64			; 00000040H
  00142	8d 4d 94	 lea	 ecx, DWORD PTR _buf$[ebp]
  00145	51		 push	 ecx
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0014b	e8 00 00 00 00	 call	 ?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputText
  00150	83 c4 18	 add	 esp, 24			; 00000018H
  00153	0f b6 d0	 movzx	 edx, al
  00156	85 d2		 test	 edx, edx
  00158	74 25		 je	 SHORT $LN7@InputScala

; 2906 :             value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, p_data, format);

  0015a	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  0015d	50		 push	 eax
  0015e	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  00161	51		 push	 ecx
  00162	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  00165	52		 push	 edx
  00166	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00169	8b 88 2c 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7724]
  0016f	51		 push	 ecx
  00170	8d 55 94	 lea	 edx, DWORD PTR _buf$[ebp]
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 ?DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z ; ImGui::DataTypeApplyOpFromText
  00179	83 c4 14	 add	 esp, 20			; 00000014H
  0017c	88 45 8b	 mov	 BYTE PTR _value_changed$[ebp], al
$LN7@InputScala:

; 2907 : 
; 2908 :         // Step buttons
; 2909 :         const ImVec2 backup_frame_padding = style.FramePadding;

  0017f	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00182	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00185	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00188	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _backup_frame_padding$5[ebp], ecx
  0018e	89 95 70 ff ff
	ff		 mov	 DWORD PTR _backup_frame_padding$5[ebp+4], edx

; 2910 :         style.FramePadding.x = style.FramePadding.y;

  00194	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00197	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  0019a	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0019d	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 2911 :         ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;

  001a0	c7 85 60 ff ff
	ff 81 00 00 00	 mov	 DWORD PTR _button_flags$4[ebp], 129 ; 00000081H

; 2912 :         if (flags & ImGuiInputTextFlags_ReadOnly)

  001aa	8b 45 20	 mov	 eax, DWORD PTR _flags$[ebp]
  001ad	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  001b2	74 11		 je	 SHORT $LN8@InputScala

; 2913 :             button_flags |= ImGuiButtonFlags_Disabled;

  001b4	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$4[ebp]
  001ba	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  001bf	89 85 60 ff ff
	ff		 mov	 DWORD PTR _button_flags$4[ebp], eax
$LN8@InputScala:

; 2914 :         SameLine(0, style.ItemInnerSpacing.x);

  001c5	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  001c8	51		 push	 ecx
  001c9	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  001ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d3	51		 push	 ecx
  001d4	0f 57 c0	 xorps	 xmm0, xmm0
  001d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001dc	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  001e1	83 c4 08	 add	 esp, 8

; 2915 :         if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))

  001e4	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$4[ebp]
  001ea	50		 push	 eax
  001eb	51		 push	 ecx
  001ec	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _button_size$6[ebp]
  001f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f9	51		 push	 ecx
  001fa	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _button_size$6[ebp]
  00202	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00207	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0020d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00212	50		 push	 eax
  00213	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9@
  00218	e8 00 00 00 00	 call	 ?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z ; ImGui::ButtonEx
  0021d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00220	0f b6 c8	 movzx	 ecx, al
  00223	85 c9		 test	 ecx, ecx
  00225	74 49		 je	 SHORT $LN9@InputScala

; 2916 :         {
; 2917 :             DataTypeApplyOp(data_type, '-', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);

  00227	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0022a	0f b6 88 00 01
	00 00		 movzx	 ecx, BYTE PTR [eax+256]
  00231	85 c9		 test	 ecx, ecx
  00233	74 11		 je	 SHORT $LN15@InputScala
  00235	83 7d 18 00	 cmp	 DWORD PTR _p_step_fast$[ebp], 0
  00239	74 0b		 je	 SHORT $LN15@InputScala
  0023b	8b 55 18	 mov	 edx, DWORD PTR _p_step_fast$[ebp]
  0023e	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv174[ebp], edx
  00244	eb 09		 jmp	 SHORT $LN16@InputScala
$LN15@InputScala:
  00246	8b 45 14	 mov	 eax, DWORD PTR _p_step$[ebp]
  00249	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
$LN16@InputScala:
  0024f	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv174[ebp]
  00255	51		 push	 ecx
  00256	8b 55 10	 mov	 edx, DWORD PTR _p_data$[ebp]
  00259	52		 push	 edx
  0025a	8b 45 10	 mov	 eax, DWORD PTR _p_data$[ebp]
  0025d	50		 push	 eax
  0025e	6a 2d		 push	 45			; 0000002dH
  00260	8b 4d 0c	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 ?DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z ; ImGui::DataTypeApplyOp
  00269	83 c4 14	 add	 esp, 20			; 00000014H

; 2918 :             value_changed = true;

  0026c	c6 45 8b 01	 mov	 BYTE PTR _value_changed$[ebp], 1
$LN9@InputScala:

; 2919 :         }
; 2920 :         SameLine(0, style.ItemInnerSpacing.x);

  00270	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00273	51		 push	 ecx
  00274	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00279	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027e	51		 push	 ecx
  0027f	0f 57 c0	 xorps	 xmm0, xmm0
  00282	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00287	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  0028c	83 c4 08	 add	 esp, 8

; 2921 :         if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))

  0028f	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _button_flags$4[ebp]
  00295	50		 push	 eax
  00296	51		 push	 ecx
  00297	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _button_size$6[ebp]
  0029f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a4	51		 push	 ecx
  002a5	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _button_size$6[ebp]
  002ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b2	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002b8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002bd	50		 push	 eax
  002be	68 00 00 00 00	 push	 OFFSET ??_C@_01MIFGBAGJ@?$CL@
  002c3	e8 00 00 00 00	 call	 ?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z ; ImGui::ButtonEx
  002c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002cb	0f b6 c8	 movzx	 ecx, al
  002ce	85 c9		 test	 ecx, ecx
  002d0	74 49		 je	 SHORT $LN10@InputScala

; 2922 :         {
; 2923 :             DataTypeApplyOp(data_type, '+', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);

  002d2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  002d5	0f b6 88 00 01
	00 00		 movzx	 ecx, BYTE PTR [eax+256]
  002dc	85 c9		 test	 ecx, ecx
  002de	74 11		 je	 SHORT $LN17@InputScala
  002e0	83 7d 18 00	 cmp	 DWORD PTR _p_step_fast$[ebp], 0
  002e4	74 0b		 je	 SHORT $LN17@InputScala
  002e6	8b 55 18	 mov	 edx, DWORD PTR _p_step_fast$[ebp]
  002e9	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv199[ebp], edx
  002ef	eb 09		 jmp	 SHORT $LN18@InputScala
$LN17@InputScala:
  002f1	8b 45 14	 mov	 eax, DWORD PTR _p_step$[ebp]
  002f4	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv199[ebp], eax
$LN18@InputScala:
  002fa	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv199[ebp]
  00300	51		 push	 ecx
  00301	8b 55 10	 mov	 edx, DWORD PTR _p_data$[ebp]
  00304	52		 push	 edx
  00305	8b 45 10	 mov	 eax, DWORD PTR _p_data$[ebp]
  00308	50		 push	 eax
  00309	6a 2b		 push	 43			; 0000002bH
  0030b	8b 4d 0c	 mov	 ecx, DWORD PTR _data_type$[ebp]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?DataTypeApplyOp@ImGui@@YAXHHPAX0PBX@Z ; ImGui::DataTypeApplyOp
  00314	83 c4 14	 add	 esp, 20			; 00000014H

; 2924 :             value_changed = true;

  00317	c6 45 8b 01	 mov	 BYTE PTR _value_changed$[ebp], 1
$LN10@InputScala:

; 2925 :         }
; 2926 : 
; 2927 :         const char* label_end = FindRenderedTextEnd(label);

  0031b	6a 00		 push	 0
  0031d	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  00326	83 c4 08	 add	 esp, 8
  00329	89 85 54 ff ff
	ff		 mov	 DWORD PTR _label_end$3[ebp], eax

; 2928 :         if (label != label_end)

  0032f	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00332	3b 85 54 ff ff
	ff		 cmp	 eax, DWORD PTR _label_end$3[ebp]
  00338	74 34		 je	 SHORT $LN11@InputScala

; 2929 :         {
; 2930 :             SameLine(0, style.ItemInnerSpacing.x);

  0033a	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0033d	51		 push	 ecx
  0033e	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00343	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00348	51		 push	 ecx
  00349	0f 57 c0	 xorps	 xmm0, xmm0
  0034c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00351	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00356	83 c4 08	 add	 esp, 8

; 2931 :             TextEx(label, label_end);

  00359	6a 00		 push	 0
  0035b	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _label_end$3[ebp]
  00361	50		 push	 eax
  00362	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00365	51		 push	 ecx
  00366	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  0036b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@InputScala:

; 2932 :         }
; 2933 :         style.FramePadding = backup_frame_padding;

  0036e	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00371	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _backup_frame_padding$5[ebp]
  00377	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  0037a	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _backup_frame_padding$5[ebp+4]
  00380	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 2934 : 
; 2935 :         PopID();

  00383	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2936 :         EndGroup();

  00388	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 2937 :     }

  0038d	eb 46		 jmp	 SHORT $LN12@InputScala
$LN5@InputScala:

; 2938 :     else
; 2939 :     {
; 2940 :         if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))

  0038f	6a 00		 push	 0
  00391	6a 00		 push	 0
  00393	8b 45 20	 mov	 eax, DWORD PTR _flags$[ebp]
  00396	50		 push	 eax
  00397	6a 40		 push	 64			; 00000040H
  00399	8d 4d 94	 lea	 ecx, DWORD PTR _buf$[ebp]
  0039c	51		 push	 ecx
  0039d	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  003a0	52		 push	 edx
  003a1	e8 00 00 00 00	 call	 ?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputText
  003a6	83 c4 18	 add	 esp, 24			; 00000018H
  003a9	0f b6 c0	 movzx	 eax, al
  003ac	85 c0		 test	 eax, eax
  003ae	74 25		 je	 SHORT $LN12@InputScala

; 2941 :             value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, p_data, format);

  003b0	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  003b3	50		 push	 eax
  003b4	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  003b7	51		 push	 ecx
  003b8	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  003bb	52		 push	 edx
  003bc	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  003bf	8b 88 2c 1e 00
	00		 mov	 ecx, DWORD PTR [eax+7724]
  003c5	51		 push	 ecx
  003c6	8d 55 94	 lea	 edx, DWORD PTR _buf$[ebp]
  003c9	52		 push	 edx
  003ca	e8 00 00 00 00	 call	 ?DataTypeApplyOpFromText@ImGui@@YA_NPBD0HPAX0@Z ; ImGui::DataTypeApplyOpFromText
  003cf	83 c4 14	 add	 esp, 20			; 00000014H
  003d2	88 45 8b	 mov	 BYTE PTR _value_changed$[ebp], al
$LN12@InputScala:

; 2942 :     }
; 2943 :     if (value_changed)

  003d5	0f b6 45 8b	 movzx	 eax, BYTE PTR _value_changed$[ebp]
  003d9	85 c0		 test	 eax, eax
  003db	74 12		 je	 SHORT $LN13@InputScala

; 2944 :         MarkItemEdited(window->DC.LastItemId);

  003dd	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  003e0	8b 88 08 01 00
	00		 mov	 ecx, DWORD PTR [eax+264]
  003e6	51		 push	 ecx
  003e7	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  003ec	83 c4 04	 add	 esp, 4
$LN13@InputScala:

; 2945 : 
; 2946 :     return value_changed;

  003ef	8a 45 8b	 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@InputScala:

; 2947 : }

  003f2	52		 push	 edx
  003f3	8b cd		 mov	 ecx, ebp
  003f5	50		 push	 eax
  003f6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@InputScala
  003fc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00401	58		 pop	 eax
  00402	5a		 pop	 edx
  00403	5f		 pop	 edi
  00404	5e		 pop	 esi
  00405	5b		 pop	 ebx
  00406	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00409	33 cd		 xor	 ecx, ebp
  0040b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00410	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  00416	3b ec		 cmp	 ebp, esp
  00418	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0041d	8b e5		 mov	 esp, ebp
  0041f	5d		 pop	 ebp
  00420	c3		 ret	 0
  00421	0f 1f 00	 npad	 3
$LN22@InputScala:
  00424	02 00 00 00	 DD	 2
  00428	00 00 00 00	 DD	 $LN21@InputScala
$LN21@InputScala:
  0042c	94 ff ff ff	 DD	 -108			; ffffff94H
  00430	40 00 00 00	 DD	 64			; 00000040H
  00434	00 00 00 00	 DD	 $LN19@InputScala
  00438	6c ff ff ff	 DD	 -148			; ffffff6cH
  0043c	08 00 00 00	 DD	 8
  00440	00 00 00 00	 DD	 $LN20@InputScala
$LN20@InputScala:
  00444	62		 DB	 98			; 00000062H
  00445	61		 DB	 97			; 00000061H
  00446	63		 DB	 99			; 00000063H
  00447	6b		 DB	 107			; 0000006bH
  00448	75		 DB	 117			; 00000075H
  00449	70		 DB	 112			; 00000070H
  0044a	5f		 DB	 95			; 0000005fH
  0044b	66		 DB	 102			; 00000066H
  0044c	72		 DB	 114			; 00000072H
  0044d	61		 DB	 97			; 00000061H
  0044e	6d		 DB	 109			; 0000006dH
  0044f	65		 DB	 101			; 00000065H
  00450	5f		 DB	 95			; 0000005fH
  00451	70		 DB	 112			; 00000070H
  00452	61		 DB	 97			; 00000061H
  00453	64		 DB	 100			; 00000064H
  00454	64		 DB	 100			; 00000064H
  00455	69		 DB	 105			; 00000069H
  00456	6e		 DB	 110			; 0000006eH
  00457	67		 DB	 103			; 00000067H
  00458	00		 DB	 0
$LN19@InputScala:
  00459	62		 DB	 98			; 00000062H
  0045a	75		 DB	 117			; 00000075H
  0045b	66		 DB	 102			; 00000066H
  0045c	00		 DB	 0
?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z ENDP		; ImGui::InputScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputDouble@ImGui@@YA_NPBDPANNN0H@Z
_TEXT	SEGMENT
tv72 = -200						; size = 4
tv69 = -196						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_step$ = 16						; size = 8
_step_fast$ = 24					; size = 8
_format$ = 32						; size = 4
_flags$ = 36						; size = 4
?InputDouble@ImGui@@YA_NPBDPANNN0H@Z PROC		; ImGui::InputDouble, COMDAT

; 3063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3064 :     flags |= ImGuiInputTextFlags_CharsScientific;

  00028	8b 45 24	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  00030	89 45 24	 mov	 DWORD PTR _flags$[ebp], eax

; 3065 :     return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step>0.0 ? &step : NULL), (void*)(step_fast>0.0 ? &step_fast : NULL), format, flags);

  00033	f2 0f 10 45 18	 movsd	 xmm0, QWORD PTR _step_fast$[ebp]
  00038	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00040	76 0b		 jbe	 SHORT $LN3@InputDoubl
  00042	8d 45 18	 lea	 eax, DWORD PTR _step_fast$[ebp]
  00045	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0004b	eb 0a		 jmp	 SHORT $LN4@InputDoubl
$LN3@InputDoubl:
  0004d	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@InputDoubl:
  00057	f2 0f 10 45 10	 movsd	 xmm0, QWORD PTR _step$[ebp]
  0005c	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00064	76 0b		 jbe	 SHORT $LN5@InputDoubl
  00066	8d 4d 10	 lea	 ecx, DWORD PTR _step$[ebp]
  00069	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  0006f	eb 0a		 jmp	 SHORT $LN6@InputDoubl
$LN5@InputDoubl:
  00071	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
$LN6@InputDoubl:
  0007b	8b 55 24	 mov	 edx, DWORD PTR _flags$[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  00082	50		 push	 eax
  00083	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  00089	51		 push	 ecx
  0008a	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  00090	52		 push	 edx
  00091	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00094	50		 push	 eax
  00095	6a 09		 push	 9
  00097	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 ?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z ; ImGui::InputScalar
  000a0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3066 : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000ac	3b ec		 cmp	 ebp, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?InputDouble@ImGui@@YA_NPBDPANNN0H@Z ENDP		; ImGui::InputDouble
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputInt4@ImGui@@YA_NPBDQAHH@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_flags$ = 16						; size = 4
?InputInt4@ImGui@@YA_NPBDQAHH@Z PROC			; ImGui::InputInt4, COMDAT

; 3058 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3059 :     return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);

  00028	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 04		 push	 4
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0003a	51		 push	 ecx
  0003b	6a 04		 push	 4
  0003d	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  00046	83 c4 20	 add	 esp, 32			; 00000020H

; 3060 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?InputInt4@ImGui@@YA_NPBDQAHH@Z ENDP			; ImGui::InputInt4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputInt3@ImGui@@YA_NPBDQAHH@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_flags$ = 16						; size = 4
?InputInt3@ImGui@@YA_NPBDQAHH@Z PROC			; ImGui::InputInt3, COMDAT

; 3053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3054 :     return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);

  00028	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 03		 push	 3
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0003a	51		 push	 ecx
  0003b	6a 04		 push	 4
  0003d	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  00046	83 c4 20	 add	 esp, 32			; 00000020H

; 3055 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?InputInt3@ImGui@@YA_NPBDQAHH@Z ENDP			; ImGui::InputInt3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputInt2@ImGui@@YA_NPBDQAHH@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_flags$ = 16						; size = 4
?InputInt2@ImGui@@YA_NPBDQAHH@Z PROC			; ImGui::InputInt2, COMDAT

; 3048 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3049 :     return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);

  00028	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 02		 push	 2
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0003a	51		 push	 ecx
  0003b	6a 04		 push	 4
  0003d	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  00046	83 c4 20	 add	 esp, 32			; 00000020H

; 3050 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?InputInt2@ImGui@@YA_NPBDQAHH@Z ENDP			; ImGui::InputInt2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputInt@ImGui@@YA_NPBDPAHHHH@Z
_TEXT	SEGMENT
tv74 = -212						; size = 4
tv71 = -208						; size = 4
tv66 = -208						; size = 4
_format$ = -8						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_step$ = 16						; size = 4
_step_fast$ = 20					; size = 4
_flags$ = 24						; size = 4
?InputInt@ImGui@@YA_NPBDPAHHHH@Z PROC			; ImGui::InputInt, COMDAT

; 3041 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3042 :     // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
; 3043 :     const char* format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";

  00028	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	83 e0 02	 and	 eax, 2
  0002e	74 0c		 je	 SHORT $LN3@InputInt
  00030	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], OFFSET ??_C@_04JIMNDDED@?$CF08X@
  0003a	eb 0a		 jmp	 SHORT $LN4@InputInt
$LN3@InputInt:
  0003c	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], OFFSET ??_C@_02DPKJAMEF@?$CFd@
$LN4@InputInt:
  00046	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0004c	89 4d f8	 mov	 DWORD PTR _format$[ebp], ecx

; 3044 :     return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step>0 ? &step : NULL), (void*)(step_fast>0 ? &step_fast : NULL), format, flags);

  0004f	83 7d 14 00	 cmp	 DWORD PTR _step_fast$[ebp], 0
  00053	7e 0b		 jle	 SHORT $LN5@InputInt
  00055	8d 45 14	 lea	 eax, DWORD PTR _step_fast$[ebp]
  00058	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  0005e	eb 0a		 jmp	 SHORT $LN6@InputInt
$LN5@InputInt:
  00060	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN6@InputInt:
  0006a	83 7d 10 00	 cmp	 DWORD PTR _step$[ebp], 0
  0006e	7e 0b		 jle	 SHORT $LN7@InputInt
  00070	8d 4d 10	 lea	 ecx, DWORD PTR _step$[ebp]
  00073	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv74[ebp], ecx
  00079	eb 0a		 jmp	 SHORT $LN8@InputInt
$LN7@InputInt:
  0007b	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
$LN8@InputInt:
  00085	8b 55 18	 mov	 edx, DWORD PTR _flags$[ebp]
  00088	52		 push	 edx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _format$[ebp]
  0008c	50		 push	 eax
  0008d	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  00093	51		 push	 ecx
  00094	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv74[ebp]
  0009a	52		 push	 edx
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0009e	50		 push	 eax
  0009f	6a 04		 push	 4
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z ; ImGui::InputScalar
  000aa	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3045 : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?InputInt@ImGui@@YA_NPBDPAHHHH@Z ENDP			; ImGui::InputInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat4@ImGui@@YA_NPBDQAM0H@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_format$ = 16						; size = 4
_flags$ = 20						; size = 4
?InputFloat4@ImGui@@YA_NPBDQAM0H@Z PROC			; ImGui::InputFloat4, COMDAT

; 3001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3002 :     return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);

  00028	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _format$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 04		 push	 4
  00036	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00039	52		 push	 edx
  0003a	6a 08		 push	 8
  0003c	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  00045	83 c4 20	 add	 esp, 32			; 00000020H

; 3003 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?InputFloat4@ImGui@@YA_NPBDQAM0H@Z ENDP			; ImGui::InputFloat4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat3@ImGui@@YA_NPBDQAM0H@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_format$ = 16						; size = 4
_flags$ = 20						; size = 4
?InputFloat3@ImGui@@YA_NPBDQAM0H@Z PROC			; ImGui::InputFloat3, COMDAT

; 2996 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2997 :     return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);

  00028	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _format$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 03		 push	 3
  00036	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00039	52		 push	 edx
  0003a	6a 08		 push	 8
  0003c	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  00045	83 c4 20	 add	 esp, 32			; 00000020H

; 2998 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?InputFloat3@ImGui@@YA_NPBDQAM0H@Z ENDP			; ImGui::InputFloat3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat2@ImGui@@YA_NPBDQAM0H@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_format$ = 16						; size = 4
_flags$ = 20						; size = 4
?InputFloat2@ImGui@@YA_NPBDQAM0H@Z PROC			; ImGui::InputFloat2, COMDAT

; 2991 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2992 :     return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);

  00028	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _format$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 02		 push	 2
  00036	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00039	52		 push	 edx
  0003a	6a 08		 push	 8
  0003c	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?InputScalarN@ImGui@@YA_NPBDHPAXHPBX20H@Z ; ImGui::InputScalarN
  00045	83 c4 20	 add	 esp, 32			; 00000020H

; 2993 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?InputFloat2@ImGui@@YA_NPBDQAM0H@Z ENDP			; ImGui::InputFloat2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat@ImGui@@YA_NPBDPAMMM0H@Z
_TEXT	SEGMENT
tv72 = -200						; size = 4
tv69 = -196						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_step$ = 16						; size = 4
_step_fast$ = 20					; size = 4
_format$ = 24						; size = 4
_flags$ = 28						; size = 4
?InputFloat@ImGui@@YA_NPBDPAMMM0H@Z PROC		; ImGui::InputFloat, COMDAT

; 2985 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2986 :     flags |= ImGuiInputTextFlags_CharsScientific;

  00028	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  00030	89 45 1c	 mov	 DWORD PTR _flags$[ebp], eax

; 2987 :     return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), format, flags);

  00033	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _step_fast$[ebp]
  00038	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0003f	76 0b		 jbe	 SHORT $LN3@InputFloat
  00041	8d 45 14	 lea	 eax, DWORD PTR _step_fast$[ebp]
  00044	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0004a	eb 0a		 jmp	 SHORT $LN4@InputFloat
$LN3@InputFloat:
  0004c	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
$LN4@InputFloat:
  00056	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _step$[ebp]
  0005b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00062	76 0b		 jbe	 SHORT $LN5@InputFloat
  00064	8d 4d 10	 lea	 ecx, DWORD PTR _step$[ebp]
  00067	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  0006d	eb 0a		 jmp	 SHORT $LN6@InputFloat
$LN5@InputFloat:
  0006f	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
$LN6@InputFloat:
  00079	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00080	50		 push	 eax
  00081	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  00087	51		 push	 ecx
  00088	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00092	50		 push	 eax
  00093	6a 08		 push	 8
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ?InputScalar@ImGui@@YA_NPBDHPAXPBX20H@Z ; ImGui::InputScalar
  0009e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2988 : }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000aa	3b ec		 cmp	 ebp, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?InputFloat@ImGui@@YA_NPBDPAMMM0H@Z ENDP		; ImGui::InputFloat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z
_TEXT	SEGMENT
$T1 = -204						; size = 8
_label$ = 8						; size = 4
_hint$ = 12						; size = 4
_buf$ = 16						; size = 4
_buf_size$ = 20						; size = 4
_flags$ = 24						; size = 4
_callback$ = 28						; size = 4
_user_data$ = 32					; size = 4
?InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z PROC ; ImGui::InputTextWithHint, COMDAT

; 3089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3090 :     IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()

  00028	8b 45 18	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00030	74 26		 je	 SHORT $LN3@InputTextW
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  00038	83 c1 01	 add	 ecx, 1
  0003b	8b f4		 mov	 esi, esp
  0003d	51		 push	 ecx
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1FC@IFNBIILP@?$AA?$CB?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@InputTextW:

; 3091 :     return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

  00058	8b 45 20	 mov	 eax, DWORD PTR _user_data$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d 1c	 mov	 ecx, DWORD PTR _callback$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 18	 mov	 edx, DWORD PTR _flags$[ebp]
  00063	52		 push	 edx
  00064	51		 push	 ecx
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006d	51		 push	 ecx
  0006e	0f 57 c0	 xorps	 xmm0, xmm0
  00071	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00076	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0007c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00081	50		 push	 eax
  00082	8b 45 14	 mov	 eax, DWORD PTR _buf_size$[ebp]
  00085	50		 push	 eax
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _buf$[ebp]
  00089	51		 push	 ecx
  0008a	8b 55 0c	 mov	 edx, DWORD PTR _hint$[ebp]
  0008d	52		 push	 edx
  0008e	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
  00097	83 c4 20	 add	 esp, 32			; 00000020H

; 3092 : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?InputTextWithHint@ImGui@@YA_NPBD0PADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ENDP ; ImGui::InputTextWithHint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_buf$ = 12						; size = 4
_buf_size$ = 16						; size = 4
_size$ = 20						; size = 4
_flags$ = 24						; size = 4
_callback$ = 28						; size = 4
_user_data$ = 32					; size = 4
?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z PROC ; ImGui::InputTextMultiline, COMDAT

; 3084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3085 :     return InputTextEx(label, NULL, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);

  00028	8b 45 20	 mov	 eax, DWORD PTR _user_data$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 1c	 mov	 ecx, DWORD PTR _callback$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 18	 mov	 edx, DWORD PTR _flags$[ebp]
  00033	81 ca 00 00 10
	00		 or	 edx, 1048576		; 00100000H
  00039	52		 push	 edx
  0003a	8b 45 14	 mov	 eax, DWORD PTR _size$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _buf_size$[ebp]
  00041	51		 push	 ecx
  00042	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00045	52		 push	 edx
  00046	6a 00		 push	 0
  00048	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
  00051	83 c4 20	 add	 esp, 32			; 00000020H

; 3086 : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ENDP ; ImGui::InputTextMultiline
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z
_TEXT	SEGMENT
$T1 = -204						; size = 8
_label$ = 8						; size = 4
_buf$ = 12						; size = 4
_buf_size$ = 16						; size = 4
_flags$ = 20						; size = 4
_callback$ = 24						; size = 4
_user_data$ = 28					; size = 4
?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z PROC ; ImGui::InputText, COMDAT

; 3078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3079 :     IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()

  00028	8b 45 14	 mov	 eax, DWORD PTR _flags$[ebp]
  0002b	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00030	74 26		 je	 SHORT $LN3@InputText
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z@4JA
  00038	83 c1 01	 add	 ecx, 1
  0003b	8b f4		 mov	 esi, esp
  0003d	51		 push	 ecx
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1FC@IFNBIILP@?$AA?$CB?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAI?$AAm?$AAG?$AAu?$AAi@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@InputText:

; 3080 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);

  00058	8b 45 1c	 mov	 eax, DWORD PTR _user_data$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d 18	 mov	 ecx, DWORD PTR _callback$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  00063	52		 push	 edx
  00064	51		 push	 ecx
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006d	51		 push	 ecx
  0006e	0f 57 c0	 xorps	 xmm0, xmm0
  00071	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00076	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0007c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00081	50		 push	 eax
  00082	8b 45 10	 mov	 eax, DWORD PTR _buf_size$[ebp]
  00085	50		 push	 eax
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00089	51		 push	 ecx
  0008a	6a 00		 push	 0
  0008c	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?InputTextEx@ImGui@@YA_NPBD0PADHABUImVec2@@HP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
  00095	83 c4 20	 add	 esp, 32			; 00000020H

; 3081 : }

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiInputTextCallbackData@@@ZPAX@Z ENDP ; ImGui::InputText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?VSliderScalar@ImGui@@YA_NPBDABUImVec2@@HPAXPBX30M@Z
_TEXT	SEGMENT
tv187 = -556						; size = 4
tv257 = -552						; size = 4
tv188 = -552						; size = 4
tv131 = -552						; size = 4
$T1 = -544						; size = 8
$T2 = -528						; size = 8
$T3 = -512						; size = 8
$T4 = -496						; size = 8
$T5 = -480						; size = 8
$T6 = -464						; size = 8
_value_buf_end$ = -256					; size = 4
_value_buf$ = -244					; size = 64
_value_changed$ = -169					; size = 1
_grab_bb$ = -160					; size = 16
_frame_col$ = -136					; size = 4
_hovered$ = -121					; size = 1
_bb$ = -112						; size = 16
_frame_bb$ = -88					; size = 16
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_size$ = 12						; size = 4
_data_type$ = 16					; size = 4
_p_data$ = 20						; size = 4
_p_min$ = 24						; size = 4
_p_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
?VSliderScalar@ImGui@@YA_NPBDABUImVec2@@HPAXPBX30M@Z PROC ; ImGui::VSliderScalar, COMDAT

; 2677 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-556]
  00012	b9 8b 00 00 00	 mov	 ecx, 139		; 0000008bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2678 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 2679 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@VSliderSca

; 2680 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 76 04 00 00	 jmp	 $LN1@VSliderSca
$LN2@VSliderSca:

; 2681 : 
; 2682 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 2683 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 2684 :     const ImGuiID id = window->GetID(label);

  0005f	6a 00		 push	 0
  00061	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00068	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0006d	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 2685 : 
; 2686 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  00070	51		 push	 ecx
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	6a 01		 push	 1
  00080	6a 00		 push	 0
  00082	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00085	50		 push	 eax
  00086	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0008f	83 c4 14	 add	 esp, 20			; 00000014H

; 2687 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);

  00092	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00095	50		 push	 eax
  00096	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00099	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  0009f	51		 push	 ecx
  000a0	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	50		 push	 eax
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000b3	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000b8	50		 push	 eax
  000b9	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  000bc	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 2688 :     const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

  000c1	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  000c6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000cd	76 17		 jbe	 SHORT $LN14@VSliderSca
  000cf	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000d2	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  000d7	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  000dc	f3 0f 11 85 d8
	fd ff ff	 movss	 DWORD PTR tv131[ebp], xmm0
  000e4	eb 0b		 jmp	 SHORT $LN15@VSliderSca
$LN14@VSliderSca:
  000e6	0f 57 c0	 xorps	 xmm0, xmm0
  000e9	f3 0f 11 85 d8
	fd ff ff	 movss	 DWORD PTR tv131[ebp], xmm0
$LN15@VSliderSca:
  000f1	51		 push	 ecx
  000f2	0f 57 c0	 xorps	 xmm0, xmm0
  000f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fa	51		 push	 ecx
  000fb	f3 0f 10 85 d8
	fd ff ff	 movss	 xmm0, DWORD PTR tv131[ebp]
  00103	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00108	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0010e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00113	50		 push	 eax
  00114	8d 4d b0	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  00117	51		 push	 ecx
  00118	8d 95 10 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
  00127	50		 push	 eax
  00128	8d 45 a8	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  0012b	50		 push	 eax
  0012c	8d 4d 90	 lea	 ecx, DWORD PTR _bb$[ebp]
  0012f	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 2689 : 
; 2690 :     ItemSize(bb, style.FramePadding.y);

  00134	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00137	51		 push	 ecx
  00138	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0013d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00142	8d 4d 90	 lea	 ecx, DWORD PTR _bb$[ebp]
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  0014b	83 c4 08	 add	 esp, 8

; 2691 :     if (!ItemAdd(frame_bb, id))

  0014e	6a 00		 push	 0
  00150	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00153	50		 push	 eax
  00154	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00157	51		 push	 ecx
  00158	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	0f b6 d0	 movzx	 edx, al
  00163	85 d2		 test	 edx, edx
  00165	75 07		 jne	 SHORT $LN3@VSliderSca

; 2692 :         return false;

  00167	32 c0		 xor	 al, al
  00169	e9 54 03 00 00	 jmp	 $LN1@VSliderSca
$LN3@VSliderSca:

; 2693 : 
; 2694 :     // Default format string when passing NULL
; 2695 :     if (format == NULL)

  0016e	83 7d 20 00	 cmp	 DWORD PTR _format$[ebp], 0
  00172	75 14		 jne	 SHORT $LN4@VSliderSca

; 2696 :         format = DataTypeGetInfo(data_type)->PrintFmt;

  00174	8b 45 10	 mov	 eax, DWORD PTR _data_type$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z ; ImGui::DataTypeGetInfo
  0017d	83 c4 04	 add	 esp, 4
  00180	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00183	89 4d 20	 mov	 DWORD PTR _format$[ebp], ecx
  00186	eb 2a		 jmp	 SHORT $LN6@VSliderSca
$LN4@VSliderSca:

; 2697 :     else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)

  00188	83 7d 10 04	 cmp	 DWORD PTR _data_type$[ebp], 4
  0018c	75 24		 jne	 SHORT $LN6@VSliderSca
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00193	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _strcmp
  0019c	83 c4 08	 add	 esp, 8
  0019f	85 c0		 test	 eax, eax
  001a1	74 0f		 je	 SHORT $LN6@VSliderSca

; 2698 :         format = PatchFormatStringFloatToInt(format);

  001a3	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ?PatchFormatStringFloatToInt@@YAPBDPBD@Z ; PatchFormatStringFloatToInt
  001ac	83 c4 04	 add	 esp, 4
  001af	89 45 20	 mov	 DWORD PTR _format$[ebp], eax
$LN6@VSliderSca:

; 2699 : 
; 2700 :     const bool hovered = ItemHoverable(frame_bb, id);

  001b2	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  001b5	50		 push	 eax
  001b6	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z ; ImGui::ItemHoverable
  001bf	83 c4 08	 add	 esp, 8
  001c2	88 45 87	 mov	 BYTE PTR _hovered$[ebp], al

; 2701 :     if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)

  001c5	0f b6 45 87	 movzx	 eax, BYTE PTR _hovered$[ebp]
  001c9	85 c0		 test	 eax, eax
  001cb	74 17		 je	 SHORT $LN9@VSliderSca
  001cd	b8 01 00 00 00	 mov	 eax, 1
  001d2	6b c8 00	 imul	 ecx, eax, 0
  001d5	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  001d8	0f b6 84 0a d8
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+984]
  001e0	85 c0		 test	 eax, eax
  001e2	75 1c		 jne	 SHORT $LN8@VSliderSca
$LN9@VSliderSca:
  001e4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  001e7	8b 88 d8 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6872]
  001ed	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  001f0	74 0e		 je	 SHORT $LN8@VSliderSca
  001f2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  001f5	8b 88 e4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6884]
  001fb	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  001fe	75 41		 jne	 SHORT $LN7@VSliderSca
$LN8@VSliderSca:

; 2702 :     {
; 2703 :         SetActiveID(id, window);

  00200	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00203	50		 push	 eax
  00204	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00207	51		 push	 ecx
  00208	e8 00 00 00 00	 call	 ?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
  0020d	83 c4 08	 add	 esp, 8

; 2704 :         SetFocusID(id, window);

  00210	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00213	50		 push	 eax
  00214	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00217	51		 push	 ecx
  00218	e8 00 00 00 00	 call	 ?SetFocusID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetFocusID
  0021d	83 c4 08	 add	 esp, 8

; 2705 :         FocusWindow(window);

  00220	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00223	50		 push	 eax
  00224	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  00229	83 c4 04	 add	 esp, 4

; 2706 :         g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);

  0022c	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0022f	8b 88 f8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6648]
  00235	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00238	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  0023b	89 8a f8 19 00
	00		 mov	 DWORD PTR [edx+6648], ecx
$LN7@VSliderSca:

; 2707 :     }
; 2708 : 
; 2709 :     // Draw frame
; 2710 :     const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

  00241	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00244	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0024a	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0024d	75 0c		 jne	 SHORT $LN18@VSliderSca
  0024f	c7 85 d8 fd ff
	ff 09 00 00 00	 mov	 DWORD PTR tv188[ebp], 9
  00259	eb 30		 jmp	 SHORT $LN19@VSliderSca
$LN18@VSliderSca:
  0025b	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  0025e	8b 82 d0 19 00
	00		 mov	 eax, DWORD PTR [edx+6608]
  00264	3b 45 d0	 cmp	 eax, DWORD PTR _id$[ebp]
  00267	75 0c		 jne	 SHORT $LN16@VSliderSca
  00269	c7 85 d4 fd ff
	ff 08 00 00 00	 mov	 DWORD PTR tv187[ebp], 8
  00273	eb 0a		 jmp	 SHORT $LN17@VSliderSca
$LN16@VSliderSca:
  00275	c7 85 d4 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR tv187[ebp], 7
$LN17@VSliderSca:
  0027f	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR tv187[ebp]
  00285	89 8d d8 fd ff
	ff		 mov	 DWORD PTR tv188[ebp], ecx
$LN19@VSliderSca:
  0028b	51		 push	 ecx
  0028c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00294	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00299	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR tv188[ebp]
  0029f	52		 push	 edx
  002a0	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  002a5	83 c4 08	 add	 esp, 8
  002a8	89 85 78 ff ff
	ff		 mov	 DWORD PTR _frame_col$[ebp], eax

; 2711 :     RenderNavHighlight(frame_bb, id);

  002ae	6a 01		 push	 1
  002b0	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  002b3	50		 push	 eax
  002b4	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  002b7	51		 push	 ecx
  002b8	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  002bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2712 :     RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

  002c0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  002c3	51		 push	 ecx
  002c4	f3 0f 10 80 50
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5456]
  002cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d1	6a 01		 push	 1
  002d3	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _frame_col$[ebp]
  002d9	51		 push	 ecx
  002da	8b 55 b4	 mov	 edx, DWORD PTR _frame_bb$[ebp+12]
  002dd	52		 push	 edx
  002de	8b 45 b0	 mov	 eax, DWORD PTR _frame_bb$[ebp+8]
  002e1	50		 push	 eax
  002e2	8b 4d ac	 mov	 ecx, DWORD PTR _frame_bb$[ebp+4]
  002e5	51		 push	 ecx
  002e6	8b 55 a8	 mov	 edx, DWORD PTR _frame_bb$[ebp]
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  002ef	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2713 : 
; 2714 :     // Slider behavior
; 2715 :     ImRect grab_bb;

  002f2	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _grab_bb$[ebp]
  002f8	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect

; 2716 :     const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);

  002fd	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _grab_bb$[ebp]
  00303	50		 push	 eax
  00304	6a 01		 push	 1
  00306	51		 push	 ecx
  00307	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  0030c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00311	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  00314	51		 push	 ecx
  00315	8b 55 1c	 mov	 edx, DWORD PTR _p_max$[ebp]
  00318	52		 push	 edx
  00319	8b 45 18	 mov	 eax, DWORD PTR _p_min$[ebp]
  0031c	50		 push	 eax
  0031d	8b 4d 14	 mov	 ecx, DWORD PTR _p_data$[ebp]
  00320	51		 push	 ecx
  00321	8b 55 10	 mov	 edx, DWORD PTR _data_type$[ebp]
  00324	52		 push	 edx
  00325	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00328	50		 push	 eax
  00329	8d 4d a8	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  0032c	51		 push	 ecx
  0032d	e8 00 00 00 00	 call	 ?SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU2@@Z ; ImGui::SliderBehavior
  00332	83 c4 28	 add	 esp, 40			; 00000028H
  00335	88 85 57 ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al

; 2717 :     if (value_changed)

  0033b	0f b6 85 57 ff
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  00342	85 c0		 test	 eax, eax
  00344	74 0c		 je	 SHORT $LN10@VSliderSca

; 2718 :         MarkItemEdited(id);

  00346	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  0034f	83 c4 04	 add	 esp, 4
$LN10@VSliderSca:

; 2719 : 
; 2720 :     // Render grab
; 2721 :     if (grab_bb.Max.y > grab_bb.Min.y)

  00352	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_bb$[ebp+12]
  0035a	0f 2f 85 64 ff
	ff ff		 comiss	 xmm0, DWORD PTR _grab_bb$[ebp+4]
  00361	76 6e		 jbe	 SHORT $LN11@VSliderSca

; 2722 :         window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

  00363	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00366	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0036c	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0036f	75 0c		 jne	 SHORT $LN20@VSliderSca
  00371	c7 85 d8 fd ff
	ff 14 00 00 00	 mov	 DWORD PTR tv257[ebp], 20 ; 00000014H
  0037b	eb 0a		 jmp	 SHORT $LN21@VSliderSca
$LN20@VSliderSca:
  0037d	c7 85 d8 fd ff
	ff 13 00 00 00	 mov	 DWORD PTR tv257[ebp], 19 ; 00000013H
$LN21@VSliderSca:
  00387	6a 0f		 push	 15			; 0000000fH
  00389	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  0038c	51		 push	 ecx
  0038d	f3 0f 10 42 74	 movss	 xmm0, DWORD PTR [edx+116]
  00392	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00397	51		 push	 ecx
  00398	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a5	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR tv257[ebp]
  003ab	50		 push	 eax
  003ac	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  003b1	83 c4 08	 add	 esp, 8
  003b4	50		 push	 eax
  003b5	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _grab_bb$[ebp+8]
  003bb	51		 push	 ecx
  003bc	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _grab_bb$[ebp]
  003c2	52		 push	 edx
  003c3	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  003c6	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  003cc	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN11@VSliderSca:

; 2723 : 
; 2724 :     // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
; 2725 :     // For the vertical slider we allow centered text to overlap the frame padding
; 2726 :     char value_buf[64];
; 2727 :     const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);

  003d1	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  003d4	50		 push	 eax
  003d5	8b 4d 14	 mov	 ecx, DWORD PTR _p_data$[ebp]
  003d8	51		 push	 ecx
  003d9	8b 55 10	 mov	 edx, DWORD PTR _data_type$[ebp]
  003dc	52		 push	 edx
  003dd	6a 40		 push	 64			; 00000040H
  003df	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _value_buf$[ebp]
  003e5	50		 push	 eax
  003e6	e8 00 00 00 00	 call	 ?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z ; ImGui::DataTypeFormatString
  003eb	83 c4 14	 add	 esp, 20			; 00000014H
  003ee	8d 8c 05 0c ff
	ff ff		 lea	 ecx, DWORD PTR _value_buf$[ebp+eax]
  003f5	89 8d 00 ff ff
	ff		 mov	 DWORD PTR _value_buf_end$[ebp], ecx

; 2728 :     RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));

  003fb	6a 00		 push	 0
  003fd	51		 push	 ecx
  003fe	0f 57 c0	 xorps	 xmm0, xmm0
  00401	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00406	51		 push	 ecx
  00407	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0040f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00414	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0041a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0041f	50		 push	 eax
  00420	6a 00		 push	 0
  00422	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _value_buf_end$[ebp]
  00428	50		 push	 eax
  00429	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _value_buf$[ebp]
  0042f	51		 push	 ecx
  00430	8d 55 b0	 lea	 edx, DWORD PTR _frame_bb$[ebp+8]
  00433	52		 push	 edx
  00434	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00437	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  0043c	f3 0f 58 40 3c	 addss	 xmm0, DWORD PTR [eax+60]
  00441	51		 push	 ecx
  00442	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00447	51		 push	 ecx
  00448	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _frame_bb$[ebp]
  0044d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00452	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00458	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0045d	50		 push	 eax
  0045e	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00463	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2729 :     if (label_size.x > 0.0f)

  00466	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  0046b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00472	76 48		 jbe	 SHORT $LN12@VSliderSca

; 2730 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

  00474	6a 01		 push	 1
  00476	6a 00		 push	 0
  00478	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0047b	50		 push	 eax
  0047c	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  0047f	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  00484	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  00489	51		 push	 ecx
  0048a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0048f	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  00492	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  00497	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  0049c	51		 push	 ecx
  0049d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a2	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  004a8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  004ad	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004b0	51		 push	 ecx
  004b1	8b 10		 mov	 edx, DWORD PTR [eax]
  004b3	52		 push	 edx
  004b4	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  004b9	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@VSliderSca:

; 2731 : 
; 2732 :     return value_changed;

  004bc	8a 85 57 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@VSliderSca:

; 2733 : }

  004c2	52		 push	 edx
  004c3	8b cd		 mov	 ecx, ebp
  004c5	50		 push	 eax
  004c6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@VSliderSca
  004cc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004d1	58		 pop	 eax
  004d2	5a		 pop	 edx
  004d3	5f		 pop	 edi
  004d4	5e		 pop	 esi
  004d5	5b		 pop	 ebx
  004d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d9	33 cd		 xor	 ecx, ebp
  004db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e0	81 c4 2c 02 00
	00		 add	 esp, 556		; 0000022cH
  004e6	3b ec		 cmp	 ebp, esp
  004e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004ed	8b e5		 mov	 esp, ebp
  004ef	5d		 pop	 ebp
  004f0	c3		 ret	 0
  004f1	0f 1f 00	 npad	 3
$LN28@VSliderSca:
  004f4	05 00 00 00	 DD	 5
  004f8	00 00 00 00	 DD	 $LN27@VSliderSca
$LN27@VSliderSca:
  004fc	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00500	08 00 00 00	 DD	 8
  00504	00 00 00 00	 DD	 $LN22@VSliderSca
  00508	a8 ff ff ff	 DD	 -88			; ffffffa8H
  0050c	10 00 00 00	 DD	 16			; 00000010H
  00510	00 00 00 00	 DD	 $LN23@VSliderSca
  00514	90 ff ff ff	 DD	 -112			; ffffff90H
  00518	10 00 00 00	 DD	 16			; 00000010H
  0051c	00 00 00 00	 DD	 $LN24@VSliderSca
  00520	60 ff ff ff	 DD	 -160			; ffffff60H
  00524	10 00 00 00	 DD	 16			; 00000010H
  00528	00 00 00 00	 DD	 $LN25@VSliderSca
  0052c	0c ff ff ff	 DD	 -244			; ffffff0cH
  00530	40 00 00 00	 DD	 64			; 00000040H
  00534	00 00 00 00	 DD	 $LN26@VSliderSca
$LN26@VSliderSca:
  00538	76		 DB	 118			; 00000076H
  00539	61		 DB	 97			; 00000061H
  0053a	6c		 DB	 108			; 0000006cH
  0053b	75		 DB	 117			; 00000075H
  0053c	65		 DB	 101			; 00000065H
  0053d	5f		 DB	 95			; 0000005fH
  0053e	62		 DB	 98			; 00000062H
  0053f	75		 DB	 117			; 00000075H
  00540	66		 DB	 102			; 00000066H
  00541	00		 DB	 0
$LN25@VSliderSca:
  00542	67		 DB	 103			; 00000067H
  00543	72		 DB	 114			; 00000072H
  00544	61		 DB	 97			; 00000061H
  00545	62		 DB	 98			; 00000062H
  00546	5f		 DB	 95			; 0000005fH
  00547	62		 DB	 98			; 00000062H
  00548	62		 DB	 98			; 00000062H
  00549	00		 DB	 0
$LN24@VSliderSca:
  0054a	62		 DB	 98			; 00000062H
  0054b	62		 DB	 98			; 00000062H
  0054c	00		 DB	 0
$LN23@VSliderSca:
  0054d	66		 DB	 102			; 00000066H
  0054e	72		 DB	 114			; 00000072H
  0054f	61		 DB	 97			; 00000061H
  00550	6d		 DB	 109			; 0000006dH
  00551	65		 DB	 101			; 00000065H
  00552	5f		 DB	 95			; 0000005fH
  00553	62		 DB	 98			; 00000062H
  00554	62		 DB	 98			; 00000062H
  00555	00		 DB	 0
$LN22@VSliderSca:
  00556	6c		 DB	 108			; 0000006cH
  00557	61		 DB	 97			; 00000061H
  00558	62		 DB	 98			; 00000062H
  00559	65		 DB	 101			; 00000065H
  0055a	6c		 DB	 108			; 0000006cH
  0055b	5f		 DB	 95			; 0000005fH
  0055c	73		 DB	 115			; 00000073H
  0055d	69		 DB	 105			; 00000069H
  0055e	7a		 DB	 122			; 0000007aH
  0055f	65		 DB	 101			; 00000065H
  00560	00		 DB	 0
?VSliderScalar@ImGui@@YA_NPBDABUImVec2@@HPAXPBX30M@Z ENDP ; ImGui::VSliderScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_size$ = 12						; size = 4
_v$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z PROC	; ImGui::VSliderInt, COMDAT

; 2741 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2742 :     return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  00045	50		 push	 eax
  00046	6a 04		 push	 4
  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 ?VSliderScalar@ImGui@@YA_NPBDABUImVec2@@HPAXPBX30M@Z ; ImGui::VSliderScalar
  00055	83 c4 20	 add	 esp, 32			; 00000020H

; 2743 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z ENDP	; ImGui::VSliderInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_size$ = 12						; size = 4
_v$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z PROC	; ImGui::VSliderFloat, COMDAT

; 2736 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2737 :     return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  00042	50		 push	 eax
  00043	6a 08		 push	 8
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00048	51		 push	 ecx
  00049	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 ?VSliderScalar@ImGui@@YA_NPBDABUImVec2@@HPAXPBX30M@Z ; ImGui::VSliderScalar
  00052	83 c4 20	 add	 esp, 32			; 00000020H

; 2738 : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ENDP	; ImGui::VSliderFloat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z
_TEXT	SEGMENT
_label_end$ = -68					; size = 4
_i$1 = -56						; size = 4
_type_size$ = -44					; size = 4
_value_changed$ = -29					; size = 1
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_label$ = 8						; size = 4
_data_type$ = 12					; size = 4
_v$ = 16						; size = 4
_components$ = 20					; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z PROC		; ImGui::SliderScalarN, COMDAT

; 2592 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2593 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 2594 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 07		 je	 SHORT $LN5@SliderScal

; 2595 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	e9 3b 01 00 00	 jmp	 $LN1@SliderScal
$LN5@SliderScal:

; 2596 : 
; 2597 :     ImGuiContext& g = *GImGui;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00047	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 2598 :     bool value_changed = false;

  0004a	c6 45 e3 00	 mov	 BYTE PTR _value_changed$[ebp], 0

; 2599 :     BeginGroup();

  0004e	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 2600 :     PushID(label);

  00053	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  0005c	83 c4 04	 add	 esp, 4

; 2601 :     PushMultiItemsWidths(components, CalcItemWidth());

  0005f	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00064	51		 push	 ecx
  00065	d9 1c 24	 fstp	 DWORD PTR [esp]
  00068	8b 45 14	 mov	 eax, DWORD PTR _components$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?PushMultiItemsWidths@ImGui@@YAXHM@Z ; ImGui::PushMultiItemsWidths
  00071	83 c4 08	 add	 esp, 8

; 2602 :     size_t type_size = GDataTypeInfo[data_type].Size;

  00074	6b 45 0c 0c	 imul	 eax, DWORD PTR _data_type$[ebp], 12
  00078	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B[eax]
  0007e	89 4d d4	 mov	 DWORD PTR _type_size$[ebp], ecx

; 2603 :     for (int i = 0; i < components; i++)

  00081	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00088	eb 09		 jmp	 SHORT $LN4@SliderScal
$LN2@SliderScal:
  0008a	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  0008d	83 c0 01	 add	 eax, 1
  00090	89 45 c8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SliderScal:
  00093	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  00096	3b 45 14	 cmp	 eax, DWORD PTR _components$[ebp]
  00099	0f 8d 84 00 00
	00		 jge	 $LN3@SliderScal

; 2604 :     {
; 2605 :         PushID(i);

  0009f	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID
  000a8	83 c4 04	 add	 esp, 4

; 2606 :         if (i > 0)

  000ab	83 7d c8 00	 cmp	 DWORD PTR _i$1[ebp], 0
  000af	7e 22		 jle	 SHORT $LN6@SliderScal

; 2607 :             SameLine(0, g.Style.ItemInnerSpacing.x);

  000b1	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  000b4	51		 push	 ecx
  000b5	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	51		 push	 ecx
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cb	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  000d0	83 c4 08	 add	 esp, 8
$LN6@SliderScal:

; 2608 :         value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, power);

  000d3	0f b6 5d e3	 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  000d7	51		 push	 ecx
  000d8	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  000dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e2	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d 1c	 mov	 ecx, DWORD PTR _v_max$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp]
  000ed	52		 push	 edx
  000ee	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  000f1	50		 push	 eax
  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _data_type$[ebp]
  000f5	51		 push	 ecx
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000fb	e8 00 00 00 00	 call	 ?SliderScalar@ImGui@@YA_NPBDHPAXPBX20M@Z ; ImGui::SliderScalar
  00100	83 c4 1c	 add	 esp, 28			; 0000001cH
  00103	0f b6 d0	 movzx	 edx, al
  00106	0b da		 or	 ebx, edx
  00108	88 5d e3	 mov	 BYTE PTR _value_changed$[ebp], bl

; 2609 :         PopID();

  0010b	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2610 :         PopItemWidth();

  00110	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 2611 :         v = (void*)((char*)v + type_size);

  00115	8b 45 10	 mov	 eax, DWORD PTR _v$[ebp]
  00118	03 45 d4	 add	 eax, DWORD PTR _type_size$[ebp]
  0011b	89 45 10	 mov	 DWORD PTR _v$[ebp], eax

; 2612 :     }

  0011e	e9 67 ff ff ff	 jmp	 $LN2@SliderScal
$LN3@SliderScal:

; 2613 :     PopID();

  00123	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2614 : 
; 2615 :     const char* label_end = FindRenderedTextEnd(label);

  00128	6a 00		 push	 0
  0012a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  00133	83 c4 08	 add	 esp, 8
  00136	89 45 bc	 mov	 DWORD PTR _label_end$[ebp], eax

; 2616 :     if (label != label_end)

  00139	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0013c	3b 45 bc	 cmp	 eax, DWORD PTR _label_end$[ebp]
  0013f	74 34		 je	 SHORT $LN7@SliderScal

; 2617 :     {
; 2618 :         SameLine(0, g.Style.ItemInnerSpacing.x);

  00141	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00144	51		 push	 ecx
  00145	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  0014d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00152	51		 push	 ecx
  00153	0f 57 c0	 xorps	 xmm0, xmm0
  00156	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015b	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00160	83 c4 08	 add	 esp, 8

; 2619 :         TextEx(label, label_end);

  00163	6a 00		 push	 0
  00165	8b 45 bc	 mov	 eax, DWORD PTR _label_end$[ebp]
  00168	50		 push	 eax
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@SliderScal:

; 2620 :     }
; 2621 : 
; 2622 :     EndGroup();

  00175	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 2623 :     return value_changed;

  0017a	8a 45 e3	 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@SliderScal:

; 2624 : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00186	3b ec		 cmp	 ebp, esp
  00188	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z ENDP		; ImGui::SliderScalarN
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderScalar@ImGui@@YA_NPBDHPAXPBX20M@Z
_TEXT	SEGMENT
tv230 = -616						; size = 4
tv300 = -612						; size = 4
tv231 = -612						; size = 4
tv140 = -612						; size = 4
tv185 = -609						; size = 1
$T1 = -604						; size = 8
$T2 = -588						; size = 8
$T3 = -572						; size = 8
$T4 = -556						; size = 8
$T5 = -540						; size = 8
$T6 = -524						; size = 8
_value_buf_end$ = -316					; size = 4
_value_buf$ = -304					; size = 64
_value_changed$ = -229					; size = 1
_grab_bb$ = -220					; size = 16
_frame_col$ = -196					; size = 4
_clicked$7 = -181					; size = 1
_focus_requested$8 = -169				; size = 1
_temp_input_start$ = -157				; size = 1
_temp_input_is_active$ = -145				; size = 1
_hovered$ = -133					; size = 1
_total_bb$ = -124					; size = 16
_frame_bb$ = -100					; size = 16
_label_size$ = -76					; size = 8
_w$ = -60						; size = 4
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_data_type$ = 12					; size = 4
_p_data$ = 16						; size = 4
_p_min$ = 20						; size = 4
_p_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
?SliderScalar@ImGui@@YA_NPBDHPAXPBX20M@Z PROC		; ImGui::SliderScalar, COMDAT

; 2515 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 02 00
	00		 sub	 esp, 616		; 00000268H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 98 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-616]
  00012	b9 9a 00 00 00	 mov	 ecx, 154		; 0000009aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2516 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 2517 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN5@SliderScal

; 2518 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 8b 05 00 00	 jmp	 $LN1@SliderScal
$LN5@SliderScal:

; 2519 : 
; 2520 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 2521 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 2522 :     const ImGuiID id = window->GetID(label);

  0005f	6a 00		 push	 0
  00061	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00068	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0006d	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 2523 :     const float w = CalcItemWidth();

  00070	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00075	d9 5d c4	 fstp	 DWORD PTR _w$[ebp]

; 2524 : 
; 2525 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  00078	51		 push	 ecx
  00079	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00081	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00086	6a 01		 push	 1
  00088	6a 00		 push	 0
  0008a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0008d	50		 push	 eax
  0008e	8d 4d b4	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00097	83 c4 14	 add	 esp, 20			; 00000014H

; 2526 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

  0009a	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0009d	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  000a2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000aa	f3 0f 58 45 b8	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000af	51		 push	 ecx
  000b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b5	51		 push	 ecx
  000b6	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _w$[ebp]
  000bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c0	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000c6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000cb	50		 push	 eax
  000cc	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000cf	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  000d5	51		 push	 ecx
  000d6	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	50		 push	 eax
  000e6	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000e9	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000ee	50		 push	 eax
  000ef	8d 4d 9c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  000f2	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 2527 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

  000f7	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  000fc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00103	76 17		 jbe	 SHORT $LN22@SliderScal
  00105	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00108	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  0010d	f3 0f 58 45 b4	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  00112	f3 0f 11 85 9c
	fd ff ff	 movss	 DWORD PTR tv140[ebp], xmm0
  0011a	eb 0b		 jmp	 SHORT $LN23@SliderScal
$LN22@SliderScal:
  0011c	0f 57 c0	 xorps	 xmm0, xmm0
  0011f	f3 0f 11 85 9c
	fd ff ff	 movss	 DWORD PTR tv140[ebp], xmm0
$LN23@SliderScal:
  00127	51		 push	 ecx
  00128	0f 57 c0	 xorps	 xmm0, xmm0
  0012b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00130	51		 push	 ecx
  00131	f3 0f 10 85 9c
	fd ff ff	 movss	 xmm0, DWORD PTR tv140[ebp]
  00139	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013e	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00144	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00149	50		 push	 eax
  0014a	8d 4d a4	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  0014d	51		 push	 ecx
  0014e	8d 95 c4 fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00154	52		 push	 edx
  00155	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015d	50		 push	 eax
  0015e	8d 45 9c	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00161	50		 push	 eax
  00162	8d 4d 84	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00165	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 2528 : 
; 2529 :     ItemSize(total_bb, style.FramePadding.y);

  0016a	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0016d	51		 push	 ecx
  0016e	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00173	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00178	8d 4d 84	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  00181	83 c4 08	 add	 esp, 8

; 2530 :     if (!ItemAdd(total_bb, id, &frame_bb))

  00184	8d 45 9c	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00187	50		 push	 eax
  00188	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  0018b	51		 push	 ecx
  0018c	8d 55 84	 lea	 edx, DWORD PTR _total_bb$[ebp]
  0018f	52		 push	 edx
  00190	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00195	83 c4 0c	 add	 esp, 12			; 0000000cH
  00198	0f b6 c0	 movzx	 eax, al
  0019b	85 c0		 test	 eax, eax
  0019d	75 07		 jne	 SHORT $LN6@SliderScal

; 2531 :         return false;

  0019f	32 c0		 xor	 al, al
  001a1	e9 31 04 00 00	 jmp	 $LN1@SliderScal
$LN6@SliderScal:

; 2532 : 
; 2533 :     // Default format string when passing NULL
; 2534 :     if (format == NULL)

  001a6	83 7d 1c 00	 cmp	 DWORD PTR _format$[ebp], 0
  001aa	75 14		 jne	 SHORT $LN7@SliderScal

; 2535 :         format = DataTypeGetInfo(data_type)->PrintFmt;

  001ac	8b 45 0c	 mov	 eax, DWORD PTR _data_type$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z ; ImGui::DataTypeGetInfo
  001b5	83 c4 04	 add	 esp, 4
  001b8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001bb	89 4d 1c	 mov	 DWORD PTR _format$[ebp], ecx
  001be	eb 2a		 jmp	 SHORT $LN9@SliderScal
$LN7@SliderScal:

; 2536 :     else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)

  001c0	83 7d 0c 04	 cmp	 DWORD PTR _data_type$[ebp], 4
  001c4	75 24		 jne	 SHORT $LN9@SliderScal
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001cb	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _strcmp
  001d4	83 c4 08	 add	 esp, 8
  001d7	85 c0		 test	 eax, eax
  001d9	74 0f		 je	 SHORT $LN9@SliderScal

; 2537 :         format = PatchFormatStringFloatToInt(format);

  001db	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 ?PatchFormatStringFloatToInt@@YAPBDPBD@Z ; PatchFormatStringFloatToInt
  001e4	83 c4 04	 add	 esp, 4
  001e7	89 45 1c	 mov	 DWORD PTR _format$[ebp], eax
$LN9@SliderScal:

; 2538 : 
; 2539 :     // Tabbing or CTRL-clicking on Slider turns it into an input box
; 2540 :     const bool hovered = ItemHoverable(frame_bb, id);

  001ea	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  001ed	50		 push	 eax
  001ee	8d 4d 9c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z ; ImGui::ItemHoverable
  001f7	83 c4 08	 add	 esp, 8
  001fa	88 85 7b ff ff
	ff		 mov	 BYTE PTR _hovered$[ebp], al

; 2541 :     bool temp_input_is_active = TempInputTextIsActive(id);

  00200	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ?TempInputTextIsActive@ImGui@@YA_NI@Z ; ImGui::TempInputTextIsActive
  00209	83 c4 04	 add	 esp, 4
  0020c	88 85 6f ff ff
	ff		 mov	 BYTE PTR _temp_input_is_active$[ebp], al

; 2542 :     bool temp_input_start = false;

  00212	c6 85 63 ff ff
	ff 00		 mov	 BYTE PTR _temp_input_start$[ebp], 0

; 2543 :     if (!temp_input_is_active)

  00219	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _temp_input_is_active$[ebp]
  00220	85 c0		 test	 eax, eax
  00222	0f 85 10 01 00
	00		 jne	 $LN13@SliderScal

; 2544 :     {
; 2545 :         const bool focus_requested = FocusableItemRegister(window, id);

  00228	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0022b	50		 push	 eax
  0022c	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I@Z ; ImGui::FocusableItemRegister
  00235	83 c4 08	 add	 esp, 8
  00238	88 85 57 ff ff
	ff		 mov	 BYTE PTR _focus_requested$8[ebp], al

; 2546 :         const bool clicked = (hovered && g.IO.MouseClicked[0]);

  0023e	0f b6 85 7b ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  00245	85 c0		 test	 eax, eax
  00247	74 20		 je	 SHORT $LN24@SliderScal
  00249	b9 01 00 00 00	 mov	 ecx, 1
  0024e	6b d1 00	 imul	 edx, ecx, 0
  00251	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00254	0f b6 8c 10 d8
	03 00 00	 movzx	 ecx, BYTE PTR [eax+edx+984]
  0025c	85 c9		 test	 ecx, ecx
  0025e	74 09		 je	 SHORT $LN24@SliderScal
  00260	c6 85 9f fd ff
	ff 01		 mov	 BYTE PTR tv185[ebp], 1
  00267	eb 07		 jmp	 SHORT $LN25@SliderScal
$LN24@SliderScal:
  00269	c6 85 9f fd ff
	ff 00		 mov	 BYTE PTR tv185[ebp], 0
$LN25@SliderScal:
  00270	8a 95 9f fd ff
	ff		 mov	 dl, BYTE PTR tv185[ebp]
  00276	88 95 4b ff ff
	ff		 mov	 BYTE PTR _clicked$7[ebp], dl

; 2547 :         if (focus_requested || clicked || g.NavActivateId == id || g.NavInputId == id)

  0027c	0f b6 85 57 ff
	ff ff		 movzx	 eax, BYTE PTR _focus_requested$8[ebp]
  00283	85 c0		 test	 eax, eax
  00285	75 2b		 jne	 SHORT $LN12@SliderScal
  00287	0f b6 85 4b ff
	ff ff		 movzx	 eax, BYTE PTR _clicked$7[ebp]
  0028e	85 c0		 test	 eax, eax
  00290	75 20		 jne	 SHORT $LN12@SliderScal
  00292	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00295	8b 88 d8 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6872]
  0029b	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0029e	74 12		 je	 SHORT $LN12@SliderScal
  002a0	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  002a3	8b 88 e4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6884]
  002a9	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  002ac	0f 85 86 00 00
	00		 jne	 $LN13@SliderScal
$LN12@SliderScal:

; 2548 :         {
; 2549 :             SetActiveID(id, window);

  002b2	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002b5	50		 push	 eax
  002b6	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  002b9	51		 push	 ecx
  002ba	e8 00 00 00 00	 call	 ?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
  002bf	83 c4 08	 add	 esp, 8

; 2550 :             SetFocusID(id, window);

  002c2	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002c5	50		 push	 eax
  002c6	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?SetFocusID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetFocusID
  002cf	83 c4 08	 add	 esp, 8

; 2551 :             FocusWindow(window);

  002d2	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002d5	50		 push	 eax
  002d6	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  002db	83 c4 04	 add	 esp, 4

; 2552 :             g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);

  002de	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  002e1	8b 88 f8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6648]
  002e7	83 c9 03	 or	 ecx, 3
  002ea	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  002ed	89 8a f8 19 00
	00		 mov	 DWORD PTR [edx+6648], ecx

; 2553 :             if (focus_requested || (clicked && g.IO.KeyCtrl) || g.NavInputId == id)

  002f3	0f b6 85 57 ff
	ff ff		 movzx	 eax, BYTE PTR _focus_requested$8[ebp]
  002fa	85 c0		 test	 eax, eax
  002fc	75 27		 jne	 SHORT $LN14@SliderScal
  002fe	0f b6 85 4b ff
	ff ff		 movzx	 eax, BYTE PTR _clicked$7[ebp]
  00305	85 c0		 test	 eax, eax
  00307	74 0e		 je	 SHORT $LN15@SliderScal
  00309	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0030c	0f b6 88 00 01
	00 00		 movzx	 ecx, BYTE PTR [eax+256]
  00313	85 c9		 test	 ecx, ecx
  00315	75 0e		 jne	 SHORT $LN14@SliderScal
$LN15@SliderScal:
  00317	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0031a	8b 88 e4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6884]
  00320	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  00323	75 13		 jne	 SHORT $LN13@SliderScal
$LN14@SliderScal:

; 2554 :             {
; 2555 :                 temp_input_start = true;

  00325	c6 85 63 ff ff
	ff 01		 mov	 BYTE PTR _temp_input_start$[ebp], 1

; 2556 :                 FocusableItemUnregister(window);

  0032c	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0032f	50		 push	 eax
  00330	e8 00 00 00 00	 call	 ?FocusableItemUnregister@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusableItemUnregister
  00335	83 c4 04	 add	 esp, 4
$LN13@SliderScal:

; 2557 :             }
; 2558 :         }
; 2559 :     }
; 2560 :     if (temp_input_is_active || temp_input_start)

  00338	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _temp_input_is_active$[ebp]
  0033f	85 c0		 test	 eax, eax
  00341	75 0b		 jne	 SHORT $LN17@SliderScal
  00343	0f b6 85 63 ff
	ff ff		 movzx	 eax, BYTE PTR _temp_input_start$[ebp]
  0034a	85 c0		 test	 eax, eax
  0034c	74 25		 je	 SHORT $LN16@SliderScal
$LN17@SliderScal:

; 2561 :         return TempInputTextScalar(frame_bb, id, label, data_type, p_data, format);

  0034e	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00351	50		 push	 eax
  00352	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  00355	51		 push	 ecx
  00356	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  00359	52		 push	 edx
  0035a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0035d	50		 push	 eax
  0035e	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00361	51		 push	 ecx
  00362	8d 55 9c	 lea	 edx, DWORD PTR _frame_bb$[ebp]
  00365	52		 push	 edx
  00366	e8 00 00 00 00	 call	 ?TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z ; ImGui::TempInputTextScalar
  0036b	83 c4 18	 add	 esp, 24			; 00000018H
  0036e	e9 64 02 00 00	 jmp	 $LN1@SliderScal
$LN16@SliderScal:

; 2562 : 
; 2563 :     // Draw frame
; 2564 :     const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

  00373	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00376	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0037c	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0037f	75 0c		 jne	 SHORT $LN28@SliderScal
  00381	c7 85 9c fd ff
	ff 09 00 00 00	 mov	 DWORD PTR tv231[ebp], 9
  0038b	eb 30		 jmp	 SHORT $LN29@SliderScal
$LN28@SliderScal:
  0038d	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00390	8b 82 d0 19 00
	00		 mov	 eax, DWORD PTR [edx+6608]
  00396	3b 45 d0	 cmp	 eax, DWORD PTR _id$[ebp]
  00399	75 0c		 jne	 SHORT $LN26@SliderScal
  0039b	c7 85 98 fd ff
	ff 08 00 00 00	 mov	 DWORD PTR tv230[ebp], 8
  003a5	eb 0a		 jmp	 SHORT $LN27@SliderScal
$LN26@SliderScal:
  003a7	c7 85 98 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR tv230[ebp], 7
$LN27@SliderScal:
  003b1	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR tv230[ebp]
  003b7	89 8d 9c fd ff
	ff		 mov	 DWORD PTR tv231[ebp], ecx
$LN29@SliderScal:
  003bd	51		 push	 ecx
  003be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cb	8b 95 9c fd ff
	ff		 mov	 edx, DWORD PTR tv231[ebp]
  003d1	52		 push	 edx
  003d2	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  003d7	83 c4 08	 add	 esp, 8
  003da	89 85 3c ff ff
	ff		 mov	 DWORD PTR _frame_col$[ebp], eax

; 2565 :     RenderNavHighlight(frame_bb, id);

  003e0	6a 01		 push	 1
  003e2	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  003e5	50		 push	 eax
  003e6	8d 4d 9c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  003e9	51		 push	 ecx
  003ea	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  003ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2566 :     RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

  003f2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  003f5	51		 push	 ecx
  003f6	f3 0f 10 80 50
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5456]
  003fe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00403	6a 01		 push	 1
  00405	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _frame_col$[ebp]
  0040b	51		 push	 ecx
  0040c	8b 55 a8	 mov	 edx, DWORD PTR _frame_bb$[ebp+12]
  0040f	52		 push	 edx
  00410	8b 45 a4	 mov	 eax, DWORD PTR _frame_bb$[ebp+8]
  00413	50		 push	 eax
  00414	8b 4d a0	 mov	 ecx, DWORD PTR _frame_bb$[ebp+4]
  00417	51		 push	 ecx
  00418	8b 55 9c	 mov	 edx, DWORD PTR _frame_bb$[ebp]
  0041b	52		 push	 edx
  0041c	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  00421	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2567 : 
; 2568 :     // Slider behavior
; 2569 :     ImRect grab_bb;

  00424	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _grab_bb$[ebp]
  0042a	e8 00 00 00 00	 call	 ??0ImRect@@QAE@XZ	; ImRect::ImRect

; 2570 :     const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, power, ImGuiSliderFlags_None, &grab_bb);

  0042f	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _grab_bb$[ebp]
  00435	50		 push	 eax
  00436	6a 00		 push	 0
  00438	51		 push	 ecx
  00439	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  0043e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00443	8b 4d 1c	 mov	 ecx, DWORD PTR _format$[ebp]
  00446	51		 push	 ecx
  00447	8b 55 18	 mov	 edx, DWORD PTR _p_max$[ebp]
  0044a	52		 push	 edx
  0044b	8b 45 14	 mov	 eax, DWORD PTR _p_min$[ebp]
  0044e	50		 push	 eax
  0044f	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  00452	51		 push	 ecx
  00453	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  00456	52		 push	 edx
  00457	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0045a	50		 push	 eax
  0045b	8d 4d 9c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  0045e	51		 push	 ecx
  0045f	e8 00 00 00 00	 call	 ?SliderBehavior@ImGui@@YA_NABUImRect@@IHPAXPBX2PBDMHPAU2@@Z ; ImGui::SliderBehavior
  00464	83 c4 28	 add	 esp, 40			; 00000028H
  00467	88 85 1b ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al

; 2571 :     if (value_changed)

  0046d	0f b6 85 1b ff
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  00474	85 c0		 test	 eax, eax
  00476	74 0c		 je	 SHORT $LN18@SliderScal

; 2572 :         MarkItemEdited(id);

  00478	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0047b	50		 push	 eax
  0047c	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  00481	83 c4 04	 add	 esp, 4
$LN18@SliderScal:

; 2573 : 
; 2574 :     // Render grab
; 2575 :     if (grab_bb.Max.x > grab_bb.Min.x)

  00484	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _grab_bb$[ebp+8]
  0048c	0f 2f 85 24 ff
	ff ff		 comiss	 xmm0, DWORD PTR _grab_bb$[ebp]
  00493	76 6e		 jbe	 SHORT $LN19@SliderScal

; 2576 :         window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

  00495	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00498	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0049e	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  004a1	75 0c		 jne	 SHORT $LN30@SliderScal
  004a3	c7 85 9c fd ff
	ff 14 00 00 00	 mov	 DWORD PTR tv300[ebp], 20 ; 00000014H
  004ad	eb 0a		 jmp	 SHORT $LN31@SliderScal
$LN30@SliderScal:
  004af	c7 85 9c fd ff
	ff 13 00 00 00	 mov	 DWORD PTR tv300[ebp], 19 ; 00000013H
$LN31@SliderScal:
  004b9	6a 0f		 push	 15			; 0000000fH
  004bb	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  004be	51		 push	 ecx
  004bf	f3 0f 10 42 74	 movss	 xmm0, DWORD PTR [edx+116]
  004c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c9	51		 push	 ecx
  004ca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d7	8b 85 9c fd ff
	ff		 mov	 eax, DWORD PTR tv300[ebp]
  004dd	50		 push	 eax
  004de	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  004e3	83 c4 08	 add	 esp, 8
  004e6	50		 push	 eax
  004e7	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _grab_bb$[ebp+8]
  004ed	51		 push	 ecx
  004ee	8d 95 24 ff ff
	ff		 lea	 edx, DWORD PTR _grab_bb$[ebp]
  004f4	52		 push	 edx
  004f5	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  004f8	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  004fe	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN19@SliderScal:

; 2577 : 
; 2578 :     // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
; 2579 :     char value_buf[64];
; 2580 :     const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);

  00503	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00506	50		 push	 eax
  00507	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  0050a	51		 push	 ecx
  0050b	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  0050e	52		 push	 edx
  0050f	6a 40		 push	 64			; 00000040H
  00511	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _value_buf$[ebp]
  00517	50		 push	 eax
  00518	e8 00 00 00 00	 call	 ?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z ; ImGui::DataTypeFormatString
  0051d	83 c4 14	 add	 esp, 20			; 00000014H
  00520	8d 8c 05 d0 fe
	ff ff		 lea	 ecx, DWORD PTR _value_buf$[ebp+eax]
  00527	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _value_buf_end$[ebp], ecx

; 2581 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

  0052d	6a 00		 push	 0
  0052f	51		 push	 ecx
  00530	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00538	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0053d	51		 push	 ecx
  0053e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00546	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0054b	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00551	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00556	50		 push	 eax
  00557	6a 00		 push	 0
  00559	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _value_buf_end$[ebp]
  0055f	50		 push	 eax
  00560	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _value_buf$[ebp]
  00566	51		 push	 ecx
  00567	8d 55 a4	 lea	 edx, DWORD PTR _frame_bb$[ebp+8]
  0056a	52		 push	 edx
  0056b	8d 45 9c	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  0056e	50		 push	 eax
  0056f	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00574	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2582 : 
; 2583 :     if (label_size.x > 0.0f)

  00577	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  0057c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00583	76 48		 jbe	 SHORT $LN20@SliderScal

; 2584 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

  00585	6a 01		 push	 1
  00587	6a 00		 push	 0
  00589	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0058c	50		 push	 eax
  0058d	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00590	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  00595	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  0059a	51		 push	 ecx
  0059b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a0	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  005a3	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  005a8	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  005ad	51		 push	 ecx
  005ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b3	8d 8d a4 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  005b9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  005be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005c1	51		 push	 ecx
  005c2	8b 10		 mov	 edx, DWORD PTR [eax]
  005c4	52		 push	 edx
  005c5	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  005ca	83 c4 14	 add	 esp, 20			; 00000014H
$LN20@SliderScal:

; 2585 : 
; 2586 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);

  005cd	33 c0		 xor	 eax, eax
  005cf	75 fc		 jne	 SHORT $LN20@SliderScal

; 2587 :     return value_changed;

  005d1	8a 85 1b ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@SliderScal:

; 2588 : }

  005d7	52		 push	 edx
  005d8	8b cd		 mov	 ecx, ebp
  005da	50		 push	 eax
  005db	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN38@SliderScal
  005e1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005e6	58		 pop	 eax
  005e7	5a		 pop	 edx
  005e8	5f		 pop	 edi
  005e9	5e		 pop	 esi
  005ea	5b		 pop	 ebx
  005eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ee	33 cd		 xor	 ecx, ebp
  005f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f5	81 c4 68 02 00
	00		 add	 esp, 616		; 00000268H
  005fb	3b ec		 cmp	 ebp, esp
  005fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00602	8b e5		 mov	 esp, ebp
  00604	5d		 pop	 ebp
  00605	c3		 ret	 0
  00606	66 90		 npad	 2
$LN38@SliderScal:
  00608	05 00 00 00	 DD	 5
  0060c	00 00 00 00	 DD	 $LN37@SliderScal
$LN37@SliderScal:
  00610	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00614	08 00 00 00	 DD	 8
  00618	00 00 00 00	 DD	 $LN32@SliderScal
  0061c	9c ff ff ff	 DD	 -100			; ffffff9cH
  00620	10 00 00 00	 DD	 16			; 00000010H
  00624	00 00 00 00	 DD	 $LN33@SliderScal
  00628	84 ff ff ff	 DD	 -124			; ffffff84H
  0062c	10 00 00 00	 DD	 16			; 00000010H
  00630	00 00 00 00	 DD	 $LN34@SliderScal
  00634	24 ff ff ff	 DD	 -220			; ffffff24H
  00638	10 00 00 00	 DD	 16			; 00000010H
  0063c	00 00 00 00	 DD	 $LN35@SliderScal
  00640	d0 fe ff ff	 DD	 -304			; fffffed0H
  00644	40 00 00 00	 DD	 64			; 00000040H
  00648	00 00 00 00	 DD	 $LN36@SliderScal
$LN36@SliderScal:
  0064c	76		 DB	 118			; 00000076H
  0064d	61		 DB	 97			; 00000061H
  0064e	6c		 DB	 108			; 0000006cH
  0064f	75		 DB	 117			; 00000075H
  00650	65		 DB	 101			; 00000065H
  00651	5f		 DB	 95			; 0000005fH
  00652	62		 DB	 98			; 00000062H
  00653	75		 DB	 117			; 00000075H
  00654	66		 DB	 102			; 00000066H
  00655	00		 DB	 0
$LN35@SliderScal:
  00656	67		 DB	 103			; 00000067H
  00657	72		 DB	 114			; 00000072H
  00658	61		 DB	 97			; 00000061H
  00659	62		 DB	 98			; 00000062H
  0065a	5f		 DB	 95			; 0000005fH
  0065b	62		 DB	 98			; 00000062H
  0065c	62		 DB	 98			; 00000062H
  0065d	00		 DB	 0
$LN34@SliderScal:
  0065e	74		 DB	 116			; 00000074H
  0065f	6f		 DB	 111			; 0000006fH
  00660	74		 DB	 116			; 00000074H
  00661	61		 DB	 97			; 00000061H
  00662	6c		 DB	 108			; 0000006cH
  00663	5f		 DB	 95			; 0000005fH
  00664	62		 DB	 98			; 00000062H
  00665	62		 DB	 98			; 00000062H
  00666	00		 DB	 0
$LN33@SliderScal:
  00667	66		 DB	 102			; 00000066H
  00668	72		 DB	 114			; 00000072H
  00669	61		 DB	 97			; 00000061H
  0066a	6d		 DB	 109			; 0000006dH
  0066b	65		 DB	 101			; 00000065H
  0066c	5f		 DB	 95			; 0000005fH
  0066d	62		 DB	 98			; 00000062H
  0066e	62		 DB	 98			; 00000062H
  0066f	00		 DB	 0
$LN32@SliderScal:
  00670	6c		 DB	 108			; 0000006cH
  00671	61		 DB	 97			; 00000061H
  00672	62		 DB	 98			; 00000062H
  00673	65		 DB	 101			; 00000065H
  00674	6c		 DB	 108			; 0000006cH
  00675	5f		 DB	 95			; 0000005fH
  00676	73		 DB	 115			; 00000073H
  00677	69		 DB	 105			; 00000069H
  00678	7a		 DB	 122			; 0000007aH
  00679	65		 DB	 101			; 00000065H
  0067a	00		 DB	 0
?SliderScalar@ImGui@@YA_NPBDHPAXPBX20M@Z ENDP		; ImGui::SliderScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z PROC			; ImGui::SliderInt4, COMDAT

; 2672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2673 :     return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	6a 04		 push	 4
  00044	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00047	50		 push	 eax
  00048	6a 04		 push	 4
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z ; ImGui::SliderScalarN
  00053	83 c4 20	 add	 esp, 32			; 00000020H

; 2674 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z ENDP			; ImGui::SliderInt4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z PROC			; ImGui::SliderInt3, COMDAT

; 2667 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2668 :     return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	6a 03		 push	 3
  00044	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00047	50		 push	 eax
  00048	6a 04		 push	 4
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z ; ImGui::SliderScalarN
  00053	83 c4 20	 add	 esp, 32			; 00000020H

; 2669 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z ENDP			; ImGui::SliderInt3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z PROC			; ImGui::SliderInt2, COMDAT

; 2662 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2663 :     return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	6a 02		 push	 2
  00044	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00047	50		 push	 eax
  00048	6a 04		 push	 4
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z ; ImGui::SliderScalarN
  00053	83 c4 20	 add	 esp, 32			; 00000020H

; 2664 : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z ENDP			; ImGui::SliderInt2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderInt@ImGui@@YA_NPBDPAHHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
?SliderInt@ImGui@@YA_NPBDPAHHH0@Z PROC			; ImGui::SliderInt, COMDAT

; 2657 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2658 :     return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00045	50		 push	 eax
  00046	6a 04		 push	 4
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?SliderScalar@ImGui@@YA_NPBDHPAXPBX20M@Z ; ImGui::SliderScalar
  00051	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2659 : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005d	3b ec		 cmp	 ebp, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?SliderInt@ImGui@@YA_NPBDPAHHH0@Z ENDP			; ImGui::SliderInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderAngle@ImGui@@YA_NPBDPAMMM0@Z
_TEXT	SEGMENT
_value_changed$ = -21					; size = 1
_v_deg$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_v_rad$ = 12						; size = 4
_v_degrees_min$ = 16					; size = 4
_v_degrees_max$ = 20					; size = 4
_format$ = 24						; size = 4
?SliderAngle@ImGui@@YA_NPBDPAMMM0@Z PROC		; ImGui::SliderAngle, COMDAT

; 2647 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2648 :     if (format == NULL)

  00032	83 7d 18 00	 cmp	 DWORD PTR _format$[ebp], 0
  00036	75 07		 jne	 SHORT $LN2@SliderAngl

; 2649 :         format = "%.0f deg";

  00038	c7 45 18 00 00
	00 00		 mov	 DWORD PTR _format$[ebp], OFFSET ??_C@_08FKIHKODH@?$CF?40f?5deg@
$LN2@SliderAngl:

; 2650 :     float v_deg = (*v_rad) * 360.0f / (2*IM_PI);

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _v_rad$[ebp]
  00042	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00046	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@43b40000
  0004e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40c90fdb
  00056	f3 0f 11 45 f4	 movss	 DWORD PTR _v_deg$[ebp], xmm0

; 2651 :     bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f);

  0005b	51		 push	 ecx
  0005c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00064	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00069	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  0006c	50		 push	 eax
  0006d	51		 push	 ecx
  0006e	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_degrees_max$[ebp]
  00073	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00078	51		 push	 ecx
  00079	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_degrees_min$[ebp]
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	8d 4d f4	 lea	 ecx, DWORD PTR _v_deg$[ebp]
  00086	51		 push	 ecx
  00087	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  0008a	52		 push	 edx
  0008b	e8 00 00 00 00	 call	 ?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z ; ImGui::SliderFloat
  00090	83 c4 18	 add	 esp, 24			; 00000018H
  00093	88 45 eb	 mov	 BYTE PTR _value_changed$[ebp], al

; 2652 :     *v_rad = v_deg * (2*IM_PI) / 360.0f;

  00096	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v_deg$[ebp]
  0009b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40c90fdb
  000a3	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@43b40000
  000ab	8b 45 0c	 mov	 eax, DWORD PTR _v_rad$[ebp]
  000ae	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 2653 :     return value_changed;

  000b2	8a 45 eb	 mov	 al, BYTE PTR _value_changed$[ebp]

; 2654 : }

  000b5	52		 push	 edx
  000b6	8b cd		 mov	 ecx, ebp
  000b8	50		 push	 eax
  000b9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@SliderAngl
  000bf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c4	58		 pop	 eax
  000c5	5a		 pop	 edx
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cc	33 cd		 xor	 ecx, ebp
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000d9	3b ec		 cmp	 ebp, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN6@SliderAngl:
  000e4	01 00 00 00	 DD	 1
  000e8	00 00 00 00	 DD	 $LN5@SliderAngl
$LN5@SliderAngl:
  000ec	f4 ff ff ff	 DD	 -12			; fffffff4H
  000f0	04 00 00 00	 DD	 4
  000f4	00 00 00 00	 DD	 $LN4@SliderAngl
$LN4@SliderAngl:
  000f8	76		 DB	 118			; 00000076H
  000f9	5f		 DB	 95			; 0000005fH
  000fa	64		 DB	 100			; 00000064H
  000fb	65		 DB	 101			; 00000065H
  000fc	67		 DB	 103			; 00000067H
  000fd	00		 DB	 0
?SliderAngle@ImGui@@YA_NPBDPAMMM0@Z ENDP		; ImGui::SliderAngle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
_power$ = 28						; size = 4
?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z PROC		; ImGui::SliderFloat4, COMDAT

; 2642 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2643 :     return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	6a 04		 push	 4
  00041	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00044	50		 push	 eax
  00045	6a 08		 push	 8
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z ; ImGui::SliderScalarN
  00050	83 c4 20	 add	 esp, 32			; 00000020H

; 2644 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z ENDP		; ImGui::SliderFloat4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
_power$ = 28						; size = 4
?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z PROC		; ImGui::SliderFloat3, COMDAT

; 2637 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2638 :     return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	6a 03		 push	 3
  00041	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00044	50		 push	 eax
  00045	6a 08		 push	 8
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z ; ImGui::SliderScalarN
  00050	83 c4 20	 add	 esp, 32			; 00000020H

; 2639 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z ENDP		; ImGui::SliderFloat3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
_power$ = 28						; size = 4
?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z PROC		; ImGui::SliderFloat2, COMDAT

; 2632 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2633 :     return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	6a 02		 push	 2
  00041	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00044	50		 push	 eax
  00045	6a 08		 push	 8
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?SliderScalarN@ImGui@@YA_NPBDHPAXHPBX20M@Z ; ImGui::SliderScalarN
  00050	83 c4 20	 add	 esp, 32			; 00000020H

; 2634 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z ENDP		; ImGui::SliderFloat2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_format$ = 24						; size = 4
_power$ = 28						; size = 4
?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z PROC		; ImGui::SliderFloat, COMDAT

; 2627 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2628 :     return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 18	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 14	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 10	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00042	50		 push	 eax
  00043	6a 08		 push	 8
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?SliderScalar@ImGui@@YA_NPBDHPAXPBX20M@Z ; ImGui::SliderScalar
  0004e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2629 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z ENDP		; ImGui::SliderFloat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z
_TEXT	SEGMENT
_label_end$ = -68					; size = 4
_i$1 = -56						; size = 4
_type_size$ = -44					; size = 4
_value_changed$ = -29					; size = 1
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_label$ = 8						; size = 4
_data_type$ = 12					; size = 4
_p_data$ = 16						; size = 4
_components$ = 20					; size = 4
_v_speed$ = 24						; size = 4
_p_min$ = 28						; size = 4
_p_max$ = 32						; size = 4
_format$ = 36						; size = 4
_power$ = 40						; size = 4
?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z PROC		; ImGui::DragScalarN, COMDAT

; 2135 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2136 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 2137 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 07		 je	 SHORT $LN5@DragScalar

; 2138 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	e9 46 01 00 00	 jmp	 $LN1@DragScalar
$LN5@DragScalar:

; 2139 : 
; 2140 :     ImGuiContext& g = *GImGui;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00047	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 2141 :     bool value_changed = false;

  0004a	c6 45 e3 00	 mov	 BYTE PTR _value_changed$[ebp], 0

; 2142 :     BeginGroup();

  0004e	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 2143 :     PushID(label);

  00053	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  0005c	83 c4 04	 add	 esp, 4

; 2144 :     PushMultiItemsWidths(components, CalcItemWidth());

  0005f	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00064	51		 push	 ecx
  00065	d9 1c 24	 fstp	 DWORD PTR [esp]
  00068	8b 45 14	 mov	 eax, DWORD PTR _components$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?PushMultiItemsWidths@ImGui@@YAXHM@Z ; ImGui::PushMultiItemsWidths
  00071	83 c4 08	 add	 esp, 8

; 2145 :     size_t type_size = GDataTypeInfo[data_type].Size;

  00074	6b 45 0c 0c	 imul	 eax, DWORD PTR _data_type$[ebp], 12
  00078	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B[eax]
  0007e	89 4d d4	 mov	 DWORD PTR _type_size$[ebp], ecx

; 2146 :     for (int i = 0; i < components; i++)

  00081	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00088	eb 09		 jmp	 SHORT $LN4@DragScalar
$LN2@DragScalar:
  0008a	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  0008d	83 c0 01	 add	 eax, 1
  00090	89 45 c8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@DragScalar:
  00093	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  00096	3b 45 14	 cmp	 eax, DWORD PTR _components$[ebp]
  00099	0f 8d 8f 00 00
	00		 jge	 $LN3@DragScalar

; 2147 :     {
; 2148 :         PushID(i);

  0009f	8b 45 c8	 mov	 eax, DWORD PTR _i$1[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXH@Z	; ImGui::PushID
  000a8	83 c4 04	 add	 esp, 4

; 2149 :         if (i > 0)

  000ab	83 7d c8 00	 cmp	 DWORD PTR _i$1[ebp], 0
  000af	7e 22		 jle	 SHORT $LN6@DragScalar

; 2150 :             SameLine(0, g.Style.ItemInnerSpacing.x);

  000b1	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  000b4	51		 push	 ecx
  000b5	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  000bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c2	51		 push	 ecx
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cb	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  000d0	83 c4 08	 add	 esp, 8
$LN6@DragScalar:

; 2151 :         value_changed |= DragScalar("", data_type, p_data, v_speed, p_min, p_max, format, power);

  000d3	0f b6 5d e3	 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  000d7	51		 push	 ecx
  000d8	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  000dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e2	8b 45 24	 mov	 eax, DWORD PTR _format$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d 20	 mov	 ecx, DWORD PTR _p_max$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 1c	 mov	 edx, DWORD PTR _p_min$[ebp]
  000ed	52		 push	 edx
  000ee	51		 push	 ecx
  000ef	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  000f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f9	8b 45 10	 mov	 eax, DWORD PTR _p_data$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _data_type$[ebp]
  00100	51		 push	 ecx
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00106	e8 00 00 00 00	 call	 ?DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z ; ImGui::DragScalar
  0010b	83 c4 20	 add	 esp, 32			; 00000020H
  0010e	0f b6 d0	 movzx	 edx, al
  00111	0b da		 or	 ebx, edx
  00113	88 5d e3	 mov	 BYTE PTR _value_changed$[ebp], bl

; 2152 :         PopID();

  00116	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2153 :         PopItemWidth();

  0011b	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 2154 :         p_data = (void*)((char*)p_data + type_size);

  00120	8b 45 10	 mov	 eax, DWORD PTR _p_data$[ebp]
  00123	03 45 d4	 add	 eax, DWORD PTR _type_size$[ebp]
  00126	89 45 10	 mov	 DWORD PTR _p_data$[ebp], eax

; 2155 :     }

  00129	e9 5c ff ff ff	 jmp	 $LN2@DragScalar
$LN3@DragScalar:

; 2156 :     PopID();

  0012e	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2157 : 
; 2158 :     const char* label_end = FindRenderedTextEnd(label);

  00133	6a 00		 push	 0
  00135	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  0013e	83 c4 08	 add	 esp, 8
  00141	89 45 bc	 mov	 DWORD PTR _label_end$[ebp], eax

; 2159 :     if (label != label_end)

  00144	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00147	3b 45 bc	 cmp	 eax, DWORD PTR _label_end$[ebp]
  0014a	74 34		 je	 SHORT $LN7@DragScalar

; 2160 :     {
; 2161 :         SameLine(0, g.Style.ItemInnerSpacing.x);

  0014c	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  0014f	51		 push	 ecx
  00150	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  00158	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015d	51		 push	 ecx
  0015e	0f 57 c0	 xorps	 xmm0, xmm0
  00161	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00166	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  0016b	83 c4 08	 add	 esp, 8

; 2162 :         TextEx(label, label_end);

  0016e	6a 00		 push	 0
  00170	8b 45 bc	 mov	 eax, DWORD PTR _label_end$[ebp]
  00173	50		 push	 eax
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@DragScalar:

; 2163 :     }
; 2164 : 
; 2165 :     EndGroup();

  00180	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 2166 :     return value_changed;

  00185	8a 45 e3	 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@DragScalar:

; 2167 : }

  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	5b		 pop	 ebx
  0018b	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00191	3b ec		 cmp	 ebp, esp
  00193	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z ENDP		; ImGui::DragScalarN
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z
_TEXT	SEGMENT
tv249 = -604						; size = 4
tv250 = -600						; size = 4
tv148 = -600						; size = 4
tv202 = -597						; size = 1
tv193 = -597						; size = 1
$T1 = -592						; size = 8
$T2 = -576						; size = 8
$T3 = -560						; size = 8
$T4 = -544						; size = 8
$T5 = -528						; size = 8
$T6 = -512						; size = 8
_value_buf_end$ = -304					; size = 4
_value_buf$ = -292					; size = 64
_value_changed$ = -217					; size = 1
_frame_col$ = -208					; size = 4
_double_clicked$7 = -193				; size = 1
_clicked$8 = -181					; size = 1
_focus_requested$9 = -169				; size = 1
_temp_input_start$ = -157				; size = 1
_temp_input_is_active$ = -145				; size = 1
_hovered$ = -133					; size = 1
_total_bb$ = -124					; size = 16
_frame_bb$ = -100					; size = 16
_label_size$ = -76					; size = 8
_w$ = -60						; size = 4
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_data_type$ = 12					; size = 4
_p_data$ = 16						; size = 4
_v_speed$ = 20						; size = 4
_p_min$ = 24						; size = 4
_p_max$ = 28						; size = 4
_format$ = 32						; size = 4
_power$ = 36						; size = 4
?DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z PROC		; ImGui::DragScalar, COMDAT

; 2061 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 02 00
	00		 sub	 esp, 604		; 0000025cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a4 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-604]
  00012	b9 97 00 00 00	 mov	 ecx, 151		; 00000097H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2062 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 2063 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN5@DragScalar

; 2064 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 8d 05 00 00	 jmp	 $LN1@DragScalar
$LN5@DragScalar:

; 2065 : 
; 2066 :     if (power != 1.0f)

  0004c	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  00051	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  00058	9f		 lahf
  00059	f6 c4 44	 test	 ah, 68			; 00000044H
  0005c	7b 31		 jnp	 SHORT $LN23@DragScalar

; 2067 :         IM_ASSERT(p_min != NULL && p_max != NULL); // When using a power curve the drag needs to have known bounds

  0005e	83 7d 18 00	 cmp	 DWORD PTR _p_min$[ebp], 0
  00062	74 06		 je	 SHORT $LN22@DragScalar
  00064	83 7d 1c 00	 cmp	 DWORD PTR _p_max$[ebp], 0
  00068	75 25		 jne	 SHORT $LN23@DragScalar
$LN22@DragScalar:
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z@4JA
  0006f	83 c0 06	 add	 eax, 6
  00072	8b f4		 mov	 esi, esp
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@IAANKGPJ@?$AAp?$AA_?$AAm?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN23@DragScalar:

; 2068 : 
; 2069 :     ImGuiContext& g = *GImGui;

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00094	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 2070 :     const ImGuiStyle& style = g.Style;

  00097	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0009a	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0009f	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 2071 :     const ImGuiID id = window->GetID(label);

  000a2	6a 00		 push	 0
  000a4	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000ab	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  000b0	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 2072 :     const float w = CalcItemWidth();

  000b3	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  000b8	d9 5d c4	 fstp	 DWORD PTR _w$[ebp]

; 2073 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  000bb	51		 push	 ecx
  000bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c9	6a 01		 push	 1
  000cb	6a 00		 push	 0
  000cd	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000d0	50		 push	 eax
  000d1	8d 4d b4	 lea	 ecx, DWORD PTR _label_size$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  000da	83 c4 14	 add	 esp, 20			; 00000014H

; 2074 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

  000dd	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000e0	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  000e5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000ed	f3 0f 58 45 b8	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000f2	51		 push	 ecx
  000f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f8	51		 push	 ecx
  000f9	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _w$[ebp]
  000fe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00103	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00109	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0010e	50		 push	 eax
  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00112	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  00118	51		 push	 ecx
  00119	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
  00128	50		 push	 eax
  00129	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0012c	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  00131	50		 push	 eax
  00132	8d 4d 9c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00135	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 2075 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

  0013a	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  0013f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00146	76 17		 jbe	 SHORT $LN24@DragScalar
  00148	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0014b	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00150	f3 0f 58 45 b4	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  00155	f3 0f 11 85 a8
	fd ff ff	 movss	 DWORD PTR tv148[ebp], xmm0
  0015d	eb 0b		 jmp	 SHORT $LN25@DragScalar
$LN24@DragScalar:
  0015f	0f 57 c0	 xorps	 xmm0, xmm0
  00162	f3 0f 11 85 a8
	fd ff ff	 movss	 DWORD PTR tv148[ebp], xmm0
$LN25@DragScalar:
  0016a	51		 push	 ecx
  0016b	0f 57 c0	 xorps	 xmm0, xmm0
  0016e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00173	51		 push	 ecx
  00174	f3 0f 10 85 a8
	fd ff ff	 movss	 xmm0, DWORD PTR tv148[ebp]
  0017c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00181	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00187	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0018c	50		 push	 eax
  0018d	8d 4d a4	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  00190	51		 push	 ecx
  00191	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00197	52		 push	 edx
  00198	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a0	50		 push	 eax
  001a1	8d 45 9c	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  001a4	50		 push	 eax
  001a5	8d 4d 84	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  001a8	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 2076 : 
; 2077 :     ItemSize(total_bb, style.FramePadding.y);

  001ad	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  001b0	51		 push	 ecx
  001b1	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  001b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bb	8d 4d 84	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  001be	51		 push	 ecx
  001bf	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  001c4	83 c4 08	 add	 esp, 8

; 2078 :     if (!ItemAdd(total_bb, id, &frame_bb))

  001c7	8d 45 9c	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  001ca	50		 push	 eax
  001cb	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  001ce	51		 push	 ecx
  001cf	8d 55 84	 lea	 edx, DWORD PTR _total_bb$[ebp]
  001d2	52		 push	 edx
  001d3	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001db	0f b6 c0	 movzx	 eax, al
  001de	85 c0		 test	 eax, eax
  001e0	75 07		 jne	 SHORT $LN7@DragScalar

; 2079 :         return false;

  001e2	32 c0		 xor	 al, al
  001e4	e9 f0 03 00 00	 jmp	 $LN1@DragScalar
$LN7@DragScalar:

; 2080 : 
; 2081 :     // Default format string when passing NULL
; 2082 :     if (format == NULL)

  001e9	83 7d 20 00	 cmp	 DWORD PTR _format$[ebp], 0
  001ed	75 14		 jne	 SHORT $LN8@DragScalar

; 2083 :         format = DataTypeGetInfo(data_type)->PrintFmt;

  001ef	8b 45 0c	 mov	 eax, DWORD PTR _data_type$[ebp]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ?DataTypeGetInfo@ImGui@@YAPBUImGuiDataTypeInfo@@H@Z ; ImGui::DataTypeGetInfo
  001f8	83 c4 04	 add	 esp, 4
  001fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001fe	89 4d 20	 mov	 DWORD PTR _format$[ebp], ecx
  00201	eb 2a		 jmp	 SHORT $LN10@DragScalar
$LN8@DragScalar:

; 2084 :     else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)

  00203	83 7d 0c 04	 cmp	 DWORD PTR _data_type$[ebp], 4
  00207	75 24		 jne	 SHORT $LN10@DragScalar
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0020e	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _strcmp
  00217	83 c4 08	 add	 esp, 8
  0021a	85 c0		 test	 eax, eax
  0021c	74 0f		 je	 SHORT $LN10@DragScalar

; 2085 :         format = PatchFormatStringFloatToInt(format);

  0021e	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ?PatchFormatStringFloatToInt@@YAPBDPBD@Z ; PatchFormatStringFloatToInt
  00227	83 c4 04	 add	 esp, 4
  0022a	89 45 20	 mov	 DWORD PTR _format$[ebp], eax
$LN10@DragScalar:

; 2086 : 
; 2087 :     // Tabbing or CTRL-clicking on Drag turns it into an input box
; 2088 :     const bool hovered = ItemHoverable(frame_bb, id);

  0022d	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00230	50		 push	 eax
  00231	8d 4d 9c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00234	51		 push	 ecx
  00235	e8 00 00 00 00	 call	 ?ItemHoverable@ImGui@@YA_NABUImRect@@I@Z ; ImGui::ItemHoverable
  0023a	83 c4 08	 add	 esp, 8
  0023d	88 85 7b ff ff
	ff		 mov	 BYTE PTR _hovered$[ebp], al

; 2089 :     bool temp_input_is_active = TempInputTextIsActive(id);

  00243	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 ?TempInputTextIsActive@ImGui@@YA_NI@Z ; ImGui::TempInputTextIsActive
  0024c	83 c4 04	 add	 esp, 4
  0024f	88 85 6f ff ff
	ff		 mov	 BYTE PTR _temp_input_is_active$[ebp], al

; 2090 :     bool temp_input_start = false;

  00255	c6 85 63 ff ff
	ff 00		 mov	 BYTE PTR _temp_input_start$[ebp], 0

; 2091 :     if (!temp_input_is_active)

  0025c	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _temp_input_is_active$[ebp]
  00263	85 c0		 test	 eax, eax
  00265	0f 85 5c 01 00
	00		 jne	 $LN14@DragScalar

; 2092 :     {
; 2093 :         const bool focus_requested = FocusableItemRegister(window, id);

  0026b	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0026e	50		 push	 eax
  0026f	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00272	51		 push	 ecx
  00273	e8 00 00 00 00	 call	 ?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I@Z ; ImGui::FocusableItemRegister
  00278	83 c4 08	 add	 esp, 8
  0027b	88 85 57 ff ff
	ff		 mov	 BYTE PTR _focus_requested$9[ebp], al

; 2094 :         const bool clicked = (hovered && g.IO.MouseClicked[0]);

  00281	0f b6 85 7b ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  00288	85 c0		 test	 eax, eax
  0028a	74 20		 je	 SHORT $LN26@DragScalar
  0028c	b9 01 00 00 00	 mov	 ecx, 1
  00291	6b d1 00	 imul	 edx, ecx, 0
  00294	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00297	0f b6 8c 10 d8
	03 00 00	 movzx	 ecx, BYTE PTR [eax+edx+984]
  0029f	85 c9		 test	 ecx, ecx
  002a1	74 09		 je	 SHORT $LN26@DragScalar
  002a3	c6 85 ab fd ff
	ff 01		 mov	 BYTE PTR tv193[ebp], 1
  002aa	eb 07		 jmp	 SHORT $LN27@DragScalar
$LN26@DragScalar:
  002ac	c6 85 ab fd ff
	ff 00		 mov	 BYTE PTR tv193[ebp], 0
$LN27@DragScalar:
  002b3	8a 95 ab fd ff
	ff		 mov	 dl, BYTE PTR tv193[ebp]
  002b9	88 95 4b ff ff
	ff		 mov	 BYTE PTR _clicked$8[ebp], dl

; 2095 :         const bool double_clicked = (hovered && g.IO.MouseDoubleClicked[0]);

  002bf	0f b6 85 7b ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  002c6	85 c0		 test	 eax, eax
  002c8	74 20		 je	 SHORT $LN28@DragScalar
  002ca	b9 01 00 00 00	 mov	 ecx, 1
  002cf	6b d1 00	 imul	 edx, ecx, 0
  002d2	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  002d5	0f b6 8c 10 dd
	03 00 00	 movzx	 ecx, BYTE PTR [eax+edx+989]
  002dd	85 c9		 test	 ecx, ecx
  002df	74 09		 je	 SHORT $LN28@DragScalar
  002e1	c6 85 ab fd ff
	ff 01		 mov	 BYTE PTR tv202[ebp], 1
  002e8	eb 07		 jmp	 SHORT $LN29@DragScalar
$LN28@DragScalar:
  002ea	c6 85 ab fd ff
	ff 00		 mov	 BYTE PTR tv202[ebp], 0
$LN29@DragScalar:
  002f1	8a 95 ab fd ff
	ff		 mov	 dl, BYTE PTR tv202[ebp]
  002f7	88 95 3f ff ff
	ff		 mov	 BYTE PTR _double_clicked$7[ebp], dl

; 2096 :         if (focus_requested || clicked || double_clicked || g.NavActivateId == id || g.NavInputId == id)

  002fd	0f b6 85 57 ff
	ff ff		 movzx	 eax, BYTE PTR _focus_requested$9[ebp]
  00304	85 c0		 test	 eax, eax
  00306	75 36		 jne	 SHORT $LN13@DragScalar
  00308	0f b6 85 4b ff
	ff ff		 movzx	 eax, BYTE PTR _clicked$8[ebp]
  0030f	85 c0		 test	 eax, eax
  00311	75 2b		 jne	 SHORT $LN13@DragScalar
  00313	0f b6 85 3f ff
	ff ff		 movzx	 eax, BYTE PTR _double_clicked$7[ebp]
  0031a	85 c0		 test	 eax, eax
  0031c	75 20		 jne	 SHORT $LN13@DragScalar
  0031e	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00321	8b 88 d8 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6872]
  00327	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0032a	74 12		 je	 SHORT $LN13@DragScalar
  0032c	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0032f	8b 88 e4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6884]
  00335	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  00338	0f 85 89 00 00
	00		 jne	 $LN14@DragScalar
$LN13@DragScalar:

; 2097 :         {
; 2098 :             SetActiveID(id, window);

  0033e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00341	50		 push	 eax
  00342	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00345	51		 push	 ecx
  00346	e8 00 00 00 00	 call	 ?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
  0034b	83 c4 08	 add	 esp, 8

; 2099 :             SetFocusID(id, window);

  0034e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00351	50		 push	 eax
  00352	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  00355	51		 push	 ecx
  00356	e8 00 00 00 00	 call	 ?SetFocusID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetFocusID
  0035b	83 c4 08	 add	 esp, 8

; 2100 :             FocusWindow(window);

  0035e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00361	50		 push	 eax
  00362	e8 00 00 00 00	 call	 ?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
  00367	83 c4 04	 add	 esp, 4

; 2101 :             g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);

  0036a	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0036d	c7 80 f8 19 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+6648], 3

; 2102 :             if (focus_requested || (clicked && g.IO.KeyCtrl) || double_clicked || g.NavInputId == id)

  00377	0f b6 85 57 ff
	ff ff		 movzx	 eax, BYTE PTR _focus_requested$9[ebp]
  0037e	85 c0		 test	 eax, eax
  00380	75 32		 jne	 SHORT $LN15@DragScalar
  00382	0f b6 85 4b ff
	ff ff		 movzx	 eax, BYTE PTR _clicked$8[ebp]
  00389	85 c0		 test	 eax, eax
  0038b	74 0e		 je	 SHORT $LN16@DragScalar
  0038d	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00390	0f b6 88 00 01
	00 00		 movzx	 ecx, BYTE PTR [eax+256]
  00397	85 c9		 test	 ecx, ecx
  00399	75 19		 jne	 SHORT $LN15@DragScalar
$LN16@DragScalar:
  0039b	0f b6 85 3f ff
	ff ff		 movzx	 eax, BYTE PTR _double_clicked$7[ebp]
  003a2	85 c0		 test	 eax, eax
  003a4	75 0e		 jne	 SHORT $LN15@DragScalar
  003a6	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  003a9	8b 88 e4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6884]
  003af	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  003b2	75 13		 jne	 SHORT $LN14@DragScalar
$LN15@DragScalar:

; 2103 :             {
; 2104 :                 temp_input_start = true;

  003b4	c6 85 63 ff ff
	ff 01		 mov	 BYTE PTR _temp_input_start$[ebp], 1

; 2105 :                 FocusableItemUnregister(window);

  003bb	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  003be	50		 push	 eax
  003bf	e8 00 00 00 00	 call	 ?FocusableItemUnregister@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusableItemUnregister
  003c4	83 c4 04	 add	 esp, 4
$LN14@DragScalar:

; 2106 :             }
; 2107 :         }
; 2108 :     }
; 2109 :     if (temp_input_is_active || temp_input_start)

  003c7	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _temp_input_is_active$[ebp]
  003ce	85 c0		 test	 eax, eax
  003d0	75 0b		 jne	 SHORT $LN18@DragScalar
  003d2	0f b6 85 63 ff
	ff ff		 movzx	 eax, BYTE PTR _temp_input_start$[ebp]
  003d9	85 c0		 test	 eax, eax
  003db	74 25		 je	 SHORT $LN17@DragScalar
$LN18@DragScalar:

; 2110 :         return TempInputTextScalar(frame_bb, id, label, data_type, p_data, format);

  003dd	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  003e0	50		 push	 eax
  003e1	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  003e4	51		 push	 ecx
  003e5	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  003e8	52		 push	 edx
  003e9	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  003ec	50		 push	 eax
  003ed	8b 4d d0	 mov	 ecx, DWORD PTR _id$[ebp]
  003f0	51		 push	 ecx
  003f1	8d 55 9c	 lea	 edx, DWORD PTR _frame_bb$[ebp]
  003f4	52		 push	 edx
  003f5	e8 00 00 00 00	 call	 ?TempInputTextScalar@ImGui@@YA_NABUImRect@@IPBDHPAX1@Z ; ImGui::TempInputTextScalar
  003fa	83 c4 18	 add	 esp, 24			; 00000018H
  003fd	e9 d7 01 00 00	 jmp	 $LN1@DragScalar
$LN17@DragScalar:

; 2111 : 
; 2112 :     // Draw frame
; 2113 :     const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

  00402	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00405	8b 88 e4 19 00
	00		 mov	 ecx, DWORD PTR [eax+6628]
  0040b	3b 4d d0	 cmp	 ecx, DWORD PTR _id$[ebp]
  0040e	75 0c		 jne	 SHORT $LN32@DragScalar
  00410	c7 85 a8 fd ff
	ff 09 00 00 00	 mov	 DWORD PTR tv250[ebp], 9
  0041a	eb 30		 jmp	 SHORT $LN33@DragScalar
$LN32@DragScalar:
  0041c	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  0041f	8b 82 d0 19 00
	00		 mov	 eax, DWORD PTR [edx+6608]
  00425	3b 45 d0	 cmp	 eax, DWORD PTR _id$[ebp]
  00428	75 0c		 jne	 SHORT $LN30@DragScalar
  0042a	c7 85 a4 fd ff
	ff 08 00 00 00	 mov	 DWORD PTR tv249[ebp], 8
  00434	eb 0a		 jmp	 SHORT $LN31@DragScalar
$LN30@DragScalar:
  00436	c7 85 a4 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR tv249[ebp], 7
$LN31@DragScalar:
  00440	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR tv249[ebp]
  00446	89 8d a8 fd ff
	ff		 mov	 DWORD PTR tv250[ebp], ecx
$LN33@DragScalar:
  0044c	51		 push	 ecx
  0044d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00455	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0045a	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR tv250[ebp]
  00460	52		 push	 edx
  00461	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00466	83 c4 08	 add	 esp, 8
  00469	89 85 30 ff ff
	ff		 mov	 DWORD PTR _frame_col$[ebp], eax

; 2114 :     RenderNavHighlight(frame_bb, id);

  0046f	6a 01		 push	 1
  00471	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00474	50		 push	 eax
  00475	8d 4d 9c	 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00478	51		 push	 ecx
  00479	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  0047e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2115 :     RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

  00481	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00484	51		 push	 ecx
  00485	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  0048a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0048f	6a 01		 push	 1
  00491	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _frame_col$[ebp]
  00497	51		 push	 ecx
  00498	8b 55 a8	 mov	 edx, DWORD PTR _frame_bb$[ebp+12]
  0049b	52		 push	 edx
  0049c	8b 45 a4	 mov	 eax, DWORD PTR _frame_bb$[ebp+8]
  0049f	50		 push	 eax
  004a0	8b 4d a0	 mov	 ecx, DWORD PTR _frame_bb$[ebp+4]
  004a3	51		 push	 ecx
  004a4	8b 55 9c	 mov	 edx, DWORD PTR _frame_bb$[ebp]
  004a7	52		 push	 edx
  004a8	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  004ad	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2116 : 
; 2117 :     // Drag behavior
; 2118 :     const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, power, ImGuiDragFlags_None);

  004b0	6a 00		 push	 0
  004b2	51		 push	 ecx
  004b3	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _power$[ebp]
  004b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004bd	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  004c0	50		 push	 eax
  004c1	8b 4d 1c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  004c4	51		 push	 ecx
  004c5	8b 55 18	 mov	 edx, DWORD PTR _p_min$[ebp]
  004c8	52		 push	 edx
  004c9	51		 push	 ecx
  004ca	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  004cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d4	8b 45 10	 mov	 eax, DWORD PTR _p_data$[ebp]
  004d7	50		 push	 eax
  004d8	8b 4d 0c	 mov	 ecx, DWORD PTR _data_type$[ebp]
  004db	51		 push	 ecx
  004dc	8b 55 d0	 mov	 edx, DWORD PTR _id$[ebp]
  004df	52		 push	 edx
  004e0	e8 00 00 00 00	 call	 ?DragBehavior@ImGui@@YA_NIHPAXMPBX1PBDMH@Z ; ImGui::DragBehavior
  004e5	83 c4 24	 add	 esp, 36			; 00000024H
  004e8	88 85 27 ff ff
	ff		 mov	 BYTE PTR _value_changed$[ebp], al

; 2119 :     if (value_changed)

  004ee	0f b6 85 27 ff
	ff ff		 movzx	 eax, BYTE PTR _value_changed$[ebp]
  004f5	85 c0		 test	 eax, eax
  004f7	74 0c		 je	 SHORT $LN19@DragScalar

; 2120 :         MarkItemEdited(id);

  004f9	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  004fc	50		 push	 eax
  004fd	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  00502	83 c4 04	 add	 esp, 4
$LN19@DragScalar:

; 2121 : 
; 2122 :     // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
; 2123 :     char value_buf[64];
; 2124 :     const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);

  00505	8b 45 20	 mov	 eax, DWORD PTR _format$[ebp]
  00508	50		 push	 eax
  00509	8b 4d 10	 mov	 ecx, DWORD PTR _p_data$[ebp]
  0050c	51		 push	 ecx
  0050d	8b 55 0c	 mov	 edx, DWORD PTR _data_type$[ebp]
  00510	52		 push	 edx
  00511	6a 40		 push	 64			; 00000040H
  00513	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _value_buf$[ebp]
  00519	50		 push	 eax
  0051a	e8 00 00 00 00	 call	 ?DataTypeFormatString@ImGui@@YAHPADHHPBXPBD@Z ; ImGui::DataTypeFormatString
  0051f	83 c4 14	 add	 esp, 20			; 00000014H
  00522	8d 8c 05 dc fe
	ff ff		 lea	 ecx, DWORD PTR _value_buf$[ebp+eax]
  00529	89 8d d0 fe ff
	ff		 mov	 DWORD PTR _value_buf_end$[ebp], ecx

; 2125 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

  0052f	6a 00		 push	 0
  00531	51		 push	 ecx
  00532	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0053a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0053f	51		 push	 ecx
  00540	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00548	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0054d	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00553	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00558	50		 push	 eax
  00559	6a 00		 push	 0
  0055b	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _value_buf_end$[ebp]
  00561	50		 push	 eax
  00562	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _value_buf$[ebp]
  00568	51		 push	 ecx
  00569	8d 55 a4	 lea	 edx, DWORD PTR _frame_bb$[ebp+8]
  0056c	52		 push	 edx
  0056d	8d 45 9c	 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00570	50		 push	 eax
  00571	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00576	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2126 : 
; 2127 :     if (label_size.x > 0.0f)

  00579	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  0057e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00585	76 48		 jbe	 SHORT $LN20@DragScalar

; 2128 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

  00587	6a 01		 push	 1
  00589	6a 00		 push	 0
  0058b	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0058e	50		 push	 eax
  0058f	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00592	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  00597	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  0059c	51		 push	 ecx
  0059d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a2	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  005a5	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  005aa	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  005af	51		 push	 ecx
  005b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b5	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  005bb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  005c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005c3	51		 push	 ecx
  005c4	8b 10		 mov	 edx, DWORD PTR [eax]
  005c6	52		 push	 edx
  005c7	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  005cc	83 c4 14	 add	 esp, 20			; 00000014H
$LN20@DragScalar:

; 2129 : 
; 2130 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);

  005cf	33 c0		 xor	 eax, eax
  005d1	75 fc		 jne	 SHORT $LN20@DragScalar

; 2131 :     return value_changed;

  005d3	8a 85 27 ff ff
	ff		 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@DragScalar:

; 2132 : }

  005d9	52		 push	 edx
  005da	8b cd		 mov	 ecx, ebp
  005dc	50		 push	 eax
  005dd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN39@DragScalar
  005e3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005e8	58		 pop	 eax
  005e9	5a		 pop	 edx
  005ea	5f		 pop	 edi
  005eb	5e		 pop	 esi
  005ec	5b		 pop	 ebx
  005ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f0	33 cd		 xor	 ecx, ebp
  005f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f7	81 c4 5c 02 00
	00		 add	 esp, 604		; 0000025cH
  005fd	3b ec		 cmp	 ebp, esp
  005ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00604	8b e5		 mov	 esp, ebp
  00606	5d		 pop	 ebp
  00607	c3		 ret	 0
$LN39@DragScalar:
  00608	04 00 00 00	 DD	 4
  0060c	00 00 00 00	 DD	 $LN38@DragScalar
$LN38@DragScalar:
  00610	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00614	08 00 00 00	 DD	 8
  00618	00 00 00 00	 DD	 $LN34@DragScalar
  0061c	9c ff ff ff	 DD	 -100			; ffffff9cH
  00620	10 00 00 00	 DD	 16			; 00000010H
  00624	00 00 00 00	 DD	 $LN35@DragScalar
  00628	84 ff ff ff	 DD	 -124			; ffffff84H
  0062c	10 00 00 00	 DD	 16			; 00000010H
  00630	00 00 00 00	 DD	 $LN36@DragScalar
  00634	dc fe ff ff	 DD	 -292			; fffffedcH
  00638	40 00 00 00	 DD	 64			; 00000040H
  0063c	00 00 00 00	 DD	 $LN37@DragScalar
$LN37@DragScalar:
  00640	76		 DB	 118			; 00000076H
  00641	61		 DB	 97			; 00000061H
  00642	6c		 DB	 108			; 0000006cH
  00643	75		 DB	 117			; 00000075H
  00644	65		 DB	 101			; 00000065H
  00645	5f		 DB	 95			; 0000005fH
  00646	62		 DB	 98			; 00000062H
  00647	75		 DB	 117			; 00000075H
  00648	66		 DB	 102			; 00000066H
  00649	00		 DB	 0
$LN36@DragScalar:
  0064a	74		 DB	 116			; 00000074H
  0064b	6f		 DB	 111			; 0000006fH
  0064c	74		 DB	 116			; 00000074H
  0064d	61		 DB	 97			; 00000061H
  0064e	6c		 DB	 108			; 0000006cH
  0064f	5f		 DB	 95			; 0000005fH
  00650	62		 DB	 98			; 00000062H
  00651	62		 DB	 98			; 00000062H
  00652	00		 DB	 0
$LN35@DragScalar:
  00653	66		 DB	 102			; 00000066H
  00654	72		 DB	 114			; 00000072H
  00655	61		 DB	 97			; 00000061H
  00656	6d		 DB	 109			; 0000006dH
  00657	65		 DB	 101			; 00000065H
  00658	5f		 DB	 95			; 0000005fH
  00659	62		 DB	 98			; 00000062H
  0065a	62		 DB	 98			; 00000062H
  0065b	00		 DB	 0
$LN34@DragScalar:
  0065c	6c		 DB	 108			; 0000006cH
  0065d	61		 DB	 97			; 00000061H
  0065e	62		 DB	 98			; 00000062H
  0065f	65		 DB	 101			; 00000065H
  00660	6c		 DB	 108			; 0000006cH
  00661	5f		 DB	 95			; 0000005fH
  00662	73		 DB	 115			; 00000073H
  00663	69		 DB	 105			; 00000069H
  00664	7a		 DB	 122			; 0000007aH
  00665	65		 DB	 101			; 00000065H
  00666	00		 DB	 0
?DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z ENDP		; ImGui::DragScalar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z
_TEXT	SEGMENT
tv135 = -240						; size = 4
tv129 = -236						; size = 4
tv81 = -236						; size = 4
tv94 = -232						; size = 4
tv78 = -232						; size = 4
_value_changed$ = -29					; size = 1
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_label$ = 8						; size = 4
_v_current_min$ = 12					; size = 4
_v_current_max$ = 16					; size = 4
_v_speed$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_format$ = 32						; size = 4
_format_max$ = 36					; size = 4
?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z PROC		; ImGui::DragIntRange2, COMDAT

; 2235 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2236 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 2237 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 07		 je	 SHORT $LN2@DragIntRan

; 2238 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	e9 c0 01 00 00	 jmp	 $LN1@DragIntRan
$LN2@DragIntRan:

; 2239 : 
; 2240 :     ImGuiContext& g = *GImGui;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00047	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 2241 :     PushID(label);

  0004a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  00053	83 c4 04	 add	 esp, 4

; 2242 :     BeginGroup();

  00056	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 2243 :     PushMultiItemsWidths(2, CalcItemWidth());

  0005b	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00060	51		 push	 ecx
  00061	d9 1c 24	 fstp	 DWORD PTR [esp]
  00064	6a 02		 push	 2
  00066	e8 00 00 00 00	 call	 ?PushMultiItemsWidths@ImGui@@YAXHM@Z ; ImGui::PushMultiItemsWidths
  0006b	83 c4 08	 add	 esp, 8

; 2244 : 
; 2245 :     bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);

  0006e	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00071	3b 45 1c	 cmp	 eax, DWORD PTR _v_max$[ebp]
  00074	7c 0d		 jl	 SHORT $LN4@DragIntRan
  00076	8b 4d 10	 mov	 ecx, DWORD PTR _v_current_max$[ebp]
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	89 95 18 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], edx
  00081	eb 18		 jmp	 SHORT $LN5@DragIntRan
$LN4@DragIntRan:
  00083	8b 45 10	 mov	 eax, DWORD PTR _v_current_max$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	51		 push	 ecx
  00089	8b 55 1c	 mov	 edx, DWORD PTR _v_max$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ??$ImMin@H@@YAHHH@Z	; ImMin<int>
  00092	83 c4 08	 add	 esp, 8
  00095	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
$LN5@DragIntRan:
  0009b	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  0009e	3b 45 1c	 cmp	 eax, DWORD PTR _v_max$[ebp]
  000a1	7c 0c		 jl	 SHORT $LN6@DragIntRan
  000a3	c7 85 14 ff ff
	ff 00 00 00 80	 mov	 DWORD PTR tv81[ebp], -2147483648 ; 80000000H
  000ad	eb 09		 jmp	 SHORT $LN7@DragIntRan
$LN6@DragIntRan:
  000af	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  000b2	89 8d 14 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
$LN7@DragIntRan:
  000b8	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  000bb	52		 push	 edx
  000bc	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  000c2	50		 push	 eax
  000c3	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv81[ebp]
  000c9	51		 push	 ecx
  000ca	51		 push	 ecx
  000cb	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	8b 55 0c	 mov	 edx, DWORD PTR _v_current_min$[ebp]
  000d8	52		 push	 edx
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_05DMFAOFEI@?$CD?$CDmin@
  000de	e8 00 00 00 00	 call	 ?DragInt@ImGui@@YA_NPBDPAHMHH0@Z ; ImGui::DragInt
  000e3	83 c4 18	 add	 esp, 24			; 00000018H
  000e6	88 45 e3	 mov	 BYTE PTR _value_changed$[ebp], al

; 2246 :     PopItemWidth();

  000e9	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 2247 :     SameLine(0, g.Style.ItemInnerSpacing.x);

  000ee	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  000f1	51		 push	 ecx
  000f2	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  000fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ff	51		 push	 ecx
  00100	0f 57 c0	 xorps	 xmm0, xmm0
  00103	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00108	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  0010d	83 c4 08	 add	 esp, 8

; 2248 :     value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);

  00110	83 7d 24 00	 cmp	 DWORD PTR _format_max$[ebp], 0
  00114	74 0b		 je	 SHORT $LN8@DragIntRan
  00116	8b 45 24	 mov	 eax, DWORD PTR _format_max$[ebp]
  00119	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv94[ebp], eax
  0011f	eb 09		 jmp	 SHORT $LN9@DragIntRan
$LN8@DragIntRan:
  00121	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  00124	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv94[ebp], ecx
$LN9@DragIntRan:
  0012a	8b 55 18	 mov	 edx, DWORD PTR _v_min$[ebp]
  0012d	3b 55 1c	 cmp	 edx, DWORD PTR _v_max$[ebp]
  00130	7c 0c		 jl	 SHORT $LN10@DragIntRan
  00132	c7 85 14 ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR tv129[ebp], 2147483647 ; 7fffffffH
  0013c	eb 09		 jmp	 SHORT $LN11@DragIntRan
$LN10@DragIntRan:
  0013e	8b 45 1c	 mov	 eax, DWORD PTR _v_max$[ebp]
  00141	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
$LN11@DragIntRan:
  00147	8b 4d 18	 mov	 ecx, DWORD PTR _v_min$[ebp]
  0014a	3b 4d 1c	 cmp	 ecx, DWORD PTR _v_max$[ebp]
  0014d	7c 0d		 jl	 SHORT $LN12@DragIntRan
  0014f	8b 55 0c	 mov	 edx, DWORD PTR _v_current_min$[ebp]
  00152	8b 02		 mov	 eax, DWORD PTR [edx]
  00154	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
  0015a	eb 18		 jmp	 SHORT $LN13@DragIntRan
$LN12@DragIntRan:
  0015c	8b 4d 0c	 mov	 ecx, DWORD PTR _v_current_min$[ebp]
  0015f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00161	52		 push	 edx
  00162	8b 45 18	 mov	 eax, DWORD PTR _v_min$[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  0016b	83 c4 08	 add	 esp, 8
  0016e	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
$LN13@DragIntRan:
  00174	0f b6 5d e3	 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  00178	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv94[ebp]
  0017e	51		 push	 ecx
  0017f	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv129[ebp]
  00185	52		 push	 edx
  00186	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv135[ebp]
  0018c	50		 push	 eax
  0018d	51		 push	 ecx
  0018e	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00193	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00198	8b 4d 10	 mov	 ecx, DWORD PTR _v_current_max$[ebp]
  0019b	51		 push	 ecx
  0019c	68 00 00 00 00	 push	 OFFSET ??_C@_05CONLABCH@?$CD?$CDmax@
  001a1	e8 00 00 00 00	 call	 ?DragInt@ImGui@@YA_NPBDPAHMHH0@Z ; ImGui::DragInt
  001a6	83 c4 18	 add	 esp, 24			; 00000018H
  001a9	0f b6 d0	 movzx	 edx, al
  001ac	0b da		 or	 ebx, edx
  001ae	88 5d e3	 mov	 BYTE PTR _value_changed$[ebp], bl

; 2249 :     PopItemWidth();

  001b1	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 2250 :     SameLine(0, g.Style.ItemInnerSpacing.x);

  001b6	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  001b9	51		 push	 ecx
  001ba	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  001c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c7	51		 push	 ecx
  001c8	0f 57 c0	 xorps	 xmm0, xmm0
  001cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d0	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  001d5	83 c4 08	 add	 esp, 8

; 2251 : 
; 2252 :     TextEx(label, FindRenderedTextEnd(label));

  001d8	6a 00		 push	 0
  001da	6a 00		 push	 0
  001dc	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  001e5	83 c4 08	 add	 esp, 8
  001e8	50		 push	 eax
  001e9	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  001ec	51		 push	 ecx
  001ed	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  001f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2253 :     EndGroup();

  001f5	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 2254 :     PopID();

  001fa	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2255 : 
; 2256 :     return value_changed;

  001ff	8a 45 e3	 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@DragIntRan:

; 2257 : }

  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx
  00205	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0020b	3b ec		 cmp	 ebp, esp
  0020d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00212	8b e5		 mov	 esp, ebp
  00214	5d		 pop	 ebp
  00215	c3		 ret	 0
?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z ENDP		; ImGui::DragIntRange2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z PROC			; ImGui::DragInt4, COMDAT

; 2230 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2231 :     return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00048	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004d	6a 04		 push	 4
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00052	50		 push	 eax
  00053	6a 04		 push	 4
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z ; ImGui::DragScalarN
  0005e	83 c4 24	 add	 esp, 36			; 00000024H

; 2232 : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z ENDP			; ImGui::DragInt4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z PROC			; ImGui::DragInt3, COMDAT

; 2225 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2226 :     return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00048	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004d	6a 03		 push	 3
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00052	50		 push	 eax
  00053	6a 04		 push	 4
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z ; ImGui::DragScalarN
  0005e	83 c4 24	 add	 esp, 36			; 00000024H

; 2227 : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z ENDP			; ImGui::DragInt3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z PROC			; ImGui::DragInt2, COMDAT

; 2220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2221 :     return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00048	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004d	6a 02		 push	 2
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00052	50		 push	 eax
  00053	6a 04		 push	 4
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z ; ImGui::DragScalarN
  0005e	83 c4 24	 add	 esp, 36			; 00000024H

; 2222 : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z ENDP			; ImGui::DragInt2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragInt@ImGui@@YA_NPBDPAHMHH0@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
?DragInt@ImGui@@YA_NPBDPAHMHH0@Z PROC			; ImGui::DragInt, COMDAT

; 2215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2216 :     return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00048	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004d	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00050	50		 push	 eax
  00051	6a 04		 push	 4
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ?DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z ; ImGui::DragScalar
  0005c	83 c4 20	 add	 esp, 32			; 00000020H

; 2217 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?DragInt@ImGui@@YA_NPBDPAHMHH0@Z ENDP			; ImGui::DragInt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z
_TEXT	SEGMENT
tv137 = -240						; size = 4
tv131 = -236						; size = 4
tv82 = -236						; size = 4
tv128 = -232						; size = 4
tv79 = -232						; size = 4
_value_changed$ = -29					; size = 1
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_label$ = 8						; size = 4
_v_current_min$ = 12					; size = 4
_v_current_max$ = 16					; size = 4
_v_speed$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_format$ = 32						; size = 4
_format_max$ = 36					; size = 4
_power$ = 40						; size = 4
?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z PROC	; ImGui::DragFloatRange2, COMDAT

; 2190 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2191 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 2192 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 07		 je	 SHORT $LN2@DragFloatR

; 2193 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	e9 36 02 00 00	 jmp	 $LN1@DragFloatR
$LN2@DragFloatR:

; 2194 : 
; 2195 :     ImGuiContext& g = *GImGui;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00047	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 2196 :     PushID(label);

  0004a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBD@Z	; ImGui::PushID
  00053	83 c4 04	 add	 esp, 4

; 2197 :     BeginGroup();

  00056	e8 00 00 00 00	 call	 ?BeginGroup@ImGui@@YAXXZ ; ImGui::BeginGroup

; 2198 :     PushMultiItemsWidths(2, CalcItemWidth());

  0005b	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00060	51		 push	 ecx
  00061	d9 1c 24	 fstp	 DWORD PTR [esp]
  00064	6a 02		 push	 2
  00066	e8 00 00 00 00	 call	 ?PushMultiItemsWidths@ImGui@@YAXHM@Z ; ImGui::PushMultiItemsWidths
  0006b	83 c4 08	 add	 esp, 8

; 2199 : 
; 2200 :     bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);

  0006e	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00073	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _v_max$[ebp]
  00077	72 11		 jb	 SHORT $LN4@DragFloatR
  00079	8b 45 10	 mov	 eax, DWORD PTR _v_current_max$[ebp]
  0007c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00080	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR tv79[ebp], xmm0
  00088	eb 26		 jmp	 SHORT $LN5@DragFloatR
$LN4@DragFloatR:
  0008a	8b 4d 10	 mov	 ecx, DWORD PTR _v_current_max$[ebp]
  0008d	51		 push	 ecx
  0008e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00092	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00097	51		 push	 ecx
  00098	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  0009d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a2	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  000a7	83 c4 08	 add	 esp, 8
  000aa	d9 9d 18 ff ff
	ff		 fstp	 DWORD PTR tv79[ebp]
$LN5@DragFloatR:
  000b0	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  000b5	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _v_max$[ebp]
  000b9	72 12		 jb	 SHORT $LN6@DragFloatR
  000bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ff7fffff
  000c3	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR tv82[ebp], xmm0
  000cb	eb 0d		 jmp	 SHORT $LN7@DragFloatR
$LN6@DragFloatR:
  000cd	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  000d2	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR tv82[ebp], xmm0
$LN7@DragFloatR:
  000da	51		 push	 ecx
  000db	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  000e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e5	8b 55 20	 mov	 edx, DWORD PTR _format$[ebp]
  000e8	52		 push	 edx
  000e9	51		 push	 ecx
  000ea	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR tv79[ebp]
  000f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f7	51		 push	 ecx
  000f8	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR tv82[ebp]
  00100	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00105	51		 push	 ecx
  00106	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  0010b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00110	8b 45 0c	 mov	 eax, DWORD PTR _v_current_min$[ebp]
  00113	50		 push	 eax
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_05DMFAOFEI@?$CD?$CDmin@
  00119	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z ; ImGui::DragFloat
  0011e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00121	88 45 e3	 mov	 BYTE PTR _value_changed$[ebp], al

; 2201 :     PopItemWidth();

  00124	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 2202 :     SameLine(0, g.Style.ItemInnerSpacing.x);

  00129	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  0012c	51		 push	 ecx
  0012d	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  00135	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013a	51		 push	 ecx
  0013b	0f 57 c0	 xorps	 xmm0, xmm0
  0013e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00143	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00148	83 c4 08	 add	 esp, 8

; 2203 :     value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);

  0014b	83 7d 24 00	 cmp	 DWORD PTR _format_max$[ebp], 0
  0014f	74 0b		 je	 SHORT $LN8@DragFloatR
  00151	8b 45 24	 mov	 eax, DWORD PTR _format_max$[ebp]
  00154	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
  0015a	eb 09		 jmp	 SHORT $LN9@DragFloatR
$LN8@DragFloatR:
  0015c	8b 4d 20	 mov	 ecx, DWORD PTR _format$[ebp]
  0015f	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv128[ebp], ecx
$LN9@DragFloatR:
  00165	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  0016a	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _v_max$[ebp]
  0016e	72 12		 jb	 SHORT $LN10@DragFloatR
  00170	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00178	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR tv131[ebp], xmm0
  00180	eb 0d		 jmp	 SHORT $LN11@DragFloatR
$LN10@DragFloatR:
  00182	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _v_max$[ebp]
  00187	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR tv131[ebp], xmm0
$LN11@DragFloatR:
  0018f	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  00194	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _v_max$[ebp]
  00198	72 11		 jb	 SHORT $LN12@DragFloatR
  0019a	8b 55 0c	 mov	 edx, DWORD PTR _v_current_min$[ebp]
  0019d	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  001a1	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR tv137[ebp], xmm0
  001a9	eb 26		 jmp	 SHORT $LN13@DragFloatR
$LN12@DragFloatR:
  001ab	8b 45 0c	 mov	 eax, DWORD PTR _v_current_min$[ebp]
  001ae	51		 push	 ecx
  001af	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b8	51		 push	 ecx
  001b9	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _v_min$[ebp]
  001be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c3	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  001c8	83 c4 08	 add	 esp, 8
  001cb	d9 9d 10 ff ff
	ff		 fstp	 DWORD PTR tv137[ebp]
$LN13@DragFloatR:
  001d1	0f b6 5d e3	 movzx	 ebx, BYTE PTR _value_changed$[ebp]
  001d5	51		 push	 ecx
  001d6	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _power$[ebp]
  001db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e0	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv128[ebp]
  001e6	51		 push	 ecx
  001e7	51		 push	 ecx
  001e8	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR tv131[ebp]
  001f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f5	51		 push	 ecx
  001f6	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR tv137[ebp]
  001fe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00203	51		 push	 ecx
  00204	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00209	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020e	8b 55 10	 mov	 edx, DWORD PTR _v_current_max$[ebp]
  00211	52		 push	 edx
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_05CONLABCH@?$CD?$CDmax@
  00217	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z ; ImGui::DragFloat
  0021c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0021f	0f b6 c0	 movzx	 eax, al
  00222	0b d8		 or	 ebx, eax
  00224	88 5d e3	 mov	 BYTE PTR _value_changed$[ebp], bl

; 2204 :     PopItemWidth();

  00227	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 2205 :     SameLine(0, g.Style.ItemInnerSpacing.x);

  0022c	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  0022f	51		 push	 ecx
  00230	f3 0f 10 80 60
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5472]
  00238	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023d	51		 push	 ecx
  0023e	0f 57 c0	 xorps	 xmm0, xmm0
  00241	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00246	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  0024b	83 c4 08	 add	 esp, 8

; 2206 : 
; 2207 :     TextEx(label, FindRenderedTextEnd(label));

  0024e	6a 00		 push	 0
  00250	6a 00		 push	 0
  00252	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 ?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ; ImGui::FindRenderedTextEnd
  0025b	83 c4 08	 add	 esp, 8
  0025e	50		 push	 eax
  0025f	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00262	51		 push	 ecx
  00263	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  00268	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2208 :     EndGroup();

  0026b	e8 00 00 00 00	 call	 ?EndGroup@ImGui@@YAXXZ	; ImGui::EndGroup

; 2209 :     PopID();

  00270	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 2210 :     return value_changed;

  00275	8a 45 e3	 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@DragFloatR:

; 2211 : }

  00278	5f		 pop	 edi
  00279	5e		 pop	 esi
  0027a	5b		 pop	 ebx
  0027b	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00281	3b ec		 cmp	 ebp, esp
  00283	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z ENDP	; ImGui::DragFloatRange2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z PROC		; ImGui::DragFloat4, COMDAT

; 2185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2186 :     return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	51		 push	 ecx
  00040	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	6a 04		 push	 4
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0004f	50		 push	 eax
  00050	6a 08		 push	 8
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z ; ImGui::DragScalarN
  0005b	83 c4 24	 add	 esp, 36			; 00000024H

; 2187 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z ENDP		; ImGui::DragFloat4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z PROC		; ImGui::DragFloat3, COMDAT

; 2180 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2181 :     return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	51		 push	 ecx
  00040	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	6a 03		 push	 3
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0004f	50		 push	 eax
  00050	6a 08		 push	 8
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z ; ImGui::DragScalarN
  0005b	83 c4 24	 add	 esp, 36			; 00000024H

; 2182 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z ENDP		; ImGui::DragFloat3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z PROC		; ImGui::DragFloat2, COMDAT

; 2175 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2176 :     return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	51		 push	 ecx
  00040	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	6a 02		 push	 2
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0004f	50		 push	 eax
  00050	6a 08		 push	 8
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?DragScalarN@ImGui@@YA_NPBDHPAXHMPBX20M@Z ; ImGui::DragScalarN
  0005b	83 c4 24	 add	 esp, 36			; 00000024H

; 2177 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z ENDP		; ImGui::DragFloat2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_format$ = 28						; size = 4
_power$ = 32						; size = 4
?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z PROC		; ImGui::DragFloat, COMDAT

; 2170 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2171 :     return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);

  00028	51		 push	 ecx
  00029	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _power$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 1c	 mov	 eax, DWORD PTR _format$[ebp]
  00036	50		 push	 eax
  00037	8d 4d 18	 lea	 ecx, DWORD PTR _v_max$[ebp]
  0003a	51		 push	 ecx
  0003b	8d 55 14	 lea	 edx, DWORD PTR _v_min$[ebp]
  0003e	52		 push	 edx
  0003f	51		 push	 ecx
  00040	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _v_speed$[ebp]
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0004d	50		 push	 eax
  0004e	6a 08		 push	 8
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ?DragScalar@ImGui@@YA_NPBDHPAXMPBX20M@Z ; ImGui::DragScalar
  00059	83 c4 20	 add	 esp, 32			; 00000020H

; 2172 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z ENDP		; ImGui::DragFloat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z
_TEXT	SEGMENT
tv130 = -317						; size = 1
$T1 = -312						; size = 8
$T2 = -296						; size = 8
$T3 = -280						; size = 8
_item_text$4 = -72					; size = 4
_item_selected$5 = -57					; size = 1
_i$6 = -48						; size = 4
_value_changed$ = -33					; size = 1
_preview_value$ = -24					; size = 4
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items_getter$ = 16					; size = 4
_data$ = 20						; size = 4
_items_count$ = 24					; size = 4
_popup_max_height_in_items$ = 28			; size = 4
?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z PROC	; ImGui::Combo, COMDAT

; 1562 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-320]
  00012	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1563 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 1564 : 
; 1565 :     // Call the getter to obtain the preview string which is a parameter to BeginCombo()
; 1566 :     const char* preview_value = NULL;

  0003a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _preview_value$[ebp], 0

; 1567 :     if (*current_item >= 0 && *current_item < items_count)

  00041	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  00044	83 38 00	 cmp	 DWORD PTR [eax], 0
  00047	7c 27		 jl	 SHORT $LN5@Combo
  00049	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	3b 4d 18	 cmp	 ecx, DWORD PTR _items_count$[ebp]
  00051	7d 1d		 jge	 SHORT $LN5@Combo

; 1568 :         items_getter(data, *current_item, &preview_value);

  00053	8b f4		 mov	 esi, esp
  00055	8d 45 e8	 lea	 eax, DWORD PTR _preview_value$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _current_item$[ebp]
  0005c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005e	52		 push	 edx
  0005f	8b 45 14	 mov	 eax, DWORD PTR _data$[ebp]
  00062	50		 push	 eax
  00063	ff 55 10	 call	 DWORD PTR _items_getter$[ebp]
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@Combo:

; 1569 : 
; 1570 :     // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
; 1571 :     if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint))

  00070	83 7d 1c ff	 cmp	 DWORD PTR _popup_max_height_in_items$[ebp], -1
  00074	74 5e		 je	 SHORT $LN6@Combo
  00076	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  00079	8b 88 2c 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6700]
  0007f	83 e1 10	 and	 ecx, 16			; 00000010H
  00082	75 50		 jne	 SHORT $LN6@Combo

; 1572 :         SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	8b 45 1c	 mov	 eax, DWORD PTR _popup_max_height_in_items$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?CalcMaxPopupHeightFromItemCount@@YAMH@Z ; CalcMaxPopupHeightFromItemCount
  00091	d9 1c 24	 fstp	 DWORD PTR [esp]
  00094	51		 push	 ecx
  00095	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  0009d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a2	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000a8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ad	50		 push	 eax
  000ae	51		 push	 ecx
  000af	0f 57 c0	 xorps	 xmm0, xmm0
  000b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b7	51		 push	 ecx
  000b8	0f 57 c0	 xorps	 xmm0, xmm0
  000bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c0	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000c6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@Combo:

; 1573 : 
; 1574 :     if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))

  000d4	6a 00		 push	 0
  000d6	8b 45 e8	 mov	 eax, DWORD PTR _preview_value$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?BeginCombo@ImGui@@YA_NPBD0H@Z ; ImGui::BeginCombo
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	0f b6 d0	 movzx	 edx, al
  000e9	85 d2		 test	 edx, edx
  000eb	75 07		 jne	 SHORT $LN7@Combo

; 1575 :         return false;

  000ed	32 c0		 xor	 al, al
  000ef	e9 dd 00 00 00	 jmp	 $LN1@Combo
$LN7@Combo:

; 1576 : 
; 1577 :     // Display items
; 1578 :     // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
; 1579 :     bool value_changed = false;

  000f4	c6 45 df 00	 mov	 BYTE PTR _value_changed$[ebp], 0

; 1580 :     for (int i = 0; i < items_count; i++)

  000f8	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  000ff	eb 09		 jmp	 SHORT $LN4@Combo
$LN2@Combo:
  00101	8b 45 d0	 mov	 eax, DWORD PTR _i$6[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 d0	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@Combo:
  0010a	8b 45 d0	 mov	 eax, DWORD PTR _i$6[ebp]
  0010d	3b 45 18	 cmp	 eax, DWORD PTR _items_count$[ebp]
  00110	0f 8d b3 00 00
	00		 jge	 $LN3@Combo

; 1581 :     {
; 1582 :         PushID((void*)(intptr_t)i);

  00116	8b 45 d0	 mov	 eax, DWORD PTR _i$6[ebp]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBX@Z	; ImGui::PushID
  0011f	83 c4 04	 add	 esp, 4

; 1583 :         const bool item_selected = (i == *current_item);

  00122	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  00125	8b 4d d0	 mov	 ecx, DWORD PTR _i$6[ebp]
  00128	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0012a	75 09		 jne	 SHORT $LN12@Combo
  0012c	c6 85 c3 fe ff
	ff 01		 mov	 BYTE PTR tv130[ebp], 1
  00133	eb 07		 jmp	 SHORT $LN13@Combo
$LN12@Combo:
  00135	c6 85 c3 fe ff
	ff 00		 mov	 BYTE PTR tv130[ebp], 0
$LN13@Combo:
  0013c	8a 95 c3 fe ff
	ff		 mov	 dl, BYTE PTR tv130[ebp]
  00142	88 55 c7	 mov	 BYTE PTR _item_selected$5[ebp], dl

; 1584 :         const char* item_text;
; 1585 :         if (!items_getter(data, i, &item_text))

  00145	8b f4		 mov	 esi, esp
  00147	8d 45 b8	 lea	 eax, DWORD PTR _item_text$4[ebp]
  0014a	50		 push	 eax
  0014b	8b 4d d0	 mov	 ecx, DWORD PTR _i$6[ebp]
  0014e	51		 push	 ecx
  0014f	8b 55 14	 mov	 edx, DWORD PTR _data$[ebp]
  00152	52		 push	 edx
  00153	ff 55 10	 call	 DWORD PTR _items_getter$[ebp]
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH
  00159	3b f4		 cmp	 esi, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00160	0f b6 c0	 movzx	 eax, al
  00163	85 c0		 test	 eax, eax
  00165	75 07		 jne	 SHORT $LN8@Combo

; 1586 :             item_text = "*Unknown item*";

  00167	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _item_text$4[ebp], OFFSET ??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
$LN8@Combo:

; 1587 :         if (Selectable(item_text, item_selected))

  0016e	51		 push	 ecx
  0016f	0f 57 c0	 xorps	 xmm0, xmm0
  00172	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00177	51		 push	 ecx
  00178	0f 57 c0	 xorps	 xmm0, xmm0
  0017b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00180	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00186	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0018b	50		 push	 eax
  0018c	6a 00		 push	 0
  0018e	0f b6 45 c7	 movzx	 eax, BYTE PTR _item_selected$5[ebp]
  00192	50		 push	 eax
  00193	8b 4d b8	 mov	 ecx, DWORD PTR _item_text$4[ebp]
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
  0019c	83 c4 10	 add	 esp, 16			; 00000010H
  0019f	0f b6 d0	 movzx	 edx, al
  001a2	85 d2		 test	 edx, edx
  001a4	74 0c		 je	 SHORT $LN9@Combo

; 1588 :         {
; 1589 :             value_changed = true;

  001a6	c6 45 df 01	 mov	 BYTE PTR _value_changed$[ebp], 1

; 1590 :             *current_item = i;

  001aa	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  001ad	8b 4d d0	 mov	 ecx, DWORD PTR _i$6[ebp]
  001b0	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@Combo:

; 1591 :         }
; 1592 :         if (item_selected)

  001b2	0f b6 45 c7	 movzx	 eax, BYTE PTR _item_selected$5[ebp]
  001b6	85 c0		 test	 eax, eax
  001b8	74 05		 je	 SHORT $LN10@Combo

; 1593 :             SetItemDefaultFocus();

  001ba	e8 00 00 00 00	 call	 ?SetItemDefaultFocus@ImGui@@YAXXZ ; ImGui::SetItemDefaultFocus
$LN10@Combo:

; 1594 :         PopID();

  001bf	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 1595 :     }

  001c4	e9 38 ff ff ff	 jmp	 $LN2@Combo
$LN3@Combo:

; 1596 : 
; 1597 :     EndCombo();

  001c9	e8 00 00 00 00	 call	 ?EndCombo@ImGui@@YAXXZ	; ImGui::EndCombo

; 1598 :     return value_changed;

  001ce	8a 45 df	 mov	 al, BYTE PTR _value_changed$[ebp]
$LN1@Combo:

; 1599 : }

  001d1	52		 push	 edx
  001d2	8b cd		 mov	 ecx, ebp
  001d4	50		 push	 eax
  001d5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@Combo
  001db	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001e0	58		 pop	 eax
  001e1	5a		 pop	 edx
  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e8	33 cd		 xor	 ecx, ebp
  001ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ef	81 c4 40 01 00
	00		 add	 esp, 320		; 00000140H
  001f5	3b ec		 cmp	 ebp, esp
  001f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c3		 ret	 0
$LN17@Combo:
  00200	02 00 00 00	 DD	 2
  00204	00 00 00 00	 DD	 $LN16@Combo
$LN16@Combo:
  00208	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0020c	04 00 00 00	 DD	 4
  00210	00 00 00 00	 DD	 $LN14@Combo
  00214	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00218	04 00 00 00	 DD	 4
  0021c	00 00 00 00	 DD	 $LN15@Combo
$LN15@Combo:
  00220	69		 DB	 105			; 00000069H
  00221	74		 DB	 116			; 00000074H
  00222	65		 DB	 101			; 00000065H
  00223	6d		 DB	 109			; 0000006dH
  00224	5f		 DB	 95			; 0000005fH
  00225	74		 DB	 116			; 00000074H
  00226	65		 DB	 101			; 00000065H
  00227	78		 DB	 120			; 00000078H
  00228	74		 DB	 116			; 00000074H
  00229	00		 DB	 0
$LN14@Combo:
  0022a	70		 DB	 112			; 00000070H
  0022b	72		 DB	 114			; 00000072H
  0022c	65		 DB	 101			; 00000065H
  0022d	76		 DB	 118			; 00000076H
  0022e	69		 DB	 105			; 00000069H
  0022f	65		 DB	 101			; 00000065H
  00230	77		 DB	 119			; 00000077H
  00231	5f		 DB	 95			; 0000005fH
  00232	76		 DB	 118			; 00000076H
  00233	61		 DB	 97			; 00000061H
  00234	6c		 DB	 108			; 0000006cH
  00235	75		 DB	 117			; 00000075H
  00236	65		 DB	 101			; 00000065H
  00237	00		 DB	 0
?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ENDP	; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Combo@ImGui@@YA_NPBDPAH0H@Z
_TEXT	SEGMENT
_value_changed$ = -29					; size = 1
_p$ = -20						; size = 4
_items_count$ = -8					; size = 4
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items_separated_by_zeros$ = 16				; size = 4
_height_in_items$ = 20					; size = 4
?Combo@ImGui@@YA_NPBDPAH0H@Z PROC			; ImGui::Combo, COMDAT

; 1610 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1611 :     int items_count = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _items_count$[ebp], 0

; 1612 :     const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open

  0002f	8b 45 10	 mov	 eax, DWORD PTR _items_separated_by_zeros$[ebp]
  00032	89 45 ec	 mov	 DWORD PTR _p$[ebp], eax
$LN2@Combo:

; 1613 :     while (*p)

  00035	8b 45 ec	 mov	 eax, DWORD PTR _p$[ebp]
  00038	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 21		 je	 SHORT $LN3@Combo

; 1614 :     {
; 1615 :         p += strlen(p) + 1;

  0003f	8b 45 ec	 mov	 eax, DWORD PTR _p$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _strlen
  00048	83 c4 04	 add	 esp, 4
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  0004e	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00052	89 55 ec	 mov	 DWORD PTR _p$[ebp], edx

; 1616 :         items_count++;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _items_count$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f8	 mov	 DWORD PTR _items_count$[ebp], eax

; 1617 :     }

  0005e	eb d5		 jmp	 SHORT $LN2@Combo
$LN3@Combo:

; 1618 :     bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);

  00060	8b 45 14	 mov	 eax, DWORD PTR _height_in_items$[ebp]
  00063	50		 push	 eax
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _items_count$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 10	 mov	 edx, DWORD PTR _items_separated_by_zeros$[ebp]
  0006b	52		 push	 edx
  0006c	68 00 00 00 00	 push	 OFFSET ?Items_SingleStringGetter@@YA_NPAXHPAPBD@Z ; Items_SingleStringGetter
  00071	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  00074	50		 push	 eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ; ImGui::Combo
  0007e	83 c4 18	 add	 esp, 24			; 00000018H
  00081	88 45 e3	 mov	 BYTE PTR _value_changed$[ebp], al

; 1619 :     return value_changed;

  00084	8a 45 e3	 mov	 al, BYTE PTR _value_changed$[ebp]

; 1620 : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?Combo@ImGui@@YA_NPBDPAH0H@Z ENDP			; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Combo@ImGui@@YA_NPBDPAHQBQBDHH@Z
_TEXT	SEGMENT
_value_changed$ = -5					; size = 1
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items$ = 16						; size = 4
_items_count$ = 20					; size = 4
_height_in_items$ = 24					; size = 4
?Combo@ImGui@@YA_NPBDPAHQBQBDHH@Z PROC			; ImGui::Combo, COMDAT

; 1603 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1604 :     const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);

  00028	8b 45 18	 mov	 eax, DWORD PTR _height_in_items$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 14	 mov	 ecx, DWORD PTR _items_count$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 10	 mov	 edx, DWORD PTR _items$[ebp]
  00033	52		 push	 edx
  00034	68 00 00 00 00	 push	 OFFSET ?Items_ArrayGetter@@YA_NPAXHPAPBD@Z ; Items_ArrayGetter
  00039	8b 45 0c	 mov	 eax, DWORD PTR _current_item$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ; ImGui::Combo
  00046	83 c4 18	 add	 esp, 24			; 00000018H
  00049	88 45 fb	 mov	 BYTE PTR _value_changed$[ebp], al

; 1605 :     return value_changed;

  0004c	8a 45 fb	 mov	 al, BYTE PTR _value_changed$[ebp]

; 1606 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?Combo@ImGui@@YA_NPBDPAHQBQBDHH@Z ENDP			; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?EndCombo@ImGui@@YAXXZ
_TEXT	SEGMENT
?EndCombo@ImGui@@YAXXZ PROC				; ImGui::EndCombo, COMDAT

; 1526 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1527 :     EndPopup();

  00028	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup

; 1528 : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?EndCombo@ImGui@@YAXXZ ENDP				; ImGui::EndCombo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BeginCombo@ImGui@@YA_NPBD0H@Z
_TEXT	SEGMENT
tv267 = -1032						; size = 4
tv259 = -1032						; size = 4
tv208 = -1032						; size = 4
tv193 = -1032						; size = 4
tv165 = -1032						; size = 4
tv135 = -1032						; size = 4
tv94 = -1032						; size = 4
tv68 = -1032						; size = 4
$T1 = -1024						; size = 8
$T2 = -1008						; size = 8
$T3 = -992						; size = 8
$T4 = -976						; size = 8
$T5 = -960						; size = 8
$T6 = -944						; size = 8
$T7 = -928						; size = 8
$T8 = -912						; size = 8
$T9 = -896						; size = 8
$T10 = -880						; size = 8
$T11 = -864						; size = 8
$T12 = -848						; size = 8
$T13 = -832						; size = 8
$T14 = -816						; size = 8
$T15 = -800						; size = 8
$T16 = -784						; size = 8
_ret$ = -381						; size = 1
_window_flags$ = -372					; size = 4
_pos$17 = -360						; size = 8
_r_outer$18 = -344					; size = 16
_size_expected$19 = -320				; size = 8
_popup_window$20 = -304					; size = 4
_name$ = -292						; size = 16
_popup_max_height_in_items$21 = -268			; size = 4
_text_col$22 = -256					; size = 4
_bg_col$23 = -244					; size = 4
_value_x2$ = -232					; size = 4
_frame_col$ = -220					; size = 4
_popup_open$ = -205					; size = 1
_pressed$ = -193					; size = 1
_held$ = -181						; size = 1
_hovered$ = -169					; size = 1
_total_bb$ = -160					; size = 16
_frame_bb$ = -136					; size = 16
_w$ = -112						; size = 4
_expected_w$ = -100					; size = 4
_label_size$ = -88					; size = 8
_arrow_size$ = -72					; size = 4
_id$ = -60						; size = 4
_style$ = -48						; size = 4
_window$ = -36						; size = 4
_has_window_size_constraint$ = -21			; size = 1
_g$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_preview_value$ = 12					; size = 4
_flags$ = 16						; size = 4
?BeginCombo@ImGui@@YA_NPBD0H@Z PROC			; ImGui::BeginCombo, COMDAT

; 1418 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1032]
  00012	b9 02 01 00 00	 mov	 ecx, 258		; 00000102H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1419 :     // Always consume the SetNextWindowSizeConstraint() call in our early return paths
; 1420 :     ImGuiContext& g = *GImGui;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00037	89 45 f4	 mov	 DWORD PTR _g$[ebp], eax

; 1421 :     bool has_window_size_constraint = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint) != 0;

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0003d	8b 88 2c 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6700]
  00043	83 e1 10	 and	 ecx, 16			; 00000010H
  00046	74 0c		 je	 SHORT $LN26@BeginCombo
  00048	c7 85 f8 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
  00052	eb 0a		 jmp	 SHORT $LN27@BeginCombo
$LN26@BeginCombo:
  00054	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN27@BeginCombo:
  0005e	8a 95 f8 fb ff
	ff		 mov	 dl, BYTE PTR tv68[ebp]
  00064	88 55 eb	 mov	 BYTE PTR _has_window_size_constraint$[ebp], dl

; 1422 :     g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint;

  00067	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0006a	8b 88 2c 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6700]
  00070	83 e1 ef	 and	 ecx, -17		; ffffffefH
  00073	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  00076	89 8a 2c 1a 00
	00		 mov	 DWORD PTR [edx+6700], ecx

; 1423 : 
; 1424 :     ImGuiWindow* window = GetCurrentWindow();

  0007c	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00081	89 45 dc	 mov	 DWORD PTR _window$[ebp], eax

; 1425 :     if (window->SkipItems)

  00084	8b 45 dc	 mov	 eax, DWORD PTR _window$[ebp]
  00087	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 07		 je	 SHORT $LN2@BeginCombo

; 1426 :         return false;

  0008f	32 c0		 xor	 al, al
  00091	e9 fb 08 00 00	 jmp	 $LN1@BeginCombo
$LN2@BeginCombo:

; 1427 : 
; 1428 :     IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

  00096	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00099	83 e0 60	 and	 eax, 96			; 00000060H
  0009c	83 f8 60	 cmp	 eax, 96			; 00000060H
  0009f	75 26		 jne	 SHORT $LN28@BeginCombo
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??BeginCombo@ImGui@@YA_NPBD0H@Z@4JA
  000a7	83 c1 0a	 add	 ecx, 10			; 0000000aH
  000aa	8b f4		 mov	 esi, esp
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_1BAK@ONBANIIG@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AAI?$AAm?$AAG?$AAu?$AAi@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN28@BeginCombo:

; 1429 : 
; 1430 :     const ImGuiStyle& style = g.Style;

  000c7	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  000ca	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  000cf	89 45 d0	 mov	 DWORD PTR _style$[ebp], eax

; 1431 :     const ImGuiID id = window->GetID(label);

  000d2	6a 00		 push	 0
  000d4	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d dc	 mov	 ecx, DWORD PTR _window$[ebp]
  000db	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  000e0	89 45 c4	 mov	 DWORD PTR _id$[ebp], eax

; 1432 : 
; 1433 :     const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();

  000e3	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  000e6	83 e0 20	 and	 eax, 32			; 00000020H
  000e9	74 0d		 je	 SHORT $LN29@BeginCombo
  000eb	0f 57 c0	 xorps	 xmm0, xmm0
  000ee	f3 0f 11 85 f8
	fb ff ff	 movss	 DWORD PTR tv94[ebp], xmm0
  000f6	eb 0b		 jmp	 SHORT $LN30@BeginCombo
$LN29@BeginCombo:
  000f8	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  000fd	d9 9d f8 fb ff
	ff		 fstp	 DWORD PTR tv94[ebp]
$LN30@BeginCombo:
  00103	f3 0f 10 85 f8
	fb ff ff	 movss	 xmm0, DWORD PTR tv94[ebp]
  0010b	f3 0f 11 45 b8	 movss	 DWORD PTR _arrow_size$[ebp], xmm0

; 1434 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  00110	51		 push	 ecx
  00111	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00119	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011e	6a 01		 push	 1
  00120	6a 00		 push	 0
  00122	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00125	50		 push	 eax
  00126	8d 4d a8	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0012f	83 c4 14	 add	 esp, 20			; 00000014H

; 1435 :     const float expected_w = CalcItemWidth();

  00132	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00137	d9 5d 9c	 fstp	 DWORD PTR _expected_w$[ebp]

; 1436 :     const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : expected_w;

  0013a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0013d	83 e0 40	 and	 eax, 64			; 00000040H
  00140	74 0f		 je	 SHORT $LN31@BeginCombo
  00142	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _arrow_size$[ebp]
  00147	f3 0f 11 85 f8
	fb ff ff	 movss	 DWORD PTR tv135[ebp], xmm0
  0014f	eb 0d		 jmp	 SHORT $LN32@BeginCombo
$LN31@BeginCombo:
  00151	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _expected_w$[ebp]
  00156	f3 0f 11 85 f8
	fb ff ff	 movss	 DWORD PTR tv135[ebp], xmm0
$LN32@BeginCombo:
  0015e	f3 0f 10 85 f8
	fb ff ff	 movss	 xmm0, DWORD PTR tv135[ebp]
  00166	f3 0f 11 45 90	 movss	 DWORD PTR _w$[ebp], xmm0

; 1437 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

  0016b	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0016e	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00173	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0017b	f3 0f 58 45 ac	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  00180	51		 push	 ecx
  00181	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00186	51		 push	 ecx
  00187	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _w$[ebp]
  0018c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00191	8d 8d f0 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00197	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0019c	50		 push	 eax
  0019d	8b 4d dc	 mov	 ecx, DWORD PTR _window$[ebp]
  001a0	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  001a6	51		 push	 ecx
  001a7	8d 95 e0 fc ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  001ad	52		 push	 edx
  001ae	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b6	50		 push	 eax
  001b7	8b 45 dc	 mov	 eax, DWORD PTR _window$[ebp]
  001ba	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  001bf	50		 push	 eax
  001c0	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  001c6	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1438 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

  001cb	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  001d0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  001d7	76 17		 jbe	 SHORT $LN33@BeginCombo
  001d9	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  001dc	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  001e1	f3 0f 58 45 a8	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  001e6	f3 0f 11 85 f8
	fb ff ff	 movss	 DWORD PTR tv165[ebp], xmm0
  001ee	eb 0b		 jmp	 SHORT $LN34@BeginCombo
$LN33@BeginCombo:
  001f0	0f 57 c0	 xorps	 xmm0, xmm0
  001f3	f3 0f 11 85 f8
	fb ff ff	 movss	 DWORD PTR tv165[ebp], xmm0
$LN34@BeginCombo:
  001fb	51		 push	 ecx
  001fc	0f 57 c0	 xorps	 xmm0, xmm0
  001ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00204	51		 push	 ecx
  00205	f3 0f 10 85 f8
	fb ff ff	 movss	 xmm0, DWORD PTR tv165[ebp]
  0020d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00212	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00218	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0021d	50		 push	 eax
  0021e	8d 4d 80	 lea	 ecx, DWORD PTR _frame_bb$[ebp+8]
  00221	51		 push	 ecx
  00222	8d 95 c0 fc ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  00228	52		 push	 edx
  00229	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0022e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00231	50		 push	 eax
  00232	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00238	50		 push	 eax
  00239	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  0023f	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1439 :     ItemSize(total_bb, style.FramePadding.y);

  00244	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  00247	51		 push	 ecx
  00248	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0024d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00252	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00258	51		 push	 ecx
  00259	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  0025e	83 c4 08	 add	 esp, 8

; 1440 :     if (!ItemAdd(total_bb, id, &frame_bb))

  00261	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00267	50		 push	 eax
  00268	8b 4d c4	 mov	 ecx, DWORD PTR _id$[ebp]
  0026b	51		 push	 ecx
  0026c	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _total_bb$[ebp]
  00272	52		 push	 edx
  00273	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00278	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027b	0f b6 c0	 movzx	 eax, al
  0027e	85 c0		 test	 eax, eax
  00280	75 07		 jne	 SHORT $LN3@BeginCombo

; 1441 :         return false;

  00282	32 c0		 xor	 al, al
  00284	e9 08 07 00 00	 jmp	 $LN1@BeginCombo
$LN3@BeginCombo:

; 1442 : 
; 1443 :     bool hovered, held;
; 1444 :     bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);

  00289	6a 00		 push	 0
  0028b	8d 85 4b ff ff
	ff		 lea	 eax, DWORD PTR _held$[ebp]
  00291	50		 push	 eax
  00292	8d 8d 57 ff ff
	ff		 lea	 ecx, DWORD PTR _hovered$[ebp]
  00298	51		 push	 ecx
  00299	8b 55 c4	 mov	 edx, DWORD PTR _id$[ebp]
  0029c	52		 push	 edx
  0029d	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  002a3	50		 push	 eax
  002a4	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  002a9	83 c4 14	 add	 esp, 20			; 00000014H
  002ac	88 85 3f ff ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 1445 :     bool popup_open = IsPopupOpen(id);

  002b2	8b 45 c4	 mov	 eax, DWORD PTR _id$[ebp]
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 ?IsPopupOpen@ImGui@@YA_NI@Z ; ImGui::IsPopupOpen
  002bb	83 c4 04	 add	 esp, 4
  002be	88 85 33 ff ff
	ff		 mov	 BYTE PTR _popup_open$[ebp], al

; 1446 : 
; 1447 :     const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

  002c4	0f b6 85 57 ff
	ff ff		 movzx	 eax, BYTE PTR _hovered$[ebp]
  002cb	85 c0		 test	 eax, eax
  002cd	74 0c		 je	 SHORT $LN35@BeginCombo
  002cf	c7 85 f8 fb ff
	ff 08 00 00 00	 mov	 DWORD PTR tv193[ebp], 8
  002d9	eb 0a		 jmp	 SHORT $LN36@BeginCombo
$LN35@BeginCombo:
  002db	c7 85 f8 fb ff
	ff 07 00 00 00	 mov	 DWORD PTR tv193[ebp], 7
$LN36@BeginCombo:
  002e5	51		 push	 ecx
  002e6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f3	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR tv193[ebp]
  002f9	51		 push	 ecx
  002fa	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  002ff	83 c4 08	 add	 esp, 8
  00302	89 85 24 ff ff
	ff		 mov	 DWORD PTR _frame_col$[ebp], eax

; 1448 :     const float value_x2 = ImMax(frame_bb.Min.x, frame_bb.Max.x - arrow_size);

  00308	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  0030d	f3 0f 5c 45 b8	 subss	 xmm0, DWORD PTR _arrow_size$[ebp]
  00312	51		 push	 ecx
  00313	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00318	51		 push	 ecx
  00319	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp]
  00321	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00326	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0032b	83 c4 08	 add	 esp, 8
  0032e	d9 9d 18 ff ff
	ff		 fstp	 DWORD PTR _value_x2$[ebp]

; 1449 :     RenderNavHighlight(frame_bb, id);

  00334	6a 01		 push	 1
  00336	8b 45 c4	 mov	 eax, DWORD PTR _id$[ebp]
  00339	50		 push	 eax
  0033a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  00340	51		 push	 ecx
  00341	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  00346	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1450 :     if (!(flags & ImGuiComboFlags_NoPreview))

  00349	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0034c	83 e0 40	 and	 eax, 64			; 00000040H
  0034f	75 74		 jne	 SHORT $LN4@BeginCombo

; 1451 :         window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(value_x2, frame_bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Left);

  00351	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00354	83 e0 20	 and	 eax, 32			; 00000020H
  00357	74 0c		 je	 SHORT $LN37@BeginCombo
  00359	c7 85 f8 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR tv208[ebp], 15 ; 0000000fH
  00363	eb 0a		 jmp	 SHORT $LN38@BeginCombo
$LN37@BeginCombo:
  00365	c7 85 f8 fb ff
	ff 05 00 00 00	 mov	 DWORD PTR tv208[ebp], 5
$LN38@BeginCombo:
  0036f	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR tv208[ebp]
  00375	51		 push	 ecx
  00376	8b 55 d0	 mov	 edx, DWORD PTR _style$[ebp]
  00379	51		 push	 ecx
  0037a	f3 0f 10 42 40	 movss	 xmm0, DWORD PTR [edx+64]
  0037f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00384	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _frame_col$[ebp]
  0038a	50		 push	 eax
  0038b	51		 push	 ecx
  0038c	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+12]
  00391	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00396	51		 push	 ecx
  00397	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _value_x2$[ebp]
  0039f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a4	8d 8d b0 fc ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  003aa	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003af	50		 push	 eax
  003b0	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  003b6	51		 push	 ecx
  003b7	8b 55 dc	 mov	 edx, DWORD PTR _window$[ebp]
  003ba	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  003c0	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN4@BeginCombo:

; 1452 :     if (!(flags & ImGuiComboFlags_NoArrowButton))

  003c5	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  003c8	83 e0 20	 and	 eax, 32			; 00000020H
  003cb	0f 85 6a 01 00
	00		 jne	 $LN6@BeginCombo

; 1453 :     {
; 1454 :         ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

  003d1	0f b6 85 33 ff
	ff ff		 movzx	 eax, BYTE PTR _popup_open$[ebp]
  003d8	85 c0		 test	 eax, eax
  003da	75 17		 jne	 SHORT $LN39@BeginCombo
  003dc	0f b6 8d 57 ff
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  003e3	85 c9		 test	 ecx, ecx
  003e5	75 0c		 jne	 SHORT $LN39@BeginCombo
  003e7	c7 85 f8 fb ff
	ff 15 00 00 00	 mov	 DWORD PTR tv259[ebp], 21 ; 00000015H
  003f1	eb 0a		 jmp	 SHORT $LN40@BeginCombo
$LN39@BeginCombo:
  003f3	c7 85 f8 fb ff
	ff 16 00 00 00	 mov	 DWORD PTR tv259[ebp], 22 ; 00000016H
$LN40@BeginCombo:
  003fd	51		 push	 ecx
  003fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00406	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0040b	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR tv259[ebp]
  00411	52		 push	 edx
  00412	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00417	83 c4 08	 add	 esp, 8
  0041a	89 85 0c ff ff
	ff		 mov	 DWORD PTR _bg_col$23[ebp], eax

; 1455 :         ImU32 text_col = GetColorU32(ImGuiCol_Text);

  00420	51		 push	 ecx
  00421	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00429	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0042e	6a 00		 push	 0
  00430	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00435	83 c4 08	 add	 esp, 8
  00438	89 85 00 ff ff
	ff		 mov	 DWORD PTR _text_col$22[ebp], eax

; 1456 :         window->DrawList->AddRectFilled(ImVec2(value_x2, frame_bb.Min.y), frame_bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);

  0043e	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _arrow_size$[ebp]
  00443	0f 2f 45 90	 comiss	 xmm0, DWORD PTR _w$[ebp]
  00447	72 0c		 jb	 SHORT $LN41@BeginCombo
  00449	c7 85 f8 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR tv267[ebp], 15 ; 0000000fH
  00453	eb 0a		 jmp	 SHORT $LN42@BeginCombo
$LN41@BeginCombo:
  00455	c7 85 f8 fb ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv267[ebp], 10 ; 0000000aH
$LN42@BeginCombo:
  0045f	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR tv267[ebp]
  00465	50		 push	 eax
  00466	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  00469	51		 push	 ecx
  0046a	f3 0f 10 41 40	 movss	 xmm0, DWORD PTR [ecx+64]
  0046f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00474	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _bg_col$23[ebp]
  0047a	52		 push	 edx
  0047b	8d 45 80	 lea	 eax, DWORD PTR _frame_bb$[ebp+8]
  0047e	50		 push	 eax
  0047f	51		 push	 ecx
  00480	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  00488	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0048d	51		 push	 ecx
  0048e	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _value_x2$[ebp]
  00496	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0049b	8d 8d a0 fc ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  004a1	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  004a6	50		 push	 eax
  004a7	8b 4d dc	 mov	 ecx, DWORD PTR _window$[ebp]
  004aa	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  004b0	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1457 :         if (value_x2 + arrow_size - style.FramePadding.x <= frame_bb.Max.x)

  004b5	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _value_x2$[ebp]
  004bd	f3 0f 58 45 b8	 addss	 xmm0, DWORD PTR _arrow_size$[ebp]
  004c2	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  004c5	f3 0f 5c 40 38	 subss	 xmm0, DWORD PTR [eax+56]
  004ca	f3 0f 10 4d 80	 movss	 xmm1, DWORD PTR _frame_bb$[ebp+8]
  004cf	0f 2f c8	 comiss	 xmm1, xmm0
  004d2	72 67		 jb	 SHORT $LN6@BeginCombo

; 1458 :             RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f);

  004d4	51		 push	 ecx
  004d5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e2	6a 03		 push	 3
  004e4	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _text_col$22[ebp]
  004ea	50		 push	 eax
  004eb	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  004ee	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  004f6	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  004fb	51		 push	 ecx
  004fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00501	8b 55 d0	 mov	 edx, DWORD PTR _style$[ebp]
  00504	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _value_x2$[ebp]
  0050c	f3 0f 58 42 3c	 addss	 xmm0, DWORD PTR [edx+60]
  00511	51		 push	 ecx
  00512	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00517	8d 8d 90 fc ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0051d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00522	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00525	51		 push	 ecx
  00526	8b 10		 mov	 edx, DWORD PTR [eax]
  00528	52		 push	 edx
  00529	8b 45 dc	 mov	 eax, DWORD PTR _window$[ebp]
  0052c	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00532	51		 push	 ecx
  00533	e8 00 00 00 00	 call	 ?RenderArrow@ImGui@@YAXPAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
  00538	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@BeginCombo:

; 1459 :     }
; 1460 :     RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);

  0053b	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  0053e	51		 push	 ecx
  0053f	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00544	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00549	8b 4d 84	 mov	 ecx, DWORD PTR _frame_bb$[ebp+12]
  0054c	51		 push	 ecx
  0054d	8b 55 80	 mov	 edx, DWORD PTR _frame_bb$[ebp+8]
  00550	52		 push	 edx
  00551	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _frame_bb$[ebp+4]
  00557	50		 push	 eax
  00558	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _frame_bb$[ebp]
  0055e	51		 push	 ecx
  0055f	e8 00 00 00 00	 call	 ?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
  00564	83 c4 14	 add	 esp, 20			; 00000014H

; 1461 :     if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))

  00567	83 7d 0c 00	 cmp	 DWORD PTR _preview_value$[ebp], 0
  0056b	74 7b		 je	 SHORT $LN7@BeginCombo
  0056d	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00570	83 e0 40	 and	 eax, 64			; 00000040H
  00573	75 73		 jne	 SHORT $LN7@BeginCombo

; 1462 :         RenderTextClipped(frame_bb.Min + style.FramePadding, ImVec2(value_x2, frame_bb.Max.y), preview_value, NULL, NULL, ImVec2(0.0f,0.0f));

  00575	6a 00		 push	 0
  00577	51		 push	 ecx
  00578	0f 57 c0	 xorps	 xmm0, xmm0
  0057b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00580	51		 push	 ecx
  00581	0f 57 c0	 xorps	 xmm0, xmm0
  00584	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00589	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0058f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00594	50		 push	 eax
  00595	6a 00		 push	 0
  00597	6a 00		 push	 0
  00599	8b 45 0c	 mov	 eax, DWORD PTR _preview_value$[ebp]
  0059c	50		 push	 eax
  0059d	51		 push	 ecx
  0059e	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+12]
  005a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a8	51		 push	 ecx
  005a9	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _value_x2$[ebp]
  005b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b6	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  005bc	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  005c1	50		 push	 eax
  005c2	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  005c5	83 c1 38	 add	 ecx, 56			; 00000038H
  005c8	51		 push	 ecx
  005c9	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _frame_bb$[ebp]
  005cf	52		 push	 edx
  005d0	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  005d6	50		 push	 eax
  005d7	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  005dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  005df	50		 push	 eax
  005e0	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  005e5	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN7@BeginCombo:

; 1463 :     if (label_size.x > 0)

  005e8	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  005ed	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  005f4	76 4b		 jbe	 SHORT $LN8@BeginCombo

; 1464 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

  005f6	6a 01		 push	 1
  005f8	6a 00		 push	 0
  005fa	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  005fd	50		 push	 eax
  005fe	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  00601	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+4]
  00609	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  0060e	51		 push	 ecx
  0060f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00614	8b 55 d0	 mov	 edx, DWORD PTR _style$[ebp]
  00617	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _frame_bb$[ebp+8]
  0061c	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  00621	51		 push	 ecx
  00622	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00627	8d 8d 50 fc ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0062d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00632	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00635	51		 push	 ecx
  00636	8b 10		 mov	 edx, DWORD PTR [eax]
  00638	52		 push	 edx
  00639	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  0063e	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@BeginCombo:

; 1465 : 
; 1466 :     if ((pressed || g.NavActivateId == id) && !popup_open)

  00641	0f b6 85 3f ff
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  00648	85 c0		 test	 eax, eax
  0064a	75 0e		 jne	 SHORT $LN10@BeginCombo
  0064c	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  0064f	8b 88 d8 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6872]
  00655	3b 4d c4	 cmp	 ecx, DWORD PTR _id$[ebp]
  00658	75 3f		 jne	 SHORT $LN9@BeginCombo
$LN10@BeginCombo:
  0065a	0f b6 85 33 ff
	ff ff		 movzx	 eax, BYTE PTR _popup_open$[ebp]
  00661	85 c0		 test	 eax, eax
  00663	75 34		 jne	 SHORT $LN9@BeginCombo

; 1467 :     {
; 1468 :         if (window->DC.NavLayerCurrent == 0)

  00665	8b 45 dc	 mov	 eax, DWORD PTR _window$[ebp]
  00668	83 b8 30 01 00
	00 00		 cmp	 DWORD PTR [eax+304], 0
  0066f	75 15		 jne	 SHORT $LN11@BeginCombo

; 1469 :             window->NavLastIds[0] = id;

  00671	b8 04 00 00 00	 mov	 eax, 4
  00676	6b c8 00	 imul	 ecx, eax, 0
  00679	8b 55 dc	 mov	 edx, DWORD PTR _window$[ebp]
  0067c	8b 45 c4	 mov	 eax, DWORD PTR _id$[ebp]
  0067f	89 84 0a 04 03
	00 00		 mov	 DWORD PTR [edx+ecx+772], eax
$LN11@BeginCombo:

; 1470 :         OpenPopupEx(id);

  00686	8b 45 c4	 mov	 eax, DWORD PTR _id$[ebp]
  00689	50		 push	 eax
  0068a	e8 00 00 00 00	 call	 ?OpenPopupEx@ImGui@@YAXI@Z ; ImGui::OpenPopupEx
  0068f	83 c4 04	 add	 esp, 4

; 1471 :         popup_open = true;

  00692	c6 85 33 ff ff
	ff 01		 mov	 BYTE PTR _popup_open$[ebp], 1
$LN9@BeginCombo:

; 1472 :     }
; 1473 : 
; 1474 :     if (!popup_open)

  00699	0f b6 85 33 ff
	ff ff		 movzx	 eax, BYTE PTR _popup_open$[ebp]
  006a0	85 c0		 test	 eax, eax
  006a2	75 07		 jne	 SHORT $LN12@BeginCombo

; 1475 :         return false;

  006a4	32 c0		 xor	 al, al
  006a6	e9 e6 02 00 00	 jmp	 $LN1@BeginCombo
$LN12@BeginCombo:

; 1476 : 
; 1477 :     if (has_window_size_constraint)

  006ab	0f b6 45 eb	 movzx	 eax, BYTE PTR _has_window_size_constraint$[ebp]
  006af	85 c0		 test	 eax, eax
  006b1	74 47		 je	 SHORT $LN13@BeginCombo

; 1478 :     {
; 1479 :         g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;

  006b3	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  006b6	8b 88 2c 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6700]
  006bc	83 c9 10	 or	 ecx, 16			; 00000010H
  006bf	8b 55 f4	 mov	 edx, DWORD PTR _g$[ebp]
  006c2	89 8a 2c 1a 00
	00		 mov	 DWORD PTR [edx+6700], ecx

; 1480 :         g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);

  006c8	51		 push	 ecx
  006c9	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _w$[ebp]
  006ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006d3	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  006d6	51		 push	 ecx
  006d7	f3 0f 10 80 60
	1a 00 00	 movss	 xmm0, DWORD PTR [eax+6752]
  006df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006e4	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  006e9	83 c4 08	 add	 esp, 8
  006ec	8b 4d f4	 mov	 ecx, DWORD PTR _g$[ebp]
  006ef	d9 99 60 1a 00
	00		 fstp	 DWORD PTR [ecx+6752]

; 1481 :     }

  006f5	e9 e6 00 00 00	 jmp	 $LN14@BeginCombo
$LN13@BeginCombo:

; 1482 :     else
; 1483 :     {
; 1484 :         if ((flags & ImGuiComboFlags_HeightMask_) == 0)

  006fa	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  006fd	83 e0 1e	 and	 eax, 30			; 0000001eH
  00700	75 09		 jne	 SHORT $LN15@BeginCombo

; 1485 :             flags |= ImGuiComboFlags_HeightRegular;

  00702	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00705	83 c8 04	 or	 eax, 4
  00708	89 45 10	 mov	 DWORD PTR _flags$[ebp], eax
$LN15@BeginCombo:

; 1486 :         IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one

  0070b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0070e	83 e0 1e	 and	 eax, 30			; 0000001eH
  00711	50		 push	 eax
  00712	e8 00 00 00 00	 call	 ?ImIsPowerOfTwo@@YA_NH@Z ; ImIsPowerOfTwo
  00717	83 c4 04	 add	 esp, 4
  0071a	0f b6 c8	 movzx	 ecx, al
  0071d	85 c9		 test	 ecx, ecx
  0071f	75 26		 jne	 SHORT $LN43@BeginCombo
  00721	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??BeginCombo@ImGui@@YA_NPBD0H@Z@4JA
  00727	83 c2 44	 add	 edx, 68			; 00000044H
  0072a	8b f4		 mov	 esi, esp
  0072c	52		 push	 edx
  0072d	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00732	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@IOEAHNLK@?$AAI?$AAm?$AAI?$AAs?$AAP?$AAo?$AAw?$AAe?$AAr?$AAO?$AAf?$AAT?$AAw?$AAo?$AA?$CI@
  00737	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0073d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00740	3b f4		 cmp	 esi, esp
  00742	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN43@BeginCombo:

; 1487 :         int popup_max_height_in_items = -1;

  00747	c7 85 f4 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _popup_max_height_in_items$21[ebp], -1

; 1488 :         if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;

  00751	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00754	83 e0 04	 and	 eax, 4
  00757	74 0c		 je	 SHORT $LN16@BeginCombo
  00759	c7 85 f4 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _popup_max_height_in_items$21[ebp], 8
  00763	eb 26		 jmp	 SHORT $LN20@BeginCombo
$LN16@BeginCombo:

; 1489 :         else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;

  00765	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  00768	83 e0 02	 and	 eax, 2
  0076b	74 0c		 je	 SHORT $LN18@BeginCombo
  0076d	c7 85 f4 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR _popup_max_height_in_items$21[ebp], 4
  00777	eb 12		 jmp	 SHORT $LN20@BeginCombo
$LN18@BeginCombo:

; 1490 :         else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;

  00779	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0077c	83 e0 08	 and	 eax, 8
  0077f	74 0a		 je	 SHORT $LN20@BeginCombo
  00781	c7 85 f4 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _popup_max_height_in_items$21[ebp], 20 ; 00000014H
$LN20@BeginCombo:

; 1491 :         SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

  0078b	6a 00		 push	 0
  0078d	6a 00		 push	 0
  0078f	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _popup_max_height_in_items$21[ebp]
  00795	50		 push	 eax
  00796	e8 00 00 00 00	 call	 ?CalcMaxPopupHeightFromItemCount@@YAMH@Z ; CalcMaxPopupHeightFromItemCount
  0079b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0079e	51		 push	 ecx
  0079f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  007a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007ac	8d 8d 40 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  007b2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  007b7	50		 push	 eax
  007b8	51		 push	 ecx
  007b9	0f 57 c0	 xorps	 xmm0, xmm0
  007bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007c1	51		 push	 ecx
  007c2	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _w$[ebp]
  007c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007cc	8d 8d 30 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  007d2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  007d7	50		 push	 eax
  007d8	e8 00 00 00 00	 call	 ?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
  007dd	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@BeginCombo:

; 1492 :     }
; 1493 : 
; 1494 :     char name[16];
; 1495 :     ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth

  007e0	8b 45 f4	 mov	 eax, DWORD PTR _g$[ebp]
  007e3	8b 88 c4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6852]
  007e9	51		 push	 ecx
  007ea	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@
  007ef	6a 10		 push	 16			; 00000010H
  007f1	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _name$[ebp]
  007f7	52		 push	 edx
  007f8	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  007fd	83 c4 10	 add	 esp, 16			; 00000010H

; 1496 : 
; 1497 :     // Peak into expected window size so we can position it
; 1498 :     if (ImGuiWindow* popup_window = FindWindowByName(name))

  00800	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _name$[ebp]
  00806	50		 push	 eax
  00807	e8 00 00 00 00	 call	 ?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ; ImGui::FindWindowByName
  0080c	83 c4 04	 add	 esp, 4
  0080f	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _popup_window$20[ebp], eax
  00815	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _popup_window$20[ebp], 0
  0081c	0f 84 cb 00 00
	00		 je	 $LN22@BeginCombo

; 1499 :         if (popup_window->WasActive)

  00822	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _popup_window$20[ebp]
  00828	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  0082c	85 c9		 test	 ecx, ecx
  0082e	0f 84 b9 00 00
	00		 je	 $LN22@BeginCombo

; 1500 :         {
; 1501 :             ImVec2 size_expected = CalcWindowExpectedSize(popup_window);

  00834	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _popup_window$20[ebp]
  0083a	50		 push	 eax
  0083b	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _size_expected$19[ebp]
  00841	51		 push	 ecx
  00842	e8 00 00 00 00	 call	 ?CalcWindowExpectedSize@ImGui@@YA?AUImVec2@@PAUImGuiWindow@@@Z ; ImGui::CalcWindowExpectedSize
  00847	83 c4 08	 add	 esp, 8

; 1502 :             if (flags & ImGuiComboFlags_PopupAlignLeft)

  0084a	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0084d	83 e0 01	 and	 eax, 1
  00850	74 10		 je	 SHORT $LN23@BeginCombo

; 1503 :                 popup_window->AutoPosLastDirection = ImGuiDir_Left;

  00852	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _popup_window$20[ebp]
  00858	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0
$LN23@BeginCombo:

; 1504 :             ImRect r_outer = GetWindowAllowedExtentRect(popup_window);

  00862	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _popup_window$20[ebp]
  00868	50		 push	 eax
  00869	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _r_outer$18[ebp]
  0086f	51		 push	 ecx
  00870	e8 00 00 00 00	 call	 ?GetWindowAllowedExtentRect@ImGui@@YA?AUImRect@@PAUImGuiWindow@@@Z ; ImGui::GetWindowAllowedExtentRect
  00875	83 c4 08	 add	 esp, 8

; 1505 :             ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);

  00878	6a 01		 push	 1
  0087a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _frame_bb$[ebp]
  00880	50		 push	 eax
  00881	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _r_outer$18[ebp]
  00887	51		 push	 ecx
  00888	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR _popup_window$20[ebp]
  0088e	81 c2 94 00 00
	00		 add	 edx, 148		; 00000094H
  00894	52		 push	 edx
  00895	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _size_expected$19[ebp]
  0089b	50		 push	 eax
  0089c	8d 8d 20 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  008a2	51		 push	 ecx
  008a3	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _frame_bb$[ebp]
  008a9	e8 00 00 00 00	 call	 ?GetBL@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetBL
  008ae	50		 push	 eax
  008af	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR _pos$17[ebp]
  008b5	52		 push	 edx
  008b6	e8 00 00 00 00	 call	 ?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@ABU2@0PAHABUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ; ImGui::FindBestWindowPosForPopupEx
  008bb	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1506 :             SetNextWindowPos(pos);

  008be	51		 push	 ecx
  008bf	0f 57 c0	 xorps	 xmm0, xmm0
  008c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c7	51		 push	 ecx
  008c8	0f 57 c0	 xorps	 xmm0, xmm0
  008cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d0	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  008d6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  008db	50		 push	 eax
  008dc	6a 00		 push	 0
  008de	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _pos$17[ebp]
  008e4	50		 push	 eax
  008e5	e8 00 00 00 00	 call	 ?SetNextWindowPos@ImGui@@YAXABUImVec2@@H0@Z ; ImGui::SetNextWindowPos
  008ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@BeginCombo:

; 1507 :         }
; 1508 : 
; 1509 :     // We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
; 1510 :     ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;

  008ed	c7 85 8c fe ff
	ff 47 01 00 04	 mov	 DWORD PTR _window_flags$[ebp], 67109191 ; 04000147H

; 1511 : 
; 1512 :     // Horizontally align ourselves with the framed text
; 1513 :     PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));

  008f7	8b 45 d0	 mov	 eax, DWORD PTR _style$[ebp]
  008fa	51		 push	 ecx
  008fb	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00900	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00905	8b 4d d0	 mov	 ecx, DWORD PTR _style$[ebp]
  00908	51		 push	 ecx
  00909	f3 0f 10 41 38	 movss	 xmm0, DWORD PTR [ecx+56]
  0090e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00913	8d 8d 00 fc ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00919	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0091e	50		 push	 eax
  0091f	6a 01		 push	 1
  00921	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z ; ImGui::PushStyleVar
  00926	83 c4 08	 add	 esp, 8

; 1514 :     bool ret = Begin(name, NULL, window_flags);

  00929	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _window_flags$[ebp]
  0092f	50		 push	 eax
  00930	6a 00		 push	 0
  00932	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _name$[ebp]
  00938	51		 push	 ecx
  00939	e8 00 00 00 00	 call	 ?Begin@ImGui@@YA_NPBDPA_NH@Z ; ImGui::Begin
  0093e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00941	88 85 83 fe ff
	ff		 mov	 BYTE PTR _ret$[ebp], al

; 1515 :     PopStyleVar();

  00947	6a 01		 push	 1
  00949	e8 00 00 00 00	 call	 ?PopStyleVar@ImGui@@YAXH@Z ; ImGui::PopStyleVar
  0094e	83 c4 04	 add	 esp, 4

; 1516 :     if (!ret)

  00951	0f b6 85 83 fe
	ff ff		 movzx	 eax, BYTE PTR _ret$[ebp]
  00958	85 c0		 test	 eax, eax
  0095a	75 33		 jne	 SHORT $LN24@BeginCombo

; 1517 :     {
; 1518 :         EndPopup();

  0095c	e8 00 00 00 00	 call	 ?EndPopup@ImGui@@YAXXZ	; ImGui::EndPopup

; 1519 :         IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above

  00961	33 c0		 xor	 eax, eax
  00963	75 26		 jne	 SHORT $LN44@BeginCombo
  00965	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??BeginCombo@ImGui@@YA_NPBD0H@Z@4JA
  0096b	83 c1 65	 add	 ecx, 101		; 00000065H
  0096e	8b f4		 mov	 esi, esp
  00970	51		 push	 ecx
  00971	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00976	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  0097b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00981	83 c4 0c	 add	 esp, 12			; 0000000cH
  00984	3b f4		 cmp	 esi, esp
  00986	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN44@BeginCombo:

; 1520 :         return false;

  0098b	32 c0		 xor	 al, al
  0098d	eb 02		 jmp	 SHORT $LN1@BeginCombo
$LN24@BeginCombo:

; 1521 :     }
; 1522 :     return true;

  0098f	b0 01		 mov	 al, 1
$LN1@BeginCombo:

; 1523 : }

  00991	52		 push	 edx
  00992	8b cd		 mov	 ecx, ebp
  00994	50		 push	 eax
  00995	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN55@BeginCombo
  0099b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  009a0	58		 pop	 eax
  009a1	5a		 pop	 edx
  009a2	5f		 pop	 edi
  009a3	5e		 pop	 esi
  009a4	5b		 pop	 ebx
  009a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009a8	33 cd		 xor	 ecx, ebp
  009aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009af	81 c4 08 04 00
	00		 add	 esp, 1032		; 00000408H
  009b5	3b ec		 cmp	 ebp, esp
  009b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  009bc	8b e5		 mov	 esp, ebp
  009be	5d		 pop	 ebp
  009bf	c3		 ret	 0
$LN55@BeginCombo:
  009c0	09 00 00 00	 DD	 9
  009c4	00 00 00 00	 DD	 $LN54@BeginCombo
$LN54@BeginCombo:
  009c8	a8 ff ff ff	 DD	 -88			; ffffffa8H
  009cc	08 00 00 00	 DD	 8
  009d0	00 00 00 00	 DD	 $LN45@BeginCombo
  009d4	78 ff ff ff	 DD	 -136			; ffffff78H
  009d8	10 00 00 00	 DD	 16			; 00000010H
  009dc	00 00 00 00	 DD	 $LN46@BeginCombo
  009e0	60 ff ff ff	 DD	 -160			; ffffff60H
  009e4	10 00 00 00	 DD	 16			; 00000010H
  009e8	00 00 00 00	 DD	 $LN47@BeginCombo
  009ec	57 ff ff ff	 DD	 -169			; ffffff57H
  009f0	01 00 00 00	 DD	 1
  009f4	00 00 00 00	 DD	 $LN48@BeginCombo
  009f8	4b ff ff ff	 DD	 -181			; ffffff4bH
  009fc	01 00 00 00	 DD	 1
  00a00	00 00 00 00	 DD	 $LN49@BeginCombo
  00a04	dc fe ff ff	 DD	 -292			; fffffedcH
  00a08	10 00 00 00	 DD	 16			; 00000010H
  00a0c	00 00 00 00	 DD	 $LN50@BeginCombo
  00a10	c0 fe ff ff	 DD	 -320			; fffffec0H
  00a14	08 00 00 00	 DD	 8
  00a18	00 00 00 00	 DD	 $LN51@BeginCombo
  00a1c	a8 fe ff ff	 DD	 -344			; fffffea8H
  00a20	10 00 00 00	 DD	 16			; 00000010H
  00a24	00 00 00 00	 DD	 $LN52@BeginCombo
  00a28	98 fe ff ff	 DD	 -360			; fffffe98H
  00a2c	08 00 00 00	 DD	 8
  00a30	00 00 00 00	 DD	 $LN53@BeginCombo
$LN53@BeginCombo:
  00a34	70		 DB	 112			; 00000070H
  00a35	6f		 DB	 111			; 0000006fH
  00a36	73		 DB	 115			; 00000073H
  00a37	00		 DB	 0
$LN52@BeginCombo:
  00a38	72		 DB	 114			; 00000072H
  00a39	5f		 DB	 95			; 0000005fH
  00a3a	6f		 DB	 111			; 0000006fH
  00a3b	75		 DB	 117			; 00000075H
  00a3c	74		 DB	 116			; 00000074H
  00a3d	65		 DB	 101			; 00000065H
  00a3e	72		 DB	 114			; 00000072H
  00a3f	00		 DB	 0
$LN51@BeginCombo:
  00a40	73		 DB	 115			; 00000073H
  00a41	69		 DB	 105			; 00000069H
  00a42	7a		 DB	 122			; 0000007aH
  00a43	65		 DB	 101			; 00000065H
  00a44	5f		 DB	 95			; 0000005fH
  00a45	65		 DB	 101			; 00000065H
  00a46	78		 DB	 120			; 00000078H
  00a47	70		 DB	 112			; 00000070H
  00a48	65		 DB	 101			; 00000065H
  00a49	63		 DB	 99			; 00000063H
  00a4a	74		 DB	 116			; 00000074H
  00a4b	65		 DB	 101			; 00000065H
  00a4c	64		 DB	 100			; 00000064H
  00a4d	00		 DB	 0
$LN50@BeginCombo:
  00a4e	6e		 DB	 110			; 0000006eH
  00a4f	61		 DB	 97			; 00000061H
  00a50	6d		 DB	 109			; 0000006dH
  00a51	65		 DB	 101			; 00000065H
  00a52	00		 DB	 0
$LN49@BeginCombo:
  00a53	68		 DB	 104			; 00000068H
  00a54	65		 DB	 101			; 00000065H
  00a55	6c		 DB	 108			; 0000006cH
  00a56	64		 DB	 100			; 00000064H
  00a57	00		 DB	 0
$LN48@BeginCombo:
  00a58	68		 DB	 104			; 00000068H
  00a59	6f		 DB	 111			; 0000006fH
  00a5a	76		 DB	 118			; 00000076H
  00a5b	65		 DB	 101			; 00000065H
  00a5c	72		 DB	 114			; 00000072H
  00a5d	65		 DB	 101			; 00000065H
  00a5e	64		 DB	 100			; 00000064H
  00a5f	00		 DB	 0
$LN47@BeginCombo:
  00a60	74		 DB	 116			; 00000074H
  00a61	6f		 DB	 111			; 0000006fH
  00a62	74		 DB	 116			; 00000074H
  00a63	61		 DB	 97			; 00000061H
  00a64	6c		 DB	 108			; 0000006cH
  00a65	5f		 DB	 95			; 0000005fH
  00a66	62		 DB	 98			; 00000062H
  00a67	62		 DB	 98			; 00000062H
  00a68	00		 DB	 0
$LN46@BeginCombo:
  00a69	66		 DB	 102			; 00000066H
  00a6a	72		 DB	 114			; 00000072H
  00a6b	61		 DB	 97			; 00000061H
  00a6c	6d		 DB	 109			; 0000006dH
  00a6d	65		 DB	 101			; 00000065H
  00a6e	5f		 DB	 95			; 0000005fH
  00a6f	62		 DB	 98			; 00000062H
  00a70	62		 DB	 98			; 00000062H
  00a71	00		 DB	 0
$LN45@BeginCombo:
  00a72	6c		 DB	 108			; 0000006cH
  00a73	61		 DB	 97			; 00000061H
  00a74	62		 DB	 98			; 00000062H
  00a75	65		 DB	 101			; 00000065H
  00a76	6c		 DB	 108			; 0000006cH
  00a77	5f		 DB	 95			; 0000005fH
  00a78	73		 DB	 115			; 00000073H
  00a79	69		 DB	 105			; 00000069H
  00a7a	7a		 DB	 122			; 0000007aH
  00a7b	65		 DB	 101			; 00000065H
  00a7c	00		 DB	 0
?BeginCombo@ImGui@@YA_NPBD0H@Z ENDP			; ImGui::BeginCombo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Bullet@ImGui@@YAXXZ
_TEXT	SEGMENT
$T1 = -340						; size = 8
$T2 = -324						; size = 8
$T3 = -308						; size = 8
$T4 = -292						; size = 8
_text_col$ = -84					; size = 4
_bb$ = -72						; size = 16
_line_height$ = -48					; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Bullet@ImGui@@YAXXZ PROC				; ImGui::Bullet, COMDAT

; 1139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-344]
  00012	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1140 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 1141 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN2@Bullet

; 1142 :         return;

  00045	e9 d1 01 00 00	 jmp	 $LN1@Bullet
$LN2@Bullet:

; 1143 : 
; 1144 :     ImGuiContext& g = *GImGui;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004f	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 1145 :     const ImGuiStyle& style = g.Style;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00055	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005a	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 1146 :     const float line_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);

  0005d	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00060	51		 push	 ecx
  00061	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00071	f3 0f 10 81 4c
	15 00 00	 movss	 xmm0, DWORD PTR [ecx+5452]
  00079	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00081	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00084	f3 0f 58 82 c4
	18 00 00	 addss	 xmm0, DWORD PTR [edx+6340]
  0008c	51		 push	 ecx
  0008d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00092	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00095	51		 push	 ecx
  00096	f3 0f 10 80 ec
	00 00 00	 movss	 xmm0, DWORD PTR [eax+236]
  0009e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a3	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  000a8	83 c4 04	 add	 esp, 4
  000ab	d9 1c 24	 fstp	 DWORD PTR [esp]
  000ae	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000b3	83 c4 08	 add	 esp, 8
  000b6	d9 5d d0	 fstp	 DWORD PTR _line_height$[ebp]

; 1147 :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));

  000b9	51		 push	 ecx
  000ba	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _line_height$[ebp]
  000bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c4	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  000c7	51		 push	 ecx
  000c8	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000db	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000e0	50		 push	 eax
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000e4	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  000ea	51		 push	 ecx
  000eb	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  000f1	52		 push	 edx
  000f2	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fa	50		 push	 eax
  000fb	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000fe	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  00103	50		 push	 eax
  00104	8d 4d b8	 lea	 ecx, DWORD PTR _bb$[ebp]
  00107	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1148 :     ItemSize(bb);

  0010c	51		 push	 ecx
  0010d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00115	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011a	8d 45 b8	 lea	 eax, DWORD PTR _bb$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  00123	83 c4 08	 add	 esp, 8

; 1149 :     if (!ItemAdd(bb, 0))

  00126	6a 00		 push	 0
  00128	6a 00		 push	 0
  0012a	8d 45 b8	 lea	 eax, DWORD PTR _bb$[ebp]
  0012d	50		 push	 eax
  0012e	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
  00136	0f b6 c8	 movzx	 ecx, al
  00139	85 c9		 test	 ecx, ecx
  0013b	75 2c		 jne	 SHORT $LN3@Bullet

; 1150 :     {
; 1151 :         SameLine(0, style.FramePadding.x*2);

  0013d	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00140	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  00145	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0014d	51		 push	 ecx
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	51		 push	 ecx
  00154	0f 57 c0	 xorps	 xmm0, xmm0
  00157	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015c	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00161	83 c4 08	 add	 esp, 8

; 1152 :         return;

  00164	e9 b2 00 00 00	 jmp	 $LN1@Bullet
$LN3@Bullet:

; 1153 :     }
; 1154 : 
; 1155 :     // Render and stay on same line
; 1156 :     ImU32 text_col = GetColorU32(ImGuiCol_Text);

  00169	51		 push	 ecx
  0016a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00172	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00177	6a 00		 push	 0
  00179	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  0017e	83 c4 08	 add	 esp, 8
  00181	89 45 ac	 mov	 DWORD PTR _text_col$[ebp], eax

; 1157 :     RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f), text_col);

  00184	8b 45 ac	 mov	 eax, DWORD PTR _text_col$[ebp]
  00187	50		 push	 eax
  00188	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _line_height$[ebp]
  0018d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00195	51		 push	 ecx
  00196	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019b	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  0019e	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  001a6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001ae	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  001b1	f3 0f 58 42 38	 addss	 xmm0, DWORD PTR [edx+56]
  001b6	51		 push	 ecx
  001b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bc	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001c2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001c7	50		 push	 eax
  001c8	8d 45 b8	 lea	 eax, DWORD PTR _bb$[ebp]
  001cb	50		 push	 eax
  001cc	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001db	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001de	52		 push	 edx
  001df	8b 00		 mov	 eax, DWORD PTR [eax]
  001e1	50		 push	 eax
  001e2	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  001e5	8b 91 74 02 00
	00		 mov	 edx, DWORD PTR [ecx+628]
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 ?RenderBullet@ImGui@@YAXPAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
  001f1	83 c4 10	 add	 esp, 16			; 00000010H

; 1158 :     SameLine(0, style.FramePadding.x * 2.0f);

  001f4	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  001f7	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  001fc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00204	51		 push	 ecx
  00205	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020a	51		 push	 ecx
  0020b	0f 57 c0	 xorps	 xmm0, xmm0
  0020e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00213	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine
  00218	83 c4 08	 add	 esp, 8
$LN1@Bullet:

; 1159 : }

  0021b	52		 push	 edx
  0021c	8b cd		 mov	 ecx, ebp
  0021e	50		 push	 eax
  0021f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@Bullet
  00225	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022a	58		 pop	 eax
  0022b	5a		 pop	 edx
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	5b		 pop	 ebx
  0022f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00232	33 cd		 xor	 ecx, ebp
  00234	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00239	81 c4 58 01 00
	00		 add	 esp, 344		; 00000158H
  0023f	3b ec		 cmp	 ebp, esp
  00241	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
  0024a	66 90		 npad	 2
$LN7@Bullet:
  0024c	01 00 00 00	 DD	 1
  00250	00 00 00 00	 DD	 $LN6@Bullet
$LN6@Bullet:
  00254	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00258	10 00 00 00	 DD	 16			; 00000010H
  0025c	00 00 00 00	 DD	 $LN5@Bullet
$LN5@Bullet:
  00260	62		 DB	 98			; 00000062H
  00261	62		 DB	 98			; 00000062H
  00262	00		 DB	 0
?Bullet@ImGui@@YAXXZ ENDP				; ImGui::Bullet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z
_TEXT	SEGMENT
$T1 = -420						; size = 8
$T2 = -404						; size = 8
$T3 = -388						; size = 8
$T4 = -372						; size = 8
_overlay_size$ = -164					; size = 8
_overlay_buf$ = -148					; size = 32
_fill_br$ = -108					; size = 8
_bb$ = -92						; size = 16
_size$ = -68						; size = 8
_pos$ = -52						; size = 8
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fraction$ = 8						; size = 4
_size_arg$ = 12						; size = 4
_overlay$ = 16						; size = 4
?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z PROC		; ImGui::ProgressBar, COMDAT

; 1103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 58 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-424]
  00012	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1104 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 1105 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN2@ProgressBa

; 1106 :         return;

  00045	e9 02 03 00 00	 jmp	 $LN1@ProgressBa
$LN2@ProgressBa:

; 1107 : 
; 1108 :     ImGuiContext& g = *GImGui;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004f	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 1109 :     const ImGuiStyle& style = g.Style;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00055	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005a	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 1110 : 
; 1111 :     ImVec2 pos = window->DC.CursorPos;

  0005d	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00060	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  00066	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  0006c	89 4d cc	 mov	 DWORD PTR _pos$[ebp], ecx
  0006f	89 55 d0	 mov	 DWORD PTR _pos$[ebp+4], edx

; 1112 :     ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y*2.0f);

  00072	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00075	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0007a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00082	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  00085	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  0008d	51		 push	 ecx
  0008e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00093	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00098	51		 push	 ecx
  00099	d9 1c 24	 fstp	 DWORD PTR [esp]
  0009c	8b 55 0c	 mov	 edx, DWORD PTR _size_arg$[ebp]
  0009f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a2	50		 push	 eax
  000a3	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000a5	51		 push	 ecx
  000a6	8d 55 bc	 lea	 edx, DWORD PTR _size$[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
  000af	83 c4 14	 add	 esp, 20			; 00000014H

; 1113 :     ImRect bb(pos, pos + size);

  000b2	8d 45 bc	 lea	 eax, DWORD PTR _size$[ebp]
  000b5	50		 push	 eax
  000b6	8d 4d cc	 lea	 ecx, DWORD PTR _pos$[ebp]
  000b9	51		 push	 ecx
  000ba	8d 95 8c fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	50		 push	 eax
  000ca	8d 45 cc	 lea	 eax, DWORD PTR _pos$[ebp]
  000cd	50		 push	 eax
  000ce	8d 4d a4	 lea	 ecx, DWORD PTR _bb$[ebp]
  000d1	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1114 :     ItemSize(size, style.FramePadding.y);

  000d6	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000d9	51		 push	 ecx
  000da	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  000df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e4	8d 4d bc	 lea	 ecx, DWORD PTR _size$[ebp]
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  000ed	83 c4 08	 add	 esp, 8

; 1115 :     if (!ItemAdd(bb, 0))

  000f0	6a 00		 push	 0
  000f2	6a 00		 push	 0
  000f4	8d 45 a4	 lea	 eax, DWORD PTR _bb$[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	0f b6 c8	 movzx	 ecx, al
  00103	85 c9		 test	 ecx, ecx
  00105	75 05		 jne	 SHORT $LN3@ProgressBa

; 1116 :         return;

  00107	e9 40 02 00 00	 jmp	 $LN1@ProgressBa
$LN3@ProgressBa:

; 1117 : 
; 1118 :     // Render
; 1119 :     fraction = ImSaturate(fraction);

  0010c	51		 push	 ecx
  0010d	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fraction$[ebp]
  00112	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00117	e8 00 00 00 00	 call	 ?ImSaturate@@YAMM@Z	; ImSaturate
  0011c	83 c4 04	 add	 esp, 4
  0011f	d9 5d 08	 fstp	 DWORD PTR _fraction$[ebp]

; 1120 :     RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

  00122	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00125	51		 push	 ecx
  00126	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  0012b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00130	6a 01		 push	 1
  00132	51		 push	 ecx
  00133	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0013b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00140	6a 07		 push	 7
  00142	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00147	83 c4 08	 add	 esp, 8
  0014a	50		 push	 eax
  0014b	8b 4d b0	 mov	 ecx, DWORD PTR _bb$[ebp+12]
  0014e	51		 push	 ecx
  0014f	8b 55 ac	 mov	 edx, DWORD PTR _bb$[ebp+8]
  00152	52		 push	 edx
  00153	8b 45 a8	 mov	 eax, DWORD PTR _bb$[ebp+4]
  00156	50		 push	 eax
  00157	8b 4d a4	 mov	 ecx, DWORD PTR _bb$[ebp]
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  00160	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1121 :     bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));

  00163	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00166	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  0016b	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00172	51		 push	 ecx
  00173	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00178	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  0017b	f3 0f 10 41 44	 movss	 xmm0, DWORD PTR [ecx+68]
  00180	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00187	51		 push	 ecx
  00188	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018d	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00193	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00198	50		 push	 eax
  00199	8d 4d a4	 lea	 ecx, DWORD PTR _bb$[ebp]
  0019c	e8 00 00 00 00	 call	 ?Expand@ImRect@@QAEXABUImVec2@@@Z ; ImRect::Expand

; 1122 :     const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);

  001a1	51		 push	 ecx
  001a2	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _bb$[ebp+12]
  001a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ac	51		 push	 ecx
  001ad	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fraction$[ebp]
  001b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b7	51		 push	 ecx
  001b8	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _bb$[ebp+8]
  001bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c2	51		 push	 ecx
  001c3	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _bb$[ebp]
  001c8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001cd	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  001d2	83 c4 08	 add	 esp, 8
  001d5	d9 1c 24	 fstp	 DWORD PTR [esp]
  001d8	8d 4d 94	 lea	 ecx, DWORD PTR _fill_br$[ebp]
  001db	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1123 :     RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);

  001e0	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  001e3	51		 push	 ecx
  001e4	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	51		 push	 ecx
  001ef	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fraction$[ebp]
  001f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f9	51		 push	 ecx
  001fa	0f 57 c0	 xorps	 xmm0, xmm0
  001fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00202	51		 push	 ecx
  00203	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00210	6a 28		 push	 40			; 00000028H
  00212	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00217	83 c4 08	 add	 esp, 8
  0021a	50		 push	 eax
  0021b	8d 4d a4	 lea	 ecx, DWORD PTR _bb$[ebp]
  0021e	51		 push	 ecx
  0021f	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00222	8b 82 74 02 00
	00		 mov	 eax, DWORD PTR [edx+628]
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 ?RenderRectFilledRangeH@ImGui@@YAXPAUImDrawList@@ABUImRect@@IMMM@Z ; ImGui::RenderRectFilledRangeH
  0022e	83 c4 18	 add	 esp, 24			; 00000018H

; 1124 : 
; 1125 :     // Default displaying the fraction as percentage string, but user can override it
; 1126 :     char overlay_buf[32];
; 1127 :     if (!overlay)

  00231	83 7d 10 00	 cmp	 DWORD PTR _overlay$[ebp], 0
  00235	75 40		 jne	 SHORT $LN4@ProgressBa

; 1128 :     {
; 1129 :         ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction*100+0.01f);

  00237	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fraction$[ebp]
  0023c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c80000
  00244	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3c23d70a
  0024c	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00250	83 ec 08	 sub	 esp, 8
  00253	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@
  0025d	6a 20		 push	 32			; 00000020H
  0025f	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _overlay_buf$[ebp]
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  0026b	83 c4 14	 add	 esp, 20			; 00000014H

; 1130 :         overlay = overlay_buf;

  0026e	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _overlay_buf$[ebp]
  00274	89 45 10	 mov	 DWORD PTR _overlay$[ebp], eax
$LN4@ProgressBa:

; 1131 :     }
; 1132 : 
; 1133 :     ImVec2 overlay_size = CalcTextSize(overlay, NULL);

  00277	51		 push	 ecx
  00278	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00280	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00285	6a 00		 push	 0
  00287	6a 00		 push	 0
  00289	8b 45 10	 mov	 eax, DWORD PTR _overlay$[ebp]
  0028c	50		 push	 eax
  0028d	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _overlay_size$[ebp]
  00293	51		 push	 ecx
  00294	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00299	83 c4 14	 add	 esp, 20			; 00000014H

; 1134 :     if (overlay_size.x > 0.0f)

  0029c	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _overlay_size$[ebp]
  002a4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002ab	0f 86 9b 00 00
	00		 jbe	 $LN5@ProgressBa

; 1135 :         RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);

  002b1	8d 45 a4	 lea	 eax, DWORD PTR _bb$[ebp]
  002b4	50		 push	 eax
  002b5	51		 push	 ecx
  002b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  002be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c3	51		 push	 ecx
  002c4	0f 57 c0	 xorps	 xmm0, xmm0
  002c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002cc	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  002d2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002d7	50		 push	 eax
  002d8	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _overlay_size$[ebp]
  002de	51		 push	 ecx
  002df	6a 00		 push	 0
  002e1	8b 55 10	 mov	 edx, DWORD PTR _overlay$[ebp]
  002e4	52		 push	 edx
  002e5	8d 45 ac	 lea	 eax, DWORD PTR _bb$[ebp+8]
  002e8	50		 push	 eax
  002e9	51		 push	 ecx
  002ea	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _bb$[ebp+4]
  002ef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f4	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _bb$[ebp+8]
  002f9	f3 0f 5c 85 5c
	ff ff ff	 subss	 xmm0, DWORD PTR _overlay_size$[ebp]
  00301	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00304	f3 0f 5c 41 50	 subss	 xmm0, DWORD PTR [ecx+80]
  00309	51		 push	 ecx
  0030a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030f	51		 push	 ecx
  00310	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _bb$[ebp]
  00315	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0031a	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  0031d	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _fill_br$[ebp]
  00322	f3 0f 58 42 48	 addss	 xmm0, DWORD PTR [edx+72]
  00327	51		 push	 ecx
  00328	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032d	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  00332	83 c4 08	 add	 esp, 8
  00335	d9 1c 24	 fstp	 DWORD PTR [esp]
  00338	8d 8d 5c fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0033e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00343	50		 push	 eax
  00344	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00349	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@ProgressBa:
$LN1@ProgressBa:

; 1136 : }

  0034c	52		 push	 edx
  0034d	8b cd		 mov	 ecx, ebp
  0034f	50		 push	 eax
  00350	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@ProgressBa
  00356	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0035b	58		 pop	 eax
  0035c	5a		 pop	 edx
  0035d	5f		 pop	 edi
  0035e	5e		 pop	 esi
  0035f	5b		 pop	 ebx
  00360	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00363	33 cd		 xor	 ecx, ebp
  00365	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0036a	81 c4 a8 01 00
	00		 add	 esp, 424		; 000001a8H
  00370	3b ec		 cmp	 ebp, esp
  00372	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00377	8b e5		 mov	 esp, ebp
  00379	5d		 pop	 ebp
  0037a	c3		 ret	 0
  0037b	90		 npad	 1
$LN14@ProgressBa:
  0037c	06 00 00 00	 DD	 6
  00380	00 00 00 00	 DD	 $LN13@ProgressBa
$LN13@ProgressBa:
  00384	cc ff ff ff	 DD	 -52			; ffffffccH
  00388	08 00 00 00	 DD	 8
  0038c	00 00 00 00	 DD	 $LN7@ProgressBa
  00390	bc ff ff ff	 DD	 -68			; ffffffbcH
  00394	08 00 00 00	 DD	 8
  00398	00 00 00 00	 DD	 $LN8@ProgressBa
  0039c	a4 ff ff ff	 DD	 -92			; ffffffa4H
  003a0	10 00 00 00	 DD	 16			; 00000010H
  003a4	00 00 00 00	 DD	 $LN9@ProgressBa
  003a8	94 ff ff ff	 DD	 -108			; ffffff94H
  003ac	08 00 00 00	 DD	 8
  003b0	00 00 00 00	 DD	 $LN10@ProgressBa
  003b4	6c ff ff ff	 DD	 -148			; ffffff6cH
  003b8	20 00 00 00	 DD	 32			; 00000020H
  003bc	00 00 00 00	 DD	 $LN11@ProgressBa
  003c0	5c ff ff ff	 DD	 -164			; ffffff5cH
  003c4	08 00 00 00	 DD	 8
  003c8	00 00 00 00	 DD	 $LN12@ProgressBa
$LN12@ProgressBa:
  003cc	6f		 DB	 111			; 0000006fH
  003cd	76		 DB	 118			; 00000076H
  003ce	65		 DB	 101			; 00000065H
  003cf	72		 DB	 114			; 00000072H
  003d0	6c		 DB	 108			; 0000006cH
  003d1	61		 DB	 97			; 00000061H
  003d2	79		 DB	 121			; 00000079H
  003d3	5f		 DB	 95			; 0000005fH
  003d4	73		 DB	 115			; 00000073H
  003d5	69		 DB	 105			; 00000069H
  003d6	7a		 DB	 122			; 0000007aH
  003d7	65		 DB	 101			; 00000065H
  003d8	00		 DB	 0
$LN11@ProgressBa:
  003d9	6f		 DB	 111			; 0000006fH
  003da	76		 DB	 118			; 00000076H
  003db	65		 DB	 101			; 00000065H
  003dc	72		 DB	 114			; 00000072H
  003dd	6c		 DB	 108			; 0000006cH
  003de	61		 DB	 97			; 00000061H
  003df	79		 DB	 121			; 00000079H
  003e0	5f		 DB	 95			; 0000005fH
  003e1	62		 DB	 98			; 00000062H
  003e2	75		 DB	 117			; 00000075H
  003e3	66		 DB	 102			; 00000066H
  003e4	00		 DB	 0
$LN10@ProgressBa:
  003e5	66		 DB	 102			; 00000066H
  003e6	69		 DB	 105			; 00000069H
  003e7	6c		 DB	 108			; 0000006cH
  003e8	6c		 DB	 108			; 0000006cH
  003e9	5f		 DB	 95			; 0000005fH
  003ea	62		 DB	 98			; 00000062H
  003eb	72		 DB	 114			; 00000072H
  003ec	00		 DB	 0
$LN9@ProgressBa:
  003ed	62		 DB	 98			; 00000062H
  003ee	62		 DB	 98			; 00000062H
  003ef	00		 DB	 0
$LN8@ProgressBa:
  003f0	73		 DB	 115			; 00000073H
  003f1	69		 DB	 105			; 00000069H
  003f2	7a		 DB	 122			; 0000007aH
  003f3	65		 DB	 101			; 00000065H
  003f4	00		 DB	 0
$LN7@ProgressBa:
  003f5	70		 DB	 112			; 00000070H
  003f6	6f		 DB	 111			; 0000006fH
  003f7	73		 DB	 115			; 00000073H
  003f8	00		 DB	 0
?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z ENDP		; ImGui::ProgressBar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?RadioButton@ImGui@@YA_NPBDPAHH@Z
_TEXT	SEGMENT
tv66 = -205						; size = 1
_pressed$ = -5						; size = 1
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_button$ = 16						; size = 4
?RadioButton@ImGui@@YA_NPBDPAHH@Z PROC			; ImGui::RadioButton, COMDAT

; 1094 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1095 :     const bool pressed = RadioButton(label, *v == v_button);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	3b 4d 10	 cmp	 ecx, DWORD PTR _v_button$[ebp]
  00030	75 09		 jne	 SHORT $LN4@RadioButto
  00032	c6 85 33 ff ff
	ff 01		 mov	 BYTE PTR tv66[ebp], 1
  00039	eb 07		 jmp	 SHORT $LN5@RadioButto
$LN4@RadioButto:
  0003b	c6 85 33 ff ff
	ff 00		 mov	 BYTE PTR tv66[ebp], 0
$LN5@RadioButto:
  00042	0f b6 95 33 ff
	ff ff		 movzx	 edx, BYTE PTR tv66[ebp]
  00049	52		 push	 edx
  0004a	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPBD_N@Z ; ImGui::RadioButton
  00053	83 c4 08	 add	 esp, 8
  00056	88 45 fb	 mov	 BYTE PTR _pressed$[ebp], al

; 1096 :     if (pressed)

  00059	0f b6 45 fb	 movzx	 eax, BYTE PTR _pressed$[ebp]
  0005d	85 c0		 test	 eax, eax
  0005f	74 08		 je	 SHORT $LN2@RadioButto

; 1097 :         *v = v_button;

  00061	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00064	8b 4d 10	 mov	 ecx, DWORD PTR _v_button$[ebp]
  00067	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@RadioButto:

; 1098 :     return pressed;

  00069	8a 45 fb	 mov	 al, BYTE PTR _pressed$[ebp]

; 1099 : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?RadioButton@ImGui@@YA_NPBDPAHH@Z ENDP			; ImGui::RadioButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?RadioButton@ImGui@@YA_NPBD_N@Z
_TEXT	SEGMENT
tv191 = -532						; size = 4
tv255 = -528						; size = 4
tv192 = -528						; size = 4
tv139 = -528						; size = 4
$T1 = -520						; size = 8
$T2 = -504						; size = 8
$T3 = -488						; size = 8
$T4 = -472						; size = 8
$T5 = -456						; size = 8
$T6 = -440						; size = 8
$T7 = -424						; size = 8
_pad$8 = -216						; size = 4
_pressed$ = -201					; size = 1
_held$ = -189						; size = 1
_hovered$ = -177					; size = 1
_radius$ = -168						; size = 4
_center$ = -156						; size = 8
_total_bb$ = -140					; size = 16
_check_bb$ = -116					; size = 16
_pos$ = -92						; size = 8
_square_sz$ = -76					; size = 4
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_active$ = 12						; size = 1
?RadioButton@ImGui@@YA_NPBD_N@Z PROC			; ImGui::RadioButton, COMDAT

; 1042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 02 00
	00		 sub	 esp, 532		; 00000214H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fd ff
	ff		 lea	 edi, DWORD PTR [ebp-532]
  00012	b9 85 00 00 00	 mov	 ecx, 133		; 00000085H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1043 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 1044 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@RadioButto

; 1045 :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 cf 04 00 00	 jmp	 $LN1@RadioButto
$LN2@RadioButto:

; 1046 : 
; 1047 :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 1048 :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 1049 :     const ImGuiID id = window->GetID(label);

  0005f	6a 00		 push	 0
  00061	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00068	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0006d	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 1050 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  00070	51		 push	 ecx
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	6a 01		 push	 1
  00080	6a 00		 push	 0
  00082	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00085	50		 push	 eax
  00086	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0008f	83 c4 14	 add	 esp, 20			; 00000014H

; 1051 : 
; 1052 :     const float square_sz = GetFrameHeight();

  00092	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  00097	d9 5d b4	 fstp	 DWORD PTR _square_sz$[ebp]

; 1053 :     const ImVec2 pos = window->DC.CursorPos;

  0009a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0009d	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  000a3	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  000a9	89 4d a4	 mov	 DWORD PTR _pos$[ebp], ecx
  000ac	89 55 a8	 mov	 DWORD PTR _pos$[ebp+4], edx

; 1054 :     const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));

  000af	51		 push	 ecx
  000b0	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  000b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ba	51		 push	 ecx
  000bb	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  000c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c5	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  000cb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000d0	50		 push	 eax
  000d1	8d 45 a4	 lea	 eax, DWORD PTR _pos$[ebp]
  000d4	50		 push	 eax
  000d5	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	50		 push	 eax
  000e5	8d 55 a4	 lea	 edx, DWORD PTR _pos$[ebp]
  000e8	52		 push	 edx
  000e9	8d 4d 8c	 lea	 ecx, DWORD PTR _check_bb$[ebp]
  000ec	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1055 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

  000f1	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  000f6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000fd	76 17		 jbe	 SHORT $LN10@RadioButto
  000ff	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00102	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  00107	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  0010c	f3 0f 11 85 f0
	fd ff ff	 movss	 DWORD PTR tv139[ebp], xmm0
  00114	eb 0b		 jmp	 SHORT $LN11@RadioButto
$LN10@RadioButto:
  00116	0f 57 c0	 xorps	 xmm0, xmm0
  00119	f3 0f 11 85 f0
	fd ff ff	 movss	 DWORD PTR tv139[ebp], xmm0
$LN11@RadioButto:
  00121	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00124	f3 0f 10 41 3c	 movss	 xmm0, DWORD PTR [ecx+60]
  00129	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00131	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  00136	51		 push	 ecx
  00137	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013c	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00141	f3 0f 58 85 f0
	fd ff ff	 addss	 xmm0, DWORD PTR tv139[ebp]
  00149	51		 push	 ecx
  0014a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014f	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00155	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0015a	50		 push	 eax
  0015b	8d 55 a4	 lea	 edx, DWORD PTR _pos$[ebp]
  0015e	52		 push	 edx
  0015f	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016e	50		 push	 eax
  0016f	8d 4d a4	 lea	 ecx, DWORD PTR _pos$[ebp]
  00172	51		 push	 ecx
  00173	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00179	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1056 :     ItemSize(total_bb, style.FramePadding.y);

  0017e	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00181	51		 push	 ecx
  00182	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00187	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00192	51		 push	 ecx
  00193	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  00198	83 c4 08	 add	 esp, 8

; 1057 :     if (!ItemAdd(total_bb, id))

  0019b	6a 00		 push	 0
  0019d	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  001a0	50		 push	 eax
  001a1	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  001a7	51		 push	 ecx
  001a8	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  001ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b0	0f b6 d0	 movzx	 edx, al
  001b3	85 d2		 test	 edx, edx
  001b5	75 07		 jne	 SHORT $LN3@RadioButto

; 1058 :         return false;

  001b7	32 c0		 xor	 al, al
  001b9	e9 5d 03 00 00	 jmp	 $LN1@RadioButto
$LN3@RadioButto:

; 1059 : 
; 1060 :     ImVec2 center = check_bb.GetCenter();

  001be	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _center$[ebp]
  001c4	50		 push	 eax
  001c5	8d 4d 8c	 lea	 ecx, DWORD PTR _check_bb$[ebp]
  001c8	e8 00 00 00 00	 call	 ?GetCenter@ImRect@@QBE?AUImVec2@@XZ ; ImRect::GetCenter

; 1061 :     center.x = IM_ROUND(center.x);

  001cd	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _center$[ebp]
  001d5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001dd	f3 0f 2c c0	 cvttss2si eax, xmm0
  001e1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001e5	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _center$[ebp], xmm0

; 1062 :     center.y = IM_ROUND(center.y);

  001ed	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _center$[ebp+4]
  001f5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001fd	f3 0f 2c c0	 cvttss2si eax, xmm0
  00201	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00205	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _center$[ebp+4], xmm0

; 1063 :     const float radius = (square_sz - 1.0f) * 0.5f;

  0020d	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00212	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0021a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00222	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _radius$[ebp], xmm0

; 1064 : 
; 1065 :     bool hovered, held;
; 1066 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

  0022a	6a 00		 push	 0
  0022c	8d 85 43 ff ff
	ff		 lea	 eax, DWORD PTR _held$[ebp]
  00232	50		 push	 eax
  00233	8d 8d 4f ff ff
	ff		 lea	 ecx, DWORD PTR _hovered$[ebp]
  00239	51		 push	 ecx
  0023a	8b 55 d0	 mov	 edx, DWORD PTR _id$[ebp]
  0023d	52		 push	 edx
  0023e	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _total_bb$[ebp]
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  0024a	83 c4 14	 add	 esp, 20			; 00000014H
  0024d	88 85 37 ff ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 1067 :     if (pressed)

  00253	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  0025a	85 c0		 test	 eax, eax
  0025c	74 0c		 je	 SHORT $LN4@RadioButto

; 1068 :         MarkItemEdited(id);

  0025e	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00261	50		 push	 eax
  00262	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  00267	83 c4 04	 add	 esp, 4
$LN4@RadioButto:

; 1069 : 
; 1070 :     RenderNavHighlight(total_bb, id);

  0026a	6a 01		 push	 1
  0026c	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  0026f	50		 push	 eax
  00270	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00276	51		 push	 ecx
  00277	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  0027c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1071 :     window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);

  0027f	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  00286	85 c0		 test	 eax, eax
  00288	74 17		 je	 SHORT $LN12@RadioButto
  0028a	0f b6 8d 4f ff
	ff ff		 movzx	 ecx, BYTE PTR _hovered$[ebp]
  00291	85 c9		 test	 ecx, ecx
  00293	74 0c		 je	 SHORT $LN12@RadioButto
  00295	c7 85 f0 fd ff
	ff 09 00 00 00	 mov	 DWORD PTR tv192[ebp], 9
  0029f	eb 2d		 jmp	 SHORT $LN15@RadioButto
$LN12@RadioButto:
  002a1	0f b6 95 4f ff
	ff ff		 movzx	 edx, BYTE PTR _hovered$[ebp]
  002a8	85 d2		 test	 edx, edx
  002aa	74 0c		 je	 SHORT $LN13@RadioButto
  002ac	c7 85 ec fd ff
	ff 08 00 00 00	 mov	 DWORD PTR tv191[ebp], 8
  002b6	eb 0a		 jmp	 SHORT $LN14@RadioButto
$LN13@RadioButto:
  002b8	c7 85 ec fd ff
	ff 07 00 00 00	 mov	 DWORD PTR tv191[ebp], 7
$LN14@RadioButto:
  002c2	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR tv191[ebp]
  002c8	89 85 f0 fd ff
	ff		 mov	 DWORD PTR tv192[ebp], eax
$LN15@RadioButto:
  002ce	6a 10		 push	 16			; 00000010H
  002d0	51		 push	 ecx
  002d1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002d9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002de	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv192[ebp]
  002e4	51		 push	 ecx
  002e5	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  002ea	83 c4 08	 add	 esp, 8
  002ed	50		 push	 eax
  002ee	51		 push	 ecx
  002ef	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _radius$[ebp]
  002f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fc	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _center$[ebp]
  00302	52		 push	 edx
  00303	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00306	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  0030c	e8 00 00 00 00	 call	 ?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 1072 :     if (active)

  00311	0f b6 45 0c	 movzx	 eax, BYTE PTR _active$[ebp]
  00315	85 c0		 test	 eax, eax
  00317	74 7d		 je	 SHORT $LN5@RadioButto

; 1073 :     {
; 1074 :         const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));

  00319	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  0031e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40c00000
  00326	f3 0f 2c c0	 cvttss2si eax, xmm0
  0032a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0032e	51		 push	 ecx
  0032f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00334	51		 push	 ecx
  00335	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0033d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00342	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00347	83 c4 08	 add	 esp, 8
  0034a	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _pad$8[ebp]

; 1075 :         window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark), 16);

  00350	6a 10		 push	 16			; 00000010H
  00352	51		 push	 ecx
  00353	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0035b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00360	6a 12		 push	 18			; 00000012H
  00362	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00367	83 c4 08	 add	 esp, 8
  0036a	50		 push	 eax
  0036b	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00373	f3 0f 5c 85 28
	ff ff ff	 subss	 xmm0, DWORD PTR _pad$8[ebp]
  0037b	51		 push	 ecx
  0037c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00381	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _center$[ebp]
  00387	50		 push	 eax
  00388	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0038b	8b 89 74 02 00
	00		 mov	 ecx, DWORD PTR [ecx+628]
  00391	e8 00 00 00 00	 call	 ?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
$LN5@RadioButto:

; 1076 :     }
; 1077 : 
; 1078 :     if (style.FrameBorderSize > 0.0f)

  00396	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00399	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  0039e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003a5	0f 86 d0 00 00
	00		 jbe	 $LN6@RadioButto

; 1079 :     {
; 1080 :         window->DrawList->AddCircle(center + ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);

  003ab	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  003ae	51		 push	 ecx
  003af	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  003b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b9	6a 10		 push	 16			; 00000010H
  003bb	51		 push	 ecx
  003bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c9	6a 06		 push	 6
  003cb	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  003d0	83 c4 08	 add	 esp, 8
  003d3	50		 push	 eax
  003d4	51		 push	 ecx
  003d5	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _radius$[ebp]
  003dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003e2	51		 push	 ecx
  003e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003f0	51		 push	 ecx
  003f1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fe	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00404	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00409	50		 push	 eax
  0040a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _center$[ebp]
  00410	51		 push	 ecx
  00411	8d 95 08 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  00417	52		 push	 edx
  00418	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0041d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00420	50		 push	 eax
  00421	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00424	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  0042a	e8 00 00 00 00	 call	 ?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 1081 :         window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);

  0042f	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00432	51		 push	 ecx
  00433	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  00438	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0043d	6a 10		 push	 16			; 00000010H
  0043f	51		 push	 ecx
  00440	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00448	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0044d	6a 05		 push	 5
  0044f	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00454	83 c4 08	 add	 esp, 8
  00457	50		 push	 eax
  00458	51		 push	 ecx
  00459	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00461	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00466	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _center$[ebp]
  0046c	51		 push	 ecx
  0046d	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  00470	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  00476	e8 00 00 00 00	 call	 ?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle
$LN6@RadioButto:

; 1082 :     }
; 1083 : 
; 1084 :     if (g.LogEnabled)

  0047b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0047e	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  00485	85 c9		 test	 ecx, ecx
  00487	74 36		 je	 SHORT $LN7@RadioButto

; 1085 :         LogRenderedText(&total_bb.Min, active ? "(x)" : "( )");

  00489	0f b6 45 0c	 movzx	 eax, BYTE PTR _active$[ebp]
  0048d	85 c0		 test	 eax, eax
  0048f	74 0c		 je	 SHORT $LN16@RadioButto
  00491	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv255[ebp], OFFSET ??_C@_03KFJJABDB@?$CIx?$CJ@
  0049b	eb 0a		 jmp	 SHORT $LN17@RadioButto
$LN16@RadioButto:
  0049d	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv255[ebp], OFFSET ??_C@_03MHDGHODJ@?$CI?5?$CJ@
$LN17@RadioButto:
  004a7	6a 00		 push	 0
  004a9	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR tv255[ebp]
  004af	51		 push	 ecx
  004b0	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _total_bb$[ebp]
  004b6	52		 push	 edx
  004b7	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z ; ImGui::LogRenderedText
  004bc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@RadioButto:

; 1086 :     if (label_size.x > 0.0f)

  004bf	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  004c4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  004cb	76 48		 jbe	 SHORT $LN8@RadioButto

; 1087 :         RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

  004cd	6a 01		 push	 1
  004cf	6a 00		 push	 0
  004d1	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  004d4	50		 push	 eax
  004d5	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  004d8	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _check_bb$[ebp+4]
  004dd	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  004e2	51		 push	 ecx
  004e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e8	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  004eb	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _check_bb$[ebp+8]
  004f0	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  004f5	51		 push	 ecx
  004f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004fb	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00501	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00506	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00509	51		 push	 ecx
  0050a	8b 10		 mov	 edx, DWORD PTR [eax]
  0050c	52		 push	 edx
  0050d	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  00512	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@RadioButto:

; 1088 : 
; 1089 :     return pressed;

  00515	8a 85 37 ff ff
	ff		 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@RadioButto:

; 1090 : }

  0051b	52		 push	 edx
  0051c	8b cd		 mov	 ecx, ebp
  0051e	50		 push	 eax
  0051f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@RadioButto
  00525	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0052a	58		 pop	 eax
  0052b	5a		 pop	 edx
  0052c	5f		 pop	 edi
  0052d	5e		 pop	 esi
  0052e	5b		 pop	 ebx
  0052f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00532	33 cd		 xor	 ecx, ebp
  00534	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00539	81 c4 14 02 00
	00		 add	 esp, 532		; 00000214H
  0053f	3b ec		 cmp	 ebp, esp
  00541	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00546	8b e5		 mov	 esp, ebp
  00548	5d		 pop	 ebp
  00549	c3		 ret	 0
  0054a	66 90		 npad	 2
$LN26@RadioButto:
  0054c	07 00 00 00	 DD	 7
  00550	00 00 00 00	 DD	 $LN25@RadioButto
$LN25@RadioButto:
  00554	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00558	08 00 00 00	 DD	 8
  0055c	00 00 00 00	 DD	 $LN18@RadioButto
  00560	a4 ff ff ff	 DD	 -92			; ffffffa4H
  00564	08 00 00 00	 DD	 8
  00568	00 00 00 00	 DD	 $LN19@RadioButto
  0056c	8c ff ff ff	 DD	 -116			; ffffff8cH
  00570	10 00 00 00	 DD	 16			; 00000010H
  00574	00 00 00 00	 DD	 $LN20@RadioButto
  00578	74 ff ff ff	 DD	 -140			; ffffff74H
  0057c	10 00 00 00	 DD	 16			; 00000010H
  00580	00 00 00 00	 DD	 $LN21@RadioButto
  00584	64 ff ff ff	 DD	 -156			; ffffff64H
  00588	08 00 00 00	 DD	 8
  0058c	00 00 00 00	 DD	 $LN22@RadioButto
  00590	4f ff ff ff	 DD	 -177			; ffffff4fH
  00594	01 00 00 00	 DD	 1
  00598	00 00 00 00	 DD	 $LN23@RadioButto
  0059c	43 ff ff ff	 DD	 -189			; ffffff43H
  005a0	01 00 00 00	 DD	 1
  005a4	00 00 00 00	 DD	 $LN24@RadioButto
$LN24@RadioButto:
  005a8	68		 DB	 104			; 00000068H
  005a9	65		 DB	 101			; 00000065H
  005aa	6c		 DB	 108			; 0000006cH
  005ab	64		 DB	 100			; 00000064H
  005ac	00		 DB	 0
$LN23@RadioButto:
  005ad	68		 DB	 104			; 00000068H
  005ae	6f		 DB	 111			; 0000006fH
  005af	76		 DB	 118			; 00000076H
  005b0	65		 DB	 101			; 00000065H
  005b1	72		 DB	 114			; 00000072H
  005b2	65		 DB	 101			; 00000065H
  005b3	64		 DB	 100			; 00000064H
  005b4	00		 DB	 0
$LN22@RadioButto:
  005b5	63		 DB	 99			; 00000063H
  005b6	65		 DB	 101			; 00000065H
  005b7	6e		 DB	 110			; 0000006eH
  005b8	74		 DB	 116			; 00000074H
  005b9	65		 DB	 101			; 00000065H
  005ba	72		 DB	 114			; 00000072H
  005bb	00		 DB	 0
$LN21@RadioButto:
  005bc	74		 DB	 116			; 00000074H
  005bd	6f		 DB	 111			; 0000006fH
  005be	74		 DB	 116			; 00000074H
  005bf	61		 DB	 97			; 00000061H
  005c0	6c		 DB	 108			; 0000006cH
  005c1	5f		 DB	 95			; 0000005fH
  005c2	62		 DB	 98			; 00000062H
  005c3	62		 DB	 98			; 00000062H
  005c4	00		 DB	 0
$LN20@RadioButto:
  005c5	63		 DB	 99			; 00000063H
  005c6	68		 DB	 104			; 00000068H
  005c7	65		 DB	 101			; 00000065H
  005c8	63		 DB	 99			; 00000063H
  005c9	6b		 DB	 107			; 0000006bH
  005ca	5f		 DB	 95			; 0000005fH
  005cb	62		 DB	 98			; 00000062H
  005cc	62		 DB	 98			; 00000062H
  005cd	00		 DB	 0
$LN19@RadioButto:
  005ce	70		 DB	 112			; 00000070H
  005cf	6f		 DB	 111			; 0000006fH
  005d0	73		 DB	 115			; 00000073H
  005d1	00		 DB	 0
$LN18@RadioButto:
  005d2	6c		 DB	 108			; 0000006cH
  005d3	61		 DB	 97			; 00000061H
  005d4	62		 DB	 98			; 00000062H
  005d5	65		 DB	 101			; 00000065H
  005d6	6c		 DB	 108			; 0000006cH
  005d7	5f		 DB	 95			; 0000005fH
  005d8	73		 DB	 115			; 00000073H
  005d9	69		 DB	 105			; 00000069H
  005da	7a		 DB	 122			; 0000007aH
  005db	65		 DB	 101			; 00000065H
  005dc	00		 DB	 0
?RadioButton@ImGui@@YA_NPBD_N@Z ENDP			; ImGui::RadioButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?CheckboxFlags@ImGui@@YA_NPBDPAII@Z
_TEXT	SEGMENT
tv66 = -224						; size = 4
_pressed$ = -21						; size = 1
_v$ = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_flags$ = 12						; size = 4
_flags_value$ = 16					; size = 4
?CheckboxFlags@ImGui@@YA_NPBDPAII@Z PROC		; ImGui::CheckboxFlags, COMDAT

; 1027 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1028 :     bool v = ((*flags & flags_value) == flags_value);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	23 4d 10	 and	 ecx, DWORD PTR _flags_value$[ebp]
  0003a	3b 4d 10	 cmp	 ecx, DWORD PTR _flags_value$[ebp]
  0003d	75 0c		 jne	 SHORT $LN6@CheckboxFl
  0003f	c7 85 20 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00049	eb 0a		 jmp	 SHORT $LN7@CheckboxFl
$LN6@CheckboxFl:
  0004b	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN7@CheckboxFl:
  00055	8a 95 20 ff ff
	ff		 mov	 dl, BYTE PTR tv66[ebp]
  0005b	88 55 f7	 mov	 BYTE PTR _v$[ebp], dl

; 1029 :     bool pressed = Checkbox(label, &v);

  0005e	8d 45 f7	 lea	 eax, DWORD PTR _v$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?Checkbox@ImGui@@YA_NPBDPA_N@Z ; ImGui::Checkbox
  0006b	83 c4 08	 add	 esp, 8
  0006e	88 45 eb	 mov	 BYTE PTR _pressed$[ebp], al

; 1030 :     if (pressed)

  00071	0f b6 45 eb	 movzx	 eax, BYTE PTR _pressed$[ebp]
  00075	85 c0		 test	 eax, eax
  00077	74 26		 je	 SHORT $LN2@CheckboxFl

; 1031 :     {
; 1032 :         if (v)

  00079	0f b6 45 f7	 movzx	 eax, BYTE PTR _v$[ebp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 0f		 je	 SHORT $LN3@CheckboxFl

; 1033 :             *flags |= flags_value;

  00081	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	0b 4d 10	 or	 ecx, DWORD PTR _flags_value$[ebp]
  00089	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  0008c	89 0a		 mov	 DWORD PTR [edx], ecx
  0008e	eb 0f		 jmp	 SHORT $LN2@CheckboxFl
$LN3@CheckboxFl:

; 1034 :         else
; 1035 :             *flags &= ~flags_value;

  00090	8b 45 10	 mov	 eax, DWORD PTR _flags_value$[ebp]
  00093	f7 d0		 not	 eax
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00098	23 01		 and	 eax, DWORD PTR [ecx]
  0009a	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  0009d	89 02		 mov	 DWORD PTR [edx], eax
$LN2@CheckboxFl:

; 1036 :     }
; 1037 : 
; 1038 :     return pressed;

  0009f	8a 45 eb	 mov	 al, BYTE PTR _pressed$[ebp]

; 1039 : }

  000a2	52		 push	 edx
  000a3	8b cd		 mov	 ecx, ebp
  000a5	50		 push	 eax
  000a6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@CheckboxFl
  000ac	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000b1	58		 pop	 eax
  000b2	5a		 pop	 edx
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b9	33 cd		 xor	 ecx, ebp
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000c6	3b ec		 cmp	 ebp, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
  000d1	0f 1f 00	 npad	 3
$LN10@CheckboxFl:
  000d4	01 00 00 00	 DD	 1
  000d8	00 00 00 00	 DD	 $LN9@CheckboxFl
$LN9@CheckboxFl:
  000dc	f7 ff ff ff	 DD	 -9			; fffffff7H
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN8@CheckboxFl
$LN8@CheckboxFl:
  000e8	76		 DB	 118			; 00000076H
  000e9	00		 DB	 0
?CheckboxFlags@ImGui@@YA_NPBDPAII@Z ENDP		; ImGui::CheckboxFlags
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Checkbox@ImGui@@YA_NPBDPA_N@Z
_TEXT	SEGMENT
tv183 = -564						; size = 4
tv292 = -560						; size = 4
tv184 = -560						; size = 4
tv155 = -560						; size = 4
tv128 = -560						; size = 4
$T1 = -552						; size = 8
$T2 = -536						; size = 8
$T3 = -520						; size = 8
$T4 = -504						; size = 8
$T5 = -488						; size = 8
$T6 = -472						; size = 8
$T7 = -456						; size = 8
$T8 = -440						; size = 8
$T9 = -424						; size = 8
_pad$10 = -216						; size = 4
_pad$11 = -204						; size = 8
_check_col$ = -188					; size = 4
_check_bb$ = -176					; size = 16
_pressed$ = -149					; size = 1
_held$ = -137						; size = 1
_hovered$ = -125					; size = 1
_total_bb$ = -116					; size = 16
_pos$ = -92						; size = 8
_square_sz$ = -76					; size = 4
_label_size$ = -64					; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
?Checkbox@ImGui@@YA_NPBDPA_N@Z PROC			; ImGui::Checkbox, COMDAT

; 976  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 02 00
	00		 sub	 esp, 564		; 00000234H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc fd ff
	ff		 lea	 edi, DWORD PTR [ebp-564]
  00012	b9 8d 00 00 00	 mov	 ecx, 141		; 0000008dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 977  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 978  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN5@Checkbox

; 979  :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 e8 04 00 00	 jmp	 $LN1@Checkbox
$LN5@Checkbox:

; 980  : 
; 981  :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 982  :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 983  :     const ImGuiID id = window->GetID(label);

  0005f	6a 00		 push	 0
  00061	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00068	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0006d	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 984  :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  00070	51		 push	 ecx
  00071	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00079	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007e	6a 01		 push	 1
  00080	6a 00		 push	 0
  00082	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00085	50		 push	 eax
  00086	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  0008f	83 c4 14	 add	 esp, 20			; 00000014H

; 985  : 
; 986  :     const float square_sz = GetFrameHeight();

  00092	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  00097	d9 5d b4	 fstp	 DWORD PTR _square_sz$[ebp]

; 987  :     const ImVec2 pos = window->DC.CursorPos;

  0009a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0009d	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  000a3	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  000a9	89 4d a4	 mov	 DWORD PTR _pos$[ebp], ecx
  000ac	89 55 a8	 mov	 DWORD PTR _pos$[ebp+4], edx

; 988  :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

  000af	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  000b4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000bb	76 17		 jbe	 SHORT $LN14@Checkbox
  000bd	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000c0	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  000c5	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  000ca	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR tv128[ebp], xmm0
  000d2	eb 0b		 jmp	 SHORT $LN15@Checkbox
$LN14@Checkbox:
  000d4	0f 57 c0	 xorps	 xmm0, xmm0
  000d7	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR tv128[ebp], xmm0
$LN15@Checkbox:
  000df	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  000e2	f3 0f 10 41 3c	 movss	 xmm0, DWORD PTR [ecx+60]
  000e7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000ef	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000f4	51		 push	 ecx
  000f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fa	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  000ff	f3 0f 58 85 d0
	fd ff ff	 addss	 xmm0, DWORD PTR tv128[ebp]
  00107	51		 push	 ecx
  00108	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010d	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00113	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00118	50		 push	 eax
  00119	8d 55 a4	 lea	 edx, DWORD PTR _pos$[ebp]
  0011c	52		 push	 edx
  0011d	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012c	50		 push	 eax
  0012d	8d 4d a4	 lea	 ecx, DWORD PTR _pos$[ebp]
  00130	51		 push	 ecx
  00131	8d 4d 8c	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00134	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 989  :     ItemSize(total_bb, style.FramePadding.y);

  00139	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0013c	51		 push	 ecx
  0013d	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00142	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00147	8d 4d 8c	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  0014a	51		 push	 ecx
  0014b	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  00150	83 c4 08	 add	 esp, 8

; 990  :     if (!ItemAdd(total_bb, id))

  00153	6a 00		 push	 0
  00155	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00158	50		 push	 eax
  00159	8d 4d 8c	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH
  00165	0f b6 d0	 movzx	 edx, al
  00168	85 d2		 test	 edx, edx
  0016a	75 07		 jne	 SHORT $LN6@Checkbox

; 991  :         return false;

  0016c	32 c0		 xor	 al, al
  0016e	e9 c1 03 00 00	 jmp	 $LN1@Checkbox
$LN6@Checkbox:

; 992  : 
; 993  :     bool hovered, held;
; 994  :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

  00173	6a 00		 push	 0
  00175	8d 85 77 ff ff
	ff		 lea	 eax, DWORD PTR _held$[ebp]
  0017b	50		 push	 eax
  0017c	8d 4d 83	 lea	 ecx, DWORD PTR _hovered$[ebp]
  0017f	51		 push	 ecx
  00180	8b 55 d0	 mov	 edx, DWORD PTR _id$[ebp]
  00183	52		 push	 edx
  00184	8d 45 8c	 lea	 eax, DWORD PTR _total_bb$[ebp]
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  0018d	83 c4 14	 add	 esp, 20			; 00000014H
  00190	88 85 6b ff ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 995  :     if (pressed)

  00196	0f b6 85 6b ff
	ff ff		 movzx	 eax, BYTE PTR _pressed$[ebp]
  0019d	85 c0		 test	 eax, eax
  0019f	74 37		 je	 SHORT $LN7@Checkbox

; 996  :     {
; 997  :         *v = !(*v);

  001a1	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  001a4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001a7	85 c9		 test	 ecx, ecx
  001a9	75 0c		 jne	 SHORT $LN16@Checkbox
  001ab	c7 85 d0 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv155[ebp], 1
  001b5	eb 0a		 jmp	 SHORT $LN17@Checkbox
$LN16@Checkbox:
  001b7	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv155[ebp], 0
$LN17@Checkbox:
  001c1	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  001c4	8a 85 d0 fd ff
	ff		 mov	 al, BYTE PTR tv155[ebp]
  001ca	88 02		 mov	 BYTE PTR [edx], al

; 998  :         MarkItemEdited(id);

  001cc	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 ?MarkItemEdited@ImGui@@YAXI@Z ; ImGui::MarkItemEdited
  001d5	83 c4 04	 add	 esp, 4
$LN7@Checkbox:

; 999  :     }
; 1000 : 
; 1001 :     const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));

  001d8	51		 push	 ecx
  001d9	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	51		 push	 ecx
  001e4	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  001f4	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001f9	50		 push	 eax
  001fa	8d 45 a4	 lea	 eax, DWORD PTR _pos$[ebp]
  001fd	50		 push	 eax
  001fe	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0020a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020d	50		 push	 eax
  0020e	8d 55 a4	 lea	 edx, DWORD PTR _pos$[ebp]
  00211	52		 push	 edx
  00212	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _check_bb$[ebp]
  00218	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1002 :     RenderNavHighlight(total_bb, id);

  0021d	6a 01		 push	 1
  0021f	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00222	50		 push	 eax
  00223	8d 4d 8c	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00226	51		 push	 ecx
  00227	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1003 :     RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);

  0022f	0f b6 85 77 ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  00236	85 c0		 test	 eax, eax
  00238	74 14		 je	 SHORT $LN18@Checkbox
  0023a	0f b6 4d 83	 movzx	 ecx, BYTE PTR _hovered$[ebp]
  0023e	85 c9		 test	 ecx, ecx
  00240	74 0c		 je	 SHORT $LN18@Checkbox
  00242	c7 85 d0 fd ff
	ff 09 00 00 00	 mov	 DWORD PTR tv184[ebp], 9
  0024c	eb 2a		 jmp	 SHORT $LN21@Checkbox
$LN18@Checkbox:
  0024e	0f b6 55 83	 movzx	 edx, BYTE PTR _hovered$[ebp]
  00252	85 d2		 test	 edx, edx
  00254	74 0c		 je	 SHORT $LN19@Checkbox
  00256	c7 85 cc fd ff
	ff 08 00 00 00	 mov	 DWORD PTR tv183[ebp], 8
  00260	eb 0a		 jmp	 SHORT $LN20@Checkbox
$LN19@Checkbox:
  00262	c7 85 cc fd ff
	ff 07 00 00 00	 mov	 DWORD PTR tv183[ebp], 7
$LN20@Checkbox:
  0026c	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR tv183[ebp]
  00272	89 85 d0 fd ff
	ff		 mov	 DWORD PTR tv184[ebp], eax
$LN21@Checkbox:
  00278	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  0027b	51		 push	 ecx
  0027c	f3 0f 10 41 40	 movss	 xmm0, DWORD PTR [ecx+64]
  00281	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00286	6a 01		 push	 1
  00288	51		 push	 ecx
  00289	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00291	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00296	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR tv184[ebp]
  0029c	52		 push	 edx
  0029d	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  002a2	83 c4 08	 add	 esp, 8
  002a5	50		 push	 eax
  002a6	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _check_bb$[ebp+12]
  002ac	50		 push	 eax
  002ad	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _check_bb$[ebp+8]
  002b3	51		 push	 ecx
  002b4	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _check_bb$[ebp+4]
  002ba	52		 push	 edx
  002bb	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _check_bb$[ebp]
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  002c7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1004 :     ImU32 check_col = GetColorU32(ImGuiCol_CheckMark);

  002ca	51		 push	 ecx
  002cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d8	6a 12		 push	 18			; 00000012H
  002da	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  002df	83 c4 08	 add	 esp, 8
  002e2	89 85 44 ff ff
	ff		 mov	 DWORD PTR _check_col$[ebp], eax

; 1005 :     if (window->DC.ItemFlags & ImGuiItemFlags_MixedValue)

  002e8	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  002eb	8b 88 6c 01 00
	00		 mov	 ecx, DWORD PTR [eax+364]
  002f1	83 e1 40	 and	 ecx, 64			; 00000040H
  002f4	0f 84 d9 00 00
	00		 je	 $LN8@Checkbox

; 1006 :     {
; 1007 :         // Undocumented tristate/mixed/indeterminate checkbox (#2644)
; 1008 :         ImVec2 pad(ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)), ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)));

  002fa	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  002ff	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40666666
  00307	f3 0f 2c c0	 cvttss2si eax, xmm0
  0030b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0030f	51		 push	 ecx
  00310	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00315	51		 push	 ecx
  00316	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0031e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00323	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00328	83 c4 04	 add	 esp, 4
  0032b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0032e	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  00333	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40666666
  0033b	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0033f	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00343	51		 push	 ecx
  00344	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00349	51		 push	 ecx
  0034a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00352	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00357	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0035c	83 c4 04	 add	 esp, 4
  0035f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00362	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _pad$11[ebp]
  00368	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1009 :         window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);

  0036d	6a 0f		 push	 15			; 0000000fH
  0036f	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00372	51		 push	 ecx
  00373	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00378	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0037d	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _check_col$[ebp]
  00383	51		 push	 ecx
  00384	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _pad$11[ebp]
  0038a	52		 push	 edx
  0038b	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _check_bb$[ebp+8]
  00391	50		 push	 eax
  00392	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00398	51		 push	 ecx
  00399	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  0039e	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a1	50		 push	 eax
  003a2	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR _pad$11[ebp]
  003a8	52		 push	 edx
  003a9	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _check_bb$[ebp]
  003af	50		 push	 eax
  003b0	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003b6	51		 push	 ecx
  003b7	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  003bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  003bf	50		 push	 eax
  003c0	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  003c3	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  003c9	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1010 :     }

  003ce	e9 b8 00 00 00	 jmp	 $LN10@Checkbox
$LN8@Checkbox:

; 1011 :     else if (*v)

  003d3	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  003d6	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  003d9	85 c9		 test	 ecx, ecx
  003db	0f 84 aa 00 00
	00		 je	 $LN10@Checkbox

; 1012 :     {
; 1013 :         const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));

  003e1	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _square_sz$[ebp]
  003e6	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40c00000
  003ee	f3 0f 2c c0	 cvttss2si eax, xmm0
  003f2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003f6	51		 push	 ecx
  003f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fc	51		 push	 ecx
  003fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00405	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0040a	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0040f	83 c4 08	 add	 esp, 8
  00412	d9 9d 28 ff ff
	ff		 fstp	 DWORD PTR _pad$10[ebp]

; 1014 :         RenderCheckMark(check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad*2.0f);

  00418	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _pad$10[ebp]
  00420	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00428	f3 0f 10 4d b4	 movss	 xmm1, DWORD PTR _square_sz$[ebp]
  0042d	f3 0f 5c c8	 subss	 xmm1, xmm0
  00431	51		 push	 ecx
  00432	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00437	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _check_col$[ebp]
  0043d	50		 push	 eax
  0043e	51		 push	 ecx
  0043f	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _pad$10[ebp]
  00447	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0044c	51		 push	 ecx
  0044d	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _pad$10[ebp]
  00455	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0045a	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00460	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00465	50		 push	 eax
  00466	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR _check_bb$[ebp]
  0046c	51		 push	 ecx
  0046d	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  00473	52		 push	 edx
  00474	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00479	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0047f	51		 push	 ecx
  00480	8b 10		 mov	 edx, DWORD PTR [eax]
  00482	52		 push	 edx
  00483	e8 00 00 00 00	 call	 ?RenderCheckMark@ImGui@@YAXUImVec2@@IM@Z ; ImGui::RenderCheckMark
  00488	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@Checkbox:

; 1015 :     }
; 1016 : 
; 1017 :     if (g.LogEnabled)

  0048b	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0048e	0f b6 88 58 2d
	00 00		 movzx	 ecx, BYTE PTR [eax+11608]
  00495	85 c9		 test	 ecx, ecx
  00497	74 35		 je	 SHORT $LN11@Checkbox

; 1018 :         LogRenderedText(&total_bb.Min, *v ? "[x]" : "[ ]");

  00499	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0049c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0049f	85 c9		 test	 ecx, ecx
  004a1	74 0c		 je	 SHORT $LN22@Checkbox
  004a3	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv292[ebp], OFFSET ??_C@_03JHEALCLB@?$FLx?$FN@
  004ad	eb 0a		 jmp	 SHORT $LN23@Checkbox
$LN22@Checkbox:
  004af	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv292[ebp], OFFSET ??_C@_03PFOPMNLJ@?$FL?5?$FN@
$LN23@Checkbox:
  004b9	6a 00		 push	 0
  004bb	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR tv292[ebp]
  004c1	52		 push	 edx
  004c2	8d 45 8c	 lea	 eax, DWORD PTR _total_bb$[ebp]
  004c5	50		 push	 eax
  004c6	e8 00 00 00 00	 call	 ?LogRenderedText@ImGui@@YAXPBUImVec2@@PBD1@Z ; ImGui::LogRenderedText
  004cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@Checkbox:

; 1019 :     if (label_size.x > 0.0f)

  004ce	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  004d3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  004da	76 4e		 jbe	 SHORT $LN12@Checkbox

; 1020 :         RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);

  004dc	6a 01		 push	 1
  004de	6a 00		 push	 0
  004e0	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  004e3	50		 push	 eax
  004e4	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  004e7	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _check_bb$[ebp+4]
  004ef	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  004f4	51		 push	 ecx
  004f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004fa	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  004fd	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _check_bb$[ebp+8]
  00505	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  0050a	51		 push	 ecx
  0050b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00510	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00516	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0051b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0051e	51		 push	 ecx
  0051f	8b 10		 mov	 edx, DWORD PTR [eax]
  00521	52		 push	 edx
  00522	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  00527	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@Checkbox:

; 1021 : 
; 1022 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));

  0052a	33 c0		 xor	 eax, eax
  0052c	75 fc		 jne	 SHORT $LN12@Checkbox

; 1023 :     return pressed;

  0052e	8a 85 6b ff ff
	ff		 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@Checkbox:

; 1024 : }

  00534	52		 push	 edx
  00535	8b cd		 mov	 ecx, ebp
  00537	50		 push	 eax
  00538	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@Checkbox
  0053e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00543	58		 pop	 eax
  00544	5a		 pop	 edx
  00545	5f		 pop	 edi
  00546	5e		 pop	 esi
  00547	5b		 pop	 ebx
  00548	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054b	33 cd		 xor	 ecx, ebp
  0054d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00552	81 c4 34 02 00
	00		 add	 esp, 564		; 00000234H
  00558	3b ec		 cmp	 ebp, esp
  0055a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0055f	8b e5		 mov	 esp, ebp
  00561	5d		 pop	 ebp
  00562	c3		 ret	 0
  00563	90		 npad	 1
$LN32@Checkbox:
  00564	07 00 00 00	 DD	 7
  00568	00 00 00 00	 DD	 $LN31@Checkbox
$LN31@Checkbox:
  0056c	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00570	08 00 00 00	 DD	 8
  00574	00 00 00 00	 DD	 $LN24@Checkbox
  00578	a4 ff ff ff	 DD	 -92			; ffffffa4H
  0057c	08 00 00 00	 DD	 8
  00580	00 00 00 00	 DD	 $LN25@Checkbox
  00584	8c ff ff ff	 DD	 -116			; ffffff8cH
  00588	10 00 00 00	 DD	 16			; 00000010H
  0058c	00 00 00 00	 DD	 $LN26@Checkbox
  00590	83 ff ff ff	 DD	 -125			; ffffff83H
  00594	01 00 00 00	 DD	 1
  00598	00 00 00 00	 DD	 $LN27@Checkbox
  0059c	77 ff ff ff	 DD	 -137			; ffffff77H
  005a0	01 00 00 00	 DD	 1
  005a4	00 00 00 00	 DD	 $LN28@Checkbox
  005a8	50 ff ff ff	 DD	 -176			; ffffff50H
  005ac	10 00 00 00	 DD	 16			; 00000010H
  005b0	00 00 00 00	 DD	 $LN29@Checkbox
  005b4	34 ff ff ff	 DD	 -204			; ffffff34H
  005b8	08 00 00 00	 DD	 8
  005bc	00 00 00 00	 DD	 $LN30@Checkbox
$LN30@Checkbox:
  005c0	70		 DB	 112			; 00000070H
  005c1	61		 DB	 97			; 00000061H
  005c2	64		 DB	 100			; 00000064H
  005c3	00		 DB	 0
$LN29@Checkbox:
  005c4	63		 DB	 99			; 00000063H
  005c5	68		 DB	 104			; 00000068H
  005c6	65		 DB	 101			; 00000065H
  005c7	63		 DB	 99			; 00000063H
  005c8	6b		 DB	 107			; 0000006bH
  005c9	5f		 DB	 95			; 0000005fH
  005ca	62		 DB	 98			; 00000062H
  005cb	62		 DB	 98			; 00000062H
  005cc	00		 DB	 0
$LN28@Checkbox:
  005cd	68		 DB	 104			; 00000068H
  005ce	65		 DB	 101			; 00000065H
  005cf	6c		 DB	 108			; 0000006cH
  005d0	64		 DB	 100			; 00000064H
  005d1	00		 DB	 0
$LN27@Checkbox:
  005d2	68		 DB	 104			; 00000068H
  005d3	6f		 DB	 111			; 0000006fH
  005d4	76		 DB	 118			; 00000076H
  005d5	65		 DB	 101			; 00000065H
  005d6	72		 DB	 114			; 00000072H
  005d7	65		 DB	 101			; 00000065H
  005d8	64		 DB	 100			; 00000064H
  005d9	00		 DB	 0
$LN26@Checkbox:
  005da	74		 DB	 116			; 00000074H
  005db	6f		 DB	 111			; 0000006fH
  005dc	74		 DB	 116			; 00000074H
  005dd	61		 DB	 97			; 00000061H
  005de	6c		 DB	 108			; 0000006cH
  005df	5f		 DB	 95			; 0000005fH
  005e0	62		 DB	 98			; 00000062H
  005e1	62		 DB	 98			; 00000062H
  005e2	00		 DB	 0
$LN25@Checkbox:
  005e3	70		 DB	 112			; 00000070H
  005e4	6f		 DB	 111			; 0000006fH
  005e5	73		 DB	 115			; 00000073H
  005e6	00		 DB	 0
$LN24@Checkbox:
  005e7	6c		 DB	 108			; 0000006cH
  005e8	61		 DB	 97			; 00000061H
  005e9	62		 DB	 98			; 00000062H
  005ea	65		 DB	 101			; 00000065H
  005eb	6c		 DB	 108			; 0000006cH
  005ec	5f		 DB	 95			; 0000005fH
  005ed	73		 DB	 115			; 00000073H
  005ee	69		 DB	 105			; 00000069H
  005ef	7a		 DB	 122			; 0000007aH
  005f0	65		 DB	 101			; 00000065H
  005f1	00		 DB	 0
?Checkbox@ImGui@@YA_NPBDPA_N@Z ENDP			; ImGui::Checkbox
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z
_TEXT	SEGMENT
tv177 = -504						; size = 4
tv178 = -500						; size = 4
tv83 = -500						; size = 4
$T1 = -492						; size = 8
$T2 = -476						; size = 8
$T3 = -460						; size = 8
$T4 = -444						; size = 8
$T5 = -428						; size = 8
$T6 = -412						; size = 8
$T7 = -396						; size = 8
$T8 = -380						; size = 8
$T9 = -364						; size = 4
_col$ = -160						; size = 4
_pressed$ = -145					; size = 1
_held$ = -133						; size = 1
_hovered$ = -121					; size = 1
_image_bb$ = -112					; size = 16
_bb$ = -88						; size = 16
_padding$ = -64						; size = 8
_id$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_user_texture_id$ = 8					; size = 4
_size$ = 12						; size = 4
_uv0$ = 16						; size = 4
_uv1$ = 20						; size = 4
_frame_padding$ = 24					; size = 4
_bg_col$ = 28						; size = 4
_tint_col$ = 32						; size = 4
?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z PROC ; ImGui::ImageButton, COMDAT

; 940  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 01 00
	00		 sub	 esp, 504		; 000001f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-504]
  00012	b9 7e 00 00 00	 mov	 ecx, 126		; 0000007eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 941  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 942  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@ImageButto

; 943  :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 0d 03 00 00	 jmp	 $LN1@ImageButto
$LN2@ImageButto:

; 944  : 
; 945  :     ImGuiContext& g = *GImGui;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00051	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 946  :     const ImGuiStyle& style = g.Style;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00057	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005c	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 947  : 
; 948  :     // Default to using texture ID as ID. User can still push string/integer prefixes.
; 949  :     // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
; 950  :     PushID((void*)(intptr_t)user_texture_id);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _user_texture_id$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPBX@Z	; ImGui::PushID
  00068	83 c4 04	 add	 esp, 4

; 951  :     const ImGuiID id = window->GetID("#image");

  0006b	6a 00		 push	 0
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_06EBHDMMP@?$CDimage@
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00075	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  0007a	89 45 d0	 mov	 DWORD PTR _id$[ebp], eax

; 952  :     PopID();

  0007d	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 953  : 
; 954  :     const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;

  00082	83 7d 18 00	 cmp	 DWORD PTR _frame_padding$[ebp], 0
  00086	7c 29		 jl	 SHORT $LN6@ImageButto
  00088	f3 0f 2a 45 18	 cvtsi2ss xmm0, DWORD PTR _frame_padding$[ebp]
  0008d	51		 push	 ecx
  0008e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00093	f3 0f 2a 45 18	 cvtsi2ss xmm0, DWORD PTR _frame_padding$[ebp]
  00098	51		 push	 ecx
  00099	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009e	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  000a4	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000a9	89 85 0c fe ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  000af	eb 21		 jmp	 SHORT $LN7@ImageButto
$LN6@ImageButto:
  000b1	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000b4	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b7	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  000ba	89 8d 74 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], ecx
  000c0	89 95 78 fe ff
	ff		 mov	 DWORD PTR $T7[ebp+4], edx
  000c6	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  000cc	89 85 0c fe ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
$LN7@ImageButto:
  000d2	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR tv83[ebp]
  000d8	89 8d 94 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], ecx
  000de	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR $T9[ebp]
  000e4	8b 02		 mov	 eax, DWORD PTR [edx]
  000e6	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e9	89 45 c0	 mov	 DWORD PTR _padding$[ebp], eax
  000ec	89 4d c4	 mov	 DWORD PTR _padding$[ebp+4], ecx

; 955  :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);

  000ef	51		 push	 ecx
  000f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fd	8d 45 c0	 lea	 eax, DWORD PTR _padding$[ebp]
  00100	50		 push	 eax
  00101	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00107	51		 push	 ecx
  00108	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00110	50		 push	 eax
  00111	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00114	52		 push	 edx
  00115	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00118	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0011d	50		 push	 eax
  0011e	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012d	50		 push	 eax
  0012e	8d 95 44 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013d	50		 push	 eax
  0013e	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00141	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  00146	50		 push	 eax
  00147	8d 4d a8	 lea	 ecx, DWORD PTR _bb$[ebp]
  0014a	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 956  :     const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);

  0014f	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00152	50		 push	 eax
  00153	8d 4d c0	 lea	 ecx, DWORD PTR _padding$[ebp]
  00156	51		 push	 ecx
  00157	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  0015a	81 c2 c8 00 00
	00		 add	 edx, 200		; 000000c8H
  00160	52		 push	 edx
  00161	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0016d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00170	50		 push	 eax
  00171	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00180	50		 push	 eax
  00181	8d 55 c0	 lea	 edx, DWORD PTR _padding$[ebp]
  00184	52		 push	 edx
  00185	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00188	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0018d	50		 push	 eax
  0018e	8d 8d 14 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019d	50		 push	 eax
  0019e	8d 4d 90	 lea	 ecx, DWORD PTR _image_bb$[ebp]
  001a1	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 957  :     ItemSize(bb);

  001a6	51		 push	 ecx
  001a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b4	8d 45 a8	 lea	 eax, DWORD PTR _bb$[ebp]
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  001bd	83 c4 08	 add	 esp, 8

; 958  :     if (!ItemAdd(bb, id))

  001c0	6a 00		 push	 0
  001c2	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  001c5	50		 push	 eax
  001c6	8d 4d a8	 lea	 ecx, DWORD PTR _bb$[ebp]
  001c9	51		 push	 ecx
  001ca	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d2	0f b6 d0	 movzx	 edx, al
  001d5	85 d2		 test	 edx, edx
  001d7	75 07		 jne	 SHORT $LN3@ImageButto

; 959  :         return false;

  001d9	32 c0		 xor	 al, al
  001db	e9 79 01 00 00	 jmp	 $LN1@ImageButto
$LN3@ImageButto:

; 960  : 
; 961  :     bool hovered, held;
; 962  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

  001e0	6a 00		 push	 0
  001e2	8d 85 7b ff ff
	ff		 lea	 eax, DWORD PTR _held$[ebp]
  001e8	50		 push	 eax
  001e9	8d 4d 87	 lea	 ecx, DWORD PTR _hovered$[ebp]
  001ec	51		 push	 ecx
  001ed	8b 55 d0	 mov	 edx, DWORD PTR _id$[ebp]
  001f0	52		 push	 edx
  001f1	8d 45 a8	 lea	 eax, DWORD PTR _bb$[ebp]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  001fa	83 c4 14	 add	 esp, 20			; 00000014H
  001fd	88 85 6f ff ff
	ff		 mov	 BYTE PTR _pressed$[ebp], al

; 963  : 
; 964  :     // Render
; 965  :     const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

  00203	0f b6 85 7b ff
	ff ff		 movzx	 eax, BYTE PTR _held$[ebp]
  0020a	85 c0		 test	 eax, eax
  0020c	74 14		 je	 SHORT $LN8@ImageButto
  0020e	0f b6 4d 87	 movzx	 ecx, BYTE PTR _hovered$[ebp]
  00212	85 c9		 test	 ecx, ecx
  00214	74 0c		 je	 SHORT $LN8@ImageButto
  00216	c7 85 0c fe ff
	ff 17 00 00 00	 mov	 DWORD PTR tv178[ebp], 23 ; 00000017H
  00220	eb 2a		 jmp	 SHORT $LN11@ImageButto
$LN8@ImageButto:
  00222	0f b6 55 87	 movzx	 edx, BYTE PTR _hovered$[ebp]
  00226	85 d2		 test	 edx, edx
  00228	74 0c		 je	 SHORT $LN9@ImageButto
  0022a	c7 85 08 fe ff
	ff 16 00 00 00	 mov	 DWORD PTR tv177[ebp], 22 ; 00000016H
  00234	eb 0a		 jmp	 SHORT $LN10@ImageButto
$LN9@ImageButto:
  00236	c7 85 08 fe ff
	ff 15 00 00 00	 mov	 DWORD PTR tv177[ebp], 21 ; 00000015H
$LN10@ImageButto:
  00240	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR tv177[ebp]
  00246	89 85 0c fe ff
	ff		 mov	 DWORD PTR tv178[ebp], eax
$LN11@ImageButto:
  0024c	51		 push	 ecx
  0024d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00255	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025a	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR tv178[ebp]
  00260	51		 push	 ecx
  00261	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  00266	83 c4 08	 add	 esp, 8
  00269	89 85 60 ff ff
	ff		 mov	 DWORD PTR _col$[ebp], eax

; 966  :     RenderNavHighlight(bb, id);

  0026f	6a 01		 push	 1
  00271	8b 45 d0	 mov	 eax, DWORD PTR _id$[ebp]
  00274	50		 push	 eax
  00275	8d 4d a8	 lea	 ecx, DWORD PTR _bb$[ebp]
  00278	51		 push	 ecx
  00279	e8 00 00 00 00	 call	 ?RenderNavHighlight@ImGui@@YAXABUImRect@@IH@Z ; ImGui::RenderNavHighlight
  0027e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 967  :     RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));

  00281	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00284	51		 push	 ecx
  00285	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  0028a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028f	51		 push	 ecx
  00290	0f 57 c0	 xorps	 xmm0, xmm0
  00293	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00298	51		 push	 ecx
  00299	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _padding$[ebp+4]
  0029e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a3	51		 push	 ecx
  002a4	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _padding$[ebp]
  002a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ae	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  002b3	83 c4 04	 add	 esp, 4
  002b6	d9 1c 24	 fstp	 DWORD PTR [esp]
  002b9	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  002be	83 c4 08	 add	 esp, 8
  002c1	d9 1c 24	 fstp	 DWORD PTR [esp]
  002c4	6a 01		 push	 1
  002c6	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _col$[ebp]
  002cc	51		 push	 ecx
  002cd	8b 55 b4	 mov	 edx, DWORD PTR _bb$[ebp+12]
  002d0	52		 push	 edx
  002d1	8b 45 b0	 mov	 eax, DWORD PTR _bb$[ebp+8]
  002d4	50		 push	 eax
  002d5	8b 4d ac	 mov	 ecx, DWORD PTR _bb$[ebp+4]
  002d8	51		 push	 ecx
  002d9	8b 55 a8	 mov	 edx, DWORD PTR _bb$[ebp]
  002dc	52		 push	 edx
  002dd	e8 00 00 00 00	 call	 ?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ; ImGui::RenderFrame
  002e2	83 c4 1c	 add	 esp, 28			; 0000001cH

; 968  :     if (bg_col.w > 0.0f)

  002e5	8b 45 1c	 mov	 eax, DWORD PTR _bg_col$[ebp]
  002e8	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  002ed	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002f4	76 2e		 jbe	 SHORT $LN4@ImageButto

; 969  :         window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));

  002f6	6a 0f		 push	 15			; 0000000fH
  002f8	51		 push	 ecx
  002f9	0f 57 c0	 xorps	 xmm0, xmm0
  002fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00301	8b 45 1c	 mov	 eax, DWORD PTR _bg_col$[ebp]
  00304	50		 push	 eax
  00305	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  0030a	83 c4 04	 add	 esp, 4
  0030d	50		 push	 eax
  0030e	8d 4d 98	 lea	 ecx, DWORD PTR _image_bb$[ebp+8]
  00311	51		 push	 ecx
  00312	8d 55 90	 lea	 edx, DWORD PTR _image_bb$[ebp]
  00315	52		 push	 edx
  00316	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00319	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  0031f	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN4@ImageButto:

; 970  :     window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

  00324	8b 45 20	 mov	 eax, DWORD PTR _tint_col$[ebp]
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  0032d	83 c4 04	 add	 esp, 4
  00330	50		 push	 eax
  00331	8b 4d 14	 mov	 ecx, DWORD PTR _uv1$[ebp]
  00334	51		 push	 ecx
  00335	8b 55 10	 mov	 edx, DWORD PTR _uv0$[ebp]
  00338	52		 push	 edx
  00339	8d 45 98	 lea	 eax, DWORD PTR _image_bb$[ebp+8]
  0033c	50		 push	 eax
  0033d	8d 4d 90	 lea	 ecx, DWORD PTR _image_bb$[ebp]
  00340	51		 push	 ecx
  00341	8b 55 08	 mov	 edx, DWORD PTR _user_texture_id$[ebp]
  00344	52		 push	 edx
  00345	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00348	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  0034e	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 971  : 
; 972  :     return pressed;

  00353	8a 85 6f ff ff
	ff		 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@ImageButto:

; 973  : }

  00359	52		 push	 edx
  0035a	8b cd		 mov	 ecx, ebp
  0035c	50		 push	 eax
  0035d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@ImageButto
  00363	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00368	58		 pop	 eax
  00369	5a		 pop	 edx
  0036a	5f		 pop	 edi
  0036b	5e		 pop	 esi
  0036c	5b		 pop	 ebx
  0036d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00370	33 cd		 xor	 ecx, ebp
  00372	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00377	81 c4 f8 01 00
	00		 add	 esp, 504		; 000001f8H
  0037d	3b ec		 cmp	 ebp, esp
  0037f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00384	8b e5		 mov	 esp, ebp
  00386	5d		 pop	 ebp
  00387	c3		 ret	 0
$LN18@ImageButto:
  00388	05 00 00 00	 DD	 5
  0038c	00 00 00 00	 DD	 $LN17@ImageButto
$LN17@ImageButto:
  00390	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00394	08 00 00 00	 DD	 8
  00398	00 00 00 00	 DD	 $LN12@ImageButto
  0039c	a8 ff ff ff	 DD	 -88			; ffffffa8H
  003a0	10 00 00 00	 DD	 16			; 00000010H
  003a4	00 00 00 00	 DD	 $LN13@ImageButto
  003a8	90 ff ff ff	 DD	 -112			; ffffff90H
  003ac	10 00 00 00	 DD	 16			; 00000010H
  003b0	00 00 00 00	 DD	 $LN14@ImageButto
  003b4	87 ff ff ff	 DD	 -121			; ffffff87H
  003b8	01 00 00 00	 DD	 1
  003bc	00 00 00 00	 DD	 $LN15@ImageButto
  003c0	7b ff ff ff	 DD	 -133			; ffffff7bH
  003c4	01 00 00 00	 DD	 1
  003c8	00 00 00 00	 DD	 $LN16@ImageButto
$LN16@ImageButto:
  003cc	68		 DB	 104			; 00000068H
  003cd	65		 DB	 101			; 00000065H
  003ce	6c		 DB	 108			; 0000006cH
  003cf	64		 DB	 100			; 00000064H
  003d0	00		 DB	 0
$LN15@ImageButto:
  003d1	68		 DB	 104			; 00000068H
  003d2	6f		 DB	 111			; 0000006fH
  003d3	76		 DB	 118			; 00000076H
  003d4	65		 DB	 101			; 00000065H
  003d5	72		 DB	 114			; 00000072H
  003d6	65		 DB	 101			; 00000065H
  003d7	64		 DB	 100			; 00000064H
  003d8	00		 DB	 0
$LN14@ImageButto:
  003d9	69		 DB	 105			; 00000069H
  003da	6d		 DB	 109			; 0000006dH
  003db	61		 DB	 97			; 00000061H
  003dc	67		 DB	 103			; 00000067H
  003dd	65		 DB	 101			; 00000065H
  003de	5f		 DB	 95			; 0000005fH
  003df	62		 DB	 98			; 00000062H
  003e0	62		 DB	 98			; 00000062H
  003e1	00		 DB	 0
$LN13@ImageButto:
  003e2	62		 DB	 98			; 00000062H
  003e3	62		 DB	 98			; 00000062H
  003e4	00		 DB	 0
$LN12@ImageButto:
  003e5	70		 DB	 112			; 00000070H
  003e6	61		 DB	 97			; 00000061H
  003e7	64		 DB	 100			; 00000064H
  003e8	64		 DB	 100			; 00000064H
  003e9	69		 DB	 105			; 00000069H
  003ea	6e		 DB	 110			; 0000006eH
  003eb	67		 DB	 103			; 00000067H
  003ec	00		 DB	 0
?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z ENDP ; ImGui::ImageButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z
_TEXT	SEGMENT
$T1 = -324						; size = 8
$T2 = -308						; size = 8
$T3 = -292						; size = 8
$T4 = -276						; size = 8
$T5 = -260						; size = 8
$T6 = -244						; size = 8
_bb$ = -36						; size = 16
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_user_texture_id$ = 8					; size = 4
_size$ = 12						; size = 4
_uv0$ = 16						; size = 4
_uv1$ = 20						; size = 4
_tint_col$ = 24						; size = 4
_border_col$ = 28					; size = 4
?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z PROC	; ImGui::Image, COMDAT

; 912  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00012	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 913  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 914  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN2@Image

; 915  :         return;

  00045	e9 cb 01 00 00	 jmp	 $LN1@Image
$LN2@Image:

; 916  : 
; 917  :     ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  00051	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  00057	51		 push	 ecx
  00058	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	50		 push	 eax
  00068	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0006b	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  00070	50		 push	 eax
  00071	8d 4d dc	 lea	 ecx, DWORD PTR _bb$[ebp]
  00074	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 918  :     if (border_col.w > 0.0f)

  00079	8b 45 1c	 mov	 eax, DWORD PTR _border_col$[ebp]
  0007c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00081	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00088	76 34		 jbe	 SHORT $LN3@Image

; 919  :         bb.Max += ImVec2(2, 2);

  0008a	51		 push	 ecx
  0008b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00093	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00098	51		 push	 ecx
  00099	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000ac	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000b1	50		 push	 eax
  000b2	8d 45 e4	 lea	 eax, DWORD PTR _bb$[ebp+8]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??Y@YAAAUImVec2@@AAU0@ABU0@@Z ; operator+=
  000bb	83 c4 08	 add	 esp, 8
$LN3@Image:

; 920  :     ItemSize(bb);

  000be	51		 push	 ecx
  000bf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cc	8d 45 dc	 lea	 eax, DWORD PTR _bb$[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  000d5	83 c4 08	 add	 esp, 8

; 921  :     if (!ItemAdd(bb, 0))

  000d8	6a 00		 push	 0
  000da	6a 00		 push	 0
  000dc	8d 45 dc	 lea	 eax, DWORD PTR _bb$[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e8	0f b6 c8	 movzx	 ecx, al
  000eb	85 c9		 test	 ecx, ecx
  000ed	75 05		 jne	 SHORT $LN4@Image

; 922  :         return;

  000ef	e9 21 01 00 00	 jmp	 $LN1@Image
$LN4@Image:

; 923  : 
; 924  :     if (border_col.w > 0.0f)

  000f4	8b 45 1c	 mov	 eax, DWORD PTR _border_col$[ebp]
  000f7	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000fc	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00103	0f 86 dd 00 00
	00		 jbe	 $LN5@Image

; 925  :     {
; 926  :         window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);

  00109	51		 push	 ecx
  0010a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00112	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00117	6a 0f		 push	 15			; 0000000fH
  00119	51		 push	 ecx
  0011a	0f 57 c0	 xorps	 xmm0, xmm0
  0011d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00122	8b 45 1c	 mov	 eax, DWORD PTR _border_col$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  0012b	83 c4 04	 add	 esp, 4
  0012e	50		 push	 eax
  0012f	8d 4d e4	 lea	 ecx, DWORD PTR _bb$[ebp+8]
  00132	51		 push	 ecx
  00133	8d 55 dc	 lea	 edx, DWORD PTR _bb$[ebp]
  00136	52		 push	 edx
  00137	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0013a	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00140	e8 00 00 00 00	 call	 ?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 927  :         window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));

  00145	8b 45 18	 mov	 eax, DWORD PTR _tint_col$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  0014e	83 c4 04	 add	 esp, 4
  00151	50		 push	 eax
  00152	8b 4d 14	 mov	 ecx, DWORD PTR _uv1$[ebp]
  00155	51		 push	 ecx
  00156	8b 55 10	 mov	 edx, DWORD PTR _uv0$[ebp]
  00159	52		 push	 edx
  0015a	51		 push	 ecx
  0015b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00163	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00168	51		 push	 ecx
  00169	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00171	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00176	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0017c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00181	50		 push	 eax
  00182	8d 45 e4	 lea	 eax, DWORD PTR _bb$[ebp+8]
  00185	50		 push	 eax
  00186	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH
  00195	50		 push	 eax
  00196	51		 push	 ecx
  00197	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a4	51		 push	 ecx
  001a5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b2	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001b8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001bd	50		 push	 eax
  001be	8d 55 dc	 lea	 edx, DWORD PTR _bb$[ebp]
  001c1	52		 push	 edx
  001c2	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  001ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d1	50		 push	 eax
  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _user_texture_id$[ebp]
  001d5	51		 push	 ecx
  001d6	8b 55 f4	 mov	 edx, DWORD PTR _window$[ebp]
  001d9	8b 8a 74 02 00
	00		 mov	 ecx, DWORD PTR [edx+628]
  001df	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 928  :     }

  001e4	eb 2f		 jmp	 SHORT $LN6@Image
$LN5@Image:

; 929  :     else
; 930  :     {
; 931  :         window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));

  001e6	8b 45 18	 mov	 eax, DWORD PTR _tint_col$[ebp]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::GetColorU32
  001ef	83 c4 04	 add	 esp, 4
  001f2	50		 push	 eax
  001f3	8b 4d 14	 mov	 ecx, DWORD PTR _uv1$[ebp]
  001f6	51		 push	 ecx
  001f7	8b 55 10	 mov	 edx, DWORD PTR _uv0$[ebp]
  001fa	52		 push	 edx
  001fb	8d 45 e4	 lea	 eax, DWORD PTR _bb$[ebp+8]
  001fe	50		 push	 eax
  001ff	8d 4d dc	 lea	 ecx, DWORD PTR _bb$[ebp]
  00202	51		 push	 ecx
  00203	8b 55 08	 mov	 edx, DWORD PTR _user_texture_id$[ebp]
  00206	52		 push	 edx
  00207	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0020a	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  00210	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage
$LN6@Image:
$LN1@Image:

; 932  :     }
; 933  : }

  00215	52		 push	 edx
  00216	8b cd		 mov	 ecx, ebp
  00218	50		 push	 eax
  00219	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@Image
  0021f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00224	58		 pop	 eax
  00225	5a		 pop	 edx
  00226	5f		 pop	 edi
  00227	5e		 pop	 esi
  00228	5b		 pop	 ebx
  00229	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022c	33 cd		 xor	 ecx, ebp
  0022e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00233	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  00239	3b ec		 cmp	 ebp, esp
  0023b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c3		 ret	 0
$LN10@Image:
  00244	01 00 00 00	 DD	 1
  00248	00 00 00 00	 DD	 $LN9@Image
$LN9@Image:
  0024c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00250	10 00 00 00	 DD	 16			; 00000010H
  00254	00 00 00 00	 DD	 $LN8@Image
$LN8@Image:
  00258	62		 DB	 98			; 00000062H
  00259	62		 DB	 98			; 00000062H
  0025a	00		 DB	 0
?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z ENDP	; ImGui::Image
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?ArrowButton@ImGui@@YA_NPBDH@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_sz$ = -8						; size = 4
_str_id$ = 8						; size = 4
_dir$ = 12						; size = 4
?ArrowButton@ImGui@@YA_NPBDH@Z PROC			; ImGui::ArrowButton, COMDAT

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 717  :     float sz = GetFrameHeight();

  00028	e8 00 00 00 00	 call	 ?GetFrameHeight@ImGui@@YAMXZ ; ImGui::GetFrameHeight
  0002d	d9 5d f8	 fstp	 DWORD PTR _sz$[ebp]

; 718  :     return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);

  00030	6a 00		 push	 0
  00032	51		 push	 ecx
  00033	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _sz$[ebp]
  00038	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003d	51		 push	 ecx
  0003e	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _sz$[ebp]
  00043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00048	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	51		 push	 ecx
  00057	8b 10		 mov	 edx, DWORD PTR [eax]
  00059	52		 push	 edx
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _str_id$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?ArrowButtonEx@ImGui@@YA_NPBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx
  00067	83 c4 14	 add	 esp, 20			; 00000014H

; 719  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?ArrowButton@ImGui@@YA_NPBDH@Z ENDP			; ImGui::ArrowButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z
_TEXT	SEGMENT
$T1 = -308						; size = 8
_pressed$ = -97						; size = 1
_held$ = -85						; size = 1
_hovered$ = -73						; size = 1
_bb$ = -64						; size = 16
_size$ = -40						; size = 8
_id$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_str_id$ = 8						; size = 4
_size_arg$ = 12						; size = 4
?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z PROC	; ImGui::InvisibleButton, COMDAT

; 664  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00012	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 665  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 666  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 07		 je	 SHORT $LN2@InvisibleB

; 667  :         return false;

  00045	32 c0		 xor	 al, al
  00047	e9 0e 01 00 00	 jmp	 $LN1@InvisibleB
$LN2@InvisibleB:

; 668  : 
; 669  :     // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
; 670  :     IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _size_arg$[ebp]
  0004f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00053	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0005a	9f		 lahf
  0005b	f6 c4 44	 test	 ah, 68			; 00000044H
  0005e	7b 15		 jnp	 SHORT $LN5@InvisibleB
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _size_arg$[ebp]
  00063	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00068	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0006f	9f		 lahf
  00070	f6 c4 44	 test	 ah, 68			; 00000044H
  00073	7a 26		 jp	 SHORT $LN6@InvisibleB
$LN5@InvisibleB:
  00075	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z@4JA
  0007b	83 c2 06	 add	 edx, 6
  0007e	8b f4		 mov	 esi, esp
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@NBNJEEME@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_1FC@KJEAANOI@?$AAs?$AAi?$AAz?$AAe?$AA_?$AAa?$AAr?$AAg?$AA?4?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@InvisibleB:

; 671  : 
; 672  :     const ImGuiID id = window->GetID(str_id);

  0009b	6a 00		 push	 0
  0009d	8b 45 08	 mov	 eax, DWORD PTR _str_id$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000a4	e8 00 00 00 00	 call	 ?GetID@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetID
  000a9	89 45 e8	 mov	 DWORD PTR _id$[ebp], eax

; 673  :     ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);

  000ac	51		 push	 ecx
  000ad	0f 57 c0	 xorps	 xmm0, xmm0
  000b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b5	51		 push	 ecx
  000b6	0f 57 c0	 xorps	 xmm0, xmm0
  000b9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000be	8b 45 0c	 mov	 eax, DWORD PTR _size_arg$[ebp]
  000c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c4	51		 push	 ecx
  000c5	8b 10		 mov	 edx, DWORD PTR [eax]
  000c7	52		 push	 edx
  000c8	8d 45 d8	 lea	 eax, DWORD PTR _size$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
  000d1	83 c4 14	 add	 esp, 20			; 00000014H

; 674  :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

  000d4	8d 45 d8	 lea	 eax, DWORD PTR _size$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000db	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  000e1	51		 push	 ecx
  000e2	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f1	50		 push	 eax
  000f2	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000f5	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000fa	50		 push	 eax
  000fb	8d 4d c0	 lea	 ecx, DWORD PTR _bb$[ebp]
  000fe	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 675  :     ItemSize(size);

  00103	51		 push	 ecx
  00104	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0010c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00111	8d 45 d8	 lea	 eax, DWORD PTR _size$[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  0011a	83 c4 08	 add	 esp, 8

; 676  :     if (!ItemAdd(bb, id))

  0011d	6a 00		 push	 0
  0011f	8b 45 e8	 mov	 eax, DWORD PTR _id$[ebp]
  00122	50		 push	 eax
  00123	8d 4d c0	 lea	 ecx, DWORD PTR _bb$[ebp]
  00126	51		 push	 ecx
  00127	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0012c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012f	0f b6 d0	 movzx	 edx, al
  00132	85 d2		 test	 edx, edx
  00134	75 04		 jne	 SHORT $LN3@InvisibleB

; 677  :         return false;

  00136	32 c0		 xor	 al, al
  00138	eb 20		 jmp	 SHORT $LN1@InvisibleB
$LN3@InvisibleB:

; 678  : 
; 679  :     bool hovered, held;
; 680  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

  0013a	6a 00		 push	 0
  0013c	8d 45 ab	 lea	 eax, DWORD PTR _held$[ebp]
  0013f	50		 push	 eax
  00140	8d 4d b7	 lea	 ecx, DWORD PTR _hovered$[ebp]
  00143	51		 push	 ecx
  00144	8b 55 e8	 mov	 edx, DWORD PTR _id$[ebp]
  00147	52		 push	 edx
  00148	8d 45 c0	 lea	 eax, DWORD PTR _bb$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
  00151	83 c4 14	 add	 esp, 20			; 00000014H
  00154	88 45 9f	 mov	 BYTE PTR _pressed$[ebp], al

; 681  : 
; 682  :     return pressed;

  00157	8a 45 9f	 mov	 al, BYTE PTR _pressed$[ebp]
$LN1@InvisibleB:

; 683  : }

  0015a	52		 push	 edx
  0015b	8b cd		 mov	 ecx, ebp
  0015d	50		 push	 eax
  0015e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@InvisibleB
  00164	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00169	58		 pop	 eax
  0016a	5a		 pop	 edx
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00171	33 cd		 xor	 ecx, ebp
  00173	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00178	81 c4 38 01 00
	00		 add	 esp, 312		; 00000138H
  0017e	3b ec		 cmp	 ebp, esp
  00180	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
  00189	0f 1f 00	 npad	 3
$LN12@InvisibleB:
  0018c	04 00 00 00	 DD	 4
  00190	00 00 00 00	 DD	 $LN11@InvisibleB
$LN11@InvisibleB:
  00194	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00198	08 00 00 00	 DD	 8
  0019c	00 00 00 00	 DD	 $LN7@InvisibleB
  001a0	c0 ff ff ff	 DD	 -64			; ffffffc0H
  001a4	10 00 00 00	 DD	 16			; 00000010H
  001a8	00 00 00 00	 DD	 $LN8@InvisibleB
  001ac	b7 ff ff ff	 DD	 -73			; ffffffb7H
  001b0	01 00 00 00	 DD	 1
  001b4	00 00 00 00	 DD	 $LN9@InvisibleB
  001b8	ab ff ff ff	 DD	 -85			; ffffffabH
  001bc	01 00 00 00	 DD	 1
  001c0	00 00 00 00	 DD	 $LN10@InvisibleB
$LN10@InvisibleB:
  001c4	68		 DB	 104			; 00000068H
  001c5	65		 DB	 101			; 00000065H
  001c6	6c		 DB	 108			; 0000006cH
  001c7	64		 DB	 100			; 00000064H
  001c8	00		 DB	 0
$LN9@InvisibleB:
  001c9	68		 DB	 104			; 00000068H
  001ca	6f		 DB	 111			; 0000006fH
  001cb	76		 DB	 118			; 00000076H
  001cc	65		 DB	 101			; 00000065H
  001cd	72		 DB	 114			; 00000072H
  001ce	65		 DB	 101			; 00000065H
  001cf	64		 DB	 100			; 00000064H
  001d0	00		 DB	 0
$LN8@InvisibleB:
  001d1	62		 DB	 98			; 00000062H
  001d2	62		 DB	 98			; 00000062H
  001d3	00		 DB	 0
$LN7@InvisibleB:
  001d4	73		 DB	 115			; 00000073H
  001d5	69		 DB	 105			; 00000069H
  001d6	7a		 DB	 122			; 0000007aH
  001d7	65		 DB	 101			; 00000065H
  001d8	00		 DB	 0
?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ENDP	; ImGui::InvisibleButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?SmallButton@ImGui@@YA_NPBD@Z
_TEXT	SEGMENT
$T1 = -240						; size = 8
_pressed$ = -29						; size = 1
_backup_padding_y$ = -20				; size = 4
_g$ = -8						; size = 4
_label$ = 8						; size = 4
?SmallButton@ImGui@@YA_NPBD@Z PROC			; ImGui::SmallButton, COMDAT

; 652  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 653  :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 654  :     float backup_padding_y = g.Style.FramePadding.y;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  0003b	f3 0f 11 45 ec	 movss	 DWORD PTR _backup_padding_y$[ebp], xmm0

; 655  :     g.Style.FramePadding.y = 0.0f;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00043	0f 57 c0	 xorps	 xmm0, xmm0
  00046	f3 0f 11 80 4c
	15 00 00	 movss	 DWORD PTR [eax+5452], xmm0

; 656  :     bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);

  0004e	68 00 02 00 00	 push	 512			; 00000200H
  00053	51		 push	 ecx
  00054	0f 57 c0	 xorps	 xmm0, xmm0
  00057	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005c	51		 push	 ecx
  0005d	0f 57 c0	 xorps	 xmm0, xmm0
  00060	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00065	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0006b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00070	50		 push	 eax
  00071	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z ; ImGui::ButtonEx
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	88 45 e3	 mov	 BYTE PTR _pressed$[ebp], al

; 657  :     g.Style.FramePadding.y = backup_padding_y;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00083	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _backup_padding_y$[ebp]
  00088	f3 0f 11 80 4c
	15 00 00	 movss	 DWORD PTR [eax+5452], xmm0

; 658  :     return pressed;

  00090	8a 45 e3	 mov	 al, BYTE PTR _pressed$[ebp]

; 659  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?SmallButton@ImGui@@YA_NPBD@Z ENDP			; ImGui::SmallButton
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Button@ImGui@@YA_NPBDABUImVec2@@@Z
_TEXT	SEGMENT
_label$ = 8						; size = 4
_size_arg$ = 12						; size = 4
?Button@ImGui@@YA_NPBDABUImVec2@@@Z PROC		; ImGui::Button, COMDAT

; 646  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 647  :     return ButtonEx(label, size_arg, 0);

  00028	6a 00		 push	 0
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _size_arg$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _label$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z ; ImGui::ButtonEx
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 648  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Button@ImGui@@YA_NPBDABUImVec2@@@Z ENDP		; ImGui::Button
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BulletTextV@ImGui@@YAXPBDPAD@Z
_TEXT	SEGMENT
tv92 = -424						; size = 4
$T1 = -416						; size = 8
$T2 = -400						; size = 8
$T3 = -384						; size = 8
$T4 = -368						; size = 8
$T5 = -352						; size = 8
_text_col$ = -144					; size = 4
_bb$ = -132						; size = 16
_pos$ = -108						; size = 8
_total_size$ = -92					; size = 8
_label_size$ = -76					; size = 8
_text_end$ = -60					; size = 4
_text_begin$ = -48					; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?BulletTextV@ImGui@@YAXPBDPAD@Z PROC			; ImGui::BulletTextV, COMDAT

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 58 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-424]
  00012	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 352  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 353  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN2@BulletText

; 354  :         return;

  00045	e9 4f 02 00 00	 jmp	 $LN1@BulletText
$LN2@BulletText:

; 355  : 
; 356  :     ImGuiContext& g = *GImGui;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004f	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 357  :     const ImGuiStyle& style = g.Style;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00055	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005a	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 358  : 
; 359  :     const char* text_begin = g.TempBuffer;

  0005d	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00060	05 80 2f 00 00	 add	 eax, 12160		; 00002f80H
  00065	89 45 d0	 mov	 DWORD PTR _text_begin$[ebp], eax

; 360  :     const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

  00068	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0006f	51		 push	 ecx
  00070	68 01 0c 00 00	 push	 3073			; 00000c01H
  00075	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  00078	81 c2 80 2f 00
	00		 add	 edx, 12160		; 00002f80H
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?ImFormatStringV@@YAHPADIPBD0@Z ; ImFormatStringV
  00084	83 c4 10	 add	 esp, 16			; 00000010H
  00087	03 45 d0	 add	 eax, DWORD PTR _text_begin$[ebp]
  0008a	89 45 c4	 mov	 DWORD PTR _text_end$[ebp], eax

; 361  :     const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);

  0008d	51		 push	 ecx
  0008e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00096	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009b	6a 00		 push	 0
  0009d	8b 45 c4	 mov	 eax, DWORD PTR _text_end$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d d0	 mov	 ecx, DWORD PTR _text_begin$[ebp]
  000a4	51		 push	 ecx
  000a5	8d 55 b4	 lea	 edx, DWORD PTR _label_size$[ebp]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  000ae	83 c4 14	 add	 esp, 20			; 00000014H

; 362  :     const ImVec2 total_size = ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x * 2) : 0.0f), label_size.y);  // Empty text doesn't add padding

  000b1	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  000b6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000bd	76 1f		 jbe	 SHORT $LN5@BulletText
  000bf	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000c2	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  000c7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  000cf	f3 0f 58 45 b4	 addss	 xmm0, DWORD PTR _label_size$[ebp]
  000d4	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR tv92[ebp], xmm0
  000dc	eb 0b		 jmp	 SHORT $LN6@BulletText
$LN5@BulletText:
  000de	0f 57 c0	 xorps	 xmm0, xmm0
  000e1	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR tv92[ebp], xmm0
$LN6@BulletText:
  000e9	51		 push	 ecx
  000ea	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _label_size$[ebp+4]
  000ef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f4	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  000f7	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  000ff	f3 0f 58 85 58
	fe ff ff	 addss	 xmm0, DWORD PTR tv92[ebp]
  00107	51		 push	 ecx
  00108	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010d	8d 4d a4	 lea	 ecx, DWORD PTR _total_size$[ebp]
  00110	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 363  :     ImVec2 pos = window->DC.CursorPos;

  00115	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00118	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0011e	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00124	89 4d 94	 mov	 DWORD PTR _pos$[ebp], ecx
  00127	89 55 98	 mov	 DWORD PTR _pos$[ebp+4], edx

; 364  :     pos.y += window->DC.CurrLineTextBaseOffset;

  0012a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0012d	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00132	f3 0f 58 80 f8
	00 00 00	 addss	 xmm0, DWORD PTR [eax+248]
  0013a	f3 0f 11 45 98	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 365  :     ItemSize(total_size, 0.0f);

  0013f	51		 push	 ecx
  00140	0f 57 c0	 xorps	 xmm0, xmm0
  00143	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00148	8d 45 a4	 lea	 eax, DWORD PTR _total_size$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  00151	83 c4 08	 add	 esp, 8

; 366  :     const ImRect bb(pos, pos + total_size);

  00154	8d 45 a4	 lea	 eax, DWORD PTR _total_size$[ebp]
  00157	50		 push	 eax
  00158	8d 4d 94	 lea	 ecx, DWORD PTR _pos$[ebp]
  0015b	51		 push	 ecx
  0015c	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00162	52		 push	 edx
  00163	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016b	50		 push	 eax
  0016c	8d 45 94	 lea	 eax, DWORD PTR _pos$[ebp]
  0016f	50		 push	 eax
  00170	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  00176	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 367  :     if (!ItemAdd(bb, 0))

  0017b	6a 00		 push	 0
  0017d	6a 00		 push	 0
  0017f	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _bb$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018e	0f b6 c8	 movzx	 ecx, al
  00191	85 c9		 test	 ecx, ecx
  00193	75 05		 jne	 SHORT $LN3@BulletText

; 368  :         return;

  00195	e9 ff 00 00 00	 jmp	 $LN1@BulletText
$LN3@BulletText:

; 369  : 
; 370  :     // Render
; 371  :     ImU32 text_col = GetColorU32(ImGuiCol_Text);

  0019a	51		 push	 ecx
  0019b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a8	6a 00		 push	 0
  001aa	e8 00 00 00 00	 call	 ?GetColorU32@ImGui@@YAIHM@Z ; ImGui::GetColorU32
  001af	83 c4 08	 add	 esp, 8
  001b2	89 85 70 ff ff
	ff		 mov	 DWORD PTR _text_col$[ebp], eax

; 372  :     RenderBullet(window->DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, g.FontSize*0.5f), text_col);

  001b8	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _text_col$[ebp]
  001be	50		 push	 eax
  001bf	8b 4d e8	 mov	 ecx, DWORD PTR _g$[ebp]
  001c2	f3 0f 10 81 c4
	18 00 00	 movss	 xmm0, DWORD PTR [ecx+6340]
  001ca	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001d2	51		 push	 ecx
  001d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d8	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  001db	f3 0f 10 82 c4
	18 00 00	 movss	 xmm0, DWORD PTR [edx+6340]
  001e3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001eb	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  001ee	f3 0f 58 40 38	 addss	 xmm0, DWORD PTR [eax+56]
  001f3	51		 push	 ecx
  001f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f9	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001ff	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00204	50		 push	 eax
  00205	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  0020b	51		 push	 ecx
  0020c	8d 95 80 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00212	52		 push	 edx
  00213	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0021e	51		 push	 ecx
  0021f	8b 10		 mov	 edx, DWORD PTR [eax]
  00221	52		 push	 edx
  00222	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00225	8b 88 74 02 00
	00		 mov	 ecx, DWORD PTR [eax+628]
  0022b	51		 push	 ecx
  0022c	e8 00 00 00 00	 call	 ?RenderBullet@ImGui@@YAXPAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
  00231	83 c4 10	 add	 esp, 16			; 00000010H

; 373  :     RenderText(bb.Min + ImVec2(g.FontSize + style.FramePadding.x * 2, 0.0f), text_begin, text_end, false);

  00234	6a 00		 push	 0
  00236	8b 45 c4	 mov	 eax, DWORD PTR _text_end$[ebp]
  00239	50		 push	 eax
  0023a	8b 4d d0	 mov	 ecx, DWORD PTR _text_begin$[ebp]
  0023d	51		 push	 ecx
  0023e	51		 push	 ecx
  0023f	0f 57 c0	 xorps	 xmm0, xmm0
  00242	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00247	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  0024a	f3 0f 10 42 38	 movss	 xmm0, DWORD PTR [edx+56]
  0024f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00257	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  0025a	f3 0f 58 80 c4
	18 00 00	 addss	 xmm0, DWORD PTR [eax+6340]
  00262	51		 push	 ecx
  00263	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00268	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0026e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00273	50		 push	 eax
  00274	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _bb$[ebp]
  0027a	51		 push	 ecx
  0027b	8d 95 60 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00287	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0028d	51		 push	 ecx
  0028e	8b 10		 mov	 edx, DWORD PTR [eax]
  00290	52		 push	 edx
  00291	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  00296	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@BulletText:

; 374  : }

  00299	52		 push	 edx
  0029a	8b cd		 mov	 ecx, ebp
  0029c	50		 push	 eax
  0029d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@BulletText
  002a3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002a8	58		 pop	 eax
  002a9	5a		 pop	 edx
  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi
  002ac	5b		 pop	 ebx
  002ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b0	33 cd		 xor	 ecx, ebp
  002b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b7	81 c4 a8 01 00
	00		 add	 esp, 424		; 000001a8H
  002bd	3b ec		 cmp	 ebp, esp
  002bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c4	8b e5		 mov	 esp, ebp
  002c6	5d		 pop	 ebp
  002c7	c3		 ret	 0
$LN12@BulletText:
  002c8	04 00 00 00	 DD	 4
  002cc	00 00 00 00	 DD	 $LN11@BulletText
$LN11@BulletText:
  002d0	b4 ff ff ff	 DD	 -76			; ffffffb4H
  002d4	08 00 00 00	 DD	 8
  002d8	00 00 00 00	 DD	 $LN7@BulletText
  002dc	a4 ff ff ff	 DD	 -92			; ffffffa4H
  002e0	08 00 00 00	 DD	 8
  002e4	00 00 00 00	 DD	 $LN8@BulletText
  002e8	94 ff ff ff	 DD	 -108			; ffffff94H
  002ec	08 00 00 00	 DD	 8
  002f0	00 00 00 00	 DD	 $LN9@BulletText
  002f4	7c ff ff ff	 DD	 -132			; ffffff7cH
  002f8	10 00 00 00	 DD	 16			; 00000010H
  002fc	00 00 00 00	 DD	 $LN10@BulletText
$LN10@BulletText:
  00300	62		 DB	 98			; 00000062H
  00301	62		 DB	 98			; 00000062H
  00302	00		 DB	 0
$LN9@BulletText:
  00303	70		 DB	 112			; 00000070H
  00304	6f		 DB	 111			; 0000006fH
  00305	73		 DB	 115			; 00000073H
  00306	00		 DB	 0
$LN8@BulletText:
  00307	74		 DB	 116			; 00000074H
  00308	6f		 DB	 111			; 0000006fH
  00309	74		 DB	 116			; 00000074H
  0030a	61		 DB	 97			; 00000061H
  0030b	6c		 DB	 108			; 0000006cH
  0030c	5f		 DB	 95			; 0000005fH
  0030d	73		 DB	 115			; 00000073H
  0030e	69		 DB	 105			; 00000069H
  0030f	7a		 DB	 122			; 0000007aH
  00310	65		 DB	 101			; 00000065H
  00311	00		 DB	 0
$LN7@BulletText:
  00312	6c		 DB	 108			; 0000006cH
  00313	61		 DB	 97			; 00000061H
  00314	62		 DB	 98			; 00000062H
  00315	65		 DB	 101			; 00000065H
  00316	6c		 DB	 108			; 0000006cH
  00317	5f		 DB	 95			; 0000005fH
  00318	73		 DB	 115			; 00000073H
  00319	69		 DB	 105			; 00000069H
  0031a	7a		 DB	 122			; 0000007aH
  0031b	65		 DB	 101			; 00000065H
  0031c	00		 DB	 0
?BulletTextV@ImGui@@YAXPBDPAD@Z ENDP			; ImGui::BulletTextV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?BulletText@ImGui@@YAXPBDZZ
_TEXT	SEGMENT
_args$ = -8						; size = 4
_fmt$ = 8						; size = 4
?BulletText@ImGui@@YAXPBDZZ PROC			; ImGui::BulletText, COMDAT

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 343  :     va_list args;
; 344  :     va_start(args, fmt);

  00028	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 345  :     BulletTextV(fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?BulletTextV@ImGui@@YAXPBDPAD@Z ; ImGui::BulletTextV
  0003b	83 c4 08	 add	 esp, 8

; 346  :     va_end(args);

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 347  : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?BulletText@ImGui@@YAXPBDZZ ENDP			; ImGui::BulletText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?LabelTextV@ImGui@@YAXPBD0PAD@Z
_TEXT	SEGMENT
tv140 = -448						; size = 4
$T1 = -440						; size = 8
$T2 = -424						; size = 8
$T3 = -408						; size = 8
$T4 = -392						; size = 8
$T5 = -376						; size = 8
$T6 = -360						; size = 8
$T7 = -344						; size = 8
_value_text_end$ = -136					; size = 4
_value_text_begin$ = -124				; size = 4
_total_bb$ = -112					; size = 16
_value_bb$ = -88					; size = 16
_label_size$ = -64					; size = 8
_w$ = -48						; size = 4
_style$ = -36						; size = 4
_g$ = -24						; size = 4
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_label$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?LabelTextV@ImGui@@YAXPBD0PAD@Z PROC			; ImGui::LabelTextV, COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 01 00
	00		 sub	 esp, 448		; 000001c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-448]
  00012	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 318  :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 319  :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN2@LabelTextV

; 320  :         return;

  00045	e9 43 02 00 00	 jmp	 $LN1@LabelTextV
$LN2@LabelTextV:

; 321  : 
; 322  :     ImGuiContext& g = *GImGui;

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0004f	89 45 e8	 mov	 DWORD PTR _g$[ebp], eax

; 323  :     const ImGuiStyle& style = g.Style;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _g$[ebp]
  00055	05 10 15 00 00	 add	 eax, 5392		; 00001510H
  0005a	89 45 dc	 mov	 DWORD PTR _style$[ebp], eax

; 324  :     const float w = CalcItemWidth();

  0005d	e8 00 00 00 00	 call	 ?CalcItemWidth@ImGui@@YAMXZ ; ImGui::CalcItemWidth
  00062	d9 5d d0	 fstp	 DWORD PTR _w$[ebp]

; 325  : 
; 326  :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

  00065	51		 push	 ecx
  00066	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0006e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00073	6a 01		 push	 1
  00075	6a 00		 push	 0
  00077	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0007a	50		 push	 eax
  0007b	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
  00084	83 c4 14	 add	 esp, 20			; 00000014H

; 327  :     const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));

  00087	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  0008a	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0008f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00097	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _label_size$[ebp+4]
  0009c	51		 push	 ecx
  0009d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a2	51		 push	 ecx
  000a3	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _w$[ebp]
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  000b3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000b8	50		 push	 eax
  000b9	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  000bc	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  000c2	51		 push	 ecx
  000c3	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d2	50		 push	 eax
  000d3	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  000d6	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  000db	50		 push	 eax
  000dc	8d 4d a8	 lea	 ecx, DWORD PTR _value_bb$[ebp]
  000df	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 328  :     const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);

  000e4	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  000e9	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000f0	76 12		 jbe	 SHORT $LN6@LabelTextV
  000f2	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  000f5	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
  000fa	f3 0f 11 85 40
	fe ff ff	 movss	 DWORD PTR tv140[ebp], xmm0
  00102	eb 0b		 jmp	 SHORT $LN7@LabelTextV
$LN6@LabelTextV:
  00104	0f 57 c0	 xorps	 xmm0, xmm0
  00107	f3 0f 11 85 40
	fe ff ff	 movss	 DWORD PTR tv140[ebp], xmm0
$LN7@LabelTextV:
  0010f	8d 4d c0	 lea	 ecx, DWORD PTR _label_size$[ebp]
  00112	51		 push	 ecx
  00113	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  00116	f3 0f 10 42 3c	 movss	 xmm0, DWORD PTR [edx+60]
  0011b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00123	51		 push	 ecx
  00124	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00129	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _w$[ebp]
  0012e	f3 0f 58 85 40
	fe ff ff	 addss	 xmm0, DWORD PTR tv140[ebp]
  00136	51		 push	 ecx
  00137	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013c	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00142	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00147	50		 push	 eax
  00148	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0014b	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  00150	50		 push	 eax
  00151	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00157	51		 push	 ecx
  00158	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	50		 push	 eax
  00161	8d 95 68 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00167	52		 push	 edx
  00168	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0016d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00170	50		 push	 eax
  00171	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00174	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  00179	50		 push	 eax
  0017a	8d 4d 90	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  0017d	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 329  :     ItemSize(total_bb, style.FramePadding.y);

  00182	8b 45 dc	 mov	 eax, DWORD PTR _style$[ebp]
  00185	51		 push	 ecx
  00186	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0018b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00190	8d 4d 90	 lea	 ecx, DWORD PTR _total_bb$[ebp]
  00193	51		 push	 ecx
  00194	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImRect@@M@Z ; ImGui::ItemSize
  00199	83 c4 08	 add	 esp, 8

; 330  :     if (!ItemAdd(total_bb, 0))

  0019c	6a 00		 push	 0
  0019e	6a 00		 push	 0
  001a0	8d 45 90	 lea	 eax, DWORD PTR _total_bb$[ebp]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ac	0f b6 c8	 movzx	 ecx, al
  001af	85 c9		 test	 ecx, ecx
  001b1	75 05		 jne	 SHORT $LN3@LabelTextV

; 331  :         return;

  001b3	e9 d5 00 00 00	 jmp	 $LN1@LabelTextV
$LN3@LabelTextV:

; 332  : 
; 333  :     // Render
; 334  :     const char* value_text_begin = &g.TempBuffer[0];

  001b8	b8 01 00 00 00	 mov	 eax, 1
  001bd	6b c8 00	 imul	 ecx, eax, 0
  001c0	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  001c3	8d 84 0a 80 2f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+12160]
  001ca	89 45 84	 mov	 DWORD PTR _value_text_begin$[ebp], eax

; 335  :     const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

  001cd	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  001d0	50		 push	 eax
  001d1	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  001d4	51		 push	 ecx
  001d5	68 01 0c 00 00	 push	 3073			; 00000c01H
  001da	8b 55 e8	 mov	 edx, DWORD PTR _g$[ebp]
  001dd	81 c2 80 2f 00
	00		 add	 edx, 12160		; 00002f80H
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 ?ImFormatStringV@@YAHPADIPBD0@Z ; ImFormatStringV
  001e9	83 c4 10	 add	 esp, 16			; 00000010H
  001ec	03 45 84	 add	 eax, DWORD PTR _value_text_begin$[ebp]
  001ef	89 85 78 ff ff
	ff		 mov	 DWORD PTR _value_text_end$[ebp], eax

; 336  :     RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));

  001f5	6a 00		 push	 0
  001f7	51		 push	 ecx
  001f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00200	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00205	51		 push	 ecx
  00206	0f 57 c0	 xorps	 xmm0, xmm0
  00209	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020e	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00214	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00219	50		 push	 eax
  0021a	6a 00		 push	 0
  0021c	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _value_text_end$[ebp]
  00222	50		 push	 eax
  00223	8b 4d 84	 mov	 ecx, DWORD PTR _value_text_begin$[ebp]
  00226	51		 push	 ecx
  00227	8d 55 b0	 lea	 edx, DWORD PTR _value_bb$[ebp+8]
  0022a	52		 push	 edx
  0022b	8d 45 a8	 lea	 eax, DWORD PTR _value_bb$[ebp]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 ?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
  00234	83 c4 1c	 add	 esp, 28			; 0000001cH

; 337  :     if (label_size.x > 0.0f)

  00237	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _label_size$[ebp]
  0023c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00243	76 48		 jbe	 SHORT $LN4@LabelTextV

; 338  :         RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);

  00245	6a 01		 push	 1
  00247	6a 00		 push	 0
  00249	8b 45 08	 mov	 eax, DWORD PTR _label$[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d dc	 mov	 ecx, DWORD PTR _style$[ebp]
  00250	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _value_bb$[ebp+4]
  00255	f3 0f 58 41 3c	 addss	 xmm0, DWORD PTR [ecx+60]
  0025a	51		 push	 ecx
  0025b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00260	8b 55 dc	 mov	 edx, DWORD PTR _style$[ebp]
  00263	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _value_bb$[ebp+8]
  00268	f3 0f 58 42 50	 addss	 xmm0, DWORD PTR [edx+80]
  0026d	51		 push	 ecx
  0026e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00273	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00279	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0027e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00281	51		 push	 ecx
  00282	8b 10		 mov	 edx, DWORD PTR [eax]
  00284	52		 push	 edx
  00285	e8 00 00 00 00	 call	 ?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ; ImGui::RenderText
  0028a	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@LabelTextV:
$LN1@LabelTextV:

; 339  : }

  0028d	52		 push	 edx
  0028e	8b cd		 mov	 ecx, ebp
  00290	50		 push	 eax
  00291	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@LabelTextV
  00297	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0029c	58		 pop	 eax
  0029d	5a		 pop	 edx
  0029e	5f		 pop	 edi
  0029f	5e		 pop	 esi
  002a0	5b		 pop	 ebx
  002a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a4	33 cd		 xor	 ecx, ebp
  002a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ab	81 c4 c0 01 00
	00		 add	 esp, 448		; 000001c0H
  002b1	3b ec		 cmp	 ebp, esp
  002b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
$LN12@LabelTextV:
  002bc	03 00 00 00	 DD	 3
  002c0	00 00 00 00	 DD	 $LN11@LabelTextV
$LN11@LabelTextV:
  002c4	c0 ff ff ff	 DD	 -64			; ffffffc0H
  002c8	08 00 00 00	 DD	 8
  002cc	00 00 00 00	 DD	 $LN8@LabelTextV
  002d0	a8 ff ff ff	 DD	 -88			; ffffffa8H
  002d4	10 00 00 00	 DD	 16			; 00000010H
  002d8	00 00 00 00	 DD	 $LN9@LabelTextV
  002dc	90 ff ff ff	 DD	 -112			; ffffff90H
  002e0	10 00 00 00	 DD	 16			; 00000010H
  002e4	00 00 00 00	 DD	 $LN10@LabelTextV
$LN10@LabelTextV:
  002e8	74		 DB	 116			; 00000074H
  002e9	6f		 DB	 111			; 0000006fH
  002ea	74		 DB	 116			; 00000074H
  002eb	61		 DB	 97			; 00000061H
  002ec	6c		 DB	 108			; 0000006cH
  002ed	5f		 DB	 95			; 0000005fH
  002ee	62		 DB	 98			; 00000062H
  002ef	62		 DB	 98			; 00000062H
  002f0	00		 DB	 0
$LN9@LabelTextV:
  002f1	76		 DB	 118			; 00000076H
  002f2	61		 DB	 97			; 00000061H
  002f3	6c		 DB	 108			; 0000006cH
  002f4	75		 DB	 117			; 00000075H
  002f5	65		 DB	 101			; 00000065H
  002f6	5f		 DB	 95			; 0000005fH
  002f7	62		 DB	 98			; 00000062H
  002f8	62		 DB	 98			; 00000062H
  002f9	00		 DB	 0
$LN8@LabelTextV:
  002fa	6c		 DB	 108			; 0000006cH
  002fb	61		 DB	 97			; 00000061H
  002fc	62		 DB	 98			; 00000062H
  002fd	65		 DB	 101			; 00000065H
  002fe	6c		 DB	 108			; 0000006cH
  002ff	5f		 DB	 95			; 0000005fH
  00300	73		 DB	 115			; 00000073H
  00301	69		 DB	 105			; 00000069H
  00302	7a		 DB	 122			; 0000007aH
  00303	65		 DB	 101			; 00000065H
  00304	00		 DB	 0
?LabelTextV@ImGui@@YAXPBD0PAD@Z ENDP			; ImGui::LabelTextV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?LabelText@ImGui@@YAXPBD0ZZ
_TEXT	SEGMENT
_args$ = -8						; size = 4
_label$ = 8						; size = 4
_fmt$ = 12						; size = 4
?LabelText@ImGui@@YAXPBD0ZZ PROC			; ImGui::LabelText, COMDAT

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 309  :     va_list args;
; 310  :     va_start(args, fmt);

  00028	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 311  :     LabelTextV(label, fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _label$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?LabelTextV@ImGui@@YAXPBD0PAD@Z ; ImGui::LabelTextV
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  :     va_end(args);

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 313  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?LabelText@ImGui@@YAXPBD0ZZ ENDP			; ImGui::LabelText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextWrappedV@ImGui@@YAXPBDPAD@Z
_TEXT	SEGMENT
tv68 = -220						; size = 4
_need_backup$ = -17					; size = 1
_window$ = -8						; size = 4
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?TextWrappedV@ImGui@@YAXPBDPAD@Z PROC			; ImGui::TextWrappedV, COMDAT

; 297  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 298  :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 299  :     bool need_backup = (window->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f 57 c0	 xorps	 xmm0, xmm0
  00036	0f 2f 80 74 01
	00 00		 comiss	 xmm0, DWORD PTR [eax+372]
  0003d	76 0c		 jbe	 SHORT $LN5@TextWrappe
  0003f	c7 85 24 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
  00049	eb 0a		 jmp	 SHORT $LN6@TextWrappe
$LN5@TextWrappe:
  0004b	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
$LN6@TextWrappe:
  00055	8a 8d 24 ff ff
	ff		 mov	 cl, BYTE PTR tv68[ebp]
  0005b	88 4d ef	 mov	 BYTE PTR _need_backup$[ebp], cl

; 300  :     if (need_backup)

  0005e	0f b6 45 ef	 movzx	 eax, BYTE PTR _need_backup$[ebp]
  00062	85 c0		 test	 eax, eax
  00064	74 11		 je	 SHORT $LN2@TextWrappe

; 301  :         PushTextWrapPos(0.0f);

  00066	51		 push	 ecx
  00067	0f 57 c0	 xorps	 xmm0, xmm0
  0006a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006f	e8 00 00 00 00	 call	 ?PushTextWrapPos@ImGui@@YAXM@Z ; ImGui::PushTextWrapPos
  00074	83 c4 04	 add	 esp, 4
$LN2@TextWrappe:

; 302  :     TextV(fmt, args);

  00077	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?TextV@ImGui@@YAXPBDPAD@Z ; ImGui::TextV
  00084	83 c4 08	 add	 esp, 8

; 303  :     if (need_backup)

  00087	0f b6 45 ef	 movzx	 eax, BYTE PTR _need_backup$[ebp]
  0008b	85 c0		 test	 eax, eax
  0008d	74 05		 je	 SHORT $LN3@TextWrappe

; 304  :         PopTextWrapPos();

  0008f	e8 00 00 00 00	 call	 ?PopTextWrapPos@ImGui@@YAXXZ ; ImGui::PopTextWrapPos
$LN3@TextWrappe:

; 305  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0009d	3b ec		 cmp	 ebp, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?TextWrappedV@ImGui@@YAXPBDPAD@Z ENDP			; ImGui::TextWrappedV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextWrapped@ImGui@@YAXPBDZZ
_TEXT	SEGMENT
_args$ = -8						; size = 4
_fmt$ = 8						; size = 4
?TextWrapped@ImGui@@YAXPBDZZ PROC			; ImGui::TextWrapped, COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 290  :     va_list args;
; 291  :     va_start(args, fmt);

  00028	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 292  :     TextWrappedV(fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?TextWrappedV@ImGui@@YAXPBDPAD@Z ; ImGui::TextWrappedV
  0003b	83 c4 08	 add	 esp, 8

; 293  :     va_end(args);

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 294  : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?TextWrapped@ImGui@@YAXPBDZZ ENDP			; ImGui::TextWrapped
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextDisabledV@ImGui@@YAXPBDPAD@Z
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?TextDisabledV@ImGui@@YAXPBDPAD@Z PROC			; ImGui::TextDisabledV, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 283  :     PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);

  00028	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0002d	c1 e0 00	 shl	 eax, 0
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00036	8d 94 01 c0 15
	00 00		 lea	 edx, DWORD PTR [ecx+eax+5568]
  0003d	52		 push	 edx
  0003e	6a 00		 push	 0
  00040	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  00045	83 c4 08	 add	 esp, 8

; 284  :     TextV(fmt, args);

  00048	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?TextV@ImGui@@YAXPBDPAD@Z ; ImGui::TextV
  00055	83 c4 08	 add	 esp, 8

; 285  :     PopStyleColor();

  00058	6a 01		 push	 1
  0005a	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor
  0005f	83 c4 04	 add	 esp, 4

; 286  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?TextDisabledV@ImGui@@YAXPBDPAD@Z ENDP			; ImGui::TextDisabledV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextDisabled@ImGui@@YAXPBDZZ
_TEXT	SEGMENT
_args$ = -8						; size = 4
_fmt$ = 8						; size = 4
?TextDisabled@ImGui@@YAXPBDZZ PROC			; ImGui::TextDisabled, COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     va_list args;
; 276  :     va_start(args, fmt);

  00028	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 277  :     TextDisabledV(fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?TextDisabledV@ImGui@@YAXPBDPAD@Z ; ImGui::TextDisabledV
  0003b	83 c4 08	 add	 esp, 8

; 278  :     va_end(args);

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 279  : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?TextDisabled@ImGui@@YAXPBDZZ ENDP			; ImGui::TextDisabled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z PROC	; ImGui::TextColoredV, COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 268  :     PushStyleColor(ImGuiCol_Text, col);

  00028	8b 45 08	 mov	 eax, DWORD PTR _col$[ebp]
  0002b	50		 push	 eax
  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
  00033	83 c4 08	 add	 esp, 8

; 269  :     TextV(fmt, args);

  00036	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?TextV@ImGui@@YAXPBDPAD@Z ; ImGui::TextV
  00043	83 c4 08	 add	 esp, 8

; 270  :     PopStyleColor();

  00046	6a 01		 push	 1
  00048	e8 00 00 00 00	 call	 ?PopStyleColor@ImGui@@YAXH@Z ; ImGui::PopStyleColor
  0004d	83 c4 04	 add	 esp, 4

; 271  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z ENDP	; ImGui::TextColoredV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextColored@ImGui@@YAXABUImVec4@@PBDZZ
_TEXT	SEGMENT
_args$ = -8						; size = 4
_col$ = 8						; size = 4
_fmt$ = 12						; size = 4
?TextColored@ImGui@@YAXABUImVec4@@PBDZZ PROC		; ImGui::TextColored, COMDAT

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 260  :     va_list args;
; 261  :     va_start(args, fmt);

  00028	8d 45 10	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 262  :     TextColoredV(col, fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _col$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z ; ImGui::TextColoredV
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  :     va_end(args);

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 264  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?TextColored@ImGui@@YAXABUImVec4@@PBDZZ ENDP		; ImGui::TextColored
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextV@ImGui@@YAXPBDPAD@Z
_TEXT	SEGMENT
_text_end$ = -32					; size = 4
_g$ = -20						; size = 4
_window$ = -8						; size = 4
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?TextV@ImGui@@YAXPBDPAD@Z PROC				; ImGui::TextV, COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 249  :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 250  :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 02		 je	 SHORT $LN2@TextV

; 251  :         return;

  0003b	eb 4c		 jmp	 SHORT $LN1@TextV
$LN2@TextV:

; 252  : 
; 253  :     ImGuiContext& g = *GImGui;

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00042	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 254  :     const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _args$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  0004c	51		 push	 ecx
  0004d	68 01 0c 00 00	 push	 3073			; 00000c01H
  00052	8b 55 ec	 mov	 edx, DWORD PTR _g$[ebp]
  00055	81 c2 80 2f 00
	00		 add	 edx, 12160		; 00002f80H
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?ImFormatStringV@@YAHPADIPBD0@Z ; ImFormatStringV
  00061	83 c4 10	 add	 esp, 16			; 00000010H
  00064	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  00067	8d 94 01 80 2f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+12160]
  0006e	89 55 e0	 mov	 DWORD PTR _text_end$[ebp], edx

; 255  :     TextEx(g.TempBuffer, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

  00071	6a 01		 push	 1
  00073	8b 45 e0	 mov	 eax, DWORD PTR _text_end$[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  0007a	81 c1 80 2f 00
	00		 add	 ecx, 12160		; 00002f80H
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@TextV:

; 256  : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?TextV@ImGui@@YAXPBDPAD@Z ENDP				; ImGui::TextV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Text@ImGui@@YAXPBDZZ
_TEXT	SEGMENT
_args$ = -8						; size = 4
_fmt$ = 8						; size = 4
?Text@ImGui@@YAXPBDZZ PROC				; ImGui::Text, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 241  :     va_list args;
; 242  :     va_start(args, fmt);

  00028	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  0002b	89 45 f8	 mov	 DWORD PTR _args$[ebp], eax

; 243  :     TextV(fmt, args);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _args$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?TextV@ImGui@@YAXPBDPAD@Z ; ImGui::TextV
  0003b	83 c4 08	 add	 esp, 8

; 244  :     va_end(args);

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _args$[ebp], 0

; 245  : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?Text@ImGui@@YAXPBDZZ ENDP				; ImGui::Text
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?TextUnformatted@ImGui@@YAXPBD0@Z
_TEXT	SEGMENT
_text$ = 8						; size = 4
_text_end$ = 12						; size = 4
?TextUnformatted@ImGui@@YAXPBD0@Z PROC			; ImGui::TextUnformatted, COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 236  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

  00028	6a 01		 push	 1
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _text$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ?TextEx@ImGui@@YAXPBD0H@Z ; ImGui::TextEx
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?TextUnformatted@ImGui@@YAXPBD0@Z ENDP			; ImGui::TextUnformatted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?AlignTextToFramePadding@ImGui@@YAXXZ
_TEXT	SEGMENT
_g$ = -20						; size = 4
_window$ = -8						; size = 4
?AlignTextToFramePadding@ImGui@@YAXXZ PROC		; ImGui::AlignTextToFramePadding, COMDAT

; 1210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1211 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 1212 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 05		 je	 SHORT $LN2@AlignTextT

; 1213 :         return;

  0003b	e9 81 00 00 00	 jmp	 $LN1@AlignTextT
$LN2@AlignTextT:

; 1214 : 
; 1215 :     ImGuiContext& g = *GImGui;

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00045	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 1216 :     window->DC.CurrLineSize.y = ImMax(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);

  00048	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  0004b	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  00053	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _g$[ebp]
  0005e	f3 0f 58 81 c4
	18 00 00	 addss	 xmm0, DWORD PTR [ecx+6340]
  00066	51		 push	 ecx
  00067	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006c	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  0006f	51		 push	 ecx
  00070	f3 0f 10 82 ec
	00 00 00	 movss	 xmm0, DWORD PTR [edx+236]
  00078	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007d	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00082	83 c4 08	 add	 esp, 8
  00085	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00088	d9 98 ec 00 00
	00		 fstp	 DWORD PTR [eax+236]

; 1217 :     window->DC.CurrLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, g.Style.FramePadding.y);

  0008e	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  00091	51		 push	 ecx
  00092	f3 0f 10 80 4c
	15 00 00	 movss	 xmm0, DWORD PTR [eax+5452]
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _window$[ebp]
  000a2	51		 push	 ecx
  000a3	f3 0f 10 81 f8
	00 00 00	 movss	 xmm0, DWORD PTR [ecx+248]
  000ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b0	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  000b5	83 c4 08	 add	 esp, 8
  000b8	8b 55 f8	 mov	 edx, DWORD PTR _window$[ebp]
  000bb	d9 9a f8 00 00
	00		 fstp	 DWORD PTR [edx+248]
$LN1@AlignTextT:

; 1218 : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ca	3b ec		 cmp	 ebp, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?AlignTextToFramePadding@ImGui@@YAXXZ ENDP		; ImGui::AlignTextToFramePadding
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Dummy@ImGui@@YAXABUImVec2@@@Z
_TEXT	SEGMENT
$T1 = -244						; size = 8
_bb$ = -36						; size = 16
_window$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_size$ = 8						; size = 4
?Dummy@ImGui@@YAXABUImVec2@@@Z PROC			; ImGui::Dummy, COMDAT

; 1183 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1184 :     ImGuiWindow* window = GetCurrentWindow();

  00032	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  00037	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 1185 :     if (window->SkipItems)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  0003d	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00041	85 c9		 test	 ecx, ecx
  00043	74 02		 je	 SHORT $LN2@Dummy

; 1186 :         return;

  00045	eb 59		 jmp	 SHORT $LN1@Dummy
$LN2@Dummy:

; 1187 : 
; 1188 :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);

  00047	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  0004e	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  00054	51		 push	 ecx
  00055	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	50		 push	 eax
  00065	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  00068	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0006d	50		 push	 eax
  0006e	8d 4d dc	 lea	 ecx, DWORD PTR _bb$[ebp]
  00071	e8 00 00 00 00	 call	 ??0ImRect@@QAE@ABUImVec2@@0@Z ; ImRect::ImRect

; 1189 :     ItemSize(size);

  00076	51		 push	 ecx
  00077	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0007f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00084	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  0008d	83 c4 08	 add	 esp, 8

; 1190 :     ItemAdd(bb, 0);

  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	8d 45 dc	 lea	 eax, DWORD PTR _bb$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?ItemAdd@ImGui@@YA_NABUImRect@@IPBU2@@Z ; ImGui::ItemAdd
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Dummy:

; 1191 : }

  000a0	52		 push	 edx
  000a1	8b cd		 mov	 ecx, ebp
  000a3	50		 push	 eax
  000a4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Dummy
  000aa	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000af	58		 pop	 eax
  000b0	5a		 pop	 edx
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  000c4	3b ec		 cmp	 ebp, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
  000cf	90		 npad	 1
$LN6@Dummy:
  000d0	01 00 00 00	 DD	 1
  000d4	00 00 00 00	 DD	 $LN5@Dummy
$LN5@Dummy:
  000d8	dc ff ff ff	 DD	 -36			; ffffffdcH
  000dc	10 00 00 00	 DD	 16			; 00000010H
  000e0	00 00 00 00	 DD	 $LN4@Dummy
$LN4@Dummy:
  000e4	62		 DB	 98			; 00000062H
  000e5	62		 DB	 98			; 00000062H
  000e6	00		 DB	 0
?Dummy@ImGui@@YAXABUImVec2@@@Z ENDP			; ImGui::Dummy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Spacing@ImGui@@YAXXZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_window$ = -8						; size = 4
?Spacing@ImGui@@YAXXZ PROC				; ImGui::Spacing, COMDAT

; 1175 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1176 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 1177 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 02		 je	 SHORT $LN2@Spacing

; 1178 :         return;

  0003b	eb 34		 jmp	 SHORT $LN1@Spacing
$LN2@Spacing:

; 1179 :     ItemSize(ImVec2(0,0));

  0003d	51		 push	 ecx
  0003e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	51		 push	 ecx
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	51		 push	 ecx
  00055	0f 57 c0	 xorps	 xmm0, xmm0
  00058	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005d	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00063	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  0006e	83 c4 08	 add	 esp, 8
$LN1@Spacing:

; 1180 : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?Spacing@ImGui@@YAXXZ ENDP				; ImGui::Spacing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?NewLine@ImGui@@YAXXZ
_TEXT	SEGMENT
$T1 = -256						; size = 8
$T2 = -240						; size = 8
_backup_layout_type$ = -32				; size = 4
_g$ = -20						; size = 4
_window$ = -8						; size = 4
?NewLine@ImGui@@YAXXZ PROC				; ImGui::NewLine, COMDAT

; 1194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-260]
  00012	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1195 :     ImGuiWindow* window = GetCurrentWindow();

  00028	e8 00 00 00 00	 call	 ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindow
  0002d	89 45 f8	 mov	 DWORD PTR _window$[ebp], eax

; 1196 :     if (window->SkipItems)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00033	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00037	85 c9		 test	 ecx, ecx
  00039	74 05		 je	 SHORT $LN2@NewLine

; 1197 :         return;

  0003b	e9 b3 00 00 00	 jmp	 $LN1@NewLine
$LN2@NewLine:

; 1198 : 
; 1199 :     ImGuiContext& g = *GImGui;

  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  00045	89 45 ec	 mov	 DWORD PTR _g$[ebp], eax

; 1200 :     const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  0004b	8b 88 5c 01 00
	00		 mov	 ecx, DWORD PTR [eax+348]
  00051	89 4d e0	 mov	 DWORD PTR _backup_layout_type$[ebp], ecx

; 1201 :     window->DC.LayoutType = ImGuiLayoutType_Vertical;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00057	c7 80 5c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+348], 1

; 1202 :     if (window->DC.CurrLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.

  00061	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  00064	f3 0f 10 80 ec
	00 00 00	 movss	 xmm0, DWORD PTR [eax+236]
  0006c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00073	76 36		 jbe	 SHORT $LN3@NewLine

; 1203 :         ItemSize(ImVec2(0,0));

  00075	51		 push	 ecx
  00076	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	51		 push	 ecx
  00084	0f 57 c0	 xorps	 xmm0, xmm0
  00087	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008c	51		 push	 ecx
  0008d	0f 57 c0	 xorps	 xmm0, xmm0
  00090	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00095	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0009b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  000a6	83 c4 08	 add	 esp, 8
  000a9	eb 3c		 jmp	 SHORT $LN4@NewLine
$LN3@NewLine:

; 1204 :     else
; 1205 :         ItemSize(ImVec2(0.0f, g.FontSize));

  000ab	51		 push	 ecx
  000ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b9	8b 45 ec	 mov	 eax, DWORD PTR _g$[ebp]
  000bc	51		 push	 ecx
  000bd	f3 0f 10 80 c4
	18 00 00	 movss	 xmm0, DWORD PTR [eax+6340]
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	51		 push	 ecx
  000cb	0f 57 c0	 xorps	 xmm0, xmm0
  000ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d3	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000d9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?ItemSize@ImGui@@YAXABUImVec2@@M@Z ; ImGui::ItemSize
  000e4	83 c4 08	 add	 esp, 8
$LN4@NewLine:

; 1206 :     window->DC.LayoutType = backup_layout_type;

  000e7	8b 45 f8	 mov	 eax, DWORD PTR _window$[ebp]
  000ea	8b 4d e0	 mov	 ecx, DWORD PTR _backup_layout_type$[ebp]
  000ed	89 88 5c 01 00
	00		 mov	 DWORD PTR [eax+348], ecx
$LN1@NewLine:

; 1207 : }

  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  000fc	3b ec		 cmp	 ebp, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
?NewLine@ImGui@@YAXXZ ENDP				; ImGui::NewLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_widgets.cpp
;	COMDAT ?Separator@ImGui@@YAXXZ
_TEXT	SEGMENT
tv71 = -232						; size = 4
_flags$ = -32						; size = 4
_window$ = -20						; size = 4
_g$ = -8						; size = 4
?Separator@ImGui@@YAXXZ PROC				; ImGui::Separator, COMDAT

; 1286 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __32F429E7_imgui_widgets@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1287 :     ImGuiContext& g = *GImGui;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
  0002d	89 45 f8	 mov	 DWORD PTR _g$[ebp], eax

; 1288 :     ImGuiWindow* window = g.CurrentWindow;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _g$[ebp]
  00033	8b 88 b0 19 00
	00		 mov	 ecx, DWORD PTR [eax+6576]
  00039	89 4d ec	 mov	 DWORD PTR _window$[ebp], ecx

; 1289 :     if (window->SkipItems)

  0003c	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0003f	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  00043	85 c9		 test	 ecx, ecx
  00045	74 02		 je	 SHORT $LN2@Separator

; 1290 :         return;

  00047	eb 40		 jmp	 SHORT $LN1@Separator
$LN2@Separator:

; 1291 : 
; 1292 :     // Those flags should eventually be overridable by the user
; 1293 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;

  00049	8b 45 ec	 mov	 eax, DWORD PTR _window$[ebp]
  0004c	83 b8 5c 01 00
	00 00		 cmp	 DWORD PTR [eax+348], 0
  00053	75 0c		 jne	 SHORT $LN4@Separator
  00055	c7 85 18 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR tv71[ebp], 2
  0005f	eb 0a		 jmp	 SHORT $LN5@Separator
$LN4@Separator:
  00061	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
$LN5@Separator:
  0006b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  00071	89 4d e0	 mov	 DWORD PTR _flags$[ebp], ecx

; 1294 :     flags |= ImGuiSeparatorFlags_SpanAllColumns;

  00074	8b 45 e0	 mov	 eax, DWORD PTR _flags$[ebp]
  00077	83 c8 04	 or	 eax, 4
  0007a	89 45 e0	 mov	 DWORD PTR _flags$[ebp], eax

; 1295 :     SeparatorEx(flags);

  0007d	8b 45 e0	 mov	 eax, DWORD PTR _flags$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?SeparatorEx@ImGui@@YAXH@Z ; ImGui::SeparatorEx
  00086	83 c4 04	 add	 esp, 4
$LN1@Separator:

; 1296 : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00092	3b ec		 cmp	 ebp, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?Separator@ImGui@@YAXXZ ENDP				; ImGui::Separator
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0ImVec4@@QAE@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 200  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __x$[ebp]
  00035	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __y$[ebp]
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR __z$[ebp]
  0004e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR __w$[ebp]
  0005b	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 10 00	 ret	 16			; 00000010H
??0ImVec4@@QAE@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImVec4@@QAE@XZ PROC					; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 199  :     ImVec4()  { x = y = z = w = 0.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	0f 57 c0	 xorps	 xmm0, xmm0
  00049	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??0ImVec4@@QAE@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??AImVec2@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_idx$ = 8						; size = 4
??AImVec2@@QAEAAMI@Z PROC				; ImVec2::operator[], COMDAT
; _this$ = ecx

; 189  :     float& operator[] (size_t idx)       { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	83 7d 08 01	 cmp	 DWORD PTR _idx$[ebp], 1
  00031	76 21		 jbe	 SHORT $LN3@operator
  00033	8b f4		 mov	 esi, esp
  00035	68 bd 00 00 00	 push	 189			; 000000bdH
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@IIGHOJGM@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00054	8b 45 08	 mov	 eax, DWORD PTR _idx$[ebp]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
??AImVec2@@QAEAAMI@Z ENDP				; ImVec2::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??AImVec2@@QBEMI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_idx$ = 8						; size = 4
??AImVec2@@QBEMI@Z PROC					; ImVec2::operator[], COMDAT
; _this$ = ecx

; 188  :     float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	83 7d 08 01	 cmp	 DWORD PTR _idx$[ebp], 1
  00031	76 21		 jbe	 SHORT $LN3@operator
  00033	8b f4		 mov	 esi, esp
  00035	68 bc 00 00 00	 push	 188			; 000000bcH
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@IIGHOJGM@?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00054	8b 45 08	 mov	 eax, DWORD PTR _idx$[ebp]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	d9 04 81	 fld	 DWORD PTR [ecx+eax*4]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
??AImVec2@@QBEMI@Z ENDP					; ImVec2::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 187  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __x$[ebp]
  00035	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __y$[ebp]
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImVec2@@QAE@XZ PROC					; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 186  :     ImVec2()  { x = y = 0.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??0ImVec2@@QAE@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
END
