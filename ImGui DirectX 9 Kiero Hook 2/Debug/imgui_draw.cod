; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29112.0 

	TITLE	D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__241EEA0C_corecrt_memory@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__42049807_imgui@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__F5601360_stdlib@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__71512A68_imgui_internal@h DB 01H
__614D3496_malloc@h DB 01H
__285947CA_imstb_rectpack@h DB 01H
__15A8FCCD_imstb_truetype@h DB 01H
__C693DA93_imgui_draw@cpp DB 01H
__45E2592B_predefined C++ types (compiler internal) DB 01H
msvcjmc	ENDS
CONST	SEGMENT
?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB DB '..-         -XXXXXXX-    X'
	DB	'    -           X           -XXXXXXX          -          XXXX'
	DB	'XXX-     XX          ..-         -X.....X-   X.X   -         '
	DB	' X.X          -X.....X          -          X.....X-    X..X  '
	DB	'       ---         -XXX.XXX-  X...X  -         X...X         '
	DB	'-X....X           -           X....X-    X..X         X      '
	DB	'     -  X.X  - X.....X -        X.....X        -X...X        '
	DB	'    -            X...X-    X..X         XX          -  X.X  -'
	DB	'X.......X-       X.......X       -X..X.X           -         '
	DB	'  X.X..X-    X..X         X.X         -  X.X  -XXXX.XXXX-    '
	DB	'   XXXX.XXXX       -X.X X.X          -          X.X X.X-    X'
	DB	'..XXX       X..X        -  X.X  -   X.X   -          X.X     '
	DB	'     -XX   X.X         -         X.X   XX-    X..X..XXX    X.'
	DB	'..X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.'
	DB	'X        -        X.X      -    X..X..X..XX  X....X      -  X'
	DB	'.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -    '
	DB	'   X.X       -    X..X..X..X.X X.....X     -  X.X  -   X.X   '
	DB	'-  X..X    X.X    X..X  -        X.X      -      X.X        -'
	DB	'XXX X..X..X..X..XX......X    -  X.X  -   X.X   - X...XXXXXX.X'
	DB	'XXXXX...X -         X.X   XX-XX   X.X         -X..XX........X'
	DB	'..XX.......X   -  X.X  -   X.X   -X.....................X-   '
	DB	'       X.X X.X-X.X X.X          -X...X...........XX........X '
	DB	' -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X'
	DB	'-X..X.X           - X..............XX.........X -XXX.XXX-   X'
	DB	'.X   -  X..X    X.X    X..X  -            X...X-X...X        '
	DB	'    -  X.............XX..........X-X.....X-   X.X   -   X.X  '
	DB	'  X.X    X.X   -           X....X-X....X           -  X......'
	DB	'.......XX......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX   '
	DB	' -          X.....X-X.....X          -   X............XX...X.'
	DB	'.X    ---------   X.X   -          X.X          -          XX'
	DB	'XXXXX-XXXXXXX          -   X...........X X..X X..X   -       '
	DB	'-XXXX.XXXX-       XXXX.XXXX       ---------------------------'
	DB	'----------    X..........X X.X  X..X   -       -X.......X-   '
	DB	'    X.......X       -    XX           XX    -           -    '
	DB	'X..........X XX    X..X  -       - X.....X -        X.....X  '
	DB	'      -   X.X           X.X   -           -     X........X   '
	DB	'     X..X          -  X...X  -         X...X         -  X..X '
	DB	'          X..X  -           -     X........X         XX      '
	DB	'     -   X.X   -          X.X          - X...XXXXXXXXXXXXX...'
	DB	'X -           -     XXXXXXXXXX  ------------        -    X   '
	DB	' -           X           -X.....................X-           '
	DB	'------------------                    -----------------------'
	DB	'------------ X...XXXXXXXXXXXXX...X -                         '
	DB	'                                                          -  '
	DB	'X..X           X..X  -                                       '
	DB	'                                            -   X.X          '
	DB	' X.X   -                                                     '
	DB	'                              -    XX           XX    -      '
	DB	'                       ', 00H		; FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS
	ORG $+3
?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesDefault'::`2'::ranges
	DW	0ffH
	DW	00H
	ORG $+2
?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesKorean'::`2'::ranges
	DW	0ffH
	DW	03131H
	DW	03163H
	DW	0ac00H
	DW	0d79dH
	DW	00H
	ORG $+2
?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesChineseFull'::`2'::ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	04e00H
	DW	09fafH
	DW	00H
	ORG $+6
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	08H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	05H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	0aH
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	0eH
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	06H
	DW	07H
	DW	0aH
	DW	04H
	DW	07H
	DW	0dH
	DW	01H
	DW	05H
	DW	04H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01cH
	DW	05H
	DW	06H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	014H
	DW	02H
	DW	02H
	DW	09H
	DW	08H
	DW	0bH
	DW	02H
	DW	09H
	DW	011H
	DW	01H
	DW	08H
	DW	06H
	DW	08H
	DW	01bH
	DW	04H
	DW	06H
	DW	09H
	DW	014H
	DW	0bH
	DW	01bH
	DW	06H
	DW	044H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	06H
	DW	0bH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	07H
	DW	02H
	DW	01H
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	05H
	DW	06H
	DW	03H
	DW	06H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	03H
	DW	09H
	DW	02H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	04H
	DW	05H
	DW	0fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	03H
	DW	016H
	DW	013H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	0cH
	DW	08H
	DW	02H
	DW	09H
	DW	012H
	DW	016H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	010H
	DW	01H
	DW	02H
	DW	07H
	DW	0aH
	DW	0fH
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	02H
	DW	05H
	DW	07H
	DW	02H
	DW	013H
	DW	04H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	06H
	DW	02H
	DW	02H
	DW	0eH
	DW	04H
	DW	06H
	DW	06H
	DW	0bH
	DW	09H
	DW	01H
	DW	0fH
	DW	03H
	DW	01H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	05H
	DW	04H
	DW	06H
	DW	0eH
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	015H
	DW	02H
	DW	07H
	DW	014H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	04H
	DW	01cH
	DW	01cH
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	0eH
	DW	04H
	DW	01H
	DW	01aH
	DW	01cH
	DW	02aH
	DW	0cH
	DW	028H
	DW	03H
	DW	034H
	DW	04fH
	DW	05H
	DW	0eH
	DW	011H
	DW	03H
	DW	02H
	DW	02H
	DW	0bH
	DW	03H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	08H
	DW	02H
	DW	017H
	DW	04H
	DW	05H
	DW	08H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01cH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	014H
	DW	05H
	DW	03H
	DW	01dH
	DW	03H
	DW	011H
	DW	01aH
	DW	01H
	DW	08H
	DW	04H
	DW	01bH
	DW	03H
	DW	06H
	DW	0bH
	DW	017H
	DW	05H
	DW	03H
	DW	04H
	DW	06H
	DW	0dH
	DW	018H
	DW	010H
	DW	06H
	DW	05H
	DW	0aH
	DW	019H
	DW	023H
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	06H
	DW	02H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	0dH
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	0eH
	DW	0eH
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	0eH
	DW	03H
	DW	0cH
	DW	03H
	DW	011H
	DW	02H
	DW	010H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	08H
	DW	09H
	DW	03H
	DW	013H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	011H
	DW	019H
	DW	015H
	DW	014H
	DW	01cH
	DW	04bH
	DW	01H
	DW	0aH
	DW	01dH
	DW	067H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	018H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	06H
	DW	0dH
	DW	09H
	DW	010H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	05H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	0dH
	DW	07H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	01H
	DW	0eH
	DW	02H
	DW	0eH
	DW	02H
	DW	01H
	DW	012H
	DW	03H
	DW	04H
	DW	0eH
	DW	04H
	DW	0bH
	DW	029H
	DW	0fH
	DW	017H
	DW	0fH
	DW	017H
	DW	0b0H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	07H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	09H
	DW	07H
	DW	01H
	DW	0aH
	DW	05H
	DW	08H
	DW	010H
	DW	01dH
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	05H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	07H
	DW	01H
	DW	06H
	DW	0aH
	DW	01H
	DW	011H
	DW	01H
	DW	02cH
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	05H
	DW	04H
	DW	02H
	DW	0aH
	DW	01H
	DW	06H
	DW	09H
	DW	02H
	DW	08H
	DW	01H
	DW	018H
	DW	01H
	DW	02H
	DW	0dH
	DW	07H
	DW	08H
	DW	08H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	02H
	DW	05H
	DW	0aH
	DW	09H
	DW	04H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	04H
	DW	0aH
	DW	08H
	DW	03H
	DW	01H
	DW	0dH
	DW	04H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	011H
	DW	010H
	DW	05H
	DW	02H
	DW	010H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	05H
	DW	0bH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	06H
	DW	0aH
	DW	09H
	DW	05H
	DW	07H
	DW	04H
	DW	07H
	DW	04H
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	08H
	DW	07H
	DW	01H
	DW	06H
	DW	0bH
	DW	05H
	DW	05H
	DW	03H
	DW	018H
	DW	09H
	DW	04H
	DW	02H
	DW	07H
	DW	0dH
	DW	05H
	DW	01H
	DW	08H
	DW	052H
	DW	010H
	DW	03dH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	010H
	DW	0aH
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	06H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	08H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	0bH
	DW	03H
	DW	09H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	09H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	07H
	DW	09H
	DW	09H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	020H
	DW	06H
	DW	01H
	DW	02H
	DW	0fH
	DW	09H
	DW	03H
	DW	07H
	DW	0dH
	DW	01H
	DW	03H
	DW	0aH
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0dH
	DW	0aH
	DW	02H
	DW	01H
	DW	03H
	DW	0aH
	DW	04H
	DW	0fH
	DW	02H
	DW	0fH
	DW	0fH
	DW	0aH
	DW	01H
	DW	03H
	DW	09H
	DW	06H
	DW	09H
	DW	020H
	DW	019H
	DW	01aH
	DW	02fH
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	03H
	DW	04H
	DW	03H
	DW	02H
	DW	08H
	DW	05H
	DW	04H
	DW	01H
	DW	09H
	DW	04H
	DW	02H
	DW	02H
	DW	013H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	06H
	DW	04H
	DW	08H
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	05H
	DW	05H
	DW	01H
	DW	03H
	DW	08H
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	04H
	DW	0cH
	DW	01H
	DW	05H
	DW	03H
	DW	07H
	DW	0dH
	DW	02H
	DW	05H
	DW	08H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	05H
	DW	0eH
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	08H
	DW	0fH
	DW	05H
	DW	01H
	DW	017H
	DW	06H
	DW	03eH
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	0aH
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	07H
	DW	01H
	DW	0eH
	DW	01H
	DW	02H
	DW	03H
	DW	0cH
	DW	05H
	DW	02H
	DW	05H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	07H
	DW	0eH
	DW	0bH
	DW	01H
	DW	03H
	DW	01H
	DW	08H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	0bH
	DW	08H
	DW	04H
	DW	04H
	DW	02H
	DW	06H
	DW	0aH
	DW	09H
	DW	0dH
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	05H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	012H
	DW	02H
	DW	03H
	DW	0eH
	DW	0bH
	DW	04H
	DW	01dH
	DW	04H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	0dH
	DW	09H
	DW	02H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	014H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	048H
	DW	022H
	DW	06H
	DW	04H
	DW	016H
	DW	0cH
	DW	0cH
	DW	01cH
	DW	02dH
	DW	024H
	DW	09H
	DW	07H
	DW	027H
	DW	09H
	DW	0bfH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0bH
	DW	08H
	DW	04H
	DW	09H
	DW	02H
	DW	03H
	DW	016H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	011H
	DW	01H
	DW	07H
	DW	07H
	DW	01H
	DW	0bH
	DW	01fH
	DW	0aH
	DW	02H
	DW	04H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	010H
	DW	04H
	DW	020H
	DW	02H
	DW	03H
	DW	013H
	DW	0dH
	DW	04H
	DW	09H
	DW	01H
	DW	05H
	DW	02H
	DW	0eH
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	013H
	DW	06H
	DW	05H
	DW	01H
	DW	010H
	DW	06H
	DW	02H
	DW	0aH
	DW	08H
	DW	05H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	05H
	DW	01H
	DW	0bH
	DW	06H
	DW	06H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	07H
	DW	05H
	DW	07H
	DW	07H
	DW	05H
	DW	08H
	DW	09H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	010H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	03H
	DW	0fH
	DW	02H
	DW	09H
	DW	02H
	DW	0aH
	DW	019H
	DW	0dH
	DW	09H
	DW	010H
	DW	06H
	DW	02H
	DW	02H
	DW	0aH
	DW	0bH
	DW	04H
	DW	03H
	DW	09H
	DW	01H
	DW	02H
	DW	06H
	DW	06H
	DW	05H
	DW	04H
	DW	01eH
	DW	028H
	DW	01H
	DW	0aH
	DW	07H
	DW	0cH
	DW	0eH
	DW	021H
	DW	06H
	DW	03H
	DW	06H
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	0eH
	DW	04H
	DW	09H
	DW	05H
	DW	0cH
	DW	0bH
	DW	031H
	DW	012H
	DW	033H
	DW	01fH
	DW	08cH
	DW	01fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	08H
	DW	01H
	DW	0aH
	DW	01H
	DW	04H
	DW	04H
	DW	03H
	DW	018H
	DW	01H
	DW	0aH
	DW	01H
	DW	03H
	DW	06H
	DW	06H
	DW	010H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	039H
	DW	0aH
	DW	06H
	DW	016H
	DW	02H
	DW	016H
	DW	03H
	DW	07H
	DW	016H
	DW	06H
	DW	0aH
	DW	0bH
	DW	024H
	DW	012H
	DW	010H
	DW	021H
	DW	024H
	DW	02H
	DW	05H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	01H
	DW	04H
	DW	0dH
	DW	02H
	DW	07H
	DW	05H
	DW	02H
	DW	09H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02bH
	DW	03H
	DW	07H
	DW	03H
	DW	09H
	DW	0eH
	DW	07H
	DW	09H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	04H
	DW	012H
	DW	0dH
	DW	01H
	DW	0eH
	DW	01H
	DW	03H
	DW	06H
	DW	0aH
	DW	049H
	DW	02H
	DW	02H
	DW	01eH
	DW	06H
	DW	01H
	DW	0bH
	DW	012H
	DW	013H
	DW	0dH
	DW	016H
	DW	03H
	DW	02eH
	DW	02aH
	DW	025H
	DW	059H
	DW	07H
	DW	03H
	DW	010H
	DW	022H
	DW	02H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	03H
	DW	0aH
	DW	03H
	DW	09H
	DW	05H
	DW	01cH
	DW	09H
	DW	02H
	DW	06H
	DW	0dH
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	0aH
	DW	02H
	DW	07H
	DW	02H
	DW	0bH
	DW	03H
	DW	06H
	DW	015H
	DW	036H
	DW	055H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	027H
	DW	03H
	DW	015H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0fH
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	014H
	DW	01H
	DW	08H
	DW	07H
	DW	0dH
	DW	04H
	DW	01H
	DW	01aH
	DW	06H
	DW	02H
	DW	09H
	DW	022H
	DW	04H
	DW	015H
	DW	034H
	DW	0aH
	DW	04H
	DW	04H
	DW	01H
	DW	05H
	DW	0cH
	DW	02H
	DW	0bH
	DW	01H
	DW	07H
	DW	02H
	DW	01eH
	DW	0cH
	DW	02cH
	DW	02H
	DW	01eH
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	010H
	DW	09H
	DW	011H
	DW	027H
	DW	052H
	DW	02H
	DW	02H
	DW	018H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	010H
	DW	09H
	DW	0eH
	DW	02cH
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	0bH
	DW	05H
	DW	0bH
	DW	02H
	DW	01H
	DW	012H
	DW	013H
	DW	08H
	DW	01H
	DW	03H
	DW	018H
	DW	01dH
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	0dH
	DW	06H
	DW	05H
	DW	01H
	DW	02eH
	DW	0bH
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	08H
	DW	02H
	DW	0aH
	DW	06H
	DW	0cH
	DW	06H
	DW	03H
	DW	07H
	DW	0bH
	DW	02H
	DW	04H
	DW	010H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	05H
	DW	02H
	DW	01cH
	DW	05H
	DW	02H
	DW	017H
	DW	0aH
	DW	08H
	DW	04H
	DW	04H
	DW	016H
	DW	027H
	DW	05fH
	DW	026H
	DW	08H
	DW	0eH
	DW	09H
	DW	05H
	DW	01H
	DW	0dH
	DW	05H
	DW	04H
	DW	03H
	DW	0dH
	DW	0cH
	DW	0bH
	DW	01H
	DW	09H
	DW	01H
	DW	01bH
	DW	025H
	DW	02H
	DW	05H
	DW	04H
	DW	04H
	DW	03fH
	DW	0d3H
	DW	05fH
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	05H
	DW	03H
	DW	02H
	DW	05H
	DW	03H
	DW	09H
	DW	0bH
	DW	04H
	DW	02H
	DW	016H
	DW	01H
	DW	06H
	DW	03H
	DW	08H
	DW	07H
	DW	01H
	DW	04H
	DW	01cH
	DW	04H
	DW	010H
	DW	03H
	DW	03H
	DW	019H
	DW	04H
	DW	04H
	DW	01bH
	DW	01bH
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01cH
	DW	08H
	DW	02H
	DW	0eH
	DW	01H
	DW	08H
	DW	06H
	DW	010H
	DW	019H
	DW	03H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	06H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	012H
	DW	03H
	DW	02H
	DW	05H
	DW	05H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	04H
	DW	017H
	DW	07H
	DW	06H
	DW	0cH
	DW	06H
	DW	04H
	DW	011H
	DW	0bH
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	0aH
	DW	05H
	DW	0cH
	DW	01H
	DW	01H
	DW	0bH
	DW	01aH
	DW	021H
	DW	07H
	DW	03H
	DW	06H
	DW	01H
	DW	011H
	DW	07H
	DW	01H
	DW	05H
	DW	0cH
	DW	01H
	DW	0bH
	DW	02H
	DW	04H
	DW	01H
	DW	08H
	DW	0eH
	DW	011H
	DW	017H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	08H
	DW	010H
	DW	0bH
	DW	09H
	DW	06H
	DW	05H
	DW	02H
	DW	06H
	DW	04H
	DW	010H
	DW	02H
	DW	08H
	DW	0eH
	DW	01H
	DW	0bH
	DW	08H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	019H
	DW	04H
	DW	0bH
	DW	013H
	DW	07H
	DW	02H
	DW	0fH
	DW	02H
	DW	0cH
	DW	08H
	DW	034H
	DW	07H
	DW	05H
	DW	013H
	DW	02H
	DW	010H
	DW	04H
	DW	024H
	DW	08H
	DW	01H
	DW	010H
	DW	08H
	DW	018H
	DW	01aH
	DW	04H
	DW	06H
	DW	02H
	DW	09H
	DW	05H
	DW	04H
	DW	024H
	DW	03H
	DW	01cH
	DW	0cH
	DW	019H
	DW	0fH
	DW	025H
	DW	01bH
	DW	011H
	DW	0cH
	DW	03bH
	DW	026H
	DW	05H
	DW	020H
	DW	07fH
	DW	01H
	DW	02H
	DW	09H
	DW	011H
	DW	0eH
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	08H
	DW	0bH
	DW	032H
	DW	04H
	DW	0eH
	DW	02H
	DW	013H
	DW	010H
	DW	04H
	DW	011H
	DW	05H
	DW	04H
	DW	05H
	DW	01aH
	DW	0cH
	DW	02dH
	DW	02H
	DW	017H
	DW	02dH
	DW	068H
	DW	01eH
	DW	0cH
	DW	08H
	DW	03H
	DW	0aH
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	014H
	DW	07H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	02H
	DW	014H
	DW	01H
	DW	03H
	DW	010H
	DW	04H
	DW	0bH
	DW	0fH
	DW	06H
	DW	086H
	DW	02H
	DW	05H
	DW	03bH
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	09H
	DW	011H
	DW	03H
	DW	01aH
	DW	089H
	DW	0aH
	DW	0d3H
	DW	03bH
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	0eH
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	01bH
	DW	09H
	DW	022H
	DW	091H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	08H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	05H
	DW	01H
	DW	014H
	DW	04H
	DW	010H
	DW	01H
	DW	0fH
	DW	09H
	DW	05H
	DW	0cH
	DW	02H
	DW	09H
	DW	02H
	DW	05H
	DW	04H
	DW	02H
	DW	01aH
	DW	013H
	DW	07H
	DW	01H
	DW	01aH
	DW	04H
	DW	01eH
	DW	0cH
	DW	0fH
	DW	02aH
	DW	01H
	DW	06H
	DW	08H
	DW	0acH
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	0bH
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	08H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	0cH
	DW	0eH
	DW	0bH
	DW	06H
	DW	06H
	DW	04H
	DW	0cH
	DW	02H
	DW	08H
	DW	01H
	DW	07H
	DW	0aH
	DW	01H
	DW	023H
	DW	07H
	DW	04H
	DW	0dH
	DW	0fH
	DW	04H
	DW	03H
	DW	017H
	DW	015H
	DW	01cH
	DW	034H
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	01H
	DW	07H
	DW	0aH
	DW	02H
	DW	07H
	DW	035H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	0a3H
	DW	0214H
	DW	01H
	DW	0aH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	04H
	DW	08H
	DW	02H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	017H
	DW	016H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	09H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01H
	DW	0aH
	DW	02H
	DW	0cH
	DW	015H
	DW	014H
	DW	0fH
	DW	069H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	0fH
	DW	0bH
	DW	013H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	0fH
	DW	09H
	DW	01H
	DW	04H
	DW	05H
	DW	03H
	DW	01aH
	DW	08H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0fH
	DW	013H
	DW	02H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	02H
	DW	07H
	DW	02H
	DW	013H
	DW	02H
	DW	014H
	DW	06H
	DW	01aH
	DW	07H
	DW	05H
	DW	02H
	DW	02H
	DW	07H
	DW	022H
	DW	015H
	DW	0dH
	DW	046H
	DW	02H
	DW	080H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0fH
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02aH
	DW	0aH
	DW	06H
	DW	01H
	DW	031H
	DW	055H
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	05H
	DW	07H
	DW	04H
	DW	03H
	DW	0d3H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	06H
	DW	05H
	DW	06H
	DW	0aH
	DW	03H
	DW	04H
	DW	030H
	DW	064H
	DW	06H
	DW	02H
	DW	010H
	DW	0128H
	DW	05H
	DW	01bH
	DW	0183H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	026H
	DW	0fH
	DW	027H
	DW	015H
	DW	09H
	DW	0aH
	DW	03H
	DW	07H
	DW	03bH
	DW	0dH
	DW	01bH
	DW	015H
	DW	02fH
	DW	05H
	DW	015H
	DW	06H
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	02H
	DW	01H
	DW	08H
	DW	05H
	DW	07H
	DW	0bH
	DW	01H
	DW	02H
	DW	0aH
	DW	0aH
	DW	08H
	DW	02H
	DW	04H
	DW	014H
	DW	02H
	DW	0bH
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	07H
	DW	05H
	DW	03H
	DW	07H
	DW	01H
	DW	01H
	DW	0dH
	DW	07H
	DW	09H
	DW	01H
	DW	04H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	09H
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	06H
	DW	0eH
	DW	01H
	DW	01H
	DW	09H
	DW	03H
	DW	012H
	DW	05H
	DW	04H
	DW	02H
	DW	02H
	DW	0aH
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	03H
	DW	017H
	DW	02H
	DW	0aH
	DW	0cH
	DW	02H
	DW	0eH
	DW	02H
	DW	04H
	DW	0dH
	DW	01H
	DW	06H
	DW	0aH
	DW	03H
	DW	01H
	DW	07H
	DW	0dH
	DW	06H
	DW	04H
	DW	0dH
	DW	05H
	DW	02H
	DW	03H
	DW	011H
	DW	02H
	DW	02H
	DW	05H
	DW	07H
	DW	06H
	DW	04H
	DW	01H
	DW	07H
	DW	0eH
	DW	010H
	DW	06H
	DW	0dH
	DW	09H
	DW	0fH
	DW	01H
	DW	01H
	DW	07H
	DW	010H
	DW	04H
	DW	07H
	DW	01H
	DW	013H
	DW	09H
	DW	02H
	DW	07H
	DW	0fH
	DW	02H
	DW	06H
	DW	05H
	DW	0dH
	DW	019H
	DW	04H
	DW	0eH
	DW	0dH
	DW	0bH
	DW	019H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	0aH
	DW	0bH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	09H
	DW	01H
	DW	04H
	DW	03H
	DW	05H
	DW	05H
	DW	02H
	DW	07H
	DW	0cH
	DW	0bH
	DW	0fH
	DW	07H
	DW	010H
	DW	04H
	DW	05H
	DW	010H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	07H
	DW	06H
	DW	06H
	DW	07H
	DW	01H
	DW	04H
	DW	07H
	DW	06H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0cH
	DW	03H
	DW	03H
	DW	09H
	DW	05H
	DW	08H
	DW	01H
	DW	0bH
	DW	01H
	DW	02H
	DW	03H
	DW	012H
	DW	014H
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	07H
	DW	03H
	DW	05H
	DW	05H
	DW	07H
	DW	02H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	0bH
	DW	08H
	DW	07H
	DW	04H
	DW	011H
	DW	01H
	DW	09H
	DW	019H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	06H
	DW	010H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	0cH
	DW	014H
	DW	02H
	DW	05H
	DW	014H
	DW	08H
	DW	07H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	0cH
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	07H
	DW	05H
	DW	0dH
	DW	01H
	DW	0fH
	DW	01H
	DW	01H
	DW	01eH
	DW	0bH
	DW	09H
	DW	01H
	DW	0fH
	DW	026H
	DW	0eH
	DW	01H
	DW	020H
	DW	011H
	DW	014H
	DW	01H
	DW	09H
	DW	01fH
	DW	02H
	DW	015H
	DW	09H
	DW	04H
	DW	031H
	DW	016H
	DW	02H
	DW	01H
	DW	0dH
	DW	01H
	DW	0bH
	DW	02dH
	DW	023H
	DW	02bH
	DW	037H
	DW	0cH
	DW	013H
	DW	053H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	0dH
	DW	02H
	DW	01H
	DW	07H
	DW	03H
	DW	012H
	DW	03H
	DW	0dH
	DW	08H
	DW	01H
	DW	08H
	DW	012H
	DW	05H
	DW	03H
	DW	07H
	DW	019H
	DW	018H
	DW	09H
	DW	018H
	DW	028H
	DW	03H
	DW	011H
	DW	018H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	010H
	DW	0fH
	DW	06H
	DW	07H
	DW	03H
	DW	0cH
	DW	01H
	DW	09H
	DW	07H
	DW	03H
	DW	03H
	DW	03H
	DW	0fH
	DW	015H
	DW	05H
	DW	010H
	DW	04H
	DW	05H
	DW	0cH
	DW	0bH
	DW	0bH
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	01fH
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	017H
	DW	06H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	06H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	016H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	011H
	DW	03H
	DW	02H
	DW	04H
	DW	05H
	DW	01H
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	0fH
	DW	0cH
	DW	03H
	DW	011H
	DW	02H
	DW	0eH
	DW	02H
	DW	08H
	DW	01H
	DW	017H
	DW	010H
	DW	04H
	DW	02H
	DW	017H
	DW	08H
	DW	0fH
	DW	017H
	DW	014H
	DW	0cH
	DW	019H
	DW	013H
	DW	02fH
	DW	0bH
	DW	015H
	DW	041H
	DW	02eH
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	06H
	DW	01H
	DW	02H
	DW	05H
	DW	01aH
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	0bH
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	0aH
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	02H
	DW	06H
	DW	06H
	DW	09H
	DW	02H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	05H
	DW	0aH
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	09H
	DW	017H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	02H
	DW	01H
	DW	0aH
	DW	09H
	DW	06H
	DW	01H
	DW	0aH
	DW	02H
	DW	01fH
	DW	019H
	DW	03H
	DW	07H
	DW	05H
	DW	028H
	DW	01H
	DW	0fH
	DW	06H
	DW	011H
	DW	07H
	DW	01bH
	DW	0b4H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	0aH
	DW	07H
	DW	01H
	DW	03H
	DW	06H
	DW	011H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	05H
	DW	08H
	DW	010H
	DW	0eH
	DW	0fH
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	07H
	DW	05H
	DW	06H
	DW	02H
	DW	05H
	DW	0aH
	DW	01H
	DW	04H
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	0bH
	DW	06H
	DW	01H
	DW	02cH
	DW	01H
	DW	03H
	DW	07H
	DW	09H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0aH
	DW	07H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	015H
	DW	0fH
	DW	07H
	DW	02H
	DW	05H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	0aH
	DW	08H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	05H
	DW	0aH
	DW	02H
	DW	07H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0bH
	DW	0aH
	DW	01dH
	DW	04H
	DW	07H
	DW	03H
	DW	05H
	DW	02H
	DW	03H
	DW	021H
	DW	05H
	DW	02H
	DW	013H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	06H
	DW	01fH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	08H
	DW	0aH
	DW	09H
	DW	0cH
	DW	0bH
	DW	0cH
	DW	08H
	DW	03H
	DW	0eH
	DW	08H
	DW	06H
	DW	0bH
	DW	01H
	DW	04H
	DW	029H
	DW	03H
	DW	01H
	DW	02H
	DW	07H
	DW	0dH
	DW	01H
	DW	05H
	DW	06H
	DW	02H
	DW	06H
	DW	0cH
	DW	0cH
	DW	016H
	DW	05H
	DW	09H
	DW	04H
	DW	08H
	DW	09H
	DW	09H
	DW	022H
	DW	06H
	DW	018H
	DW	01H
	DW	01H
	DW	014H
	DW	09H
	DW	09H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	01cH
	DW	05H
	DW	03H
	DW	06H
	DW	01H
	DW	04H
	DW	06H
	DW	07H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	0dH
	DW	06H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	08H
	DW	08H
	DW	03H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	0bH
	DW	0bH
	DW	07H
	DW	03H
	DW	06H
	DW	0aH
	DW	08H
	DW	06H
	DW	010H
	DW	010H
	DW	016H
	DW	07H
	DW	0cH
	DW	06H
	DW	015H
	DW	05H
	DW	04H
	DW	06H
	DW	06H
	DW	03H
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01dH
	DW	01H
	DW	0aH
	DW	01H
	DW	06H
	DW	0dH
	DW	06H
	DW	06H
	DW	013H
	DW	01fH
	DW	01H
	DW	0dH
	DW	04H
	DW	04H
	DW	016H
	DW	011H
	DW	01aH
	DW	021H
	DW	0aH
	DW	04H
	DW	0fH
	DW	0cH
	DW	019H
	DW	06H
	DW	043H
	DW	0aH
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	0aH
	DW	02H
	DW	06H
	DW	02H
	DW	09H
	DW	01H
	DW	09H
	DW	04H
	DW	04H
	DW	01H
	DW	02H
	DW	010H
	DW	02H
	DW	05H
	DW	09H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	08H
	DW	03H
	DW	09H
	DW	04H
	DW	08H
	DW	06H
	DW	04H
	DW	08H
	DW	0bH
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01aH
	DW	01H
	DW	07H
	DW	05H
	DW	01H
	DW	0bH
	DW	01H
	DW	05H
	DW	03H
	DW	05H
	DW	02H
	DW	0dH
	DW	06H
	DW	027H
	DW	05H
	DW	01H
	DW	05H
	DW	02H
	DW	0bH
	DW	06H
	DW	0aH
	DW	05H
	DW	01H
	DW	0fH
	DW	05H
	DW	03H
	DW	06H
	DW	013H
	DW	015H
	DW	016H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	01H
	DW	08H
	DW	01H
	DW	04H
	DW	08H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	03H
	DW	0cH
	DW	07H
	DW	01H
	DW	0eH
	DW	02H
	DW	04H
	DW	0aH
	DW	02H
	DW	0dH
	DW	01H
	DW	011H
	DW	07H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	0dH
	DW	07H
	DW	0eH
	DW	0cH
	DW	03H
	DW	01H
	DW	01dH
	DW	02H
	DW	08H
	DW	09H
	DW	0fH
	DW	0eH
	DW	09H
	DW	0eH
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	05H
	DW	09H
	DW	0bH
	DW	03H
	DW	026H
	DW	02bH
	DW	014H
	DW	07H
	DW	07H
	DW	08H
	DW	05H
	DW	0fH
	DW	0cH
	DW	013H
	DW	0fH
	DW	051H
	DW	08H
	DW	07H
	DW	01H
	DW	05H
	DW	049H
	DW	0dH
	DW	025H
	DW	01cH
	DW	08H
	DW	08H
	DW	01H
	DW	0fH
	DW	012H
	DW	014H
	DW	0a5H
	DW	01cH
	DW	01H
	DW	06H
	DW	0bH
	DW	08H
	DW	04H
	DW	0eH
	DW	07H
	DW	0fH
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	07H
	DW	0eH
	DW	01H
	DW	01H
	DW	0bH
	DW	01eH
	DW	01H
	DW	05H
	DW	01H
	DW	04H
	DW	0eH
	DW	01H
	DW	04H
	DW	02H
	DW	07H
	DW	034H
	DW	02H
	DW	06H
	DW	01dH
	DW	03H
	DW	01H
	DW	09H
	DW	01H
	DW	015H
	DW	03H
	DW	05H
	DW	01H
	DW	01aH
	DW	03H
	DW	0bH
	DW	0eH
	DW	0bH
	DW	01H
	DW	011H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	08H
	DW	01H
	DW	02H
	DW	09H
	DW	0cH
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	08H
	DW	03H
	DW	018H
	DW	0cH
	DW	07H
	DW	07H
	DW	05H
	DW	011H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	017H
	DW	0aH
	DW	04H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	010H
	DW	011H
	DW	016H
	DW	03H
	DW	0aH
	DW	015H
	DW	010H
	DW	010H
	DW	06H
	DW	04H
	DW	0aH
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	08H
	DW	08H
	DW	06H
	DW	05H
	DW	03H
	DW	03H
	DW	03H
	DW	027H
	DW	019H
	DW	0fH
	DW	01H
	DW	01H
	DW	010H
	DW	06H
	DW	07H
	DW	019H
	DW	0fH
	DW	06H
	DW	06H
	DW	0cH
	DW	01H
	DW	016H
	DW	0dH
	DW	01H
	DW	04H
	DW	09H
	DW	05H
	DW	0cH
	DW	02H
	DW	09H
	DW	01H
	DW	0cH
	DW	01cH
	DW	08H
	DW	03H
	DW	05H
	DW	0aH
	DW	016H
	DW	03cH
	DW	01H
	DW	02H
	DW	028H
	DW	04H
	DW	03dH
	DW	03fH
	DW	04H
	DW	01H
	DW	0dH
	DW	0cH
	DW	01H
	DW	04H
	DW	01fH
	DW	0cH
	DW	01H
	DW	0eH
	DW	059H
	DW	05H
	DW	010H
	DW	06H
	DW	01dH
	DW	0eH
	DW	02H
	DW	05H
	DW	031H
	DW	012H
	DW	012H
	DW	05H
	DW	01dH
	DW	021H
	DW	02fH
	DW	01H
	DW	011H
	DW	01H
	DW	013H
	DW	0cH
	DW	02H
	DW	09H
	DW	07H
	DW	027H
	DW	0cH
	DW	03H
	DW	07H
	DW	0cH
	DW	027H
	DW	03H
	DW	01H
	DW	02eH
	DW	04H
	DW	0cH
	DW	03H
	DW	08H
	DW	09H
	DW	05H
	DW	01fH
	DW	0fH
	DW	012H
	DW	03H
	DW	02H
	DW	02H
	DW	042H
	DW	013H
	DW	0dH
	DW	011H
	DW	05H
	DW	03H
	DW	02eH
	DW	07cH
	DW	0dH
	DW	039H
	DW	022H
	DW	02H
	DW	05H
	DW	04H
	DW	05H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	011H
	DW	05H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	08H
	DW	05H
	DW	06H
	DW	03H
	DW	01bH
	DW	03H
	DW	01aH
	DW	07H
	DW	0cH
	DW	07H
	DW	02H
	DW	011H
	DW	03H
	DW	07H
	DW	012H
	DW	04eH
	DW	010H
	DW	04H
	DW	024H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	027H
	DW	011H
	DW	07H
	DW	04H
	DW	0dH
	DW	04H
	DW	04H
	DW	04H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	04H
	DW	06H
	DW	03H
	DW	0aH
	DW	01H
	DW	013H
	DW	01H
	DW	01aH
	DW	02H
	DW	04H
	DW	021H
	DW	02H
	DW	049H
	DW	02fH
	DW	07H
	DW	03H
	DW	08H
	DW	02H
	DW	04H
	DW	0fH
	DW	012H
	DW	01H
	DW	01dH
	DW	02H
	DW	029H
	DW	0eH
	DW	01H
	DW	015H
	DW	010H
	DW	029H
	DW	07H
	DW	027H
	DW	019H
	DW	0dH
	DW	02cH
	DW	02H
	DW	02H
	DW	0aH
	DW	01H
	DW	0dH
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	05H
	DW	014H
	DW	04H
	DW	08H
	DW	02H
	DW	031H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	06H
	DW	07H
	DW	0aH
	DW	07H
	DW	0bH
	DW	010H
	DW	03H
	DW	0cH
	DW	014H
	DW	04H
	DW	0aH
	DW	03H
	DW	01H
	DW	02H
	DW	0bH
	DW	02H
	DW	01cH
	DW	09H
	DW	02H
	DW	04H
	DW	07H
	DW	02H
	DW	0fH
	DW	01H
	DW	01bH
	DW	01H
	DW	01cH
	DW	011H
	DW	04H
	DW	05H
	DW	0aH
	DW	07H
	DW	03H
	DW	018H
	DW	0aH
	DW	0bH
	DW	06H
	DW	01aH
	DW	03H
	DW	02H
	DW	07H
	DW	02H
	DW	02H
	DW	031H
	DW	010H
	DW	0aH
	DW	010H
	DW	0fH
	DW	04H
	DW	05H
	DW	01bH
	DW	03dH
	DW	01eH
	DW	0eH
	DW	026H
	DW	016H
	DW	02H
	DW	07H
	DW	05H
	DW	01H
	DW	03H
	DW	0cH
	DW	017H
	DW	018H
	DW	011H
	DW	011H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	02H
	DW	07H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	09H
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	08H
	DW	02H
	DW	08H
	DW	04H
	DW	0eH
	DW	03H
	DW	05H
	DW	0bH
	DW	04H
	DW	01H
	DW	03H
	DW	020H
	DW	01H
	DW	013H
	DW	04H
	DW	01H
	DW	0dH
	DW	0bH
	DW	05H
	DW	02H
	DW	01H
	DW	08H
	DW	06H
	DW	08H
	DW	01H
	DW	06H
	DW	05H
	DW	0dH
	DW	03H
	DW	017H
	DW	0bH
	DW	05H
	DW	03H
	DW	010H
	DW	03H
	DW	09H
	DW	0aH
	DW	01H
	DW	018H
	DW	03H
	DW	0c6H
	DW	034H
	DW	04H
	DW	02H
	DW	02H
	DW	05H
	DW	0eH
	DW	05H
	DW	04H
	DW	016H
	DW	05H
	DW	014H
	DW	04H
	DW	0bH
	DW	06H
	DW	029H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	0bH
	DW	05H
	DW	02H
	DW	01cH
	DW	023H
	DW	08H
	DW	016H
	DW	03H
	DW	012H
	DW	03H
	DW	0aH
	DW	07H
	DW	05H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	08H
	DW	09H
	DW	03H
	DW	06H
	DW	02H
	DW	010H
	DW	016H
	DW	04H
	DW	05H
	DW	05H
	DW	03H
	DW	03H
	DW	012H
	DW	017H
	DW	02H
	DW	06H
	DW	017H
	DW	05H
	DW	01bH
	DW	08H
	DW	01H
	DW	021H
	DW	02H
	DW	0cH
	DW	02bH
	DW	010H
	DW	05H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	014H
	DW	04H
	DW	02H
	DW	09H
	DW	07H
	DW	01H
	DW	0bH
	DW	02H
	DW	0aH
	DW	03H
	DW	0eH
	DW	01fH
	DW	09H
	DW	03H
	DW	019H
	DW	012H
	DW	014H
	DW	02H
	DW	05H
	DW	05H
	DW	01aH
	DW	0eH
	DW	01H
	DW	0bH
	DW	011H
	DW	0cH
	DW	028H
	DW	013H
	DW	09H
	DW	06H
	DW	01fH
	DW	053H
	DW	02H
	DW	07H
	DW	09H
	DW	013H
	DW	04eH
	DW	0cH
	DW	0eH
	DW	015H
	DW	04cH
	DW	0cH
	DW	071H
	DW	04fH
	DW	022H
	DW	04H
	DW	01H
	DW	01H
	DW	03dH
	DW	012H
	DW	055H
	DW	0aH
	DW	02H
	DW	02H
	DW	0dH
	DW	01fH
	DW	0bH
	DW	032H
	DW	06H
	DW	021H
	DW	09fH
	DW	0b3H
	DW	06H
	DW	06H
	DW	07H
	DW	04H
	DW	04H
	DW	02H
	DW	04H
	DW	02H
	DW	05H
	DW	08H
	DW	07H
	DW	014H
	DW	020H
	DW	016H
	DW	01H
	DW	03H
	DW	0aH
	DW	06H
	DW	07H
	DW	01cH
	DW	05H
	DW	0aH
	DW	09H
	DW	02H
	DW	04dH
	DW	013H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	04H
	DW	07H
	DW	04H
	DW	0dH
	DW	03H
	DW	09H
	DW	01fH
	DW	011H
	DW	03H
	DW	01aH
	DW	02H
	DW	06H
	DW	06H
	DW	05H
	DW	04H
	DW	01H
	DW	07H
	DW	0bH
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	014H
	DW	04H
	DW	01H
	DW	09H
	DW	02H
	DW	06H
	DW	03H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	014H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	06H
	DW	02H
	DW	04H
	DW	08H
	DW	01H
	DW	05H
	DW	0dH
	DW	08H
	DW	04H
	DW	0bH
	DW	017H
	DW	01H
	DW	0aH
	DW	06H
	DW	02H
	DW	01H
	DW	03H
	DW	015H
	DW	02H
	DW	02H
	DW	04H
	DW	018H
	DW	01fH
	DW	04H
	DW	0aH
	DW	0aH
	DW	02H
	DW	05H
	DW	0c0H
	DW	0fH
	DW	04H
	DW	010H
	DW	07H
	DW	09H
	DW	033H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	09H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	04H
	DW	04H
	DW	012H
	DW	0cH
	DW	05cH
	DW	02H
	DW	0aH
	DW	04H
	DW	03H
	DW	0eH
	DW	05H
	DW	019H
	DW	010H
	DW	02aH
	DW	04H
	DW	0eH
	DW	04H
	DW	02H
	DW	015H
	DW	05H
	DW	07eH
	DW	01eH
	DW	01fH
	DW	02H
	DW	01H
	DW	05H
	DW	0dH
	DW	03H
	DW	016H
	DW	05H
	DW	06H
	DW	06H
	DW	014H
	DW	0cH
	DW	01H
	DW	0eH
	DW	0cH
	DW	057H
	DW	03H
	DW	013H
	DW	01H
	DW	08H
	DW	02H
	DW	09H
	DW	09H
	DW	03H
	DW	03H
	DW	017H
	DW	02H
	DW	03H
	DW	07H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	0bH
	DW	03H
	DW	01H
	DW	06H
	DW	0aH
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	0bH
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	02H
	DW	05H
	DW	05H
	DW	022H
	DW	04H
	DW	0eH
	DW	012H
	DW	04H
	DW	013H
	DW	07H
	DW	05H
	DW	08H
	DW	02H
	DW	06H
	DW	04fH
	DW	01H
	DW	05H
	DW	02H
	DW	0eH
	DW	08H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	024H
	DW	01cH
	DW	010H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	0cH
	DW	06H
	DW	02aH
	DW	027H
	DW	010H
	DW	017H
	DW	07H
	DW	0fH
	DW	0fH
	DW	03H
	DW	02H
	DW	0cH
	DW	07H
	DW	015H
	DW	040H
	DW	06H
	DW	09H
	DW	01cH
	DW	08H
	DW	0cH
	DW	03H
	DW	03H
	DW	029H
	DW	03bH
	DW	018H
	DW	033H
	DW	037H
	DW	039H
	DW	0126H
	DW	09H
	DW	09H
	DW	02H
	DW	06H
	DW	02H
	DW	0fH
	DW	01H
	DW	02H
	DW	0dH
	DW	026H
	DW	05aH
	DW	09H
	DW	09H
	DW	09H
	DW	03H
	DW	0bH
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	04H
	DW	04H
	DW	01H
	DW	05H
	DW	07H
	DW	01H
	DW	04H
	DW	03H
	DW	014H
	DW	04H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	05H
	DW	011H
	DW	01H
	DW	05H
	DW	02H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	05H
	DW	07H
	DW	03H
	DW	012H
	DW	0bH
	DW	0bH
	DW	020H
	DW	07H
	DW	05H
	DW	04H
	DW	07H
	DW	0bH
	DW	07fH
	DW	08H
	DW	04H
	DW	03H
	DW	03H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	06H
	DW	015H
	DW	0eH
	DW	01H
	DW	010H
	DW	01H
	DW	07H
	DW	01H
	DW	03H
	DW	06H
	DW	09H
	DW	041H
	DW	033H
	DW	04H
	DW	03H
	DW	0dH
	DW	03H
	DW	0aH
	DW	01H
	DW	01H
	DW	0cH
	DW	09H
	DW	015H
	DW	06eH
	DW	03H
	DW	013H
	DW	018H
	DW	01H
	DW	01H
	DW	0aH
	DW	03eH
	DW	04H
	DW	01H
	DW	01dH
	DW	02aH
	DW	04eH
	DW	01cH
	DW	014H
	DW	012H
	DW	052H
	DW	06H
	DW	03H
	DW	0fH
	DW	06H
	DW	054H
	DW	03aH
	DW	0fdH
	DW	0fH
	DW	09bH
	DW	0108H
	DW	0fH
	DW	015H
	DW	09H
	DW	0eH
	DW	07H
	DW	03aH
	DW	028H
	DW	027H
?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesCyrillic'::`2'::ranges
	DW	0ffH
	DW	0400H
	DW	052fH
	DW	02de0H
	DW	02dffH
	DW	0a640H
	DW	0a69fH
	DW	00H
	ORG $+2
?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesThai'::`2'::ranges
	DW	0ffH
	DW	02010H
	DW	0205eH
	DW	0e00H
	DW	0e7fH
	DW	00H
	ORG $+2
?ranges@?1??GetGlyphRangesVietnamese@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesVietnamese'::`2'::ranges
	DW	0ffH
	DW	0102H
	DW	0103H
	DW	0110H
	DW	0111H
	DW	0128H
	DW	0129H
	DW	0168H
	DW	0169H
	DW	01a0H
	DW	01a1H
	DW	01afH
	DW	01b0H
	DW	01ea0H
	DW	01ef9H
	DW	00H
	ORG $+6
?proggy_clean_ttf_compressed_data_base85@@3QBDB DB '7])#######hV0qs''/###'
	DB	'[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`'
	DB	'$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb'';9Crc6tgXmKVeU2cD4Eo3R/2'
	DB	'*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:'
	DB	'U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(l'
	DB	'f(r/7GrRgwV%MS=C#`8ND>Qo#t''X#(v#Y9w0#1D$CIf;W''#pWUPXOuxXuU('
	DB	'H9M(1<q-UE31#^-V''8IRUo7Qf./L>=Ke$$''5F%)]0^#0X@U.a<r:QLtFsLc'
	DB	'L6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uLi@^rMl9t=cWq6##weg>$FB'
	DB	'jVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N''[0#7RL_&#w'
	DB	'+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`Nkfi'
	DB	'mM2J,W-jXS:)r0wK#@Fge$U>`w''N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%'
	DB	'?76%^GMHePW-Z5l''&GiF#$956:rS?dA#fiK:)Yr+`&#0j@''DbG&#^$PG.Ll'
	DB	'+DNa<XCMKEV*N)LN/N*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl''&hF;;$<_'
	DB	'=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp'
	DB	'5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)tm+/Us9pG)XPu`<0s-)WTt(g'
	DB	'CRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW'
	DB	'$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CXow0i(?'
	DB	'$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q'
	DB	'^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQ'
	DB	'k.a>D[.e;mc.x]Ip.PH^''/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ''NQ(3_PL'
	DB	'hE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZ'
	DB	'q]DAbkU*JqkL+nwX@@47`5>w=4h(9.`GCRUxHPeR`5Mjol(dUWxZa(>STrPkr'
	DB	'JiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HO'
	DB	'IZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).''2($5FNP&EQ(,)U]W]+fh18.'
	DB	'vsai00);D3@4ku5P?DP8aJt+;qUM]=+b''8@;mViBKx0DE[-auGl8:PJ&Dj+M'
	DB	'6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$U'
	DB	'V(?#P6YY#''/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]''/4C#v$U`0#V.[0>'
	DB	'xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.'
	DB	'kK/HSB==-''Ie/QTtG?-.*^N-4B/ZM_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]'
	DB	'$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw''.,MRsqVr.L;aN&#/EgJ)PBc[-f'
	DB	'>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`guFt(c%=;Am_Qs'
	DB	'@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8''=l_f-b49''UOqkLu7-##oDY2L('
	DB	'te+Mch&gLYtJ,MEtJfLh''x''M=$CS-ZZ%P]8bZ>#S?YY#%Q&q''3^Fw&?D)U'
	DB	'DNrocM3A76//oL?#h7gl85[qW/NDOk%16ij;+:1a''iNIdb-ou8.P*w,v5#EI'
	DB	'$TWS>Pot-R*H''-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>2'
	DB	'9sp3dt-52U%VM#q7''DHpg+#Z9%H[K<L%a2E-grWVM3@2=-k22tL]4$##6We'''
	DB	'8UJCKE[d_=%wI;''6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&'
	DB	'#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#OQFKNX@QI'''
	DB	'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c''[0#(s1X&xm$Y%B7*K:eDA32'
	DB	'3j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682'
	DB	'-SjMXJK)(h$hxua_K]ul92%''BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDP'
	DB	'mL<LYs8i#XwJOYaKPKc1h:''9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuY'
	DB	'a%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5ho;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB'
	DB	'3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]'
	DB	']u-[=99tts1.qb#q72g1WJO81q+eN''03''eM>&1XxY-caEnOj%2n8)),?ILR'
	DB	'5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew''He]h:sI[2LM$[guka'
	DB	'3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1'
	DB	']MupW^-sj_$%[HK%''F####QRZJ::Y3EGl4''@%FkiAOg#p[##O`gukTfBHag'
	DB	'L<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg'
	DB	'*%K8ln(wcf3/''DW-$.lR?n[nCH-eXOONTJlh:.RYF%3''p6sq:UIMA945&^H'
	DB	'FS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP''vh1/R&O_J9''u'
	DB	'm,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56''hl;.s5CUrxjOM7-##.l+Au'''
	DB	'A&O:-T72L]P`&=;ctp''XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B'
	DB	'*P:Rowwm-`0PKjYDDM''3]d39VZHEl4,.j'']Pk-M.h^&:0FACm$maq-&sgw0'
	DB	't7/6(^xtk%LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P''$M<Jnq79VsJW'
	DB	'/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_'
	DB	'-Sj9,VK3M.*''&0D[Ca]J9gp8,kAW]%(?A%R$f<->Zts''^kn=-^@c4%-pY6q'
	DB	'I%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%'
	DB	'KYo8fRULNd2.>%m]UK:n%r$''sw]J;5pAoO_#2mO3n,''=H5(etHg*`+RLgv>'
	DB	'=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ'':+Q_k+uvOSLiEo(<aD/K<'
	DB	'CCc`''Lx>''?;++O''>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRb'
	DB	'A#Kjm%upV1g:a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'
	DB	'''ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X''e?YLfjM[VO0MbuFp7;>Q'
	DB	'&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL($/V,;(kXZejWO`<[5??ewY(*9=%wD'
	DB	'c;,u<''9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.k'
	DB	'Lg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI''o8)b<nKnw''Ho8'
	DB	'C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE'
	DB	'5^V8O(x<<aG/1N$#FX$0V5Y6x''aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM'
	DB	'(=/M0:JxG''?7WhH%o''a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-'
	DB	'e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?''(<S:68tq*'
	DB	'WoDfZu'';mM?8X[ma8W%*`-=;D.(nc7/;)g:T1=^J$&BRV(-lTmNB6xqB[@0*'
	DB	'o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u'
	DB	'75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3MD?@f&1''BW'
	DB	'-)Ju<L25gl8uhVm1hL$##*8###''A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmW'
	DB	'CMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD''QdWoY-F$BtUwmfe'
	DB	'$YqL''8(PWX(P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w''KD`LP5IbH;rTV'
	DB	'>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO'
	DB	'*5NK,((W-i:$,kp''UDAO(G0Sq7MVjJsbIu)''Z,*[>br5fX^:FPAWr-m2KgL'
	DB	'<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6''8uTG&#1T5'
	DB	'g)uLv:873UpTLgH+#FgpH''_o1780Ph8KmxQJ8#H72L4@768@Tm&Qh4CB/5Ov'
	DB	'mA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&'
	DB	'&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z''<$#4H)6,>e0jT6''N#(q%.'
	DB	'O=?2S]u*(m<-V8J''(1)G][68hW$5''q[GC&5j`TE?m''esFGNRM)j,ffZ?-q'
	DB	'x8;->g4t*:CIP/[Qap7/9''#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFF'
	DB	'cL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5isZ88+dKQ)W6>J%CL<KE>`.d*(B`'
	DB	'-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv''?>-XV1q[''-5k''cAZ69'
	DB	'e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7.m7jil'
	DB	'Q02''0-VWAg<a/''''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2''v:^;-DIBW,B4E'
	DB	'68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW''b)T'
	DB	'q7VT9q^*^$$.:&N@@$&)WHtPm*5_rO0&e%K&#-30j(E4#''Zb.o/(Tpm$>K'''
	DB	'f@[PvFl,hfINTNU6u''0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'''
	DB	'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*hv^BFpQj:K''#SJ,sB-''#]'
	DB	'(j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&Gj'
	DB	'UR=1D8QaS3Up&@*9wP?+lo7b?@%''k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u@-'
	DB	'W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAK'
	DB	'jKjseK</xKT*)B,N9X3]krc12t''pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8c'
	DB	'Y#YZ?=,`Wdxu/ae&#w6)R89tI#6@s''(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,'
	DB	';^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D##'
	DB	'#EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#u1p]ovUKW&Y%q]''>$1@-[xfn'
	DB	'$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%'
	DB	')$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0d=j.LQ'
	DB	'f./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c'
	DB	')QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrL'
	DB	'W-1pG_&2UdB86e%B/:=>)N4xeW.*wft-;$''58-ESqr<b?UI(_%@[P46>#U`'''
	DB	'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc'
	DB	'%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#b0v=Pjer]$gG&JXDf->''StvU7505l'
	DB	'9$AFvgYRI^&<^b68?j#q9QX4SM''RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'
	DB	'''bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''''X.`$#8+1GD:k$YUWs'
	DB	'bn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4'
	DB	')''$Ab(Nof%V''8hL&#<NEdtg(n''=S1A(Q1/I&4([%dM`,Iu''1:_hL>SfD0'
	DB	'7&6D<fp8dHM7/g+tlPN9J*rKaPct&?''uBCem^jn%9_K)<,C5K3s=5g&GmJb*'
	DB	'[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m''vi`3?%'
	DB	'Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*$3WoJSCLweV[aZ''MQIjO<7;X-'
	DB	'X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68L'
	DB	'vEA''q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7:d[/;r'
	DB	'_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup''D'
	DB	'#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr''_wgH)NUIR8a1n#S?Yej''h8^58'
	DB	'UbZd+^FKD*T@;6A7aQC[K8d-(v6GI$x:T<&''Gp5Uf>@M.*J:;$-rv29''M]8'
	DB	'qMv-tLp,''886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu''QvBT.#=)0ukru'
	DB	'V&.)3=(^1`o*Pj4<-<aN((^7(''#Z0wK#5GX@7u][`*S^43933A4rl][`*O4C'
	DB	'gLEl]v$1Q3AeF37dbXk,.)vj#x''d`;qgbQR%FW,2(?LO=s%Sc68%NP''##Ao'
	DB	'tl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f''f/&_mt&F)XdF<9t4)Qa.*kTLw'
	DB	'Q''(TTB9.xH''>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72Ln'
	DB	'Yl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2''I'
	DB	'M%L3I)X((e/dl2&8''<M:^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En''CR.q7'
	DB	'E)p''/kle2HM,u;^%OKC-N+Ll%F9CF<Nf''^#t2L,;27W:0O@6##U6W7:$rJf'
	DB	'LWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>_>@kXQtMacfD.m-VAb8;'
	DB	'IReM3$wf0''''hra*so568''Ip&vRs849''MRYSp%:t:h5qSgwpEr$B>Q,;s('
	DB	'C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP''##p#C0c%-'
	DB	'Gb%hd+<-j''Ai*x&&HMkT]C''OSl##5RG[JXaHN;d''uA#x._U;.`PU@(Z3dt'
	DB	'4r152@:v,''R.Sj''w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%'
	DB	'>.G690a:$##<,);?;72#?x9+d;^V''9;jY@;)br#q^YQpx:X#Te$Z^''=-=bG'
	DB	'hLf:D6&bNwZ9-ZD#n^9HhLMr5G;'']d&6''wYmTFmL<LD)F^%[tC''8;+9E#C'
	DB	'$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s''B;K-M6$EB%is00:+A4[7xks.Lr'
	DB	'Nk0&E)wILYF@2L''0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT''<-,v`3;_)I9M'
	DB	'^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k'
	DB	'11IM1c^j%9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8''je''D7k`e;)'
	DB	'2pYwPA''_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^(''7fB&Hq-:sf,sNj'
	DB	'8xq^>$U4O]GKx''m9)b@p7YsvK3w^YR-CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp'
	DB	'^iI9O8KnTj,]H?D*r7''M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnr'
	DB	'U(4&8/P+:hLSKj$#U%]49t''I:rgMi''FL@a:0Y-uA[39'',(vbma*hU%<-SR'
	DB	'F`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>T'
	DB	'i1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*V'
	DB	'j>SsD<U4JHY8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK''-x?''(:siIfL<$p'
	DB	'FM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa'
	DB	'8wD8=^GlPa8TKI1CjhsCTSLJM''/Wl>-S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n'
	DB	'<bhPmUkMw>%t<)''mEVE''''n`WnJra$^TKvX5B>;_aSEK'',(hwa0:i4G?.B'
	DB	'ci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs''6,''85`0?t/'''
	DB	'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%O'
	DB	'tJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<RO'
	DB	'u7cL5l;-[A]%/+fsd;l#SafT/f*W]0=O''$(Tb<[)*@e775R-:Yob%g*>l*:x'
	DB	'P?Yb.5)%w_I?7uk5JC+FS(m#i''k.''a0i)9<7b''fs''59hq$*5Uhv##pi^8'
	DB	'+hIEBF`nvo`;''l0.^S1<-wUK2/Coh58KKhLjM=SO*rfO`+qC`W-On.=AJ56>'
	DB	'>i2@2LH6A:&5q`?9I3@@''04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c'
	DB	'<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V?6*C('
	DB	')dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+Aur'
	DB	'K<m86QIth*#v;-OBqi+L7wDE-Ir8K[''m+DDSLwK&/.?-V%U_%3:qKNu$_b*B'
	DB	'-kp7NaD''QdWQPKYq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vm'
	DB	'J80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/''+'
	DB	'1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa>gXm8YB`1d@K#n]76-a$U,mF<fX'
	DB	']idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&'
	DB	'c$ooQUj]Exd*3ZM@-WGW2%s'',B-_M%>%Ul:#/''xoFM9QX-$.QN''>[%$Z$u'
	DB	'F6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o''$?X3B</R90;'
	DB	'eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*''3E>=-<'
	DB	')Gt*Iw)''QG:`@IwOf7&]1i''S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/'
	DB	'6Aj7:''1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0''1<Vc52=u`3^o-n1'
	DB	'''g4v58Hj&6_t7$##?M)c<$bgQ_''SY((-xkA#Y(,p''H9rIVY-b,''%bCPF7'
	DB	'.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs'
	DB	',eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$Mlv'
	DB	'AF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo''RS1R84=@paTKt)>=%&1[)*v'
	DB	'p''u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u''m0dr9l,<*wMK*Oe=g8lV_KEBF'
	DB	'kO''oU]^=[-792#ok,)i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K'
	DB	'1<-rGdO''$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw''DJN:)Ss;wGn9A32ijw%FL'
	DB	'+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo1*c-(aY168o<`JsSbk-,1N'
	DB	';$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+S'
	DB	'TRxX''q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W''$PiD'
	DB	'DG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7'
	DB	'fSkgl6-++D:''A,uq7SvlB$pcpH''q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF'
	DB	'6##$l84N1w?AO>''IAOURQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi'
	DB	'68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne'
	DB	'_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#;u.T%fAr%4tJ8&><1=GHZ_+m'
	DB	'9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx='
	DB	'T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>w$)F./'
	DB	'^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;'
	DB	'P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*'
	DB	'A#]-=A#a9OA#d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%'
	DB	'#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k''MS.o?.5/sWel/wpEM0%3'''
	DB	'/1)K^f1-d>G21&v(35>V`39V7A4=onx4A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,'
	DB	';WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#'
	DB	'2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#''9$C#+E6C#/QHC#3^ZC#'
	DB	'7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L'
	DB	'-d3#rWM4#Hga1#,<w0#T.j<#O#''2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`'
	DB	'+78#4uI-#m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%'
	DB	'X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$'
	DB	'0#n`-0#sf60#(F24#wrH0#%/e0#TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G'
	DB	'3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiC'
	DB	'f&0g2''tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP'
	DB	'GT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5K'
	DB	'TB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI''O'
	DB	'?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?'
	DB	';xpO?;xp;7q-#lLYI:xvD=#', 00H		; proggy_clean_ttf_compressed_data_base85
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0ImVec2@@QAE@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QAE@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QAE@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?StyleColorsDark@ImGui@@YAXPAUImGuiStyle@@@Z	; ImGui::StyleColorsDark
PUBLIC	?StyleColorsClassic@ImGui@@YAXPAUImGuiStyle@@@Z	; ImGui::StyleColorsClassic
PUBLIC	?StyleColorsLight@ImGui@@YAXPAUImGuiStyle@@@Z	; ImGui::StyleColorsLight
PUBLIC	??2@YAPAXIUImNewDummy@@PAX@Z			; operator new
PUBLIC	??3@YAXPAXUImNewDummy@@0@Z			; operator delete
PUBLIC	??0?$ImVector@G@@QAE@XZ				; ImVector<unsigned short>::ImVector<unsigned short>
PUBLIC	??4?$ImVector@G@@QAEAAU0@ABU0@@Z		; ImVector<unsigned short>::operator=
PUBLIC	??1?$ImVector@G@@QAE@XZ				; ImVector<unsigned short>::~ImVector<unsigned short>
PUBLIC	?empty@?$ImVector@G@@QBE_NXZ			; ImVector<unsigned short>::empty
PUBLIC	??A?$ImVector@G@@QAEAAGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?clear@?$ImVector@G@@QAEXXZ			; ImVector<unsigned short>::clear
PUBLIC	?_grow_capacity@?$ImVector@G@@QBEHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?resize@?$ImVector@G@@QAEXHABG@Z		; ImVector<unsigned short>::resize
PUBLIC	?shrink@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::shrink
PUBLIC	?reserve@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	?push_back@?$ImVector@G@@QAEXABG@Z		; ImVector<unsigned short>::push_back
PUBLIC	??0ImDrawCmd@@QAE@XZ				; ImDrawCmd::ImDrawCmd
PUBLIC	??0?$ImVector@UImDrawCmd@@@@QAE@XZ		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
PUBLIC	??4?$ImVector@UImDrawCmd@@@@QAEAAU0@ABU0@@Z	; ImVector<ImDrawCmd>::operator=
PUBLIC	??1?$ImVector@UImDrawCmd@@@@QAE@XZ		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ		; ImVector<ImDrawCmd>::clear
PUBLIC	?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
PUBLIC	?_grow_capacity@?$ImVector@UImDrawCmd@@@@QBEHH@Z ; ImVector<ImDrawCmd>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z	; ImVector<ImDrawCmd>::resize
PUBLIC	?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z	; ImVector<ImDrawCmd>::reserve
PUBLIC	?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back
PUBLIC	?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ	; ImVector<ImDrawCmd>::pop_back
PUBLIC	?erase@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@PBU2@@Z ; ImVector<ImDrawCmd>::erase
PUBLIC	??0ImDrawChannel@@QAE@XZ			; ImDrawChannel::ImDrawChannel
PUBLIC	??0?$ImVector@UImDrawChannel@@@@QAE@XZ		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
PUBLIC	??1?$ImVector@UImDrawChannel@@@@QAE@XZ		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
PUBLIC	??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ	; ImVector<ImDrawChannel>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImDrawChannel@@@@QBEHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z	; ImVector<ImDrawChannel>::resize
PUBLIC	?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z	; ImVector<ImDrawChannel>::reserve
PUBLIC	??0ImDrawListSplitter@@QAE@XZ			; ImDrawListSplitter::ImDrawListSplitter
PUBLIC	??1ImDrawListSplitter@@QAE@XZ			; ImDrawListSplitter::~ImDrawListSplitter
PUBLIC	?Clear@ImDrawListSplitter@@QAEXXZ		; ImDrawListSplitter::Clear
PUBLIC	?ClearFreeMemory@ImDrawListSplitter@@QAEXXZ	; ImDrawListSplitter::ClearFreeMemory
PUBLIC	?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z ; ImDrawListSplitter::Split
PUBLIC	?Merge@ImDrawListSplitter@@QAEXPAUImDrawList@@@Z ; ImDrawListSplitter::Merge
PUBLIC	?SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
PUBLIC	??0?$ImVector@UImDrawVert@@@@QAE@XZ		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
PUBLIC	??4?$ImVector@UImDrawVert@@@@QAEAAU0@ABU0@@Z	; ImVector<ImDrawVert>::operator=
PUBLIC	??1?$ImVector@UImDrawVert@@@@QAE@XZ		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
PUBLIC	??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawVert@@@@QAEXXZ		; ImVector<ImDrawVert>::clear
PUBLIC	?swap@?$ImVector@UImDrawVert@@@@QAEXAAU1@@Z	; ImVector<ImDrawVert>::swap
PUBLIC	?_grow_capacity@?$ImVector@UImDrawVert@@@@QBEHH@Z ; ImVector<ImDrawVert>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z	; ImVector<ImDrawVert>::resize
PUBLIC	?shrink@?$ImVector@UImDrawVert@@@@QAEXH@Z	; ImVector<ImDrawVert>::shrink
PUBLIC	?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z	; ImVector<ImDrawVert>::reserve
PUBLIC	??0?$ImVector@UImVec4@@@@QAE@XZ			; ImVector<ImVec4>::ImVector<ImVec4>
PUBLIC	??1?$ImVector@UImVec4@@@@QAE@XZ			; ImVector<ImVec4>::~ImVector<ImVec4>
PUBLIC	?clear@?$ImVector@UImVec4@@@@QAEXXZ		; ImVector<ImVec4>::clear
PUBLIC	?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ	; ImVector<ImVec4>::back
PUBLIC	?_grow_capacity@?$ImVector@UImVec4@@@@QBEHH@Z	; ImVector<ImVec4>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImVec4@@@@QAEXH@Z		; ImVector<ImVec4>::resize
PUBLIC	?reserve@?$ImVector@UImVec4@@@@QAEXH@Z		; ImVector<ImVec4>::reserve
PUBLIC	?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z ; ImVector<ImVec4>::push_back
PUBLIC	?pop_back@?$ImVector@UImVec4@@@@QAEXXZ		; ImVector<ImVec4>::pop_back
PUBLIC	??0?$ImVector@PAX@@QAE@XZ			; ImVector<void *>::ImVector<void *>
PUBLIC	??1?$ImVector@PAX@@QAE@XZ			; ImVector<void *>::~ImVector<void *>
PUBLIC	?empty@?$ImVector@PAX@@QBE_NXZ			; ImVector<void *>::empty
PUBLIC	?clear@?$ImVector@PAX@@QAEXXZ			; ImVector<void *>::clear
PUBLIC	?back@?$ImVector@PAX@@QAEAAPAXXZ		; ImVector<void *>::back
PUBLIC	?_grow_capacity@?$ImVector@PAX@@QBEHH@Z		; ImVector<void *>::_grow_capacity
PUBLIC	?resize@?$ImVector@PAX@@QAEXH@Z			; ImVector<void *>::resize
PUBLIC	?reserve@?$ImVector@PAX@@QAEXH@Z		; ImVector<void *>::reserve
PUBLIC	?push_back@?$ImVector@PAX@@QAEXABQAX@Z		; ImVector<void *>::push_back
PUBLIC	?pop_back@?$ImVector@PAX@@QAEXXZ		; ImVector<void *>::pop_back
PUBLIC	??0?$ImVector@UImVec2@@@@QAE@XZ			; ImVector<ImVec2>::ImVector<ImVec2>
PUBLIC	??1?$ImVector@UImVec2@@@@QAE@XZ			; ImVector<ImVec2>::~ImVector<ImVec2>
PUBLIC	?clear@?$ImVector@UImVec2@@@@QAEXXZ		; ImVector<ImVec2>::clear
PUBLIC	?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ	; ImVector<ImVec2>::back
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::resize
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z	; ImDrawList::ImDrawList
PUBLIC	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z	; ImDrawList::PushClipRect
PUBLIC	?PushClipRectFullScreen@ImDrawList@@QAEXXZ	; ImDrawList::PushClipRectFullScreen
PUBLIC	?PopClipRect@ImDrawList@@QAEXXZ			; ImDrawList::PopClipRect
PUBLIC	?PushTextureID@ImDrawList@@QAEXPAX@Z		; ImDrawList::PushTextureID
PUBLIC	?PopTextureID@ImDrawList@@QAEXXZ		; ImDrawList::PopTextureID
PUBLIC	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z	; ImDrawList::AddLine
PUBLIC	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z	; ImDrawList::AddRect
PUBLIC	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
PUBLIC	?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
PUBLIC	?AddQuad@ImDrawList@@QAEXABUImVec2@@000IM@Z	; ImDrawList::AddQuad
PUBLIC	?AddQuadFilled@ImDrawList@@QAEXABUImVec2@@000I@Z ; ImDrawList::AddQuadFilled
PUBLIC	?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z	; ImDrawList::AddTriangle
PUBLIC	?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
PUBLIC	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z	; ImDrawList::AddCircle
PUBLIC	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
PUBLIC	?AddNgon@ImDrawList@@QAEXABUImVec2@@MIHM@Z	; ImDrawList::AddNgon
PUBLIC	?AddNgonFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z	; ImDrawList::AddNgonFilled
PUBLIC	?AddText@ImDrawList@@QAEXABUImVec2@@IPBD1@Z	; ImDrawList::AddText
PUBLIC	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText
PUBLIC	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM@Z	; ImDrawList::AddPolyline
PUBLIC	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
PUBLIC	?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z ; ImDrawList::AddBezierCurve
PUBLIC	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z	; ImDrawList::AddImage
PUBLIC	?AddImageQuad@ImDrawList@@QAEXPAXABUImVec2@@1111111I@Z ; ImDrawList::AddImageQuad
PUBLIC	?AddImageRounded@ImDrawList@@QAEXPAXABUImVec2@@111IMH@Z ; ImDrawList::AddImageRounded
PUBLIC	?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	?PathFillConvex@ImDrawList@@QAEXI@Z		; ImDrawList::PathFillConvex
PUBLIC	?PathStroke@ImDrawList@@QAEXI_NM@Z		; ImDrawList::PathStroke
PUBLIC	?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z	; ImDrawList::PathArcTo
PUBLIC	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z	; ImDrawList::PathArcToFast
PUBLIC	?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z ; ImDrawList::PathBezierCurveTo
PUBLIC	?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z	; ImDrawList::PathRect
PUBLIC	?AddCallback@ImDrawList@@QAEXP6AXPBU1@PBUImDrawCmd@@@ZPAX@Z ; ImDrawList::AddCallback
PUBLIC	?AddDrawCmd@ImDrawList@@QAEXXZ			; ImDrawList::AddDrawCmd
PUBLIC	?CloneOutput@ImDrawList@@QBEPAU1@XZ		; ImDrawList::CloneOutput
PUBLIC	?Clear@ImDrawList@@QAEXXZ			; ImDrawList::Clear
PUBLIC	?ClearFreeMemory@ImDrawList@@QAEXXZ		; ImDrawList::ClearFreeMemory
PUBLIC	?PrimReserve@ImDrawList@@QAEXHH@Z		; ImDrawList::PrimReserve
PUBLIC	?PrimUnreserve@ImDrawList@@QAEXHH@Z		; ImDrawList::PrimUnreserve
PUBLIC	?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z	; ImDrawList::PrimRect
PUBLIC	?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z	; ImDrawList::PrimRectUV
PUBLIC	?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z ; ImDrawList::PrimQuadUV
PUBLIC	?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z	; ImDrawList::PrimWriteVtx
PUBLIC	?PrimWriteIdx@ImDrawList@@QAEXG@Z		; ImDrawList::PrimWriteIdx
PUBLIC	?UpdateClipRect@ImDrawList@@QAEXXZ		; ImDrawList::UpdateClipRect
PUBLIC	?UpdateTextureID@ImDrawList@@QAEXXZ		; ImDrawList::UpdateTextureID
PUBLIC	?DeIndexAllBuffers@ImDrawData@@QAEXXZ		; ImDrawData::DeIndexAllBuffers
PUBLIC	?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z	; ImDrawData::ScaleClipRects
PUBLIC	??0ImFontConfig@@QAE@XZ				; ImFontConfig::ImFontConfig
PUBLIC	??A?$ImVector@I@@QAEAAIH@Z			; ImVector<unsigned int>::operator[]
PUBLIC	??A?$ImVector@I@@QBEABIH@Z			; ImVector<unsigned int>::operator[]
PUBLIC	?GetBit@ImFontGlyphRangesBuilder@@QBE_NH@Z	; ImFontGlyphRangesBuilder::GetBit
PUBLIC	?SetBit@ImFontGlyphRangesBuilder@@QAEXH@Z	; ImFontGlyphRangesBuilder::SetBit
PUBLIC	?AddChar@ImFontGlyphRangesBuilder@@QAEXG@Z	; ImFontGlyphRangesBuilder::AddChar
PUBLIC	?AddText@ImFontGlyphRangesBuilder@@QAEXPBD0@Z	; ImFontGlyphRangesBuilder::AddText
PUBLIC	?AddRanges@ImFontGlyphRangesBuilder@@QAEXPBG@Z	; ImFontGlyphRangesBuilder::AddRanges
PUBLIC	?BuildRanges@ImFontGlyphRangesBuilder@@QAEXPAU?$ImVector@G@@@Z ; ImFontGlyphRangesBuilder::BuildRanges
PUBLIC	??0ImFontAtlasCustomRect@@QAE@XZ		; ImFontAtlasCustomRect::ImFontAtlasCustomRect
PUBLIC	?IsPacked@ImFontAtlasCustomRect@@QBE_NXZ	; ImFontAtlasCustomRect::IsPacked
PUBLIC	??0ImFontAtlas@@QAE@XZ				; ImFontAtlas::ImFontAtlas
PUBLIC	??1ImFontAtlas@@QAE@XZ				; ImFontAtlas::~ImFontAtlas
PUBLIC	?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFont
PUBLIC	?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
PUBLIC	?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromFileTTF
PUBLIC	?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
PUBLIC	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
PUBLIC	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
PUBLIC	?ClearInputData@ImFontAtlas@@QAEXXZ		; ImFontAtlas::ClearInputData
PUBLIC	?ClearTexData@ImFontAtlas@@QAEXXZ		; ImFontAtlas::ClearTexData
PUBLIC	?ClearFonts@ImFontAtlas@@QAEXXZ			; ImFontAtlas::ClearFonts
PUBLIC	?Clear@ImFontAtlas@@QAEXXZ			; ImFontAtlas::Clear
PUBLIC	?Build@ImFontAtlas@@QAE_NXZ			; ImFontAtlas::Build
PUBLIC	?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8
PUBLIC	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32
PUBLIC	?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesDefault
PUBLIC	?GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesKorean
PUBLIC	?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesJapanese
PUBLIC	?GetGlyphRangesChineseFull@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesChineseFull
PUBLIC	?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon
PUBLIC	?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesCyrillic
PUBLIC	?GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesThai
PUBLIC	?GetGlyphRangesVietnamese@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesVietnamese
PUBLIC	?AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z	; ImFontAtlas::AddCustomRectRegular
PUBLIC	?AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z ; ImFontAtlas::AddCustomRectFontGlyph
PUBLIC	?CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z ; ImFontAtlas::CalcCustomRectUV
PUBLIC	?GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU2@1@Z ; ImFontAtlas::GetMouseCursorTexData
PUBLIC	??0?$ImVector@PAUImFont@@@@QAE@XZ		; ImVector<ImFont *>::ImVector<ImFont *>
PUBLIC	??1?$ImVector@PAUImFont@@@@QAE@XZ		; ImVector<ImFont *>::~ImVector<ImFont *>
PUBLIC	?empty@?$ImVector@PAUImFont@@@@QBE_NXZ		; ImVector<ImFont *>::empty
PUBLIC	?size@?$ImVector@PAUImFont@@@@QBEHXZ		; ImVector<ImFont *>::size
PUBLIC	??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z	; ImVector<ImFont *>::operator[]
PUBLIC	?clear@?$ImVector@PAUImFont@@@@QAEXXZ		; ImVector<ImFont *>::clear
PUBLIC	?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ ; ImVector<ImFont *>::back
PUBLIC	?_grow_capacity@?$ImVector@PAUImFont@@@@QBEHH@Z	; ImVector<ImFont *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z	; ImVector<ImFont *>::reserve
PUBLIC	?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ; ImVector<ImFont *>::push_back
PUBLIC	??0?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>
PUBLIC	??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
PUBLIC	??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
PUBLIC	?clear@?$ImVector@UImFontAtlasCustomRect@@@@QAEXXZ ; ImVector<ImFontAtlasCustomRect>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QBEHH@Z ; ImVector<ImFontAtlasCustomRect>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QAEXH@Z ; ImVector<ImFontAtlasCustomRect>::reserve
PUBLIC	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QAEXABUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back
PUBLIC	??0?$ImVector@UImFontConfig@@@@QAE@XZ		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
PUBLIC	??1?$ImVector@UImFontConfig@@@@QAE@XZ		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
PUBLIC	?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ	; ImVector<ImFontConfig>::empty
PUBLIC	??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
PUBLIC	?clear@?$ImVector@UImFontConfig@@@@QAEXXZ	; ImVector<ImFontConfig>::clear
PUBLIC	?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ ; ImVector<ImFontConfig>::back
PUBLIC	?_grow_capacity@?$ImVector@UImFontConfig@@@@QBEHH@Z ; ImVector<ImFontConfig>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z	; ImVector<ImFontConfig>::reserve
PUBLIC	?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back
PUBLIC	??0?$ImVector@M@@QAE@XZ				; ImVector<float>::ImVector<float>
PUBLIC	??1?$ImVector@M@@QAE@XZ				; ImVector<float>::~ImVector<float>
PUBLIC	??A?$ImVector@M@@QAEAAMH@Z			; ImVector<float>::operator[]
PUBLIC	?clear@?$ImVector@M@@QAEXXZ			; ImVector<float>::clear
PUBLIC	?_grow_capacity@?$ImVector@M@@QBEHH@Z		; ImVector<float>::_grow_capacity
PUBLIC	?resize@?$ImVector@M@@QAEXHABM@Z		; ImVector<float>::resize
PUBLIC	?reserve@?$ImVector@M@@QAEXH@Z			; ImVector<float>::reserve
PUBLIC	??0?$ImVector@UImFontGlyph@@@@QAE@XZ		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
PUBLIC	??1?$ImVector@UImFontGlyph@@@@QAE@XZ		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
PUBLIC	??A?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
PUBLIC	?clear@?$ImVector@UImFontGlyph@@@@QAEXXZ	; ImVector<ImFontGlyph>::clear
PUBLIC	?back@?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
PUBLIC	?_grow_capacity@?$ImVector@UImFontGlyph@@@@QBEHH@Z ; ImVector<ImFontGlyph>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImFontGlyph@@@@QAEXH@Z	; ImVector<ImFontGlyph>::resize
PUBLIC	?reserve@?$ImVector@UImFontGlyph@@@@QAEXH@Z	; ImVector<ImFontGlyph>::reserve
PUBLIC	??0ImFont@@QAE@XZ				; ImFont::ImFont
PUBLIC	??1ImFont@@QAE@XZ				; ImFont::~ImFont
PUBLIC	?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z	; ImFont::FindGlyph
PUBLIC	?FindGlyphNoFallback@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyphNoFallback
PUBLIC	?IsLoaded@ImFont@@QBE_NXZ			; ImFont::IsLoaded
PUBLIC	?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z ; ImFont::CalcTextSizeA
PUBLIC	?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z	; ImFont::CalcWordWrapPositionA
PUBLIC	?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z ; ImFont::RenderChar
PUBLIC	?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z ; ImFont::RenderText
PUBLIC	?BuildLookupTable@ImFont@@QAEXXZ		; ImFont::BuildLookupTable
PUBLIC	?ClearOutputData@ImFont@@QAEXXZ			; ImFont::ClearOutputData
PUBLIC	?GrowIndex@ImFont@@QAEXH@Z			; ImFont::GrowIndex
PUBLIC	?AddGlyph@ImFont@@QAEXGMMMMMMMMM@Z		; ImFont::AddGlyph
PUBLIC	?AddRemapChar@ImFont@@QAEXGG_N@Z		; ImFont::AddRemapChar
PUBLIC	?SetFallbackChar@ImFont@@QAEXG@Z		; ImFont::SetFallbackChar
PUBLIC	??_GImFont@@QAEPAXI@Z				; ImFont::`scalar deleting destructor'
PUBLIC	_acosf
PUBLIC	_ceilf
PUBLIC	_cosf
PUBLIC	_fabsf
PUBLIC	_floorf
PUBLIC	_sinf
PUBLIC	_sqrtf
PUBLIC	??1?$ImVector@H@@QAE@XZ				; ImVector<int>::~ImVector<int>
PUBLIC	?empty@?$ImVector@H@@QBE_NXZ			; ImVector<int>::empty
PUBLIC	??A?$ImVector@H@@QAEAAHH@Z			; ImVector<int>::operator[]
PUBLIC	??A?$ImVector@H@@QBEABHH@Z			; ImVector<int>::operator[]
PUBLIC	?clear@?$ImVector@H@@QAEXXZ			; ImVector<int>::clear
PUBLIC	?begin@?$ImVector@H@@QBEPBHXZ			; ImVector<int>::begin
PUBLIC	?end@?$ImVector@H@@QBEPBHXZ			; ImVector<int>::end
PUBLIC	?_grow_capacity@?$ImVector@H@@QBEHH@Z		; ImVector<int>::_grow_capacity
PUBLIC	?resize@?$ImVector@H@@QAEXH@Z			; ImVector<int>::resize
PUBLIC	?reserve@?$ImVector@H@@QAEXH@Z			; ImVector<int>::reserve
PUBLIC	?push_back@?$ImVector@H@@QAEXABH@Z		; ImVector<int>::push_back
PUBLIC	?Resize@ImBoolVector@@QAEXH@Z			; ImBoolVector::Resize
PUBLIC	?Clear@ImBoolVector@@QAEXXZ			; ImBoolVector::Clear
PUBLIC	?GetBit@ImBoolVector@@QBE_NH@Z			; ImBoolVector::GetBit
PUBLIC	?SetBit@ImBoolVector@@QAEXH_N@Z			; ImBoolVector::SetBit
PUBLIC	??1ImBoolVector@@QAE@XZ				; ImBoolVector::~ImBoolVector
PUBLIC	??0ImDrawListSharedData@@QAE@XZ			; ImDrawListSharedData::ImDrawListSharedData
PUBLIC	?RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z ; ImGui::RenderMouseCursor
PUBLIC	?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
PUBLIC	?RenderRectFilledRangeH@ImGui@@YAXPAUImDrawList@@ABUImRect@@IMMM@Z ; ImGui::RenderRectFilledRangeH
PUBLIC	?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPAUImDrawList@@HHUImVec2@@1II@Z ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
PUBLIC	?ShadeVertsLinearUV@ImGui@@YAXPAUImDrawList@@HHABUImVec2@@111_N@Z ; ImGui::ShadeVertsLinearUV
PUBLIC	?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
PUBLIC	?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPAUImFontAtlas@@@Z ; ImFontAtlasBuildRegisterDefaultCustomRects
PUBLIC	?ImFontAtlasBuildSetupFont@@YAXPAUImFontAtlas@@PAUImFont@@PAUImFontConfig@@MM@Z ; ImFontAtlasBuildSetupFont
PUBLIC	?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z ; ImFontAtlasBuildPackCustomRects
PUBLIC	?ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z	; ImFontAtlasBuildFinish
PUBLIC	?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQAEM@Z ; ImFontAtlasBuildMultiplyCalcLookupTable
PUBLIC	?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQBEPAEHHHHH@Z ; ImFontAtlasBuildMultiplyRectAlpha8
PUBLIC	??$__builtin_array_init_helper@UImVec2@@@@YAXPAUImVec2@@I@Z ; __builtin_array_init_helper<ImVec2>
PUBLIC	??$IM_DELETE@UImFont@@@@YAXPAUImFont@@@Z	; IM_DELETE<ImFont>
PUBLIC	??1ImFontBuildSrcData@@QAE@XZ			; ImFontBuildSrcData::~ImFontBuildSrcData
PUBLIC	??_GImFontBuildSrcData@@QAEPAXI@Z		; ImFontBuildSrcData::`scalar deleting destructor'
PUBLIC	??0?$ImVector@UImFontBuildSrcData@@@@QAE@XZ	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
PUBLIC	??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QBEHXZ ; ImVector<ImFontBuildSrcData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QBEHH@Z ; ImVector<ImFontBuildSrcData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z ; ImVector<ImFontBuildSrcData>::resize
PUBLIC	?reserve@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z ; ImVector<ImFontBuildSrcData>::reserve
PUBLIC	??0?$ImVector@UImFontBuildDstData@@@@QAE@XZ	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
PUBLIC	??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QBEHXZ ; ImVector<ImFontBuildDstData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildDstData@@@@QAEAAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
PUBLIC	?clear@?$ImVector@UImFontBuildDstData@@@@QAEXXZ	; ImVector<ImFontBuildDstData>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QBEHH@Z ; ImVector<ImFontBuildDstData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z ; ImVector<ImFontBuildDstData>::resize
PUBLIC	?reserve@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z ; ImVector<ImFontBuildDstData>::reserve
PUBLIC	??0?$ImVector@Ustbrp_rect@@@@QAE@XZ		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
PUBLIC	??1?$ImVector@Ustbrp_rect@@@@QAE@XZ		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
PUBLIC	?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QBEHXZ	; ImVector<stbrp_rect>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
PUBLIC	?clear@?$ImVector@Ustbrp_rect@@@@QAEXXZ		; ImVector<stbrp_rect>::clear
PUBLIC	?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QBEHH@Z ; ImVector<stbrp_rect>::_grow_capacity
PUBLIC	?resize@?$ImVector@Ustbrp_rect@@@@QAEXH@Z	; ImVector<stbrp_rect>::resize
PUBLIC	?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z	; ImVector<stbrp_rect>::reserve
PUBLIC	??0?$ImVector@Ustbtt_packedchar@@@@QAE@XZ	; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
PUBLIC	??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ	; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
PUBLIC	?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QBEHXZ ; ImVector<stbtt_packedchar>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbtt_packedchar@@@@QAEAAUstbtt_packedchar@@H@Z ; ImVector<stbtt_packedchar>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QBEHH@Z ; ImVector<stbtt_packedchar>::_grow_capacity
PUBLIC	?resize@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z	; ImVector<stbtt_packedchar>::resize
PUBLIC	?reserve@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z ; ImVector<stbtt_packedchar>::reserve
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??stbrp_init_target@@9@4JA	; `stbrp_init_target'::`1'::__LINE__Var
PUBLIC	??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@ ; `string'
PUBLIC	?__LINE__Var@?0??stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z@4JA ; `stbrp__skyline_find_min_y'::`1'::__LINE__Var
PUBLIC	??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ ; `string'
PUBLIC	??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ ; `string'
PUBLIC	??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA ; `stbrp__skyline_find_best_pos'::`1'::__LINE__Var
PUBLIC	??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@ ; `string'
PUBLIC	??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ ; `string'
PUBLIC	??_C@_1BI@JNFMLHFF@?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAe?$AAs?$AAt?$AA_?$AAy@ ; `string'
PUBLIC	?__LINE__Var@?0??stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA ; `stbrp__skyline_pack_rectangle'::`1'::__LINE__Var
PUBLIC	??_C@_1CM@NCKIDPDA@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn@ ; `string'
PUBLIC	??_C@_1BO@NJIDGHPD@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1DM@MABMKAHD@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z@4JA ; `stbtt__buf_seek'::`1'::__LINE__Var
PUBLIC	??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z@4JA ; `stbtt__buf_get'::`1'::__LINE__Var
PUBLIC	??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z@4JA ; `stbtt__new_buf'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU2@@Z@4JA ; `stbtt__cff_get_index'::`1'::__LINE__Var
PUBLIC	??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__cff_int@@YAIPAUstbtt__buf@@@Z@4JA ; `stbtt__cff_int'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z@4JA ; `stbtt__cff_skip_operand'::`1'::__LINE__Var
PUBLIC	??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__cff_index_get@@YA?AUstbtt__buf@@U2@H@Z@4JA ; `stbtt__cff_index_get'::`1'::__LINE__Var
PUBLIC	??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_04LBBEMOBJ@typ1@				; `string'
PUBLIC	??_C@_04LLEFIKCJ@OTTO@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_04KIOEMAHO@ttcf@				; `string'
PUBLIC	??_C@_04EICJPCEA@cmap@				; `string'
PUBLIC	??_C@_04DACNFKGE@loca@				; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_04LLIHEPK@glyf@				; `string'
PUBLIC	??_C@_04FMPHLIKP@hhea@				; `string'
PUBLIC	??_C@_04ONMNCIMC@hmtx@				; `string'
PUBLIC	??_C@_04HHMMLDJI@kern@				; `string'
PUBLIC	??_C@_04PCFDEHHD@GPOS@				; `string'
PUBLIC	??_C@_04HJGCPIEK@CFF?5@				; `string'
PUBLIC	??_C@_04KODIGLGG@maxp@				; `string'
PUBLIC	?__LINE__Var@?0??stbtt_FindGlyphIndex@@9@4JA	; `stbtt_FindGlyphIndex'::`1'::__LINE__Var
PUBLIC	??_C@_1HA@EBGBJFDE@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z@4JA ; `stbtt__GetGlyfOffset'::`1'::__LINE__Var
PUBLIC	??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA ; `stbtt__GetGlyphShapeTT'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA ; `stbtt__GetGlyphShapeT2'::`1'::__LINE__Var
PUBLIC	??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z@4JA ; `stbtt__new_active'::`1'::__LINE__Var
PUBLIC	??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA ; `stbtt__handle_clipped_edge'::`1'::__LINE__Var
PUBLIC	??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@ ; `string'
PUBLIC	??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@ ; `string'
PUBLIC	??_C@_1BE@DHAKMBPL@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@ ; `string'
PUBLIC	??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@ ; `string'
PUBLIC	??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@ ; `string'
PUBLIC	??_C@_1BE@NGGEAFFG@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@ ; `string'
PUBLIC	??_C@_1CK@NILBPPPH@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@ ; `string'
PUBLIC	??_C@_1FK@JPMIPNJF@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z@4JA ; `stbtt__fill_active_edges_new'::`1'::__LINE__Var
PUBLIC	??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@ ; `string'
PUBLIC	??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@ ; `string'
PUBLIC	??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@ ; `string'
PUBLIC	??_C@_1CM@OJNMKDLP@?$AAI?$AAm?$AAF?$AAa?$AAb?$AAs?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z@4JA ; `stbtt__rasterize_sorted_edges'::`1'::__LINE__Var
PUBLIC	??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__h_prefilter@@YAXPAEHHHI@Z@4JA ; `stbtt__h_prefilter'::`1'::__LINE__Var
PUBLIC	??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??stbtt__v_prefilter@@YAXPAEHHHI@Z@4JA ; `stbtt__v_prefilter'::`1'::__LINE__Var
PUBLIC	??_C@_1DO@LAPBLJ@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$CK?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??AddDrawCmd@ImDrawList@@QAEXXZ@4JA ; `ImDrawList::AddDrawCmd'::`1'::__LINE__Var
PUBLIC	??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??PopClipRect@ImDrawList@@QAEXXZ@4JA ; `ImDrawList::PopClipRect'::`1'::__LINE__Var
PUBLIC	??_C@_1DA@MJAOFGMF@?$AA_?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4@ ; `string'
PUBLIC	?__LINE__Var@?0??PopTextureID@ImDrawList@@QAEXXZ@4JA ; `ImDrawList::PopTextureID'::`1'::__LINE__Var
PUBLIC	??_C@_1DC@CKLENJON@?$AA_?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AAI?$AAd?$AAS?$AAt?$AAa?$AAc?$AAk@ ; `string'
PUBLIC	?__LINE__Var@?0??AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z@4JA ; `ImDrawList::AddText'::`1'::__LINE__Var
PUBLIC	??_C@_1GM@DGBHKFGF@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@ ; `string'
PUBLIC	?__LINE__Var@?0??Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA ; `ImDrawListSplitter::Split'::`1'::__LINE__Var
PUBLIC	??_C@_1DK@EHEALEDG@?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@ ; `string'
PUBLIC	?__LINE__Var@?0??SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA ; `ImDrawListSplitter::SetCurrentChannel'::`1'::__LINE__Var
PUBLIC	??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@ ; `string'
PUBLIC	?__LINE__Var@?0???1ImFontAtlas@@QAE@XZ@4JA	; `ImFontAtlas::~ImFontAtlas'::`1'::__LINE__Var
PUBLIC	??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@ ; `string'
PUBLIC	??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@ ; `string'
PUBLIC	?__LINE__Var@?0??ClearInputData@ImFontAtlas@@QAEXXZ@4JA ; `ImFontAtlas::ClearInputData'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??ClearTexData@ImFontAtlas@@QAEXXZ@4JA ; `ImFontAtlas::ClearTexData'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??ClearFonts@ImFontAtlas@@QAEXXZ@4JA ; `ImFontAtlas::ClearFonts'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z@4JA ; `ImFontAtlas::AddFont'::`1'::__LINE__Var
PUBLIC	??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@ ; `string'
PUBLIC	??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@ ; `string'
PUBLIC	??_C@_0CI@EDBCHFCN@Cannot?5use?5MergeMode?5for?5the?5fi@ ; `string'
PUBLIC	??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@ ; `string'
PUBLIC	??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@	; `string'
PUBLIC	?__LINE__Var@?0??AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z@4JA ; `ImFontAtlas::AddFontFromFileTTF'::`1'::__LINE__Var
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@ ; `string'
PUBLIC	??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@		; `string'
PUBLIC	?__LINE__Var@?0??AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z@4JA ; `ImFontAtlas::AddFontFromMemoryTTF'::`1'::__LINE__Var
PUBLIC	??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@ ; `string'
PUBLIC	?__LINE__Var@?0??AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z@4JA ; `ImFontAtlas::AddFontFromMemoryCompressedTTF'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z@4JA ; `ImFontAtlas::AddCustomRectRegular'::`1'::__LINE__Var
PUBLIC	??_C@_1BO@IFEPJNFF@?$AAi?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AAx?$AA1?$AA1?$AA0?$AA0?$AA0?$AA0@ ; `string'
PUBLIC	??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@ ; `string'
PUBLIC	??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@ ; `string'
PUBLIC	?__LINE__Var@?0??AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z@4JA ; `ImFontAtlas::AddCustomRectFontGlyph'::`1'::__LINE__Var
PUBLIC	??_C@_1BE@PBFICKNN@?$AAf?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z@4JA ; `ImFontAtlas::CalcCustomRectUV'::`1'::__LINE__Var
PUBLIC	??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@ ; `string'
PUBLIC	??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@ ; `string'
PUBLIC	?__LINE__Var@?0??GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU3@1@Z@4JA ; `ImFontAtlas::GetMouseCursorTexData'::`1'::__LINE__Var
PUBLIC	??_C@_1CO@OOJMDEAG@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe?$AAc?$AAt?$AAI?$AAd?$AAs?$AA?$FL?$AA0@ ; `string'
PUBLIC	??_C@_1EO@NGCKHELE@?$AAr?$AA?4?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT?$AA_?$AAA?$AAT@ ; `string'
PUBLIC	?__LINE__Var@?0??Build@ImFontAtlas@@QAE_NXZ@4JA	; `ImFontAtlas::Build'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA ; `ImFontAtlasBuildWithStbTruetype'::`1'::__LINE__Var
PUBLIC	??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@ ; `string'
PUBLIC	??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_0DC@IFELKFNN@FontData?5is?5incorrect?0?5or?5FontN@ ; `string'
PUBLIC	??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@ ; `string'
PUBLIC	??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@ ; `string'
PUBLIC	?__LINE__Var@?0??ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z@4JA ; `ImFontAtlasBuildPackCustomRects'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@ ; `string'
PUBLIC	??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@ ; `string'
PUBLIC	?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA ; `ImFontAtlasBuildRenderDefaultTexData'::`1'::__LINE__Var
PUBLIC	??_C@_1DK@CIPOCJML@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe@ ; `string'
PUBLIC	??_C@_1DI@LKIOFBD@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@ ; `string'
PUBLIC	??_C@_1BK@MDHNDFCJ@?$AAr?$AA?4?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1MG@KMJKJDJG@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT@ ; `string'
PUBLIC	??_C@_1DM@OOPIKMMI@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG@ ; `string'
PUBLIC	?__LINE__Var@?0??ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z@4JA ; `ImFontAtlasBuildFinish'::`1'::__LINE__Var
PUBLIC	??_C@_1EA@GJDLMPMC@?$AAr?$AA?4?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn@ ; `string'
PUBLIC	?__LINE__Var@?0??BuildLookupTable@ImFont@@QAEXXZ@4JA ; `ImFont::BuildLookupTable'::`1'::__LINE__Var
PUBLIC	??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??GrowIndex@ImFont@@QAEXH@Z@4JA	; `ImFont::GrowIndex'::`1'::__LINE__Var
PUBLIC	??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@ ; `string'
PUBLIC	?__LINE__Var@?0??AddRemapChar@ImFont@@QAEXGG_N@Z@4JA ; `ImFont::AddRemapChar'::`1'::__LINE__Var
PUBLIC	??_C@_1CK@OHOOGJPG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAL?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?4?$AAS?$AAi?$AAz@ ; `string'
PUBLIC	?__LINE__Var@?0??RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z@4JA ; `ImGui::RenderMouseCursor'::`1'::__LINE__Var
PUBLIC	??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??stb__match@@YAXPBEI@Z@4JA	; `stb__match'::`1'::__LINE__Var
PUBLIC	??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@ ; `string'
PUBLIC	?__LINE__Var@?0??stb__lit@@YAXPBEI@Z@4JA	; `stb__lit'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??stb_decompress@@YAIPAEPBEI@Z@4JA ; `stb_decompress'::`1'::__LINE__Var
PUBLIC	??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ ; `string'
PUBLIC	??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@ ; `string'
PUBLIC	??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@ ; `string'
PUBLIC	??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3d23d70a
PUBLIC	__real@3d75c28f
PUBLIC	__real@3da3d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3de147ae
PUBLIC	__real@3e0f5c29
PUBLIC	__real@3e23d70a
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e75c28f
PUBLIC	__real@3e800000
PUBLIC	__real@3e851eb8
PUBLIC	__real@3e8a3d71
PUBLIC	__real@3e947ae1
PUBLIC	__real@3e99999a
PUBLIC	__real@3e9eb852
PUBLIC	__real@3ea3d70a
PUBLIC	__real@3eb33333
PUBLIC	__real@3ec7ae14
PUBLIC	__real@3ecccccd
PUBLIC	__real@3ed1eb85
PUBLIC	__real@3ed70a3d
PUBLIC	__real@3edc28f6
PUBLIC	__real@3ee147ae
PUBLIC	__real@3ee66666
PUBLIC	__real@3eeb851f
PUBLIC	__real@3ef0a3d7
PUBLIC	__real@3ef5c28f
PUBLIC	__real@3efae148
PUBLIC	__real@3f000000
PUBLIC	__real@3f028f5c
PUBLIC	__real@3f051eb8
PUBLIC	__real@3f07ae14
PUBLIC	__real@3f0a3d71
PUBLIC	__real@3f0ccccd
PUBLIC	__real@3f0f5c29
PUBLIC	__real@3f170a3d
PUBLIC	__real@3f19999a
PUBLIC	__real@3f1c28f6
PUBLIC	__real@3f1eb852
PUBLIC	__real@3f2147ae
PUBLIC	__real@3f23d70a
PUBLIC	__real@3f2b851f
PUBLIC	__real@3f30a3d7
PUBLIC	__real@3f333333
PUBLIC	__real@3f35c28f
PUBLIC	__real@3f400000
PUBLIC	__real@3f47ae14
PUBLIC	__real@3f4a3d71
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f51eb85
PUBLIC	__real@3f547ae1
PUBLIC	__real@3f5c28f6
PUBLIC	__real@3f5eb852
PUBLIC	__real@3f6147ae
PUBLIC	__real@3f666666
PUBLIC	__real@3f6b851f
PUBLIC	__real@3f70a3d7
PUBLIC	__real@3f733333
PUBLIC	__real@3f75c28f
PUBLIC	__real@3f7ae148
PUBLIC	__real@3f800000
PUBLIC	__real@3f8147ae
PUBLIC	__real@3fc90fdb
PUBLIC	__real@3ffeb852
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__real@41300000
PUBLIC	__real@41400000
PUBLIC	__real@41500000
PUBLIC	__real@41800000
PUBLIC	__real@41880000
PUBLIC	__real@41900000
PUBLIC	__real@41980000
PUBLIC	__real@41a80000
PUBLIC	__real@41b00000
PUBLIC	__real@41b80000
PUBLIC	__real@41f80000
PUBLIC	__real@425c0000
PUBLIC	__real@42920000
PUBLIC	__real@42b60000
PUBLIC	__real@42da0000
PUBLIC	__real@437f0000
PUBLIC	__real@44333333
PUBLIC	__real@44b33333
PUBLIC	__real@45333333
PUBLIC	__real@46000000
PUBLIC	__real@46800000
PUBLIC	__real@47800000
PUBLIC	__real@7f7fffff
PUBLIC	__real@bf800000
PUBLIC	__real@c6000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_memchr:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___wassert:PROC
EXTRN	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?MemAlloc@ImGui@@YAPAXI@Z:PROC			; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPAX@Z:PROC			; ImGui::MemFree
EXTRN	__imp__qsort:PROC
EXTRN	_acos:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp__floor:PROC
EXTRN	?ImFormatString@@YAHPADIPBDZZ:PROC		; ImFormatString
EXTRN	?ImTextCharFromUtf8@@YAHPAIPBD1@Z:PROC		; ImTextCharFromUtf8
EXTRN	?ImFileLoadToMemory@@YAPAXPBD0PAIH@Z:PROC	; ImFileLoadToMemory
EXTRN	@_RTC_AllocaHelper@12:PROC
EXTRN	@_RTC_CheckStackVars2@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ftoui3:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A DQ 01bH DUP (?) ; FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA
?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4PAGA DW 01393H DUP (?) ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::full_ranges
	ALIGN	4

?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA DW 0f3dH DUP (?) ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::full_ranges
	ALIGN	4

?stb__barrier_out_e@@3PAEA DD 01H DUP (?)		; stb__barrier_out_e
?stb__barrier_out_b@@3PAEA DD 01H DUP (?)		; stb__barrier_out_b
?stb__barrier_in_b@@3PBEB DD 01H DUP (?)		; stb__barrier_in_b
?stb__dout@@3PAEA DD 01H DUP (?)			; stb__dout
_BSS	ENDS
CRT$XCU	SEGMENT
?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA$initializer$@@3P6AXXZA DD FLAT:??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ ; FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c6000000
CONST	SEGMENT
__real@c6000000 DD 0c6000000r			; -8192
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@46800000
CONST	SEGMENT
__real@46800000 DD 046800000r			; 16384
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@45333333
CONST	SEGMENT
__real@45333333 DD 045333333r			; 2867.2
CONST	ENDS
;	COMDAT __real@44b33333
CONST	SEGMENT
__real@44b33333 DD 044b33333r			; 1433.6
CONST	ENDS
;	COMDAT __real@44333333
CONST	SEGMENT
__real@44333333 DD 044333333r			; 716.8
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42da0000
CONST	SEGMENT
__real@42da0000 DD 042da0000r			; 109
CONST	ENDS
;	COMDAT __real@42b60000
CONST	SEGMENT
__real@42b60000 DD 042b60000r			; 91
CONST	ENDS
;	COMDAT __real@42920000
CONST	SEGMENT
__real@42920000 DD 042920000r			; 73
CONST	ENDS
;	COMDAT __real@425c0000
CONST	SEGMENT
__real@425c0000 DD 0425c0000r			; 55
CONST	ENDS
;	COMDAT __real@41f80000
CONST	SEGMENT
__real@41f80000 DD 041f80000r			; 31
CONST	ENDS
;	COMDAT __real@41b80000
CONST	SEGMENT
__real@41b80000 DD 041b80000r			; 23
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
CONST	ENDS
;	COMDAT __real@41a80000
CONST	SEGMENT
__real@41a80000 DD 041a80000r			; 21
CONST	ENDS
;	COMDAT __real@41980000
CONST	SEGMENT
__real@41980000 DD 041980000r			; 19
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41880000
CONST	SEGMENT
__real@41880000 DD 041880000r			; 17
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41500000
CONST	SEGMENT
__real@41500000 DD 041500000r			; 13
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ffeb852
CONST	SEGMENT
__real@3ffeb852 DD 03ffeb852r			; 1.99
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3f8147ae
CONST	SEGMENT
__real@3f8147ae DD 03f8147aer			; 1.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ae148
CONST	SEGMENT
__real@3f7ae148 DD 03f7ae148r			; 0.98
CONST	ENDS
;	COMDAT __real@3f75c28f
CONST	SEGMENT
__real@3f75c28f DD 03f75c28fr			; 0.96
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f70a3d7
CONST	SEGMENT
__real@3f70a3d7 DD 03f70a3d7r			; 0.94
CONST	ENDS
;	COMDAT __real@3f6b851f
CONST	SEGMENT
__real@3f6b851f DD 03f6b851fr			; 0.92
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f6147ae
CONST	SEGMENT
__real@3f6147ae DD 03f6147aer			; 0.88
CONST	ENDS
;	COMDAT __real@3f5eb852
CONST	SEGMENT
__real@3f5eb852 DD 03f5eb852r			; 0.87
CONST	ENDS
;	COMDAT __real@3f5c28f6
CONST	SEGMENT
__real@3f5c28f6 DD 03f5c28f6r			; 0.86
CONST	ENDS
;	COMDAT __real@3f547ae1
CONST	SEGMENT
__real@3f547ae1 DD 03f547ae1r			; 0.83
CONST	ENDS
;	COMDAT __real@3f51eb85
CONST	SEGMENT
__real@3f51eb85 DD 03f51eb85r			; 0.82
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f4a3d71
CONST	SEGMENT
__real@3f4a3d71 DD 03f4a3d71r			; 0.79
CONST	ENDS
;	COMDAT __real@3f47ae14
CONST	SEGMENT
__real@3f47ae14 DD 03f47ae14r			; 0.78
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f35c28f
CONST	SEGMENT
__real@3f35c28f DD 03f35c28fr			; 0.71
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f30a3d7
CONST	SEGMENT
__real@3f30a3d7 DD 03f30a3d7r			; 0.69
CONST	ENDS
;	COMDAT __real@3f2b851f
CONST	SEGMENT
__real@3f2b851f DD 03f2b851fr			; 0.67
CONST	ENDS
;	COMDAT __real@3f23d70a
CONST	SEGMENT
__real@3f23d70a DD 03f23d70ar			; 0.64
CONST	ENDS
;	COMDAT __real@3f2147ae
CONST	SEGMENT
__real@3f2147ae DD 03f2147aer			; 0.63
CONST	ENDS
;	COMDAT __real@3f1eb852
CONST	SEGMENT
__real@3f1eb852 DD 03f1eb852r			; 0.62
CONST	ENDS
;	COMDAT __real@3f1c28f6
CONST	SEGMENT
__real@3f1c28f6 DD 03f1c28f6r			; 0.61
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f170a3d
CONST	SEGMENT
__real@3f170a3d DD 03f170a3dr			; 0.59
CONST	ENDS
;	COMDAT __real@3f0f5c29
CONST	SEGMENT
__real@3f0f5c29 DD 03f0f5c29r			; 0.56
CONST	ENDS
;	COMDAT __real@3f0ccccd
CONST	SEGMENT
__real@3f0ccccd DD 03f0ccccdr			; 0.55
CONST	ENDS
;	COMDAT __real@3f0a3d71
CONST	SEGMENT
__real@3f0a3d71 DD 03f0a3d71r			; 0.54
CONST	ENDS
;	COMDAT __real@3f07ae14
CONST	SEGMENT
__real@3f07ae14 DD 03f07ae14r			; 0.53
CONST	ENDS
;	COMDAT __real@3f051eb8
CONST	SEGMENT
__real@3f051eb8 DD 03f051eb8r			; 0.52
CONST	ENDS
;	COMDAT __real@3f028f5c
CONST	SEGMENT
__real@3f028f5c DD 03f028f5cr			; 0.51
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3efae148
CONST	SEGMENT
__real@3efae148 DD 03efae148r			; 0.49
CONST	ENDS
;	COMDAT __real@3ef5c28f
CONST	SEGMENT
__real@3ef5c28f DD 03ef5c28fr			; 0.48
CONST	ENDS
;	COMDAT __real@3ef0a3d7
CONST	SEGMENT
__real@3ef0a3d7 DD 03ef0a3d7r			; 0.47
CONST	ENDS
;	COMDAT __real@3eeb851f
CONST	SEGMENT
__real@3eeb851f DD 03eeb851fr			; 0.46
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3ee147ae
CONST	SEGMENT
__real@3ee147ae DD 03ee147aer			; 0.44
CONST	ENDS
;	COMDAT __real@3edc28f6
CONST	SEGMENT
__real@3edc28f6 DD 03edc28f6r			; 0.43
CONST	ENDS
;	COMDAT __real@3ed70a3d
CONST	SEGMENT
__real@3ed70a3d DD 03ed70a3dr			; 0.42
CONST	ENDS
;	COMDAT __real@3ed1eb85
CONST	SEGMENT
__real@3ed1eb85 DD 03ed1eb85r			; 0.41
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3ec7ae14
CONST	SEGMENT
__real@3ec7ae14 DD 03ec7ae14r			; 0.39
CONST	ENDS
;	COMDAT __real@3eb33333
CONST	SEGMENT
__real@3eb33333 DD 03eb33333r			; 0.35
CONST	ENDS
;	COMDAT __real@3ea3d70a
CONST	SEGMENT
__real@3ea3d70a DD 03ea3d70ar			; 0.32
CONST	ENDS
;	COMDAT __real@3e9eb852
CONST	SEGMENT
__real@3e9eb852 DD 03e9eb852r			; 0.31
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e947ae1
CONST	SEGMENT
__real@3e947ae1 DD 03e947ae1r			; 0.29
CONST	ENDS
;	COMDAT __real@3e8a3d71
CONST	SEGMENT
__real@3e8a3d71 DD 03e8a3d71r			; 0.27
CONST	ENDS
;	COMDAT __real@3e851eb8
CONST	SEGMENT
__real@3e851eb8 DD 03e851eb8r			; 0.26
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e75c28f
CONST	SEGMENT
__real@3e75c28f DD 03e75c28fr			; 0.24
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e23d70a
CONST	SEGMENT
__real@3e23d70a DD 03e23d70ar			; 0.16
CONST	ENDS
;	COMDAT __real@3e0f5c29
CONST	SEGMENT
__real@3e0f5c29 DD 03e0f5c29r			; 0.14
CONST	ENDS
;	COMDAT __real@3de147ae
CONST	SEGMENT
__real@3de147ae DD 03de147aer			; 0.11
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3da3d70a
CONST	SEGMENT
__real@3da3d70a DD 03da3d70ar			; 0.08
CONST	ENDS
;	COMDAT __real@3d75c28f
CONST	SEGMENT
__real@3d75c28f DD 03d75c28fr			; 0.06
CONST	ENDS
;	COMDAT __real@3d23d70a
CONST	SEGMENT
__real@3d23d70a DD 03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@ DB 'i'
	DB	00H, 't', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, '+', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@
CONST	SEGMENT
??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@ DB 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@ DB 'i', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@
CONST	SEGMENT
??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@ DB 's'
	DB	00H, 't', 00H, 'b', 00H, '_', 00H, '_', 00H, 'd', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, 'o', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
CONST	SEGMENT
??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ DB 's'
	DB	00H, 't', 00H, 'b', 00H, '_', 00H, '_', 00H, 'd', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, 'o', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stb_decompress@@YAIPAEPBEI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stb_decompress@@YAIPAEPBEI@Z@4JA DD 0cc7H ; `stb_decompress'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??stb__lit@@YAXPBEI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stb__lit@@YAXPBEI@Z@4JA DD 0c8aH	; `stb__lit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@
CONST	SEGMENT
??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@ DB 's'
	DB	00H, 't', 00H, 'b', 00H, '_', 00H, '_', 00H, 'd', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'l', 00H, 'e'
	DB	00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, '_'
	DB	00H, 'b', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stb__match@@YAXPBEI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stb__match@@YAXPBEI@Z@4JA DD 0c81H	; `stb__match'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@
CONST	SEGMENT
??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@ DB 'm'
	DB	00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, '_', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'N', 00H
	DB	'o', 00H, 'n', 00H, 'e', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'm', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, '_', 00H
	DB	'c', 00H, 'u', 00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H
	DB	'i', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'C'
	DB	00H, 'u', 00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, '_', 00H
	DB	'C', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z@4JA DD 0c09H ; `ImGui::RenderMouseCursor'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CK@OHOOGJPG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAL?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?4?$AAS?$AAi?$AAz@
CONST	SEGMENT
??_C@_1CK@OHOOGJPG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAL?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?4?$AAS?$AAi?$AAz@ DB 'I'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, 'L', 00H, 'o', 00H
	DB	'o', 00H, 'k', 00H, 'u', 00H, 'p', 00H, '.', 00H, 'S', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddRemapChar@ImFont@@QAEXGG_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddRemapChar@ImFont@@QAEXGG_N@Z@4JA DD 0a51H ; `ImFont::AddRemapChar'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@
CONST	SEGMENT
??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@ DB 'I'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, 'A', 00H, 'd', 00H
	DB	'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'X', 00H, '.'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x'
	DB	00H, 'L', 00H, 'o', 00H, 'o', 00H, 'k', 00H, 'u', 00H, 'p', 00H
	DB	'.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GrowIndex@ImFont@@QAEXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GrowIndex@ImFont@@QAEXH@Z@4JA DD 0a2fH	; `ImFont::GrowIndex'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@ DB 'G'
	DB	00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h', 00H, 's', 00H, '.', 00H
	DB	'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '0', 00H, 'x', 00H, 'F', 00H, 'F', 00H, 'F', 00H, 'F', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??BuildLookupTable@ImFont@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??BuildLookupTable@ImFont@@QAEXXZ@4JA DD 0a02H ; `ImFont::BuildLookupTable'::`1'::__LINE__Var
_DATA	ENDS
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::base_ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::base_ranges
	DW	0ffH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
_DATA	ENDS
;	COMDAT ??_C@_1EA@GJDLMPMC@?$AAr?$AA?4?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn@
CONST	SEGMENT
??_C@_1EA@GJDLMPMC@?$AAr?$AA?4?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn@ DB 'r'
	DB	00H, '.', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, '-', 00H
	DB	'>', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, 'e', 00H, 'r', 00H, 'A', 00H, 't', 00H, 'l', 00H
	DB	'a', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'a'
	DB	00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z@4JA DD 08afH ; `ImFontAtlasBuildFinish'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DM@OOPIKMMI@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG@
CONST	SEGMENT
??_C@_1DM@OOPIKMMI@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG@ DB 'r'
	DB	00H, '.', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'r', 00H, '.', 00H, 'H', 00H, 'e', 00H
	DB	'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '2', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@KMJKJDJG@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT@
CONST	SEGMENT
??_C@_1MG@KMJKJDJG@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT@ DB 'r'
	DB	00H, '.', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'F', 00H, 'O', 00H, 'N'
	DB	00H, 'T', 00H, '_', 00H, 'A', 00H, 'T', 00H, 'L', 00H, 'A', 00H
	DB	'S', 00H, '_', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 'A', 00H, 'U'
	DB	00H, 'L', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'E', 00H, 'X', 00H
	DB	'_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, '_', 00H, 'W'
	DB	00H, '_', 00H, 'H', 00H, 'A', 00H, 'L', 00H, 'F', 00H, ' ', 00H
	DB	'*', 00H, ' ', 00H, '2', 00H, ' ', 00H, '+', 00H, ' ', 00H, '1'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, '.', 00H
	DB	'H', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'F', 00H, 'O', 00H, 'N', 00H
	DB	'T', 00H, '_', 00H, 'A', 00H, 'T', 00H, 'L', 00H, 'A', 00H, 'S'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 'A', 00H, 'U', 00H
	DB	'L', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'E', 00H, 'X', 00H, '_'
	DB	00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, '_', 00H, 'H', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MDHNDFCJ@?$AAr?$AA?4?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1BK@MDHNDFCJ@?$AAr?$AA?4?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@ DB 'r'
	DB	00H, '.', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, 'e', 00H, 'd', 00H, '(', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LKIOFBD@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@
CONST	SEGMENT
??_C@_1DI@LKIOFBD@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'T', 00H, 'e', 00H, 'x', 00H, 'P', 00H, 'i', 00H, 'x', 00H, 'e'
	DB	00H, 'l', 00H, 's', 00H, 'A', 00H, 'l', 00H, 'p', 00H, 'h', 00H
	DB	'a', 00H, '8', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@CIPOCJML@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe@
CONST	SEGMENT
??_C@_1DK@CIPOCJML@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'C', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'R'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'I', 00H, 'd', 00H, 's', 00H
	DB	'[', 00H, '0', 00H, ']', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA DD 0890H ; `ImFontAtlasBuildRenderDefaultTexData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@
CONST	SEGMENT
??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@ DB 'p'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '[', 00H, 'i', 00H, ']', 00H, '.'
	DB	00H, 'w', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 's', 00H, '[', 00H, 'i', 00H, ']', 00H, '.', 00H
	DB	'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 'k', 00H
	DB	'_', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '['
	DB	00H, 'i', 00H, ']', 00H, '.', 00H, 'h', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, ']', 00H, '.', 00H, 'H', 00H, 'e', 00H, 'i', 00H, 'g'
	DB	00H, 'h', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@ DB 'u'
	DB	00H, 's', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@ DB 'p'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z@4JA DD 0875H ; `ImFontAtlasBuildPackCustomRects'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@
CONST	SEGMENT
??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@ DB 'g'
	DB	00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h', 00H, '_', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '_', 00H, 'i', 00H, 'n'
	DB	00H, '_', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@
CONST	SEGMENT
??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '_', 00H, 't', 00H, 'm', 00H, 'p', 00H
	DB	'.', 00H, 'G', 00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h', 00H, 's'
	DB	00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '_', 00H, 't', 00H, 'm', 00H
	DB	'p', 00H, '.', 00H, 'G', 00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h'
	DB	00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'o', 00H, 'f', 00H
	DB	'f', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'"', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'D', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'r', 00H, 'r', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, ',', 00H, ' ', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'N', 00H, 'o'
	DB	00H, ' ', 00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 'd', 00H, '.', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IFELKFNN@FontData?5is?5incorrect?0?5or?5FontN@
CONST	SEGMENT
??_C@_0DC@IFELKFNN@FontData?5is?5incorrect?0?5or?5FontN@ DB 'FontData is '
	DB	'incorrect, or FontNo cannot be found.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@
CONST	SEGMENT
??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '_', 00H, 't', 00H, 'm', 00H, 'p', 00H
	DB	'.', 00H, 'D', 00H, 's', 00H, 't', 00H, 'I', 00H, 'n', 00H, 'd'
	DB	00H, 'e', 00H, 'x', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'-', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB 'c'
	DB	00H, 'f', 00H, 'g', 00H, '.', 00H, 'D', 00H, 's', 00H, 't', 00H
	DB	'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '(', 00H, '!', 00H, 'c', 00H, 'f', 00H, 'g', 00H
	DB	'.', 00H, 'D', 00H, 's', 00H, 't', 00H, 'F', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, '-', 00H, '>', 00H, 'I', 00H, 's', 00H, 'L', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'd', 00H, '(', 00H, ')'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '.', 00H, 'D', 00H, 's', 00H, 't', 00H, 'F', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'A', 00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@
CONST	SEGMENT
??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'D'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, '.', 00H, 'S', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA DD 075dH ; `ImFontAtlasBuildWithStbTruetype'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Build@ImFontAtlas@@QAE_NXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Build@ImFontAtlas@@QAE_NXZ@4JA DD 0721H ; `ImFontAtlas::Build'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EO@NGCKHELE@?$AAr?$AA?4?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT?$AA_?$AAA?$AAT@
CONST	SEGMENT
??_C@_1EO@NGCKHELE@?$AAr?$AA?4?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT?$AA_?$AAA?$AAT@ DB 'r'
	DB	00H, '.', 00H, 'I', 00H, 'D', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'F', 00H, 'O', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'A'
	DB	00H, 'T', 00H, 'L', 00H, 'A', 00H, 'S', 00H, '_', 00H, 'D', 00H
	DB	'E', 00H, 'F', 00H, 'A', 00H, 'U', 00H, 'L', 00H, 'T', 00H, '_'
	DB	00H, 'T', 00H, 'E', 00H, 'X', 00H, '_', 00H, 'D', 00H, 'A', 00H
	DB	'T', 00H, 'A', 00H, '_', 00H, 'I', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@OOJMDEAG@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe?$AAc?$AAt?$AAI?$AAd?$AAs?$AA?$FL?$AA0@
CONST	SEGMENT
??_C@_1CO@OOJMDEAG@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe?$AAc?$AAt?$AAI?$AAd?$AAs?$AA?$FL?$AA0@ DB 'C'
	DB	00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'R', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'I', 00H, 'd', 00H, 's', 00H, '['
	DB	00H, '0', 00H, ']', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'-', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU3@1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU3@1@Z@4JA DD 070bH ; `ImFontAtlas::GetMouseCursorTexData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@
CONST	SEGMENT
??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@ DB 'r'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '-', 00H, '>', 00H, 'I', 00H
	DB	's', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 'd'
	DB	00H, '(', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@
CONST	SEGMENT
??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@ DB 'T'
	DB	00H, 'e', 00H, 'x', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 'H', 00H
	DB	'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z@4JA DD 0703H ; `ImFontAtlas::CalcCustomRectUV'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BE@PBFICKNN@?$AAf?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BE@PBFICKNN@?$AAf?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z@4JA DD 06f3H ; `ImFontAtlas::AddCustomRectFontGlyph'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@
CONST	SEGMENT
??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@ DB 'h'
	DB	00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'h', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'F'
	DB	00H, 'F', 00H, 'F', 00H, 'F', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@
CONST	SEGMENT
??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@ DB 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'F', 00H, 'F', 00H, 'F'
	DB	00H, 'F', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@IFEPJNFF@?$AAi?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AAx?$AA1?$AA1?$AA0?$AA0?$AA0?$AA0@
CONST	SEGMENT
??_C@_1BO@IFEPJNFF@?$AAi?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AAx?$AA1?$AA1?$AA0?$AA0?$AA0?$AA0@ DB 'i'
	DB	00H, 'd', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	'x', 00H, '1', 00H, '1', 00H, '0', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z@4JA DD 06e5H ; `ImFontAtlas::AddCustomRectRegular'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z@4JA DD 06cfH ; `ImFontAtlas::AddFontFromMemoryCompressedTTF'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@
CONST	SEGMENT
??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '.', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'D'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z@4JA DD 06c2H ; `ImFontAtlas::AddFontFromMemoryTTF'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@
CONST	SEGMENT
??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@ DB '%s, %.0fpx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@
CONST	SEGMENT
??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@ DB '('
	DB	00H, '0', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'"', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' '
	DB	00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '!', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z@4JA DD 06acH ; `ImFontAtlas::AddFontFromFileTTF'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
CONST	SEGMENT
??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@ DB 'ProggyClean.ttf, %dpx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@
CONST	SEGMENT
??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@ DB '!'
	DB	00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 's', 00H, '.', 00H
	DB	'e', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, '(', 00H, ')'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'C', 00H
	DB	'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'u'
	DB	00H, 's', 00H, 'e', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 'r', 00H
	DB	'g', 00H, 'e', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EDBCHFCN@Cannot?5use?5MergeMode?5for?5the?5fi@
CONST	SEGMENT
??_C@_0CI@EDBCHFCN@Cannot?5use?5MergeMode?5for?5the?5fi@ DB 'Cannot use M'
	DB	'ergeMode for the first font', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@
CONST	SEGMENT
??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '-', 00H, '>', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 'P', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@
CONST	SEGMENT
??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '-', 00H, '>', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H
	DB	'f', 00H, 'g', 00H, '-', 00H, '>', 00H, 'F', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z@4JA DD 0667H ; `ImFontAtlas::AddFont'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??ClearFonts@ImFontAtlas@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ClearFonts@ImFontAtlas@@QAEXXZ@4JA DD 0630H ; `ImFontAtlas::ClearFonts'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??ClearTexData@ImFontAtlas@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ClearTexData@ImFontAtlas@@QAEXXZ@4JA DD 0625H ; `ImFontAtlas::ClearTexData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??ClearInputData@ImFontAtlas@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ClearInputData@ImFontAtlas@@QAEXXZ@4JA DD 060eH ; `ImFontAtlas::ClearInputData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
CONST	SEGMENT
??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@ DB '!'
	DB	00H, 'L', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'C', 00H, 'a'
	DB	00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'm', 00H
	DB	'o', 00H, 'd', 00H, 'i', 00H, 'f', 00H, 'y', 00H, ' ', 00H, 'a'
	DB	00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'F', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, 'A', 00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	' ', 00H, 'b', 00H, 'e', 00H, 't', 00H, 'w', 00H, 'e', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, 'N', 00H, 'e', 00H, 'w', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'd', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '/'
	DB	00H, 'R', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'(', 00H, ')', 00H, '!', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
CONST	SEGMENT
??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@ DB 'Cannot modify'
	DB	' a locked ImFontAtlas between NewFrame() and EndFrame/Render('
	DB	')!', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0???1ImFontAtlas@@QAE@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0???1ImFontAtlas@@QAE@XZ@4JA DD 0608H	; `ImFontAtlas::~ImFontAtlas'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@
CONST	SEGMENT
??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@ DB 'i'
	DB	00H, 'd', 00H, 'x', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'i', 00H, 'd'
	DB	00H, 'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, '_', 00H, 'C', 00H
	DB	'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA DD 0543H ; `ImDrawListSplitter::SetCurrentChannel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DK@EHEALEDG@?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1DK@EHEALEDG@?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@ DB '_'
	DB	00H, 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'C', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA DD 04e6H ; `ImDrawListSplitter::Split'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GM@DGBHKFGF@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@
CONST	SEGMENT
??_C@_1GM@DGBHKFGF@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '-', 00H, '>', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, 'A', 00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	'-', 00H, '>', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 'I', 00H, 'D'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '_', 00H, 'T', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 'I'
	DB	00H, 'd', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H
	DB	'.', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '(', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z@4JA DD 0476H ; `ImDrawList::AddText'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@CKLENJON@?$AA_?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AAI?$AAd?$AAS?$AAt?$AAa?$AAc?$AAk@
CONST	SEGMENT
??_C@_1DC@CKLENJON@?$AA_?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AAI?$AAd?$AAS?$AAt?$AAa?$AAc?$AAk@ DB '_'
	DB	00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, 'I', 00H, 'd', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??PopTextureID@ImDrawList@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??PopTextureID@ImDrawList@@QAEXXZ@4JA DD 0201H ; `ImDrawList::PopTextureID'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DA@MJAOFGMF@?$AA_?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4@
CONST	SEGMENT
??_C@_1DA@MJAOFGMF@?$AA_?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4@ DB '_'
	DB	00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p', 00H, 'R', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k'
	DB	00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??PopClipRect@ImDrawList@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??PopClipRect@ImDrawList@@QAEXXZ@4JA DD 01f4H ; `ImDrawList::PopClipRect'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@
CONST	SEGMENT
??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@ DB 'd'
	DB	00H, 'r', 00H, 'a', 00H, 'w', 00H, '_', 00H, 'c', 00H, 'm', 00H
	DB	'd', 00H, '.', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p', 00H, 'R'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'x', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w'
	DB	00H, '_', 00H, 'c', 00H, 'm', 00H, 'd', 00H, '.', 00H, 'C', 00H
	DB	'l', 00H, 'i', 00H, 'p', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, '.', 00H, 'z', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, '_', 00H, 'c', 00H, 'm'
	DB	00H, 'd', 00H, '.', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p', 00H
	DB	'R', 00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'y', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a', 00H
	DB	'w', 00H, '_', 00H, 'c', 00H, 'm', 00H, 'd', 00H, '.', 00H, 'C'
	DB	00H, 'l', 00H, 'i', 00H, 'p', 00H, 'R', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, '.', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '_'
	DB	00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, '.', 00H, 'c', 00H
	DB	'p', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AddDrawCmd@ImDrawList@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??AddDrawCmd@ImDrawList@@QAEXXZ@4JA DD 0197H ; `ImDrawList::AddDrawCmd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DO@LAPBLJ@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$CK?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe@
CONST	SEGMENT
??_C@_1DO@LAPBLJ@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$CK?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe@ DB 'p'
	DB	00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, '*', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, '_', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'b', 00H
	DB	'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ']', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__v_prefilter@@YAXPAEHHHI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__v_prefilter@@YAXPAEHHHI@Z@4JA DD 0f4bH ; `stbtt__v_prefilter'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ DB 'p'
	DB	00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__h_prefilter@@YAXPAEHHHI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__h_prefilter@@YAXPAEHHHI@Z@4JA DD 0f0dH ; `stbtt__h_prefilter'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@
CONST	SEGMENT
??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'n', 00H, '_'
	DB	00H, 'y', 00H, '_', 00H, 't', 00H, 'o', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@
CONST	SEGMENT
??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 'd', 00H, 'i', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z@4JA DD 0c42H ; `stbtt__rasterize_sorted_edges'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CM@OJNMKDLP@?$AAI?$AAm?$AAF?$AAa?$AAb?$AAs?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN@
CONST	SEGMENT
??_C@_1CM@OJNMKDLP@?$AAI?$AAm?$AAF?$AAa?$AAb?$AAs?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN@ DB 'I'
	DB	00H, 'm', 00H, 'F', 00H, 'a', 00H, 'b', 00H, 's', 00H, '(', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'a', 00H, ')', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '1', 00H, '.', 00H, '0', 00H, '1', 00H
	DB	'f', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@
CONST	SEGMENT
??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@ DB 'x'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@
CONST	SEGMENT
??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'y', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 'b', 00H, 'o', 00H, 't'
	DB	00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'e', 00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 't', 00H
	DB	'o', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@
CONST	SEGMENT
??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 't', 00H, 'o', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z@4JA DD 0b9eH ; `stbtt__fill_active_edges_new'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FK@JPMIPNJF@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@
CONST	SEGMENT
??_C@_1FK@JPMIPNJF@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@ DB 'x'
	DB	00H, '0', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '0', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '+', 00H, '1', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '1', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'x', 00H, '1', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, 'x', 00H, '+', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@NILBPPPH@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@
CONST	SEGMENT
??_C@_1CK@NILBPPPH@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@ DB 'x'
	DB	00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '1', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '+', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@NGGEAFFG@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@
CONST	SEGMENT
??_C@_1BE@NGGEAFFG@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@ DB 'x'
	DB	00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	'+', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@
CONST	SEGMENT
??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@ DB 'x', 00H
	DB	'1', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@
CONST	SEGMENT
??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@ DB 'x', 00H
	DB	'1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@DHAKMBPL@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@
CONST	SEGMENT
??_C@_1BE@DHAKMBPL@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@ DB 'x'
	DB	00H, '1', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	'+', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@
CONST	SEGMENT
??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'y', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'e', 00H, '-', 00H, '>', 00H, 'e', 00H, 'y'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@
CONST	SEGMENT
??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@ DB 'y', 00H, '0'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'y', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA DD 0b79H ; `stbtt__handle_clipped_edge'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 'z', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z@4JA DD 0aceH ; `stbtt__new_active'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@
CONST	SEGMENT
??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, '_', 00H
	DB	'c', 00H, 't', 00H, 'x', 00H, '.', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, '_', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, '_', 00H
	DB	'c', 00H, 't', 00H, 'x', 00H, '.', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, '_', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA DD 08beH ; `stbtt__GetGlyphShapeT2'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA DD 0668H ; `stbtt__GetGlyphShapeTT'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@ DB '!'
	DB	00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '-', 00H, '>', 00H
	DB	'c', 00H, 'f', 00H, 'f', 00H, '.', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z@4JA DD 0621H ; `stbtt__GetGlyfOffset'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1HA@EBGBJFDE@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1HA@EBGBJFDE@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@ DB 'u'
	DB	00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, 't', 00H, 't', 00H, 'U', 00H, 'S', 00H, 'H', 00H, 'O'
	DB	00H, 'R', 00H, 'T', 00H, '(', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, '2', 00H, '*', 00H, 'i', 00H, 't', 00H, 'e'
	DB	00H, 'm', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt_FindGlyphIndex@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt_FindGlyphIndex@@9@4JA DD 05b6H	; `stbtt_FindGlyphIndex'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04KODIGLGG@maxp@
CONST	SEGMENT
??_C@_04KODIGLGG@maxp@ DB 'maxp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJGCPIEK@CFF?5@
CONST	SEGMENT
??_C@_04HJGCPIEK@CFF?5@ DB 'CFF ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCFDEHHD@GPOS@
CONST	SEGMENT
??_C@_04PCFDEHHD@GPOS@ DB 'GPOS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HHMMLDJI@kern@
CONST	SEGMENT
??_C@_04HHMMLDJI@kern@ DB 'kern', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONMNCIMC@hmtx@
CONST	SEGMENT
??_C@_04ONMNCIMC@hmtx@ DB 'hmtx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMPHLIKP@hhea@
CONST	SEGMENT
??_C@_04FMPHLIKP@hhea@ DB 'hhea', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLIHEPK@glyf@
CONST	SEGMENT
??_C@_04LLIHEPK@glyf@ DB 'glyf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DACNFKGE@loca@
CONST	SEGMENT
??_C@_04DACNFKGE@loca@ DB 'loca', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EICJPCEA@cmap@
CONST	SEGMENT
??_C@_04EICJPCEA@cmap@ DB 'cmap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIOEMAHO@ttcf@
CONST	SEGMENT
??_C@_04KIOEMAHO@ttcf@ DB 'ttcf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLEFIKCJ@OTTO@
CONST	SEGMENT
??_C@_04LLEFIKCJ@OTTO@ DB 'OTTO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBBEMOBJ@typ1@
CONST	SEGMENT
??_C@_04LBBEMOBJ@typ1@ DB 'typ1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@ DB 'i'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__cff_index_get@@YA?AUstbtt__buf@@U2@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__cff_index_get@@YA?AUstbtt__buf@@U2@H@Z@4JA DD 04dcH ; `stbtt__cff_index_get'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@
CONST	SEGMENT
??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@ DB 'b'
	DB	00H, '0', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '2', 00H
	DB	'8', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z@4JA DD 04afH ; `stbtt__cff_skip_operand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__cff_int@@YAIPAUstbtt__buf@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__cff_int@@YAIPAUstbtt__buf@@@Z@4JA DD 04a4H ; `stbtt__cff_int'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
CONST	SEGMENT
??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@ DB 'o'
	DB	00H, 'f', 00H, 'f', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, '4', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU2@@Z@4JA DD 0496H ; `stbtt__cff_get_index'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@
CONST	SEGMENT
??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'0', 00H, 'x', 00H, '4', 00H, '0', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z@4JA DD 0480H ; `stbtt__new_buf'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@ DB 'n'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '4', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z@4JA DD 0476H ; `stbtt__buf_get'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
CONST	SEGMENT
??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@ DB '!'
	DB	00H, '(', 00H, 'o', 00H, ' ', 00H, '>', 00H, ' ', 00H, 'b', 00H
	DB	'-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' '
	DB	00H, '|', 00H, '|', 00H, ' ', 00H, 'o', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '0', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 's', 00H, 't', 00H, 'b', 00H, '_'
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z@4JA DD 046bH ; `stbtt__buf_seek'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DM@MABMKAHD@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx@
CONST	SEGMENT
??_C@_1DM@MABMKAHD@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx@ DB 'c'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'e'
	DB	00H, 'x', 00H, 't', 00H, '-', 00H, '>', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, '_', 00H, 'n', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 's'
	DB	00H, '+', 00H, '2', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NJIDGHPD@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BO@NJIDGHPD@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ DB 'c'
	DB	00H, 'u', 00H, 'r', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@NCKIDPDA@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn@
CONST	SEGMENT
??_C@_1CM@NCKIDPDA@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn@ DB 'c'
	DB	00H, 'u', 00H, 'r', 00H, '-', 00H, '>', 00H, 'x', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 'r', 00H, '-', 00H, '>'
	DB	00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, '-', 00H, '>', 00H
	DB	'x', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA DD 01c6H ; `stbrp__skyline_pack_rectangle'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BI@JNFMLHFF@?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAe?$AAs?$AAt?$AA_?$AAy@
CONST	SEGMENT
??_C@_1BI@JNFMLHFF@?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAe?$AAs?$AAt?$AA_?$AAy@ DB 'y'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'b', 00H, 'e', 00H
	DB	's', 00H, 't', 00H, '_', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
CONST	SEGMENT
??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, '-', 00H, '>', 00H, 'x', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, 'x', 00H, 'p', 00H, 'o', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, '-', 00H, '>', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'x', 00H, 'p', 00H, 'o', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ DB 'x'
	DB	00H, 'p', 00H, 'o', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@
CONST	SEGMENT
??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@ DB 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '%', 00H
	DB	' ', 00H, 'c', 00H, '-', 00H, '>', 00H, 'a', 00H, 'l', 00H, 'i'
	DB	00H, 'g', 00H, 'n', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA DD 0160H ; `stbrp__skyline_find_best_pos'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
CONST	SEGMENT
??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '-', 00H, '>', 00H, 'x', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
CONST	SEGMENT
??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, '-', 00H, '>', 00H, 'x', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, 'x', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
CONST	SEGMENT
??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ DB 'f'
	DB	00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, '-', 00H, '>', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z@4JA DD 0128H ; `stbrp__skyline_find_min_y'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@
CONST	SEGMENT
??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@ DB 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'f', 00H, 'f', 00H, 'f'
	DB	00H, 'f', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H
	DB	'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'f', 00H, 'f', 00H
	DB	'f', 00H, 'f', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stbrp_init_target@@9@4JA
_DATA	SEGMENT
?__LINE__Var@?0??stbrp_init_target@@9@4JA DD 0107H	; `stbrp_init_target'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 's', 00H, 't', 00H, 'b', 00H, '_'
	DB	00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'p', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@ DB 'D'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'm', 00H, 'i', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, '\', 00H, 'c', 00H, 's', 00H, 'g', 00H
	DB	'o', 00H, 'H', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '\', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'k', 00H, 't', 00H
	DB	'W', 00H, 'o', 00H, 'l', 00H, 'f', 00H, '\', 00H, 'I', 00H, 'm'
	DB	00H, 'G', 00H, 'u', 00H, 'i', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'X', 00H, ' ', 00H, '9'
	DB	00H, ' ', 00H, 'K', 00H, 'i', 00H, 'e', 00H, 'r', 00H, 'o', 00H
	DB	' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, ' ', 00H, '2'
	DB	00H, '\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z$0
__ehfuncinfo$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$3
__ehfuncinfo$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@H@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImFont@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImFont@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImFont@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ImFont@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ImFont@@QAE@XZ$2
__ehfuncinfo$??0ImFont@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0ImFont@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImFontGlyph@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@M@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImFontConfig@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAUImFont@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z$0
__ehfuncinfo$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImFontAtlas@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImFontAtlas@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImFontAtlas@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ImFontAtlas@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ImFontAtlas@@QAE@XZ$2
__ehfuncinfo$??0ImFontAtlas@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0ImFontAtlas@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DeIndexAllBuffers@ImDrawData@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeIndexAllBuffers@ImDrawData@@QAEXXZ$0
__ehfuncinfo$?DeIndexAllBuffers@ImDrawData@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeIndexAllBuffers@ImDrawData@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CloneOutput@ImDrawList@@QBEPAU1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CloneOutput@ImDrawList@@QBEPAU1@XZ$0
__ehfuncinfo$?CloneOutput@ImDrawList@@QBEPAU1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CloneOutput@ImDrawList@@QBEPAU1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImVec2@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAX@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImVec4@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawVert@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z$0
__ehfuncinfo$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImDrawListSplitter@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImDrawListSplitter@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImDrawListSplitter@@QAE@XZ$0
__ehfuncinfo$??0ImDrawListSplitter@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImDrawListSplitter@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawChannel@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImDrawChannel@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImDrawChannel@@QAE@XZ$0
__ehfuncinfo$??0ImDrawChannel@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImDrawChannel@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawCmd@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@G@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??3@YAXPAXUImNewDummy@@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?stb_adler32@@YAIIPAEI@Z
_TEXT	SEGMENT
_i$ = -56						; size = 4
_blocklen$ = -44					; size = 4
_s2$ = -32						; size = 4
_s1$ = -20						; size = 4
_ADLER_MOD$ = -8					; size = 4
_adler32$ = 8						; size = 4
_buffer$ = 12						; size = 4
_buflen$ = 16						; size = 4
?stb_adler32@@YAIIPAEI@Z PROC				; stb_adler32, COMDAT

; 3240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3241 :     const unsigned long ADLER_MOD = 65521;

  00028	c7 45 f8 f1 ff
	00 00		 mov	 DWORD PTR _ADLER_MOD$[ebp], 65521 ; 0000fff1H

; 3242 :     unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _adler32$[ebp]
  00032	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00037	89 45 ec	 mov	 DWORD PTR _s1$[ebp], eax
  0003a	8b 45 08	 mov	 eax, DWORD PTR _adler32$[ebp]
  0003d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00040	89 45 e0	 mov	 DWORD PTR _s2$[ebp], eax

; 3243 :     unsigned long blocklen = buflen % 5552;

  00043	8b 45 10	 mov	 eax, DWORD PTR _buflen$[ebp]
  00046	33 d2		 xor	 edx, edx
  00048	b9 b0 15 00 00	 mov	 ecx, 5552		; 000015b0H
  0004d	f7 f1		 div	 ecx
  0004f	89 55 d4	 mov	 DWORD PTR _blocklen$[ebp], edx
$LN2@stb_adler3:

; 3244 : 
; 3245 :     unsigned long i;
; 3246 :     while (buflen) {

  00052	83 7d 10 00	 cmp	 DWORD PTR _buflen$[ebp], 0
  00056	0f 84 84 01 00
	00		 je	 $LN3@stb_adler3

; 3247 :         for (i=0; i + 7 < blocklen; i += 8) {

  0005c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00063	eb 09		 jmp	 SHORT $LN6@stb_adler3
$LN4@stb_adler3:
  00065	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00068	83 c0 08	 add	 eax, 8
  0006b	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
$LN6@stb_adler3:
  0006e	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00071	83 c0 07	 add	 eax, 7
  00074	3b 45 d4	 cmp	 eax, DWORD PTR _blocklen$[ebp]
  00077	0f 83 fd 00 00
	00		 jae	 $LN5@stb_adler3

; 3248 :             s1 += buffer[0], s2 += s1;

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	6b c8 00	 imul	 ecx, eax, 0
  00085	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00088	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0008c	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  0008f	89 45 ec	 mov	 DWORD PTR _s1$[ebp], eax
  00092	8b 4d e0	 mov	 ecx, DWORD PTR _s2$[ebp]
  00095	03 4d ec	 add	 ecx, DWORD PTR _s1$[ebp]
  00098	89 4d e0	 mov	 DWORD PTR _s2$[ebp], ecx

; 3249 :             s1 += buffer[1], s2 += s1;

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	c1 e0 00	 shl	 eax, 0
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000a6	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000aa	03 55 ec	 add	 edx, DWORD PTR _s1$[ebp]
  000ad	89 55 ec	 mov	 DWORD PTR _s1$[ebp], edx
  000b0	8b 45 e0	 mov	 eax, DWORD PTR _s2$[ebp]
  000b3	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  000b6	89 45 e0	 mov	 DWORD PTR _s2$[ebp], eax

; 3250 :             s1 += buffer[2], s2 += s1;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	d1 e0		 shl	 eax, 1
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000c3	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000c7	03 55 ec	 add	 edx, DWORD PTR _s1$[ebp]
  000ca	89 55 ec	 mov	 DWORD PTR _s1$[ebp], edx
  000cd	8b 45 e0	 mov	 eax, DWORD PTR _s2$[ebp]
  000d0	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  000d3	89 45 e0	 mov	 DWORD PTR _s2$[ebp], eax

; 3251 :             s1 += buffer[3], s2 += s1;

  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	6b c8 03	 imul	 ecx, eax, 3
  000de	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  000e1	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000e5	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  000e8	89 45 ec	 mov	 DWORD PTR _s1$[ebp], eax
  000eb	8b 4d e0	 mov	 ecx, DWORD PTR _s2$[ebp]
  000ee	03 4d ec	 add	 ecx, DWORD PTR _s1$[ebp]
  000f1	89 4d e0	 mov	 DWORD PTR _s2$[ebp], ecx

; 3252 :             s1 += buffer[4], s2 += s1;

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	c1 e0 02	 shl	 eax, 2
  000fc	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000ff	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00103	03 55 ec	 add	 edx, DWORD PTR _s1$[ebp]
  00106	89 55 ec	 mov	 DWORD PTR _s1$[ebp], edx
  00109	8b 45 e0	 mov	 eax, DWORD PTR _s2$[ebp]
  0010c	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  0010f	89 45 e0	 mov	 DWORD PTR _s2$[ebp], eax

; 3253 :             s1 += buffer[5], s2 += s1;

  00112	b8 01 00 00 00	 mov	 eax, 1
  00117	6b c8 05	 imul	 ecx, eax, 5
  0011a	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0011d	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00121	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  00124	89 45 ec	 mov	 DWORD PTR _s1$[ebp], eax
  00127	8b 4d e0	 mov	 ecx, DWORD PTR _s2$[ebp]
  0012a	03 4d ec	 add	 ecx, DWORD PTR _s1$[ebp]
  0012d	89 4d e0	 mov	 DWORD PTR _s2$[ebp], ecx

; 3254 :             s1 += buffer[6], s2 += s1;

  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	6b c8 06	 imul	 ecx, eax, 6
  00138	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0013b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0013f	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  00142	89 45 ec	 mov	 DWORD PTR _s1$[ebp], eax
  00145	8b 4d e0	 mov	 ecx, DWORD PTR _s2$[ebp]
  00148	03 4d ec	 add	 ecx, DWORD PTR _s1$[ebp]
  0014b	89 4d e0	 mov	 DWORD PTR _s2$[ebp], ecx

; 3255 :             s1 += buffer[7], s2 += s1;

  0014e	b8 01 00 00 00	 mov	 eax, 1
  00153	6b c8 07	 imul	 ecx, eax, 7
  00156	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00159	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0015d	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  00160	89 45 ec	 mov	 DWORD PTR _s1$[ebp], eax
  00163	8b 4d e0	 mov	 ecx, DWORD PTR _s2$[ebp]
  00166	03 4d ec	 add	 ecx, DWORD PTR _s1$[ebp]
  00169	89 4d e0	 mov	 DWORD PTR _s2$[ebp], ecx

; 3256 : 
; 3257 :             buffer += 8;

  0016c	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0016f	83 c0 08	 add	 eax, 8
  00172	89 45 0c	 mov	 DWORD PTR _buffer$[ebp], eax

; 3258 :         }

  00175	e9 eb fe ff ff	 jmp	 $LN4@stb_adler3
$LN5@stb_adler3:

; 3259 : 
; 3260 :         for (; i < blocklen; ++i)

  0017a	eb 09		 jmp	 SHORT $LN9@stb_adler3
$LN7@stb_adler3:
  0017c	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  0017f	83 c0 01	 add	 eax, 1
  00182	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
$LN9@stb_adler3:
  00185	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00188	3b 45 d4	 cmp	 eax, DWORD PTR _blocklen$[ebp]
  0018b	73 20		 jae	 SHORT $LN8@stb_adler3

; 3261 :             s1 += *buffer++, s2 += s1;

  0018d	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00190	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00193	03 4d ec	 add	 ecx, DWORD PTR _s1$[ebp]
  00196	89 4d ec	 mov	 DWORD PTR _s1$[ebp], ecx
  00199	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0019c	83 c2 01	 add	 edx, 1
  0019f	89 55 0c	 mov	 DWORD PTR _buffer$[ebp], edx
  001a2	8b 45 e0	 mov	 eax, DWORD PTR _s2$[ebp]
  001a5	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]
  001a8	89 45 e0	 mov	 DWORD PTR _s2$[ebp], eax
  001ab	eb cf		 jmp	 SHORT $LN7@stb_adler3
$LN8@stb_adler3:

; 3262 : 
; 3263 :         s1 %= ADLER_MOD, s2 %= ADLER_MOD;

  001ad	8b 45 ec	 mov	 eax, DWORD PTR _s1$[ebp]
  001b0	33 d2		 xor	 edx, edx
  001b2	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  001b7	f7 f1		 div	 ecx
  001b9	89 55 ec	 mov	 DWORD PTR _s1$[ebp], edx
  001bc	8b 45 e0	 mov	 eax, DWORD PTR _s2$[ebp]
  001bf	33 d2		 xor	 edx, edx
  001c1	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  001c6	f7 f1		 div	 ecx
  001c8	89 55 e0	 mov	 DWORD PTR _s2$[ebp], edx

; 3264 :         buflen -= blocklen;

  001cb	8b 45 10	 mov	 eax, DWORD PTR _buflen$[ebp]
  001ce	2b 45 d4	 sub	 eax, DWORD PTR _blocklen$[ebp]
  001d1	89 45 10	 mov	 DWORD PTR _buflen$[ebp], eax

; 3265 :         blocklen = 5552;

  001d4	c7 45 d4 b0 15
	00 00		 mov	 DWORD PTR _blocklen$[ebp], 5552 ; 000015b0H

; 3266 :     }

  001db	e9 72 fe ff ff	 jmp	 $LN2@stb_adler3
$LN3@stb_adler3:

; 3267 :     return (unsigned int)(s2 << 16) + (unsigned int)s1;

  001e0	8b 45 e0	 mov	 eax, DWORD PTR _s2$[ebp]
  001e3	c1 e0 10	 shl	 eax, 16			; 00000010H
  001e6	03 45 ec	 add	 eax, DWORD PTR _s1$[ebp]

; 3268 : }

  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	5b		 pop	 ebx
  001ec	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  001f2	3b ec		 cmp	 ebp, esp
  001f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
?stb_adler32@@YAIIPAEI@Z ENDP				; stb_adler32
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?stb_decompress_token@@YAPBEPBE@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?stb_decompress_token@@YAPBEPBE@Z PROC			; stb_decompress_token, COMDAT

; 3223 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3224 :     if (*i >= 0x20) { // use fewer if's for cases that expand small

  00028	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002e	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00031	0f 8c f2 00 00
	00		 jl	 $LN2@stb_decomp

; 3225 :         if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;

  00037	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0003d	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00043	7c 44		 jl	 SHORT $LN4@stb_decomp
  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	6b c8 00	 imul	 ecx, eax, 0
  0004d	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00050	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00054	83 e8 7f	 sub	 eax, 127		; 0000007fH
  00057	50		 push	 eax
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	c1 e1 00	 shl	 ecx, 0
  00060	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00063	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stb__dout@@3PAEA
  0006d	2b c8		 sub	 ecx, eax
  0006f	83 e9 01	 sub	 ecx, 1
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ?stb__match@@YAXPBEI@Z	; stb__match
  00078	83 c4 08	 add	 esp, 8
  0007b	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  0007e	83 c2 02	 add	 edx, 2
  00081	89 55 08	 mov	 DWORD PTR _i$[ebp], edx
  00084	e9 9b 00 00 00	 jmp	 $LN5@stb_decomp
$LN4@stb_decomp:

; 3226 :         else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;

  00089	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0008c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0008f	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00092	7c 55		 jl	 SHORT $LN6@stb_decomp
  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	d1 e0		 shl	 eax, 1
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0009e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000a2	83 c2 01	 add	 edx, 1
  000a5	52		 push	 edx
  000a6	b8 01 00 00 00	 mov	 eax, 1
  000ab	6b c8 00	 imul	 ecx, eax, 0
  000ae	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  000b1	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000b5	c1 e0 08	 shl	 eax, 8
  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	c1 e1 00	 shl	 ecx, 0
  000c0	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  000c3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  000c7	8d 94 08 01 c0
	ff ff		 lea	 edx, DWORD PTR [eax+ecx-16383]
  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  000d3	2b c2		 sub	 eax, edx
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?stb__match@@YAXPBEI@Z	; stb__match
  000db	83 c4 08	 add	 esp, 8
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  000e1	83 c1 03	 add	 ecx, 3
  000e4	89 4d 08	 mov	 DWORD PTR _i$[ebp], ecx
  000e7	eb 3b		 jmp	 SHORT $LN5@stb_decomp
$LN6@stb_decomp:

; 3227 :         else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	6b c8 00	 imul	 ecx, eax, 0
  000f1	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  000f4	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000f8	83 e8 1f	 sub	 eax, 31			; 0000001fH
  000fb	50		 push	 eax
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  000ff	83 c1 01	 add	 ecx, 1
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 ?stb__lit@@YAXPBEI@Z	; stb__lit
  00108	83 c4 08	 add	 esp, 8
  0010b	ba 01 00 00 00	 mov	 edx, 1
  00110	6b c2 00	 imul	 eax, edx, 0
  00113	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00116	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0011a	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0011d	8d 4c 10 e2	 lea	 ecx, DWORD PTR [eax+edx-30]
  00121	89 4d 08	 mov	 DWORD PTR _i$[ebp], ecx
$LN5@stb_decomp:

; 3228 :     } else { // more ifs for cases that expand large, since overhead is amortized

  00124	e9 e1 02 00 00	 jmp	 $LN3@stb_decomp
$LN2@stb_decomp:

; 3229 :         if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;

  00129	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0012c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0012f	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00132	7c 6d		 jl	 SHORT $LN8@stb_decomp
  00134	b8 01 00 00 00	 mov	 eax, 1
  00139	6b c8 03	 imul	 ecx, eax, 3
  0013c	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  0013f	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00143	83 c0 01	 add	 eax, 1
  00146	50		 push	 eax
  00147	b9 01 00 00 00	 mov	 ecx, 1
  0014c	6b d1 00	 imul	 edx, ecx, 0
  0014f	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00152	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00156	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00159	ba 01 00 00 00	 mov	 edx, 1
  0015e	c1 e2 00	 shl	 edx, 0
  00161	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00164	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  00168	c1 e2 08	 shl	 edx, 8
  0016b	b8 01 00 00 00	 mov	 eax, 1
  00170	d1 e0		 shl	 eax, 1
  00172	8b 75 08	 mov	 esi, DWORD PTR _i$[ebp]
  00175	0f b6 04 06	 movzx	 eax, BYTE PTR [esi+eax]
  00179	03 d0		 add	 edx, eax
  0017b	8d 8c 11 01 00
	e8 ff		 lea	 ecx, DWORD PTR [ecx+edx-1572863]
  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?stb__dout@@3PAEA
  00188	2b d1		 sub	 edx, ecx
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?stb__match@@YAXPBEI@Z	; stb__match
  00190	83 c4 08	 add	 esp, 8
  00193	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00196	83 c0 04	 add	 eax, 4
  00199	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
  0019c	e9 69 02 00 00	 jmp	 $LN3@stb_decomp
$LN8@stb_decomp:

; 3230 :         else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;

  001a1	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  001a4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001a7	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001aa	0f 8c 80 00 00
	00		 jl	 $LN10@stb_decomp
  001b0	b8 01 00 00 00	 mov	 eax, 1
  001b5	6b c8 03	 imul	 ecx, eax, 3
  001b8	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  001bb	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001bf	c1 e0 08	 shl	 eax, 8
  001c2	b9 01 00 00 00	 mov	 ecx, 1
  001c7	c1 e1 02	 shl	 ecx, 2
  001ca	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  001cd	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  001d1	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  001d5	52		 push	 edx
  001d6	b8 01 00 00 00	 mov	 eax, 1
  001db	6b c8 00	 imul	 ecx, eax, 0
  001de	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  001e1	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001e5	c1 e0 10	 shl	 eax, 16			; 00000010H
  001e8	b9 01 00 00 00	 mov	 ecx, 1
  001ed	c1 e1 00	 shl	 ecx, 0
  001f0	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  001f3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  001f7	c1 e1 08	 shl	 ecx, 8
  001fa	ba 01 00 00 00	 mov	 edx, 1
  001ff	d1 e2		 shl	 edx, 1
  00201	8b 75 08	 mov	 esi, DWORD PTR _i$[ebp]
  00204	0f b6 14 16	 movzx	 edx, BYTE PTR [esi+edx]
  00208	03 ca		 add	 ecx, edx
  0020a	8d 84 08 01 00
	f0 ff		 lea	 eax, DWORD PTR [eax+ecx-1048575]
  00211	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stb__dout@@3PAEA
  00217	2b c8		 sub	 ecx, eax
  00219	51		 push	 ecx
  0021a	e8 00 00 00 00	 call	 ?stb__match@@YAXPBEI@Z	; stb__match
  0021f	83 c4 08	 add	 esp, 8
  00222	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00225	83 c2 05	 add	 edx, 5
  00228	89 55 08	 mov	 DWORD PTR _i$[ebp], edx
  0022b	e9 da 01 00 00	 jmp	 $LN3@stb_decomp
$LN10@stb_decomp:

; 3231 :         else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);

  00230	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00233	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00236	83 f9 08	 cmp	 ecx, 8
  00239	7c 6b		 jl	 SHORT $LN12@stb_decomp
  0023b	b8 01 00 00 00	 mov	 eax, 1
  00240	6b c8 00	 imul	 ecx, eax, 0
  00243	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00246	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0024a	c1 e0 08	 shl	 eax, 8
  0024d	b9 01 00 00 00	 mov	 ecx, 1
  00252	c1 e1 00	 shl	 ecx, 0
  00255	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00258	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0025c	8d 94 08 01 f8
	ff ff		 lea	 edx, DWORD PTR [eax+ecx-2047]
  00263	52		 push	 edx
  00264	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00267	83 c0 02	 add	 eax, 2
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 ?stb__lit@@YAXPBEI@Z	; stb__lit
  00270	83 c4 08	 add	 esp, 8
  00273	b9 01 00 00 00	 mov	 ecx, 1
  00278	6b d1 00	 imul	 edx, ecx, 0
  0027b	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0027e	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00282	c1 e1 08	 shl	 ecx, 8
  00285	ba 01 00 00 00	 mov	 edx, 1
  0028a	c1 e2 00	 shl	 edx, 0
  0028d	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00290	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  00294	03 55 08	 add	 edx, DWORD PTR _i$[ebp]
  00297	8d 84 0a 03 f8
	ff ff		 lea	 eax, DWORD PTR [edx+ecx-2045]
  0029e	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
  002a1	e9 64 01 00 00	 jmp	 $LN3@stb_decomp
$LN12@stb_decomp:

; 3232 :         else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);

  002a6	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  002a9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002ac	83 f9 07	 cmp	 ecx, 7
  002af	75 63		 jne	 SHORT $LN14@stb_decomp
  002b1	b8 01 00 00 00	 mov	 eax, 1
  002b6	c1 e0 00	 shl	 eax, 0
  002b9	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  002bc	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002c0	c1 e2 08	 shl	 edx, 8
  002c3	b8 01 00 00 00	 mov	 eax, 1
  002c8	d1 e0		 shl	 eax, 1
  002ca	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  002cd	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  002d1	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  002d5	51		 push	 ecx
  002d6	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  002d9	83 c2 03	 add	 edx, 3
  002dc	52		 push	 edx
  002dd	e8 00 00 00 00	 call	 ?stb__lit@@YAXPBEI@Z	; stb__lit
  002e2	83 c4 08	 add	 esp, 8
  002e5	b8 01 00 00 00	 mov	 eax, 1
  002ea	c1 e0 00	 shl	 eax, 0
  002ed	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  002f0	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002f4	c1 e2 08	 shl	 edx, 8
  002f7	b8 01 00 00 00	 mov	 eax, 1
  002fc	d1 e0		 shl	 eax, 1
  002fe	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00301	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00305	03 45 08	 add	 eax, DWORD PTR _i$[ebp]
  00308	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0030c	89 4d 08	 mov	 DWORD PTR _i$[ebp], ecx
  0030f	e9 f6 00 00 00	 jmp	 $LN3@stb_decomp
$LN14@stb_decomp:

; 3233 :         else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;

  00314	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00317	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0031a	83 f9 06	 cmp	 ecx, 6
  0031d	75 69		 jne	 SHORT $LN16@stb_decomp
  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	c1 e0 02	 shl	 eax, 2
  00327	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0032a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0032e	83 c2 01	 add	 edx, 1
  00331	52		 push	 edx
  00332	b8 01 00 00 00	 mov	 eax, 1
  00337	c1 e0 00	 shl	 eax, 0
  0033a	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0033d	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00341	c1 e2 10	 shl	 edx, 16			; 00000010H
  00344	b8 01 00 00 00	 mov	 eax, 1
  00349	d1 e0		 shl	 eax, 1
  0034b	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0034e	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00352	c1 e0 08	 shl	 eax, 8
  00355	b9 01 00 00 00	 mov	 ecx, 1
  0035a	6b c9 03	 imul	 ecx, ecx, 3
  0035d	8b 75 08	 mov	 esi, DWORD PTR _i$[ebp]
  00360	0f b6 0c 0e	 movzx	 ecx, BYTE PTR [esi+ecx]
  00364	03 c1		 add	 eax, ecx
  00366	8d 54 02 01	 lea	 edx, DWORD PTR [edx+eax+1]
  0036a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  0036f	2b c2		 sub	 eax, edx
  00371	50		 push	 eax
  00372	e8 00 00 00 00	 call	 ?stb__match@@YAXPBEI@Z	; stb__match
  00377	83 c4 08	 add	 esp, 8
  0037a	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0037d	83 c1 05	 add	 ecx, 5
  00380	89 4d 08	 mov	 DWORD PTR _i$[ebp], ecx
  00383	e9 82 00 00 00	 jmp	 $LN3@stb_decomp
$LN16@stb_decomp:

; 3234 :         else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;

  00388	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0038b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0038e	83 f9 04	 cmp	 ecx, 4
  00391	75 77		 jne	 SHORT $LN3@stb_decomp
  00393	b8 01 00 00 00	 mov	 eax, 1
  00398	c1 e0 02	 shl	 eax, 2
  0039b	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  0039e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003a2	c1 e2 08	 shl	 edx, 8
  003a5	b8 01 00 00 00	 mov	 eax, 1
  003aa	6b c8 05	 imul	 ecx, eax, 5
  003ad	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  003b0	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  003b4	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  003b8	52		 push	 edx
  003b9	b8 01 00 00 00	 mov	 eax, 1
  003be	c1 e0 00	 shl	 eax, 0
  003c1	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  003c4	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003c8	c1 e2 10	 shl	 edx, 16			; 00000010H
  003cb	b8 01 00 00 00	 mov	 eax, 1
  003d0	d1 e0		 shl	 eax, 1
  003d2	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  003d5	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  003d9	c1 e0 08	 shl	 eax, 8
  003dc	b9 01 00 00 00	 mov	 ecx, 1
  003e1	6b c9 03	 imul	 ecx, ecx, 3
  003e4	8b 75 08	 mov	 esi, DWORD PTR _i$[ebp]
  003e7	0f b6 0c 0e	 movzx	 ecx, BYTE PTR [esi+ecx]
  003eb	03 c1		 add	 eax, ecx
  003ed	8d 54 02 01	 lea	 edx, DWORD PTR [edx+eax+1]
  003f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  003f6	2b c2		 sub	 eax, edx
  003f8	50		 push	 eax
  003f9	e8 00 00 00 00	 call	 ?stb__match@@YAXPBEI@Z	; stb__match
  003fe	83 c4 08	 add	 esp, 8
  00401	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00404	83 c1 06	 add	 ecx, 6
  00407	89 4d 08	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@stb_decomp:

; 3235 :     }
; 3236 :     return i;

  0040a	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]

; 3237 : }

  0040d	5f		 pop	 edi
  0040e	5e		 pop	 esi
  0040f	5b		 pop	 ebx
  00410	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00416	3b ec		 cmp	 ebp, esp
  00418	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0041d	8b e5		 mov	 esp, ebp
  0041f	5d		 pop	 ebp
  00420	c3		 ret	 0
?stb_decompress_token@@YAPBEPBE@Z ENDP			; stb_decompress_token
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?stb__lit@@YAXPBEI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_length$ = 12						; size = 4
?stb__lit@@YAXPBEI@Z PROC				; stb__lit, COMDAT

; 3210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3211 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  0002d	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00030	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?stb__barrier_out_e@@3PAEA
  00036	76 26		 jbe	 SHORT $LN5@stb__lit
  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stb__lit@@YAXPBEI@Z@4JA
  0003e	83 c1 01	 add	 ecx, 1
  00041	8b f4		 mov	 esi, esp
  00043	51		 push	 ecx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@stb__lit:

; 3212 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  00063	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00066	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?stb__barrier_out_e@@3PAEA
  0006c	76 0f		 jbe	 SHORT $LN2@stb__lit
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  00073	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00076	a3 00 00 00 00	 mov	 DWORD PTR ?stb__dout@@3PAEA, eax
  0007b	eb 3e		 jmp	 SHORT $LN1@stb__lit
$LN2@stb__lit:

; 3213 :     if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }

  0007d	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00080	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?stb__barrier_in_b@@3PBEB
  00086	73 0f		 jae	 SHORT $LN3@stb__lit
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__barrier_out_e@@3PAEA
  0008d	83 c0 01	 add	 eax, 1
  00090	a3 00 00 00 00	 mov	 DWORD PTR ?stb__dout@@3PAEA, eax
  00095	eb 24		 jmp	 SHORT $LN1@stb__lit
$LN3@stb__lit:

; 3214 :     memcpy(stb__dout, data, length);

  00097	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0009e	51		 push	 ecx
  0009f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?stb__dout@@3PAEA
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _memcpy
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3215 :     stb__dout += length;

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  000b3	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  000b6	a3 00 00 00 00	 mov	 DWORD PTR ?stb__dout@@3PAEA, eax
$LN1@stb__lit:

; 3216 : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c4	3b ec		 cmp	 ebp, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?stb__lit@@YAXPBEI@Z ENDP				; stb__lit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?stb__match@@YAXPBEI@Z
_TEXT	SEGMENT
tv77 = -196						; size = 4
_data$ = 8						; size = 4
_length$ = 12						; size = 4
?stb__match@@YAXPBEI@Z PROC				; stb__match, COMDAT

; 3201 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3202 :     // INVERSE of memmove... write each byte before copying the next...
; 3203 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  0002d	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00030	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?stb__barrier_out_e@@3PAEA
  00036	76 26		 jbe	 SHORT $LN7@stb__match
  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stb__match@@YAXPBEI@Z@4JA
  0003e	83 c1 02	 add	 ecx, 2
  00041	8b f4		 mov	 esi, esp
  00043	51		 push	 ecx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@stb__match:

; 3204 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  00063	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00066	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?stb__barrier_out_e@@3PAEA
  0006c	76 0f		 jbe	 SHORT $LN4@stb__match
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  00073	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00076	a3 00 00 00 00	 mov	 DWORD PTR ?stb__dout@@3PAEA, eax
  0007b	eb 59		 jmp	 SHORT $LN1@stb__match
$LN4@stb__match:

; 3205 :     if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }

  0007d	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00080	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?stb__barrier_out_b@@3PAEA
  00086	73 0f		 jae	 SHORT $LN2@stb__match
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__barrier_out_e@@3PAEA
  0008d	83 c0 01	 add	 eax, 1
  00090	a3 00 00 00 00	 mov	 DWORD PTR ?stb__dout@@3PAEA, eax
  00095	eb 3f		 jmp	 SHORT $LN1@stb__match
$LN2@stb__match:

; 3206 :     while (length--) *stb__dout++ = *data++;

  00097	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0009a	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  000a3	83 e9 01	 sub	 ecx, 1
  000a6	89 4d 0c	 mov	 DWORD PTR _length$[ebp], ecx
  000a9	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv77[ebp], 0
  000b0	74 24		 je	 SHORT $LN1@stb__match
  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000ba	8a 11		 mov	 dl, BYTE PTR [ecx]
  000bc	88 10		 mov	 BYTE PTR [eax], dl
  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stb__dout@@3PAEA
  000c3	83 c0 01	 add	 eax, 1
  000c6	a3 00 00 00 00	 mov	 DWORD PTR ?stb__dout@@3PAEA, eax
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  000ce	83 c1 01	 add	 ecx, 1
  000d1	89 4d 08	 mov	 DWORD PTR _data$[ebp], ecx
  000d4	eb c1		 jmp	 SHORT $LN2@stb__match
$LN1@stb__match:

; 3207 : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000df	3b ec		 cmp	 ebp, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?stb__match@@YAXPBEI@Z ENDP				; stb__match
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@M@@YAMMMM@Z
_TEXT	SEGMENT
tv72 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_t$ = 16						; size = 4
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  0002d	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _a$[ebp]
  00032	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _t$[ebp]
  00037	f3 0f 58 45 08	 addss	 xmm0, DWORD PTR _a$[ebp]
  0003c	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv72[ebp], xmm0
  00044	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@M@@YAXAAM0@Z
_TEXT	SEGMENT
_tmp$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$ImSwap@M@@YAXAAM0@Z PROC				; ImSwap<float>, COMDAT

; 318  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	f3 0f 11 45 f8	 movss	 DWORD PTR _tmp$[ebp], xmm0
  00034	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	89 10		 mov	 DWORD PTR [eax], edx
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00041	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _tmp$[ebp]
  00046	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImSwap@M@@YAXAAM0@Z ENDP				; ImSwap<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImAcos01@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImAcos01@@YAMM@Z PROC					; ImAcos01, COMDAT

; 3115 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3116 :     if (x <= 0.0f) return IM_PI * 0.5f;

  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _x$[ebp]
  0002f	72 08		 jb	 SHORT $LN2@ImAcos01
  00031	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@3fc90fdb
  00037	eb 25		 jmp	 SHORT $LN1@ImAcos01
$LN2@ImAcos01:

; 3117 :     if (x >= 1.0f) return 0.0f;

  00039	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0003e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00045	72 04		 jb	 SHORT $LN3@ImAcos01
  00047	d9 ee		 fldz
  00049	eb 13		 jmp	 SHORT $LN1@ImAcos01
$LN3@ImAcos01:

; 3118 :     return ImAcos(x);

  0004b	51		 push	 ecx
  0004c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	e8 00 00 00 00	 call	 ?ImAcos@@YAMM@Z		; ImAcos
  0005b	83 c4 04	 add	 esp, 4
$LN1@ImAcos01:

; 3119 :     //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
; 3120 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?ImAcos01@@YAMM@Z ENDP					; ImAcos01
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?UnpackAccumulativeOffsetsIntoRanges@@YAXHPBFHPAG@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_n$1 = -8						; size = 4
_base_codepoint$ = 8					; size = 4
_accumulative_offsets$ = 12				; size = 4
_accumulative_offsets_count$ = 16			; size = 4
_out_ranges$ = 20					; size = 4
?UnpackAccumulativeOffsetsIntoRanges@@YAXHPBFHPAG@Z PROC ; UnpackAccumulativeOffsetsIntoRanges, COMDAT

; 2302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2303 :     for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0002f	eb 12		 jmp	 SHORT $LN4@UnpackAccu
$LN2@UnpackAccu:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
  0003a	8b 4d 14	 mov	 ecx, DWORD PTR _out_ranges$[ebp]
  0003d	83 c1 04	 add	 ecx, 4
  00040	89 4d 14	 mov	 DWORD PTR _out_ranges$[ebp], ecx
$LN4@UnpackAccu:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00046	3b 45 10	 cmp	 eax, DWORD PTR _accumulative_offsets_count$[ebp]
  00049	7d 53		 jge	 SHORT $LN3@UnpackAccu

; 2304 :     {
; 2305 :         out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _accumulative_offsets$[ebp]
  00051	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00055	8b 45 08	 mov	 eax, DWORD PTR _base_codepoint$[ebp]
  00058	03 c2		 add	 eax, edx
  0005a	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  00060	b9 02 00 00 00	 mov	 ecx, 2
  00065	c1 e1 00	 shl	 ecx, 0
  00068	8b 55 14	 mov	 edx, DWORD PTR _out_ranges$[ebp]
  0006b	66 8b 85 30 ff
	ff ff		 mov	 ax, WORD PTR tv74[ebp]
  00072	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00076	b9 02 00 00 00	 mov	 ecx, 2
  0007b	6b d1 00	 imul	 edx, ecx, 0
  0007e	8b 45 14	 mov	 eax, DWORD PTR _out_ranges$[ebp]
  00081	66 8b 8d 30 ff
	ff ff		 mov	 cx, WORD PTR tv74[ebp]
  00088	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 2306 :         base_codepoint += accumulative_offsets[n];

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _accumulative_offsets$[ebp]
  00092	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00096	03 55 08	 add	 edx, DWORD PTR _base_codepoint$[ebp]
  00099	89 55 08	 mov	 DWORD PTR _base_codepoint$[ebp], edx

; 2307 :     }

  0009c	eb 93		 jmp	 SHORT $LN2@UnpackAccu
$LN3@UnpackAccu:

; 2308 :     out_ranges[0] = 0;

  0009e	b8 02 00 00 00	 mov	 eax, 2
  000a3	6b c8 00	 imul	 ecx, eax, 0
  000a6	33 d2		 xor	 edx, edx
  000a8	8b 45 14	 mov	 eax, DWORD PTR _out_ranges$[ebp]
  000ab	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx

; 2309 : }

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
?UnpackAccumulativeOffsetsIntoRanges@@YAXHPBFHPAG@Z ENDP ; UnpackAccumulativeOffsetsIntoRanges
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z
_TEXT	SEGMENT
tv181 = -308						; size = 4
tv172 = -308						; size = 4
$T1 = -300						; size = 8
_offset$2 = -92						; size = 4
_offset1$3 = -80					; size = 4
_offset0$4 = -68					; size = 4
_x$5 = -56						; size = 4
_n$6 = -44						; size = 4
_y$7 = -32						; size = 4
_w$ = -20						; size = 4
_r$ = -8						; size = 4
_atlas$ = 8						; size = 4
?ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRenderDefaultTexData, COMDAT

; 2192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-308]
  00012	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2193 :     IM_ASSERT(atlas->CustomRectIds[0] >= 0);

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00033	83 7c 0a 58 00	 cmp	 DWORD PTR [edx+ecx+88], 0
  00038	7d 25		 jge	 SHORT $LN11@ImFontAtla
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA
  0003f	83 c0 01	 add	 eax, 1
  00042	8b f4		 mov	 esi, esp
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@CIPOCJML@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@ImFontAtla:

; 2194 :     IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00062	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00066	75 26		 jne	 SHORT $LN12@ImFontAtla
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA
  0006e	83 c1 02	 add	 ecx, 2
  00071	8b f4		 mov	 esi, esp
  00073	51		 push	 ecx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1DI@LKIOFBD@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	3b f4		 cmp	 esi, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@ImFontAtla:

; 2195 :     ImFontAtlasCustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];

  0008e	b8 04 00 00 00	 mov	 eax, 4
  00093	6b c8 00	 imul	 ecx, eax, 0
  00096	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00099	8b 44 0a 58	 mov	 eax, DWORD PTR [edx+ecx+88]
  0009d	50		 push	 eax
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  000a1	83 c1 40	 add	 ecx, 64			; 00000040H
  000a4	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  000a9	89 45 f8	 mov	 DWORD PTR _r$[ebp], eax

; 2196 :     IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  000af	81 38 00 00 00
	80		 cmp	 DWORD PTR [eax], -2147483648 ; 80000000H
  000b5	74 26		 je	 SHORT $LN13@ImFontAtla
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA
  000bd	83 c1 04	 add	 ecx, 4
  000c0	8b f4		 mov	 esi, esp
  000c2	51		 push	 ecx
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@NGCKHELE@?$AAr?$AA?4?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT?$AA_?$AAA?$AAT@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	3b f4		 cmp	 esi, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@ImFontAtla:

; 2197 :     IM_ASSERT(r.IsPacked());

  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _r$[ebp]
  000e0	e8 00 00 00 00	 call	 ?IsPacked@ImFontAtlasCustomRect@@QBE_NXZ ; ImFontAtlasCustomRect::IsPacked
  000e5	0f b6 c0	 movzx	 eax, al
  000e8	85 c0		 test	 eax, eax
  000ea	75 26		 jne	 SHORT $LN14@ImFontAtla
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA
  000f2	83 c1 05	 add	 ecx, 5
  000f5	8b f4		 mov	 esi, esp
  000f7	51		 push	 ecx
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MDHNDFCJ@?$AAr?$AA?4?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	3b f4		 cmp	 esi, esp
  0010d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@ImFontAtla:

; 2198 : 
; 2199 :     const int w = atlas->TexWidth;

  00112	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00115	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00118	89 4d ec	 mov	 DWORD PTR _w$[ebp], ecx

; 2200 :     if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

  0011b	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0011e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00121	83 e1 02	 and	 ecx, 2
  00124	0f 85 2c 01 00
	00		 jne	 $LN8@ImFontAtla

; 2201 :     {
; 2202 :         // Render/copy pixels
; 2203 :         IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);

  0012a	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  0012d	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00131	81 f9 d9 00 00
	00		 cmp	 ecx, 217		; 000000d9H
  00137	75 0c		 jne	 SHORT $LN15@ImFontAtla
  00139	8b 55 f8	 mov	 edx, DWORD PTR _r$[ebp]
  0013c	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00140	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  00143	74 26		 je	 SHORT $LN16@ImFontAtla
$LN15@ImFontAtla:
  00145	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA
  0014b	83 c1 0b	 add	 ecx, 11			; 0000000bH
  0014e	8b f4		 mov	 esi, esp
  00150	51		 push	 ecx
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@KMJKJDJG@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT@
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
  00164	3b f4		 cmp	 esi, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@ImFontAtla:

; 2204 :         for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)

  0016b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _y$7[ebp], 0
  00172	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _n$6[ebp], 0
  00179	eb 09		 jmp	 SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
  0017b	8b 45 e0	 mov	 eax, DWORD PTR _y$7[ebp]
  0017e	83 c0 01	 add	 eax, 1
  00181	89 45 e0	 mov	 DWORD PTR _y$7[ebp], eax
$LN4@ImFontAtla:
  00184	83 7d e0 1b	 cmp	 DWORD PTR _y$7[ebp], 27	; 0000001bH
  00188	0f 8d c3 00 00
	00		 jge	 $LN3@ImFontAtla

; 2205 :             for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)

  0018e	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00195	eb 12		 jmp	 SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
  00197	8b 45 c8	 mov	 eax, DWORD PTR _x$5[ebp]
  0019a	83 c0 01	 add	 eax, 1
  0019d	89 45 c8	 mov	 DWORD PTR _x$5[ebp], eax
  001a0	8b 4d d4	 mov	 ecx, DWORD PTR _n$6[ebp]
  001a3	83 c1 01	 add	 ecx, 1
  001a6	89 4d d4	 mov	 DWORD PTR _n$6[ebp], ecx
$LN7@ImFontAtla:
  001a9	83 7d c8 6c	 cmp	 DWORD PTR _x$5[ebp], 108 ; 0000006cH
  001ad	0f 8d 99 00 00
	00		 jge	 $LN6@ImFontAtla

; 2206 :             {
; 2207 :                 const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;

  001b3	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  001b6	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  001ba	03 4d c8	 add	 ecx, DWORD PTR _x$5[ebp]
  001bd	8b 55 f8	 mov	 edx, DWORD PTR _r$[ebp]
  001c0	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  001c4	03 45 e0	 add	 eax, DWORD PTR _y$7[ebp]
  001c7	0f af 45 ec	 imul	 eax, DWORD PTR _w$[ebp]
  001cb	03 c8		 add	 ecx, eax
  001cd	89 4d bc	 mov	 DWORD PTR _offset0$4[ebp], ecx

; 2208 :                 const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;

  001d0	8b 45 bc	 mov	 eax, DWORD PTR _offset0$4[ebp]
  001d3	83 c0 6d	 add	 eax, 109		; 0000006dH
  001d6	89 45 b0	 mov	 DWORD PTR _offset1$3[ebp], eax

; 2209 :                 atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;

  001d9	8b 45 d4	 mov	 eax, DWORD PTR _n$6[ebp]
  001dc	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB[eax]
  001e3	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  001e6	75 0c		 jne	 SHORT $LN17@ImFontAtla
  001e8	c7 85 cc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv172[ebp], 255 ; 000000ffH
  001f2	eb 0a		 jmp	 SHORT $LN18@ImFontAtla
$LN17@ImFontAtla:
  001f4	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
$LN18@ImFontAtla:
  001fe	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00201	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00204	8b 4d bc	 mov	 ecx, DWORD PTR _offset0$4[ebp]
  00207	8a 95 cc fe ff
	ff		 mov	 dl, BYTE PTR tv172[ebp]
  0020d	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2210 :                 atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;

  00210	8b 45 d4	 mov	 eax, DWORD PTR _n$6[ebp]
  00213	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB[eax]
  0021a	83 f9 58	 cmp	 ecx, 88			; 00000058H
  0021d	75 0c		 jne	 SHORT $LN19@ImFontAtla
  0021f	c7 85 cc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv181[ebp], 255 ; 000000ffH
  00229	eb 0a		 jmp	 SHORT $LN20@ImFontAtla
$LN19@ImFontAtla:
  0022b	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv181[ebp], 0
$LN20@ImFontAtla:
  00235	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00238	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0023b	8b 4d b0	 mov	 ecx, DWORD PTR _offset1$3[ebp]
  0023e	8a 95 cc fe ff
	ff		 mov	 dl, BYTE PTR tv181[ebp]
  00244	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2211 :             }

  00247	e9 4b ff ff ff	 jmp	 $LN5@ImFontAtla
$LN6@ImFontAtla:
  0024c	e9 2a ff ff ff	 jmp	 $LN2@ImFontAtla
$LN3@ImFontAtla:

; 2212 :     }

  00251	e9 91 00 00 00	 jmp	 $LN9@ImFontAtla
$LN8@ImFontAtla:

; 2213 :     else
; 2214 :     {
; 2215 :         IM_ASSERT(r.Width == 2 && r.Height == 2);

  00256	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  00259	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0025d	83 f9 02	 cmp	 ecx, 2
  00260	75 0c		 jne	 SHORT $LN21@ImFontAtla
  00262	8b 55 f8	 mov	 edx, DWORD PTR _r$[ebp]
  00265	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00269	83 f8 02	 cmp	 eax, 2
  0026c	74 26		 je	 SHORT $LN22@ImFontAtla
$LN21@ImFontAtla:
  0026e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z@4JA
  00274	83 c1 17	 add	 ecx, 23			; 00000017H
  00277	8b f4		 mov	 esi, esp
  00279	51		 push	 ecx
  0027a	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0027f	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@OOPIKMMI@?$AAr?$AA?4?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG?$AA?$CG@
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028d	3b f4		 cmp	 esi, esp
  0028f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN22@ImFontAtla:

; 2216 :         const int offset = (int)(r.X) + (int)(r.Y) * w;

  00294	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  00297	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  0029b	8b 55 f8	 mov	 edx, DWORD PTR _r$[ebp]
  0029e	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  002a2	0f af 45 ec	 imul	 eax, DWORD PTR _w$[ebp]
  002a6	03 c8		 add	 ecx, eax
  002a8	89 4d a4	 mov	 DWORD PTR _offset$2[ebp], ecx

; 2217 :         atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;

  002ab	8b 45 a4	 mov	 eax, DWORD PTR _offset$2[ebp]
  002ae	03 45 ec	 add	 eax, DWORD PTR _w$[ebp]
  002b1	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  002b4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  002b7	c6 44 02 01 ff	 mov	 BYTE PTR [edx+eax+1], 255 ; 000000ffH
  002bc	8b 45 a4	 mov	 eax, DWORD PTR _offset$2[ebp]
  002bf	03 45 ec	 add	 eax, DWORD PTR _w$[ebp]
  002c2	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  002c5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  002c8	c6 04 02 ff	 mov	 BYTE PTR [edx+eax], 255	; 000000ffH
  002cc	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  002cf	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002d2	8b 55 a4	 mov	 edx, DWORD PTR _offset$2[ebp]
  002d5	c6 44 11 01 ff	 mov	 BYTE PTR [ecx+edx+1], 255 ; 000000ffH
  002da	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  002dd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002e0	8b 55 a4	 mov	 edx, DWORD PTR _offset$2[ebp]
  002e3	c6 04 11 ff	 mov	 BYTE PTR [ecx+edx], 255	; 000000ffH
$LN9@ImFontAtla:

; 2218 :     }
; 2219 :     atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);

  002e7	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  002ea	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  002ee	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  002f2	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  002fa	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  002fd	f3 0f 59 42 28	 mulss	 xmm0, DWORD PTR [edx+40]
  00302	51		 push	 ecx
  00303	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00308	8b 45 f8	 mov	 eax, DWORD PTR _r$[ebp]
  0030b	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  0030f	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00313	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0031b	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  0031e	f3 0f 59 42 24	 mulss	 xmm0, DWORD PTR [edx+36]
  00323	51		 push	 ecx
  00324	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00329	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0032f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00334	8b 08		 mov	 ecx, DWORD PTR [eax]
  00336	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00339	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0033c	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  0033f	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 2220 : }

  00342	5f		 pop	 edi
  00343	5e		 pop	 esi
  00344	5b		 pop	 ebx
  00345	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  0034b	3b ec		 cmp	 ebp, esp
  0034d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00352	8b e5		 mov	 esp, ebp
  00354	5d		 pop	 ebp
  00355	c3		 ret	 0
?ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRenderDefaultTexData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z PROC	; ImVector<stbtt_packedchar>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 1c	 imul	 eax, DWORD PTR _new_capacity$[ebp], 28
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z ENDP	; ImVector<stbtt_packedchar>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z PROC	; ImVector<stbtt_packedchar>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QBEHH@Z ; ImVector<stbtt_packedchar>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z ; ImVector<stbtt_packedchar>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z ENDP	; ImVector<stbtt_packedchar>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QBEHH@Z PROC ; ImVector<stbtt_packedchar>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QBEHH@Z ENDP ; ImVector<stbtt_packedchar>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbtt_packedchar@@@@QAEAAUstbtt_packedchar@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@Ustbtt_packedchar@@@@QAEAAUstbtt_packedchar@@H@Z PROC ; ImVector<stbtt_packedchar>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@Ustbtt_packedchar@@@@QAEAAUstbtt_packedchar@@H@Z ENDP ; ImVector<stbtt_packedchar>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QBEHXZ PROC ; ImVector<stbtt_packedchar>::size_in_bytes, COMDAT
; _this$ = ecx

; 1270 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	6b 00 1c	 imul	 eax, DWORD PTR [eax], 28
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QBEHXZ ENDP ; ImVector<stbtt_packedchar>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ PROC		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ ENDP		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbtt_packedchar@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@Ustbtt_packedchar@@@@QAE@XZ PROC		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@Ustbtt_packedchar@@@@QAE@XZ ENDP		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z PROC		; ImVector<stbrp_rect>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 04	 shl	 eax, 4
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 04	 shl	 ecx, 4
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z ENDP		; ImVector<stbrp_rect>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbrp_rect@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@Ustbrp_rect@@@@QAEXH@Z PROC		; ImVector<stbrp_rect>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QBEHH@Z ; ImVector<stbrp_rect>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z ; ImVector<stbrp_rect>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@Ustbrp_rect@@@@QAEXH@Z ENDP		; ImVector<stbrp_rect>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QBEHH@Z PROC	; ImVector<stbrp_rect>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QBEHH@Z ENDP	; ImVector<stbrp_rect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@Ustbrp_rect@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@Ustbrp_rect@@@@QAEXXZ PROC		; ImVector<stbrp_rect>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@Ustbrp_rect@@@@QAEXXZ ENDP		; ImVector<stbrp_rect>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z PROC	; ImVector<stbrp_rect>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0005b	c1 e0 04	 shl	 eax, 4
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ENDP	; ImVector<stbrp_rect>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QBEHXZ PROC	; ImVector<stbrp_rect>::size_in_bytes, COMDAT
; _this$ = ecx

; 1270 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	c1 e0 04	 shl	 eax, 4
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QBEHXZ ENDP	; ImVector<stbrp_rect>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbrp_rect@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@Ustbrp_rect@@@@QAE@XZ PROC		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@Ustbrp_rect@@@@QAE@XZ ENDP		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbrp_rect@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@Ustbrp_rect@@@@QAE@XZ PROC		; ImVector<stbrp_rect>::ImVector<stbrp_rect>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@Ustbrp_rect@@@@QAE@XZ ENDP		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@H@@YAHHH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMax@H@@YAHHH@Z PROC				; ImMax<int>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR _rhs$[ebp]
  0002e	7c 0b		 jl	 SHORT $LN3@ImMax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00033	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00039	eb 09		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _rhs$[ebp]
  0003e	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
$LN4@ImMax:
  00044	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$ImMax@H@@YAHHH@Z ENDP				; ImMax<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z PROC	; ImVector<ImFontBuildDstData>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 18	 imul	 eax, DWORD PTR _new_capacity$[ebp], 24
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 18	 imul	 ecx, DWORD PTR [eax], 24
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z ENDP	; ImVector<ImFontBuildDstData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z PROC	; ImVector<ImFontBuildDstData>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QBEHH@Z ; ImVector<ImFontBuildDstData>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z ; ImVector<ImFontBuildDstData>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z ENDP	; ImVector<ImFontBuildDstData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QBEHH@Z PROC ; ImVector<ImFontBuildDstData>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QBEHH@Z ENDP ; ImVector<ImFontBuildDstData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontBuildDstData@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImFontBuildDstData@@@@QAEXXZ PROC	; ImVector<ImFontBuildDstData>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImFontBuildDstData@@@@QAEXXZ ENDP	; ImVector<ImFontBuildDstData>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildDstData@@@@QAEAAUImFontBuildDstData@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImFontBuildDstData@@@@QAEAAUImFontBuildDstData@@H@Z PROC ; ImVector<ImFontBuildDstData>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImFontBuildDstData@@@@QAEAAUImFontBuildDstData@@H@Z ENDP ; ImVector<ImFontBuildDstData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QBEHXZ PROC ; ImVector<ImFontBuildDstData>::size_in_bytes, COMDAT
; _this$ = ecx

; 1270 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	6b 00 18	 imul	 eax, DWORD PTR [eax], 24
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QBEHXZ ENDP ; ImVector<ImFontBuildDstData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ PROC	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ ENDP	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildDstData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImFontBuildDstData@@@@QAE@XZ PROC	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImFontBuildDstData@@@@QAE@XZ ENDP	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z PROC	; ImVector<ImFontBuildSrcData>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 5a		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	69 45 08 c4 00
	00 00		 imul	 eax, DWORD PTR _new_capacity$[ebp], 196
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00047	83 c4 04	 add	 esp, 4
  0004a	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00054	74 2c		 je	 SHORT $LN3@reserve
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	69 08 c4 00 00
	00		 imul	 ecx, DWORD PTR [eax], 196
  0005f	51		 push	 ecx
  00060	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00063	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00066	50		 push	 eax
  00067	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _memcpy
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007f	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009d	3b ec		 cmp	 ebp, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?reserve@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z ENDP	; ImVector<ImFontBuildSrcData>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z PROC	; ImVector<ImFontBuildSrcData>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QBEHH@Z ; ImVector<ImFontBuildSrcData>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z ; ImVector<ImFontBuildSrcData>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z ENDP	; ImVector<ImFontBuildSrcData>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QBEHH@Z PROC ; ImVector<ImFontBuildSrcData>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QBEHH@Z ENDP ; ImVector<ImFontBuildSrcData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z PROC ; ImVector<ImFontBuildSrcData>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	69 45 08 c4 00
	00 00		 imul	 eax, DWORD PTR _i$[ebp], 196
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ENDP ; ImVector<ImFontBuildSrcData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QBEHXZ PROC ; ImVector<ImFontBuildSrcData>::size_in_bytes, COMDAT
; _this$ = ecx

; 1270 :     inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	69 00 c4 00 00
	00		 imul	 eax, DWORD PTR [eax], 196
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QBEHXZ ENDP ; ImVector<ImFontBuildSrcData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ PROC	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ ENDP	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildSrcData@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImFontBuildSrcData@@@@QAE@XZ PROC	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImFontBuildSrcData@@@@QAE@XZ ENDP	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?UnpackBoolVectorToFlatIndexList@@YAXPBUImBoolVector@@PAU?$ImVector@H@@@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_bit_n$2 = -56						; size = 4
_entries_32$3 = -44					; size = 4
_it$4 = -32						; size = 4
_it_end$ = -20						; size = 4
_it_begin$ = -8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?UnpackBoolVectorToFlatIndexList@@YAXPBUImBoolVector@@PAU?$ImVector@H@@@Z PROC ; UnpackBoolVectorToFlatIndexList, COMDAT

; 1873 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1874 :     IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
; 1875 :     const int* it_begin = in->Storage.begin();

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  0002b	e8 00 00 00 00	 call	 ?begin@?$ImVector@H@@QBEPBHXZ ; ImVector<int>::begin
  00030	89 45 f8	 mov	 DWORD PTR _it_begin$[ebp], eax

; 1876 :     const int* it_end = in->Storage.end();

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  00036	e8 00 00 00 00	 call	 ?end@?$ImVector@H@@QBEPBHXZ ; ImVector<int>::end
  0003b	89 45 ec	 mov	 DWORD PTR _it_end$[ebp], eax

; 1877 :     for (const int* it = it_begin; it < it_end; it++)

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _it_begin$[ebp]
  00041	89 45 e0	 mov	 DWORD PTR _it$4[ebp], eax
  00044	eb 09		 jmp	 SHORT $LN4@UnpackBool
$LN2@UnpackBool:
  00046	8b 45 e0	 mov	 eax, DWORD PTR _it$4[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 e0	 mov	 DWORD PTR _it$4[ebp], eax
$LN4@UnpackBool:
  0004f	8b 45 e0	 mov	 eax, DWORD PTR _it$4[ebp]
  00052	3b 45 ec	 cmp	 eax, DWORD PTR _it_end$[ebp]
  00055	73 5d		 jae	 SHORT $LN1@UnpackBool

; 1878 :         if (int entries_32 = *it)

  00057	8b 45 e0	 mov	 eax, DWORD PTR _it$4[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	89 4d d4	 mov	 DWORD PTR _entries_32$3[ebp], ecx
  0005f	83 7d d4 00	 cmp	 DWORD PTR _entries_32$3[ebp], 0
  00063	74 4d		 je	 SHORT $LN8@UnpackBool

; 1879 :             for (int bit_n = 0; bit_n < 32; bit_n++)

  00065	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _bit_n$2[ebp], 0
  0006c	eb 09		 jmp	 SHORT $LN7@UnpackBool
$LN5@UnpackBool:
  0006e	8b 45 c8	 mov	 eax, DWORD PTR _bit_n$2[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 c8	 mov	 DWORD PTR _bit_n$2[ebp], eax
$LN7@UnpackBool:
  00077	83 7d c8 20	 cmp	 DWORD PTR _bit_n$2[ebp], 32 ; 00000020H
  0007b	7d 35		 jge	 SHORT $LN8@UnpackBool

; 1880 :                 if (entries_32 & (1u << bit_n))

  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	8b 4d c8	 mov	 ecx, DWORD PTR _bit_n$2[ebp]
  00085	d3 e0		 shl	 eax, cl
  00087	23 45 d4	 and	 eax, DWORD PTR _entries_32$3[ebp]
  0008a	74 24		 je	 SHORT $LN9@UnpackBool

; 1881 :                     out->push_back((int)((it - it_begin) << 5) + bit_n);

  0008c	8b 45 e0	 mov	 eax, DWORD PTR _it$4[ebp]
  0008f	2b 45 f8	 sub	 eax, DWORD PTR _it_begin$[ebp]
  00092	c1 f8 02	 sar	 eax, 2
  00095	c1 e0 05	 shl	 eax, 5
  00098	03 45 c8	 add	 eax, DWORD PTR _bit_n$2[ebp]
  0009b	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  000a1	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000a7	51		 push	 ecx
  000a8	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  000ab	e8 00 00 00 00	 call	 ?push_back@?$ImVector@H@@QAEXABH@Z ; ImVector<int>::push_back
$LN9@UnpackBool:
  000b0	eb bc		 jmp	 SHORT $LN5@UnpackBool
$LN8@UnpackBool:
  000b2	eb 92		 jmp	 SHORT $LN2@UnpackBool
$LN1@UnpackBool:

; 1882 : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?UnpackBoolVectorToFlatIndexList@@YAXPBUImBoolVector@@PAU?$ImVector@H@@@Z ENDP ; UnpackBoolVectorToFlatIndexList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GImFontBuildSrcData@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GImFontBuildSrcData@@QAEPAXI@Z PROC			; ImFontBuildSrcData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1ImFontBuildSrcData@@QAE@XZ
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 11		 je	 SHORT $LN2@scalar
  00033	68 c4 00 00 00	 push	 196			; 000000c4H
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00041	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
??_GImFontBuildSrcData@@QAEPAXI@Z ENDP			; ImFontBuildSrcData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1ImFontBuildSrcData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1ImFontBuildSrcData@@QAE@XZ PROC			; ImFontBuildSrcData::~ImFontBuildSrcData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  0002c	e8 00 00 00 00	 call	 ??1?$ImVector@H@@QAE@XZ	; ImVector<int>::~ImVector<int>
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  0003a	e8 00 00 00 00	 call	 ??1ImBoolVector@@QAE@XZ
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??1ImFontBuildSrcData@@QAE@XZ ENDP			; ImFontBuildSrcData::~ImFontBuildSrcData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?Decode85@@YAXPBEPAE@Z
_TEXT	SEGMENT
tv188 = -208						; size = 4
_tmp$1 = -8						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?Decode85@@YAXPBEPAE@Z PROC				; Decode85, COMDAT

; 1675 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@Decode85:

; 1676 :     while (*src)

  00028	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0002b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002e	85 c9		 test	 ecx, ecx
  00030	0f 84 17 01 00
	00		 je	 $LN1@Decode85

; 1677 :     {
; 1678 :         unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	6b c8 00	 imul	 ecx, eax, 0
  0003e	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00041	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?Decode85Byte@@YAID@Z	; Decode85Byte
  0004b	83 c4 04	 add	 esp, 4
  0004e	8b f0		 mov	 esi, eax
  00050	b9 01 00 00 00	 mov	 ecx, 1
  00055	c1 e1 00	 shl	 ecx, 0
  00058	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0005b	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?Decode85Byte@@YAID@Z	; Decode85Byte
  00065	83 c4 04	 add	 esp, 4
  00068	8b f8		 mov	 edi, eax
  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	d1 e1		 shl	 ecx, 1
  00071	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00074	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?Decode85Byte@@YAID@Z	; Decode85Byte
  0007e	83 c4 04	 add	 esp, 4
  00081	8b d8		 mov	 ebx, eax
  00083	b9 01 00 00 00	 mov	 ecx, 1
  00088	6b d1 03	 imul	 edx, ecx, 3
  0008b	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0008e	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?Decode85Byte@@YAID@Z	; Decode85Byte
  00098	83 c4 04	 add	 esp, 4
  0009b	ba 01 00 00 00	 mov	 edx, 1
  000a0	c1 e2 02	 shl	 edx, 2
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  000a6	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  000aa	52		 push	 edx
  000ab	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv188[ebp], eax
  000b1	e8 00 00 00 00	 call	 ?Decode85Byte@@YAID@Z	; Decode85Byte
  000b6	83 c4 04	 add	 esp, 4
  000b9	6b c0 55	 imul	 eax, eax, 85
  000bc	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv188[ebp]
  000c2	03 c8		 add	 ecx, eax
  000c4	6b c9 55	 imul	 ecx, ecx, 85
  000c7	03 d9		 add	 ebx, ecx
  000c9	6b d3 55	 imul	 edx, ebx, 85
  000cc	03 fa		 add	 edi, edx
  000ce	6b c7 55	 imul	 eax, edi, 85
  000d1	03 f0		 add	 esi, eax
  000d3	89 75 f8	 mov	 DWORD PTR _tmp$1[ebp], esi

; 1679 :         dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _tmp$1[ebp]
  000d9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000de	b9 01 00 00 00	 mov	 ecx, 1
  000e3	6b d1 00	 imul	 edx, ecx, 0
  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _dst$[ebp]
  000e9	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  000ec	8b 45 f8	 mov	 eax, DWORD PTR _tmp$1[ebp]
  000ef	c1 e8 08	 shr	 eax, 8
  000f2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f7	b9 01 00 00 00	 mov	 ecx, 1
  000fc	c1 e1 00	 shl	 ecx, 0
  000ff	8b 55 0c	 mov	 edx, DWORD PTR _dst$[ebp]
  00102	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00105	8b 45 f8	 mov	 eax, DWORD PTR _tmp$1[ebp]
  00108	c1 e8 10	 shr	 eax, 16			; 00000010H
  0010b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00110	b9 01 00 00 00	 mov	 ecx, 1
  00115	d1 e1		 shl	 ecx, 1
  00117	8b 55 0c	 mov	 edx, DWORD PTR _dst$[ebp]
  0011a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0011d	8b 45 f8	 mov	 eax, DWORD PTR _tmp$1[ebp]
  00120	c1 e8 18	 shr	 eax, 24			; 00000018H
  00123	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00128	b9 01 00 00 00	 mov	 ecx, 1
  0012d	6b d1 03	 imul	 edx, ecx, 3
  00130	8b 4d 0c	 mov	 ecx, DWORD PTR _dst$[ebp]
  00133	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 1680 :         src += 5;

  00136	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00139	83 c0 05	 add	 eax, 5
  0013c	89 45 08	 mov	 DWORD PTR _src$[ebp], eax

; 1681 :         dst += 4;

  0013f	8b 45 0c	 mov	 eax, DWORD PTR _dst$[ebp]
  00142	83 c0 04	 add	 eax, 4
  00145	89 45 0c	 mov	 DWORD PTR _dst$[ebp], eax

; 1682 :     }

  00148	e9 db fe ff ff	 jmp	 $LN2@Decode85
$LN1@Decode85:

; 1683 : }

  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00156	3b ec		 cmp	 ebp, esp
  00158	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
?Decode85@@YAXPBEPAE@Z ENDP				; Decode85
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?Decode85Byte@@YAID@Z
_TEXT	SEGMENT
tv70 = -196						; size = 4
_c$ = 8							; size = 1
?Decode85Byte@@YAID@Z PROC				; Decode85Byte, COMDAT

; 1673 : static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f be 45 08	 movsx	 eax, BYTE PTR _c$[ebp]
  0002c	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0002f	7c 0f		 jl	 SHORT $LN3@Decode85By
  00031	0f be 4d 08	 movsx	 ecx, BYTE PTR _c$[ebp]
  00035	83 e9 24	 sub	 ecx, 36			; 00000024H
  00038	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv70[ebp], ecx
  0003e	eb 0d		 jmp	 SHORT $LN4@Decode85By
$LN3@Decode85By:
  00040	0f be 55 08	 movsx	 edx, BYTE PTR _c$[ebp]
  00044	83 ea 23	 sub	 edx, 35			; 00000023H
  00047	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
$LN4@Decode85By:
  0004d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?Decode85Byte@@YAID@Z ENDP				; Decode85Byte
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetDefaultCompressedFontDataTTFBase85@@YAPBDXZ
_TEXT	SEGMENT
?GetDefaultCompressedFontDataTTFBase85@@YAPBDXZ PROC	; GetDefaultCompressedFontDataTTFBase85, COMDAT

; 3403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3404 :     return proggy_clean_ttf_compressed_data_base85;

  00028	b8 00 00 00 00	 mov	 eax, OFFSET ?proggy_clean_ttf_compressed_data_base85@@3QBDB

; 3405 : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?GetDefaultCompressedFontDataTTFBase85@@YAPBDXZ ENDP	; GetDefaultCompressedFontDataTTFBase85
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?stb_decompress@@YAIPAEPBEI@Z
_TEXT	SEGMENT
_old_i$1 = -20						; size = 4
_olen$ = -8						; size = 4
_output$ = 8						; size = 4
_i$ = 12						; size = 4
___formal$ = 16						; size = 4
?stb_decompress@@YAIPAEPBEI@Z PROC			; stb_decompress, COMDAT

; 3271 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3272 :     if (stb__in4(0) != 0x57bC0000) return 0;

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00033	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00037	c1 e0 18	 shl	 eax, 24			; 00000018H
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	c1 e1 00	 shl	 ecx, 0
  00042	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00045	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00049	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0004c	ba 01 00 00 00	 mov	 edx, 1
  00051	d1 e2		 shl	 edx, 1
  00053	8b 75 0c	 mov	 esi, DWORD PTR _i$[ebp]
  00056	0f b6 14 16	 movzx	 edx, BYTE PTR [esi+edx]
  0005a	c1 e2 08	 shl	 edx, 8
  0005d	be 01 00 00 00	 mov	 esi, 1
  00062	6b f6 03	 imul	 esi, esi, 3
  00065	8b 7d 0c	 mov	 edi, DWORD PTR _i$[ebp]
  00068	0f b6 34 37	 movzx	 esi, BYTE PTR [edi+esi]
  0006c	03 d6		 add	 edx, esi
  0006e	03 ca		 add	 ecx, edx
  00070	03 c1		 add	 eax, ecx
  00072	3d 00 00 bc 57	 cmp	 eax, 1471938560		; 57bc0000H
  00077	74 07		 je	 SHORT $LN5@stb_decomp
  00079	33 c0		 xor	 eax, eax
  0007b	e9 0a 02 00 00	 jmp	 $LN1@stb_decomp
$LN5@stb_decomp:

; 3273 :     if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	c1 e0 02	 shl	 eax, 2
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  0008b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0008f	c1 e2 18	 shl	 edx, 24			; 00000018H
  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	6b c8 05	 imul	 ecx, eax, 5
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  0009d	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  000a1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	6b c0 06	 imul	 eax, eax, 6
  000ac	8b 75 0c	 mov	 esi, DWORD PTR _i$[ebp]
  000af	0f b6 04 06	 movzx	 eax, BYTE PTR [esi+eax]
  000b3	c1 e0 08	 shl	 eax, 8
  000b6	be 01 00 00 00	 mov	 esi, 1
  000bb	6b f6 07	 imul	 esi, esi, 7
  000be	8b 7d 0c	 mov	 edi, DWORD PTR _i$[ebp]
  000c1	0f b6 34 37	 movzx	 esi, BYTE PTR [edi+esi]
  000c5	03 c6		 add	 eax, esi
  000c7	03 c8		 add	 ecx, eax
  000c9	03 d1		 add	 edx, ecx
  000cb	74 07		 je	 SHORT $LN6@stb_decomp
  000cd	33 c0		 xor	 eax, eax
  000cf	e9 b6 01 00 00	 jmp	 $LN1@stb_decomp
$LN6@stb_decomp:

; 3274 :     const unsigned int olen = stb_decompress_length(i);

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?stb_decompress_length@@YAIPBE@Z ; stb_decompress_length
  000dd	83 c4 04	 add	 esp, 4
  000e0	89 45 f8	 mov	 DWORD PTR _olen$[ebp], eax

; 3275 :     stb__barrier_in_b = i;

  000e3	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  000e6	a3 00 00 00 00	 mov	 DWORD PTR ?stb__barrier_in_b@@3PBEB, eax

; 3276 :     stb__barrier_out_e = output + olen;

  000eb	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  000ee	03 45 f8	 add	 eax, DWORD PTR _olen$[ebp]
  000f1	a3 00 00 00 00	 mov	 DWORD PTR ?stb__barrier_out_e@@3PAEA, eax

; 3277 :     stb__barrier_out_b = output;

  000f6	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  000f9	a3 00 00 00 00	 mov	 DWORD PTR ?stb__barrier_out_b@@3PAEA, eax

; 3278 :     i += 16;

  000fe	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00101	83 c0 10	 add	 eax, 16			; 00000010H
  00104	89 45 0c	 mov	 DWORD PTR _i$[ebp], eax

; 3279 : 
; 3280 :     stb__dout = output;

  00107	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  0010a	a3 00 00 00 00	 mov	 DWORD PTR ?stb__dout@@3PAEA, eax
$LN4@stb_decomp:

; 3281 :     for (;;) {
; 3282 :         const unsigned char *old_i = i;

  0010f	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00112	89 45 ec	 mov	 DWORD PTR _old_i$1[ebp], eax

; 3283 :         i = stb_decompress_token(i);

  00115	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?stb_decompress_token@@YAPBEPBE@Z ; stb_decompress_token
  0011e	83 c4 04	 add	 esp, 4
  00121	89 45 0c	 mov	 DWORD PTR _i$[ebp], eax

; 3284 :         if (i == old_i) {

  00124	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00127	3b 45 ec	 cmp	 eax, DWORD PTR _old_i$1[ebp]
  0012a	0f 85 0f 01 00
	00		 jne	 $LN7@stb_decomp

; 3285 :             if (*i == 0x05 && i[1] == 0xfa) {

  00130	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00133	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00136	83 f9 05	 cmp	 ecx, 5
  00139	0f 85 d2 00 00
	00		 jne	 $LN8@stb_decomp
  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	c1 e0 00	 shl	 eax, 0
  00147	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  0014a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0014e	81 fa fa 00 00
	00		 cmp	 edx, 250		; 000000faH
  00154	0f 85 b7 00 00
	00		 jne	 $LN8@stb_decomp

; 3286 :                 IM_ASSERT(stb__dout == output + olen);

  0015a	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  0015d	03 45 f8	 add	 eax, DWORD PTR _olen$[ebp]
  00160	39 05 00 00 00
	00		 cmp	 DWORD PTR ?stb__dout@@3PAEA, eax
  00166	74 26		 je	 SHORT $LN14@stb_decomp
  00168	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stb_decompress@@YAIPAEPBEI@Z@4JA
  0016e	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00171	8b f4		 mov	 esi, esp
  00173	51		 push	 ecx
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
  00187	3b f4		 cmp	 esi, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@stb_decomp:

; 3287 :                 if (stb__dout != output + olen) return 0;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  00191	03 45 f8	 add	 eax, DWORD PTR _olen$[ebp]
  00194	39 05 00 00 00
	00		 cmp	 DWORD PTR ?stb__dout@@3PAEA, eax
  0019a	74 07		 je	 SHORT $LN10@stb_decomp
  0019c	33 c0		 xor	 eax, eax
  0019e	e9 e7 00 00 00	 jmp	 $LN1@stb_decomp
$LN10@stb_decomp:

; 3288 :                 if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))

  001a3	8b 45 f8	 mov	 eax, DWORD PTR _olen$[ebp]
  001a6	50		 push	 eax
  001a7	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  001aa	51		 push	 ecx
  001ab	6a 01		 push	 1
  001ad	e8 00 00 00 00	 call	 ?stb_adler32@@YAIIPAEI@Z ; stb_adler32
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b5	ba 01 00 00 00	 mov	 edx, 1
  001ba	d1 e2		 shl	 edx, 1
  001bc	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  001bf	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  001c3	c1 e2 18	 shl	 edx, 24			; 00000018H
  001c6	b9 01 00 00 00	 mov	 ecx, 1
  001cb	6b c9 03	 imul	 ecx, ecx, 3
  001ce	8b 75 0c	 mov	 esi, DWORD PTR _i$[ebp]
  001d1	0f b6 0c 0e	 movzx	 ecx, BYTE PTR [esi+ecx]
  001d5	c1 e1 10	 shl	 ecx, 16			; 00000010H
  001d8	be 01 00 00 00	 mov	 esi, 1
  001dd	c1 e6 02	 shl	 esi, 2
  001e0	8b 7d 0c	 mov	 edi, DWORD PTR _i$[ebp]
  001e3	0f b6 34 37	 movzx	 esi, BYTE PTR [edi+esi]
  001e7	c1 e6 08	 shl	 esi, 8
  001ea	bf 01 00 00 00	 mov	 edi, 1
  001ef	6b ff 05	 imul	 edi, edi, 5
  001f2	8b 5d 0c	 mov	 ebx, DWORD PTR _i$[ebp]
  001f5	0f b6 3c 3b	 movzx	 edi, BYTE PTR [ebx+edi]
  001f9	03 f7		 add	 esi, edi
  001fb	03 ce		 add	 ecx, esi
  001fd	03 d1		 add	 edx, ecx
  001ff	3b c2		 cmp	 eax, edx
  00201	74 07		 je	 SHORT $LN11@stb_decomp

; 3289 :                     return 0;

  00203	33 c0		 xor	 eax, eax
  00205	e9 80 00 00 00	 jmp	 $LN1@stb_decomp
$LN11@stb_decomp:

; 3290 :                 return olen;

  0020a	8b 45 f8	 mov	 eax, DWORD PTR _olen$[ebp]
  0020d	eb 7b		 jmp	 SHORT $LN1@stb_decomp

; 3291 :             } else {

  0020f	eb 2e		 jmp	 SHORT $LN7@stb_decomp
$LN8@stb_decomp:

; 3292 :                 IM_ASSERT(0); /* NOTREACHED */

  00211	33 c0		 xor	 eax, eax
  00213	75 26		 jne	 SHORT $LN15@stb_decomp
  00215	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stb_decompress@@YAIPAEPBEI@Z@4JA
  0021b	83 c1 15	 add	 ecx, 21			; 00000015H
  0021e	8b f4		 mov	 esi, esp
  00220	51		 push	 ecx
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00226	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  0022b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00231	83 c4 0c	 add	 esp, 12			; 0000000cH
  00234	3b f4		 cmp	 esi, esp
  00236	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN15@stb_decomp:

; 3293 :                 return 0;

  0023b	33 c0		 xor	 eax, eax
  0023d	eb 4b		 jmp	 SHORT $LN1@stb_decomp
$LN7@stb_decomp:

; 3294 :             }
; 3295 :         }
; 3296 :         IM_ASSERT(stb__dout <= output + olen);

  0023f	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  00242	03 45 f8	 add	 eax, DWORD PTR _olen$[ebp]
  00245	39 05 00 00 00
	00		 cmp	 DWORD PTR ?stb__dout@@3PAEA, eax
  0024b	76 26		 jbe	 SHORT $LN16@stb_decomp
  0024d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stb_decompress@@YAIPAEPBEI@Z@4JA
  00253	83 c1 19	 add	 ecx, 25			; 00000019H
  00256	8b f4		 mov	 esi, esp
  00258	51		 push	 ecx
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@
  00263	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026c	3b f4		 cmp	 esi, esp
  0026e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@stb_decomp:

; 3297 :         if (stb__dout > output + olen)

  00273	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  00276	03 45 f8	 add	 eax, DWORD PTR _olen$[ebp]
  00279	39 05 00 00 00
	00		 cmp	 DWORD PTR ?stb__dout@@3PAEA, eax
  0027f	76 04		 jbe	 SHORT $LN12@stb_decomp

; 3298 :             return 0;

  00281	33 c0		 xor	 eax, eax
  00283	eb 05		 jmp	 SHORT $LN1@stb_decomp
$LN12@stb_decomp:

; 3299 :     }

  00285	e9 85 fe ff ff	 jmp	 $LN4@stb_decomp
$LN1@stb_decomp:

; 3300 : }

  0028a	5f		 pop	 edi
  0028b	5e		 pop	 esi
  0028c	5b		 pop	 ebx
  0028d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00293	3b ec		 cmp	 ebp, esp
  00295	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029a	8b e5		 mov	 esp, ebp
  0029c	5d		 pop	 ebp
  0029d	c3		 ret	 0
?stb_decompress@@YAIPAEPBEI@Z ENDP			; stb_decompress
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?stb_decompress_length@@YAIPBE@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
?stb_decompress_length@@YAIPBE@Z PROC			; stb_decompress_length, COMDAT

; 3193 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3194 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	c1 e0 03	 shl	 eax, 3
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00033	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00037	c1 e0 18	 shl	 eax, 24			; 00000018H
  0003a	ba 01 00 00 00	 mov	 edx, 1
  0003f	6b ca 09	 imul	 ecx, edx, 9
  00042	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00045	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00049	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0004c	03 c1		 add	 eax, ecx
  0004e	ba 01 00 00 00	 mov	 edx, 1
  00053	6b ca 0a	 imul	 ecx, edx, 10
  00056	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00059	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0005d	c1 e1 08	 shl	 ecx, 8
  00060	03 c1		 add	 eax, ecx
  00062	ba 01 00 00 00	 mov	 edx, 1
  00067	6b ca 0b	 imul	 ecx, edx, 11
  0006a	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0006d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00071	03 c1		 add	 eax, ecx

; 3195 : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?stb_decompress_length@@YAIPBE@Z ENDP			; stb_decompress_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImFont@@@@YAXPAUImFont@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??$IM_DELETE@UImFont@@@@YAXPAUImFont@@@Z PROC		; IM_DELETE<ImFont>, COMDAT

; 1237 : template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  0002c	74 16		 je	 SHORT $LN1@IM_DELETE
  0002e	6a 00		 push	 0
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00033	e8 00 00 00 00	 call	 ??_GImFont@@QAEPAXI@Z
  00038	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00041	83 c4 04	 add	 esp, 4
$LN1@IM_DELETE:
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$IM_DELETE@UImFont@@@@YAXPAUImFont@@@Z ENDP		; IM_DELETE<ImFont>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\predefined C++ types (compiler internal)
;	COMDAT ??$__builtin_array_init_helper@UImVec2@@@@YAXPAUImVec2@@I@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_target$ = 8						; size = 4
_N$ = 12						; size = 4
??$__builtin_array_init_helper@UImVec2@@@@YAXPAUImVec2@@I@Z PROC ; __builtin_array_init_helper<ImVec2>, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __45E2592B_predefined C++ types (compiler internal)
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@builtin_ar
$LN2@builtin_ar:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@builtin_ar:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003d	3b 45 0c	 cmp	 eax, DWORD PTR _N$[ebp]
  00040	73 10		 jae	 SHORT $LN1@builtin_ar

  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _target$[ebp]
  00048	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  0004b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2

  00050	eb df		 jmp	 SHORT $LN2@builtin_ar
$LN1@builtin_ar:

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
??$__builtin_array_init_helper@UImVec2@@@@YAXPAUImVec2@@I@Z ENDP ; __builtin_array_init_helper<ImVec2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ
text$di	SEGMENT
??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ PROC	; `dynamic initializer for 'FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA'', COMDAT

; 1524 : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1516 :     { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	51		 push	 ecx
  00037	0f 57 c0	 xorps	 xmm0, xmm0
  0003a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A
  00044	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00049	51		 push	 ecx
  0004a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41980000
  00052	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00057	51		 push	 ecx
  00058	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41400000
  00060	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00065	b9 08 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+8
  0006a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0006f	51		 push	 ecx
  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00078	51		 push	 ecx
  00079	0f 57 c0	 xorps	 xmm0, xmm0
  0007c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00081	b9 10 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+16
  00086	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1517 :     { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput

  0008b	51		 push	 ecx
  0008c	0f 57 c0	 xorps	 xmm0, xmm0
  0008f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00094	51		 push	 ecx
  00095	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41500000
  0009d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a2	b9 18 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+24
  000a7	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ac	51		 push	 ecx
  000ad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41800000
  000b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ba	51		 push	 ecx
  000bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40e00000
  000c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c8	b9 20 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+32
  000cd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000d2	51		 push	 ecx
  000d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41000000
  000db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e0	51		 push	 ecx
  000e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ee	b9 28 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+40
  000f3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1518 :     { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll

  000f8	51		 push	 ecx
  000f9	0f 57 c0	 xorps	 xmm0, xmm0
  000fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00101	51		 push	 ecx
  00102	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41f80000
  0010a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010f	b9 30 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+48
  00114	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00119	51		 push	 ecx
  0011a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41b80000
  00122	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00127	51		 push	 ecx
  00128	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41b80000
  00130	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00135	b9 38 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+56
  0013a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0013f	51		 push	 ecx
  00140	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41300000
  00148	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014d	51		 push	 ecx
  0014e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41300000
  00156	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015b	b9 40 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+64
  00160	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1519 :     { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS

  00165	51		 push	 ecx
  00166	0f 57 c0	 xorps	 xmm0, xmm0
  00169	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016e	51		 push	 ecx
  0016f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41a80000
  00177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017c	b9 48 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+72
  00181	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00186	51		 push	 ecx
  00187	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41b80000
  0018f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00194	51		 push	 ecx
  00195	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41100000
  0019d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a2	b9 50 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+80
  001a7	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001ac	51		 push	 ecx
  001ad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41300000
  001b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ba	51		 push	 ecx
  001bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  001c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c8	b9 58 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+88
  001cd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1520 :     { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW

  001d2	51		 push	 ecx
  001d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41900000
  001db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e0	51		 push	 ecx
  001e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@425c0000
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	b9 60 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+96
  001f3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001f8	51		 push	 ecx
  001f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41100000
  00201	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00206	51		 push	 ecx
  00207	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41b80000
  0020f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00214	b9 68 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+104
  00219	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0021e	51		 push	 ecx
  0021f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  00227	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0022c	51		 push	 ecx
  0022d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41300000
  00235	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023a	b9 70 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+112
  0023f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1521 :     { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW

  00244	51		 push	 ecx
  00245	0f 57 c0	 xorps	 xmm0, xmm0
  00248	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0024d	51		 push	 ecx
  0024e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42920000
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	b9 78 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+120
  00260	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00265	51		 push	 ecx
  00266	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41880000
  0026e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00273	51		 push	 ecx
  00274	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41880000
  0027c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00281	b9 80 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+128
  00286	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0028b	51		 push	 ecx
  0028c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41000000
  00294	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00299	51		 push	 ecx
  0029a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41000000
  002a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a7	b9 88 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+136
  002ac	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1522 :     { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE

  002b1	51		 push	 ecx
  002b2	0f 57 c0	 xorps	 xmm0, xmm0
  002b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ba	51		 push	 ecx
  002bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@425c0000
  002c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c8	b9 90 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+144
  002cd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002d2	51		 push	 ecx
  002d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41880000
  002db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e0	51		 push	 ecx
  002e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41880000
  002e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ee	b9 98 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+152
  002f3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002f8	51		 push	 ecx
  002f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41000000
  00301	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00306	51		 push	 ecx
  00307	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41000000
  0030f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00314	b9 a0 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+160
  00319	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1523 :     { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand

  0031e	51		 push	 ecx
  0031f	0f 57 c0	 xorps	 xmm0, xmm0
  00322	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00327	51		 push	 ecx
  00328	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42b60000
  00330	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00335	b9 a8 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+168
  0033a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0033f	51		 push	 ecx
  00340	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41b00000
  00348	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034d	51		 push	 ecx
  0034e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41880000
  00356	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035b	b9 b0 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+176
  00360	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00365	51		 push	 ecx
  00366	0f 57 c0	 xorps	 xmm0, xmm0
  00369	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036e	51		 push	 ecx
  0036f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40a00000
  00377	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0037c	b9 b8 00 00 00	 mov	 ecx, OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+184
  00381	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00386	6a 03		 push	 3
  00388	68 c0 00 00 00	 push	 OFFSET ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A+192
  0038d	e8 00 00 00 00	 call	 ??$__builtin_array_init_helper@UImVec2@@@@YAXPAUImVec2@@I@Z ; __builtin_array_init_helper<ImVec2>
  00392	83 c4 08	 add	 esp, 8
  00395	5f		 pop	 edi
  00396	5e		 pop	 esi
  00397	5b		 pop	 ebx
  00398	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0039e	3b ec		 cmp	 ebp, esp
  003a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a5	8b e5		 mov	 esp, ebp
  003a7	5d		 pop	 ebp
  003a8	c3		 ret	 0
??__EFONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@YAXXZ ENDP	; `dynamic initializer for 'FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@H@@YAHHHM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_t$ = 16						; size = 4
??$ImLerp@H@@YAHHHM@Z PROC				; ImLerp<int>, COMDAT

; 317  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 2a 45 08	 cvtsi2ss xmm0, DWORD PTR _a$[ebp]
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00030	2b 45 08	 sub	 eax, DWORD PTR _a$[ebp]
  00033	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00037	f3 0f 59 4d 10	 mulss	 xmm1, DWORD PTR _t$[ebp]
  0003c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00040	f3 0f 2c c0	 cvttss2si eax, xmm0
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$ImLerp@H@@YAHHHM@Z ENDP				; ImLerp<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@M@@YAMMMM@Z
_TEXT	SEGMENT
tv66 = -200						; size = 4
tv67 = -196						; size = 4
_v$ = 8							; size = 4
_mn$ = 12						; size = 4
_mx$ = 16						; size = 4
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>, COMDAT

; 316  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _mn$[ebp]
  0002d	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _v$[ebp]
  00031	76 0f		 jbe	 SHORT $LN5@ImClamp
  00033	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _mn$[ebp]
  00038	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv67[ebp], xmm0
  00040	eb 37		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  00042	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _v$[ebp]
  00047	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _mx$[ebp]
  0004b	76 0f		 jbe	 SHORT $LN3@ImClamp
  0004d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _mx$[ebp]
  00052	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
  0005a	eb 0d		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  0005c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _v$[ebp]
  00061	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
$LN4@ImClamp:
  00069	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv66[ebp]
  00071	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv67[ebp], xmm0
$LN6@ImClamp:
  00079	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv67[ebp]
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?CanMergeDrawCommands@@YA_NPAUImDrawCmd@@0@Z
_TEXT	SEGMENT
tv81 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?CanMergeDrawCommands@@YA_NPAUImDrawCmd@@0@Z PROC	; CanMergeDrawCommands, COMDAT

; 1287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1288 :     return memcmp(&a->ClipRect, &b->ClipRect, sizeof(a->ClipRect)) == 0 && a->TextureId == b->TextureId && a->VtxOffset == b->VtxOffset && !a->UserCallback && !b->UserCallback;

  00028	6a 10		 push	 16			; 00000010H
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _memcmp
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	85 c0		 test	 eax, eax
  00042	75 3a		 jne	 SHORT $LN3@CanMergeDr
  00044	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00047	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004a	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0004d	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00050	75 2c		 jne	 SHORT $LN3@CanMergeDr
  00052	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00055	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00058	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  0005b	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0005e	75 1e		 jne	 SHORT $LN3@CanMergeDr
  00060	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00063	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00067	75 15		 jne	 SHORT $LN3@CanMergeDr
  00069	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0006c	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00070	75 0c		 jne	 SHORT $LN3@CanMergeDr
  00072	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv81[ebp], 1
  0007c	eb 0a		 jmp	 SHORT $LN4@CanMergeDr
$LN3@CanMergeDr:
  0007e	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv81[ebp], 0
$LN4@CanMergeDr:
  00088	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv81[ebp]

; 1289 : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?CanMergeDrawCommands@@YA_NPAUImDrawCmd@@0@Z ENDP	; CanMergeDrawCommands
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PathBezierToCasteljau@@YAXPAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z
_TEXT	SEGMENT
tv81 = -404						; size = 4
tv78 = -404						; size = 4
$T1 = -396						; size = 8
_y1234$2 = -188						; size = 4
_x1234$3 = -176						; size = 4
_y234$4 = -164						; size = 4
_x234$5 = -152						; size = 4
_y123$6 = -140						; size = 4
_x123$7 = -128						; size = 4
_y34$8 = -116						; size = 4
_x34$9 = -104						; size = 4
_y23$10 = -92						; size = 4
_x23$11 = -80						; size = 4
_y12$12 = -68						; size = 4
_x12$13 = -56						; size = 4
_d3$ = -44						; size = 4
_d2$ = -32						; size = 4
_dy$ = -20						; size = 4
_dx$ = -8						; size = 4
_path$ = 8						; size = 4
_x1$ = 12						; size = 4
_y1$ = 16						; size = 4
_x2$ = 20						; size = 4
_y2$ = 24						; size = 4
_x3$ = 28						; size = 4
_y3$ = 32						; size = 4
_x4$ = 36						; size = 4
_y4$ = 40						; size = 4
_tess_tol$ = 44						; size = 4
_level$ = 48						; size = 4
?PathBezierToCasteljau@@YAXPAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z PROC ; PathBezierToCasteljau, COMDAT

; 911  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00012	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 912  :     float dx = x4 - x1;

  00028	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _x4$[ebp]
  0002d	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _x1$[ebp]
  00032	f3 0f 11 45 f8	 movss	 DWORD PTR _dx$[ebp], xmm0

; 913  :     float dy = y4 - y1;

  00037	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _y4$[ebp]
  0003c	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _y1$[ebp]
  00041	f3 0f 11 45 ec	 movss	 DWORD PTR _dy$[ebp], xmm0

; 914  :     float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);

  00046	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _x2$[ebp]
  0004b	f3 0f 5c 45 24	 subss	 xmm0, DWORD PTR _x4$[ebp]
  00050	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _dy$[ebp]
  00055	f3 0f 10 4d 18	 movss	 xmm1, DWORD PTR _y2$[ebp]
  0005a	f3 0f 5c 4d 28	 subss	 xmm1, DWORD PTR _y4$[ebp]
  0005f	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _dx$[ebp]
  00064	f3 0f 5c c1	 subss	 xmm0, xmm1
  00068	f3 0f 11 45 e0	 movss	 DWORD PTR _d2$[ebp], xmm0

; 915  :     float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);

  0006d	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _x3$[ebp]
  00072	f3 0f 5c 45 24	 subss	 xmm0, DWORD PTR _x4$[ebp]
  00077	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _dy$[ebp]
  0007c	f3 0f 10 4d 20	 movss	 xmm1, DWORD PTR _y3$[ebp]
  00081	f3 0f 5c 4d 28	 subss	 xmm1, DWORD PTR _y4$[ebp]
  00086	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _dx$[ebp]
  0008b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0008f	f3 0f 11 45 d4	 movss	 DWORD PTR _d3$[ebp], xmm0

; 916  :     d2 = (d2 >= 0) ? d2 : -d2;

  00094	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _d2$[ebp]
  00099	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000a0	72 0f		 jb	 SHORT $LN6@PathBezier
  000a2	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _d2$[ebp]
  000a7	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
  000af	eb 14		 jmp	 SHORT $LN7@PathBezier
$LN6@PathBezier:
  000b1	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _d2$[ebp]
  000b6	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000bd	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
$LN7@PathBezier:
  000c5	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR tv78[ebp]
  000cd	f3 0f 11 45 e0	 movss	 DWORD PTR _d2$[ebp], xmm0

; 917  :     d3 = (d3 >= 0) ? d3 : -d3;

  000d2	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _d3$[ebp]
  000d7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000de	72 0f		 jb	 SHORT $LN8@PathBezier
  000e0	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _d3$[ebp]
  000e5	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR tv81[ebp], xmm0
  000ed	eb 14		 jmp	 SHORT $LN9@PathBezier
$LN8@PathBezier:
  000ef	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _d3$[ebp]
  000f4	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000fb	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR tv81[ebp], xmm0
$LN9@PathBezier:
  00103	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR tv81[ebp]
  0010b	f3 0f 11 45 d4	 movss	 DWORD PTR _d3$[ebp], xmm0

; 918  :     if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))

  00110	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _d2$[ebp]
  00115	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _d3$[ebp]
  0011a	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _d2$[ebp]
  0011f	f3 0f 58 4d d4	 addss	 xmm1, DWORD PTR _d3$[ebp]
  00124	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00128	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _dx$[ebp]
  0012d	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _dx$[ebp]
  00132	f3 0f 10 55 ec	 movss	 xmm2, DWORD PTR _dy$[ebp]
  00137	f3 0f 59 55 ec	 mulss	 xmm2, DWORD PTR _dy$[ebp]
  0013c	f3 0f 58 ca	 addss	 xmm1, xmm2
  00140	f3 0f 59 4d 2c	 mulss	 xmm1, DWORD PTR _tess_tol$[ebp]
  00145	0f 2f c8	 comiss	 xmm1, xmm0
  00148	76 2f		 jbe	 SHORT $LN2@PathBezier

; 919  :     {
; 920  :         path->push_back(ImVec2(x4, y4));

  0014a	51		 push	 ecx
  0014b	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _y4$[ebp]
  00150	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00155	51		 push	 ecx
  00156	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _x4$[ebp]
  0015b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00160	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00166	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0016b	50		 push	 eax
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0016f	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 921  :     }

  00174	e9 37 02 00 00	 jmp	 $LN4@PathBezier
$LN2@PathBezier:

; 922  :     else if (level < 10)

  00179	83 7d 30 0a	 cmp	 DWORD PTR _level$[ebp], 10 ; 0000000aH
  0017d	0f 8d 2d 02 00
	00		 jge	 $LN4@PathBezier

; 923  :     {
; 924  :         float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;

  00183	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _x1$[ebp]
  00188	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _x2$[ebp]
  0018d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00195	f3 0f 11 45 c8	 movss	 DWORD PTR _x12$13[ebp], xmm0
  0019a	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _y1$[ebp]
  0019f	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _y2$[ebp]
  001a4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001ac	f3 0f 11 45 bc	 movss	 DWORD PTR _y12$12[ebp], xmm0

; 925  :         float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;

  001b1	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _x2$[ebp]
  001b6	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _x3$[ebp]
  001bb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001c3	f3 0f 11 45 b0	 movss	 DWORD PTR _x23$11[ebp], xmm0
  001c8	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y2$[ebp]
  001cd	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _y3$[ebp]
  001d2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001da	f3 0f 11 45 a4	 movss	 DWORD PTR _y23$10[ebp], xmm0

; 926  :         float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;

  001df	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _x3$[ebp]
  001e4	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _x4$[ebp]
  001e9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001f1	f3 0f 11 45 98	 movss	 DWORD PTR _x34$9[ebp], xmm0
  001f6	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _y3$[ebp]
  001fb	f3 0f 58 45 28	 addss	 xmm0, DWORD PTR _y4$[ebp]
  00200	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00208	f3 0f 11 45 8c	 movss	 DWORD PTR _y34$8[ebp], xmm0

; 927  :         float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;

  0020d	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _x12$13[ebp]
  00212	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _x23$11[ebp]
  00217	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0021f	f3 0f 11 45 80	 movss	 DWORD PTR _x123$7[ebp], xmm0
  00224	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _y12$12[ebp]
  00229	f3 0f 58 45 a4	 addss	 xmm0, DWORD PTR _y23$10[ebp]
  0022e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00236	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _y123$6[ebp], xmm0

; 928  :         float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;

  0023e	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _x23$11[ebp]
  00243	f3 0f 58 45 98	 addss	 xmm0, DWORD PTR _x34$9[ebp]
  00248	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00250	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _x234$5[ebp], xmm0
  00258	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _y23$10[ebp]
  0025d	f3 0f 58 45 8c	 addss	 xmm0, DWORD PTR _y34$8[ebp]
  00262	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0026a	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _y234$4[ebp], xmm0

; 929  :         float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;

  00272	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x123$7[ebp]
  00277	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _x234$5[ebp]
  0027f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00287	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _x1234$3[ebp], xmm0
  0028f	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _y123$6[ebp]
  00297	f3 0f 58 85 5c
	ff ff ff	 addss	 xmm0, DWORD PTR _y234$4[ebp]
  0029f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  002a7	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _y1234$2[ebp], xmm0

; 930  : 
; 931  :         PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);

  002af	8b 45 30	 mov	 eax, DWORD PTR _level$[ebp]
  002b2	83 c0 01	 add	 eax, 1
  002b5	50		 push	 eax
  002b6	51		 push	 ecx
  002b7	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _tess_tol$[ebp]
  002bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c1	51		 push	 ecx
  002c2	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _y1234$2[ebp]
  002ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002cf	51		 push	 ecx
  002d0	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _x1234$3[ebp]
  002d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002dd	51		 push	 ecx
  002de	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _y123$6[ebp]
  002e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002eb	51		 push	 ecx
  002ec	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x123$7[ebp]
  002f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f6	51		 push	 ecx
  002f7	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _y12$12[ebp]
  002fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00301	51		 push	 ecx
  00302	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _x12$13[ebp]
  00307	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030c	51		 push	 ecx
  0030d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00312	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00317	51		 push	 ecx
  00318	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _x1$[ebp]
  0031d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00322	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00325	51		 push	 ecx
  00326	e8 00 00 00 00	 call	 ?PathBezierToCasteljau@@YAXPAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau
  0032b	83 c4 2c	 add	 esp, 44			; 0000002cH

; 932  :         PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);

  0032e	8b 45 30	 mov	 eax, DWORD PTR _level$[ebp]
  00331	83 c0 01	 add	 eax, 1
  00334	50		 push	 eax
  00335	51		 push	 ecx
  00336	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _tess_tol$[ebp]
  0033b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00340	51		 push	 ecx
  00341	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _y4$[ebp]
  00346	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034b	51		 push	 ecx
  0034c	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _x4$[ebp]
  00351	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00356	51		 push	 ecx
  00357	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _y34$8[ebp]
  0035c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00361	51		 push	 ecx
  00362	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _x34$9[ebp]
  00367	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036c	51		 push	 ecx
  0036d	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _y234$4[ebp]
  00375	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0037a	51		 push	 ecx
  0037b	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _x234$5[ebp]
  00383	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00388	51		 push	 ecx
  00389	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _y1234$2[ebp]
  00391	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00396	51		 push	 ecx
  00397	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _x1234$3[ebp]
  0039f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a4	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  003a7	51		 push	 ecx
  003a8	e8 00 00 00 00	 call	 ?PathBezierToCasteljau@@YAXPAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau
  003ad	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN4@PathBezier:

; 933  :     }
; 934  : }

  003b0	5f		 pop	 edi
  003b1	5e		 pop	 esi
  003b2	5b		 pop	 ebx
  003b3	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  003b9	3b ec		 cmp	 ebp, esp
  003bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c0	8b e5		 mov	 esp, ebp
  003c2	5d		 pop	 ebp
  003c3	c3		 ret	 0
?PathBezierToCasteljau@@YAXPAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ENDP ; PathBezierToCasteljau
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__oversample_shift@@YAMH@Z
_TEXT	SEGMENT
tv76 = -196						; size = 4
_oversample$ = 8					; size = 4
?stbtt__oversample_shift@@YAMH@Z PROC			; stbtt__oversample_shift, COMDAT

; 3977 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3978 :    if (!oversample)

  00028	83 7d 08 00	 cmp	 DWORD PTR _oversample$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN2@stbtt__ove

; 3979 :       return 0.0f;

  0002e	d9 ee		 fldz
  00030	eb 2b		 jmp	 SHORT $LN1@stbtt__ove
$LN2@stbtt__ove:

; 3980 : 
; 3981 :    // The prefilter is a box filter of width "oversample",
; 3982 :    // which shifts phase by (oversample - 1)/2 pixels in
; 3983 :    // oversampled space. We want to shift in the opposite
; 3984 :    // direction to counter this.
; 3985 :    return (float)-(oversample - 1) / (2.0f * (float)oversample);

  00032	8b 45 08	 mov	 eax, DWORD PTR _oversample$[ebp]
  00035	83 e8 01	 sub	 eax, 1
  00038	f7 d8		 neg	 eax
  0003a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0003e	f3 0f 2a 4d 08	 cvtsi2ss xmm1, DWORD PTR _oversample$[ebp]
  00043	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  0004b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0004f	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv76[ebp], xmm0
  00057	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv76[ebp]
$LN1@stbtt__ove:

; 3986 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?stbtt__oversample_shift@@YAMH@Z ENDP			; stbtt__oversample_shift
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__v_prefilter@@YAXPAEHHHI@Z
_TEXT	SEGMENT
tv70 = -264						; size = 4
_total$1 = -64						; size = 4
_i$2 = -52						; size = 4
_j$ = -40						; size = 4
_safe_h$ = -28						; size = 4
_buffer$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_pixels$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_stride_in_bytes$ = 20					; size = 4
_kernel_width$ = 24					; size = 4
?stbtt__v_prefilter@@YAXPAEHHHI@Z PROC			; stbtt__v_prefilter, COMDAT

; 3915 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3916 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3917 :    int safe_h = h - kernel_width;

  00032	8b 45 10	 mov	 eax, DWORD PTR _h$[ebp]
  00035	2b 45 18	 sub	 eax, DWORD PTR _kernel_width$[ebp]
  00038	89 45 e4	 mov	 DWORD PTR _safe_h$[ebp], eax

; 3918 :    int j;
; 3919 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

  0003b	6a 08		 push	 8
  0003d	6a 00		 push	 0
  0003f	8d 45 f0	 lea	 eax, DWORD PTR _buffer$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _memset
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3920 :    for (j=0; j < w; ++j) {

  0004b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@stbtt__v_p
$LN2@stbtt__v_p:
  00054	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 d8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@stbtt__v_p:
  0005d	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  00060	3b 45 0c	 cmp	 eax, DWORD PTR _w$[ebp]
  00063	0f 8d fd 02 00
	00		 jge	 $LN1@stbtt__v_p

; 3921 :       int i;
; 3922 :       unsigned int total;
; 3923 :       STBTT_memset(buffer, 0, kernel_width);

  00069	8b 45 18	 mov	 eax, DWORD PTR _kernel_width$[ebp]
  0006c	50		 push	 eax
  0006d	6a 00		 push	 0
  0006f	8d 4d f0	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _memset
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3924 : 
; 3925 :       total = 0;

  0007b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _total$1[ebp], 0

; 3926 : 
; 3927 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3928 :       switch (kernel_width) {

  00082	8b 45 18	 mov	 eax, DWORD PTR _kernel_width$[ebp]
  00085	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0008b	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  00091	83 e9 02	 sub	 ecx, 2
  00094	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv70[ebp], ecx
  0009a	83 bd f8 fe ff
	ff 03		 cmp	 DWORD PTR tv70[ebp], 3
  000a1	0f 87 d1 01 00
	00		 ja	 $LN29@stbtt__v_p
  000a7	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv70[ebp]
  000ad	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN32@stbtt__v_p[edx*4]
$LN25@stbtt__v_p:

; 3929 :          case 2:
; 3930 :             for (i=0; i <= safe_h; ++i) {

  000b4	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  000bb	eb 09		 jmp	 SHORT $LN9@stbtt__v_p
$LN7@stbtt__v_p:
  000bd	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN9@stbtt__v_p:
  000c6	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000c9	3b 45 e4	 cmp	 eax, DWORD PTR _safe_h$[ebp]
  000cc	7f 4f		 jg	 SHORT $LN8@stbtt__v_p

; 3931 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  000ce	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000d1	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  000d8	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000dc	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000df	83 e0 07	 and	 eax, 7
  000e2	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  000e7	2b d1		 sub	 edx, ecx
  000e9	03 55 c0	 add	 edx, DWORD PTR _total$1[ebp]
  000ec	89 55 c0	 mov	 DWORD PTR _total$1[ebp], edx

; 3932 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  000ef	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000f2	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  000f6	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  000f9	03 4d 18	 add	 ecx, DWORD PTR _kernel_width$[ebp]
  000fc	83 e1 07	 and	 ecx, 7
  000ff	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  00102	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00105	88 44 0d f0	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 3933 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 2);

  00109	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  0010c	d1 e8		 shr	 eax, 1
  0010e	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  00111	0f af 4d 14	 imul	 ecx, DWORD PTR _stride_in_bytes$[ebp]
  00115	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  00118	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3934 :             }

  0011b	eb a0		 jmp	 SHORT $LN7@stbtt__v_p
$LN8@stbtt__v_p:

; 3935 :             break;

  0011d	e9 c2 01 00 00	 jmp	 $LN5@stbtt__v_p
$LN26@stbtt__v_p:

; 3936 :          case 3:
; 3937 :             for (i=0; i <= safe_h; ++i) {

  00122	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00129	eb 09		 jmp	 SHORT $LN12@stbtt__v_p
$LN10@stbtt__v_p:
  0012b	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0012e	83 c0 01	 add	 eax, 1
  00131	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN12@stbtt__v_p:
  00134	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00137	3b 45 e4	 cmp	 eax, DWORD PTR _safe_h$[ebp]
  0013a	7f 56		 jg	 SHORT $LN11@stbtt__v_p

; 3938 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  0013c	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0013f	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  00143	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  00146	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0014a	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0014d	83 e0 07	 and	 eax, 7
  00150	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  00155	2b d1		 sub	 edx, ecx
  00157	03 55 c0	 add	 edx, DWORD PTR _total$1[ebp]
  0015a	89 55 c0	 mov	 DWORD PTR _total$1[ebp], edx

; 3939 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  0015d	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00160	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  00164	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  00167	03 4d 18	 add	 ecx, DWORD PTR _kernel_width$[ebp]
  0016a	83 e1 07	 and	 ecx, 7
  0016d	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  00170	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00173	88 44 0d f0	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 3940 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 3);

  00177	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  0017a	33 d2		 xor	 edx, edx
  0017c	b9 03 00 00 00	 mov	 ecx, 3
  00181	f7 f1		 div	 ecx
  00183	8b 55 cc	 mov	 edx, DWORD PTR _i$2[ebp]
  00186	0f af 55 14	 imul	 edx, DWORD PTR _stride_in_bytes$[ebp]
  0018a	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  0018d	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3941 :             }

  00190	eb 99		 jmp	 SHORT $LN10@stbtt__v_p
$LN11@stbtt__v_p:

; 3942 :             break;

  00192	e9 4d 01 00 00	 jmp	 $LN5@stbtt__v_p
$LN27@stbtt__v_p:

; 3943 :          case 4:
; 3944 :             for (i=0; i <= safe_h; ++i) {

  00197	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0019e	eb 09		 jmp	 SHORT $LN15@stbtt__v_p
$LN13@stbtt__v_p:
  001a0	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001a3	83 c0 01	 add	 eax, 1
  001a6	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN15@stbtt__v_p:
  001a9	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001ac	3b 45 e4	 cmp	 eax, DWORD PTR _safe_h$[ebp]
  001af	7f 50		 jg	 SHORT $LN14@stbtt__v_p

; 3945 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  001b1	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001b4	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  001bb	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001bf	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001c2	83 e0 07	 and	 eax, 7
  001c5	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  001ca	2b d1		 sub	 edx, ecx
  001cc	03 55 c0	 add	 edx, DWORD PTR _total$1[ebp]
  001cf	89 55 c0	 mov	 DWORD PTR _total$1[ebp], edx

; 3946 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  001d2	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001d5	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  001d9	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  001dc	03 4d 18	 add	 ecx, DWORD PTR _kernel_width$[ebp]
  001df	83 e1 07	 and	 ecx, 7
  001e2	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  001e5	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001e8	88 44 0d f0	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 3947 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 4);

  001ec	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  001ef	c1 e8 02	 shr	 eax, 2
  001f2	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  001f5	0f af 4d 14	 imul	 ecx, DWORD PTR _stride_in_bytes$[ebp]
  001f9	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  001fc	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3948 :             }

  001ff	eb 9f		 jmp	 SHORT $LN13@stbtt__v_p
$LN14@stbtt__v_p:

; 3949 :             break;

  00201	e9 de 00 00 00	 jmp	 $LN5@stbtt__v_p
$LN28@stbtt__v_p:

; 3950 :          case 5:
; 3951 :             for (i=0; i <= safe_h; ++i) {

  00206	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0020d	eb 09		 jmp	 SHORT $LN18@stbtt__v_p
$LN16@stbtt__v_p:
  0020f	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00212	83 c0 01	 add	 eax, 1
  00215	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN18@stbtt__v_p:
  00218	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0021b	3b 45 e4	 cmp	 eax, DWORD PTR _safe_h$[ebp]
  0021e	7f 56		 jg	 SHORT $LN17@stbtt__v_p

; 3952 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  00220	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00223	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  00227	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  0022a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0022e	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00231	83 e0 07	 and	 eax, 7
  00234	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  00239	2b d1		 sub	 edx, ecx
  0023b	03 55 c0	 add	 edx, DWORD PTR _total$1[ebp]
  0023e	89 55 c0	 mov	 DWORD PTR _total$1[ebp], edx

; 3953 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  00241	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00244	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  00248	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  0024b	03 4d 18	 add	 ecx, DWORD PTR _kernel_width$[ebp]
  0024e	83 e1 07	 and	 ecx, 7
  00251	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  00254	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00257	88 44 0d f0	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 3954 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 5);

  0025b	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  0025e	33 d2		 xor	 edx, edx
  00260	b9 05 00 00 00	 mov	 ecx, 5
  00265	f7 f1		 div	 ecx
  00267	8b 55 cc	 mov	 edx, DWORD PTR _i$2[ebp]
  0026a	0f af 55 14	 imul	 edx, DWORD PTR _stride_in_bytes$[ebp]
  0026e	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  00271	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3955 :             }

  00274	eb 99		 jmp	 SHORT $LN16@stbtt__v_p
$LN17@stbtt__v_p:

; 3956 :             break;

  00276	eb 6c		 jmp	 SHORT $LN5@stbtt__v_p
$LN29@stbtt__v_p:

; 3957 :          default:
; 3958 :             for (i=0; i <= safe_h; ++i) {

  00278	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0027f	eb 09		 jmp	 SHORT $LN21@stbtt__v_p
$LN19@stbtt__v_p:
  00281	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00284	83 c0 01	 add	 eax, 1
  00287	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN21@stbtt__v_p:
  0028a	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0028d	3b 45 e4	 cmp	 eax, DWORD PTR _safe_h$[ebp]
  00290	7f 52		 jg	 SHORT $LN5@stbtt__v_p

; 3959 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  00292	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00295	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  00299	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  0029c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002a0	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  002a3	83 e0 07	 and	 eax, 7
  002a6	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  002ab	2b d1		 sub	 edx, ecx
  002ad	03 55 c0	 add	 edx, DWORD PTR _total$1[ebp]
  002b0	89 55 c0	 mov	 DWORD PTR _total$1[ebp], edx

; 3960 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

  002b3	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  002b6	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  002ba	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  002bd	03 4d 18	 add	 ecx, DWORD PTR _kernel_width$[ebp]
  002c0	83 e1 07	 and	 ecx, 7
  002c3	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  002c6	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  002c9	88 44 0d f0	 mov	 BYTE PTR _buffer$[ebp+ecx], al

; 3961 :                pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

  002cd	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  002d0	33 d2		 xor	 edx, edx
  002d2	f7 75 18	 div	 DWORD PTR _kernel_width$[ebp]
  002d5	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  002d8	0f af 4d 14	 imul	 ecx, DWORD PTR _stride_in_bytes$[ebp]
  002dc	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  002df	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3962 :             }

  002e2	eb 9d		 jmp	 SHORT $LN19@stbtt__v_p
$LN5@stbtt__v_p:

; 3963 :             break;
; 3964 :       }
; 3965 : 
; 3966 :       for (; i < h; ++i) {

  002e4	eb 09		 jmp	 SHORT $LN24@stbtt__v_p
$LN22@stbtt__v_p:
  002e6	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  002e9	83 c0 01	 add	 eax, 1
  002ec	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN24@stbtt__v_p:
  002ef	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  002f2	3b 45 10	 cmp	 eax, DWORD PTR _h$[ebp]
  002f5	7d 61		 jge	 SHORT $LN23@stbtt__v_p

; 3967 :          STBTT_assert(pixels[i*stride_in_bytes] == 0);

  002f7	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  002fa	0f af 45 14	 imul	 eax, DWORD PTR _stride_in_bytes$[ebp]
  002fe	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  00301	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00305	85 d2		 test	 edx, edx
  00307	74 25		 je	 SHORT $LN31@stbtt__v_p
  00309	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__v_prefilter@@YAXPAEHHHI@Z@4JA
  0030e	83 c0 34	 add	 eax, 52			; 00000034H
  00311	8b f4		 mov	 esi, esp
  00313	50		 push	 eax
  00314	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_1DO@LAPBLJ@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$CK?$AAs?$AAt?$AAr?$AAi?$AAd?$AAe@
  0031e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH
  00327	3b f4		 cmp	 esi, esp
  00329	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN31@stbtt__v_p:

; 3968 :          total -= buffer[i & STBTT__OVER_MASK];

  0032e	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00331	83 e0 07	 and	 eax, 7
  00334	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  00339	8b 55 c0	 mov	 edx, DWORD PTR _total$1[ebp]
  0033c	2b d1		 sub	 edx, ecx
  0033e	89 55 c0	 mov	 DWORD PTR _total$1[ebp], edx

; 3969 :          pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

  00341	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  00344	33 d2		 xor	 edx, edx
  00346	f7 75 18	 div	 DWORD PTR _kernel_width$[ebp]
  00349	8b 4d cc	 mov	 ecx, DWORD PTR _i$2[ebp]
  0034c	0f af 4d 14	 imul	 ecx, DWORD PTR _stride_in_bytes$[ebp]
  00350	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  00353	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3970 :       }

  00356	eb 8e		 jmp	 SHORT $LN22@stbtt__v_p
$LN23@stbtt__v_p:

; 3971 : 
; 3972 :       pixels += 1;

  00358	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  0035b	83 c0 01	 add	 eax, 1
  0035e	89 45 08	 mov	 DWORD PTR _pixels$[ebp], eax

; 3973 :    }

  00361	e9 ee fc ff ff	 jmp	 $LN2@stbtt__v_p
$LN1@stbtt__v_p:

; 3974 : }

  00366	52		 push	 edx
  00367	8b cd		 mov	 ecx, ebp
  00369	50		 push	 eax
  0036a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN35@stbtt__v_p
  00370	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00375	58		 pop	 eax
  00376	5a		 pop	 edx
  00377	5f		 pop	 edi
  00378	5e		 pop	 esi
  00379	5b		 pop	 ebx
  0037a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037d	33 cd		 xor	 ecx, ebp
  0037f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00384	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  0038a	3b ec		 cmp	 ebp, esp
  0038c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00391	8b e5		 mov	 esp, ebp
  00393	5d		 pop	 ebp
  00394	c3		 ret	 0
  00395	0f 1f 00	 npad	 3
$LN35@stbtt__v_p:
  00398	01 00 00 00	 DD	 1
  0039c	00 00 00 00	 DD	 $LN34@stbtt__v_p
$LN34@stbtt__v_p:
  003a0	f0 ff ff ff	 DD	 -16			; fffffff0H
  003a4	08 00 00 00	 DD	 8
  003a8	00 00 00 00	 DD	 $LN33@stbtt__v_p
$LN33@stbtt__v_p:
  003ac	62		 DB	 98			; 00000062H
  003ad	75		 DB	 117			; 00000075H
  003ae	66		 DB	 102			; 00000066H
  003af	66		 DB	 102			; 00000066H
  003b0	65		 DB	 101			; 00000065H
  003b1	72		 DB	 114			; 00000072H
  003b2	00		 DB	 0
  003b3	90		 npad	 1
$LN32@stbtt__v_p:
  003b4	00 00 00 00	 DD	 $LN25@stbtt__v_p
  003b8	00 00 00 00	 DD	 $LN26@stbtt__v_p
  003bc	00 00 00 00	 DD	 $LN27@stbtt__v_p
  003c0	00 00 00 00	 DD	 $LN28@stbtt__v_p
?stbtt__v_prefilter@@YAXPAEHHHI@Z ENDP			; stbtt__v_prefilter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__h_prefilter@@YAXPAEHHHI@Z
_TEXT	SEGMENT
tv70 = -264						; size = 4
_total$1 = -64						; size = 4
_i$2 = -52						; size = 4
_j$ = -40						; size = 4
_safe_w$ = -28						; size = 4
_buffer$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_pixels$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_stride_in_bytes$ = 20					; size = 4
_kernel_width$ = 24					; size = 4
?stbtt__h_prefilter@@YAXPAEHHHI@Z PROC			; stbtt__h_prefilter, COMDAT

; 3853 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3854 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3855 :    int safe_w = w - kernel_width;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _w$[ebp]
  00035	2b 45 18	 sub	 eax, DWORD PTR _kernel_width$[ebp]
  00038	89 45 e4	 mov	 DWORD PTR _safe_w$[ebp], eax

; 3856 :    int j;
; 3857 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

  0003b	6a 08		 push	 8
  0003d	6a 00		 push	 0
  0003f	8d 45 f0	 lea	 eax, DWORD PTR _buffer$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _memset
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3858 :    for (j=0; j < h; ++j) {

  0004b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@stbtt__h_p
$LN2@stbtt__h_p:
  00054	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 d8	 mov	 DWORD PTR _j$[ebp], eax
$LN4@stbtt__h_p:
  0005d	8b 45 d8	 mov	 eax, DWORD PTR _j$[ebp]
  00060	3b 45 10	 cmp	 eax, DWORD PTR _h$[ebp]
  00063	0f 8d a9 02 00
	00		 jge	 $LN1@stbtt__h_p

; 3859 :       int i;
; 3860 :       unsigned int total;
; 3861 :       STBTT_memset(buffer, 0, kernel_width);

  00069	8b 45 18	 mov	 eax, DWORD PTR _kernel_width$[ebp]
  0006c	50		 push	 eax
  0006d	6a 00		 push	 0
  0006f	8d 4d f0	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _memset
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3862 : 
; 3863 :       total = 0;

  0007b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _total$1[ebp], 0

; 3864 : 
; 3865 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3866 :       switch (kernel_width) {

  00082	8b 45 18	 mov	 eax, DWORD PTR _kernel_width$[ebp]
  00085	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0008b	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  00091	83 e9 02	 sub	 ecx, 2
  00094	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv70[ebp], ecx
  0009a	83 bd f8 fe ff
	ff 03		 cmp	 DWORD PTR tv70[ebp], 3
  000a1	0f 87 95 01 00
	00		 ja	 $LN29@stbtt__h_p
  000a7	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv70[ebp]
  000ad	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN32@stbtt__h_p[edx*4]
$LN25@stbtt__h_p:

; 3867 :          case 2:
; 3868 :             for (i=0; i <= safe_w; ++i) {

  000b4	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  000bb	eb 09		 jmp	 SHORT $LN9@stbtt__h_p
$LN7@stbtt__h_p:
  000bd	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000c0	83 c0 01	 add	 eax, 1
  000c3	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN9@stbtt__h_p:
  000c6	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000c9	3b 45 e4	 cmp	 eax, DWORD PTR _safe_w$[ebp]
  000cc	7f 40		 jg	 SHORT $LN8@stbtt__h_p

; 3869 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  000ce	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  000d1	03 45 cc	 add	 eax, DWORD PTR _i$2[ebp]
  000d4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d7	8b 55 cc	 mov	 edx, DWORD PTR _i$2[ebp]
  000da	83 e2 07	 and	 edx, 7
  000dd	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _buffer$[ebp+edx]
  000e2	2b c8		 sub	 ecx, eax
  000e4	03 4d c0	 add	 ecx, DWORD PTR _total$1[ebp]
  000e7	89 4d c0	 mov	 DWORD PTR _total$1[ebp], ecx

; 3870 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  000ea	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  000ed	03 45 18	 add	 eax, DWORD PTR _kernel_width$[ebp]
  000f0	83 e0 07	 and	 eax, 7
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  000f6	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  000f9	8a 11		 mov	 dl, BYTE PTR [ecx]
  000fb	88 54 05 f0	 mov	 BYTE PTR _buffer$[ebp+eax], dl

; 3871 :                pixels[i] = (unsigned char) (total / 2);

  000ff	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  00102	d1 e8		 shr	 eax, 1
  00104	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  00107	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  0010a	88 01		 mov	 BYTE PTR [ecx], al

; 3872 :             }

  0010c	eb af		 jmp	 SHORT $LN7@stbtt__h_p
$LN8@stbtt__h_p:

; 3873 :             break;

  0010e	e9 86 01 00 00	 jmp	 $LN5@stbtt__h_p
$LN26@stbtt__h_p:

; 3874 :          case 3:
; 3875 :             for (i=0; i <= safe_w; ++i) {

  00113	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0011a	eb 09		 jmp	 SHORT $LN12@stbtt__h_p
$LN10@stbtt__h_p:
  0011c	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0011f	83 c0 01	 add	 eax, 1
  00122	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN12@stbtt__h_p:
  00125	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00128	3b 45 e4	 cmp	 eax, DWORD PTR _safe_w$[ebp]
  0012b	7f 47		 jg	 SHORT $LN11@stbtt__h_p

; 3876 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  0012d	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  00130	03 45 cc	 add	 eax, DWORD PTR _i$2[ebp]
  00133	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00136	8b 55 cc	 mov	 edx, DWORD PTR _i$2[ebp]
  00139	83 e2 07	 and	 edx, 7
  0013c	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _buffer$[ebp+edx]
  00141	2b c8		 sub	 ecx, eax
  00143	03 4d c0	 add	 ecx, DWORD PTR _total$1[ebp]
  00146	89 4d c0	 mov	 DWORD PTR _total$1[ebp], ecx

; 3877 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  00149	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0014c	03 45 18	 add	 eax, DWORD PTR _kernel_width$[ebp]
  0014f	83 e0 07	 and	 eax, 7
  00152	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  00155	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  00158	8a 11		 mov	 dl, BYTE PTR [ecx]
  0015a	88 54 05 f0	 mov	 BYTE PTR _buffer$[ebp+eax], dl

; 3878 :                pixels[i] = (unsigned char) (total / 3);

  0015e	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  00161	33 d2		 xor	 edx, edx
  00163	b9 03 00 00 00	 mov	 ecx, 3
  00168	f7 f1		 div	 ecx
  0016a	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  0016d	03 55 cc	 add	 edx, DWORD PTR _i$2[ebp]
  00170	88 02		 mov	 BYTE PTR [edx], al

; 3879 :             }

  00172	eb a8		 jmp	 SHORT $LN10@stbtt__h_p
$LN11@stbtt__h_p:

; 3880 :             break;

  00174	e9 20 01 00 00	 jmp	 $LN5@stbtt__h_p
$LN27@stbtt__h_p:

; 3881 :          case 4:
; 3882 :             for (i=0; i <= safe_w; ++i) {

  00179	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00180	eb 09		 jmp	 SHORT $LN15@stbtt__h_p
$LN13@stbtt__h_p:
  00182	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00185	83 c0 01	 add	 eax, 1
  00188	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN15@stbtt__h_p:
  0018b	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0018e	3b 45 e4	 cmp	 eax, DWORD PTR _safe_w$[ebp]
  00191	7f 41		 jg	 SHORT $LN14@stbtt__h_p

; 3883 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  00193	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  00196	03 45 cc	 add	 eax, DWORD PTR _i$2[ebp]
  00199	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0019c	8b 55 cc	 mov	 edx, DWORD PTR _i$2[ebp]
  0019f	83 e2 07	 and	 edx, 7
  001a2	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _buffer$[ebp+edx]
  001a7	2b c8		 sub	 ecx, eax
  001a9	03 4d c0	 add	 ecx, DWORD PTR _total$1[ebp]
  001ac	89 4d c0	 mov	 DWORD PTR _total$1[ebp], ecx

; 3884 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  001af	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001b2	03 45 18	 add	 eax, DWORD PTR _kernel_width$[ebp]
  001b5	83 e0 07	 and	 eax, 7
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  001bb	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  001be	8a 11		 mov	 dl, BYTE PTR [ecx]
  001c0	88 54 05 f0	 mov	 BYTE PTR _buffer$[ebp+eax], dl

; 3885 :                pixels[i] = (unsigned char) (total / 4);

  001c4	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  001c7	c1 e8 02	 shr	 eax, 2
  001ca	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  001cd	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  001d0	88 01		 mov	 BYTE PTR [ecx], al

; 3886 :             }

  001d2	eb ae		 jmp	 SHORT $LN13@stbtt__h_p
$LN14@stbtt__h_p:

; 3887 :             break;

  001d4	e9 c0 00 00 00	 jmp	 $LN5@stbtt__h_p
$LN28@stbtt__h_p:

; 3888 :          case 5:
; 3889 :             for (i=0; i <= safe_w; ++i) {

  001d9	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  001e0	eb 09		 jmp	 SHORT $LN18@stbtt__h_p
$LN16@stbtt__h_p:
  001e2	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001e5	83 c0 01	 add	 eax, 1
  001e8	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN18@stbtt__h_p:
  001eb	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  001ee	3b 45 e4	 cmp	 eax, DWORD PTR _safe_w$[ebp]
  001f1	7f 47		 jg	 SHORT $LN17@stbtt__h_p

; 3890 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  001f3	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  001f6	03 45 cc	 add	 eax, DWORD PTR _i$2[ebp]
  001f9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001fc	8b 55 cc	 mov	 edx, DWORD PTR _i$2[ebp]
  001ff	83 e2 07	 and	 edx, 7
  00202	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _buffer$[ebp+edx]
  00207	2b c8		 sub	 ecx, eax
  00209	03 4d c0	 add	 ecx, DWORD PTR _total$1[ebp]
  0020c	89 4d c0	 mov	 DWORD PTR _total$1[ebp], ecx

; 3891 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  0020f	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00212	03 45 18	 add	 eax, DWORD PTR _kernel_width$[ebp]
  00215	83 e0 07	 and	 eax, 7
  00218	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  0021b	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  0021e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00220	88 54 05 f0	 mov	 BYTE PTR _buffer$[ebp+eax], dl

; 3892 :                pixels[i] = (unsigned char) (total / 5);

  00224	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  00227	33 d2		 xor	 edx, edx
  00229	b9 05 00 00 00	 mov	 ecx, 5
  0022e	f7 f1		 div	 ecx
  00230	8b 55 08	 mov	 edx, DWORD PTR _pixels$[ebp]
  00233	03 55 cc	 add	 edx, DWORD PTR _i$2[ebp]
  00236	88 02		 mov	 BYTE PTR [edx], al

; 3893 :             }

  00238	eb a8		 jmp	 SHORT $LN16@stbtt__h_p
$LN17@stbtt__h_p:

; 3894 :             break;

  0023a	eb 5d		 jmp	 SHORT $LN5@stbtt__h_p
$LN29@stbtt__h_p:

; 3895 :          default:
; 3896 :             for (i=0; i <= safe_w; ++i) {

  0023c	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00243	eb 09		 jmp	 SHORT $LN21@stbtt__h_p
$LN19@stbtt__h_p:
  00245	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00248	83 c0 01	 add	 eax, 1
  0024b	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN21@stbtt__h_p:
  0024e	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00251	3b 45 e4	 cmp	 eax, DWORD PTR _safe_w$[ebp]
  00254	7f 43		 jg	 SHORT $LN5@stbtt__h_p

; 3897 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  00256	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  00259	03 45 cc	 add	 eax, DWORD PTR _i$2[ebp]
  0025c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0025f	8b 55 cc	 mov	 edx, DWORD PTR _i$2[ebp]
  00262	83 e2 07	 and	 edx, 7
  00265	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _buffer$[ebp+edx]
  0026a	2b c8		 sub	 ecx, eax
  0026c	03 4d c0	 add	 ecx, DWORD PTR _total$1[ebp]
  0026f	89 4d c0	 mov	 DWORD PTR _total$1[ebp], ecx

; 3898 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

  00272	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  00275	03 45 18	 add	 eax, DWORD PTR _kernel_width$[ebp]
  00278	83 e0 07	 and	 eax, 7
  0027b	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  0027e	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  00281	8a 11		 mov	 dl, BYTE PTR [ecx]
  00283	88 54 05 f0	 mov	 BYTE PTR _buffer$[ebp+eax], dl

; 3899 :                pixels[i] = (unsigned char) (total / kernel_width);

  00287	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  0028a	33 d2		 xor	 edx, edx
  0028c	f7 75 18	 div	 DWORD PTR _kernel_width$[ebp]
  0028f	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  00292	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  00295	88 01		 mov	 BYTE PTR [ecx], al

; 3900 :             }

  00297	eb ac		 jmp	 SHORT $LN19@stbtt__h_p
$LN5@stbtt__h_p:

; 3901 :             break;
; 3902 :       }
; 3903 : 
; 3904 :       for (; i < w; ++i) {

  00299	eb 09		 jmp	 SHORT $LN24@stbtt__h_p
$LN22@stbtt__h_p:
  0029b	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  0029e	83 c0 01	 add	 eax, 1
  002a1	89 45 cc	 mov	 DWORD PTR _i$2[ebp], eax
$LN24@stbtt__h_p:
  002a4	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  002a7	3b 45 0c	 cmp	 eax, DWORD PTR _w$[ebp]
  002aa	7d 58		 jge	 SHORT $LN23@stbtt__h_p

; 3905 :          STBTT_assert(pixels[i] == 0);

  002ac	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  002af	03 45 cc	 add	 eax, DWORD PTR _i$2[ebp]
  002b2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002b5	85 c9		 test	 ecx, ecx
  002b7	74 26		 je	 SHORT $LN31@stbtt__h_p
  002b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbtt__h_prefilter@@YAXPAEHHHI@Z@4JA
  002bf	83 c2 34	 add	 edx, 52			; 00000034H
  002c2	8b f4		 mov	 esi, esp
  002c4	52		 push	 edx
  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d8	3b f4		 cmp	 esi, esp
  002da	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN31@stbtt__h_p:

; 3906 :          total -= buffer[i & STBTT__OVER_MASK];

  002df	8b 45 cc	 mov	 eax, DWORD PTR _i$2[ebp]
  002e2	83 e0 07	 and	 eax, 7
  002e5	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _buffer$[ebp+eax]
  002ea	8b 55 c0	 mov	 edx, DWORD PTR _total$1[ebp]
  002ed	2b d1		 sub	 edx, ecx
  002ef	89 55 c0	 mov	 DWORD PTR _total$1[ebp], edx

; 3907 :          pixels[i] = (unsigned char) (total / kernel_width);

  002f2	8b 45 c0	 mov	 eax, DWORD PTR _total$1[ebp]
  002f5	33 d2		 xor	 edx, edx
  002f7	f7 75 18	 div	 DWORD PTR _kernel_width$[ebp]
  002fa	8b 4d 08	 mov	 ecx, DWORD PTR _pixels$[ebp]
  002fd	03 4d cc	 add	 ecx, DWORD PTR _i$2[ebp]
  00300	88 01		 mov	 BYTE PTR [ecx], al

; 3908 :       }

  00302	eb 97		 jmp	 SHORT $LN22@stbtt__h_p
$LN23@stbtt__h_p:

; 3909 : 
; 3910 :       pixels += stride_in_bytes;

  00304	8b 45 08	 mov	 eax, DWORD PTR _pixels$[ebp]
  00307	03 45 14	 add	 eax, DWORD PTR _stride_in_bytes$[ebp]
  0030a	89 45 08	 mov	 DWORD PTR _pixels$[ebp], eax

; 3911 :    }

  0030d	e9 42 fd ff ff	 jmp	 $LN2@stbtt__h_p
$LN1@stbtt__h_p:

; 3912 : }

  00312	52		 push	 edx
  00313	8b cd		 mov	 ecx, ebp
  00315	50		 push	 eax
  00316	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN35@stbtt__h_p
  0031c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00321	58		 pop	 eax
  00322	5a		 pop	 edx
  00323	5f		 pop	 edi
  00324	5e		 pop	 esi
  00325	5b		 pop	 ebx
  00326	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00329	33 cd		 xor	 ecx, ebp
  0032b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00330	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00336	3b ec		 cmp	 ebp, esp
  00338	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0033d	8b e5		 mov	 esp, ebp
  0033f	5d		 pop	 ebp
  00340	c3		 ret	 0
  00341	0f 1f 00	 npad	 3
$LN35@stbtt__h_p:
  00344	01 00 00 00	 DD	 1
  00348	00 00 00 00	 DD	 $LN34@stbtt__h_p
$LN34@stbtt__h_p:
  0034c	f0 ff ff ff	 DD	 -16			; fffffff0H
  00350	08 00 00 00	 DD	 8
  00354	00 00 00 00	 DD	 $LN33@stbtt__h_p
$LN33@stbtt__h_p:
  00358	62		 DB	 98			; 00000062H
  00359	75		 DB	 117			; 00000075H
  0035a	66		 DB	 102			; 00000066H
  0035b	66		 DB	 102			; 00000066H
  0035c	65		 DB	 101			; 00000065H
  0035d	72		 DB	 114			; 00000072H
  0035e	00		 DB	 0
  0035f	90		 npad	 1
$LN32@stbtt__h_p:
  00360	00 00 00 00	 DD	 $LN25@stbtt__h_p
  00364	00 00 00 00	 DD	 $LN26@stbtt__h_p
  00368	00 00 00 00	 DD	 $LN27@stbtt__h_p
  0036c	00 00 00 00	 DD	 $LN28@stbtt__h_p
?stbtt__h_prefilter@@YAXPAEHHHI@Z ENDP			; stbtt__h_prefilter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt_FlattenCurves@@YAPAUstbtt__point@@PAUstbtt_vertex@@HMPAPAHPAHPAX@Z
_TEXT	SEGMENT
tv158 = -308						; size = 4
tv142 = -308						; size = 4
tv91 = -308						; size = 4
_y$1 = -108						; size = 4
_x$2 = -96						; size = 4
_pass$ = -84						; size = 4
_start$ = -72						; size = 4
_n$ = -60						; size = 4
_i$ = -48						; size = 4
_objspace_flatness_squared$ = -36			; size = 4
_num_points$ = -24					; size = 4
_points$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_vertices$ = 8						; size = 4
_num_verts$ = 12					; size = 4
_objspace_flatness$ = 16				; size = 4
_contour_lengths$ = 20					; size = 4
_num_contours$ = 24					; size = 4
_userdata$ = 28						; size = 4
?stbtt_FlattenCurves@@YAPAUstbtt__point@@PAUstbtt_vertex@@HMPAPAHPAHPAX@Z PROC ; stbtt_FlattenCurves, COMDAT

; 3459 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-308]
  00012	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3460 :    stbtt__point *points=0;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _points$[ebp], 0

; 3461 :    int num_points=0;

  00039	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _num_points$[ebp], 0

; 3462 : 
; 3463 :    float objspace_flatness_squared = objspace_flatness * objspace_flatness;

  00040	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _objspace_flatness$[ebp]
  00045	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _objspace_flatness$[ebp]
  0004a	f3 0f 11 45 dc	 movss	 DWORD PTR _objspace_flatness_squared$[ebp], xmm0

; 3464 :    int i,n=0,start=0, pass;

  0004f	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00056	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0

; 3465 : 
; 3466 :    // count how many "moves" there are to get the contour count
; 3467 :    for (i=0; i < num_verts; ++i)

  0005d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00064	eb 09		 jmp	 SHORT $LN4@stbtt_Flat
$LN2@stbtt_Flat:
  00066	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00069	83 c0 01	 add	 eax, 1
  0006c	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt_Flat:
  0006f	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00072	3b 45 0c	 cmp	 eax, DWORD PTR _num_verts$[ebp]
  00075	7d 1c		 jge	 SHORT $LN3@stbtt_Flat

; 3468 :       if (vertices[i].type == STBTT_vmove)

  00077	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  0007e	0f b6 54 01 0c	 movzx	 edx, BYTE PTR [ecx+eax+12]
  00083	83 fa 01	 cmp	 edx, 1
  00086	75 09		 jne	 SHORT $LN13@stbtt_Flat

; 3469 :          ++n;

  00088	8b 45 c4	 mov	 eax, DWORD PTR _n$[ebp]
  0008b	83 c0 01	 add	 eax, 1
  0008e	89 45 c4	 mov	 DWORD PTR _n$[ebp], eax
$LN13@stbtt_Flat:
  00091	eb d3		 jmp	 SHORT $LN2@stbtt_Flat
$LN3@stbtt_Flat:

; 3470 : 
; 3471 :    *num_contours = n;

  00093	8b 45 18	 mov	 eax, DWORD PTR _num_contours$[ebp]
  00096	8b 4d c4	 mov	 ecx, DWORD PTR _n$[ebp]
  00099	89 08		 mov	 DWORD PTR [eax], ecx

; 3472 :    if (n == 0) return 0;

  0009b	83 7d c4 00	 cmp	 DWORD PTR _n$[ebp], 0
  0009f	75 07		 jne	 SHORT $LN14@stbtt_Flat
  000a1	33 c0		 xor	 eax, eax
  000a3	e9 c4 03 00 00	 jmp	 $LN1@stbtt_Flat
$LN14@stbtt_Flat:

; 3473 : 
; 3474 :    *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

  000a8	8b 45 c4	 mov	 eax, DWORD PTR _n$[ebp]
  000ab	c1 e0 02	 shl	 eax, 2
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  000b4	83 c4 04	 add	 esp, 4
  000b7	8b 4d 14	 mov	 ecx, DWORD PTR _contour_lengths$[ebp]
  000ba	89 01		 mov	 DWORD PTR [ecx], eax

; 3475 : 
; 3476 :    if (*contour_lengths == 0) {

  000bc	8b 45 14	 mov	 eax, DWORD PTR _contour_lengths$[ebp]
  000bf	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c2	75 10		 jne	 SHORT $LN15@stbtt_Flat

; 3477 :       *num_contours = 0;

  000c4	8b 45 18	 mov	 eax, DWORD PTR _num_contours$[ebp]
  000c7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 3478 :       return 0;

  000cd	33 c0		 xor	 eax, eax
  000cf	e9 98 03 00 00	 jmp	 $LN1@stbtt_Flat
$LN15@stbtt_Flat:

; 3479 :    }
; 3480 : 
; 3481 :    // make two passes through the points so we don't need to realloc
; 3482 :    for (pass=0; pass < 2; ++pass) {

  000d4	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _pass$[ebp], 0
  000db	eb 09		 jmp	 SHORT $LN7@stbtt_Flat
$LN5@stbtt_Flat:
  000dd	8b 45 ac	 mov	 eax, DWORD PTR _pass$[ebp]
  000e0	83 c0 01	 add	 eax, 1
  000e3	89 45 ac	 mov	 DWORD PTR _pass$[ebp], eax
$LN7@stbtt_Flat:
  000e6	83 7d ac 02	 cmp	 DWORD PTR _pass$[ebp], 2
  000ea	0f 8d 49 03 00
	00		 jge	 $LN6@stbtt_Flat

; 3483 :       float x=0,y=0;

  000f0	0f 57 c0	 xorps	 xmm0, xmm0
  000f3	f3 0f 11 45 a0	 movss	 DWORD PTR _x$2[ebp], xmm0
  000f8	0f 57 c0	 xorps	 xmm0, xmm0
  000fb	f3 0f 11 45 94	 movss	 DWORD PTR _y$1[ebp], xmm0

; 3484 :       if (pass == 1) {

  00100	83 7d ac 01	 cmp	 DWORD PTR _pass$[ebp], 1
  00104	75 22		 jne	 SHORT $LN17@stbtt_Flat

; 3485 :          points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);

  00106	8b 45 e8	 mov	 eax, DWORD PTR _num_points$[ebp]
  00109	c1 e0 03	 shl	 eax, 3
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00112	83 c4 04	 add	 esp, 4
  00115	89 45 f4	 mov	 DWORD PTR _points$[ebp], eax

; 3486 :          if (points == NULL) goto error;

  00118	83 7d f4 00	 cmp	 DWORD PTR _points$[ebp], 0
  0011c	75 0a		 jne	 SHORT $LN17@stbtt_Flat
  0011e	e9 1b 03 00 00	 jmp	 $LN18@stbtt_Flat
  00123	e9 16 03 00 00	 jmp	 $error$29
$LN17@stbtt_Flat:

; 3487 :       }
; 3488 :       num_points = 0;

  00128	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _num_points$[ebp], 0

; 3489 :       n= -1;

  0012f	c7 45 c4 ff ff
	ff ff		 mov	 DWORD PTR _n$[ebp], -1

; 3490 :       for (i=0; i < num_verts; ++i) {

  00136	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0013d	eb 09		 jmp	 SHORT $LN10@stbtt_Flat
$LN8@stbtt_Flat:
  0013f	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00142	83 c0 01	 add	 eax, 1
  00145	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
$LN10@stbtt_Flat:
  00148	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  0014b	3b 45 0c	 cmp	 eax, DWORD PTR _num_verts$[ebp]
  0014e	0f 8d cf 02 00
	00		 jge	 $LN9@stbtt_Flat

; 3491 :          switch (vertices[i].type) {

  00154	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  0015b	0f b6 54 01 0c	 movzx	 edx, BYTE PTR [ecx+eax+12]
  00160	89 95 cc fe ff
	ff		 mov	 DWORD PTR tv91[ebp], edx
  00166	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv91[ebp]
  0016c	83 e8 01	 sub	 eax, 1
  0016f	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv91[ebp], eax
  00175	83 bd cc fe ff
	ff 03		 cmp	 DWORD PTR tv91[ebp], 3
  0017c	0f 87 9c 02 00
	00		 ja	 $LN11@stbtt_Flat
  00182	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv91[ebp]
  00188	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN25@stbtt_Flat[ecx*4]
$LN19@stbtt_Flat:

; 3492 :             case STBTT_vmove:
; 3493 :                // start the next contour
; 3494 :                if (n >= 0)

  0018f	83 7d c4 00	 cmp	 DWORD PTR _n$[ebp], 0
  00193	7c 11		 jl	 SHORT $LN20@stbtt_Flat

; 3495 :                   (*contour_lengths)[n] = num_points - start;

  00195	8b 45 e8	 mov	 eax, DWORD PTR _num_points$[ebp]
  00198	2b 45 b8	 sub	 eax, DWORD PTR _start$[ebp]
  0019b	8b 4d 14	 mov	 ecx, DWORD PTR _contour_lengths$[ebp]
  0019e	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a0	8b 4d c4	 mov	 ecx, DWORD PTR _n$[ebp]
  001a3	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN20@stbtt_Flat:

; 3496 :                ++n;

  001a6	8b 45 c4	 mov	 eax, DWORD PTR _n$[ebp]
  001a9	83 c0 01	 add	 eax, 1
  001ac	89 45 c4	 mov	 DWORD PTR _n$[ebp], eax

; 3497 :                start = num_points;

  001af	8b 45 e8	 mov	 eax, DWORD PTR _num_points$[ebp]
  001b2	89 45 b8	 mov	 DWORD PTR _start$[ebp], eax

; 3498 : 
; 3499 :                x = vertices[i].x, y = vertices[i].y;

  001b5	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  001bc	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  001c0	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  001c4	f3 0f 11 45 a0	 movss	 DWORD PTR _x$2[ebp], xmm0
  001c9	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  001cd	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  001d0	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  001d5	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  001d9	f3 0f 11 45 94	 movss	 DWORD PTR _y$1[ebp], xmm0

; 3500 :                stbtt__add_point(points, num_points++, x,y);

  001de	8b 45 e8	 mov	 eax, DWORD PTR _num_points$[ebp]
  001e1	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv142[ebp], eax
  001e7	8b 4d e8	 mov	 ecx, DWORD PTR _num_points$[ebp]
  001ea	83 c1 01	 add	 ecx, 1
  001ed	89 4d e8	 mov	 DWORD PTR _num_points$[ebp], ecx
  001f0	51		 push	 ecx
  001f1	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _y$1[ebp]
  001f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fb	51		 push	 ecx
  001fc	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _x$2[ebp]
  00201	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00206	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv142[ebp]
  0020c	52		 push	 edx
  0020d	8b 45 f4	 mov	 eax, DWORD PTR _points$[ebp]
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ; stbtt__add_point
  00216	83 c4 10	 add	 esp, 16			; 00000010H

; 3501 :                break;

  00219	e9 00 02 00 00	 jmp	 $LN11@stbtt_Flat
$LN21@stbtt_Flat:

; 3502 :             case STBTT_vline:
; 3503 :                x = vertices[i].x, y = vertices[i].y;

  0021e	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00222	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00225	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00229	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0022d	f3 0f 11 45 a0	 movss	 DWORD PTR _x$2[ebp], xmm0
  00232	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00236	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00239	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  0023e	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00242	f3 0f 11 45 94	 movss	 DWORD PTR _y$1[ebp], xmm0

; 3504 :                stbtt__add_point(points, num_points++, x, y);

  00247	8b 45 e8	 mov	 eax, DWORD PTR _num_points$[ebp]
  0024a	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv158[ebp], eax
  00250	8b 4d e8	 mov	 ecx, DWORD PTR _num_points$[ebp]
  00253	83 c1 01	 add	 ecx, 1
  00256	89 4d e8	 mov	 DWORD PTR _num_points$[ebp], ecx
  00259	51		 push	 ecx
  0025a	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _y$1[ebp]
  0025f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00264	51		 push	 ecx
  00265	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _x$2[ebp]
  0026a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026f	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv158[ebp]
  00275	52		 push	 edx
  00276	8b 45 f4	 mov	 eax, DWORD PTR _points$[ebp]
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ; stbtt__add_point
  0027f	83 c4 10	 add	 esp, 16			; 00000010H

; 3505 :                break;

  00282	e9 97 01 00 00	 jmp	 $LN11@stbtt_Flat
$LN22@stbtt_Flat:

; 3506 :             case STBTT_vcurve:
; 3507 :                stbtt__tesselate_curve(points, &num_points, x,y,

  00287	6a 00		 push	 0
  00289	51		 push	 ecx
  0028a	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  0028f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00294	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00298	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  0029b	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  002a0	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  002a4	51		 push	 ecx
  002a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002aa	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  002ae	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  002b1	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  002b5	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  002b9	51		 push	 ecx
  002ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bf	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  002c3	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  002c6	0f bf 54 01 06	 movsx	 edx, WORD PTR [ecx+eax+6]
  002cb	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  002cf	51		 push	 ecx
  002d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d5	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  002d9	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  002dc	0f bf 54 01 04	 movsx	 edx, WORD PTR [ecx+eax+4]
  002e1	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  002e5	51		 push	 ecx
  002e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002eb	51		 push	 ecx
  002ec	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _y$1[ebp]
  002f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f6	51		 push	 ecx
  002f7	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _x$2[ebp]
  002fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00301	8d 45 e8	 lea	 eax, DWORD PTR _num_points$[ebp]
  00304	50		 push	 eax
  00305	8b 4d f4	 mov	 ecx, DWORD PTR _points$[ebp]
  00308	51		 push	 ecx
  00309	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ; stbtt__tesselate_curve
  0030e	83 c4 28	 add	 esp, 40			; 00000028H

; 3508 :                                         vertices[i].cx, vertices[i].cy,
; 3509 :                                         vertices[i].x,  vertices[i].y,
; 3510 :                                         objspace_flatness_squared, 0);
; 3511 :                x = vertices[i].x, y = vertices[i].y;

  00311	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00315	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00318	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  0031c	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00320	f3 0f 11 45 a0	 movss	 DWORD PTR _x$2[ebp], xmm0
  00325	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00329	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  0032c	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  00331	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00335	f3 0f 11 45 94	 movss	 DWORD PTR _y$1[ebp], xmm0

; 3512 :                break;

  0033a	e9 df 00 00 00	 jmp	 $LN11@stbtt_Flat
$LN23@stbtt_Flat:

; 3513 :             case STBTT_vcubic:
; 3514 :                stbtt__tesselate_cubic(points, &num_points, x,y,

  0033f	6a 00		 push	 0
  00341	51		 push	 ecx
  00342	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  00347	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034c	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00350	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00353	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  00358	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0035c	51		 push	 ecx
  0035d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00362	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00366	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00369	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  0036d	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00371	51		 push	 ecx
  00372	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00377	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  0037b	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  0037e	0f bf 54 01 0a	 movsx	 edx, WORD PTR [ecx+eax+10]
  00383	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00387	51		 push	 ecx
  00388	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038d	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  00391	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00394	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  00399	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0039d	51		 push	 ecx
  0039e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a3	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  003a7	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  003aa	0f bf 54 01 06	 movsx	 edx, WORD PTR [ecx+eax+6]
  003af	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  003b3	51		 push	 ecx
  003b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b9	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  003bd	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  003c0	0f bf 54 01 04	 movsx	 edx, WORD PTR [ecx+eax+4]
  003c5	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  003c9	51		 push	 ecx
  003ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cf	51		 push	 ecx
  003d0	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _y$1[ebp]
  003d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003da	51		 push	 ecx
  003db	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _x$2[ebp]
  003e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003e5	8d 45 e8	 lea	 eax, DWORD PTR _num_points$[ebp]
  003e8	50		 push	 eax
  003e9	8b 4d f4	 mov	 ecx, DWORD PTR _points$[ebp]
  003ec	51		 push	 ecx
  003ed	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic
  003f2	83 c4 30	 add	 esp, 48			; 00000030H

; 3515 :                                         vertices[i].cx, vertices[i].cy,
; 3516 :                                         vertices[i].cx1, vertices[i].cy1,
; 3517 :                                         vertices[i].x,  vertices[i].y,
; 3518 :                                         objspace_flatness_squared, 0);
; 3519 :                x = vertices[i].x, y = vertices[i].y;

  003f5	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  003f9	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  003fc	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  00400	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00404	f3 0f 11 45 a0	 movss	 DWORD PTR _x$2[ebp], xmm0
  00409	6b 45 d0 0e	 imul	 eax, DWORD PTR _i$[ebp], 14
  0040d	8b 4d 08	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00410	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  00415	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00419	f3 0f 11 45 94	 movss	 DWORD PTR _y$1[ebp], xmm0
$LN11@stbtt_Flat:

; 3520 :                break;
; 3521 :          }
; 3522 :       }

  0041e	e9 1c fd ff ff	 jmp	 $LN8@stbtt_Flat
$LN9@stbtt_Flat:

; 3523 :       (*contour_lengths)[n] = num_points - start;

  00423	8b 45 e8	 mov	 eax, DWORD PTR _num_points$[ebp]
  00426	2b 45 b8	 sub	 eax, DWORD PTR _start$[ebp]
  00429	8b 4d 14	 mov	 ecx, DWORD PTR _contour_lengths$[ebp]
  0042c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0042e	8b 4d c4	 mov	 ecx, DWORD PTR _n$[ebp]
  00431	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 3524 :    }

  00434	e9 a4 fc ff ff	 jmp	 $LN5@stbtt_Flat
$LN6@stbtt_Flat:

; 3525 : 
; 3526 :    return points;

  00439	8b 45 f4	 mov	 eax, DWORD PTR _points$[ebp]
  0043c	eb 2e		 jmp	 SHORT $LN1@stbtt_Flat
$LN18@stbtt_Flat:
$error$29:

; 3527 : error:
; 3528 :    STBTT_free(points, userdata);

  0043e	8b 45 f4	 mov	 eax, DWORD PTR _points$[ebp]
  00441	50		 push	 eax
  00442	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00447	83 c4 04	 add	 esp, 4

; 3529 :    STBTT_free(*contour_lengths, userdata);

  0044a	8b 45 14	 mov	 eax, DWORD PTR _contour_lengths$[ebp]
  0044d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0044f	51		 push	 ecx
  00450	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00455	83 c4 04	 add	 esp, 4

; 3530 :    *contour_lengths = 0;

  00458	8b 45 14	 mov	 eax, DWORD PTR _contour_lengths$[ebp]
  0045b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 3531 :    *num_contours = 0;

  00461	8b 45 18	 mov	 eax, DWORD PTR _num_contours$[ebp]
  00464	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 3532 :    return NULL;

  0046a	33 c0		 xor	 eax, eax
$LN1@stbtt_Flat:

; 3533 : }

  0046c	52		 push	 edx
  0046d	8b cd		 mov	 ecx, ebp
  0046f	50		 push	 eax
  00470	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@stbtt_Flat
  00476	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0047b	58		 pop	 eax
  0047c	5a		 pop	 edx
  0047d	5f		 pop	 edi
  0047e	5e		 pop	 esi
  0047f	5b		 pop	 ebx
  00480	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00483	33 cd		 xor	 ecx, ebp
  00485	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0048a	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  00490	3b ec		 cmp	 ebp, esp
  00492	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00497	8b e5		 mov	 esp, ebp
  00499	5d		 pop	 ebp
  0049a	c3		 ret	 0
  0049b	90		 npad	 1
$LN28@stbtt_Flat:
  0049c	01 00 00 00	 DD	 1
  004a0	00 00 00 00	 DD	 $LN27@stbtt_Flat
$LN27@stbtt_Flat:
  004a4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  004a8	04 00 00 00	 DD	 4
  004ac	00 00 00 00	 DD	 $LN26@stbtt_Flat
$LN26@stbtt_Flat:
  004b0	6e		 DB	 110			; 0000006eH
  004b1	75		 DB	 117			; 00000075H
  004b2	6d		 DB	 109			; 0000006dH
  004b3	5f		 DB	 95			; 0000005fH
  004b4	70		 DB	 112			; 00000070H
  004b5	6f		 DB	 111			; 0000006fH
  004b6	69		 DB	 105			; 00000069H
  004b7	6e		 DB	 110			; 0000006eH
  004b8	74		 DB	 116			; 00000074H
  004b9	73		 DB	 115			; 00000073H
  004ba	00		 DB	 0
  004bb	90		 npad	 1
$LN25@stbtt_Flat:
  004bc	00 00 00 00	 DD	 $LN19@stbtt_Flat
  004c0	00 00 00 00	 DD	 $LN21@stbtt_Flat
  004c4	00 00 00 00	 DD	 $LN22@stbtt_Flat
  004c8	00 00 00 00	 DD	 $LN23@stbtt_Flat
?stbtt_FlattenCurves@@YAPAUstbtt__point@@PAUstbtt_vertex@@HMPAPAHPAHPAX@Z ENDP ; stbtt_FlattenCurves
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z
_TEXT	SEGMENT
tv283 = -488						; size = 4
tv358 = -484						; size = 4
tv276 = -480						; size = 4
tv356 = -476						; size = 4
tv269 = -472						; size = 4
_my$1 = -272						; size = 4
_mx$2 = -260						; size = 4
_yb$3 = -248						; size = 4
_xb$4 = -236						; size = 4
_ya$5 = -224						; size = 4
_xa$6 = -212						; size = 4
_y23$7 = -200						; size = 4
_x23$8 = -188						; size = 4
_y12$9 = -176						; size = 4
_x12$10 = -164						; size = 4
_y01$11 = -152						; size = 4
_x01$12 = -140						; size = 4
_flatness_squared$ = -128				; size = 4
_shortlen$ = -116					; size = 4
_longlen$ = -104					; size = 4
_dy$ = -92						; size = 4
_dx$ = -80						; size = 4
_dy2$ = -68						; size = 4
_dx2$ = -56						; size = 4
_dy1$ = -44						; size = 4
_dx1$ = -32						; size = 4
_dy0$ = -20						; size = 4
_dx0$ = -8						; size = 4
_points$ = 8						; size = 4
_num_points$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
_x2$ = 32						; size = 4
_y2$ = 36						; size = 4
_x3$ = 40						; size = 4
_y3$ = 44						; size = 4
_objspace_flatness_squared$ = 48			; size = 4
_n$ = 52						; size = 4
?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z PROC ; stbtt__tesselate_cubic, COMDAT

; 3416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 01 00
	00		 sub	 esp, 488		; 000001e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-488]
  00012	b9 7a 00 00 00	 mov	 ecx, 122		; 0000007aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3417 :    // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
; 3418 :    float dx0 = x1-x0;

  00028	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _x1$[ebp]
  0002d	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _x0$[ebp]
  00032	f3 0f 11 45 f8	 movss	 DWORD PTR _dx0$[ebp], xmm0

; 3419 :    float dy0 = y1-y0;

  00037	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _y1$[ebp]
  0003c	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _y0$[ebp]
  00041	f3 0f 11 45 ec	 movss	 DWORD PTR _dy0$[ebp], xmm0

; 3420 :    float dx1 = x2-x1;

  00046	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _x2$[ebp]
  0004b	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _x1$[ebp]
  00050	f3 0f 11 45 e0	 movss	 DWORD PTR _dx1$[ebp], xmm0

; 3421 :    float dy1 = y2-y1;

  00055	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _y2$[ebp]
  0005a	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _y1$[ebp]
  0005f	f3 0f 11 45 d4	 movss	 DWORD PTR _dy1$[ebp], xmm0

; 3422 :    float dx2 = x3-x2;

  00064	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _x3$[ebp]
  00069	f3 0f 5c 45 20	 subss	 xmm0, DWORD PTR _x2$[ebp]
  0006e	f3 0f 11 45 c8	 movss	 DWORD PTR _dx2$[ebp], xmm0

; 3423 :    float dy2 = y3-y2;

  00073	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _y3$[ebp]
  00078	f3 0f 5c 45 24	 subss	 xmm0, DWORD PTR _y2$[ebp]
  0007d	f3 0f 11 45 bc	 movss	 DWORD PTR _dy2$[ebp], xmm0

; 3424 :    float dx = x3-x0;

  00082	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _x3$[ebp]
  00087	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _x0$[ebp]
  0008c	f3 0f 11 45 b0	 movss	 DWORD PTR _dx$[ebp], xmm0

; 3425 :    float dy = y3-y0;

  00091	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _y3$[ebp]
  00096	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _y0$[ebp]
  0009b	f3 0f 11 45 a4	 movss	 DWORD PTR _dy$[ebp], xmm0

; 3426 :    float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));

  000a0	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _dx0$[ebp]
  000a5	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _dx0$[ebp]
  000aa	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _dy0$[ebp]
  000af	f3 0f 59 4d ec	 mulss	 xmm1, DWORD PTR _dy0$[ebp]
  000b4	f3 0f 58 c1	 addss	 xmm0, xmm1
  000b8	51		 push	 ecx
  000b9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000be	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  000c3	83 c4 04	 add	 esp, 4
  000c6	d9 9d 28 fe ff
	ff		 fstp	 DWORD PTR tv269[ebp]
  000cc	f3 0f 10 85 28
	fe ff ff	 movss	 xmm0, DWORD PTR tv269[ebp]
  000d4	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _dx1$[ebp]
  000d9	f3 0f 59 4d e0	 mulss	 xmm1, DWORD PTR _dx1$[ebp]
  000de	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _dy1$[ebp]
  000e3	f3 0f 59 55 d4	 mulss	 xmm2, DWORD PTR _dy1$[ebp]
  000e8	f3 0f 58 ca	 addss	 xmm1, xmm2
  000ec	51		 push	 ecx
  000ed	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  000f2	f3 0f 11 85 24
	fe ff ff	 movss	 DWORD PTR tv356[ebp], xmm0
  000fa	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  000ff	83 c4 04	 add	 esp, 4
  00102	d9 9d 20 fe ff
	ff		 fstp	 DWORD PTR tv276[ebp]
  00108	f3 0f 10 85 24
	fe ff ff	 movss	 xmm0, DWORD PTR tv356[ebp]
  00110	f3 0f 58 85 20
	fe ff ff	 addss	 xmm0, DWORD PTR tv276[ebp]
  00118	f3 0f 10 4d c8	 movss	 xmm1, DWORD PTR _dx2$[ebp]
  0011d	f3 0f 59 4d c8	 mulss	 xmm1, DWORD PTR _dx2$[ebp]
  00122	f3 0f 10 55 bc	 movss	 xmm2, DWORD PTR _dy2$[ebp]
  00127	f3 0f 59 55 bc	 mulss	 xmm2, DWORD PTR _dy2$[ebp]
  0012c	f3 0f 58 ca	 addss	 xmm1, xmm2
  00130	51		 push	 ecx
  00131	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00136	f3 0f 11 85 1c
	fe ff ff	 movss	 DWORD PTR tv358[ebp], xmm0
  0013e	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  00143	83 c4 04	 add	 esp, 4
  00146	d9 9d 18 fe ff
	ff		 fstp	 DWORD PTR tv283[ebp]
  0014c	f3 0f 10 85 1c
	fe ff ff	 movss	 xmm0, DWORD PTR tv358[ebp]
  00154	f3 0f 58 85 18
	fe ff ff	 addss	 xmm0, DWORD PTR tv283[ebp]
  0015c	f3 0f 11 45 98	 movss	 DWORD PTR _longlen$[ebp], xmm0

; 3427 :    float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);

  00161	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _dx$[ebp]
  00166	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR _dx$[ebp]
  0016b	f3 0f 10 4d a4	 movss	 xmm1, DWORD PTR _dy$[ebp]
  00170	f3 0f 59 4d a4	 mulss	 xmm1, DWORD PTR _dy$[ebp]
  00175	f3 0f 58 c1	 addss	 xmm0, xmm1
  00179	51		 push	 ecx
  0017a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017f	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  00184	83 c4 04	 add	 esp, 4
  00187	d9 5d 8c	 fstp	 DWORD PTR _shortlen$[ebp]

; 3428 :    float flatness_squared = longlen*longlen-shortlen*shortlen;

  0018a	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _longlen$[ebp]
  0018f	f3 0f 59 45 98	 mulss	 xmm0, DWORD PTR _longlen$[ebp]
  00194	f3 0f 10 4d 8c	 movss	 xmm1, DWORD PTR _shortlen$[ebp]
  00199	f3 0f 59 4d 8c	 mulss	 xmm1, DWORD PTR _shortlen$[ebp]
  0019e	f3 0f 5c c1	 subss	 xmm0, xmm1
  001a2	f3 0f 11 45 80	 movss	 DWORD PTR _flatness_squared$[ebp], xmm0

; 3429 : 
; 3430 :    if (n > 16) // 65536 segments on one curve better be enough!

  001a7	83 7d 34 10	 cmp	 DWORD PTR _n$[ebp], 16	; 00000010H
  001ab	7e 05		 jle	 SHORT $LN2@stbtt__tes

; 3431 :       return;

  001ad	e9 ba 02 00 00	 jmp	 $LN1@stbtt__tes
$LN2@stbtt__tes:

; 3432 : 
; 3433 :    if (flatness_squared > objspace_flatness_squared) {

  001b2	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _flatness_squared$[ebp]
  001b7	0f 2f 45 30	 comiss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  001bb	0f 86 76 02 00
	00		 jbe	 $LN3@stbtt__tes

; 3434 :       float x01 = (x0+x1)/2;

  001c1	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x0$[ebp]
  001c6	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _x1$[ebp]
  001cb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  001d3	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _x01$12[ebp], xmm0

; 3435 :       float y01 = (y0+y1)/2;

  001db	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y0$[ebp]
  001e0	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _y1$[ebp]
  001e5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  001ed	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _y01$11[ebp], xmm0

; 3436 :       float x12 = (x1+x2)/2;

  001f5	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _x1$[ebp]
  001fa	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _x2$[ebp]
  001ff	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00207	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _x12$10[ebp], xmm0

; 3437 :       float y12 = (y1+y2)/2;

  0020f	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00214	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _y2$[ebp]
  00219	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00221	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _y12$9[ebp], xmm0

; 3438 :       float x23 = (x2+x3)/2;

  00229	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _x2$[ebp]
  0022e	f3 0f 58 45 28	 addss	 xmm0, DWORD PTR _x3$[ebp]
  00233	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0023b	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _x23$8[ebp], xmm0

; 3439 :       float y23 = (y2+y3)/2;

  00243	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _y2$[ebp]
  00248	f3 0f 58 45 2c	 addss	 xmm0, DWORD PTR _y3$[ebp]
  0024d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00255	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _y23$7[ebp], xmm0

; 3440 : 
; 3441 :       float xa = (x01+x12)/2;

  0025d	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _x01$12[ebp]
  00265	f3 0f 58 85 5c
	ff ff ff	 addss	 xmm0, DWORD PTR _x12$10[ebp]
  0026d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00275	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _xa$6[ebp], xmm0

; 3442 :       float ya = (y01+y12)/2;

  0027d	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _y01$11[ebp]
  00285	f3 0f 58 85 50
	ff ff ff	 addss	 xmm0, DWORD PTR _y12$9[ebp]
  0028d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00295	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _ya$5[ebp], xmm0

; 3443 :       float xb = (x12+x23)/2;

  0029d	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _x12$10[ebp]
  002a5	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _x23$8[ebp]
  002ad	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  002b5	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _xb$4[ebp], xmm0

; 3444 :       float yb = (y12+y23)/2;

  002bd	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _y12$9[ebp]
  002c5	f3 0f 58 85 38
	ff ff ff	 addss	 xmm0, DWORD PTR _y23$7[ebp]
  002cd	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  002d5	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _yb$3[ebp], xmm0

; 3445 : 
; 3446 :       float mx = (xa+xb)/2;

  002dd	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _xa$6[ebp]
  002e5	f3 0f 58 85 14
	ff ff ff	 addss	 xmm0, DWORD PTR _xb$4[ebp]
  002ed	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  002f5	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _mx$2[ebp], xmm0

; 3447 :       float my = (ya+yb)/2;

  002fd	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _ya$5[ebp]
  00305	f3 0f 58 85 08
	ff ff ff	 addss	 xmm0, DWORD PTR _yb$3[ebp]
  0030d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00315	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _my$1[ebp], xmm0

; 3448 : 
; 3449 :       stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);

  0031d	8b 45 34	 mov	 eax, DWORD PTR _n$[ebp]
  00320	83 c0 01	 add	 eax, 1
  00323	50		 push	 eax
  00324	51		 push	 ecx
  00325	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  0032a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0032f	51		 push	 ecx
  00330	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _my$1[ebp]
  00338	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0033d	51		 push	 ecx
  0033e	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _mx$2[ebp]
  00346	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034b	51		 push	 ecx
  0034c	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _ya$5[ebp]
  00354	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00359	51		 push	 ecx
  0035a	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _xa$6[ebp]
  00362	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00367	51		 push	 ecx
  00368	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _y01$11[ebp]
  00370	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00375	51		 push	 ecx
  00376	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _x01$12[ebp]
  0037e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00383	51		 push	 ecx
  00384	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y0$[ebp]
  00389	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038e	51		 push	 ecx
  0038f	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x0$[ebp]
  00394	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00399	8b 4d 0c	 mov	 ecx, DWORD PTR _num_points$[ebp]
  0039c	51		 push	 ecx
  0039d	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  003a0	52		 push	 edx
  003a1	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic
  003a6	83 c4 30	 add	 esp, 48			; 00000030H

; 3450 :       stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);

  003a9	8b 45 34	 mov	 eax, DWORD PTR _n$[ebp]
  003ac	83 c0 01	 add	 eax, 1
  003af	50		 push	 eax
  003b0	51		 push	 ecx
  003b1	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  003b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003bb	51		 push	 ecx
  003bc	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _y3$[ebp]
  003c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c6	51		 push	 ecx
  003c7	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _x3$[ebp]
  003cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d1	51		 push	 ecx
  003d2	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _y23$7[ebp]
  003da	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003df	51		 push	 ecx
  003e0	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _x23$8[ebp]
  003e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ed	51		 push	 ecx
  003ee	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _yb$3[ebp]
  003f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fb	51		 push	 ecx
  003fc	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _xb$4[ebp]
  00404	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00409	51		 push	 ecx
  0040a	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _my$1[ebp]
  00412	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00417	51		 push	 ecx
  00418	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _mx$2[ebp]
  00420	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00425	8b 4d 0c	 mov	 ecx, DWORD PTR _num_points$[ebp]
  00428	51		 push	 ecx
  00429	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  0042c	52		 push	 edx
  0042d	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic
  00432	83 c4 30	 add	 esp, 48			; 00000030H

; 3451 :    } else {

  00435	eb 35		 jmp	 SHORT $LN4@stbtt__tes
$LN3@stbtt__tes:

; 3452 :       stbtt__add_point(points, *num_points,x3,y3);

  00437	51		 push	 ecx
  00438	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _y3$[ebp]
  0043d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00442	51		 push	 ecx
  00443	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _x3$[ebp]
  00448	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0044d	8b 45 0c	 mov	 eax, DWORD PTR _num_points$[ebp]
  00450	8b 08		 mov	 ecx, DWORD PTR [eax]
  00452	51		 push	 ecx
  00453	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  00456	52		 push	 edx
  00457	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ; stbtt__add_point
  0045c	83 c4 10	 add	 esp, 16			; 00000010H

; 3453 :       *num_points = *num_points+1;

  0045f	8b 45 0c	 mov	 eax, DWORD PTR _num_points$[ebp]
  00462	8b 08		 mov	 ecx, DWORD PTR [eax]
  00464	83 c1 01	 add	 ecx, 1
  00467	8b 55 0c	 mov	 edx, DWORD PTR _num_points$[ebp]
  0046a	89 0a		 mov	 DWORD PTR [edx], ecx
$LN4@stbtt__tes:
$LN1@stbtt__tes:

; 3454 :    }
; 3455 : }

  0046c	5f		 pop	 edi
  0046d	5e		 pop	 esi
  0046e	5b		 pop	 ebx
  0046f	81 c4 e8 01 00
	00		 add	 esp, 488		; 000001e8H
  00475	3b ec		 cmp	 ebp, esp
  00477	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0047c	8b e5		 mov	 esp, ebp
  0047e	5d		 pop	 ebp
  0047f	c3		 ret	 0
?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z ENDP ; stbtt__tesselate_cubic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z
_TEXT	SEGMENT
_dy$ = -44						; size = 4
_dx$ = -32						; size = 4
_my$ = -20						; size = 4
_mx$ = -8						; size = 4
_points$ = 8						; size = 4
_num_points$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
_x2$ = 32						; size = 4
_y2$ = 36						; size = 4
_objspace_flatness_squared$ = 40			; size = 4
_n$ = 44						; size = 4
?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z PROC ; stbtt__tesselate_curve, COMDAT

; 3396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3397 :    // midpoint
; 3398 :    float mx = (x0 + 2*x1 + x2)/4;

  00028	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00030	f3 0f 59 45 18	 mulss	 xmm0, DWORD PTR _x1$[ebp]
  00035	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _x0$[ebp]
  0003a	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _x2$[ebp]
  0003f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  00047	f3 0f 11 45 f8	 movss	 DWORD PTR _mx$[ebp], xmm0

; 3399 :    float my = (y0 + 2*y1 + y2)/4;

  0004c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00054	f3 0f 59 45 1c	 mulss	 xmm0, DWORD PTR _y1$[ebp]
  00059	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _y0$[ebp]
  0005e	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _y2$[ebp]
  00063	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  0006b	f3 0f 11 45 ec	 movss	 DWORD PTR _my$[ebp], xmm0

; 3400 :    // versus directly drawn line
; 3401 :    float dx = (x0+x2)/2 - mx;

  00070	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x0$[ebp]
  00075	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _x2$[ebp]
  0007a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00082	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _mx$[ebp]
  00087	f3 0f 11 45 e0	 movss	 DWORD PTR _dx$[ebp], xmm0

; 3402 :    float dy = (y0+y2)/2 - my;

  0008c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y0$[ebp]
  00091	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _y2$[ebp]
  00096	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0009e	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _my$[ebp]
  000a3	f3 0f 11 45 d4	 movss	 DWORD PTR _dy$[ebp], xmm0

; 3403 :    if (n > 16) // 65536 segments on one curve better be enough!

  000a8	83 7d 2c 10	 cmp	 DWORD PTR _n$[ebp], 16	; 00000010H
  000ac	7e 0a		 jle	 SHORT $LN2@stbtt__tes

; 3404 :       return 1;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	e9 5a 01 00 00	 jmp	 $LN1@stbtt__tes
$LN2@stbtt__tes:

; 3405 :    if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA

  000b8	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _dx$[ebp]
  000bd	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _dx$[ebp]
  000c2	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR _dy$[ebp]
  000c7	f3 0f 59 4d d4	 mulss	 xmm1, DWORD PTR _dy$[ebp]
  000cc	f3 0f 58 c1	 addss	 xmm0, xmm1
  000d0	0f 2f 45 28	 comiss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  000d4	0f 86 fe 00 00
	00		 jbe	 $LN3@stbtt__tes

; 3406 :       stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);

  000da	8b 45 2c	 mov	 eax, DWORD PTR _n$[ebp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	50		 push	 eax
  000e1	51		 push	 ecx
  000e2	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  000e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ec	51		 push	 ecx
  000ed	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _my$[ebp]
  000f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f7	51		 push	 ecx
  000f8	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _mx$[ebp]
  000fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00102	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y0$[ebp]
  00107	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _y1$[ebp]
  0010c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00114	51		 push	 ecx
  00115	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011a	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x0$[ebp]
  0011f	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _x1$[ebp]
  00124	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0012c	51		 push	 ecx
  0012d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00132	51		 push	 ecx
  00133	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y0$[ebp]
  00138	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013d	51		 push	 ecx
  0013e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x0$[ebp]
  00143	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00148	8b 4d 0c	 mov	 ecx, DWORD PTR _num_points$[ebp]
  0014b	51		 push	 ecx
  0014c	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ; stbtt__tesselate_curve
  00155	83 c4 28	 add	 esp, 40			; 00000028H

; 3407 :       stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);

  00158	8b 45 2c	 mov	 eax, DWORD PTR _n$[ebp]
  0015b	83 c0 01	 add	 eax, 1
  0015e	50		 push	 eax
  0015f	51		 push	 ecx
  00160	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
  00165	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016a	51		 push	 ecx
  0016b	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _y2$[ebp]
  00170	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00175	51		 push	 ecx
  00176	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _x2$[ebp]
  0017b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00180	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00185	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _y2$[ebp]
  0018a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00192	51		 push	 ecx
  00193	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00198	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _x1$[ebp]
  0019d	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _x2$[ebp]
  001a2	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  001aa	51		 push	 ecx
  001ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b0	51		 push	 ecx
  001b1	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _my$[ebp]
  001b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bb	51		 push	 ecx
  001bc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _mx$[ebp]
  001c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c6	8b 4d 0c	 mov	 ecx, DWORD PTR _num_points$[ebp]
  001c9	51		 push	 ecx
  001ca	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  001cd	52		 push	 edx
  001ce	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ; stbtt__tesselate_curve
  001d3	83 c4 28	 add	 esp, 40			; 00000028H

; 3408 :    } else {

  001d6	eb 35		 jmp	 SHORT $LN4@stbtt__tes
$LN3@stbtt__tes:

; 3409 :       stbtt__add_point(points, *num_points,x2,y2);

  001d8	51		 push	 ecx
  001d9	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _y2$[ebp]
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	51		 push	 ecx
  001e4	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _x2$[ebp]
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	8b 45 0c	 mov	 eax, DWORD PTR _num_points$[ebp]
  001f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f3	51		 push	 ecx
  001f4	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  001f7	52		 push	 edx
  001f8	e8 00 00 00 00	 call	 ?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ; stbtt__add_point
  001fd	83 c4 10	 add	 esp, 16			; 00000010H

; 3410 :       *num_points = *num_points+1;

  00200	8b 45 0c	 mov	 eax, DWORD PTR _num_points$[ebp]
  00203	8b 08		 mov	 ecx, DWORD PTR [eax]
  00205	83 c1 01	 add	 ecx, 1
  00208	8b 55 0c	 mov	 edx, DWORD PTR _num_points$[ebp]
  0020b	89 0a		 mov	 DWORD PTR [edx], ecx
$LN4@stbtt__tes:

; 3411 :    }
; 3412 :    return 1;

  0020d	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt__tes:

; 3413 : }

  00212	5f		 pop	 edi
  00213	5e		 pop	 esi
  00214	5b		 pop	 ebx
  00215	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0021b	3b ec		 cmp	 ebp, esp
  0021d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ENDP ; stbtt__tesselate_curve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z
_TEXT	SEGMENT
_points$ = 8						; size = 4
_n$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z PROC	; stbtt__add_point, COMDAT

; 3388 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3389 :    if (!points) return; // during first pass, it's unallocated

  00028	83 7d 08 00	 cmp	 DWORD PTR _points$[ebp], 0
  0002c	75 02		 jne	 SHORT $LN2@stbtt__add
  0002e	eb 21		 jmp	 SHORT $LN1@stbtt__add
$LN2@stbtt__add:

; 3390 :    points[n].x = x;

  00030	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00036	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _x$[ebp]
  0003b	f3 0f 11 04 c1	 movss	 DWORD PTR [ecx+eax*8], xmm0

; 3391 :    points[n].y = y;

  00040	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00046	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _y$[ebp]
  0004b	f3 0f 11 44 c1
	04		 movss	 DWORD PTR [ecx+eax*8+4], xmm0
$LN1@stbtt__add:

; 3392 : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ENDP	; stbtt__add_point
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__rasterize@@YAXPAUstbtt__bitmap@@PAUstbtt__point@@PAHHMMMMHHHPAX@Z
_TEXT	SEGMENT
tv147 = -336						; size = 4
tv150 = -332						; size = 4
tv148 = -328						; size = 4
tv66 = -328						; size = 4
_b$1 = -128						; size = 4
_a$2 = -116						; size = 4
_p$3 = -104						; size = 4
_vsubsample$ = -92					; size = 4
_m$ = -80						; size = 4
_k$ = -68						; size = 4
_j$ = -56						; size = 4
_i$ = -44						; size = 4
_n$ = -32						; size = 4
_e$ = -20						; size = 4
_y_scale_inv$ = -8					; size = 4
_result$ = 8						; size = 4
_pts$ = 12						; size = 4
_wcount$ = 16						; size = 4
_windings$ = 20						; size = 4
_scale_x$ = 24						; size = 4
_scale_y$ = 28						; size = 4
_shift_x$ = 32						; size = 4
_shift_y$ = 36						; size = 4
_off_x$ = 40						; size = 4
_off_y$ = 44						; size = 4
_invert$ = 48						; size = 4
_userdata$ = 52						; size = 4
?stbtt__rasterize@@YAXPAUstbtt__bitmap@@PAUstbtt__point@@PAHHMMMMHHHPAX@Z PROC ; stbtt__rasterize, COMDAT

; 3331 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-336]
  00012	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3332 :    float y_scale_inv = invert ? -scale_y : scale_y;

  00028	83 7d 30 00	 cmp	 DWORD PTR _invert$[ebp], 0
  0002c	74 16		 je	 SHORT $LN15@stbtt__ras
  0002e	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_y$[ebp]
  00033	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0003a	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
  00042	eb 0d		 jmp	 SHORT $LN16@stbtt__ras
$LN15@stbtt__ras:
  00044	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_y$[ebp]
  00049	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR tv66[ebp], xmm0
$LN16@stbtt__ras:
  00051	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR tv66[ebp]
  00059	f3 0f 11 45 f8	 movss	 DWORD PTR _y_scale_inv$[ebp], xmm0

; 3333 :    stbtt__edge *e;
; 3334 :    int n,i,j,k,m;
; 3335 : #if STBTT_RASTERIZER_VERSION == 1
; 3336 :    int vsubsample = result->h < 8 ? 15 : 5;
; 3337 : #elif STBTT_RASTERIZER_VERSION == 2
; 3338 :    int vsubsample = 1;

  0005e	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR _vsubsample$[ebp], 1

; 3339 : #else
; 3340 :    #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 3341 : #endif
; 3342 :    // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 3343 : 
; 3344 :    // now we have to blow out the windings into explicit edge lists
; 3345 :    n = 0;

  00065	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 3346 :    for (i=0; i < windings; ++i)

  0006c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN4@stbtt__ras
$LN2@stbtt__ras:
  00075	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt__ras:
  0007e	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00081	3b 45 14	 cmp	 eax, DWORD PTR _windings$[ebp]
  00084	7d 11		 jge	 SHORT $LN3@stbtt__ras

; 3347 :       n += wcount[i];

  00086	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00089	8b 4d 10	 mov	 ecx, DWORD PTR _wcount$[ebp]
  0008c	8b 55 e0	 mov	 edx, DWORD PTR _n$[ebp]
  0008f	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00092	89 55 e0	 mov	 DWORD PTR _n$[ebp], edx
  00095	eb de		 jmp	 SHORT $LN2@stbtt__ras
$LN3@stbtt__ras:

; 3348 : 
; 3349 :    e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel

  00097	8b 45 e0	 mov	 eax, DWORD PTR _n$[ebp]
  0009a	83 c0 01	 add	 eax, 1
  0009d	6b c8 14	 imul	 ecx, eax, 20
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  000a6	83 c4 04	 add	 esp, 4
  000a9	89 45 ec	 mov	 DWORD PTR _e$[ebp], eax

; 3350 :    if (e == 0) return;

  000ac	83 7d ec 00	 cmp	 DWORD PTR _e$[ebp], 0
  000b0	75 05		 jne	 SHORT $LN11@stbtt__ras
  000b2	e9 4a 02 00 00	 jmp	 $LN1@stbtt__ras
$LN11@stbtt__ras:

; 3351 :    n = 0;

  000b7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 3352 : 
; 3353 :    m=0;

  000be	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _m$[ebp], 0

; 3354 :    for (i=0; i < windings; ++i) {

  000c5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cc	eb 09		 jmp	 SHORT $LN7@stbtt__ras
$LN5@stbtt__ras:
  000ce	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000d1	83 c0 01	 add	 eax, 1
  000d4	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN7@stbtt__ras:
  000d7	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000da	3b 45 14	 cmp	 eax, DWORD PTR _windings$[ebp]
  000dd	0f 8d de 01 00
	00		 jge	 $LN6@stbtt__ras

; 3355 :       stbtt__point *p = pts + m;

  000e3	8b 45 b0	 mov	 eax, DWORD PTR _m$[ebp]
  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _pts$[ebp]
  000e9	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  000ec	89 55 98	 mov	 DWORD PTR _p$3[ebp], edx

; 3356 :       m += wcount[i];

  000ef	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000f2	8b 4d 10	 mov	 ecx, DWORD PTR _wcount$[ebp]
  000f5	8b 55 b0	 mov	 edx, DWORD PTR _m$[ebp]
  000f8	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000fb	89 55 b0	 mov	 DWORD PTR _m$[ebp], edx

; 3357 :       j = wcount[i]-1;

  000fe	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00101	8b 4d 10	 mov	 ecx, DWORD PTR _wcount$[ebp]
  00104	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00107	83 ea 01	 sub	 edx, 1
  0010a	89 55 c8	 mov	 DWORD PTR _j$[ebp], edx

; 3358 :       for (k=0; k < wcount[i]; j=k++) {

  0010d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00114	eb 0f		 jmp	 SHORT $LN10@stbtt__ras
$LN8@stbtt__ras:
  00116	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  00119	89 45 c8	 mov	 DWORD PTR _j$[ebp], eax
  0011c	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx
$LN10@stbtt__ras:
  00125	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00128	8b 4d 10	 mov	 ecx, DWORD PTR _wcount$[ebp]
  0012b	8b 55 bc	 mov	 edx, DWORD PTR _k$[ebp]
  0012e	3b 14 81	 cmp	 edx, DWORD PTR [ecx+eax*4]
  00131	0f 8d 85 01 00
	00		 jge	 $LN9@stbtt__ras

; 3359 :          int a=k,b=j;

  00137	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  0013a	89 45 8c	 mov	 DWORD PTR _a$2[ebp], eax
  0013d	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  00140	89 45 80	 mov	 DWORD PTR _b$1[ebp], eax

; 3360 :          // skip the edge if horizontal
; 3361 :          if (p[j].y == p[k].y)

  00143	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  00146	8b 4d 98	 mov	 ecx, DWORD PTR _p$3[ebp]
  00149	8b 55 bc	 mov	 edx, DWORD PTR _k$[ebp]
  0014c	8b 75 98	 mov	 esi, DWORD PTR _p$3[ebp]
  0014f	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00155	0f 2e 44 d6 04	 ucomiss xmm0, DWORD PTR [esi+edx*8+4]
  0015a	9f		 lahf
  0015b	f6 c4 44	 test	 ah, 68			; 00000044H
  0015e	7a 02		 jp	 SHORT $LN12@stbtt__ras

; 3362 :             continue;

  00160	eb b4		 jmp	 SHORT $LN8@stbtt__ras
$LN12@stbtt__ras:

; 3363 :          // add edge from j to k to the list
; 3364 :          e[n].invert = 0;

  00162	6b 45 e0 14	 imul	 eax, DWORD PTR _n$[ebp], 20
  00166	8b 4d ec	 mov	 ecx, DWORD PTR _e$[ebp]
  00169	c7 44 01 10 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 0

; 3365 :          if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {

  00171	83 7d 30 00	 cmp	 DWORD PTR _invert$[ebp], 0
  00175	74 3d		 je	 SHORT $LN21@stbtt__ras
  00177	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  0017a	8b 4d 98	 mov	 ecx, DWORD PTR _p$3[ebp]
  0017d	8b 55 bc	 mov	 edx, DWORD PTR _k$[ebp]
  00180	8b 75 98	 mov	 esi, DWORD PTR _p$3[ebp]
  00183	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00189	0f 2f 44 d6 04	 comiss	 xmm0, DWORD PTR [esi+edx*8+4]
  0018e	76 0c		 jbe	 SHORT $LN19@stbtt__ras
  00190	c7 85 b8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv148[ebp], 1
  0019a	eb 0a		 jmp	 SHORT $LN20@stbtt__ras
$LN19@stbtt__ras:
  0019c	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
$LN20@stbtt__ras:
  001a6	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  001ac	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv150[ebp], eax
  001b2	eb 3b		 jmp	 SHORT $LN22@stbtt__ras
$LN21@stbtt__ras:
  001b4	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  001b7	8b 55 98	 mov	 edx, DWORD PTR _p$3[ebp]
  001ba	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  001bd	8b 75 98	 mov	 esi, DWORD PTR _p$3[ebp]
  001c0	f3 0f 10 44 ca
	04		 movss	 xmm0, DWORD PTR [edx+ecx*8+4]
  001c6	0f 2f 44 c6 04	 comiss	 xmm0, DWORD PTR [esi+eax*8+4]
  001cb	76 0c		 jbe	 SHORT $LN17@stbtt__ras
  001cd	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv147[ebp], 1
  001d7	eb 0a		 jmp	 SHORT $LN18@stbtt__ras
$LN17@stbtt__ras:
  001d9	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv147[ebp], 0
$LN18@stbtt__ras:
  001e3	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv147[ebp]
  001e9	89 8d b4 fe ff
	ff		 mov	 DWORD PTR tv150[ebp], ecx
$LN22@stbtt__ras:
  001ef	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR tv150[ebp], 0
  001f6	74 1b		 je	 SHORT $LN13@stbtt__ras

; 3366 :             e[n].invert = 1;

  001f8	6b 45 e0 14	 imul	 eax, DWORD PTR _n$[ebp], 20
  001fc	8b 4d ec	 mov	 ecx, DWORD PTR _e$[ebp]
  001ff	c7 44 01 10 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+16], 1

; 3367 :             a=j,b=k;

  00207	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  0020a	89 45 8c	 mov	 DWORD PTR _a$2[ebp], eax
  0020d	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  00210	89 4d 80	 mov	 DWORD PTR _b$1[ebp], ecx
$LN13@stbtt__ras:

; 3368 :          }
; 3369 :          e[n].x0 = p[a].x * scale_x + shift_x;

  00213	8b 45 8c	 mov	 eax, DWORD PTR _a$2[ebp]
  00216	8b 4d 98	 mov	 ecx, DWORD PTR _p$3[ebp]
  00219	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  0021e	f3 0f 59 45 18	 mulss	 xmm0, DWORD PTR _scale_x$[ebp]
  00223	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _shift_x$[ebp]
  00228	6b 55 e0 14	 imul	 edx, DWORD PTR _n$[ebp], 20
  0022c	8b 45 ec	 mov	 eax, DWORD PTR _e$[ebp]
  0022f	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 3370 :          e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;

  00234	8b 45 8c	 mov	 eax, DWORD PTR _a$2[ebp]
  00237	8b 4d 98	 mov	 ecx, DWORD PTR _p$3[ebp]
  0023a	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00240	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _y_scale_inv$[ebp]
  00245	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _shift_y$[ebp]
  0024a	f3 0f 2a 4d a4	 cvtsi2ss xmm1, DWORD PTR _vsubsample$[ebp]
  0024f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00253	6b 55 e0 14	 imul	 edx, DWORD PTR _n$[ebp], 20
  00257	8b 45 ec	 mov	 eax, DWORD PTR _e$[ebp]
  0025a	f3 0f 11 44 10
	04		 movss	 DWORD PTR [eax+edx+4], xmm0

; 3371 :          e[n].x1 = p[b].x * scale_x + shift_x;

  00260	8b 45 80	 mov	 eax, DWORD PTR _b$1[ebp]
  00263	8b 4d 98	 mov	 ecx, DWORD PTR _p$3[ebp]
  00266	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  0026b	f3 0f 59 45 18	 mulss	 xmm0, DWORD PTR _scale_x$[ebp]
  00270	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _shift_x$[ebp]
  00275	6b 55 e0 14	 imul	 edx, DWORD PTR _n$[ebp], 20
  00279	8b 45 ec	 mov	 eax, DWORD PTR _e$[ebp]
  0027c	f3 0f 11 44 10
	08		 movss	 DWORD PTR [eax+edx+8], xmm0

; 3372 :          e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;

  00282	8b 45 80	 mov	 eax, DWORD PTR _b$1[ebp]
  00285	8b 4d 98	 mov	 ecx, DWORD PTR _p$3[ebp]
  00288	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  0028e	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _y_scale_inv$[ebp]
  00293	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR _shift_y$[ebp]
  00298	f3 0f 2a 4d a4	 cvtsi2ss xmm1, DWORD PTR _vsubsample$[ebp]
  0029d	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002a1	6b 55 e0 14	 imul	 edx, DWORD PTR _n$[ebp], 20
  002a5	8b 45 ec	 mov	 eax, DWORD PTR _e$[ebp]
  002a8	f3 0f 11 44 10
	0c		 movss	 DWORD PTR [eax+edx+12], xmm0

; 3373 :          ++n;

  002ae	8b 45 e0	 mov	 eax, DWORD PTR _n$[ebp]
  002b1	83 c0 01	 add	 eax, 1
  002b4	89 45 e0	 mov	 DWORD PTR _n$[ebp], eax

; 3374 :       }

  002b7	e9 5a fe ff ff	 jmp	 $LN8@stbtt__ras
$LN9@stbtt__ras:

; 3375 :    }

  002bc	e9 0d fe ff ff	 jmp	 $LN5@stbtt__ras
$LN6@stbtt__ras:

; 3376 : 
; 3377 :    // now sort the edges by their highest point (should snap to integer, and then by x)
; 3378 :    //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
; 3379 :    stbtt__sort_edges(e, n);

  002c1	8b 45 e0	 mov	 eax, DWORD PTR _n$[ebp]
  002c4	50		 push	 eax
  002c5	8b 4d ec	 mov	 ecx, DWORD PTR _e$[ebp]
  002c8	51		 push	 ecx
  002c9	e8 00 00 00 00	 call	 ?stbtt__sort_edges@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges
  002ce	83 c4 08	 add	 esp, 8

; 3380 : 
; 3381 :    // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
; 3382 :    stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

  002d1	8b 45 34	 mov	 eax, DWORD PTR _userdata$[ebp]
  002d4	50		 push	 eax
  002d5	8b 4d 2c	 mov	 ecx, DWORD PTR _off_y$[ebp]
  002d8	51		 push	 ecx
  002d9	8b 55 28	 mov	 edx, DWORD PTR _off_x$[ebp]
  002dc	52		 push	 edx
  002dd	8b 45 a4	 mov	 eax, DWORD PTR _vsubsample$[ebp]
  002e0	50		 push	 eax
  002e1	8b 4d e0	 mov	 ecx, DWORD PTR _n$[ebp]
  002e4	51		 push	 ecx
  002e5	8b 55 ec	 mov	 edx, DWORD PTR _e$[ebp]
  002e8	52		 push	 edx
  002e9	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 ?stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z ; stbtt__rasterize_sorted_edges
  002f2	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3383 : 
; 3384 :    STBTT_free(e, userdata);

  002f5	8b 45 ec	 mov	 eax, DWORD PTR _e$[ebp]
  002f8	50		 push	 eax
  002f9	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  002fe	83 c4 04	 add	 esp, 4
$LN1@stbtt__ras:

; 3385 : }

  00301	5f		 pop	 edi
  00302	5e		 pop	 esi
  00303	5b		 pop	 ebx
  00304	81 c4 50 01 00
	00		 add	 esp, 336		; 00000150H
  0030a	3b ec		 cmp	 ebp, esp
  0030c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00311	8b e5		 mov	 esp, ebp
  00313	5d		 pop	 ebp
  00314	c3		 ret	 0
?stbtt__rasterize@@YAXPAUstbtt__bitmap@@PAUstbtt__point@@PAHHMMMMHHHPAX@Z ENDP ; stbtt__rasterize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sort_edges@@YAXPAUstbtt__edge@@H@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?stbtt__sort_edges@@YAXPAUstbtt__edge@@H@Z PROC		; stbtt__sort_edges, COMDAT

; 3320 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3321 :    stbtt__sort_edges_quicksort(p, n);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort
  00035	83 c4 08	 add	 esp, 8

; 3322 :    stbtt__sort_edges_ins_sort(p, n);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?stbtt__sort_edges_ins_sort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_ins_sort
  00045	83 c4 08	 add	 esp, 8

; 3323 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?stbtt__sort_edges@@YAXPAUstbtt__edge@@H@Z ENDP		; stbtt__sort_edges
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z
_TEXT	SEGMENT
tv95 = -308						; size = 4
tv92 = -308						; size = 4
tv82 = -308						; size = 4
tv73 = -308						; size = 4
_z$1 = -108						; size = 4
_j$2 = -96						; size = 4
_i$3 = -84						; size = 4
_m$4 = -72						; size = 4
_c$5 = -60						; size = 4
_c12$6 = -48						; size = 4
_c01$7 = -36						; size = 4
_t$8 = -24						; size = 20
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_quicksort, COMDAT

; 3258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-308]
  00012	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@stbtt__sor:

; 3259 :    /* threshold for transitioning to insertion sort */
; 3260 :    while (n > 12) {

  00028	83 7d 0c 0c	 cmp	 DWORD PTR _n$[ebp], 12	; 0000000cH
  0002c	0f 8e 3d 03 00
	00		 jle	 $LN3@stbtt__sor

; 3261 :       stbtt__edge t;
; 3262 :       int c01,c12,c,m,i,j;
; 3263 : 
; 3264 :       /* compute median of three */
; 3265 :       m = n >> 1;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00035	d1 f8		 sar	 eax, 1
  00037	89 45 b8	 mov	 DWORD PTR _m$4[ebp], eax

; 3266 :       c01 = STBTT__COMPARE(&p[0],&p[m]);

  0003a	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0003f	6b c8 00	 imul	 ecx, eax, 0
  00042	6b 55 b8 14	 imul	 edx, DWORD PTR _m$4[ebp], 20
  00046	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00049	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  0004c	f3 0f 10 44 10
	04		 movss	 xmm0, DWORD PTR [eax+edx+4]
  00052	0f 2f 44 0e 04	 comiss	 xmm0, DWORD PTR [esi+ecx+4]
  00057	76 0c		 jbe	 SHORT $LN20@stbtt__sor
  00059	c7 85 cc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv73[ebp], 1
  00063	eb 0a		 jmp	 SHORT $LN21@stbtt__sor
$LN20@stbtt__sor:
  00065	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN21@stbtt__sor:
  0006f	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  00075	89 4d dc	 mov	 DWORD PTR _c01$7[ebp], ecx

; 3267 :       c12 = STBTT__COMPARE(&p[m],&p[n-1]);

  00078	6b 45 b8 14	 imul	 eax, DWORD PTR _m$4[ebp], 20
  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0007f	83 e9 01	 sub	 ecx, 1
  00082	6b d1 14	 imul	 edx, ecx, 20
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00088	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  0008b	f3 0f 10 44 11
	04		 movss	 xmm0, DWORD PTR [ecx+edx+4]
  00091	0f 2f 44 06 04	 comiss	 xmm0, DWORD PTR [esi+eax+4]
  00096	76 0c		 jbe	 SHORT $LN22@stbtt__sor
  00098	c7 85 cc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv82[ebp], 1
  000a2	eb 0a		 jmp	 SHORT $LN23@stbtt__sor
$LN22@stbtt__sor:
  000a4	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv82[ebp], 0
$LN23@stbtt__sor:
  000ae	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv82[ebp]
  000b4	89 55 d0	 mov	 DWORD PTR _c12$6[ebp], edx

; 3268 :       /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
; 3269 :       if (c01 != c12) {

  000b7	8b 45 dc	 mov	 eax, DWORD PTR _c01$7[ebp]
  000ba	3b 45 d0	 cmp	 eax, DWORD PTR _c12$6[ebp]
  000bd	0f 84 de 00 00
	00		 je	 $LN13@stbtt__sor

; 3270 :          /* otherwise, we'll need to swap something else to middle */
; 3271 :          int z;
; 3272 :          c = STBTT__COMPARE(&p[0],&p[n-1]);

  000c3	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  000c8	6b c8 00	 imul	 ecx, eax, 0
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  000ce	83 ea 01	 sub	 edx, 1
  000d1	6b c2 14	 imul	 eax, edx, 20
  000d4	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000d7	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  000da	f3 0f 10 44 02
	04		 movss	 xmm0, DWORD PTR [edx+eax+4]
  000e0	0f 2f 44 0e 04	 comiss	 xmm0, DWORD PTR [esi+ecx+4]
  000e5	76 0c		 jbe	 SHORT $LN24@stbtt__sor
  000e7	c7 85 cc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv92[ebp], 1
  000f1	eb 0a		 jmp	 SHORT $LN25@stbtt__sor
$LN24@stbtt__sor:
  000f3	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN25@stbtt__sor:
  000fd	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv92[ebp]
  00103	89 45 c4	 mov	 DWORD PTR _c$5[ebp], eax

; 3273 :          /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
; 3274 :          /* 0<mid && mid>n:  0>n => 0; 0<n => n */
; 3275 :          z = (c == c12) ? 0 : n-1;

  00106	8b 45 c4	 mov	 eax, DWORD PTR _c$5[ebp]
  00109	3b 45 d0	 cmp	 eax, DWORD PTR _c12$6[ebp]
  0010c	75 0c		 jne	 SHORT $LN26@stbtt__sor
  0010e	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv95[ebp], 0
  00118	eb 0c		 jmp	 SHORT $LN27@stbtt__sor
$LN26@stbtt__sor:
  0011a	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0011d	83 e9 01	 sub	 ecx, 1
  00120	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
$LN27@stbtt__sor:
  00126	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv95[ebp]
  0012c	89 55 94	 mov	 DWORD PTR _z$1[ebp], edx

; 3276 :          t = p[z];

  0012f	6b 45 94 14	 imul	 eax, DWORD PTR _z$1[ebp], 20
  00133	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  00136	8b 08		 mov	 ecx, DWORD PTR [eax]
  00138	89 4d e8	 mov	 DWORD PTR _t$8[ebp], ecx
  0013b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0013e	89 55 ec	 mov	 DWORD PTR _t$8[ebp+4], edx
  00141	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00144	89 4d f0	 mov	 DWORD PTR _t$8[ebp+8], ecx
  00147	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0014a	89 55 f4	 mov	 DWORD PTR _t$8[ebp+12], edx
  0014d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00150	89 45 f8	 mov	 DWORD PTR _t$8[ebp+16], eax

; 3277 :          p[z] = p[m];

  00153	6b 45 b8 14	 imul	 eax, DWORD PTR _m$4[ebp], 20
  00157	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  0015a	6b 4d 94 14	 imul	 ecx, DWORD PTR _z$1[ebp], 20
  0015e	03 4d 08	 add	 ecx, DWORD PTR _p$[ebp]
  00161	8b 10		 mov	 edx, DWORD PTR [eax]
  00163	89 11		 mov	 DWORD PTR [ecx], edx
  00165	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00168	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0016b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0016e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00171	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00174	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00177	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0017a	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3278 :          p[m] = t;

  0017d	6b 45 b8 14	 imul	 eax, DWORD PTR _m$4[ebp], 20
  00181	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  00184	8b 4d e8	 mov	 ecx, DWORD PTR _t$8[ebp]
  00187	89 08		 mov	 DWORD PTR [eax], ecx
  00189	8b 55 ec	 mov	 edx, DWORD PTR _t$8[ebp+4]
  0018c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0018f	8b 4d f0	 mov	 ecx, DWORD PTR _t$8[ebp+8]
  00192	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00195	8b 55 f4	 mov	 edx, DWORD PTR _t$8[ebp+12]
  00198	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0019b	8b 4d f8	 mov	 ecx, DWORD PTR _t$8[ebp+16]
  0019e	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN13@stbtt__sor:

; 3279 :       }
; 3280 :       /* now p[m] is the median-of-three */
; 3281 :       /* swap it to the beginning so it won't move around */
; 3282 :       t = p[0];

  001a1	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001a6	6b c8 00	 imul	 ecx, eax, 0
  001a9	03 4d 08	 add	 ecx, DWORD PTR _p$[ebp]
  001ac	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ae	89 55 e8	 mov	 DWORD PTR _t$8[ebp], edx
  001b1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001b4	89 45 ec	 mov	 DWORD PTR _t$8[ebp+4], eax
  001b7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001ba	89 55 f0	 mov	 DWORD PTR _t$8[ebp+8], edx
  001bd	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001c0	89 45 f4	 mov	 DWORD PTR _t$8[ebp+12], eax
  001c3	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  001c6	89 4d f8	 mov	 DWORD PTR _t$8[ebp+16], ecx

; 3283 :       p[0] = p[m];

  001c9	6b 45 b8 14	 imul	 eax, DWORD PTR _m$4[ebp], 20
  001cd	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  001d0	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  001d5	6b d1 00	 imul	 edx, ecx, 0
  001d8	03 55 08	 add	 edx, DWORD PTR _p$[ebp]
  001db	8b 08		 mov	 ecx, DWORD PTR [eax]
  001dd	89 0a		 mov	 DWORD PTR [edx], ecx
  001df	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001e5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001e8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  001eb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001ee	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  001f1	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  001f4	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 3284 :       p[m] = t;

  001f7	6b 45 b8 14	 imul	 eax, DWORD PTR _m$4[ebp], 20
  001fb	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  001fe	8b 4d e8	 mov	 ecx, DWORD PTR _t$8[ebp]
  00201	89 08		 mov	 DWORD PTR [eax], ecx
  00203	8b 55 ec	 mov	 edx, DWORD PTR _t$8[ebp+4]
  00206	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00209	8b 4d f0	 mov	 ecx, DWORD PTR _t$8[ebp+8]
  0020c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0020f	8b 55 f4	 mov	 edx, DWORD PTR _t$8[ebp+12]
  00212	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00215	8b 4d f8	 mov	 ecx, DWORD PTR _t$8[ebp+16]
  00218	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3285 : 
; 3286 :       /* partition loop */
; 3287 :       i=1;

  0021b	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 1

; 3288 :       j=n-1;

  00222	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00225	83 e8 01	 sub	 eax, 1
  00228	89 45 a0	 mov	 DWORD PTR _j$2[ebp], eax
$LN4@stbtt__sor:

; 3289 :       for(;;) {
; 3290 :          /* handling of equality is crucial here */
; 3291 :          /* for sentinels & efficiency with duplicates */
; 3292 :          for (;;++i) {

  0022b	eb 09		 jmp	 SHORT $LN9@stbtt__sor
$LN7@stbtt__sor:
  0022d	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  00230	83 c0 01	 add	 eax, 1
  00233	89 45 ac	 mov	 DWORD PTR _i$3[ebp], eax
$LN9@stbtt__sor:

; 3293 :             if (!STBTT__COMPARE(&p[i], &p[0])) break;

  00236	6b 45 ac 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0023a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0023f	6b d1 00	 imul	 edx, ecx, 0
  00242	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00245	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00248	f3 0f 10 44 11
	04		 movss	 xmm0, DWORD PTR [ecx+edx+4]
  0024e	0f 2f 44 06 04	 comiss	 xmm0, DWORD PTR [esi+eax+4]
  00253	77 02		 ja	 SHORT $LN14@stbtt__sor
  00255	eb 02		 jmp	 SHORT $LN8@stbtt__sor
$LN14@stbtt__sor:

; 3294 :          }

  00257	eb d4		 jmp	 SHORT $LN7@stbtt__sor
$LN8@stbtt__sor:

; 3295 :          for (;;--j) {

  00259	eb 09		 jmp	 SHORT $LN12@stbtt__sor
$LN10@stbtt__sor:
  0025b	8b 45 a0	 mov	 eax, DWORD PTR _j$2[ebp]
  0025e	83 e8 01	 sub	 eax, 1
  00261	89 45 a0	 mov	 DWORD PTR _j$2[ebp], eax
$LN12@stbtt__sor:

; 3296 :             if (!STBTT__COMPARE(&p[0], &p[j])) break;

  00264	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00269	6b c8 00	 imul	 ecx, eax, 0
  0026c	6b 55 a0 14	 imul	 edx, DWORD PTR _j$2[ebp], 20
  00270	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00273	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00276	f3 0f 10 44 10
	04		 movss	 xmm0, DWORD PTR [eax+edx+4]
  0027c	0f 2f 44 0e 04	 comiss	 xmm0, DWORD PTR [esi+ecx+4]
  00281	77 02		 ja	 SHORT $LN15@stbtt__sor
  00283	eb 02		 jmp	 SHORT $LN11@stbtt__sor
$LN15@stbtt__sor:

; 3297 :          }

  00285	eb d4		 jmp	 SHORT $LN10@stbtt__sor
$LN11@stbtt__sor:

; 3298 :          /* make sure we haven't crossed */
; 3299 :          if (i >= j) break;

  00287	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  0028a	3b 45 a0	 cmp	 eax, DWORD PTR _j$2[ebp]
  0028d	7c 05		 jl	 SHORT $LN16@stbtt__sor
  0028f	e9 89 00 00 00	 jmp	 $LN5@stbtt__sor
$LN16@stbtt__sor:

; 3300 :          t = p[i];

  00294	6b 45 ac 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  00298	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  0029b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029d	89 4d e8	 mov	 DWORD PTR _t$8[ebp], ecx
  002a0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002a3	89 55 ec	 mov	 DWORD PTR _t$8[ebp+4], edx
  002a6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002a9	89 4d f0	 mov	 DWORD PTR _t$8[ebp+8], ecx
  002ac	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  002af	89 55 f4	 mov	 DWORD PTR _t$8[ebp+12], edx
  002b2	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  002b5	89 45 f8	 mov	 DWORD PTR _t$8[ebp+16], eax

; 3301 :          p[i] = p[j];

  002b8	6b 45 a0 14	 imul	 eax, DWORD PTR _j$2[ebp], 20
  002bc	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  002bf	6b 4d ac 14	 imul	 ecx, DWORD PTR _i$3[ebp], 20
  002c3	03 4d 08	 add	 ecx, DWORD PTR _p$[ebp]
  002c6	8b 10		 mov	 edx, DWORD PTR [eax]
  002c8	89 11		 mov	 DWORD PTR [ecx], edx
  002ca	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002cd	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  002d0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002d3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  002d6	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  002d9	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  002dc	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  002df	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3302 :          p[j] = t;

  002e2	6b 45 a0 14	 imul	 eax, DWORD PTR _j$2[ebp], 20
  002e6	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  002e9	8b 4d e8	 mov	 ecx, DWORD PTR _t$8[ebp]
  002ec	89 08		 mov	 DWORD PTR [eax], ecx
  002ee	8b 55 ec	 mov	 edx, DWORD PTR _t$8[ebp+4]
  002f1	89 50 04	 mov	 DWORD PTR [eax+4], edx
  002f4	8b 4d f0	 mov	 ecx, DWORD PTR _t$8[ebp+8]
  002f7	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  002fa	8b 55 f4	 mov	 edx, DWORD PTR _t$8[ebp+12]
  002fd	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00300	8b 4d f8	 mov	 ecx, DWORD PTR _t$8[ebp+16]
  00303	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3303 : 
; 3304 :          ++i;

  00306	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  00309	83 c0 01	 add	 eax, 1
  0030c	89 45 ac	 mov	 DWORD PTR _i$3[ebp], eax

; 3305 :          --j;

  0030f	8b 45 a0	 mov	 eax, DWORD PTR _j$2[ebp]
  00312	83 e8 01	 sub	 eax, 1
  00315	89 45 a0	 mov	 DWORD PTR _j$2[ebp], eax

; 3306 :       }

  00318	e9 0e ff ff ff	 jmp	 $LN4@stbtt__sor
$LN5@stbtt__sor:

; 3307 :       /* recurse on smaller side, iterate on larger */
; 3308 :       if (j < (n-i)) {

  0031d	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00320	2b 45 ac	 sub	 eax, DWORD PTR _i$3[ebp]
  00323	39 45 a0	 cmp	 DWORD PTR _j$2[ebp], eax
  00326	7d 25		 jge	 SHORT $LN17@stbtt__sor

; 3309 :          stbtt__sort_edges_quicksort(p,j);

  00328	8b 45 a0	 mov	 eax, DWORD PTR _j$2[ebp]
  0032b	50		 push	 eax
  0032c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0032f	51		 push	 ecx
  00330	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort
  00335	83 c4 08	 add	 esp, 8

; 3310 :          p = p+i;

  00338	6b 45 ac 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0033c	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  0033f	89 45 08	 mov	 DWORD PTR _p$[ebp], eax

; 3311 :          n = n-i;

  00342	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00345	2b 45 ac	 sub	 eax, DWORD PTR _i$3[ebp]
  00348	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax

; 3312 :       } else {

  0034b	eb 1d		 jmp	 SHORT $LN18@stbtt__sor
$LN17@stbtt__sor:

; 3313 :          stbtt__sort_edges_quicksort(p+i, n-i);

  0034d	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00350	2b 45 ac	 sub	 eax, DWORD PTR _i$3[ebp]
  00353	50		 push	 eax
  00354	6b 4d ac 14	 imul	 ecx, DWORD PTR _i$3[ebp], 20
  00358	03 4d 08	 add	 ecx, DWORD PTR _p$[ebp]
  0035b	51		 push	 ecx
  0035c	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort
  00361	83 c4 08	 add	 esp, 8

; 3314 :          n = j;

  00364	8b 45 a0	 mov	 eax, DWORD PTR _j$2[ebp]
  00367	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax
$LN18@stbtt__sor:

; 3315 :       }
; 3316 :    }

  0036a	e9 b9 fc ff ff	 jmp	 $LN2@stbtt__sor
$LN3@stbtt__sor:

; 3317 : }

  0036f	52		 push	 edx
  00370	8b cd		 mov	 ecx, ebp
  00372	50		 push	 eax
  00373	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN30@stbtt__sor
  00379	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0037e	58		 pop	 eax
  0037f	5a		 pop	 edx
  00380	5f		 pop	 edi
  00381	5e		 pop	 esi
  00382	5b		 pop	 ebx
  00383	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  00389	3b ec		 cmp	 ebp, esp
  0038b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00390	8b e5		 mov	 esp, ebp
  00392	5d		 pop	 ebp
  00393	c3		 ret	 0
$LN30@stbtt__sor:
  00394	01 00 00 00	 DD	 1
  00398	00 00 00 00	 DD	 $LN29@stbtt__sor
$LN29@stbtt__sor:
  0039c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  003a0	14 00 00 00	 DD	 20			; 00000014H
  003a4	00 00 00 00	 DD	 $LN28@stbtt__sor
$LN28@stbtt__sor:
  003a8	74		 DB	 116			; 00000074H
  003a9	00		 DB	 0
?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_quicksort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__sort_edges_ins_sort@@YAXPAUstbtt__edge@@H@Z
_TEXT	SEGMENT
tv76 = -288						; size = 4
_c$1 = -88						; size = 4
_b$2 = -76						; size = 4
_a$3 = -64						; size = 4
_t$4 = -52						; size = 20
_j$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?stbtt__sort_edges_ins_sort@@YAXPAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_ins_sort, COMDAT

; 3240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3241 :    int i,j;
; 3242 :    for (i=1; i < n; ++i) {

  00032	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00039	eb 09		 jmp	 SHORT $LN4@stbtt__sor
$LN2@stbtt__sor:
  0003b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt__sor:
  00044	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00047	3b 45 0c	 cmp	 eax, DWORD PTR _n$[ebp]
  0004a	0f 8d ef 00 00
	00		 jge	 $LN3@stbtt__sor

; 3243 :       stbtt__edge t = p[i], *a = &t;

  00050	6b 45 f4 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  00054	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	89 4d cc	 mov	 DWORD PTR _t$4[ebp], ecx
  0005c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005f	89 55 d0	 mov	 DWORD PTR _t$4[ebp+4], edx
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	89 4d d4	 mov	 DWORD PTR _t$4[ebp+8], ecx
  00068	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0006b	89 55 d8	 mov	 DWORD PTR _t$4[ebp+12], edx
  0006e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00071	89 45 dc	 mov	 DWORD PTR _t$4[ebp+16], eax
  00074	8d 45 cc	 lea	 eax, DWORD PTR _t$4[ebp]
  00077	89 45 c0	 mov	 DWORD PTR _a$3[ebp], eax

; 3244 :       j = i;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
$LN5@stbtt__sor:

; 3245 :       while (j > 0) {

  00080	83 7d e8 00	 cmp	 DWORD PTR _j$[ebp], 0
  00084	0f 8e 84 00 00
	00		 jle	 $LN6@stbtt__sor

; 3246 :          stbtt__edge *b = &p[j-1];

  0008a	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  0008d	83 e8 01	 sub	 eax, 1
  00090	6b c8 14	 imul	 ecx, eax, 20
  00093	03 4d 08	 add	 ecx, DWORD PTR _p$[ebp]
  00096	89 4d b4	 mov	 DWORD PTR _b$2[ebp], ecx

; 3247 :          int c = STBTT__COMPARE(a,b);

  00099	8b 45 b4	 mov	 eax, DWORD PTR _b$2[ebp]
  0009c	8b 4d c0	 mov	 ecx, DWORD PTR _a$3[ebp]
  0009f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000a4	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  000a8	76 0c		 jbe	 SHORT $LN10@stbtt__sor
  000aa	c7 85 e0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv76[ebp], 1
  000b4	eb 0a		 jmp	 SHORT $LN11@stbtt__sor
$LN10@stbtt__sor:
  000b6	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN11@stbtt__sor:
  000c0	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  000c6	89 55 a8	 mov	 DWORD PTR _c$1[ebp], edx

; 3248 :          if (!c) break;

  000c9	83 7d a8 00	 cmp	 DWORD PTR _c$1[ebp], 0
  000cd	75 02		 jne	 SHORT $LN7@stbtt__sor
  000cf	eb 3d		 jmp	 SHORT $LN6@stbtt__sor
$LN7@stbtt__sor:

; 3249 :          p[j] = p[j-1];

  000d1	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  000d4	83 e8 01	 sub	 eax, 1
  000d7	6b c8 14	 imul	 ecx, eax, 20
  000da	03 4d 08	 add	 ecx, DWORD PTR _p$[ebp]
  000dd	6b 55 e8 14	 imul	 edx, DWORD PTR _j$[ebp], 20
  000e1	03 55 08	 add	 edx, DWORD PTR _p$[ebp]
  000e4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e6	89 02		 mov	 DWORD PTR [edx], eax
  000e8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000eb	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000ee	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000f1	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000f4	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000f7	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  000fa	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  000fd	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3250 :          --j;

  00100	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  00103	83 e8 01	 sub	 eax, 1
  00106	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax

; 3251 :       }

  00109	e9 72 ff ff ff	 jmp	 $LN5@stbtt__sor
$LN6@stbtt__sor:

; 3252 :       if (i != j)

  0010e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00111	3b 45 e8	 cmp	 eax, DWORD PTR _j$[ebp]
  00114	74 24		 je	 SHORT $LN8@stbtt__sor

; 3253 :          p[j] = t;

  00116	6b 45 e8 14	 imul	 eax, DWORD PTR _j$[ebp], 20
  0011a	03 45 08	 add	 eax, DWORD PTR _p$[ebp]
  0011d	8b 4d cc	 mov	 ecx, DWORD PTR _t$4[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
  00122	8b 55 d0	 mov	 edx, DWORD PTR _t$4[ebp+4]
  00125	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00128	8b 4d d4	 mov	 ecx, DWORD PTR _t$4[ebp+8]
  0012b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0012e	8b 55 d8	 mov	 edx, DWORD PTR _t$4[ebp+12]
  00131	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00134	8b 4d dc	 mov	 ecx, DWORD PTR _t$4[ebp+16]
  00137	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN8@stbtt__sor:

; 3254 :    }

  0013a	e9 fc fe ff ff	 jmp	 $LN2@stbtt__sor
$LN3@stbtt__sor:

; 3255 : }

  0013f	52		 push	 edx
  00140	8b cd		 mov	 ecx, ebp
  00142	50		 push	 eax
  00143	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@stbtt__sor
  00149	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0014e	58		 pop	 eax
  0014f	5a		 pop	 edx
  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	33 cd		 xor	 ecx, ebp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  00163	3b ec		 cmp	 ebp, esp
  00165	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
  0016e	66 90		 npad	 2
$LN14@stbtt__sor:
  00170	01 00 00 00	 DD	 1
  00174	00 00 00 00	 DD	 $LN13@stbtt__sor
$LN13@stbtt__sor:
  00178	cc ff ff ff	 DD	 -52			; ffffffccH
  0017c	14 00 00 00	 DD	 20			; 00000014H
  00180	00 00 00 00	 DD	 $LN12@stbtt__sor
$LN12@stbtt__sor:
  00184	74		 DB	 116			; 00000074H
  00185	00		 DB	 0
?stbtt__sort_edges_ins_sort@@YAXPAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_ins_sort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z
_TEXT	SEGMENT
tv342 = -1116						; size = 4
_z$1 = -724						; size = 4
_m$2 = -712						; size = 4
_k$3 = -700						; size = 4
_sum$4 = -688						; size = 4
_z$5 = -676						; size = 4
_z$6 = -664						; size = 4
_step$7 = -652						; size = 4
_scan_y_bottom$8 = -640					; size = 4
_scan_y_top$9 = -628					; size = 4
_scanline2$ = -616					; size = 4
_scanline$ = -604					; size = 4
_scanline_data$ = -592					; size = 516
_i$ = -68						; size = 4
_j$ = -56						; size = 4
_y$ = -44						; size = 4
_active$ = -32						; size = 4
_hh$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_result$ = 8						; size = 4
_e$ = 12						; size = 4
_n$ = 16						; size = 4
_vsubsample$ = 20					; size = 4
_off_x$ = 24						; size = 4
_off_y$ = 28						; size = 4
_userdata$ = 32						; size = 4
?stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z PROC ; stbtt__rasterize_sorted_edges, COMDAT

; 3138 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 04 00
	00		 sub	 esp, 1116		; 0000045cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd a4 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1116]
  00012	b9 17 01 00 00	 mov	 ecx, 279		; 00000117H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3139 :    stbtt__hheap hh = { 0, 0, 0 };

  00032	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _hh$[ebp], 0
  00039	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hh$[ebp+4], 0
  00040	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hh$[ebp+8], 0

; 3140 :    stbtt__active_edge *active = NULL;

  00047	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _active$[ebp], 0

; 3141 :    int y,j=0, i;

  0004e	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 3142 :    float scanline_data[129], *scanline, *scanline2;
; 3143 : 
; 3144 :    STBTT__NOTUSED(vsubsample);
; 3145 : 
; 3146 :    if (result->w > 64)

  00055	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  00058	83 38 40	 cmp	 DWORD PTR [eax], 64	; 00000040H
  0005b	7e 1f		 jle	 SHORT $LN13@stbtt__ras

; 3147 :       scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);

  0005d	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	d1 e1		 shl	 ecx, 1
  00064	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00071	83 c4 04	 add	 esp, 4
  00074	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _scanline$[ebp], eax
  0007a	eb 0c		 jmp	 SHORT $LN14@stbtt__ras
$LN13@stbtt__ras:

; 3148 :    else
; 3149 :       scanline = scanline_data;

  0007c	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _scanline_data$[ebp]
  00082	89 85 a4 fd ff
	ff		 mov	 DWORD PTR _scanline$[ebp], eax
$LN14@stbtt__ras:

; 3150 : 
; 3151 :    scanline2 = scanline + result->w;

  00088	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  0008b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008d	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _scanline$[ebp]
  00093	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00096	89 85 98 fd ff
	ff		 mov	 DWORD PTR _scanline2$[ebp], eax

; 3152 : 
; 3153 :    y = off_y;

  0009c	8b 45 1c	 mov	 eax, DWORD PTR _off_y$[ebp]
  0009f	89 45 d4	 mov	 DWORD PTR _y$[ebp], eax

; 3154 :    e[n].y0 = (float) (off_y + result->h) + 1;

  000a2	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  000a5	8b 4d 1c	 mov	 ecx, DWORD PTR _off_y$[ebp]
  000a8	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000ab	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000af	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  000b7	6b 55 10 14	 imul	 edx, DWORD PTR _n$[ebp], 20
  000bb	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  000be	f3 0f 11 44 10
	04		 movss	 DWORD PTR [eax+edx+4], xmm0
$LN2@stbtt__ras:

; 3155 : 
; 3156 :    while (j < result->h) {

  000c4	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  000c7	8b 4d c8	 mov	 ecx, DWORD PTR _j$[ebp]
  000ca	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000cd	0f 8d 9f 03 00
	00		 jge	 $LN3@stbtt__ras

; 3157 :       // find center of pixel for this scanline
; 3158 :       float scan_y_top    = y + 0.0f;

  000d3	f3 0f 2a 45 d4	 cvtsi2ss xmm0, DWORD PTR _y$[ebp]
  000d8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@00000000
  000e0	f3 0f 11 85 8c
	fd ff ff	 movss	 DWORD PTR _scan_y_top$9[ebp], xmm0

; 3159 :       float scan_y_bottom = y + 1.0f;

  000e8	f3 0f 2a 45 d4	 cvtsi2ss xmm0, DWORD PTR _y$[ebp]
  000ed	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  000f5	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR _scan_y_bottom$8[ebp], xmm0

; 3160 :       stbtt__active_edge **step = &active;

  000fd	8d 45 e0	 lea	 eax, DWORD PTR _active$[ebp]
  00100	89 85 74 fd ff
	ff		 mov	 DWORD PTR _step$7[ebp], eax

; 3161 : 
; 3162 :       STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));

  00106	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  00109	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010b	c1 e1 02	 shl	 ecx, 2
  0010e	51		 push	 ecx
  0010f	6a 00		 push	 0
  00111	8b 95 a4 fd ff
	ff		 mov	 edx, DWORD PTR _scanline$[ebp]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 _memset
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3163 :       STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

  00120	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  00123	8b 08		 mov	 ecx, DWORD PTR [eax]
  00125	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  0012c	52		 push	 edx
  0012d	6a 00		 push	 0
  0012f	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _scanline2$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memset
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@stbtt__ras:

; 3164 : 
; 3165 :       // update all active edges;
; 3166 :       // remove all active edges that terminate before the top of this scanline
; 3167 :       while (*step) {

  0013e	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _step$7[ebp]
  00144	83 38 00	 cmp	 DWORD PTR [eax], 0
  00147	0f 84 a6 00 00
	00		 je	 $LN5@stbtt__ras

; 3168 :          stbtt__active_edge * z = *step;

  0014d	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _step$7[ebp]
  00153	8b 08		 mov	 ecx, DWORD PTR [eax]
  00155	89 8d 68 fd ff
	ff		 mov	 DWORD PTR _z$6[ebp], ecx

; 3169 :          if (z->ey <= scan_y_top) {

  0015b	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR _z$6[ebp]
  00161	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR _scan_y_top$9[ebp]
  00169	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  0016d	72 71		 jb	 SHORT $LN15@stbtt__ras

; 3170 :             *step = z->next; // delete from list

  0016f	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _step$7[ebp]
  00175	8b 8d 68 fd ff
	ff		 mov	 ecx, DWORD PTR _z$6[ebp]
  0017b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017d	89 10		 mov	 DWORD PTR [eax], edx

; 3171 :             STBTT_assert(z->direction);

  0017f	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR _z$6[ebp]
  00185	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0018a	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00191	9f		 lahf
  00192	f6 c4 44	 test	 ah, 68			; 00000044H
  00195	7a 26		 jp	 SHORT $LN25@stbtt__ras
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z@4JA
  0019d	83 c1 21	 add	 ecx, 33			; 00000021H
  001a0	8b f4		 mov	 esi, esp
  001a2	51		 push	 ecx
  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b6	3b f4		 cmp	 esi, esp
  001b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN25@stbtt__ras:

; 3172 :             z->direction = 0;

  001bd	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR _z$6[ebp]
  001c3	0f 57 c0	 xorps	 xmm0, xmm0
  001c6	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 3173 :             stbtt__hheap_free(&hh, z);

  001cb	8b 85 68 fd ff
	ff		 mov	 eax, DWORD PTR _z$6[ebp]
  001d1	50		 push	 eax
  001d2	8d 4d ec	 lea	 ecx, DWORD PTR _hh$[ebp]
  001d5	51		 push	 ecx
  001d6	e8 00 00 00 00	 call	 ?stbtt__hheap_free@@YAXPAUstbtt__hheap@@PAX@Z ; stbtt__hheap_free
  001db	83 c4 08	 add	 esp, 8

; 3174 :          } else {

  001de	eb 0e		 jmp	 SHORT $LN16@stbtt__ras
$LN15@stbtt__ras:

; 3175 :             step = &((*step)->next); // advance through list

  001e0	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _step$7[ebp]
  001e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e8	89 8d 74 fd ff
	ff		 mov	 DWORD PTR _step$7[ebp], ecx
$LN16@stbtt__ras:

; 3176 :          }
; 3177 :       }

  001ee	e9 4b ff ff ff	 jmp	 $LN4@stbtt__ras
$LN5@stbtt__ras:

; 3178 : 
; 3179 :       // insert all edges that start before the bottom of this scanline
; 3180 :       while (e->y0 <= scan_y_bottom) {

  001f3	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  001f6	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR _scan_y_bottom$8[ebp]
  001fe	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00202	0f 82 e1 00 00
	00		 jb	 $LN7@stbtt__ras

; 3181 :          if (e->y0 != e->y1) {

  00208	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  0020b	8b 4d 0c	 mov	 ecx, DWORD PTR _e$[ebp]
  0020e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00213	0f 2e 41 0c	 ucomiss xmm0, DWORD PTR [ecx+12]
  00217	9f		 lahf
  00218	f6 c4 44	 test	 ah, 68			; 00000044H
  0021b	0f 8b ba 00 00
	00		 jnp	 $LN18@stbtt__ras

; 3182 :             stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);

  00221	8b 45 20	 mov	 eax, DWORD PTR _userdata$[ebp]
  00224	50		 push	 eax
  00225	51		 push	 ecx
  00226	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR _scan_y_top$9[ebp]
  0022e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00233	8b 4d 18	 mov	 ecx, DWORD PTR _off_x$[ebp]
  00236	51		 push	 ecx
  00237	8b 55 0c	 mov	 edx, DWORD PTR _e$[ebp]
  0023a	52		 push	 edx
  0023b	8d 45 ec	 lea	 eax, DWORD PTR _hh$[ebp]
  0023e	50		 push	 eax
  0023f	e8 00 00 00 00	 call	 ?stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z ; stbtt__new_active
  00244	83 c4 14	 add	 esp, 20			; 00000014H
  00247	89 85 5c fd ff
	ff		 mov	 DWORD PTR _z$5[ebp], eax

; 3183 :             if (z != NULL) {

  0024d	83 bd 5c fd ff
	ff 00		 cmp	 DWORD PTR _z$5[ebp], 0
  00254	0f 84 81 00 00
	00		 je	 $LN18@stbtt__ras

; 3184 :                if (j == 0 && off_y != 0) {

  0025a	83 7d c8 00	 cmp	 DWORD PTR _j$[ebp], 0
  0025e	75 2d		 jne	 SHORT $LN20@stbtt__ras
  00260	83 7d 1c 00	 cmp	 DWORD PTR _off_y$[ebp], 0
  00264	74 27		 je	 SHORT $LN20@stbtt__ras

; 3185 :                   if (z->ey < scan_y_top) {

  00266	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _z$5[ebp]
  0026c	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR _scan_y_top$9[ebp]
  00274	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00278	76 13		 jbe	 SHORT $LN20@stbtt__ras

; 3186 :                      // this can happen due to subpixel positioning and some kind of fp rounding error i think
; 3187 :                      z->ey = scan_y_top;

  0027a	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _z$5[ebp]
  00280	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR _scan_y_top$9[ebp]
  00288	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
$LN20@stbtt__ras:

; 3188 :                   }
; 3189 :                }
; 3190 :                STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds

  0028d	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _z$5[ebp]
  00293	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00298	0f 2f 85 8c fd
	ff ff		 comiss	 xmm0, DWORD PTR _scan_y_top$9[ebp]
  0029f	73 26		 jae	 SHORT $LN26@stbtt__ras
  002a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z@4JA
  002a7	83 c1 34	 add	 ecx, 52			; 00000034H
  002aa	8b f4		 mov	 esi, esp
  002ac	51		 push	 ecx
  002ad	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  002b2	68 00 00 00 00	 push	 OFFSET ??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  002bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c0	3b f4		 cmp	 esi, esp
  002c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN26@stbtt__ras:

; 3191 :                // insert at front
; 3192 :                z->next = active;

  002c7	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _z$5[ebp]
  002cd	8b 4d e0	 mov	 ecx, DWORD PTR _active$[ebp]
  002d0	89 08		 mov	 DWORD PTR [eax], ecx

; 3193 :                active = z;

  002d2	8b 85 5c fd ff
	ff		 mov	 eax, DWORD PTR _z$5[ebp]
  002d8	89 45 e0	 mov	 DWORD PTR _active$[ebp], eax
$LN18@stbtt__ras:

; 3194 :             }
; 3195 :          }
; 3196 :          ++e;

  002db	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  002de	83 c0 14	 add	 eax, 20			; 00000014H
  002e1	89 45 0c	 mov	 DWORD PTR _e$[ebp], eax

; 3197 :       }

  002e4	e9 0a ff ff ff	 jmp	 $LN5@stbtt__ras
$LN7@stbtt__ras:

; 3198 : 
; 3199 :       // now process all active edges
; 3200 :       if (active)

  002e9	83 7d e0 00	 cmp	 DWORD PTR _active$[ebp], 0
  002ed	74 31		 je	 SHORT $LN21@stbtt__ras

; 3201 :          stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

  002ef	51		 push	 ecx
  002f0	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR _scan_y_top$9[ebp]
  002f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fd	8b 45 e0	 mov	 eax, DWORD PTR _active$[ebp]
  00300	50		 push	 eax
  00301	8b 4d 08	 mov	 ecx, DWORD PTR _result$[ebp]
  00304	8b 11		 mov	 edx, DWORD PTR [ecx]
  00306	52		 push	 edx
  00307	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR _scanline2$[ebp]
  0030d	83 c0 04	 add	 eax, 4
  00310	50		 push	 eax
  00311	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _scanline$[ebp]
  00317	51		 push	 ecx
  00318	e8 00 00 00 00	 call	 ?stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z ; stbtt__fill_active_edges_new
  0031d	83 c4 14	 add	 esp, 20			; 00000014H
$LN21@stbtt__ras:

; 3202 : 
; 3203 :       {
; 3204 :          float sum = 0;

  00320	0f 57 c0	 xorps	 xmm0, xmm0
  00323	f3 0f 11 85 50
	fd ff ff	 movss	 DWORD PTR _sum$4[ebp], xmm0

; 3205 :          for (i=0; i < result->w; ++i) {

  0032b	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00332	eb 09		 jmp	 SHORT $LN10@stbtt__ras
$LN8@stbtt__ras:
  00334	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  00337	83 c0 01	 add	 eax, 1
  0033a	89 45 bc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@stbtt__ras:
  0033d	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  00340	8b 4d bc	 mov	 ecx, DWORD PTR _i$[ebp]
  00343	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00345	0f 8d bd 00 00
	00		 jge	 $LN9@stbtt__ras

; 3206 :             float k;
; 3207 :             int m;
; 3208 :             sum += scanline2[i];

  0034b	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  0034e	8b 8d 98 fd ff
	ff		 mov	 ecx, DWORD PTR _scanline2$[ebp]
  00354	f3 0f 10 85 50
	fd ff ff	 movss	 xmm0, DWORD PTR _sum$4[ebp]
  0035c	f3 0f 58 04 81	 addss	 xmm0, DWORD PTR [ecx+eax*4]
  00361	f3 0f 11 85 50
	fd ff ff	 movss	 DWORD PTR _sum$4[ebp], xmm0

; 3209 :             k = scanline[i] + sum;

  00369	8b 45 bc	 mov	 eax, DWORD PTR _i$[ebp]
  0036c	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _scanline$[ebp]
  00372	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [ecx+eax*4]
  00377	f3 0f 58 85 50
	fd ff ff	 addss	 xmm0, DWORD PTR _sum$4[ebp]
  0037f	f3 0f 11 85 44
	fd ff ff	 movss	 DWORD PTR _k$3[ebp], xmm0

; 3210 :             k = (float) STBTT_fabs(k)*255 + 0.5f;

  00387	51		 push	 ecx
  00388	f3 0f 10 85 44
	fd ff ff	 movss	 xmm0, DWORD PTR _k$3[ebp]
  00390	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00395	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  0039a	83 c4 04	 add	 esp, 4
  0039d	d9 9d a4 fb ff
	ff		 fstp	 DWORD PTR tv342[ebp]
  003a3	f3 0f 10 85 a4
	fb ff ff	 movss	 xmm0, DWORD PTR tv342[ebp]
  003ab	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  003b3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  003bb	f3 0f 11 85 44
	fd ff ff	 movss	 DWORD PTR _k$3[ebp], xmm0

; 3211 :             m = (int) k;

  003c3	f3 0f 2c 85 44
	fd ff ff	 cvttss2si eax, DWORD PTR _k$3[ebp]
  003cb	89 85 38 fd ff
	ff		 mov	 DWORD PTR _m$2[ebp], eax

; 3212 :             if (m > 255) m = 255;

  003d1	81 bd 38 fd ff
	ff ff 00 00 00	 cmp	 DWORD PTR _m$2[ebp], 255 ; 000000ffH
  003db	7e 0a		 jle	 SHORT $LN22@stbtt__ras
  003dd	c7 85 38 fd ff
	ff ff 00 00 00	 mov	 DWORD PTR _m$2[ebp], 255 ; 000000ffH
$LN22@stbtt__ras:

; 3213 :             result->pixels[j*result->stride + i] = (unsigned char) m;

  003e7	8b 45 08	 mov	 eax, DWORD PTR _result$[ebp]
  003ea	8b 4d c8	 mov	 ecx, DWORD PTR _j$[ebp]
  003ed	0f af 48 08	 imul	 ecx, DWORD PTR [eax+8]
  003f1	03 4d bc	 add	 ecx, DWORD PTR _i$[ebp]
  003f4	8b 55 08	 mov	 edx, DWORD PTR _result$[ebp]
  003f7	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  003fa	8a 95 38 fd ff
	ff		 mov	 dl, BYTE PTR _m$2[ebp]
  00400	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 3214 :          }

  00403	e9 2c ff ff ff	 jmp	 $LN8@stbtt__ras
$LN9@stbtt__ras:

; 3215 :       }
; 3216 :       // advance all the edges
; 3217 :       step = &active;

  00408	8d 45 e0	 lea	 eax, DWORD PTR _active$[ebp]
  0040b	89 85 74 fd ff
	ff		 mov	 DWORD PTR _step$7[ebp], eax
$LN11@stbtt__ras:

; 3218 :       while (*step) {

  00411	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _step$7[ebp]
  00417	83 38 00	 cmp	 DWORD PTR [eax], 0
  0041a	74 3f		 je	 SHORT $LN12@stbtt__ras

; 3219 :          stbtt__active_edge *z = *step;

  0041c	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _step$7[ebp]
  00422	8b 08		 mov	 ecx, DWORD PTR [eax]
  00424	89 8d 2c fd ff
	ff		 mov	 DWORD PTR _z$1[ebp], ecx

; 3220 :          z->fx += z->fdx; // advance to position for current scanline

  0042a	8b 85 2c fd ff
	ff		 mov	 eax, DWORD PTR _z$1[ebp]
  00430	8b 8d 2c fd ff
	ff		 mov	 ecx, DWORD PTR _z$1[ebp]
  00436	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0043b	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  00440	8b 95 2c fd ff
	ff		 mov	 edx, DWORD PTR _z$1[ebp]
  00446	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 3221 :          step = &((*step)->next); // advance through list

  0044b	8b 85 74 fd ff
	ff		 mov	 eax, DWORD PTR _step$7[ebp]
  00451	8b 08		 mov	 ecx, DWORD PTR [eax]
  00453	89 8d 74 fd ff
	ff		 mov	 DWORD PTR _step$7[ebp], ecx

; 3222 :       }

  00459	eb b6		 jmp	 SHORT $LN11@stbtt__ras
$LN12@stbtt__ras:

; 3223 : 
; 3224 :       ++y;

  0045b	8b 45 d4	 mov	 eax, DWORD PTR _y$[ebp]
  0045e	83 c0 01	 add	 eax, 1
  00461	89 45 d4	 mov	 DWORD PTR _y$[ebp], eax

; 3225 :       ++j;

  00464	8b 45 c8	 mov	 eax, DWORD PTR _j$[ebp]
  00467	83 c0 01	 add	 eax, 1
  0046a	89 45 c8	 mov	 DWORD PTR _j$[ebp], eax

; 3226 :    }

  0046d	e9 52 fc ff ff	 jmp	 $LN2@stbtt__ras
$LN3@stbtt__ras:

; 3227 : 
; 3228 :    stbtt__hheap_cleanup(&hh, userdata);

  00472	8b 45 20	 mov	 eax, DWORD PTR _userdata$[ebp]
  00475	50		 push	 eax
  00476	8d 4d ec	 lea	 ecx, DWORD PTR _hh$[ebp]
  00479	51		 push	 ecx
  0047a	e8 00 00 00 00	 call	 ?stbtt__hheap_cleanup@@YAXPAUstbtt__hheap@@PAX@Z ; stbtt__hheap_cleanup
  0047f	83 c4 08	 add	 esp, 8

; 3229 : 
; 3230 :    if (scanline != scanline_data)

  00482	8d 85 b0 fd ff
	ff		 lea	 eax, DWORD PTR _scanline_data$[ebp]
  00488	39 85 a4 fd ff
	ff		 cmp	 DWORD PTR _scanline$[ebp], eax
  0048e	74 0f		 je	 SHORT $LN23@stbtt__ras

; 3231 :       STBTT_free(scanline, userdata);

  00490	8b 85 a4 fd ff
	ff		 mov	 eax, DWORD PTR _scanline$[ebp]
  00496	50		 push	 eax
  00497	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0049c	83 c4 04	 add	 esp, 4
$LN23@stbtt__ras:

; 3232 : }

  0049f	52		 push	 edx
  004a0	8b cd		 mov	 ecx, ebp
  004a2	50		 push	 eax
  004a3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN31@stbtt__ras
  004a9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ae	58		 pop	 eax
  004af	5a		 pop	 edx
  004b0	5f		 pop	 edi
  004b1	5e		 pop	 esi
  004b2	5b		 pop	 ebx
  004b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b6	33 cd		 xor	 ecx, ebp
  004b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bd	81 c4 5c 04 00
	00		 add	 esp, 1116		; 0000045cH
  004c3	3b ec		 cmp	 ebp, esp
  004c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004ca	8b e5		 mov	 esp, ebp
  004cc	5d		 pop	 ebp
  004cd	c3		 ret	 0
  004ce	66 90		 npad	 2
$LN31@stbtt__ras:
  004d0	03 00 00 00	 DD	 3
  004d4	00 00 00 00	 DD	 $LN30@stbtt__ras
$LN30@stbtt__ras:
  004d8	ec ff ff ff	 DD	 -20			; ffffffecH
  004dc	0c 00 00 00	 DD	 12			; 0000000cH
  004e0	00 00 00 00	 DD	 $LN27@stbtt__ras
  004e4	e0 ff ff ff	 DD	 -32			; ffffffe0H
  004e8	04 00 00 00	 DD	 4
  004ec	00 00 00 00	 DD	 $LN28@stbtt__ras
  004f0	b0 fd ff ff	 DD	 -592			; fffffdb0H
  004f4	04 02 00 00	 DD	 516			; 00000204H
  004f8	00 00 00 00	 DD	 $LN29@stbtt__ras
$LN29@stbtt__ras:
  004fc	73		 DB	 115			; 00000073H
  004fd	63		 DB	 99			; 00000063H
  004fe	61		 DB	 97			; 00000061H
  004ff	6e		 DB	 110			; 0000006eH
  00500	6c		 DB	 108			; 0000006cH
  00501	69		 DB	 105			; 00000069H
  00502	6e		 DB	 110			; 0000006eH
  00503	65		 DB	 101			; 00000065H
  00504	5f		 DB	 95			; 0000005fH
  00505	64		 DB	 100			; 00000064H
  00506	61		 DB	 97			; 00000061H
  00507	74		 DB	 116			; 00000074H
  00508	61		 DB	 97			; 00000061H
  00509	00		 DB	 0
$LN28@stbtt__ras:
  0050a	61		 DB	 97			; 00000061H
  0050b	63		 DB	 99			; 00000063H
  0050c	74		 DB	 116			; 00000074H
  0050d	69		 DB	 105			; 00000069H
  0050e	76		 DB	 118			; 00000076H
  0050f	65		 DB	 101			; 00000065H
  00510	00		 DB	 0
$LN27@stbtt__ras:
  00511	68		 DB	 104			; 00000068H
  00512	68		 DB	 104			; 00000068H
  00513	00		 DB	 0
?stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z ENDP ; stbtt__rasterize_sorted_edges
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z
_TEXT	SEGMENT
tv603 = -532						; size = 4
_y2$1 = -332						; size = 4
_y1$2 = -320						; size = 4
_y3$3 = -308						; size = 4
_x3$4 = -296						; size = 4
_x2$5 = -284						; size = 4
_x1$6 = -272						; size = 4
_y0$7 = -260						; size = 4
_x$8 = -248						; size = 4
_t$9 = -236						; size = 4
_area$10 = -224						; size = 4
_sign$11 = -212						; size = 4
_step$12 = -200						; size = 4
_y_crossing$13 = -188					; size = 4
_x2$14 = -176						; size = 4
_x1$15 = -164						; size = 4
_x$16 = -152						; size = 4
_x$17 = -140						; size = 4
_height$18 = -128					; size = 4
_dy$19 = -116						; size = 4
_sy1$20 = -104						; size = 4
_sy0$21 = -92						; size = 4
_x_bottom$22 = -80					; size = 4
_x_top$23 = -68						; size = 4
_xb$24 = -56						; size = 4
_dx$25 = -44						; size = 4
_x0$26 = -32						; size = 4
_x0$27 = -20						; size = 4
_y_bottom$ = -8						; size = 4
_scanline$ = 8						; size = 4
_scanline_fill$ = 12					; size = 4
_len$ = 16						; size = 4
_e$ = 20						; size = 4
_y_top$ = 24						; size = 4
?stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z PROC ; stbtt__fill_active_edges_new, COMDAT

; 2974 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 02 00
	00		 sub	 esp, 532		; 00000214H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fd ff
	ff		 lea	 edi, DWORD PTR [ebp-532]
  00012	b9 85 00 00 00	 mov	 ecx, 133		; 00000085H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2975 :    float y_bottom = y_top+1;

  00028	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y_top$[ebp]
  0002d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00035	f3 0f 11 45 f8	 movss	 DWORD PTR _y_bottom$[ebp], xmm0
$LN2@stbtt__fil:

; 2976 : 
; 2977 :    while (e) {

  0003a	83 7d 14 00	 cmp	 DWORD PTR _e$[ebp], 0
  0003e	0f 84 3e 0d 00
	00		 je	 $LN3@stbtt__fil

; 2978 :       // brute force every pixel
; 2979 : 
; 2980 :       // compute intersection points with top & bottom
; 2981 :       STBTT_assert(e->ey >= y_top);

  00044	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00047	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0004c	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _y_top$[ebp]
  00050	73 26		 jae	 SHORT $LN37@stbtt__fil
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z@4JA
  00058	83 c1 07	 add	 ecx, 7
  0005b	8b f4		 mov	 esi, esp
  0005d	51		 push	 ecx
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN37@stbtt__fil:

; 2982 : 
; 2983 :       if (e->fdx == 0) {

  00078	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  0007b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00080	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00087	9f		 lahf
  00088	f6 c4 44	 test	 ah, 68			; 00000044H
  0008b	0f 8a 00 01 00
	00		 jp	 $LN10@stbtt__fil

; 2984 :          float x0 = e->fx;

  00091	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00094	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00099	f3 0f 11 45 ec	 movss	 DWORD PTR _x0$27[ebp], xmm0

; 2985 :          if (x0 < len) {

  0009e	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _len$[ebp]
  000a3	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _x0$27[ebp]
  000a7	0f 86 df 00 00
	00		 jbe	 $LN14@stbtt__fil

; 2986 :             if (x0 >= 0) {

  000ad	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _x0$27[ebp]
  000b2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000b9	0f 82 8c 00 00
	00		 jb	 $LN13@stbtt__fil

; 2987 :                stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);

  000bf	51		 push	 ecx
  000c0	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _y_bottom$[ebp]
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	51		 push	 ecx
  000cb	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _x0$27[ebp]
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	51		 push	 ecx
  000d6	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y_top$[ebp]
  000db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e0	51		 push	 ecx
  000e1	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _x0$27[ebp]
  000e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000eb	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  000ee	50		 push	 eax
  000ef	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _x0$27[ebp]
  000f4	51		 push	 ecx
  000f5	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  000fe	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2988 :                stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);

  00101	51		 push	 ecx
  00102	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _y_bottom$[ebp]
  00107	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010c	51		 push	 ecx
  0010d	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _x0$27[ebp]
  00112	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00117	51		 push	 ecx
  00118	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y_top$[ebp]
  0011d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00122	51		 push	 ecx
  00123	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _x0$27[ebp]
  00128	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012d	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00130	50		 push	 eax
  00131	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _x0$27[ebp]
  00136	83 c1 01	 add	 ecx, 1
  00139	51		 push	 ecx
  0013a	8b 55 0c	 mov	 edx, DWORD PTR _scanline_fill$[ebp]
  0013d	83 ea 04	 sub	 edx, 4
  00140	52		 push	 edx
  00141	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00146	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2989 :             } else {

  00149	eb 41		 jmp	 SHORT $LN14@stbtt__fil
$LN13@stbtt__fil:

; 2990 :                stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);

  0014b	51		 push	 ecx
  0014c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _y_bottom$[ebp]
  00151	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00156	51		 push	 ecx
  00157	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _x0$27[ebp]
  0015c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00161	51		 push	 ecx
  00162	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y_top$[ebp]
  00167	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016c	51		 push	 ecx
  0016d	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _x0$27[ebp]
  00172	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00177	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  0017a	50		 push	 eax
  0017b	6a 00		 push	 0
  0017d	8b 4d 0c	 mov	 ecx, DWORD PTR _scanline_fill$[ebp]
  00180	83 e9 04	 sub	 ecx, 4
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00189	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN14@stbtt__fil:

; 2991 :             }
; 2992 :          }
; 2993 :       } else {

  0018c	e9 e4 0b 00 00	 jmp	 $LN8@stbtt__fil
$LN10@stbtt__fil:

; 2994 :          float x0 = e->fx;

  00191	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00194	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00199	f3 0f 11 45 e0	 movss	 DWORD PTR _x0$26[ebp], xmm0

; 2995 :          float dx = e->fdx;

  0019e	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  001a1	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001a6	f3 0f 11 45 d4	 movss	 DWORD PTR _dx$25[ebp], xmm0

; 2996 :          float xb = x0 + dx;

  001ab	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  001b0	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _dx$25[ebp]
  001b5	f3 0f 11 45 c8	 movss	 DWORD PTR _xb$24[ebp], xmm0

; 2997 :          float x_top, x_bottom;
; 2998 :          float sy0,sy1;
; 2999 :          float dy = e->fdy;

  001ba	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  001bd	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001c2	f3 0f 11 45 8c	 movss	 DWORD PTR _dy$19[ebp], xmm0

; 3000 :          STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

  001c7	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  001ca	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _y_bottom$[ebp]
  001cf	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  001d3	72 0e		 jb	 SHORT $LN38@stbtt__fil
  001d5	8b 4d 14	 mov	 ecx, DWORD PTR _e$[ebp]
  001d8	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  001dd	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _y_top$[ebp]
  001e1	73 26		 jae	 SHORT $LN39@stbtt__fil
$LN38@stbtt__fil:
  001e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z@4JA
  001e9	83 c2 1a	 add	 edx, 26			; 0000001aH
  001ec	8b f4		 mov	 esi, esp
  001ee	52		 push	 edx
  001ef	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001f4	68 00 00 00 00	 push	 OFFSET ??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00202	3b f4		 cmp	 esi, esp
  00204	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN39@stbtt__fil:

; 3001 : 
; 3002 :          // compute endpoints of line segment clipped to this scanline (if the
; 3003 :          // line segment starts on this scanline. x0 is the intersection of the
; 3004 :          // line with y_top, but that may be off the line segment.
; 3005 :          if (e->sy > y_top) {

  00209	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  0020c	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00211	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _y_top$[ebp]
  00215	76 2b		 jbe	 SHORT $LN15@stbtt__fil

; 3006 :             x_top = x0 + dx * (e->sy - y_top);

  00217	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  0021a	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0021f	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _y_top$[ebp]
  00224	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _dx$25[ebp]
  00229	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _x0$26[ebp]
  0022e	f3 0f 11 45 bc	 movss	 DWORD PTR _x_top$23[ebp], xmm0

; 3007 :             sy0 = e->sy;

  00233	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00236	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0023b	f3 0f 11 45 a4	 movss	 DWORD PTR _sy0$21[ebp], xmm0

; 3008 :          } else {

  00240	eb 14		 jmp	 SHORT $LN16@stbtt__fil
$LN15@stbtt__fil:

; 3009 :             x_top = x0;

  00242	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00247	f3 0f 11 45 bc	 movss	 DWORD PTR _x_top$23[ebp], xmm0

; 3010 :             sy0 = y_top;

  0024c	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y_top$[ebp]
  00251	f3 0f 11 45 a4	 movss	 DWORD PTR _sy0$21[ebp], xmm0
$LN16@stbtt__fil:

; 3011 :          }
; 3012 :          if (e->ey < y_bottom) {

  00256	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00259	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _y_bottom$[ebp]
  0025e	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00262	76 2b		 jbe	 SHORT $LN17@stbtt__fil

; 3013 :             x_bottom = x0 + dx * (e->ey - y_top);

  00264	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00267	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0026c	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _y_top$[ebp]
  00271	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _dx$25[ebp]
  00276	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _x0$26[ebp]
  0027b	f3 0f 11 45 b0	 movss	 DWORD PTR _x_bottom$22[ebp], xmm0

; 3014 :             sy1 = e->ey;

  00280	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00283	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00288	f3 0f 11 45 98	 movss	 DWORD PTR _sy1$20[ebp], xmm0

; 3015 :          } else {

  0028d	eb 14		 jmp	 SHORT $LN18@stbtt__fil
$LN17@stbtt__fil:

; 3016 :             x_bottom = xb;

  0028f	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _xb$24[ebp]
  00294	f3 0f 11 45 b0	 movss	 DWORD PTR _x_bottom$22[ebp], xmm0

; 3017 :             sy1 = y_bottom;

  00299	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _y_bottom$[ebp]
  0029e	f3 0f 11 45 98	 movss	 DWORD PTR _sy1$20[ebp], xmm0
$LN18@stbtt__fil:

; 3018 :          }
; 3019 : 
; 3020 :          if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {

  002a3	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _x_top$23[ebp]
  002a8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002af	0f 82 71 04 00
	00		 jb	 $LN19@stbtt__fil
  002b5	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _x_bottom$22[ebp]
  002ba	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002c1	0f 82 5f 04 00
	00		 jb	 $LN19@stbtt__fil
  002c7	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _len$[ebp]
  002cc	0f 2f 45 bc	 comiss	 xmm0, DWORD PTR _x_top$23[ebp]
  002d0	0f 86 50 04 00
	00		 jbe	 $LN19@stbtt__fil
  002d6	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _len$[ebp]
  002db	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _x_bottom$22[ebp]
  002df	0f 86 41 04 00
	00		 jbe	 $LN19@stbtt__fil

; 3021 :             // from here on, we don't have to range check x values
; 3022 : 
; 3023 :             if ((int) x_top == (int) x_bottom) {

  002e5	f3 0f 2c 45 bc	 cvttss2si eax, DWORD PTR _x_top$23[ebp]
  002ea	f3 0f 2c 4d b0	 cvttss2si ecx, DWORD PTR _x_bottom$22[ebp]
  002ef	3b c1		 cmp	 eax, ecx
  002f1	0f 85 e5 00 00
	00		 jne	 $LN21@stbtt__fil

; 3024 :                float height;
; 3025 :                // simple case, only spans one pixel
; 3026 :                int x = (int) x_top;

  002f7	f3 0f 2c 45 bc	 cvttss2si eax, DWORD PTR _x_top$23[ebp]
  002fc	89 85 74 ff ff
	ff		 mov	 DWORD PTR _x$17[ebp], eax

; 3027 :                height = sy1 - sy0;

  00302	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sy1$20[ebp]
  00307	f3 0f 5c 45 a4	 subss	 xmm0, DWORD PTR _sy0$21[ebp]
  0030c	f3 0f 11 45 80	 movss	 DWORD PTR _height$18[ebp], xmm0

; 3028 :                STBTT_assert(x >= 0 && x < len);

  00311	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _x$17[ebp], 0
  00318	7c 0b		 jl	 SHORT $LN40@stbtt__fil
  0031a	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  00320	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  00323	7c 26		 jl	 SHORT $LN41@stbtt__fil
$LN40@stbtt__fil:
  00325	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z@4JA
  0032b	83 c1 36	 add	 ecx, 54			; 00000036H
  0032e	8b f4		 mov	 esi, esp
  00330	51		 push	 ecx
  00331	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00336	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00341	83 c4 0c	 add	 esp, 12			; 0000000cH
  00344	3b f4		 cmp	 esi, esp
  00346	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN41@stbtt__fil:

; 3029 :                scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;

  0034b	f3 0f 2a 85 74
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _x$17[ebp]
  00353	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR _x_top$23[ebp]
  00358	f3 0f 5c c8	 subss	 xmm1, xmm0
  0035c	f3 0f 2a 85 74
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _x$17[ebp]
  00364	f3 0f 10 55 b0	 movss	 xmm2, DWORD PTR _x_bottom$22[ebp]
  00369	f3 0f 5c d0	 subss	 xmm2, xmm0
  0036d	f3 0f 58 ca	 addss	 xmm1, xmm2
  00371	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00379	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00381	f3 0f 5c c1	 subss	 xmm0, xmm1
  00385	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00388	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  0038d	f3 0f 59 45 80	 mulss	 xmm0, DWORD PTR _height$18[ebp]
  00392	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  00398	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  0039b	f3 0f 58 04 8a	 addss	 xmm0, DWORD PTR [edx+ecx*4]
  003a0	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  003a6	8b 4d 08	 mov	 ecx, DWORD PTR _scanline$[ebp]
  003a9	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0

; 3030 :                scanline_fill[x] += e->direction * height; // everything right of this pixel is filled

  003ae	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  003b1	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  003b6	f3 0f 59 45 80	 mulss	 xmm0, DWORD PTR _height$18[ebp]
  003bb	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _x$17[ebp]
  003c1	8b 55 0c	 mov	 edx, DWORD PTR _scanline_fill$[ebp]
  003c4	f3 0f 58 04 8a	 addss	 xmm0, DWORD PTR [edx+ecx*4]
  003c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _x$17[ebp]
  003cf	8b 4d 0c	 mov	 ecx, DWORD PTR _scanline_fill$[ebp]
  003d2	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0

; 3031 :             } else {

  003d7	e9 45 03 00 00	 jmp	 $LN22@stbtt__fil
$LN21@stbtt__fil:

; 3032 :                int x,x1,x2;
; 3033 :                float y_crossing, step, sign, area;
; 3034 :                // covers 2+ pixels
; 3035 :                if (x_top > x_bottom) {

  003dc	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _x_top$23[ebp]
  003e1	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _x_bottom$22[ebp]
  003e5	0f 86 be 00 00
	00		 jbe	 $LN23@stbtt__fil

; 3036 :                   // flip scanline vertically; signed area is the same
; 3037 :                   float t;
; 3038 :                   sy0 = y_bottom - (sy0 - y_top);

  003eb	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _sy0$21[ebp]
  003f0	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _y_top$[ebp]
  003f5	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _y_bottom$[ebp]
  003fa	f3 0f 5c c8	 subss	 xmm1, xmm0
  003fe	f3 0f 11 4d a4	 movss	 DWORD PTR _sy0$21[ebp], xmm1

; 3039 :                   sy1 = y_bottom - (sy1 - y_top);

  00403	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sy1$20[ebp]
  00408	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _y_top$[ebp]
  0040d	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _y_bottom$[ebp]
  00412	f3 0f 5c c8	 subss	 xmm1, xmm0
  00416	f3 0f 11 4d 98	 movss	 DWORD PTR _sy1$20[ebp], xmm1

; 3040 :                   t = sy0, sy0 = sy1, sy1 = t;

  0041b	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _sy0$21[ebp]
  00420	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _t$9[ebp], xmm0
  00428	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sy1$20[ebp]
  0042d	f3 0f 11 45 a4	 movss	 DWORD PTR _sy0$21[ebp], xmm0
  00432	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _t$9[ebp]
  0043a	f3 0f 11 45 98	 movss	 DWORD PTR _sy1$20[ebp], xmm0

; 3041 :                   t = x_bottom, x_bottom = x_top, x_top = t;

  0043f	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _x_bottom$22[ebp]
  00444	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _t$9[ebp], xmm0
  0044c	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _x_top$23[ebp]
  00451	f3 0f 11 45 b0	 movss	 DWORD PTR _x_bottom$22[ebp], xmm0
  00456	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _t$9[ebp]
  0045e	f3 0f 11 45 bc	 movss	 DWORD PTR _x_top$23[ebp], xmm0

; 3042 :                   dx = -dx;

  00463	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _dx$25[ebp]
  00468	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0046f	f3 0f 11 45 d4	 movss	 DWORD PTR _dx$25[ebp], xmm0

; 3043 :                   dy = -dy;

  00474	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _dy$19[ebp]
  00479	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00480	f3 0f 11 45 8c	 movss	 DWORD PTR _dy$19[ebp], xmm0

; 3044 :                   t = x0, x0 = xb, xb = t;

  00485	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  0048a	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _t$9[ebp], xmm0
  00492	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _xb$24[ebp]
  00497	f3 0f 11 45 e0	 movss	 DWORD PTR _x0$26[ebp], xmm0
  0049c	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _t$9[ebp]
  004a4	f3 0f 11 45 c8	 movss	 DWORD PTR _xb$24[ebp], xmm0
$LN23@stbtt__fil:

; 3045 :                   // [DEAR IMGUI] Fix static analyzer warning
; 3046 :                   (void)dx; // [ImGui: fix static analyzer warning]
; 3047 :                }
; 3048 : 
; 3049 :                x1 = (int) x_top;

  004a9	f3 0f 2c 45 bc	 cvttss2si eax, DWORD PTR _x_top$23[ebp]
  004ae	89 85 5c ff ff
	ff		 mov	 DWORD PTR _x1$15[ebp], eax

; 3050 :                x2 = (int) x_bottom;

  004b4	f3 0f 2c 45 b0	 cvttss2si eax, DWORD PTR _x_bottom$22[ebp]
  004b9	89 85 50 ff ff
	ff		 mov	 DWORD PTR _x2$14[ebp], eax

; 3051 :                // compute intersection with y axis at x1+1
; 3052 :                y_crossing = (x1+1 - x0) * dy + y_top;

  004bf	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _x1$15[ebp]
  004c5	83 c0 01	 add	 eax, 1
  004c8	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004cc	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _x0$26[ebp]
  004d1	f3 0f 59 45 8c	 mulss	 xmm0, DWORD PTR _dy$19[ebp]
  004d6	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _y_top$[ebp]
  004db	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _y_crossing$13[ebp], xmm0

; 3053 : 
; 3054 :                sign = e->direction;

  004e3	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  004e6	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  004eb	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _sign$11[ebp], xmm0

; 3055 :                // area of the rectangle covered from y0..y_crossing
; 3056 :                area = sign * (y_crossing-sy0);

  004f3	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _y_crossing$13[ebp]
  004fb	f3 0f 5c 45 a4	 subss	 xmm0, DWORD PTR _sy0$21[ebp]
  00500	f3 0f 59 85 2c
	ff ff ff	 mulss	 xmm0, DWORD PTR _sign$11[ebp]
  00508	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _area$10[ebp], xmm0

; 3057 :                // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
; 3058 :                scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

  00510	f3 0f 2a 85 5c
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _x1$15[ebp]
  00518	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR _x_top$23[ebp]
  0051d	f3 0f 5c c8	 subss	 xmm1, xmm0
  00521	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _x1$15[ebp]
  00527	83 c0 01	 add	 eax, 1
  0052a	2b 85 5c ff ff
	ff		 sub	 eax, DWORD PTR _x1$15[ebp]
  00530	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00534	f3 0f 58 c8	 addss	 xmm1, xmm0
  00538	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00540	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00548	f3 0f 5c c1	 subss	 xmm0, xmm1
  0054c	f3 0f 59 85 20
	ff ff ff	 mulss	 xmm0, DWORD PTR _area$10[ebp]
  00554	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _x1$15[ebp]
  0055a	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  0055d	f3 0f 58 04 8a	 addss	 xmm0, DWORD PTR [edx+ecx*4]
  00562	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _x1$15[ebp]
  00568	8b 4d 08	 mov	 ecx, DWORD PTR _scanline$[ebp]
  0056b	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0

; 3059 : 
; 3060 :                step = sign * dy;

  00570	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _sign$11[ebp]
  00578	f3 0f 59 45 8c	 mulss	 xmm0, DWORD PTR _dy$19[ebp]
  0057d	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _step$12[ebp], xmm0

; 3061 :                for (x = x1+1; x < x2; ++x) {

  00585	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _x1$15[ebp]
  0058b	83 c0 01	 add	 eax, 1
  0058e	89 85 68 ff ff
	ff		 mov	 DWORD PTR _x$16[ebp], eax
  00594	eb 0f		 jmp	 SHORT $LN6@stbtt__fil
$LN4@stbtt__fil:
  00596	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _x$16[ebp]
  0059c	83 c0 01	 add	 eax, 1
  0059f	89 85 68 ff ff
	ff		 mov	 DWORD PTR _x$16[ebp], eax
$LN6@stbtt__fil:
  005a5	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _x$16[ebp]
  005ab	3b 85 50 ff ff
	ff		 cmp	 eax, DWORD PTR _x2$14[ebp]
  005b1	7d 4e		 jge	 SHORT $LN5@stbtt__fil

; 3062 :                   scanline[x] += area + step/2;

  005b3	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _step$12[ebp]
  005bb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  005c3	f3 0f 58 85 20
	ff ff ff	 addss	 xmm0, DWORD PTR _area$10[ebp]
  005cb	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _x$16[ebp]
  005d1	8b 4d 08	 mov	 ecx, DWORD PTR _scanline$[ebp]
  005d4	f3 0f 58 04 81	 addss	 xmm0, DWORD PTR [ecx+eax*4]
  005d9	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _x$16[ebp]
  005df	8b 45 08	 mov	 eax, DWORD PTR _scanline$[ebp]
  005e2	f3 0f 11 04 90	 movss	 DWORD PTR [eax+edx*4], xmm0

; 3063 :                   area += step;

  005e7	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _area$10[ebp]
  005ef	f3 0f 58 85 38
	ff ff ff	 addss	 xmm0, DWORD PTR _step$12[ebp]
  005f7	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _area$10[ebp], xmm0

; 3064 :                }

  005ff	eb 95		 jmp	 SHORT $LN4@stbtt__fil
$LN5@stbtt__fil:

; 3065 :                y_crossing += dy * (x2 - (x1+1));

  00601	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _x1$15[ebp]
  00607	83 c0 01	 add	 eax, 1
  0060a	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _x2$14[ebp]
  00610	2b c8		 sub	 ecx, eax
  00612	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00616	f3 0f 59 45 8c	 mulss	 xmm0, DWORD PTR _dy$19[ebp]
  0061b	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _y_crossing$13[ebp]
  00623	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _y_crossing$13[ebp], xmm0

; 3066 : 
; 3067 :                STBTT_assert(STBTT_fabs(area) <= 1.01f);

  0062b	51		 push	 ecx
  0062c	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _area$10[ebp]
  00634	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00639	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  0063e	83 c4 04	 add	 esp, 4
  00641	d9 9d ec fd ff
	ff		 fstp	 DWORD PTR tv603[ebp]
  00647	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f8147ae
  0064f	0f 2f 85 ec fd
	ff ff		 comiss	 xmm0, DWORD PTR tv603[ebp]
  00656	73 25		 jae	 SHORT $LN42@stbtt__fil
  00658	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z@4JA
  0065d	83 c0 5d	 add	 eax, 93			; 0000005dH
  00660	8b f4		 mov	 esi, esp
  00662	50		 push	 eax
  00663	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00668	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@OJNMKDLP@?$AAI?$AAm?$AAF?$AAa?$AAb?$AAs?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN@
  0066d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00673	83 c4 0c	 add	 esp, 12			; 0000000cH
  00676	3b f4		 cmp	 esi, esp
  00678	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN42@stbtt__fil:

; 3068 : 
; 3069 :                scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

  0067d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _x2$14[ebp]
  00683	2b 85 50 ff ff
	ff		 sub	 eax, DWORD PTR _x2$14[ebp]
  00689	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0068d	f3 0f 2a 8d 50
	ff ff ff	 cvtsi2ss xmm1, DWORD PTR _x2$14[ebp]
  00695	f3 0f 10 55 b0	 movss	 xmm2, DWORD PTR _x_bottom$22[ebp]
  0069a	f3 0f 5c d1	 subss	 xmm2, xmm1
  0069e	f3 0f 58 c2	 addss	 xmm0, xmm2
  006a2	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  006aa	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  006b2	f3 0f 5c c8	 subss	 xmm1, xmm0
  006b6	f3 0f 59 8d 2c
	ff ff ff	 mulss	 xmm1, DWORD PTR _sign$11[ebp]
  006be	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sy1$20[ebp]
  006c3	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _y_crossing$13[ebp]
  006cb	f3 0f 59 c8	 mulss	 xmm1, xmm0
  006cf	f3 0f 58 8d 20
	ff ff ff	 addss	 xmm1, DWORD PTR _area$10[ebp]
  006d7	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _x2$14[ebp]
  006dd	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  006e0	f3 0f 58 0c 8a	 addss	 xmm1, DWORD PTR [edx+ecx*4]
  006e5	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _x2$14[ebp]
  006eb	8b 4d 08	 mov	 ecx, DWORD PTR _scanline$[ebp]
  006ee	f3 0f 11 0c 81	 movss	 DWORD PTR [ecx+eax*4], xmm1

; 3070 : 
; 3071 :                scanline_fill[x2] += sign * (sy1-sy0);

  006f3	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sy1$20[ebp]
  006f8	f3 0f 5c 45 a4	 subss	 xmm0, DWORD PTR _sy0$21[ebp]
  006fd	f3 0f 59 85 2c
	ff ff ff	 mulss	 xmm0, DWORD PTR _sign$11[ebp]
  00705	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _x2$14[ebp]
  0070b	8b 4d 0c	 mov	 ecx, DWORD PTR _scanline_fill$[ebp]
  0070e	f3 0f 58 04 81	 addss	 xmm0, DWORD PTR [ecx+eax*4]
  00713	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _x2$14[ebp]
  00719	8b 45 0c	 mov	 eax, DWORD PTR _scanline_fill$[ebp]
  0071c	f3 0f 11 04 90	 movss	 DWORD PTR [eax+edx*4], xmm0
$LN22@stbtt__fil:

; 3072 :             }
; 3073 :          } else {

  00721	e9 4f 06 00 00	 jmp	 $LN8@stbtt__fil
$LN19@stbtt__fil:

; 3074 :             // if edge goes outside of box we're drawing, we require
; 3075 :             // clipping logic. since this does not match the intended use
; 3076 :             // of this library, we use a different, very slow brute
; 3077 :             // force implementation
; 3078 :             int x;
; 3079 :             for (x=0; x < len; ++x) {

  00726	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$8[ebp], 0
  00730	eb 0f		 jmp	 SHORT $LN9@stbtt__fil
$LN7@stbtt__fil:
  00732	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00738	83 c0 01	 add	 eax, 1
  0073b	89 85 08 ff ff
	ff		 mov	 DWORD PTR _x$8[ebp], eax
$LN9@stbtt__fil:
  00741	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00747	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  0074a	0f 8d 25 06 00
	00		 jge	 $LN8@stbtt__fil

; 3080 :                // cases:
; 3081 :                //
; 3082 :                // there can be up to two intersections with the pixel. any intersection
; 3083 :                // with left or right edges can be handled by splitting into two (or three)
; 3084 :                // regions. intersections with top & bottom do not necessitate case-wise logic.
; 3085 :                //
; 3086 :                // the old way of doing this found the intersections with the left & right edges,
; 3087 :                // then used some simple logic to produce up to three segments in sorted order
; 3088 :                // from top-to-bottom. however, this had a problem: if an x edge was epsilon
; 3089 :                // across the x border, then the corresponding y position might not be distinct
; 3090 :                // from the other y segment, and it might ignored as an empty segment. to avoid
; 3091 :                // that, we need to explicitly produce segments based on x positions.
; 3092 : 
; 3093 :                // rename variables to clearly-defined pairs
; 3094 :                float y0 = y_top;

  00750	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y_top$[ebp]
  00755	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _y0$7[ebp], xmm0

; 3095 :                float x1 = (float) (x);

  0075d	f3 0f 2a 85 08
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _x$8[ebp]
  00765	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _x1$6[ebp], xmm0

; 3096 :                float x2 = (float) (x+1);

  0076d	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  00773	83 c0 01	 add	 eax, 1
  00776	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0077a	f3 0f 11 85 e4
	fe ff ff	 movss	 DWORD PTR _x2$5[ebp], xmm0

; 3097 :                float x3 = xb;

  00782	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _xb$24[ebp]
  00787	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR _x3$4[ebp], xmm0

; 3098 :                float y3 = y_bottom;

  0078f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _y_bottom$[ebp]
  00794	f3 0f 11 85 cc
	fe ff ff	 movss	 DWORD PTR _y3$3[ebp], xmm0

; 3099 : 
; 3100 :                // x = e->x + e->dx * (y-y_top)
; 3101 :                // (y-y_top) = (x - e->x) / e->dx
; 3102 :                // y = (x - e->x) / e->dx + y_top
; 3103 :                float y1 = (x - x0) / dx + y_top;

  0079c	f3 0f 2a 85 08
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _x$8[ebp]
  007a4	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _x0$26[ebp]
  007a9	f3 0f 5e 45 d4	 divss	 xmm0, DWORD PTR _dx$25[ebp]
  007ae	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _y_top$[ebp]
  007b3	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _y1$2[ebp], xmm0

; 3104 :                float y2 = (x+1 - x0) / dx + y_top;

  007bb	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _x$8[ebp]
  007c1	83 c0 01	 add	 eax, 1
  007c4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  007c8	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _x0$26[ebp]
  007cd	f3 0f 5e 45 d4	 divss	 xmm0, DWORD PTR _dx$25[ebp]
  007d2	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _y_top$[ebp]
  007d7	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _y2$1[ebp], xmm0

; 3105 : 
; 3106 :                if (x0 < x1 && x3 > x2) {         // three segments descending down-right

  007df	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  007e7	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR _x0$26[ebp]
  007eb	0f 86 04 01 00
	00		 jbe	 $LN24@stbtt__fil
  007f1	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  007f9	0f 2f 85 e4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x2$5[ebp]
  00800	0f 86 ef 00 00
	00		 jbe	 $LN24@stbtt__fil

; 3107 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

  00806	51		 push	 ecx
  00807	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  0080f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00814	51		 push	 ecx
  00815	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  0081d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00822	51		 push	 ecx
  00823	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _y0$7[ebp]
  0082b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00830	51		 push	 ecx
  00831	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00836	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0083b	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  0083e	50		 push	 eax
  0083f	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00845	51		 push	 ecx
  00846	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00849	52		 push	 edx
  0084a	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  0084f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3108 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);

  00852	51		 push	 ecx
  00853	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  0085b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00860	51		 push	 ecx
  00861	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00869	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0086e	51		 push	 ecx
  0086f	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  00877	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0087c	51		 push	 ecx
  0087d	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  00885	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0088a	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  0088d	50		 push	 eax
  0088e	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00894	51		 push	 ecx
  00895	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00898	52		 push	 edx
  00899	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  0089e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3109 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

  008a1	51		 push	 ecx
  008a2	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _y3$3[ebp]
  008aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008af	51		 push	 ecx
  008b0	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  008b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008bd	51		 push	 ecx
  008be	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  008c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008cb	51		 push	 ecx
  008cc	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  008d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d9	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  008dc	50		 push	 eax
  008dd	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  008e3	51		 push	 ecx
  008e4	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  008e7	52		 push	 edx
  008e8	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  008ed	83 c4 1c	 add	 esp, 28			; 0000001cH
  008f0	e9 7b 04 00 00	 jmp	 $LN35@stbtt__fil
$LN24@stbtt__fil:

; 3110 :                } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left

  008f5	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  008fd	0f 2f 85 d8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x3$4[ebp]
  00904	0f 86 01 01 00
	00		 jbe	 $LN26@stbtt__fil
  0090a	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  0090f	0f 2f 85 e4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x2$5[ebp]
  00916	0f 86 ef 00 00
	00		 jbe	 $LN26@stbtt__fil

; 3111 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

  0091c	51		 push	 ecx
  0091d	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  00925	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0092a	51		 push	 ecx
  0092b	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00933	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00938	51		 push	 ecx
  00939	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _y0$7[ebp]
  00941	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00946	51		 push	 ecx
  00947	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  0094c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00951	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00954	50		 push	 eax
  00955	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  0095b	51		 push	 ecx
  0095c	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  0095f	52		 push	 edx
  00960	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00965	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3112 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);

  00968	51		 push	 ecx
  00969	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  00971	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00976	51		 push	 ecx
  00977	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  0097f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00984	51		 push	 ecx
  00985	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  0098d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00992	51		 push	 ecx
  00993	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  0099b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009a0	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  009a3	50		 push	 eax
  009a4	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  009aa	51		 push	 ecx
  009ab	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  009ae	52		 push	 edx
  009af	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  009b4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3113 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

  009b7	51		 push	 ecx
  009b8	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _y3$3[ebp]
  009c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009c5	51		 push	 ecx
  009c6	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  009ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009d3	51		 push	 ecx
  009d4	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  009dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009e1	51		 push	 ecx
  009e2	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  009ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009ef	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  009f2	50		 push	 eax
  009f3	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  009f9	51		 push	 ecx
  009fa	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  009fd	52		 push	 edx
  009fe	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00a03	83 c4 1c	 add	 esp, 28			; 0000001cH
  00a06	e9 65 03 00 00	 jmp	 $LN35@stbtt__fil
$LN26@stbtt__fil:

; 3114 :                } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right

  00a0b	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  00a13	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR _x0$26[ebp]
  00a17	0f 86 b5 00 00
	00		 jbe	 $LN28@stbtt__fil
  00a1d	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  00a25	0f 2f 85 f0 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x1$6[ebp]
  00a2c	0f 86 a0 00 00
	00		 jbe	 $LN28@stbtt__fil

; 3115 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

  00a32	51		 push	 ecx
  00a33	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  00a3b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a40	51		 push	 ecx
  00a41	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  00a49	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a4e	51		 push	 ecx
  00a4f	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _y0$7[ebp]
  00a57	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a5c	51		 push	 ecx
  00a5d	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00a62	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a67	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00a6a	50		 push	 eax
  00a6b	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00a71	51		 push	 ecx
  00a72	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00a75	52		 push	 edx
  00a76	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00a7b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3116 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

  00a7e	51		 push	 ecx
  00a7f	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _y3$3[ebp]
  00a87	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a8c	51		 push	 ecx
  00a8d	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  00a95	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a9a	51		 push	 ecx
  00a9b	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  00aa3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aa8	51		 push	 ecx
  00aa9	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  00ab1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ab6	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00ab9	50		 push	 eax
  00aba	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00ac0	51		 push	 ecx
  00ac1	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00ac4	52		 push	 edx
  00ac5	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00aca	83 c4 1c	 add	 esp, 28			; 0000001cH
  00acd	e9 9e 02 00 00	 jmp	 $LN35@stbtt__fil
$LN28@stbtt__fil:

; 3117 :                } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left

  00ad2	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  00ada	0f 2f 85 d8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x3$4[ebp]
  00ae1	0f 86 b2 00 00
	00		 jbe	 $LN30@stbtt__fil
  00ae7	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00aec	0f 2f 85 f0 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x1$6[ebp]
  00af3	0f 86 a0 00 00
	00		 jbe	 $LN30@stbtt__fil

; 3118 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

  00af9	51		 push	 ecx
  00afa	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  00b02	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b07	51		 push	 ecx
  00b08	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  00b10	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b15	51		 push	 ecx
  00b16	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _y0$7[ebp]
  00b1e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b23	51		 push	 ecx
  00b24	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00b29	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b2e	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00b31	50		 push	 eax
  00b32	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00b38	51		 push	 ecx
  00b39	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00b3c	52		 push	 edx
  00b3d	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00b42	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3119 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

  00b45	51		 push	 ecx
  00b46	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _y3$3[ebp]
  00b4e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b53	51		 push	 ecx
  00b54	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  00b5c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b61	51		 push	 ecx
  00b62	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$2[ebp]
  00b6a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b6f	51		 push	 ecx
  00b70	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _x1$6[ebp]
  00b78	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b7d	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00b80	50		 push	 eax
  00b81	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00b87	51		 push	 ecx
  00b88	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00b8b	52		 push	 edx
  00b8c	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00b91	83 c4 1c	 add	 esp, 28			; 0000001cH
  00b94	e9 d7 01 00 00	 jmp	 $LN35@stbtt__fil
$LN30@stbtt__fil:

; 3120 :                } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right

  00b99	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00ba1	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR _x0$26[ebp]
  00ba5	0f 86 b5 00 00
	00		 jbe	 $LN32@stbtt__fil
  00bab	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  00bb3	0f 2f 85 e4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x2$5[ebp]
  00bba	0f 86 a0 00 00
	00		 jbe	 $LN32@stbtt__fil

; 3121 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

  00bc0	51		 push	 ecx
  00bc1	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  00bc9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bce	51		 push	 ecx
  00bcf	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00bd7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bdc	51		 push	 ecx
  00bdd	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _y0$7[ebp]
  00be5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bea	51		 push	 ecx
  00beb	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00bf0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bf5	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00bf8	50		 push	 eax
  00bf9	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00bff	51		 push	 ecx
  00c00	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00c03	52		 push	 edx
  00c04	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00c09	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3122 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

  00c0c	51		 push	 ecx
  00c0d	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _y3$3[ebp]
  00c15	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c1a	51		 push	 ecx
  00c1b	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  00c23	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c28	51		 push	 ecx
  00c29	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  00c31	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c36	51		 push	 ecx
  00c37	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00c3f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c44	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00c47	50		 push	 eax
  00c48	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00c4e	51		 push	 ecx
  00c4f	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00c52	52		 push	 edx
  00c53	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00c58	83 c4 1c	 add	 esp, 28			; 0000001cH
  00c5b	e9 10 01 00 00	 jmp	 $LN35@stbtt__fil
$LN32@stbtt__fil:

; 3123 :                } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left

  00c60	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00c68	0f 2f 85 d8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x3$4[ebp]
  00c6f	0f 86 af 00 00
	00		 jbe	 $LN34@stbtt__fil
  00c75	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00c7a	0f 2f 85 e4 fe
	ff ff		 comiss	 xmm0, DWORD PTR _x2$5[ebp]
  00c81	0f 86 9d 00 00
	00		 jbe	 $LN34@stbtt__fil

; 3124 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

  00c87	51		 push	 ecx
  00c88	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  00c90	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c95	51		 push	 ecx
  00c96	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00c9e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ca3	51		 push	 ecx
  00ca4	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _y0$7[ebp]
  00cac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cb1	51		 push	 ecx
  00cb2	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00cb7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cbc	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00cbf	50		 push	 eax
  00cc0	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00cc6	51		 push	 ecx
  00cc7	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00cca	52		 push	 edx
  00ccb	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00cd0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3125 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

  00cd3	51		 push	 ecx
  00cd4	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _y3$3[ebp]
  00cdc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ce1	51		 push	 ecx
  00ce2	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  00cea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cef	51		 push	 ecx
  00cf0	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$1[ebp]
  00cf8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cfd	51		 push	 ecx
  00cfe	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$5[ebp]
  00d06	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d0b	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00d0e	50		 push	 eax
  00d0f	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00d15	51		 push	 ecx
  00d16	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00d19	52		 push	 edx
  00d1a	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00d1f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3126 :                } else {  // one segment

  00d22	eb 4c		 jmp	 SHORT $LN35@stbtt__fil
$LN34@stbtt__fil:

; 3127 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);

  00d24	51		 push	 ecx
  00d25	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _y3$3[ebp]
  00d2d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d32	51		 push	 ecx
  00d33	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _x3$4[ebp]
  00d3b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d40	51		 push	 ecx
  00d41	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _y0$7[ebp]
  00d49	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d4e	51		 push	 ecx
  00d4f	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _x0$26[ebp]
  00d54	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d59	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00d5c	50		 push	 eax
  00d5d	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _x$8[ebp]
  00d63	51		 push	 ecx
  00d64	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00d67	52		 push	 edx
  00d68	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  00d6d	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN35@stbtt__fil:

; 3128 :                }
; 3129 :             }

  00d70	e9 bd f9 ff ff	 jmp	 $LN7@stbtt__fil
$LN8@stbtt__fil:

; 3130 :          }
; 3131 :       }
; 3132 :       e = e->next;

  00d75	8b 45 14	 mov	 eax, DWORD PTR _e$[ebp]
  00d78	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d7a	89 4d 14	 mov	 DWORD PTR _e$[ebp], ecx

; 3133 :    }

  00d7d	e9 b8 f2 ff ff	 jmp	 $LN2@stbtt__fil
$LN3@stbtt__fil:

; 3134 : }

  00d82	5f		 pop	 edi
  00d83	5e		 pop	 esi
  00d84	5b		 pop	 ebx
  00d85	81 c4 14 02 00
	00		 add	 esp, 532		; 00000214H
  00d8b	3b ec		 cmp	 ebp, esp
  00d8d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d92	8b e5		 mov	 esp, ebp
  00d94	5d		 pop	 ebp
  00d95	c3		 ret	 0
?stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z ENDP ; stbtt__fill_active_edges_new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z
_TEXT	SEGMENT
_scanline$ = 8						; size = 4
_x$ = 12						; size = 4
_e$ = 16						; size = 4
_x0$ = 20						; size = 4
_y0$ = 24						; size = 4
_x1$ = 28						; size = 4
_y1$ = 32						; size = 4
?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z PROC ; stbtt__handle_clipped_edge, COMDAT

; 2937 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2938 :    if (y0 == y1) return;

  00028	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y0$[ebp]
  0002d	0f 2e 45 20	 ucomiss xmm0, DWORD PTR _y1$[ebp]
  00031	9f		 lahf
  00032	f6 c4 44	 test	 ah, 68			; 00000044H
  00035	7a 05		 jp	 SHORT $LN2@stbtt__han
  00037	e9 d1 03 00 00	 jmp	 $LN1@stbtt__han
$LN2@stbtt__han:

; 2939 :    STBTT_assert(y0 < y1);

  0003c	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00041	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _y0$[ebp]
  00045	77 25		 ja	 SHORT $LN20@stbtt__han
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  0004c	83 c0 02	 add	 eax, 2
  0004f	8b f4		 mov	 esi, esp
  00051	50		 push	 eax
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@stbtt__han:

; 2940 :    STBTT_assert(e->sy <= e->ey);

  0006c	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _e$[ebp]
  00072	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00077	0f 2f 41 14	 comiss	 xmm0, DWORD PTR [ecx+20]
  0007b	73 26		 jae	 SHORT $LN21@stbtt__han
  0007d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  00083	83 c2 03	 add	 edx, 3
  00086	8b f4		 mov	 esi, esp
  00088	52		 push	 edx
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@stbtt__han:

; 2941 :    if (y0 > e->ey) return;

  000a3	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  000a6	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y0$[ebp]
  000ab	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  000af	76 05		 jbe	 SHORT $LN3@stbtt__han
  000b1	e9 57 03 00 00	 jmp	 $LN1@stbtt__han
$LN3@stbtt__han:

; 2942 :    if (y1 < e->sy) return;

  000b6	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  000b9	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000be	0f 2f 45 20	 comiss	 xmm0, DWORD PTR _y1$[ebp]
  000c2	76 05		 jbe	 SHORT $LN4@stbtt__han
  000c4	e9 44 03 00 00	 jmp	 $LN1@stbtt__han
$LN4@stbtt__han:

; 2943 :    if (y0 < e->sy) {

  000c9	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  000cc	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000d1	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _y0$[ebp]
  000d5	76 40		 jbe	 SHORT $LN5@stbtt__han

; 2944 :       x0 += (x1-x0) * (e->sy - y0) / (y1-y0);

  000d7	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _x1$[ebp]
  000dc	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _x0$[ebp]
  000e1	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  000e4	f3 0f 10 48 14	 movss	 xmm1, DWORD PTR [eax+20]
  000e9	f3 0f 5c 4d 18	 subss	 xmm1, DWORD PTR _y0$[ebp]
  000ee	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000f2	f3 0f 10 4d 20	 movss	 xmm1, DWORD PTR _y1$[ebp]
  000f7	f3 0f 5c 4d 18	 subss	 xmm1, DWORD PTR _y0$[ebp]
  000fc	f3 0f 5e c1	 divss	 xmm0, xmm1
  00100	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _x0$[ebp]
  00105	f3 0f 11 45 14	 movss	 DWORD PTR _x0$[ebp], xmm0

; 2945 :       y0 = e->sy;

  0010a	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  0010d	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00112	f3 0f 11 45 18	 movss	 DWORD PTR _y0$[ebp], xmm0
$LN5@stbtt__han:

; 2946 :    }
; 2947 :    if (y1 > e->ey) {

  00117	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  0011a	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _y1$[ebp]
  0011f	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00123	76 40		 jbe	 SHORT $LN6@stbtt__han

; 2948 :       x1 += (x1-x0) * (e->ey - y1) / (y1-y0);

  00125	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _x1$[ebp]
  0012a	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _x0$[ebp]
  0012f	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  00132	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [eax+24]
  00137	f3 0f 5c 4d 20	 subss	 xmm1, DWORD PTR _y1$[ebp]
  0013c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00140	f3 0f 10 4d 20	 movss	 xmm1, DWORD PTR _y1$[ebp]
  00145	f3 0f 5c 4d 18	 subss	 xmm1, DWORD PTR _y0$[ebp]
  0014a	f3 0f 5e c1	 divss	 xmm0, xmm1
  0014e	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _x1$[ebp]
  00153	f3 0f 11 45 1c	 movss	 DWORD PTR _x1$[ebp], xmm0

; 2949 :       y1 = e->ey;

  00158	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  0015b	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00160	f3 0f 11 45 20	 movss	 DWORD PTR _y1$[ebp], xmm0
$LN6@stbtt__han:

; 2950 :    }
; 2951 : 
; 2952 :    if (x0 == x)

  00165	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  0016a	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _x0$[ebp]
  0016f	0f 2e c8	 ucomiss xmm1, xmm0
  00172	9f		 lahf
  00173	f6 c4 44	 test	 ah, 68			; 00000044H
  00176	7a 3b		 jp	 SHORT $LN7@stbtt__han

; 2953 :       STBTT_assert(x1 <= x+1);

  00178	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0017b	83 c0 01	 add	 eax, 1
  0017e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00182	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _x1$[ebp]
  00186	73 26		 jae	 SHORT $LN22@stbtt__han
  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  0018e	83 c1 10	 add	 ecx, 16			; 00000010H
  00191	8b f4		 mov	 esi, esp
  00193	51		 push	 ecx
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@DHAKMBPL@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a7	3b f4		 cmp	 esi, esp
  001a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN22@stbtt__han:
  001ae	e9 26 01 00 00	 jmp	 $LN27@stbtt__han
$LN7@stbtt__han:

; 2954 :    else if (x0 == x+1)

  001b3	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  001b6	83 c0 01	 add	 eax, 1
  001b9	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001bd	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _x0$[ebp]
  001c2	0f 2e c8	 ucomiss xmm1, xmm0
  001c5	9f		 lahf
  001c6	f6 c4 44	 test	 ah, 68			; 00000044H
  001c9	7a 39		 jp	 SHORT $LN9@stbtt__han

; 2955 :       STBTT_assert(x1 >= x);

  001cb	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  001d0	f3 0f 10 4d 1c	 movss	 xmm1, DWORD PTR _x1$[ebp]
  001d5	0f 2f c8	 comiss	 xmm1, xmm0
  001d8	73 25		 jae	 SHORT $LN23@stbtt__han
  001da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  001df	83 c0 12	 add	 eax, 18			; 00000012H
  001e2	8b f4		 mov	 esi, esp
  001e4	50		 push	 eax
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f8	3b f4		 cmp	 esi, esp
  001fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN23@stbtt__han:
  001ff	e9 d5 00 00 00	 jmp	 $LN27@stbtt__han
$LN9@stbtt__han:

; 2956 :    else if (x0 <= x)

  00204	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  00209	0f 2f 45 14	 comiss	 xmm0, DWORD PTR _x0$[ebp]
  0020d	72 35		 jb	 SHORT $LN11@stbtt__han

; 2957 :       STBTT_assert(x1 <= x);

  0020f	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  00214	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _x1$[ebp]
  00218	73 25		 jae	 SHORT $LN24@stbtt__han
  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  0021f	83 c0 14	 add	 eax, 20			; 00000014H
  00222	8b f4		 mov	 esi, esp
  00224	50		 push	 eax
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00235	83 c4 0c	 add	 esp, 12			; 0000000cH
  00238	3b f4		 cmp	 esi, esp
  0023a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN24@stbtt__han:
  0023f	e9 95 00 00 00	 jmp	 $LN27@stbtt__han
$LN11@stbtt__han:

; 2958 :    else if (x0 >= x+1)

  00244	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00247	83 c0 01	 add	 eax, 1
  0024a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0024e	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _x0$[ebp]
  00253	0f 2f c8	 comiss	 xmm1, xmm0
  00256	72 3c		 jb	 SHORT $LN13@stbtt__han

; 2959 :       STBTT_assert(x1 >= x+1);

  00258	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0025b	83 c0 01	 add	 eax, 1
  0025e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00262	f3 0f 10 4d 1c	 movss	 xmm1, DWORD PTR _x1$[ebp]
  00267	0f 2f c8	 comiss	 xmm1, xmm0
  0026a	73 26		 jae	 SHORT $LN25@stbtt__han
  0026c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  00272	83 c1 16	 add	 ecx, 22			; 00000016H
  00275	8b f4		 mov	 esi, esp
  00277	51		 push	 ecx
  00278	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@NGGEAFFG@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?$CL?$AA1@
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00288	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028b	3b f4		 cmp	 esi, esp
  0028d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN25@stbtt__han:
  00292	eb 45		 jmp	 SHORT $LN27@stbtt__han
$LN13@stbtt__han:

; 2960 :    else
; 2961 :       STBTT_assert(x1 >= x && x1 <= x+1);

  00294	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  00299	f3 0f 10 4d 1c	 movss	 xmm1, DWORD PTR _x1$[ebp]
  0029e	0f 2f c8	 comiss	 xmm1, xmm0
  002a1	72 10		 jb	 SHORT $LN26@stbtt__han
  002a3	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  002a6	83 c0 01	 add	 eax, 1
  002a9	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002ad	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _x1$[ebp]
  002b1	73 26		 jae	 SHORT $LN27@stbtt__han
$LN26@stbtt__han:
  002b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  002b9	83 c1 18	 add	 ecx, 24			; 00000018H
  002bc	8b f4		 mov	 esi, esp
  002be	51		 push	 ecx
  002bf	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NILBPPPH@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@
  002c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  002cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d2	3b f4		 cmp	 esi, esp
  002d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN27@stbtt__han:

; 2962 : 
; 2963 :    if (x0 <= x && x1 <= x)

  002d9	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  002de	0f 2f 45 14	 comiss	 xmm0, DWORD PTR _x0$[ebp]
  002e2	72 38		 jb	 SHORT $LN15@stbtt__han
  002e4	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  002e9	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _x1$[ebp]
  002ed	72 2d		 jb	 SHORT $LN15@stbtt__han

; 2964 :       scanline[x] += e->direction * (y1-y0);

  002ef	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _y1$[ebp]
  002f4	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _y0$[ebp]
  002f9	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  002fc	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  00301	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00304	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  00307	f3 0f 58 04 8a	 addss	 xmm0, DWORD PTR [edx+ecx*4]
  0030c	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0030f	8b 4d 08	 mov	 ecx, DWORD PTR _scanline$[ebp]
  00312	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0
  00317	e9 f1 00 00 00	 jmp	 $LN18@stbtt__han
$LN15@stbtt__han:

; 2965 :    else if (x0 >= x+1 && x1 >= x+1)

  0031c	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0031f	83 c0 01	 add	 eax, 1
  00322	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00326	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _x0$[ebp]
  0032b	0f 2f c8	 comiss	 xmm1, xmm0
  0032e	72 19		 jb	 SHORT $LN17@stbtt__han
  00330	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00333	83 c0 01	 add	 eax, 1
  00336	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0033a	f3 0f 10 4d 1c	 movss	 xmm1, DWORD PTR _x1$[ebp]
  0033f	0f 2f c8	 comiss	 xmm1, xmm0
  00342	72 05		 jb	 SHORT $LN17@stbtt__han

; 2966 :       ;

  00344	e9 c4 00 00 00	 jmp	 $LN18@stbtt__han
$LN17@stbtt__han:

; 2967 :    else {
; 2968 :       STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);

  00349	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  0034e	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _x0$[ebp]
  00353	0f 2f c8	 comiss	 xmm1, xmm0
  00356	72 2f		 jb	 SHORT $LN28@stbtt__han
  00358	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0035b	83 c0 01	 add	 eax, 1
  0035e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00362	0f 2f 45 14	 comiss	 xmm0, DWORD PTR _x0$[ebp]
  00366	72 1f		 jb	 SHORT $LN28@stbtt__han
  00368	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _x$[ebp]
  0036d	f3 0f 10 4d 1c	 movss	 xmm1, DWORD PTR _x1$[ebp]
  00372	0f 2f c8	 comiss	 xmm1, xmm0
  00375	72 10		 jb	 SHORT $LN28@stbtt__han
  00377	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0037a	83 c1 01	 add	 ecx, 1
  0037d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00381	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _x1$[ebp]
  00385	73 26		 jae	 SHORT $LN29@stbtt__han
$LN28@stbtt__han:
  00387	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z@4JA
  0038d	83 c2 1f	 add	 edx, 31			; 0000001fH
  00390	8b f4		 mov	 esi, esp
  00392	52		 push	 edx
  00393	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00398	68 00 00 00 00	 push	 OFFSET ??_C@_1FK@JPMIPNJF@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@
  0039d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  003a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a6	3b f4		 cmp	 esi, esp
  003a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN29@stbtt__han:

; 2969 :       scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position

  003ad	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _y1$[ebp]
  003b2	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _y0$[ebp]
  003b7	8b 45 10	 mov	 eax, DWORD PTR _e$[ebp]
  003ba	f3 0f 59 40 10	 mulss	 xmm0, DWORD PTR [eax+16]
  003bf	f3 0f 2a 4d 0c	 cvtsi2ss xmm1, DWORD PTR _x$[ebp]
  003c4	f3 0f 10 55 14	 movss	 xmm2, DWORD PTR _x0$[ebp]
  003c9	f3 0f 5c d1	 subss	 xmm2, xmm1
  003cd	f3 0f 2a 4d 0c	 cvtsi2ss xmm1, DWORD PTR _x$[ebp]
  003d2	f3 0f 10 5d 1c	 movss	 xmm3, DWORD PTR _x1$[ebp]
  003d7	f3 0f 5c d9	 subss	 xmm3, xmm1
  003db	f3 0f 58 d3	 addss	 xmm2, xmm3
  003df	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@40000000
  003e7	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  003ef	f3 0f 5c ca	 subss	 xmm1, xmm2
  003f3	f3 0f 59 c1	 mulss	 xmm0, xmm1
  003f7	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  003fa	8b 55 08	 mov	 edx, DWORD PTR _scanline$[ebp]
  003fd	f3 0f 58 04 8a	 addss	 xmm0, DWORD PTR [edx+ecx*4]
  00402	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00405	8b 4d 08	 mov	 ecx, DWORD PTR _scanline$[ebp]
  00408	f3 0f 11 04 81	 movss	 DWORD PTR [ecx+eax*4], xmm0
$LN18@stbtt__han:
$LN1@stbtt__han:

; 2970 :    }
; 2971 : }

  0040d	5f		 pop	 edi
  0040e	5e		 pop	 esi
  0040f	5b		 pop	 ebx
  00410	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00416	3b ec		 cmp	 ebp, esp
  00418	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0041d	8b e5		 mov	 esp, ebp
  0041f	5d		 pop	 ebp
  00420	c3		 ret	 0
?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ENDP ; stbtt__handle_clipped_edge
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z
_TEXT	SEGMENT
tv133 = -220						; size = 4
tv87 = -220						; size = 4
_dxdy$ = -20						; size = 4
_z$ = -8						; size = 4
_hh$ = 8						; size = 4
_e$ = 12						; size = 4
_off_x$ = 16						; size = 4
_start_point$ = 20					; size = 4
_userdata$ = 24						; size = 4
?stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z PROC ; stbtt__new_active, COMDAT

; 2766 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2767 :    stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);

  00028	8b 45 18	 mov	 eax, DWORD PTR _userdata$[ebp]
  0002b	50		 push	 eax
  0002c	6a 1c		 push	 28			; 0000001cH
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _hh$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ?stbtt__hheap_alloc@@YAPAXPAUstbtt__hheap@@IPAX@Z ; stbtt__hheap_alloc
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	89 45 f8	 mov	 DWORD PTR _z$[ebp], eax

; 2768 :    float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _e$[ebp]
  00043	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00048	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _e$[ebp]
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  00052	f3 0f 10 4a 0c	 movss	 xmm1, DWORD PTR [edx+12]
  00057	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  0005c	f3 0f 5e c1	 divss	 xmm0, xmm1
  00060	f3 0f 11 45 ec	 movss	 DWORD PTR _dxdy$[ebp], xmm0

; 2769 :    STBTT_assert(z != NULL);

  00065	83 7d f8 00	 cmp	 DWORD PTR _z$[ebp], 0
  00069	75 25		 jne	 SHORT $LN4@stbtt__new
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z@4JA
  00070	83 c0 03	 add	 eax, 3
  00073	8b f4		 mov	 esi, esp
  00075	50		 push	 eax
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@stbtt__new:

; 2770 :    //STBTT_assert(e->y0 <= start_point);
; 2771 :    if (!z) return z;

  00090	83 7d f8 00	 cmp	 DWORD PTR _z$[ebp], 0
  00094	75 08		 jne	 SHORT $LN2@stbtt__new
  00096	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  00099	e9 ea 00 00 00	 jmp	 $LN1@stbtt__new
$LN2@stbtt__new:

; 2772 :    z->fdx = dxdy;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  000a1	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _dxdy$[ebp]
  000a6	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 2773 :    z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;

  000ab	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _dxdy$[ebp]
  000b0	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000b7	9f		 lahf
  000b8	f6 c4 44	 test	 ah, 68			; 00000044H
  000bb	7b 17		 jnp	 SHORT $LN5@stbtt__new
  000bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c5	f3 0f 5e 45 ec	 divss	 xmm0, DWORD PTR _dxdy$[ebp]
  000ca	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv87[ebp], xmm0
  000d2	eb 0b		 jmp	 SHORT $LN6@stbtt__new
$LN5@stbtt__new:
  000d4	0f 57 c0	 xorps	 xmm0, xmm0
  000d7	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv87[ebp], xmm0
$LN6@stbtt__new:
  000df	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  000e2	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv87[ebp]
  000ea	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 2774 :    z->fx = e->x0 + dxdy * (start_point - e->y0);

  000ef	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  000f2	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _start_point$[ebp]
  000f7	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  000fc	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _dxdy$[ebp]
  00101	8b 4d 0c	 mov	 ecx, DWORD PTR _e$[ebp]
  00104	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00108	8b 55 f8	 mov	 edx, DWORD PTR _z$[ebp]
  0010b	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 2775 :    z->fx -= off_x;

  00110	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _off_x$[ebp]
  00115	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  00118	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0011d	f3 0f 5c c8	 subss	 xmm1, xmm0
  00121	8b 4d f8	 mov	 ecx, DWORD PTR _z$[ebp]
  00124	f3 0f 11 49 04	 movss	 DWORD PTR [ecx+4], xmm1

; 2776 :    z->direction = e->invert ? 1.0f : -1.0f;

  00129	8b 45 0c	 mov	 eax, DWORD PTR _e$[ebp]
  0012c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00130	74 12		 je	 SHORT $LN7@stbtt__new
  00132	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0013a	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv133[ebp], xmm0
  00142	eb 10		 jmp	 SHORT $LN8@stbtt__new
$LN7@stbtt__new:
  00144	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0014c	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv133[ebp], xmm0
$LN8@stbtt__new:
  00154	8b 4d f8	 mov	 ecx, DWORD PTR _z$[ebp]
  00157	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv133[ebp]
  0015f	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0

; 2777 :    z->sy = e->y0;

  00164	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  00167	8b 4d 0c	 mov	 ecx, DWORD PTR _e$[ebp]
  0016a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0016d	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2778 :    z->ey = e->y1;

  00170	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  00173	8b 4d 0c	 mov	 ecx, DWORD PTR _e$[ebp]
  00176	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00179	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 2779 :    z->next = 0;

  0017c	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
  0017f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2780 :    return z;

  00185	8b 45 f8	 mov	 eax, DWORD PTR _z$[ebp]
$LN1@stbtt__new:

; 2781 : }

  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	5b		 pop	 ebx
  0018b	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00191	3b ec		 cmp	 ebp, esp
  00193	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
?stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z ENDP ; stbtt__new_active
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__hheap_cleanup@@YAXPAUstbtt__hheap@@PAX@Z
_TEXT	SEGMENT
_n$1 = -20						; size = 4
_c$ = -8						; size = 4
_hh$ = 8						; size = 4
_userdata$ = 12						; size = 4
?stbtt__hheap_cleanup@@YAXPAUstbtt__hheap@@PAX@Z PROC	; stbtt__hheap_cleanup, COMDAT

; 2706 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2707 :    stbtt__hheap_chunk *c = hh->head;

  00028	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	89 4d f8	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@stbtt__hhe:

; 2708 :    while (c) {

  00030	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  00034	74 1c		 je	 SHORT $LN1@stbtt__hhe

; 2709 :       stbtt__hheap_chunk *n = c->next;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d ec	 mov	 DWORD PTR _n$1[ebp], ecx

; 2710 :       STBTT_free(c, userdata);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00047	83 c4 04	 add	 esp, 4

; 2711 :       c = n;

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 2712 :    }

  00050	eb de		 jmp	 SHORT $LN2@stbtt__hhe
$LN1@stbtt__hhe:

; 2713 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?stbtt__hheap_cleanup@@YAXPAUstbtt__hheap@@PAX@Z ENDP	; stbtt__hheap_cleanup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__hheap_free@@YAXPAUstbtt__hheap@@PAX@Z
_TEXT	SEGMENT
_hh$ = 8						; size = 4
_p$ = 12						; size = 4
?stbtt__hheap_free@@YAXPAUstbtt__hheap@@PAX@Z PROC	; stbtt__hheap_free, COMDAT

; 2700 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2701 :    *(void **) p = hh->first_free;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _hh$[ebp]
  0002e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00031	89 10		 mov	 DWORD PTR [eax], edx

; 2702 :    hh->first_free = p;

  00033	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp]
  00039	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2703 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?stbtt__hheap_free@@YAXPAUstbtt__hheap@@PAX@Z ENDP	; stbtt__hheap_free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__hheap_alloc@@YAPAXPAUstbtt__hheap@@IPAX@Z
_TEXT	SEGMENT
tv72 = -236						; size = 4
tv73 = -232						; size = 4
_c$1 = -32						; size = 4
_count$2 = -20						; size = 4
_p$3 = -8						; size = 4
_hh$ = 8						; size = 4
_size$ = 12						; size = 4
_userdata$ = 16						; size = 4
?stbtt__hheap_alloc@@YAPAXPAUstbtt__hheap@@IPAX@Z PROC	; stbtt__hheap_alloc, COMDAT

; 2679 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00012	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2680 :    if (hh->first_free) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  0002b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002f	74 21		 je	 SHORT $LN2@stbtt__hhe

; 2681 :       void *p = hh->first_free;

  00031	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  00034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00037	89 4d f8	 mov	 DWORD PTR _p$3[ebp], ecx

; 2682 :       hh->first_free = * (void **) p;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _p$3[ebp]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2683 :       return p;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _p$3[ebp]
  00048	e9 b5 00 00 00	 jmp	 $LN1@stbtt__hhe

; 2684 :    } else {

  0004d	e9 b0 00 00 00	 jmp	 $LN1@stbtt__hhe
$LN2@stbtt__hhe:

; 2685 :       if (hh->num_remaining_in_head_chunk == 0) {

  00052	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  00055	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00059	0f 85 81 00 00
	00		 jne	 $LN4@stbtt__hhe

; 2686 :          int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);

  0005f	83 7d 0c 20	 cmp	 DWORD PTR _size$[ebp], 32 ; 00000020H
  00063	73 0c		 jae	 SHORT $LN9@stbtt__hhe
  00065	c7 85 18 ff ff
	ff d0 07 00 00	 mov	 DWORD PTR tv73[ebp], 2000 ; 000007d0H
  0006f	eb 2b		 jmp	 SHORT $LN10@stbtt__hhe
$LN9@stbtt__hhe:
  00071	81 7d 0c 80 00
	00 00		 cmp	 DWORD PTR _size$[ebp], 128 ; 00000080H
  00078	73 0c		 jae	 SHORT $LN7@stbtt__hhe
  0007a	c7 85 14 ff ff
	ff 20 03 00 00	 mov	 DWORD PTR tv72[ebp], 800 ; 00000320H
  00084	eb 0a		 jmp	 SHORT $LN8@stbtt__hhe
$LN7@stbtt__hhe:
  00086	c7 85 14 ff ff
	ff 64 00 00 00	 mov	 DWORD PTR tv72[ebp], 100 ; 00000064H
$LN8@stbtt__hhe:
  00090	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00096	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
$LN10@stbtt__hhe:
  0009c	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR _count$2[ebp], ecx

; 2687 :          stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);

  000a5	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  000a8	0f af 45 ec	 imul	 eax, DWORD PTR _count$2[ebp]
  000ac	83 c0 04	 add	 eax, 4
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  000b5	83 c4 04	 add	 esp, 4
  000b8	89 45 e0	 mov	 DWORD PTR _c$1[ebp], eax

; 2688 :          if (c == NULL)

  000bb	83 7d e0 00	 cmp	 DWORD PTR _c$1[ebp], 0
  000bf	75 04		 jne	 SHORT $LN5@stbtt__hhe

; 2689 :             return NULL;

  000c1	33 c0		 xor	 eax, eax
  000c3	eb 3d		 jmp	 SHORT $LN1@stbtt__hhe
$LN5@stbtt__hhe:

; 2690 :          c->next = hh->head;

  000c5	8b 45 e0	 mov	 eax, DWORD PTR _c$1[ebp]
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _hh$[ebp]
  000cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cd	89 10		 mov	 DWORD PTR [eax], edx

; 2691 :          hh->head = c;

  000cf	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  000d2	8b 4d e0	 mov	 ecx, DWORD PTR _c$1[ebp]
  000d5	89 08		 mov	 DWORD PTR [eax], ecx

; 2692 :          hh->num_remaining_in_head_chunk = count;

  000d7	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  000da	8b 4d ec	 mov	 ecx, DWORD PTR _count$2[ebp]
  000dd	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@stbtt__hhe:

; 2693 :       }
; 2694 :       --hh->num_remaining_in_head_chunk;

  000e0	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  000e3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e6	83 e9 01	 sub	 ecx, 1
  000e9	8b 55 08	 mov	 edx, DWORD PTR _hh$[ebp]
  000ec	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 2695 :       return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

  000ef	8b 45 08	 mov	 eax, DWORD PTR _hh$[ebp]
  000f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f4	8b 55 08	 mov	 edx, DWORD PTR _hh$[ebp]
  000f7	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  000fa	0f af 42 08	 imul	 eax, DWORD PTR [edx+8]
  000fe	8d 44 01 04	 lea	 eax, DWORD PTR [ecx+eax+4]
$LN1@stbtt__hhe:

; 2696 :    }
; 2697 : }

  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx
  00105	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  0010b	3b ec		 cmp	 ebp, esp
  0010d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
?stbtt__hheap_alloc@@YAPAXPAUstbtt__hheap@@IPAX@Z ENDP	; stbtt__hheap_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z
_TEXT	SEGMENT
_output_ctx$ = -112					; size = 48
_count_ctx$ = -56					; size = 48
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_pvertices$ = 16					; size = 4
?stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeT2, COMDAT

; 2238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-308]
  00012	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2239 :    // runs the charstring twice, once to count and once to output (to avoid realloc)
; 2240 :    stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);

  00032	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp], 1
  00039	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp+4], 0
  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 45 d0	 movss	 DWORD PTR _count_ctx$[ebp+8], xmm0
  00048	0f 57 c0	 xorps	 xmm0, xmm0
  0004b	f3 0f 11 45 d4	 movss	 DWORD PTR _count_ctx$[ebp+12], xmm0
  00050	0f 57 c0	 xorps	 xmm0, xmm0
  00053	f3 0f 11 45 d8	 movss	 DWORD PTR _count_ctx$[ebp+16], xmm0
  00058	0f 57 c0	 xorps	 xmm0, xmm0
  0005b	f3 0f 11 45 dc	 movss	 DWORD PTR _count_ctx$[ebp+20], xmm0
  00060	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp+24], 0
  00067	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp+28], 0
  0006e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp+32], 0
  00075	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp+36], 0
  0007c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp+40], 0
  00083	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count_ctx$[ebp+44], 0

; 2241 :    stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);

  0008a	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp], 0
  00091	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp+4], 0
  00098	0f 57 c0	 xorps	 xmm0, xmm0
  0009b	f3 0f 11 45 98	 movss	 DWORD PTR _output_ctx$[ebp+8], xmm0
  000a0	0f 57 c0	 xorps	 xmm0, xmm0
  000a3	f3 0f 11 45 9c	 movss	 DWORD PTR _output_ctx$[ebp+12], xmm0
  000a8	0f 57 c0	 xorps	 xmm0, xmm0
  000ab	f3 0f 11 45 a0	 movss	 DWORD PTR _output_ctx$[ebp+16], xmm0
  000b0	0f 57 c0	 xorps	 xmm0, xmm0
  000b3	f3 0f 11 45 a4	 movss	 DWORD PTR _output_ctx$[ebp+20], xmm0
  000b8	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp+24], 0
  000bf	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp+28], 0
  000c6	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp+32], 0
  000cd	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp+36], 0
  000d4	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp+40], 0
  000db	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _output_ctx$[ebp+44], 0

; 2242 :    if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

  000e2	8d 45 c8	 lea	 eax, DWORD PTR _count_ctx$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph_index$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ; stbtt__run_charstring
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	85 c0		 test	 eax, eax
  000f8	74 65		 je	 SHORT $LN3@stbtt__Get

; 2243 :       *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);

  000fa	6b 45 f4 0e	 imul	 eax, DWORD PTR _count_ctx$[ebp+44], 14
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00104	83 c4 04	 add	 esp, 4
  00107	8b 4d 10	 mov	 ecx, DWORD PTR _pvertices$[ebp]
  0010a	89 01		 mov	 DWORD PTR [ecx], eax

; 2244 :       output_ctx.pvertices = *pvertices;

  0010c	8b 45 10	 mov	 eax, DWORD PTR _pvertices$[ebp]
  0010f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00111	89 4d b8	 mov	 DWORD PTR _output_ctx$[ebp+40], ecx

; 2245 :       if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

  00114	8d 45 90	 lea	 eax, DWORD PTR _output_ctx$[ebp]
  00117	50		 push	 eax
  00118	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph_index$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ; stbtt__run_charstring
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
  00128	85 c0		 test	 eax, eax
  0012a	74 33		 je	 SHORT $LN3@stbtt__Get

; 2246 :          STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);

  0012c	8b 45 bc	 mov	 eax, DWORD PTR _output_ctx$[ebp+44]
  0012f	3b 45 f4	 cmp	 eax, DWORD PTR _count_ctx$[ebp+44]
  00132	74 26		 je	 SHORT $LN5@stbtt__Get
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA
  0013a	83 c1 08	 add	 ecx, 8
  0013d	8b f4		 mov	 esi, esp
  0013f	51		 push	 ecx
  00140	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH
  00153	3b f4		 cmp	 esi, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@stbtt__Get:

; 2247 :          return output_ctx.num_vertices;

  0015a	8b 45 bc	 mov	 eax, DWORD PTR _output_ctx$[ebp+44]
  0015d	eb 0b		 jmp	 SHORT $LN1@stbtt__Get
$LN3@stbtt__Get:

; 2248 :       }
; 2249 :    }
; 2250 :    *pvertices = NULL;

  0015f	8b 45 10	 mov	 eax, DWORD PTR _pvertices$[ebp]
  00162	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2251 :    return 0;

  00168	33 c0		 xor	 eax, eax
$LN1@stbtt__Get:

; 2252 : }

  0016a	52		 push	 edx
  0016b	8b cd		 mov	 ecx, ebp
  0016d	50		 push	 eax
  0016e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@stbtt__Get
  00174	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00179	58		 pop	 eax
  0017a	5a		 pop	 edx
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00181	33 cd		 xor	 ecx, ebp
  00183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00188	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  0018e	3b ec		 cmp	 ebp, esp
  00190	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
  00199	0f 1f 00	 npad	 3
$LN9@stbtt__Get:
  0019c	02 00 00 00	 DD	 2
  001a0	00 00 00 00	 DD	 $LN8@stbtt__Get
$LN8@stbtt__Get:
  001a4	c8 ff ff ff	 DD	 -56			; ffffffc8H
  001a8	30 00 00 00	 DD	 48			; 00000030H
  001ac	00 00 00 00	 DD	 $LN6@stbtt__Get
  001b0	90 ff ff ff	 DD	 -112			; ffffff90H
  001b4	30 00 00 00	 DD	 48			; 00000030H
  001b8	00 00 00 00	 DD	 $LN7@stbtt__Get
$LN7@stbtt__Get:
  001bc	6f		 DB	 111			; 0000006fH
  001bd	75		 DB	 117			; 00000075H
  001be	74		 DB	 116			; 00000074H
  001bf	70		 DB	 112			; 00000070H
  001c0	75		 DB	 117			; 00000075H
  001c1	74		 DB	 116			; 00000074H
  001c2	5f		 DB	 95			; 0000005fH
  001c3	63		 DB	 99			; 00000063H
  001c4	74		 DB	 116			; 00000074H
  001c5	78		 DB	 120			; 00000078H
  001c6	00		 DB	 0
$LN6@stbtt__Get:
  001c7	63		 DB	 99			; 00000063H
  001c8	6f		 DB	 111			; 0000006fH
  001c9	75		 DB	 117			; 00000075H
  001ca	6e		 DB	 110			; 0000006eH
  001cb	74		 DB	 116			; 00000074H
  001cc	5f		 DB	 95			; 0000005fH
  001cd	63		 DB	 99			; 00000063H
  001ce	74		 DB	 116			; 00000074H
  001cf	78		 DB	 120			; 00000078H
  001d0	00		 DB	 0
?stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeT2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z
_TEXT	SEGMENT
tv1212 = -1188						; size = 4
tv1255 = -1184						; size = 4
tv1206 = -1180						; size = 4
tv414 = -1180						; size = 4
tv400 = -1180						; size = 4
tv210 = -1180						; size = 4
tv179 = -1180						; size = 4
tv76 = -1180						; size = 4
$T1 = -1172						; size = 12
$T2 = -1152						; size = 12
$T3 = -1132						; size = 12
$T4 = -1112						; size = 12
$T5 = -1092						; size = 12
$T6 = -1072						; size = 12
_b1$7 = -668						; size = 4
_dy$8 = -656						; size = 4
_dx$9 = -644						; size = 4
_dy6$10 = -632						; size = 4
_dy5$11 = -620						; size = 4
_dy4$12 = -608						; size = 4
_dy3$13 = -596						; size = 4
_dy2$14 = -584						; size = 4
_dy1$15 = -572						; size = 4
_dx6$16 = -560						; size = 4
_dx5$17 = -548						; size = 4
_dx4$18 = -536						; size = 4
_dx3$19 = -524						; size = 4
_dx2$20 = -512						; size = 4
_dx1$21 = -500						; size = 4
_f$ = -488						; size = 4
_b$ = -476						; size = 12
_subrs$ = -456						; size = 12
_subr_stack$ = -436					; size = 120
_s$ = -308						; size = 192
_clear_stack$ = -108					; size = 4
_has_subrs$ = -96					; size = 4
_b0$ = -84						; size = 4
_i$ = -72						; size = 4
_v$ = -60						; size = 4
_sp$ = -48						; size = 4
_subr_stack_height$ = -36				; size = 4
_maskbits$ = -24					; size = 4
_in_header$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_c$ = 16						; size = 4
?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z PROC ; stbtt__run_charstring, COMDAT

; 1979 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 04 00
	00		 sub	 esp, 1188		; 000004a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 5c fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1188]
  00012	b9 29 01 00 00	 mov	 ecx, 297		; 00000129H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1980 :    int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;

  00032	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _in_header$[ebp], 1
  00039	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _maskbits$[ebp], 0
  00040	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _subr_stack_height$[ebp], 0
  00047	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _sp$[ebp], 0

; 1981 :    int has_subrs = 0, clear_stack;

  0004e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _has_subrs$[ebp], 0

; 1982 :    float s[48];
; 1983 :    stbtt__buf subr_stack[10], subrs = info->subrs, b;

  00055	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00058	83 c0 58	 add	 eax, 88			; 00000058H
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	89 8d 38 fe ff
	ff		 mov	 DWORD PTR _subrs$[ebp], ecx
  00063	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00066	89 95 3c fe ff
	ff		 mov	 DWORD PTR _subrs$[ebp+4], edx
  0006c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006f	89 85 40 fe ff
	ff		 mov	 DWORD PTR _subrs$[ebp+8], eax

; 1984 :    float f;
; 1985 : 
; 1986 : #define STBTT__CSERR(s) (0)
; 1987 : 
; 1988 :    // this currently ignores the initial width value, which isn't needed if we have hmtx
; 1989 :    b = stbtt__cff_index_get(info->charstrings, glyph_index);

  00075	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  00078	50		 push	 eax
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  0007c	83 c1 40	 add	 ecx, 64			; 00000040H
  0007f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00082	8b d4		 mov	 edx, esp
  00084	8b 01		 mov	 eax, DWORD PTR [ecx]
  00086	89 02		 mov	 DWORD PTR [edx], eax
  00088	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008b	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0008e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00091	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00094	8d 95 bc fb ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  000a0	83 c4 14	 add	 esp, 20			; 00000014H
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	89 8d d0 fb ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	89 95 d4 fb ff
	ff		 mov	 DWORD PTR $T6[ebp+4], edx
  000b4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b7	89 85 d8 fb ff
	ff		 mov	 DWORD PTR $T6[ebp+8], eax
  000bd	8b 8d d0 fb ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  000c3	89 8d 24 fe ff
	ff		 mov	 DWORD PTR _b$[ebp], ecx
  000c9	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR $T6[ebp+4]
  000cf	89 95 28 fe ff
	ff		 mov	 DWORD PTR _b$[ebp+4], edx
  000d5	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+8]
  000db	89 85 2c fe ff
	ff		 mov	 DWORD PTR _b$[ebp+8], eax
$LN2@stbtt__run:

; 1990 :    while (b.cursor < b.size) {

  000e1	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR _b$[ebp+4]
  000e7	3b 85 2c fe ff
	ff		 cmp	 eax, DWORD PTR _b$[ebp+8]
  000ed	0f 8d bc 12 00
	00		 jge	 $LN3@stbtt__run

; 1991 :       i = 0;

  000f3	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 1992 :       clear_stack = 1;

  000fa	c7 45 94 01 00
	00 00		 mov	 DWORD PTR _clear_stack$[ebp], 1

; 1993 :       b0 = stbtt__buf_get8(&b);

  00101	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _b$[ebp]
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  0010d	83 c4 04	 add	 esp, 4
  00110	0f b6 c8	 movzx	 ecx, al
  00113	89 4d ac	 mov	 DWORD PTR _b0$[ebp], ecx

; 1994 :       switch (b0) {

  00116	8b 45 ac	 mov	 eax, DWORD PTR _b0$[ebp]
  00119	89 85 64 fb ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  0011f	8b 8d 64 fb ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  00125	83 e9 01	 sub	 ecx, 1
  00128	89 8d 64 fb ff
	ff		 mov	 DWORD PTR tv76[ebp], ecx
  0012e	83 bd 64 fb ff
	ff 1e		 cmp	 DWORD PTR tv76[ebp], 30	; 0000001eH
  00135	0f 87 b0 11 00
	00		 ja	 $LN89@stbtt__run
  0013b	8b 95 64 fb ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  00141	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN103@stbtt__run[edx]
  00148	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN104@stbtt__run[eax*4]
$LN29@stbtt__run:

; 1995 :       // @TODO implement hinting
; 1996 :       case 0x13: // hintmask
; 1997 :       case 0x14: // cntrmask
; 1998 :          if (in_header)

  0014f	83 7d f4 00	 cmp	 DWORD PTR _in_header$[ebp], 0
  00153	74 0e		 je	 SHORT $LN30@stbtt__run

; 1999 :             maskbits += (sp / 2); // implicit "vstem"

  00155	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  00158	99		 cdq
  00159	2b c2		 sub	 eax, edx
  0015b	d1 f8		 sar	 eax, 1
  0015d	03 45 e8	 add	 eax, DWORD PTR _maskbits$[ebp]
  00160	89 45 e8	 mov	 DWORD PTR _maskbits$[ebp], eax
$LN30@stbtt__run:

; 2000 :          in_header = 0;

  00163	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _in_header$[ebp], 0

; 2001 :          stbtt__buf_skip(&b, (maskbits + 7) / 8);

  0016a	8b 45 e8	 mov	 eax, DWORD PTR _maskbits$[ebp]
  0016d	83 c0 07	 add	 eax, 7
  00170	99		 cdq
  00171	83 e2 07	 and	 edx, 7
  00174	03 c2		 add	 eax, edx
  00176	c1 f8 03	 sar	 eax, 3
  00179	50		 push	 eax
  0017a	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _b$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  00186	83 c4 08	 add	 esp, 8

; 2002 :          break;

  00189	e9 0f 12 00 00	 jmp	 $LN4@stbtt__run
$LN31@stbtt__run:

; 2003 : 
; 2004 :       case 0x01: // hstem
; 2005 :       case 0x03: // vstem
; 2006 :       case 0x12: // hstemhm
; 2007 :       case 0x17: // vstemhm
; 2008 :          maskbits += (sp / 2);

  0018e	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  00191	99		 cdq
  00192	2b c2		 sub	 eax, edx
  00194	d1 f8		 sar	 eax, 1
  00196	03 45 e8	 add	 eax, DWORD PTR _maskbits$[ebp]
  00199	89 45 e8	 mov	 DWORD PTR _maskbits$[ebp], eax

; 2009 :          break;

  0019c	e9 fc 11 00 00	 jmp	 $LN4@stbtt__run
$LN32@stbtt__run:

; 2010 : 
; 2011 :       case 0x15: // rmoveto
; 2012 :          in_header = 0;

  001a1	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _in_header$[ebp], 0

; 2013 :          if (sp < 2) return STBTT__CSERR("rmoveto stack");

  001a8	83 7d d0 02	 cmp	 DWORD PTR _sp$[ebp], 2
  001ac	7d 07		 jge	 SHORT $LN33@stbtt__run
  001ae	33 c0		 xor	 eax, eax
  001b0	e9 fc 11 00 00	 jmp	 $LN1@stbtt__run
$LN33@stbtt__run:

; 2014 :          stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);

  001b5	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  001b8	51		 push	 ecx
  001b9	f3 0f 10 84 85
	c8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4-4]
  001c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c7	8b 4d d0	 mov	 ecx, DWORD PTR _sp$[ebp]
  001ca	51		 push	 ecx
  001cb	f3 0f 10 84 8d
	c4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4-8]
  001d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d9	8b 55 10	 mov	 edx, DWORD PTR _c$[ebp]
  001dc	52		 push	 edx
  001dd	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
  001e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2015 :          break;

  001e5	e9 b3 11 00 00	 jmp	 $LN4@stbtt__run
$LN34@stbtt__run:

; 2016 :       case 0x04: // vmoveto
; 2017 :          in_header = 0;

  001ea	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _in_header$[ebp], 0

; 2018 :          if (sp < 1) return STBTT__CSERR("vmoveto stack");

  001f1	83 7d d0 01	 cmp	 DWORD PTR _sp$[ebp], 1
  001f5	7d 07		 jge	 SHORT $LN35@stbtt__run
  001f7	33 c0		 xor	 eax, eax
  001f9	e9 b3 11 00 00	 jmp	 $LN1@stbtt__run
$LN35@stbtt__run:

; 2019 :          stbtt__csctx_rmove_to(c, 0, s[sp-1]);

  001fe	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  00201	51		 push	 ecx
  00202	f3 0f 10 84 85
	c8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4-4]
  0020b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00210	51		 push	 ecx
  00211	0f 57 c0	 xorps	 xmm0, xmm0
  00214	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00219	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  0021c	51		 push	 ecx
  0021d	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
  00222	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2020 :          break;

  00225	e9 73 11 00 00	 jmp	 $LN4@stbtt__run
$LN36@stbtt__run:

; 2021 :       case 0x16: // hmoveto
; 2022 :          in_header = 0;

  0022a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _in_header$[ebp], 0

; 2023 :          if (sp < 1) return STBTT__CSERR("hmoveto stack");

  00231	83 7d d0 01	 cmp	 DWORD PTR _sp$[ebp], 1
  00235	7d 07		 jge	 SHORT $LN37@stbtt__run
  00237	33 c0		 xor	 eax, eax
  00239	e9 73 11 00 00	 jmp	 $LN1@stbtt__run
$LN37@stbtt__run:

; 2024 :          stbtt__csctx_rmove_to(c, s[sp-1], 0);

  0023e	51		 push	 ecx
  0023f	0f 57 c0	 xorps	 xmm0, xmm0
  00242	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00247	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  0024a	51		 push	 ecx
  0024b	f3 0f 10 84 85
	c8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4-4]
  00254	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00259	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  0025c	51		 push	 ecx
  0025d	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2025 :          break;

  00265	e9 33 11 00 00	 jmp	 $LN4@stbtt__run
$LN38@stbtt__run:

; 2026 : 
; 2027 :       case 0x05: // rlineto
; 2028 :          if (sp < 2) return STBTT__CSERR("rlineto stack");

  0026a	83 7d d0 02	 cmp	 DWORD PTR _sp$[ebp], 2
  0026e	7d 07		 jge	 SHORT $LN39@stbtt__run
  00270	33 c0		 xor	 eax, eax
  00272	e9 3a 11 00 00	 jmp	 $LN1@stbtt__run
$LN39@stbtt__run:

; 2029 :          for (; i + 1 < sp; i += 2)

  00277	eb 09		 jmp	 SHORT $LN8@stbtt__run
$LN6@stbtt__run:
  00279	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0027c	83 c0 02	 add	 eax, 2
  0027f	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN8@stbtt__run:
  00282	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00285	83 c0 01	 add	 eax, 1
  00288	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  0028b	7d 32		 jge	 SHORT $LN7@stbtt__run

; 2030 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

  0028d	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00290	51		 push	 ecx
  00291	f3 0f 10 84 85
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+4]
  0029a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029f	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  002a2	51		 push	 ecx
  002a3	f3 0f 10 84 8d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4]
  002ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b1	8b 55 10	 mov	 edx, DWORD PTR _c$[ebp]
  002b4	52		 push	 edx
  002b5	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  002ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  002bd	eb ba		 jmp	 SHORT $LN6@stbtt__run
$LN7@stbtt__run:

; 2031 :          break;

  002bf	e9 d9 10 00 00	 jmp	 $LN4@stbtt__run
$LN40@stbtt__run:

; 2032 : 
; 2033 :       // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
; 2034 :       // starting from a different place.
; 2035 : 
; 2036 :       case 0x07: // vlineto
; 2037 :          if (sp < 1) return STBTT__CSERR("vlineto stack");

  002c4	83 7d d0 01	 cmp	 DWORD PTR _sp$[ebp], 1
  002c8	7d 07		 jge	 SHORT $LN41@stbtt__run
  002ca	33 c0		 xor	 eax, eax
  002cc	e9 e0 10 00 00	 jmp	 $LN1@stbtt__run
$LN41@stbtt__run:

; 2038 :          goto vlineto;

  002d1	eb 49		 jmp	 SHORT $LN42@stbtt__run
  002d3	eb 47		 jmp	 SHORT $vlineto$112
$LN43@stbtt__run:

; 2039 :       case 0x06: // hlineto
; 2040 :          if (sp < 1) return STBTT__CSERR("hlineto stack");

  002d5	83 7d d0 01	 cmp	 DWORD PTR _sp$[ebp], 1
  002d9	7d 07		 jge	 SHORT $LN44@stbtt__run
  002db	33 c0		 xor	 eax, eax
  002dd	e9 cf 10 00 00	 jmp	 $LN1@stbtt__run
$LN44@stbtt__run:
$LN9@stbtt__run:

; 2041 :          for (;;) {
; 2042 :             if (i >= sp) break;

  002e2	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  002e5	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  002e8	7c 02		 jl	 SHORT $LN45@stbtt__run
  002ea	eb 6c		 jmp	 SHORT $LN10@stbtt__run
$LN45@stbtt__run:

; 2043 :             stbtt__csctx_rline_to(c, s[i], 0);

  002ec	51		 push	 ecx
  002ed	0f 57 c0	 xorps	 xmm0, xmm0
  002f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f5	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  002f8	51		 push	 ecx
  002f9	f3 0f 10 84 85
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4]
  00302	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00307	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  0030a	51		 push	 ecx
  0030b	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  00310	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2044 :             i++;

  00313	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00316	83 c0 01	 add	 eax, 1
  00319	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN42@stbtt__run:
$vlineto$112:

; 2045 :       vlineto:
; 2046 :             if (i >= sp) break;

  0031c	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0031f	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  00322	7c 02		 jl	 SHORT $LN46@stbtt__run
  00324	eb 32		 jmp	 SHORT $LN10@stbtt__run
$LN46@stbtt__run:

; 2047 :             stbtt__csctx_rline_to(c, 0, s[i]);

  00326	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00329	51		 push	 ecx
  0032a	f3 0f 10 84 85
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4]
  00333	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00338	51		 push	 ecx
  00339	0f 57 c0	 xorps	 xmm0, xmm0
  0033c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00341	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  00344	51		 push	 ecx
  00345	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  0034a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2048 :             i++;

  0034d	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00350	83 c0 01	 add	 eax, 1
  00353	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax

; 2049 :          }

  00356	eb 8a		 jmp	 SHORT $LN9@stbtt__run
$LN10@stbtt__run:

; 2050 :          break;

  00358	e9 40 10 00 00	 jmp	 $LN4@stbtt__run
$LN47@stbtt__run:

; 2051 : 
; 2052 :       case 0x1F: // hvcurveto
; 2053 :          if (sp < 4) return STBTT__CSERR("hvcurveto stack");

  0035d	83 7d d0 04	 cmp	 DWORD PTR _sp$[ebp], 4
  00361	7d 07		 jge	 SHORT $LN48@stbtt__run
  00363	33 c0		 xor	 eax, eax
  00365	e9 47 10 00 00	 jmp	 $LN1@stbtt__run
$LN48@stbtt__run:

; 2054 :          goto hvcurveto;

  0036a	e9 c2 00 00 00	 jmp	 $LN49@stbtt__run
  0036f	e9 bd 00 00 00	 jmp	 $hvcurveto$113
$LN50@stbtt__run:

; 2055 :       case 0x1E: // vhcurveto
; 2056 :          if (sp < 4) return STBTT__CSERR("vhcurveto stack");

  00374	83 7d d0 04	 cmp	 DWORD PTR _sp$[ebp], 4
  00378	7d 07		 jge	 SHORT $LN51@stbtt__run
  0037a	33 c0		 xor	 eax, eax
  0037c	e9 30 10 00 00	 jmp	 $LN1@stbtt__run
$LN51@stbtt__run:
$LN12@stbtt__run:

; 2057 :          for (;;) {
; 2058 :             if (i + 3 >= sp) break;

  00381	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00384	83 c0 03	 add	 eax, 3
  00387	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  0038a	7c 05		 jl	 SHORT $LN52@stbtt__run
  0038c	e9 55 01 00 00	 jmp	 $LN13@stbtt__run
$LN52@stbtt__run:

; 2059 :             stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);

  00391	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  00394	2b 45 b8	 sub	 eax, DWORD PTR _i$[ebp]
  00397	83 f8 05	 cmp	 eax, 5
  0039a	75 16		 jne	 SHORT $LN97@stbtt__run
  0039c	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  0039f	f3 0f 10 84 8d
	dc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+16]
  003a8	f3 0f 11 85 64
	fb ff ff	 movss	 DWORD PTR tv179[ebp], xmm0
  003b0	eb 0b		 jmp	 SHORT $LN98@stbtt__run
$LN97@stbtt__run:
  003b2	0f 57 c0	 xorps	 xmm0, xmm0
  003b5	f3 0f 11 85 64
	fb ff ff	 movss	 DWORD PTR tv179[ebp], xmm0
$LN98@stbtt__run:
  003bd	51		 push	 ecx
  003be	f3 0f 10 85 64
	fb ff ff	 movss	 xmm0, DWORD PTR tv179[ebp]
  003c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cb	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  003ce	51		 push	 ecx
  003cf	f3 0f 10 84 95
	d8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4+12]
  003d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003dd	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  003e0	51		 push	 ecx
  003e1	f3 0f 10 84 85
	d4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+8]
  003ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ef	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  003f2	51		 push	 ecx
  003f3	f3 0f 10 84 8d
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+4]
  003fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00401	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  00404	51		 push	 ecx
  00405	f3 0f 10 84 95
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4]
  0040e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00413	51		 push	 ecx
  00414	0f 57 c0	 xorps	 xmm0, xmm0
  00417	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0041c	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0041f	50		 push	 eax
  00420	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00425	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2060 :             i += 4;

  00428	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0042b	83 c0 04	 add	 eax, 4
  0042e	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN49@stbtt__run:
$hvcurveto$113:

; 2061 :       hvcurveto:
; 2062 :             if (i + 3 >= sp) break;

  00431	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00434	83 c0 03	 add	 eax, 3
  00437	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  0043a	7c 05		 jl	 SHORT $LN53@stbtt__run
  0043c	e9 a5 00 00 00	 jmp	 $LN13@stbtt__run
$LN53@stbtt__run:

; 2063 :             stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);

  00441	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  00444	2b 45 b8	 sub	 eax, DWORD PTR _i$[ebp]
  00447	83 f8 05	 cmp	 eax, 5
  0044a	75 16		 jne	 SHORT $LN99@stbtt__run
  0044c	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  0044f	f3 0f 10 84 8d
	dc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+16]
  00458	f3 0f 11 85 64
	fb ff ff	 movss	 DWORD PTR tv210[ebp], xmm0
  00460	eb 0b		 jmp	 SHORT $LN100@stbtt__run
$LN99@stbtt__run:
  00462	0f 57 c0	 xorps	 xmm0, xmm0
  00465	f3 0f 11 85 64
	fb ff ff	 movss	 DWORD PTR tv210[ebp], xmm0
$LN100@stbtt__run:
  0046d	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  00470	51		 push	 ecx
  00471	f3 0f 10 84 95
	d8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4+12]
  0047a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0047f	51		 push	 ecx
  00480	f3 0f 10 85 64
	fb ff ff	 movss	 xmm0, DWORD PTR tv210[ebp]
  00488	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0048d	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00490	51		 push	 ecx
  00491	f3 0f 10 84 85
	d4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+8]
  0049a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0049f	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  004a2	51		 push	 ecx
  004a3	f3 0f 10 84 8d
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+4]
  004ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b1	51		 push	 ecx
  004b2	0f 57 c0	 xorps	 xmm0, xmm0
  004b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ba	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  004bd	51		 push	 ecx
  004be	f3 0f 10 84 95
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4]
  004c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004cc	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  004cf	50		 push	 eax
  004d0	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  004d5	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2064 :             i += 4;

  004d8	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  004db	83 c0 04	 add	 eax, 4
  004de	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax

; 2065 :          }

  004e1	e9 9b fe ff ff	 jmp	 $LN12@stbtt__run
$LN13@stbtt__run:

; 2066 :          break;

  004e6	e9 b2 0e 00 00	 jmp	 $LN4@stbtt__run
$LN54@stbtt__run:

; 2067 : 
; 2068 :       case 0x08: // rrcurveto
; 2069 :          if (sp < 6) return STBTT__CSERR("rcurveline stack");

  004eb	83 7d d0 06	 cmp	 DWORD PTR _sp$[ebp], 6
  004ef	7d 07		 jge	 SHORT $LN55@stbtt__run
  004f1	33 c0		 xor	 eax, eax
  004f3	e9 b9 0e 00 00	 jmp	 $LN1@stbtt__run
$LN55@stbtt__run:

; 2070 :          for (; i + 5 < sp; i += 6)

  004f8	eb 09		 jmp	 SHORT $LN17@stbtt__run
$LN15@stbtt__run:
  004fa	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  004fd	83 c0 06	 add	 eax, 6
  00500	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN17@stbtt__run:
  00503	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00506	83 c0 05	 add	 eax, 5
  00509	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  0050c	7d 7d		 jge	 SHORT $LN16@stbtt__run

; 2071 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

  0050e	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00511	51		 push	 ecx
  00512	f3 0f 10 84 85
	e0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+20]
  0051b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00520	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  00523	51		 push	 ecx
  00524	f3 0f 10 84 8d
	dc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+16]
  0052d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00532	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  00535	51		 push	 ecx
  00536	f3 0f 10 84 95
	d8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4+12]
  0053f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00544	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00547	51		 push	 ecx
  00548	f3 0f 10 84 85
	d4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+8]
  00551	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00556	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  00559	51		 push	 ecx
  0055a	f3 0f 10 84 8d
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+4]
  00563	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00568	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  0056b	51		 push	 ecx
  0056c	f3 0f 10 84 95
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4]
  00575	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0057a	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0057d	50		 push	 eax
  0057e	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00583	83 c4 1c	 add	 esp, 28			; 0000001cH
  00586	e9 6f ff ff ff	 jmp	 $LN15@stbtt__run
$LN16@stbtt__run:

; 2072 :          break;

  0058b	e9 0d 0e 00 00	 jmp	 $LN4@stbtt__run
$LN56@stbtt__run:

; 2073 : 
; 2074 :       case 0x18: // rcurveline
; 2075 :          if (sp < 8) return STBTT__CSERR("rcurveline stack");

  00590	83 7d d0 08	 cmp	 DWORD PTR _sp$[ebp], 8
  00594	7d 07		 jge	 SHORT $LN57@stbtt__run
  00596	33 c0		 xor	 eax, eax
  00598	e9 14 0e 00 00	 jmp	 $LN1@stbtt__run
$LN57@stbtt__run:

; 2076 :          for (; i + 5 < sp - 2; i += 6)

  0059d	eb 09		 jmp	 SHORT $LN20@stbtt__run
$LN18@stbtt__run:
  0059f	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  005a2	83 c0 06	 add	 eax, 6
  005a5	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN20@stbtt__run:
  005a8	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  005ab	83 c0 05	 add	 eax, 5
  005ae	8b 4d d0	 mov	 ecx, DWORD PTR _sp$[ebp]
  005b1	83 e9 02	 sub	 ecx, 2
  005b4	3b c1		 cmp	 eax, ecx
  005b6	7d 7d		 jge	 SHORT $LN19@stbtt__run

; 2077 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

  005b8	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  005bb	51		 push	 ecx
  005bc	f3 0f 10 84 85
	e0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+20]
  005c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005ca	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  005cd	51		 push	 ecx
  005ce	f3 0f 10 84 8d
	dc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+16]
  005d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005dc	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  005df	51		 push	 ecx
  005e0	f3 0f 10 84 95
	d8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4+12]
  005e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005ee	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  005f1	51		 push	 ecx
  005f2	f3 0f 10 84 85
	d4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+8]
  005fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00600	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  00603	51		 push	 ecx
  00604	f3 0f 10 84 8d
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+4]
  0060d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00612	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  00615	51		 push	 ecx
  00616	f3 0f 10 84 95
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4]
  0061f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00624	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00627	50		 push	 eax
  00628	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  0062d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00630	e9 6a ff ff ff	 jmp	 $LN18@stbtt__run
$LN19@stbtt__run:

; 2078 :          if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");

  00635	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00638	83 c0 01	 add	 eax, 1
  0063b	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  0063e	7c 07		 jl	 SHORT $LN58@stbtt__run
  00640	33 c0		 xor	 eax, eax
  00642	e9 6a 0d 00 00	 jmp	 $LN1@stbtt__run
$LN58@stbtt__run:

; 2079 :          stbtt__csctx_rline_to(c, s[i], s[i+1]);

  00647	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0064a	51		 push	 ecx
  0064b	f3 0f 10 84 85
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+4]
  00654	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00659	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  0065c	51		 push	 ecx
  0065d	f3 0f 10 84 8d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4]
  00666	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0066b	8b 55 10	 mov	 edx, DWORD PTR _c$[ebp]
  0066e	52		 push	 edx
  0066f	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  00674	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2080 :          break;

  00677	e9 21 0d 00 00	 jmp	 $LN4@stbtt__run
$LN59@stbtt__run:

; 2081 : 
; 2082 :       case 0x19: // rlinecurve
; 2083 :          if (sp < 8) return STBTT__CSERR("rlinecurve stack");

  0067c	83 7d d0 08	 cmp	 DWORD PTR _sp$[ebp], 8
  00680	7d 07		 jge	 SHORT $LN60@stbtt__run
  00682	33 c0		 xor	 eax, eax
  00684	e9 28 0d 00 00	 jmp	 $LN1@stbtt__run
$LN60@stbtt__run:

; 2084 :          for (; i + 1 < sp - 6; i += 2)

  00689	eb 09		 jmp	 SHORT $LN23@stbtt__run
$LN21@stbtt__run:
  0068b	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0068e	83 c0 02	 add	 eax, 2
  00691	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN23@stbtt__run:
  00694	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00697	83 c0 01	 add	 eax, 1
  0069a	8b 4d d0	 mov	 ecx, DWORD PTR _sp$[ebp]
  0069d	83 e9 06	 sub	 ecx, 6
  006a0	3b c1		 cmp	 eax, ecx
  006a2	7d 32		 jge	 SHORT $LN22@stbtt__run

; 2085 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

  006a4	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  006a7	51		 push	 ecx
  006a8	f3 0f 10 84 85
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+4]
  006b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006b6	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  006b9	51		 push	 ecx
  006ba	f3 0f 10 84 8d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4]
  006c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006c8	8b 55 10	 mov	 edx, DWORD PTR _c$[ebp]
  006cb	52		 push	 edx
  006cc	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  006d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  006d4	eb b5		 jmp	 SHORT $LN21@stbtt__run
$LN22@stbtt__run:

; 2086 :          if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");

  006d6	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  006d9	83 c0 05	 add	 eax, 5
  006dc	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  006df	7c 07		 jl	 SHORT $LN61@stbtt__run
  006e1	33 c0		 xor	 eax, eax
  006e3	e9 c9 0c 00 00	 jmp	 $LN1@stbtt__run
$LN61@stbtt__run:

; 2087 :          stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

  006e8	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  006eb	51		 push	 ecx
  006ec	f3 0f 10 84 85
	e0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+20]
  006f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006fa	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  006fd	51		 push	 ecx
  006fe	f3 0f 10 84 8d
	dc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+16]
  00707	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0070c	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  0070f	51		 push	 ecx
  00710	f3 0f 10 84 95
	d8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4+12]
  00719	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0071e	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00721	51		 push	 ecx
  00722	f3 0f 10 84 85
	d4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+8]
  0072b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00730	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  00733	51		 push	 ecx
  00734	f3 0f 10 84 8d
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+4]
  0073d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00742	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  00745	51		 push	 ecx
  00746	f3 0f 10 84 95
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4]
  0074f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00754	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00757	50		 push	 eax
  00758	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  0075d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2088 :          break;

  00760	e9 38 0c 00 00	 jmp	 $LN4@stbtt__run
$LN62@stbtt__run:

; 2089 : 
; 2090 :       case 0x1A: // vvcurveto
; 2091 :       case 0x1B: // hhcurveto
; 2092 :          if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");

  00765	83 7d d0 04	 cmp	 DWORD PTR _sp$[ebp], 4
  00769	7d 07		 jge	 SHORT $LN63@stbtt__run
  0076b	33 c0		 xor	 eax, eax
  0076d	e9 3f 0c 00 00	 jmp	 $LN1@stbtt__run
$LN63@stbtt__run:

; 2093 :          f = 0.0;

  00772	0f 57 c0	 xorps	 xmm0, xmm0
  00775	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0

; 2094 :          if (sp & 1) { f = s[i]; i++; }

  0077d	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  00780	83 e0 01	 and	 eax, 1
  00783	74 1d		 je	 SHORT $LN64@stbtt__run
  00785	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00788	f3 0f 10 84 85
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4]
  00791	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
  00799	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  0079c	83 c0 01	 add	 eax, 1
  0079f	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN64@stbtt__run:

; 2095 :          for (; i + 3 < sp; i += 4) {

  007a2	eb 09		 jmp	 SHORT $LN26@stbtt__run
$LN24@stbtt__run:
  007a4	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  007a7	83 c0 04	 add	 eax, 4
  007aa	89 45 b8	 mov	 DWORD PTR _i$[ebp], eax
$LN26@stbtt__run:
  007ad	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  007b0	83 c0 03	 add	 eax, 3
  007b3	3b 45 d0	 cmp	 eax, DWORD PTR _sp$[ebp]
  007b6	0f 8d ee 00 00
	00		 jge	 $LN25@stbtt__run

; 2096 :             if (b0 == 0x1B)

  007bc	83 7d ac 1b	 cmp	 DWORD PTR _b0$[ebp], 27	; 0000001bH
  007c0	75 6d		 jne	 SHORT $LN65@stbtt__run

; 2097 :                stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);

  007c2	51		 push	 ecx
  007c3	0f 57 c0	 xorps	 xmm0, xmm0
  007c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007cb	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  007ce	51		 push	 ecx
  007cf	f3 0f 10 84 85
	d8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+12]
  007d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007dd	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  007e0	51		 push	 ecx
  007e1	f3 0f 10 84 8d
	d4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+8]
  007ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007ef	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  007f2	51		 push	 ecx
  007f3	f3 0f 10 84 95
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4+4]
  007fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00801	51		 push	 ecx
  00802	f3 0f 10 85 18
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  0080a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0080f	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00812	51		 push	 ecx
  00813	f3 0f 10 84 85
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4]
  0081c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00821	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  00824	51		 push	 ecx
  00825	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  0082a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0082d	eb 6b		 jmp	 SHORT $LN66@stbtt__run
$LN65@stbtt__run:

; 2098 :             else
; 2099 :                stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);

  0082f	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00832	51		 push	 ecx
  00833	f3 0f 10 84 85
	d8 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4+12]
  0083c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00841	51		 push	 ecx
  00842	0f 57 c0	 xorps	 xmm0, xmm0
  00845	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0084a	8b 4d b8	 mov	 ecx, DWORD PTR _i$[ebp]
  0084d	51		 push	 ecx
  0084e	f3 0f 10 84 8d
	d4 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx*4+8]
  00857	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0085c	8b 55 b8	 mov	 edx, DWORD PTR _i$[ebp]
  0085f	51		 push	 ecx
  00860	f3 0f 10 84 95
	d0 fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+edx*4+4]
  00869	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0086e	8b 45 b8	 mov	 eax, DWORD PTR _i$[ebp]
  00871	51		 push	 ecx
  00872	f3 0f 10 84 85
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax*4]
  0087b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00880	51		 push	 ecx
  00881	f3 0f 10 85 18
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00889	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0088e	8b 4d 10	 mov	 ecx, DWORD PTR _c$[ebp]
  00891	51		 push	 ecx
  00892	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00897	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN66@stbtt__run:

; 2100 :             f = 0.0;

  0089a	0f 57 c0	 xorps	 xmm0, xmm0
  0089d	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0

; 2101 :          }

  008a5	e9 fa fe ff ff	 jmp	 $LN24@stbtt__run
$LN25@stbtt__run:

; 2102 :          break;

  008aa	e9 ee 0a 00 00	 jmp	 $LN4@stbtt__run
$LN67@stbtt__run:

; 2103 : 
; 2104 :       case 0x0A: // callsubr
; 2105 :          if (!has_subrs) {

  008af	83 7d a0 00	 cmp	 DWORD PTR _has_subrs$[ebp], 0
  008b3	75 65		 jne	 SHORT $LN68@stbtt__run

; 2106 :             if (info->fdselect.size)

  008b5	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  008b8	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  008bc	74 55		 je	 SHORT $LN69@stbtt__run

; 2107 :                subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);

  008be	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  008c1	50		 push	 eax
  008c2	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  008c5	51		 push	 ecx
  008c6	8d 95 94 fb ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  008cc	52		 push	 edx
  008cd	e8 00 00 00 00	 call	 ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PBUstbtt_fontinfo@@H@Z ; stbtt__cid_get_glyph_subrs
  008d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  008d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  008d7	89 8d a8 fb ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  008dd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  008e0	89 95 ac fb ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  008e6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  008e9	89 85 b0 fb ff
	ff		 mov	 DWORD PTR $T4[ebp+8], eax
  008ef	8b 8d a8 fb ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  008f5	89 8d 38 fe ff
	ff		 mov	 DWORD PTR _subrs$[ebp], ecx
  008fb	8b 95 ac fb ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+4]
  00901	89 95 3c fe ff
	ff		 mov	 DWORD PTR _subrs$[ebp+4], edx
  00907	8b 85 b0 fb ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+8]
  0090d	89 85 40 fe ff
	ff		 mov	 DWORD PTR _subrs$[ebp+8], eax
$LN69@stbtt__run:

; 2108 :             has_subrs = 1;

  00913	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR _has_subrs$[ebp], 1
$LN68@stbtt__run:

; 2109 :          }
; 2110 :          // fallthrough
; 2111 :       case 0x1D: // callgsubr
; 2112 :          if (sp < 1) return STBTT__CSERR("call(g|)subr stack");

  0091a	83 7d d0 01	 cmp	 DWORD PTR _sp$[ebp], 1
  0091e	7d 07		 jge	 SHORT $LN71@stbtt__run
  00920	33 c0		 xor	 eax, eax
  00922	e9 8a 0a 00 00	 jmp	 $LN1@stbtt__run
$LN71@stbtt__run:

; 2113 :          v = (int) s[--sp];

  00927	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  0092a	83 e8 01	 sub	 eax, 1
  0092d	89 45 d0	 mov	 DWORD PTR _sp$[ebp], eax
  00930	8b 4d d0	 mov	 ecx, DWORD PTR _sp$[ebp]
  00933	f3 0f 2c 94 8d
	cc fe ff ff	 cvttss2si edx, DWORD PTR _s$[ebp+ecx*4]
  0093c	89 55 c4	 mov	 DWORD PTR _v$[ebp], edx

; 2114 :          if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");

  0093f	83 7d dc 0a	 cmp	 DWORD PTR _subr_stack_height$[ebp], 10 ; 0000000aH
  00943	7c 07		 jl	 SHORT $LN72@stbtt__run
  00945	33 c0		 xor	 eax, eax
  00947	e9 65 0a 00 00	 jmp	 $LN1@stbtt__run
$LN72@stbtt__run:

; 2115 :          subr_stack[subr_stack_height++] = b;

  0094c	6b 45 dc 0c	 imul	 eax, DWORD PTR _subr_stack_height$[ebp], 12
  00950	8d 8c 05 4c fe
	ff ff		 lea	 ecx, DWORD PTR _subr_stack$[ebp+eax]
  00957	8b 95 24 fe ff
	ff		 mov	 edx, DWORD PTR _b$[ebp]
  0095d	89 11		 mov	 DWORD PTR [ecx], edx
  0095f	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR _b$[ebp+4]
  00965	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00968	8b 95 2c fe ff
	ff		 mov	 edx, DWORD PTR _b$[ebp+8]
  0096e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00971	8b 45 dc	 mov	 eax, DWORD PTR _subr_stack_height$[ebp]
  00974	83 c0 01	 add	 eax, 1
  00977	89 45 dc	 mov	 DWORD PTR _subr_stack_height$[ebp], eax

; 2116 :          b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

  0097a	83 7d ac 0a	 cmp	 DWORD PTR _b0$[ebp], 10	; 0000000aH
  0097e	75 0e		 jne	 SHORT $LN101@stbtt__run
  00980	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _subrs$[ebp]
  00986	89 85 64 fb ff
	ff		 mov	 DWORD PTR tv400[ebp], eax
  0098c	eb 0c		 jmp	 SHORT $LN102@stbtt__run
$LN101@stbtt__run:
  0098e	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00991	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00994	89 8d 64 fb ff
	ff		 mov	 DWORD PTR tv400[ebp], ecx
$LN102@stbtt__run:
  0099a	8b 55 c4	 mov	 edx, DWORD PTR _v$[ebp]
  0099d	52		 push	 edx
  0099e	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR tv400[ebp]
  009a4	83 ec 0c	 sub	 esp, 12			; 0000000cH
  009a7	8b cc		 mov	 ecx, esp
  009a9	8b 10		 mov	 edx, DWORD PTR [eax]
  009ab	89 11		 mov	 DWORD PTR [ecx], edx
  009ad	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  009b0	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  009b3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  009b6	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  009b9	8d 8d 6c fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  009bf	51		 push	 ecx
  009c0	e8 00 00 00 00	 call	 ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__get_subr
  009c5	83 c4 14	 add	 esp, 20			; 00000014H
  009c8	8b 10		 mov	 edx, DWORD PTR [eax]
  009ca	89 95 80 fb ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  009d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009d3	89 8d 84 fb ff
	ff		 mov	 DWORD PTR $T2[ebp+4], ecx
  009d9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  009dc	89 95 88 fb ff
	ff		 mov	 DWORD PTR $T2[ebp+8], edx
  009e2	8b 85 80 fb ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  009e8	89 85 24 fe ff
	ff		 mov	 DWORD PTR _b$[ebp], eax
  009ee	8b 8d 84 fb ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+4]
  009f4	89 8d 28 fe ff
	ff		 mov	 DWORD PTR _b$[ebp+4], ecx
  009fa	8b 95 88 fb ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+8]
  00a00	89 95 2c fe ff
	ff		 mov	 DWORD PTR _b$[ebp+8], edx

; 2117 :          if (b.size == 0) return STBTT__CSERR("subr not found");

  00a06	83 bd 2c fe ff
	ff 00		 cmp	 DWORD PTR _b$[ebp+8], 0
  00a0d	75 07		 jne	 SHORT $LN73@stbtt__run
  00a0f	33 c0		 xor	 eax, eax
  00a11	e9 9b 09 00 00	 jmp	 $LN1@stbtt__run
$LN73@stbtt__run:

; 2118 :          b.cursor = 0;

  00a16	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _b$[ebp+4], 0

; 2119 :          clear_stack = 0;

  00a20	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _clear_stack$[ebp], 0

; 2120 :          break;

  00a27	e9 71 09 00 00	 jmp	 $LN4@stbtt__run
$LN74@stbtt__run:

; 2121 : 
; 2122 :       case 0x0B: // return
; 2123 :          if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");

  00a2c	83 7d dc 00	 cmp	 DWORD PTR _subr_stack_height$[ebp], 0
  00a30	7f 07		 jg	 SHORT $LN75@stbtt__run
  00a32	33 c0		 xor	 eax, eax
  00a34	e9 78 09 00 00	 jmp	 $LN1@stbtt__run
$LN75@stbtt__run:

; 2124 :          b = subr_stack[--subr_stack_height];

  00a39	8b 45 dc	 mov	 eax, DWORD PTR _subr_stack_height$[ebp]
  00a3c	83 e8 01	 sub	 eax, 1
  00a3f	89 45 dc	 mov	 DWORD PTR _subr_stack_height$[ebp], eax
  00a42	6b 4d dc 0c	 imul	 ecx, DWORD PTR _subr_stack_height$[ebp], 12
  00a46	8d 94 0d 4c fe
	ff ff		 lea	 edx, DWORD PTR _subr_stack$[ebp+ecx]
  00a4d	8b 02		 mov	 eax, DWORD PTR [edx]
  00a4f	89 85 24 fe ff
	ff		 mov	 DWORD PTR _b$[ebp], eax
  00a55	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00a58	89 8d 28 fe ff
	ff		 mov	 DWORD PTR _b$[ebp+4], ecx
  00a5e	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00a61	89 95 2c fe ff
	ff		 mov	 DWORD PTR _b$[ebp+8], edx

; 2125 :          clear_stack = 0;

  00a67	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _clear_stack$[ebp], 0

; 2126 :          break;

  00a6e	e9 2a 09 00 00	 jmp	 $LN4@stbtt__run
$LN76@stbtt__run:

; 2127 : 
; 2128 :       case 0x0E: // endchar
; 2129 :          stbtt__csctx_close_shape(c);

  00a73	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00a76	50		 push	 eax
  00a77	e8 00 00 00 00	 call	 ?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape
  00a7c	83 c4 04	 add	 esp, 4

; 2130 :          return 1;

  00a7f	b8 01 00 00 00	 mov	 eax, 1
  00a84	e9 28 09 00 00	 jmp	 $LN1@stbtt__run
$LN77@stbtt__run:

; 2131 : 
; 2132 :       case 0x0C: { // two-byte escape
; 2133 :          float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
; 2134 :          float dx, dy;
; 2135 :          int b1 = stbtt__buf_get8(&b);

  00a89	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _b$[ebp]
  00a8f	50		 push	 eax
  00a90	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00a95	83 c4 04	 add	 esp, 4
  00a98	0f b6 c8	 movzx	 ecx, al
  00a9b	89 8d 64 fd ff
	ff		 mov	 DWORD PTR _b1$7[ebp], ecx

; 2136 :          switch (b1) {

  00aa1	8b 85 64 fd ff
	ff		 mov	 eax, DWORD PTR _b1$7[ebp]
  00aa7	89 85 64 fb ff
	ff		 mov	 DWORD PTR tv414[ebp], eax
  00aad	8b 8d 64 fb ff
	ff		 mov	 ecx, DWORD PTR tv414[ebp]
  00ab3	83 e9 22	 sub	 ecx, 34			; 00000022H
  00ab6	89 8d 64 fb ff
	ff		 mov	 DWORD PTR tv414[ebp], ecx
  00abc	83 bd 64 fb ff
	ff 03		 cmp	 DWORD PTR tv414[ebp], 3
  00ac3	0f 87 16 08 00
	00		 ja	 $LN88@stbtt__run
  00ac9	8b 95 64 fb ff
	ff		 mov	 edx, DWORD PTR tv414[ebp]
  00acf	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN105@stbtt__run[edx*4]
$LN78@stbtt__run:

; 2137 :          // @TODO These "flex" implementations ignore the flex-depth and resolution,
; 2138 :          // and always draw beziers.
; 2139 :          case 0x22: // hflex
; 2140 :             if (sp < 7) return STBTT__CSERR("hflex stack");

  00ad6	83 7d d0 07	 cmp	 DWORD PTR _sp$[ebp], 7
  00ada	7d 07		 jge	 SHORT $LN79@stbtt__run
  00adc	33 c0		 xor	 eax, eax
  00ade	e9 ce 08 00 00	 jmp	 $LN1@stbtt__run
$LN79@stbtt__run:

; 2141 :             dx1 = s[0];

  00ae3	b8 04 00 00 00	 mov	 eax, 4
  00ae8	6b c8 00	 imul	 ecx, eax, 0
  00aeb	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00af4	f3 0f 11 85 0c
	fe ff ff	 movss	 DWORD PTR _dx1$21[ebp], xmm0

; 2142 :             dx2 = s[1];

  00afc	b8 04 00 00 00	 mov	 eax, 4
  00b01	c1 e0 00	 shl	 eax, 0
  00b04	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00b0d	f3 0f 11 85 00
	fe ff ff	 movss	 DWORD PTR _dx2$20[ebp], xmm0

; 2143 :             dy2 = s[2];

  00b15	b8 04 00 00 00	 mov	 eax, 4
  00b1a	d1 e0		 shl	 eax, 1
  00b1c	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00b25	f3 0f 11 85 b8
	fd ff ff	 movss	 DWORD PTR _dy2$14[ebp], xmm0

; 2144 :             dx3 = s[3];

  00b2d	b8 04 00 00 00	 mov	 eax, 4
  00b32	6b c8 03	 imul	 ecx, eax, 3
  00b35	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00b3e	f3 0f 11 85 f4
	fd ff ff	 movss	 DWORD PTR _dx3$19[ebp], xmm0

; 2145 :             dx4 = s[4];

  00b46	b8 04 00 00 00	 mov	 eax, 4
  00b4b	c1 e0 02	 shl	 eax, 2
  00b4e	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00b57	f3 0f 11 85 e8
	fd ff ff	 movss	 DWORD PTR _dx4$18[ebp], xmm0

; 2146 :             dx5 = s[5];

  00b5f	b8 04 00 00 00	 mov	 eax, 4
  00b64	6b c8 05	 imul	 ecx, eax, 5
  00b67	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00b70	f3 0f 11 85 dc
	fd ff ff	 movss	 DWORD PTR _dx5$17[ebp], xmm0

; 2147 :             dx6 = s[6];

  00b78	b8 04 00 00 00	 mov	 eax, 4
  00b7d	6b c8 06	 imul	 ecx, eax, 6
  00b80	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00b89	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR _dx6$16[ebp], xmm0

; 2148 :             stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);

  00b91	51		 push	 ecx
  00b92	0f 57 c0	 xorps	 xmm0, xmm0
  00b95	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b9a	51		 push	 ecx
  00b9b	f3 0f 10 85 f4
	fd ff ff	 movss	 xmm0, DWORD PTR _dx3$19[ebp]
  00ba3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ba8	51		 push	 ecx
  00ba9	f3 0f 10 85 b8
	fd ff ff	 movss	 xmm0, DWORD PTR _dy2$14[ebp]
  00bb1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bb6	51		 push	 ecx
  00bb7	f3 0f 10 85 00
	fe ff ff	 movss	 xmm0, DWORD PTR _dx2$20[ebp]
  00bbf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bc4	51		 push	 ecx
  00bc5	0f 57 c0	 xorps	 xmm0, xmm0
  00bc8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bcd	51		 push	 ecx
  00bce	f3 0f 10 85 0c
	fe ff ff	 movss	 xmm0, DWORD PTR _dx1$21[ebp]
  00bd6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bdb	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00bde	50		 push	 eax
  00bdf	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00be4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2149 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);

  00be7	51		 push	 ecx
  00be8	0f 57 c0	 xorps	 xmm0, xmm0
  00beb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bf0	51		 push	 ecx
  00bf1	f3 0f 10 85 d0
	fd ff ff	 movss	 xmm0, DWORD PTR _dx6$16[ebp]
  00bf9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bfe	f3 0f 10 85 b8
	fd ff ff	 movss	 xmm0, DWORD PTR _dy2$14[ebp]
  00c06	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00c0d	51		 push	 ecx
  00c0e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c13	51		 push	 ecx
  00c14	f3 0f 10 85 dc
	fd ff ff	 movss	 xmm0, DWORD PTR _dx5$17[ebp]
  00c1c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c21	51		 push	 ecx
  00c22	0f 57 c0	 xorps	 xmm0, xmm0
  00c25	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c2a	51		 push	 ecx
  00c2b	f3 0f 10 85 e8
	fd ff ff	 movss	 xmm0, DWORD PTR _dx4$18[ebp]
  00c33	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c38	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00c3b	50		 push	 eax
  00c3c	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00c41	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2150 :             break;

  00c44	e9 9d 06 00 00	 jmp	 $LN27@stbtt__run
$LN80@stbtt__run:

; 2151 : 
; 2152 :          case 0x23: // flex
; 2153 :             if (sp < 13) return STBTT__CSERR("flex stack");

  00c49	83 7d d0 0d	 cmp	 DWORD PTR _sp$[ebp], 13	; 0000000dH
  00c4d	7d 07		 jge	 SHORT $LN81@stbtt__run
  00c4f	33 c0		 xor	 eax, eax
  00c51	e9 5b 07 00 00	 jmp	 $LN1@stbtt__run
$LN81@stbtt__run:

; 2154 :             dx1 = s[0];

  00c56	b8 04 00 00 00	 mov	 eax, 4
  00c5b	6b c8 00	 imul	 ecx, eax, 0
  00c5e	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00c67	f3 0f 11 85 0c
	fe ff ff	 movss	 DWORD PTR _dx1$21[ebp], xmm0

; 2155 :             dy1 = s[1];

  00c6f	b8 04 00 00 00	 mov	 eax, 4
  00c74	c1 e0 00	 shl	 eax, 0
  00c77	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00c80	f3 0f 11 85 c4
	fd ff ff	 movss	 DWORD PTR _dy1$15[ebp], xmm0

; 2156 :             dx2 = s[2];

  00c88	b8 04 00 00 00	 mov	 eax, 4
  00c8d	d1 e0		 shl	 eax, 1
  00c8f	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00c98	f3 0f 11 85 00
	fe ff ff	 movss	 DWORD PTR _dx2$20[ebp], xmm0

; 2157 :             dy2 = s[3];

  00ca0	b8 04 00 00 00	 mov	 eax, 4
  00ca5	6b c8 03	 imul	 ecx, eax, 3
  00ca8	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00cb1	f3 0f 11 85 b8
	fd ff ff	 movss	 DWORD PTR _dy2$14[ebp], xmm0

; 2158 :             dx3 = s[4];

  00cb9	b8 04 00 00 00	 mov	 eax, 4
  00cbe	c1 e0 02	 shl	 eax, 2
  00cc1	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00cca	f3 0f 11 85 f4
	fd ff ff	 movss	 DWORD PTR _dx3$19[ebp], xmm0

; 2159 :             dy3 = s[5];

  00cd2	b8 04 00 00 00	 mov	 eax, 4
  00cd7	6b c8 05	 imul	 ecx, eax, 5
  00cda	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00ce3	f3 0f 11 85 ac
	fd ff ff	 movss	 DWORD PTR _dy3$13[ebp], xmm0

; 2160 :             dx4 = s[6];

  00ceb	b8 04 00 00 00	 mov	 eax, 4
  00cf0	6b c8 06	 imul	 ecx, eax, 6
  00cf3	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00cfc	f3 0f 11 85 e8
	fd ff ff	 movss	 DWORD PTR _dx4$18[ebp], xmm0

; 2161 :             dy4 = s[7];

  00d04	b8 04 00 00 00	 mov	 eax, 4
  00d09	6b c8 07	 imul	 ecx, eax, 7
  00d0c	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00d15	f3 0f 11 85 a0
	fd ff ff	 movss	 DWORD PTR _dy4$12[ebp], xmm0

; 2162 :             dx5 = s[8];

  00d1d	b8 04 00 00 00	 mov	 eax, 4
  00d22	c1 e0 03	 shl	 eax, 3
  00d25	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00d2e	f3 0f 11 85 dc
	fd ff ff	 movss	 DWORD PTR _dx5$17[ebp], xmm0

; 2163 :             dy5 = s[9];

  00d36	b8 04 00 00 00	 mov	 eax, 4
  00d3b	6b c8 09	 imul	 ecx, eax, 9
  00d3e	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00d47	f3 0f 11 85 94
	fd ff ff	 movss	 DWORD PTR _dy5$11[ebp], xmm0

; 2164 :             dx6 = s[10];

  00d4f	b8 04 00 00 00	 mov	 eax, 4
  00d54	6b c8 0a	 imul	 ecx, eax, 10
  00d57	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00d60	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR _dx6$16[ebp], xmm0

; 2165 :             dy6 = s[11];

  00d68	b8 04 00 00 00	 mov	 eax, 4
  00d6d	6b c8 0b	 imul	 ecx, eax, 11
  00d70	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00d79	f3 0f 11 85 88
	fd ff ff	 movss	 DWORD PTR _dy6$10[ebp], xmm0

; 2166 :             //fd is s[12]
; 2167 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

  00d81	51		 push	 ecx
  00d82	f3 0f 10 85 ac
	fd ff ff	 movss	 xmm0, DWORD PTR _dy3$13[ebp]
  00d8a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d8f	51		 push	 ecx
  00d90	f3 0f 10 85 f4
	fd ff ff	 movss	 xmm0, DWORD PTR _dx3$19[ebp]
  00d98	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d9d	51		 push	 ecx
  00d9e	f3 0f 10 85 b8
	fd ff ff	 movss	 xmm0, DWORD PTR _dy2$14[ebp]
  00da6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dab	51		 push	 ecx
  00dac	f3 0f 10 85 00
	fe ff ff	 movss	 xmm0, DWORD PTR _dx2$20[ebp]
  00db4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00db9	51		 push	 ecx
  00dba	f3 0f 10 85 c4
	fd ff ff	 movss	 xmm0, DWORD PTR _dy1$15[ebp]
  00dc2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dc7	51		 push	 ecx
  00dc8	f3 0f 10 85 0c
	fe ff ff	 movss	 xmm0, DWORD PTR _dx1$21[ebp]
  00dd0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dd5	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00dd8	50		 push	 eax
  00dd9	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00dde	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2168 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

  00de1	51		 push	 ecx
  00de2	f3 0f 10 85 88
	fd ff ff	 movss	 xmm0, DWORD PTR _dy6$10[ebp]
  00dea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00def	51		 push	 ecx
  00df0	f3 0f 10 85 d0
	fd ff ff	 movss	 xmm0, DWORD PTR _dx6$16[ebp]
  00df8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dfd	51		 push	 ecx
  00dfe	f3 0f 10 85 94
	fd ff ff	 movss	 xmm0, DWORD PTR _dy5$11[ebp]
  00e06	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e0b	51		 push	 ecx
  00e0c	f3 0f 10 85 dc
	fd ff ff	 movss	 xmm0, DWORD PTR _dx5$17[ebp]
  00e14	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e19	51		 push	 ecx
  00e1a	f3 0f 10 85 a0
	fd ff ff	 movss	 xmm0, DWORD PTR _dy4$12[ebp]
  00e22	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e27	51		 push	 ecx
  00e28	f3 0f 10 85 e8
	fd ff ff	 movss	 xmm0, DWORD PTR _dx4$18[ebp]
  00e30	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e35	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00e38	50		 push	 eax
  00e39	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00e3e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2169 :             break;

  00e41	e9 a0 04 00 00	 jmp	 $LN27@stbtt__run
$LN82@stbtt__run:

; 2170 : 
; 2171 :          case 0x24: // hflex1
; 2172 :             if (sp < 9) return STBTT__CSERR("hflex1 stack");

  00e46	83 7d d0 09	 cmp	 DWORD PTR _sp$[ebp], 9
  00e4a	7d 07		 jge	 SHORT $LN83@stbtt__run
  00e4c	33 c0		 xor	 eax, eax
  00e4e	e9 5e 05 00 00	 jmp	 $LN1@stbtt__run
$LN83@stbtt__run:

; 2173 :             dx1 = s[0];

  00e53	b8 04 00 00 00	 mov	 eax, 4
  00e58	6b c8 00	 imul	 ecx, eax, 0
  00e5b	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00e64	f3 0f 11 85 0c
	fe ff ff	 movss	 DWORD PTR _dx1$21[ebp], xmm0

; 2174 :             dy1 = s[1];

  00e6c	b8 04 00 00 00	 mov	 eax, 4
  00e71	c1 e0 00	 shl	 eax, 0
  00e74	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00e7d	f3 0f 11 85 c4
	fd ff ff	 movss	 DWORD PTR _dy1$15[ebp], xmm0

; 2175 :             dx2 = s[2];

  00e85	b8 04 00 00 00	 mov	 eax, 4
  00e8a	d1 e0		 shl	 eax, 1
  00e8c	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00e95	f3 0f 11 85 00
	fe ff ff	 movss	 DWORD PTR _dx2$20[ebp], xmm0

; 2176 :             dy2 = s[3];

  00e9d	b8 04 00 00 00	 mov	 eax, 4
  00ea2	6b c8 03	 imul	 ecx, eax, 3
  00ea5	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00eae	f3 0f 11 85 b8
	fd ff ff	 movss	 DWORD PTR _dy2$14[ebp], xmm0

; 2177 :             dx3 = s[4];

  00eb6	b8 04 00 00 00	 mov	 eax, 4
  00ebb	c1 e0 02	 shl	 eax, 2
  00ebe	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00ec7	f3 0f 11 85 f4
	fd ff ff	 movss	 DWORD PTR _dx3$19[ebp], xmm0

; 2178 :             dx4 = s[5];

  00ecf	b8 04 00 00 00	 mov	 eax, 4
  00ed4	6b c8 05	 imul	 ecx, eax, 5
  00ed7	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00ee0	f3 0f 11 85 e8
	fd ff ff	 movss	 DWORD PTR _dx4$18[ebp], xmm0

; 2179 :             dx5 = s[6];

  00ee8	b8 04 00 00 00	 mov	 eax, 4
  00eed	6b c8 06	 imul	 ecx, eax, 6
  00ef0	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00ef9	f3 0f 11 85 dc
	fd ff ff	 movss	 DWORD PTR _dx5$17[ebp], xmm0

; 2180 :             dy5 = s[7];

  00f01	b8 04 00 00 00	 mov	 eax, 4
  00f06	6b c8 07	 imul	 ecx, eax, 7
  00f09	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  00f12	f3 0f 11 85 94
	fd ff ff	 movss	 DWORD PTR _dy5$11[ebp], xmm0

; 2181 :             dx6 = s[8];

  00f1a	b8 04 00 00 00	 mov	 eax, 4
  00f1f	c1 e0 03	 shl	 eax, 3
  00f22	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  00f2b	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR _dx6$16[ebp], xmm0

; 2182 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);

  00f33	51		 push	 ecx
  00f34	0f 57 c0	 xorps	 xmm0, xmm0
  00f37	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f3c	51		 push	 ecx
  00f3d	f3 0f 10 85 f4
	fd ff ff	 movss	 xmm0, DWORD PTR _dx3$19[ebp]
  00f45	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f4a	51		 push	 ecx
  00f4b	f3 0f 10 85 b8
	fd ff ff	 movss	 xmm0, DWORD PTR _dy2$14[ebp]
  00f53	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f58	51		 push	 ecx
  00f59	f3 0f 10 85 00
	fe ff ff	 movss	 xmm0, DWORD PTR _dx2$20[ebp]
  00f61	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f66	51		 push	 ecx
  00f67	f3 0f 10 85 c4
	fd ff ff	 movss	 xmm0, DWORD PTR _dy1$15[ebp]
  00f6f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f74	51		 push	 ecx
  00f75	f3 0f 10 85 0c
	fe ff ff	 movss	 xmm0, DWORD PTR _dx1$21[ebp]
  00f7d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f82	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00f85	50		 push	 eax
  00f86	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00f8b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2183 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));

  00f8e	f3 0f 10 85 c4
	fd ff ff	 movss	 xmm0, DWORD PTR _dy1$15[ebp]
  00f96	f3 0f 58 85 b8
	fd ff ff	 addss	 xmm0, DWORD PTR _dy2$14[ebp]
  00f9e	f3 0f 58 85 94
	fd ff ff	 addss	 xmm0, DWORD PTR _dy5$11[ebp]
  00fa6	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00fad	51		 push	 ecx
  00fae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fb3	51		 push	 ecx
  00fb4	f3 0f 10 85 d0
	fd ff ff	 movss	 xmm0, DWORD PTR _dx6$16[ebp]
  00fbc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fc1	51		 push	 ecx
  00fc2	f3 0f 10 85 94
	fd ff ff	 movss	 xmm0, DWORD PTR _dy5$11[ebp]
  00fca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fcf	51		 push	 ecx
  00fd0	f3 0f 10 85 dc
	fd ff ff	 movss	 xmm0, DWORD PTR _dx5$17[ebp]
  00fd8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fdd	51		 push	 ecx
  00fde	0f 57 c0	 xorps	 xmm0, xmm0
  00fe1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fe6	51		 push	 ecx
  00fe7	f3 0f 10 85 e8
	fd ff ff	 movss	 xmm0, DWORD PTR _dx4$18[ebp]
  00fef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ff4	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  00ff7	50		 push	 eax
  00ff8	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00ffd	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2184 :             break;

  01000	e9 e1 02 00 00	 jmp	 $LN27@stbtt__run
$LN84@stbtt__run:

; 2185 : 
; 2186 :          case 0x25: // flex1
; 2187 :             if (sp < 11) return STBTT__CSERR("flex1 stack");

  01005	83 7d d0 0b	 cmp	 DWORD PTR _sp$[ebp], 11	; 0000000bH
  01009	7d 07		 jge	 SHORT $LN85@stbtt__run
  0100b	33 c0		 xor	 eax, eax
  0100d	e9 9f 03 00 00	 jmp	 $LN1@stbtt__run
$LN85@stbtt__run:

; 2188 :             dx1 = s[0];

  01012	b8 04 00 00 00	 mov	 eax, 4
  01017	6b c8 00	 imul	 ecx, eax, 0
  0101a	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  01023	f3 0f 11 85 0c
	fe ff ff	 movss	 DWORD PTR _dx1$21[ebp], xmm0

; 2189 :             dy1 = s[1];

  0102b	b8 04 00 00 00	 mov	 eax, 4
  01030	c1 e0 00	 shl	 eax, 0
  01033	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  0103c	f3 0f 11 85 c4
	fd ff ff	 movss	 DWORD PTR _dy1$15[ebp], xmm0

; 2190 :             dx2 = s[2];

  01044	b8 04 00 00 00	 mov	 eax, 4
  01049	d1 e0		 shl	 eax, 1
  0104b	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  01054	f3 0f 11 85 00
	fe ff ff	 movss	 DWORD PTR _dx2$20[ebp], xmm0

; 2191 :             dy2 = s[3];

  0105c	b8 04 00 00 00	 mov	 eax, 4
  01061	6b c8 03	 imul	 ecx, eax, 3
  01064	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  0106d	f3 0f 11 85 b8
	fd ff ff	 movss	 DWORD PTR _dy2$14[ebp], xmm0

; 2192 :             dx3 = s[4];

  01075	b8 04 00 00 00	 mov	 eax, 4
  0107a	c1 e0 02	 shl	 eax, 2
  0107d	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  01086	f3 0f 11 85 f4
	fd ff ff	 movss	 DWORD PTR _dx3$19[ebp], xmm0

; 2193 :             dy3 = s[5];

  0108e	b8 04 00 00 00	 mov	 eax, 4
  01093	6b c8 05	 imul	 ecx, eax, 5
  01096	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  0109f	f3 0f 11 85 ac
	fd ff ff	 movss	 DWORD PTR _dy3$13[ebp], xmm0

; 2194 :             dx4 = s[6];

  010a7	b8 04 00 00 00	 mov	 eax, 4
  010ac	6b c8 06	 imul	 ecx, eax, 6
  010af	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  010b8	f3 0f 11 85 e8
	fd ff ff	 movss	 DWORD PTR _dx4$18[ebp], xmm0

; 2195 :             dy4 = s[7];

  010c0	b8 04 00 00 00	 mov	 eax, 4
  010c5	6b c8 07	 imul	 ecx, eax, 7
  010c8	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  010d1	f3 0f 11 85 a0
	fd ff ff	 movss	 DWORD PTR _dy4$12[ebp], xmm0

; 2196 :             dx5 = s[8];

  010d9	b8 04 00 00 00	 mov	 eax, 4
  010de	c1 e0 03	 shl	 eax, 3
  010e1	f3 0f 10 84 05
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+eax]
  010ea	f3 0f 11 85 dc
	fd ff ff	 movss	 DWORD PTR _dx5$17[ebp], xmm0

; 2197 :             dy5 = s[9];

  010f2	b8 04 00 00 00	 mov	 eax, 4
  010f7	6b c8 09	 imul	 ecx, eax, 9
  010fa	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  01103	f3 0f 11 85 94
	fd ff ff	 movss	 DWORD PTR _dy5$11[ebp], xmm0

; 2198 :             dx6 = dy6 = s[10];

  0110b	b8 04 00 00 00	 mov	 eax, 4
  01110	6b c8 0a	 imul	 ecx, eax, 10
  01113	f3 0f 10 84 0d
	cc fe ff ff	 movss	 xmm0, DWORD PTR _s$[ebp+ecx]
  0111c	f3 0f 11 85 88
	fd ff ff	 movss	 DWORD PTR _dy6$10[ebp], xmm0
  01124	f3 0f 10 85 88
	fd ff ff	 movss	 xmm0, DWORD PTR _dy6$10[ebp]
  0112c	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR _dx6$16[ebp], xmm0

; 2199 :             dx = dx1+dx2+dx3+dx4+dx5;

  01134	f3 0f 10 85 0c
	fe ff ff	 movss	 xmm0, DWORD PTR _dx1$21[ebp]
  0113c	f3 0f 58 85 00
	fe ff ff	 addss	 xmm0, DWORD PTR _dx2$20[ebp]
  01144	f3 0f 58 85 f4
	fd ff ff	 addss	 xmm0, DWORD PTR _dx3$19[ebp]
  0114c	f3 0f 58 85 e8
	fd ff ff	 addss	 xmm0, DWORD PTR _dx4$18[ebp]
  01154	f3 0f 58 85 dc
	fd ff ff	 addss	 xmm0, DWORD PTR _dx5$17[ebp]
  0115c	f3 0f 11 85 7c
	fd ff ff	 movss	 DWORD PTR _dx$9[ebp], xmm0

; 2200 :             dy = dy1+dy2+dy3+dy4+dy5;

  01164	f3 0f 10 85 c4
	fd ff ff	 movss	 xmm0, DWORD PTR _dy1$15[ebp]
  0116c	f3 0f 58 85 b8
	fd ff ff	 addss	 xmm0, DWORD PTR _dy2$14[ebp]
  01174	f3 0f 58 85 ac
	fd ff ff	 addss	 xmm0, DWORD PTR _dy3$13[ebp]
  0117c	f3 0f 58 85 a0
	fd ff ff	 addss	 xmm0, DWORD PTR _dy4$12[ebp]
  01184	f3 0f 58 85 94
	fd ff ff	 addss	 xmm0, DWORD PTR _dy5$11[ebp]
  0118c	f3 0f 11 85 70
	fd ff ff	 movss	 DWORD PTR _dy$8[ebp], xmm0

; 2201 :             if (STBTT_fabs(dx) > STBTT_fabs(dy))

  01194	51		 push	 ecx
  01195	f3 0f 10 85 7c
	fd ff ff	 movss	 xmm0, DWORD PTR _dx$9[ebp]
  0119d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011a2	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  011a7	83 c4 04	 add	 esp, 4
  011aa	d9 9d 64 fb ff
	ff		 fstp	 DWORD PTR tv1206[ebp]
  011b0	f3 0f 10 85 64
	fb ff ff	 movss	 xmm0, DWORD PTR tv1206[ebp]
  011b8	51		 push	 ecx
  011b9	f3 0f 10 8d 70
	fd ff ff	 movss	 xmm1, DWORD PTR _dy$8[ebp]
  011c1	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  011c6	f3 0f 11 85 60
	fb ff ff	 movss	 DWORD PTR tv1255[ebp], xmm0
  011ce	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  011d3	83 c4 04	 add	 esp, 4
  011d6	d9 9d 5c fb ff
	ff		 fstp	 DWORD PTR tv1212[ebp]
  011dc	f3 0f 10 85 60
	fb ff ff	 movss	 xmm0, DWORD PTR tv1255[ebp]
  011e4	0f 2f 85 5c fb
	ff ff		 comiss	 xmm0, DWORD PTR tv1212[ebp]
  011eb	76 19		 jbe	 SHORT $LN86@stbtt__run

; 2202 :                dy6 = -dy;

  011ed	f3 0f 10 85 70
	fd ff ff	 movss	 xmm0, DWORD PTR _dy$8[ebp]
  011f5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  011fc	f3 0f 11 85 88
	fd ff ff	 movss	 DWORD PTR _dy6$10[ebp], xmm0
  01204	eb 17		 jmp	 SHORT $LN87@stbtt__run
$LN86@stbtt__run:

; 2203 :             else
; 2204 :                dx6 = -dx;

  01206	f3 0f 10 85 7c
	fd ff ff	 movss	 xmm0, DWORD PTR _dx$9[ebp]
  0120e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  01215	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR _dx6$16[ebp], xmm0
$LN87@stbtt__run:

; 2205 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

  0121d	51		 push	 ecx
  0121e	f3 0f 10 85 ac
	fd ff ff	 movss	 xmm0, DWORD PTR _dy3$13[ebp]
  01226	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0122b	51		 push	 ecx
  0122c	f3 0f 10 85 f4
	fd ff ff	 movss	 xmm0, DWORD PTR _dx3$19[ebp]
  01234	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01239	51		 push	 ecx
  0123a	f3 0f 10 85 b8
	fd ff ff	 movss	 xmm0, DWORD PTR _dy2$14[ebp]
  01242	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01247	51		 push	 ecx
  01248	f3 0f 10 85 00
	fe ff ff	 movss	 xmm0, DWORD PTR _dx2$20[ebp]
  01250	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01255	51		 push	 ecx
  01256	f3 0f 10 85 c4
	fd ff ff	 movss	 xmm0, DWORD PTR _dy1$15[ebp]
  0125e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01263	51		 push	 ecx
  01264	f3 0f 10 85 0c
	fe ff ff	 movss	 xmm0, DWORD PTR _dx1$21[ebp]
  0126c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01271	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  01274	50		 push	 eax
  01275	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  0127a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2206 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

  0127d	51		 push	 ecx
  0127e	f3 0f 10 85 88
	fd ff ff	 movss	 xmm0, DWORD PTR _dy6$10[ebp]
  01286	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0128b	51		 push	 ecx
  0128c	f3 0f 10 85 d0
	fd ff ff	 movss	 xmm0, DWORD PTR _dx6$16[ebp]
  01294	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01299	51		 push	 ecx
  0129a	f3 0f 10 85 94
	fd ff ff	 movss	 xmm0, DWORD PTR _dy5$11[ebp]
  012a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012a7	51		 push	 ecx
  012a8	f3 0f 10 85 dc
	fd ff ff	 movss	 xmm0, DWORD PTR _dx5$17[ebp]
  012b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012b5	51		 push	 ecx
  012b6	f3 0f 10 85 a0
	fd ff ff	 movss	 xmm0, DWORD PTR _dy4$12[ebp]
  012be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012c3	51		 push	 ecx
  012c4	f3 0f 10 85 e8
	fd ff ff	 movss	 xmm0, DWORD PTR _dx4$18[ebp]
  012cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012d1	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  012d4	50		 push	 eax
  012d5	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  012da	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2207 :             break;

  012dd	eb 07		 jmp	 SHORT $LN27@stbtt__run
$LN88@stbtt__run:

; 2208 : 
; 2209 :          default:
; 2210 :             return STBTT__CSERR("unimplemented");

  012df	33 c0		 xor	 eax, eax
  012e1	e9 cb 00 00 00	 jmp	 $LN1@stbtt__run
$LN27@stbtt__run:

; 2211 :          }
; 2212 :       } break;

  012e6	e9 b2 00 00 00	 jmp	 $LN4@stbtt__run
$LN89@stbtt__run:

; 2213 : 
; 2214 :       default:
; 2215 :          if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) //-V560

  012eb	81 7d ac ff 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 255 ; 000000ffH
  012f2	74 1c		 je	 SHORT $LN90@stbtt__run
  012f4	83 7d ac 1c	 cmp	 DWORD PTR _b0$[ebp], 28	; 0000001cH
  012f8	74 16		 je	 SHORT $LN90@stbtt__run
  012fa	83 7d ac 20	 cmp	 DWORD PTR _b0$[ebp], 32	; 00000020H
  012fe	7c 09		 jl	 SHORT $LN91@stbtt__run
  01300	81 7d ac fe 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 254 ; 000000feH
  01307	7e 07		 jle	 SHORT $LN90@stbtt__run
$LN91@stbtt__run:

; 2216 :             return STBTT__CSERR("reserved operator");

  01309	33 c0		 xor	 eax, eax
  0130b	e9 a1 00 00 00	 jmp	 $LN1@stbtt__run
$LN90@stbtt__run:

; 2217 : 
; 2218 :          // push immediate
; 2219 :          if (b0 == 255) {

  01310	81 7d ac ff 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 255 ; 000000ffH
  01317	75 27		 jne	 SHORT $LN92@stbtt__run

; 2220 :             f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;

  01319	6a 04		 push	 4
  0131b	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _b$[ebp]
  01321	50		 push	 eax
  01322	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  01327	83 c4 08	 add	 esp, 8
  0132a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0132e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@47800000
  01336	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0

; 2221 :          } else {

  0133e	eb 2f		 jmp	 SHORT $LN93@stbtt__run
$LN92@stbtt__run:

; 2222 :             stbtt__buf_skip(&b, -1);

  01340	6a ff		 push	 -1
  01342	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _b$[ebp]
  01348	50		 push	 eax
  01349	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  0134e	83 c4 08	 add	 esp, 8

; 2223 :             f = (float)(stbtt_int16)stbtt__cff_int(&b);

  01351	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR _b$[ebp]
  01357	50		 push	 eax
  01358	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z ; stbtt__cff_int
  0135d	83 c4 04	 add	 esp, 4
  01360	0f bf c8	 movsx	 ecx, ax
  01363	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  01367	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
$LN93@stbtt__run:

; 2224 :          }
; 2225 :          if (sp >= 48) return STBTT__CSERR("push stack overflow");

  0136f	83 7d d0 30	 cmp	 DWORD PTR _sp$[ebp], 48	; 00000030H
  01373	7c 04		 jl	 SHORT $LN94@stbtt__run
  01375	33 c0		 xor	 eax, eax
  01377	eb 38		 jmp	 SHORT $LN1@stbtt__run
$LN94@stbtt__run:

; 2226 :          s[sp++] = f;

  01379	8b 45 d0	 mov	 eax, DWORD PTR _sp$[ebp]
  0137c	f3 0f 10 85 18
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  01384	f3 0f 11 84 85
	cc fe ff ff	 movss	 DWORD PTR _s$[ebp+eax*4], xmm0
  0138d	8b 4d d0	 mov	 ecx, DWORD PTR _sp$[ebp]
  01390	83 c1 01	 add	 ecx, 1
  01393	89 4d d0	 mov	 DWORD PTR _sp$[ebp], ecx

; 2227 :          clear_stack = 0;

  01396	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _clear_stack$[ebp], 0
$LN4@stbtt__run:

; 2228 :          break;
; 2229 :       }
; 2230 :       if (clear_stack) sp = 0;

  0139d	83 7d 94 00	 cmp	 DWORD PTR _clear_stack$[ebp], 0
  013a1	74 07		 je	 SHORT $LN95@stbtt__run
  013a3	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _sp$[ebp], 0
$LN95@stbtt__run:

; 2231 :    }

  013aa	e9 32 ed ff ff	 jmp	 $LN2@stbtt__run
$LN3@stbtt__run:

; 2232 :    return STBTT__CSERR("no endchar");

  013af	33 c0		 xor	 eax, eax
$LN1@stbtt__run:

; 2233 : 
; 2234 : #undef STBTT__CSERR
; 2235 : }

  013b1	52		 push	 edx
  013b2	8b cd		 mov	 ecx, ebp
  013b4	50		 push	 eax
  013b5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN111@stbtt__run
  013bb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  013c0	58		 pop	 eax
  013c1	5a		 pop	 edx
  013c2	5f		 pop	 edi
  013c3	5e		 pop	 esi
  013c4	5b		 pop	 ebx
  013c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013c8	33 cd		 xor	 ecx, ebp
  013ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013cf	81 c4 a4 04 00
	00		 add	 esp, 1188		; 000004a4H
  013d5	3b ec		 cmp	 ebp, esp
  013d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  013dc	8b e5		 mov	 esp, ebp
  013de	5d		 pop	 ebp
  013df	c3		 ret	 0
$LN111@stbtt__run:
  013e0	04 00 00 00	 DD	 4
  013e4	00 00 00 00	 DD	 $LN110@stbtt__run
$LN110@stbtt__run:
  013e8	cc fe ff ff	 DD	 -308			; fffffeccH
  013ec	c0 00 00 00	 DD	 192			; 000000c0H
  013f0	00 00 00 00	 DD	 $LN106@stbtt__run
  013f4	4c fe ff ff	 DD	 -436			; fffffe4cH
  013f8	78 00 00 00	 DD	 120			; 00000078H
  013fc	00 00 00 00	 DD	 $LN107@stbtt__run
  01400	38 fe ff ff	 DD	 -456			; fffffe38H
  01404	0c 00 00 00	 DD	 12			; 0000000cH
  01408	00 00 00 00	 DD	 $LN108@stbtt__run
  0140c	24 fe ff ff	 DD	 -476			; fffffe24H
  01410	0c 00 00 00	 DD	 12			; 0000000cH
  01414	00 00 00 00	 DD	 $LN109@stbtt__run
$LN109@stbtt__run:
  01418	62		 DB	 98			; 00000062H
  01419	00		 DB	 0
$LN108@stbtt__run:
  0141a	73		 DB	 115			; 00000073H
  0141b	75		 DB	 117			; 00000075H
  0141c	62		 DB	 98			; 00000062H
  0141d	72		 DB	 114			; 00000072H
  0141e	73		 DB	 115			; 00000073H
  0141f	00		 DB	 0
$LN107@stbtt__run:
  01420	73		 DB	 115			; 00000073H
  01421	75		 DB	 117			; 00000075H
  01422	62		 DB	 98			; 00000062H
  01423	72		 DB	 114			; 00000072H
  01424	5f		 DB	 95			; 0000005fH
  01425	73		 DB	 115			; 00000073H
  01426	74		 DB	 116			; 00000074H
  01427	61		 DB	 97			; 00000061H
  01428	63		 DB	 99			; 00000063H
  01429	6b		 DB	 107			; 0000006bH
  0142a	00		 DB	 0
$LN106@stbtt__run:
  0142b	73		 DB	 115			; 00000073H
  0142c	00		 DB	 0
  0142d	0f 1f 00	 npad	 3
$LN104@stbtt__run:
  01430	00 00 00 00	 DD	 $LN31@stbtt__run
  01434	00 00 00 00	 DD	 $LN34@stbtt__run
  01438	00 00 00 00	 DD	 $LN38@stbtt__run
  0143c	00 00 00 00	 DD	 $LN43@stbtt__run
  01440	00 00 00 00	 DD	 $LN40@stbtt__run
  01444	00 00 00 00	 DD	 $LN54@stbtt__run
  01448	00 00 00 00	 DD	 $LN67@stbtt__run
  0144c	00 00 00 00	 DD	 $LN74@stbtt__run
  01450	00 00 00 00	 DD	 $LN77@stbtt__run
  01454	00 00 00 00	 DD	 $LN76@stbtt__run
  01458	00 00 00 00	 DD	 $LN29@stbtt__run
  0145c	00 00 00 00	 DD	 $LN32@stbtt__run
  01460	00 00 00 00	 DD	 $LN36@stbtt__run
  01464	00 00 00 00	 DD	 $LN56@stbtt__run
  01468	00 00 00 00	 DD	 $LN59@stbtt__run
  0146c	00 00 00 00	 DD	 $LN62@stbtt__run
  01470	00 00 00 00	 DD	 $LN68@stbtt__run
  01474	00 00 00 00	 DD	 $LN50@stbtt__run
  01478	00 00 00 00	 DD	 $LN47@stbtt__run
  0147c	00 00 00 00	 DD	 $LN89@stbtt__run
$LN103@stbtt__run:
  01480	00		 DB	 0
  01481	13		 DB	 19			; 00000013H
  01482	00		 DB	 0
  01483	01		 DB	 1
  01484	02		 DB	 2
  01485	03		 DB	 3
  01486	04		 DB	 4
  01487	05		 DB	 5
  01488	13		 DB	 19			; 00000013H
  01489	06		 DB	 6
  0148a	07		 DB	 7
  0148b	08		 DB	 8
  0148c	13		 DB	 19			; 00000013H
  0148d	09		 DB	 9
  0148e	13		 DB	 19			; 00000013H
  0148f	13		 DB	 19			; 00000013H
  01490	13		 DB	 19			; 00000013H
  01491	00		 DB	 0
  01492	0a		 DB	 10			; 0000000aH
  01493	0a		 DB	 10			; 0000000aH
  01494	0b		 DB	 11			; 0000000bH
  01495	0c		 DB	 12			; 0000000cH
  01496	00		 DB	 0
  01497	0d		 DB	 13			; 0000000dH
  01498	0e		 DB	 14			; 0000000eH
  01499	0f		 DB	 15			; 0000000fH
  0149a	0f		 DB	 15			; 0000000fH
  0149b	13		 DB	 19			; 00000013H
  0149c	10		 DB	 16			; 00000010H
  0149d	11		 DB	 17			; 00000011H
  0149e	12		 DB	 18			; 00000012H
  0149f	90		 npad	 1
$LN105@stbtt__run:
  014a0	00 00 00 00	 DD	 $LN78@stbtt__run
  014a4	00 00 00 00	 DD	 $LN80@stbtt__run
  014a8	00 00 00 00	 DD	 $LN82@stbtt__run
  014ac	00 00 00 00	 DD	 $LN84@stbtt__run
?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ENDP ; stbtt__run_charstring
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PBUstbtt_fontinfo@@H@Z
_TEXT	SEGMENT
$T1 = -416						; size = 12
$T2 = -396						; size = 12
$T3 = -376						; size = 12
$T4 = -356						; size = 12
$T5 = -336						; size = 12
$T6 = -316						; size = 12
_i$ = -104						; size = 4
_fdselector$ = -92					; size = 4
_fmt$ = -80						; size = 4
_v$ = -68						; size = 4
_end$ = -56						; size = 4
_start$ = -44						; size = 4
_nranges$ = -32						; size = 4
_fdselect$ = -20					; size = 12
__$ArrayPad$ = -4					; size = 4
$T7 = 8							; size = 4
_info$ = 12						; size = 4
_glyph_index$ = 16					; size = 4
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PBUstbtt_fontinfo@@H@Z PROC ; stbtt__cid_get_glyph_subrs, COMDAT

; 1951 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 5c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-420]
  00012	b9 69 00 00 00	 mov	 ecx, 105		; 00000069H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1952 :    stbtt__buf fdselect = info->fdselect;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _info$[ebp]
  00035	83 c0 70	 add	 eax, 112		; 00000070H
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	89 4d ec	 mov	 DWORD PTR _fdselect$[ebp], ecx
  0003d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00040	89 55 f0	 mov	 DWORD PTR _fdselect$[ebp+4], edx
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00046	89 45 f4	 mov	 DWORD PTR _fdselect$[ebp+8], eax

; 1953 :    int nranges, start, end, v, fmt, fdselector = -1, i;

  00049	c7 45 a4 ff ff
	ff ff		 mov	 DWORD PTR _fdselector$[ebp], -1

; 1954 : 
; 1955 :    stbtt__buf_seek(&fdselect, 0);

  00050	6a 00		 push	 0
  00052	8d 45 ec	 lea	 eax, DWORD PTR _fdselect$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  0005b	83 c4 08	 add	 esp, 8

; 1956 :    fmt = stbtt__buf_get8(&fdselect);

  0005e	8d 45 ec	 lea	 eax, DWORD PTR _fdselect$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00067	83 c4 04	 add	 esp, 4
  0006a	0f b6 c8	 movzx	 ecx, al
  0006d	89 4d b0	 mov	 DWORD PTR _fmt$[ebp], ecx

; 1957 :    if (fmt == 0) {

  00070	83 7d b0 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00074	75 27		 jne	 SHORT $LN5@stbtt__cid

; 1958 :       // untested
; 1959 :       stbtt__buf_skip(&fdselect, glyph_index);

  00076	8b 45 10	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  00079	50		 push	 eax
  0007a	8d 4d ec	 lea	 ecx, DWORD PTR _fdselect$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  00083	83 c4 08	 add	 esp, 8

; 1960 :       fdselector = stbtt__buf_get8(&fdselect);

  00086	8d 45 ec	 lea	 eax, DWORD PTR _fdselect$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  0008f	83 c4 04	 add	 esp, 4
  00092	0f b6 c8	 movzx	 ecx, al
  00095	89 4d a4	 mov	 DWORD PTR _fdselector$[ebp], ecx
  00098	e9 85 00 00 00	 jmp	 $LN6@stbtt__cid
$LN5@stbtt__cid:

; 1961 :    } else if (fmt == 3) {

  0009d	83 7d b0 03	 cmp	 DWORD PTR _fmt$[ebp], 3
  000a1	75 7f		 jne	 SHORT $LN6@stbtt__cid

; 1962 :       nranges = stbtt__buf_get16(&fdselect);

  000a3	6a 02		 push	 2
  000a5	8d 45 ec	 lea	 eax, DWORD PTR _fdselect$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000ae	83 c4 08	 add	 esp, 8
  000b1	89 45 e0	 mov	 DWORD PTR _nranges$[ebp], eax

; 1963 :       start = stbtt__buf_get16(&fdselect);

  000b4	6a 02		 push	 2
  000b6	8d 45 ec	 lea	 eax, DWORD PTR _fdselect$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000bf	83 c4 08	 add	 esp, 8
  000c2	89 45 d4	 mov	 DWORD PTR _start$[ebp], eax

; 1964 :       for (i = 0; i < nranges; i++) {

  000c5	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000cc	eb 09		 jmp	 SHORT $LN4@stbtt__cid
$LN2@stbtt__cid:
  000ce	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  000d1	83 c0 01	 add	 eax, 1
  000d4	89 45 98	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt__cid:
  000d7	8b 45 98	 mov	 eax, DWORD PTR _i$[ebp]
  000da	3b 45 e0	 cmp	 eax, DWORD PTR _nranges$[ebp]
  000dd	7d 43		 jge	 SHORT $LN6@stbtt__cid

; 1965 :          v = stbtt__buf_get8(&fdselect);

  000df	8d 45 ec	 lea	 eax, DWORD PTR _fdselect$[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  000e8	83 c4 04	 add	 esp, 4
  000eb	0f b6 c8	 movzx	 ecx, al
  000ee	89 4d bc	 mov	 DWORD PTR _v$[ebp], ecx

; 1966 :          end = stbtt__buf_get16(&fdselect);

  000f1	6a 02		 push	 2
  000f3	8d 45 ec	 lea	 eax, DWORD PTR _fdselect$[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000fc	83 c4 08	 add	 esp, 8
  000ff	89 45 c8	 mov	 DWORD PTR _end$[ebp], eax

; 1967 :          if (glyph_index >= start && glyph_index < end) {

  00102	8b 45 10	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  00105	3b 45 d4	 cmp	 eax, DWORD PTR _start$[ebp]
  00108	7c 10		 jl	 SHORT $LN8@stbtt__cid
  0010a	8b 45 10	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  0010d	3b 45 c8	 cmp	 eax, DWORD PTR _end$[ebp]
  00110	7d 08		 jge	 SHORT $LN8@stbtt__cid

; 1968 :             fdselector = v;

  00112	8b 45 bc	 mov	 eax, DWORD PTR _v$[ebp]
  00115	89 45 a4	 mov	 DWORD PTR _fdselector$[ebp], eax

; 1969 :             break;

  00118	eb 08		 jmp	 SHORT $LN6@stbtt__cid
$LN8@stbtt__cid:

; 1970 :          }
; 1971 :          start = end;

  0011a	8b 45 c8	 mov	 eax, DWORD PTR _end$[ebp]
  0011d	89 45 d4	 mov	 DWORD PTR _start$[ebp], eax

; 1972 :       }

  00120	eb ac		 jmp	 SHORT $LN2@stbtt__cid
$LN6@stbtt__cid:

; 1973 :    }
; 1974 :    if (fdselector == -1) stbtt__new_buf(NULL, 0);

  00122	83 7d a4 ff	 cmp	 DWORD PTR _fdselector$[ebp], -1
  00126	75 2d		 jne	 SHORT $LN9@stbtt__cid
  00128	6a 00		 push	 0
  0012a	6a 00		 push	 0
  0012c	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	89 8d c4 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  00143	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00146	89 95 c8 fe ff
	ff		 mov	 DWORD PTR $T6[ebp+4], edx
  0014c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0014f	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T6[ebp+8], eax
$LN9@stbtt__cid:

; 1975 :    return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));

  00155	8b 45 a4	 mov	 eax, DWORD PTR _fdselector$[ebp]
  00158	50		 push	 eax
  00159	8b 4d 0c	 mov	 ecx, DWORD PTR _info$[ebp]
  0015c	83 c1 64	 add	 ecx, 100		; 00000064H
  0015f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00162	8b d4		 mov	 edx, esp
  00164	8b 01		 mov	 eax, DWORD PTR [ecx]
  00166	89 02		 mov	 DWORD PTR [edx], eax
  00168	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0016b	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0016e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00171	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00174	8d 95 74 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0017a	52		 push	 edx
  0017b	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  00180	83 c4 14	 add	 esp, 20			; 00000014H
  00183	8b 08		 mov	 ecx, DWORD PTR [eax]
  00185	89 8d 88 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  0018b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0018e	89 95 8c fe ff
	ff		 mov	 DWORD PTR $T3[ebp+4], edx
  00194	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00197	89 85 90 fe ff
	ff		 mov	 DWORD PTR $T3[ebp+8], eax
  0019d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001a0	8b cc		 mov	 ecx, esp
  001a2	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  001a8	89 11		 mov	 DWORD PTR [ecx], edx
  001aa	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp+4]
  001b0	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001b3	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp+8]
  001b9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  001bc	8b 45 0c	 mov	 eax, DWORD PTR _info$[ebp]
  001bf	83 c0 34	 add	 eax, 52			; 00000034H
  001c2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c5	8b cc		 mov	 ecx, esp
  001c7	8b 10		 mov	 edx, DWORD PTR [eax]
  001c9	89 11		 mov	 DWORD PTR [ecx], edx
  001cb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ce	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001d1	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001d4	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  001d7	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
  001e3	83 c4 1c	 add	 esp, 28			; 0000001cH
  001e6	8b 10		 mov	 edx, DWORD PTR [eax]
  001e8	89 95 9c fe ff
	ff		 mov	 DWORD PTR $T4[ebp], edx
  001ee	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001f1	89 8d a0 fe ff
	ff		 mov	 DWORD PTR $T4[ebp+4], ecx
  001f7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001fa	89 95 a4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp+8], edx
  00200	8b 45 08	 mov	 eax, DWORD PTR $T7[ebp]
  00203	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  00209	89 08		 mov	 DWORD PTR [eax], ecx
  0020b	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+4]
  00211	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00214	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp+8]
  0021a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0021d	8b 45 08	 mov	 eax, DWORD PTR $T7[ebp]

; 1976 : }

  00220	52		 push	 edx
  00221	8b cd		 mov	 ecx, ebp
  00223	50		 push	 eax
  00224	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@stbtt__cid
  0022a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0022f	58		 pop	 eax
  00230	5a		 pop	 edx
  00231	5f		 pop	 edi
  00232	5e		 pop	 esi
  00233	5b		 pop	 ebx
  00234	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00237	33 cd		 xor	 ecx, ebp
  00239	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023e	81 c4 a4 01 00
	00		 add	 esp, 420		; 000001a4H
  00244	3b ec		 cmp	 ebp, esp
  00246	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
  0024f	90		 npad	 1
$LN13@stbtt__cid:
  00250	01 00 00 00	 DD	 1
  00254	00 00 00 00	 DD	 $LN12@stbtt__cid
$LN12@stbtt__cid:
  00258	ec ff ff ff	 DD	 -20			; ffffffecH
  0025c	0c 00 00 00	 DD	 12			; 0000000cH
  00260	00 00 00 00	 DD	 $LN11@stbtt__cid
$LN11@stbtt__cid:
  00264	66		 DB	 102			; 00000066H
  00265	64		 DB	 100			; 00000064H
  00266	73		 DB	 115			; 00000073H
  00267	65		 DB	 101			; 00000065H
  00268	6c		 DB	 108			; 0000006cH
  00269	65		 DB	 101			; 00000065H
  0026a	63		 DB	 99			; 00000063H
  0026b	74		 DB	 116			; 00000074H
  0026c	00		 DB	 0
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PBUstbtt_fontinfo@@H@Z ENDP ; stbtt__cid_get_glyph_subrs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
_TEXT	SEGMENT
$T1 = -292						; size = 12
$T2 = -272						; size = 12
$T3 = -252						; size = 12
$T4 = -232						; size = 12
_bias$ = -20						; size = 4
_count$ = -8						; size = 4
$T5 = 8							; size = 4
_idx$ = 12						; size = 12
_n$ = 24						; size = 4
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z PROC		; stbtt__get_subr, COMDAT

; 1937 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00012	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1938 :    int count = stbtt__cff_index_count(&idx);

  00028	8d 45 0c	 lea	 eax, DWORD PTR _idx$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?stbtt__cff_index_count@@YAHPAUstbtt__buf@@@Z ; stbtt__cff_index_count
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 1939 :    int bias = 107;

  00037	c7 45 ec 6b 00
	00 00		 mov	 DWORD PTR _bias$[ebp], 107 ; 0000006bH

; 1940 :    if (count >= 33900)

  0003e	81 7d f8 6c 84
	00 00		 cmp	 DWORD PTR _count$[ebp], 33900 ; 0000846cH
  00045	7c 09		 jl	 SHORT $LN2@stbtt__get

; 1941 :       bias = 32768;

  00047	c7 45 ec 00 80
	00 00		 mov	 DWORD PTR _bias$[ebp], 32768 ; 00008000H
  0004e	eb 10		 jmp	 SHORT $LN3@stbtt__get
$LN2@stbtt__get:

; 1942 :    else if (count >= 1240)

  00050	81 7d f8 d8 04
	00 00		 cmp	 DWORD PTR _count$[ebp], 1240 ; 000004d8H
  00057	7c 07		 jl	 SHORT $LN3@stbtt__get

; 1943 :       bias = 1131;

  00059	c7 45 ec 6b 04
	00 00		 mov	 DWORD PTR _bias$[ebp], 1131 ; 0000046bH
$LN3@stbtt__get:

; 1944 :    n += bias;

  00060	8b 45 18	 mov	 eax, DWORD PTR _n$[ebp]
  00063	03 45 ec	 add	 eax, DWORD PTR _bias$[ebp]
  00066	89 45 18	 mov	 DWORD PTR _n$[ebp], eax

; 1945 :    if (n < 0 || n >= count)

  00069	78 08		 js	 SHORT $LN6@stbtt__get
  0006b	8b 45 18	 mov	 eax, DWORD PTR _n$[ebp]
  0006e	3b 45 f8	 cmp	 eax, DWORD PTR _count$[ebp]
  00071	7c 4f		 jl	 SHORT $LN5@stbtt__get
$LN6@stbtt__get:

; 1946 :       return stbtt__new_buf(NULL, 0);

  00073	6a 00		 push	 0
  00075	6a 00		 push	 0
  00077	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	89 8d 18 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  0008e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00091	89 95 1c ff ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  00097	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0009a	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T4[ebp+8], eax
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR $T5[ebp]
  000a3	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  000a9	89 11		 mov	 DWORD PTR [ecx], edx
  000ab	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+4]
  000b1	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000b4	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+8]
  000ba	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000bd	8b 45 08	 mov	 eax, DWORD PTR $T5[ebp]
  000c0	eb 63		 jmp	 SHORT $LN1@stbtt__get
$LN5@stbtt__get:

; 1947 :    return stbtt__cff_index_get(idx, n);

  000c2	8b 45 18	 mov	 eax, DWORD PTR _n$[ebp]
  000c5	50		 push	 eax
  000c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c9	8b cc		 mov	 ecx, esp
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _idx$[ebp]
  000ce	89 11		 mov	 DWORD PTR [ecx], edx
  000d0	8b 45 10	 mov	 eax, DWORD PTR _idx$[ebp+4]
  000d3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000d6	8b 55 14	 mov	 edx, DWORD PTR _idx$[ebp+8]
  000d9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000dc	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  000e8	83 c4 14	 add	 esp, 20			; 00000014H
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	89 8d f0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  000f3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f6	89 95 f4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  000fc	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ff	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+8], eax
  00105	8b 4d 08	 mov	 ecx, DWORD PTR $T5[ebp]
  00108	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  0010e	89 11		 mov	 DWORD PTR [ecx], edx
  00110	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+4]
  00116	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00119	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+8]
  0011f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00122	8b 45 08	 mov	 eax, DWORD PTR $T5[ebp]
$LN1@stbtt__get:

; 1948 : }

  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx
  00128	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  0012e	3b ec		 cmp	 ebp, esp
  00130	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ENDP		; stbtt__get_subr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z
_TEXT	SEGMENT
_cy2$ = -44						; size = 4
_cx2$ = -32						; size = 4
_cy1$ = -20						; size = 4
_cx1$ = -8						; size = 4
_ctx$ = 8						; size = 4
_dx1$ = 12						; size = 4
_dy1$ = 16						; size = 4
_dx2$ = 20						; size = 4
_dy2$ = 24						; size = 4
_dx3$ = 28						; size = 4
_dy3$ = 32						; size = 4
?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z PROC ; stbtt__csctx_rccurve_to, COMDAT

; 1926 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1927 :    float cx1 = ctx->x + dx1;

  00028	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0002b	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00030	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _dx1$[ebp]
  00035	f3 0f 11 45 f8	 movss	 DWORD PTR _cx1$[ebp], xmm0

; 1928 :    float cy1 = ctx->y + dy1;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0003d	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00042	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _dy1$[ebp]
  00047	f3 0f 11 45 ec	 movss	 DWORD PTR _cy1$[ebp], xmm0

; 1929 :    float cx2 = cx1 + dx2;

  0004c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _cx1$[ebp]
  00051	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _dx2$[ebp]
  00056	f3 0f 11 45 e0	 movss	 DWORD PTR _cx2$[ebp], xmm0

; 1930 :    float cy2 = cy1 + dy2;

  0005b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _cy1$[ebp]
  00060	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _dy2$[ebp]
  00065	f3 0f 11 45 d4	 movss	 DWORD PTR _cy2$[ebp], xmm0

; 1931 :    ctx->x = cx2 + dx3;

  0006a	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _cx2$[ebp]
  0006f	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _dx3$[ebp]
  00074	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  00077	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 1932 :    ctx->y = cy2 + dy3;

  0007c	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _cy2$[ebp]
  00081	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR _dy3$[ebp]
  00086	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  00089	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 1933 :    stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

  0008e	f3 0f 2c 45 d4	 cvttss2si eax, DWORD PTR _cy2$[ebp]
  00093	50		 push	 eax
  00094	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _cx2$[ebp]
  00099	51		 push	 ecx
  0009a	f3 0f 2c 55 ec	 cvttss2si edx, DWORD PTR _cy1$[ebp]
  0009f	52		 push	 edx
  000a0	f3 0f 2c 45 f8	 cvttss2si eax, DWORD PTR _cx1$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000a9	f3 0f 2c 51 14	 cvttss2si edx, DWORD PTR [ecx+20]
  000ae	52		 push	 edx
  000af	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  000b2	f3 0f 2c 48 10	 cvttss2si ecx, DWORD PTR [eax+16]
  000b7	51		 push	 ecx
  000b8	6a 04		 push	 4
  000ba	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
  000c3	83 c4 20	 add	 esp, 32			; 00000020H

; 1934 : }

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000cf	3b ec		 cmp	 ebp, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ENDP ; stbtt__csctx_rccurve_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rline_to, COMDAT

; 1919 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1920 :    ctx->x += dx;

  00028	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0002b	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00030	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _dx$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00038	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0

; 1921 :    ctx->y += dy;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  00040	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00045	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _dy$[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0004d	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 1922 :    stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0005d	f3 0f 2c 48 14	 cvttss2si ecx, DWORD PTR [eax+20]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  00066	f3 0f 2c 42 10	 cvttss2si eax, DWORD PTR [edx+16]
  0006b	50		 push	 eax
  0006c	6a 02		 push	 2
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
  00077	83 c4 20	 add	 esp, 32			; 00000020H

; 1923 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rline_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z
_TEXT	SEGMENT
tv72 = -196						; size = 4
tv68 = -196						; size = 4
_ctx$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rmove_to, COMDAT

; 1911 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1912 :    stbtt__csctx_close_shape(ctx);

  00028	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape
  00031	83 c4 04	 add	 esp, 4

; 1913 :    ctx->first_x = ctx->x = ctx->x + dx;

  00034	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  00037	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0003c	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR _dx$[ebp]
  00041	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv68[ebp], xmm0
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0004c	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv68[ebp]
  00054	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0
  00059	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  0005c	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv68[ebp]
  00064	f3 0f 11 42 08	 movss	 DWORD PTR [edx+8], xmm0

; 1914 :    ctx->first_y = ctx->y = ctx->y + dy;

  00069	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0006c	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00071	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _dy$[ebp]
  00076	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv72[ebp], xmm0
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00081	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv72[ebp]
  00089	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0
  0008e	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  00091	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv72[ebp]
  00099	f3 0f 11 42 0c	 movss	 DWORD PTR [edx+12], xmm0

; 1915 :    stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

  0009e	6a 00		 push	 0
  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	6a 00		 push	 0
  000a6	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  000a9	f3 0f 2c 48 14	 cvttss2si ecx, DWORD PTR [eax+20]
  000ae	51		 push	 ecx
  000af	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  000b2	f3 0f 2c 42 10	 cvttss2si eax, DWORD PTR [edx+16]
  000b7	50		 push	 eax
  000b8	6a 01		 push	 1
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
  000c3	83 c4 20	 add	 esp, 32			; 00000020H

; 1916 : }

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  000cf	3b ec		 cmp	 ebp, esp
  000d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rmove_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z PROC	; stbtt__csctx_close_shape, COMDAT

; 1905 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1906 :    if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)

  00028	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0002e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00033	0f 2e 41 10	 ucomiss xmm0, DWORD PTR [ecx+16]
  00037	9f		 lahf
  00038	f6 c4 44	 test	 ah, 68			; 00000044H
  0003b	7a 15		 jp	 SHORT $LN3@stbtt__csc
  0003d	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00043	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00048	0f 2e 41 14	 ucomiss xmm0, DWORD PTR [ecx+20]
  0004c	9f		 lahf
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7b 28		 jnp	 SHORT $LN2@stbtt__csc
$LN3@stbtt__csc:

; 1907 :       stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);

  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0005d	f3 0f 2c 48 0c	 cvttss2si ecx, DWORD PTR [eax+12]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  00066	f3 0f 2c 42 08	 cvttss2si eax, DWORD PTR [edx+8]
  0006b	50		 push	 eax
  0006c	6a 02		 push	 2
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
  00077	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@stbtt__csc:

; 1908 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z ENDP	; stbtt__csctx_close_shape
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
_type$ = 12						; size = 1
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_cx$ = 24						; size = 4
_cy$ = 28						; size = 4
_cx1$ = 32						; size = 4
_cy1$ = 36						; size = 4
?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z PROC	; stbtt__csctx_v, COMDAT

; 1889 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1890 :    if (c->bounds) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	74 47		 je	 SHORT $LN2@stbtt__csc

; 1891 :       stbtt__track_vertex(c, x, y);

  00030	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 10	 mov	 ecx, DWORD PTR _x$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ; stbtt__track_vertex
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1892 :       if (type == STBTT_vcubic) {

  00044	0f b6 45 0c	 movzx	 eax, BYTE PTR _type$[ebp]
  00048	83 f8 04	 cmp	 eax, 4
  0004b	75 28		 jne	 SHORT $LN4@stbtt__csc

; 1893 :          stbtt__track_vertex(c, cx, cy);

  0004d	8b 45 1c	 mov	 eax, DWORD PTR _cy$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 18	 mov	 ecx, DWORD PTR _cx$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 ?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ; stbtt__track_vertex
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1894 :          stbtt__track_vertex(c, cx1, cy1);

  00061	8b 45 24	 mov	 eax, DWORD PTR _cy1$[ebp]
  00064	50		 push	 eax
  00065	8b 4d 20	 mov	 ecx, DWORD PTR _cx1$[ebp]
  00068	51		 push	 ecx
  00069	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 ?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ; stbtt__track_vertex
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@stbtt__csc:

; 1895 :       }
; 1896 :    } else {

  00075	eb 57		 jmp	 SHORT $LN3@stbtt__csc
$LN2@stbtt__csc:

; 1897 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

  00077	8b 45 1c	 mov	 eax, DWORD PTR _cy$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d 18	 mov	 ecx, DWORD PTR _cx$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  00082	52		 push	 edx
  00083	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00086	50		 push	 eax
  00087	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _type$[ebp]
  0008b	51		 push	 ecx
  0008c	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0008f	6b 42 2c 0e	 imul	 eax, DWORD PTR [edx+44], 14
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00096	03 41 28	 add	 eax, DWORD PTR [ecx+40]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  0009f	83 c4 18	 add	 esp, 24			; 00000018H

; 1898 :       c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;

  000a2	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000a5	6b 48 2c 0e	 imul	 ecx, DWORD PTR [eax+44], 14
  000a9	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000ac	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000af	66 8b 55 20	 mov	 dx, WORD PTR _cx1$[ebp]
  000b3	66 89 54 08 08	 mov	 WORD PTR [eax+ecx+8], dx

; 1899 :       c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;

  000b8	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000bb	6b 48 2c 0e	 imul	 ecx, DWORD PTR [eax+44], 14
  000bf	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000c2	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000c5	66 8b 55 24	 mov	 dx, WORD PTR _cy1$[ebp]
  000c9	66 89 54 08 0a	 mov	 WORD PTR [eax+ecx+10], dx
$LN3@stbtt__csc:

; 1900 :    }
; 1901 :    c->num_vertices++;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000d1	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000d4	83 c1 01	 add	 ecx, 1
  000d7	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  000da	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 1902 : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ENDP	; stbtt__csctx_v
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z PROC	; stbtt__track_vertex, COMDAT

; 1880 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1881 :    if (x > c->max_x || !c->started) c->max_x = x;

  00028	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0002e	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00031	7f 09		 jg	 SHORT $LN3@stbtt__tra
  00033	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00036	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003a	75 09		 jne	 SHORT $LN2@stbtt__tra
$LN3@stbtt__tra:
  0003c	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00042	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
$LN2@stbtt__tra:

; 1882 :    if (y > c->max_y || !c->started) c->max_y = y;

  00045	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00048	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0004b	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  0004e	7f 09		 jg	 SHORT $LN5@stbtt__tra
  00050	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00053	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00057	75 09		 jne	 SHORT $LN4@stbtt__tra
$LN5@stbtt__tra:
  00059	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  0005f	89 48 24	 mov	 DWORD PTR [eax+36], ecx
$LN4@stbtt__tra:

; 1883 :    if (x < c->min_x || !c->started) c->min_x = x;

  00062	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00068	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0006b	7c 09		 jl	 SHORT $LN7@stbtt__tra
  0006d	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00070	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00074	75 09		 jne	 SHORT $LN6@stbtt__tra
$LN7@stbtt__tra:
  00076	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00079	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0007c	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN6@stbtt__tra:

; 1884 :    if (y < c->min_y || !c->started) c->min_y = y;

  0007f	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00082	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00085	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00088	7c 09		 jl	 SHORT $LN9@stbtt__tra
  0008a	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0008d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00091	75 09		 jne	 SHORT $LN8@stbtt__tra
$LN9@stbtt__tra:
  00093	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00096	8b 4d 10	 mov	 ecx, DWORD PTR _y$[ebp]
  00099	89 48 20	 mov	 DWORD PTR [eax+32], ecx
$LN8@stbtt__tra:

; 1885 :    c->started = 1;

  0009c	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0009f	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 1886 : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ENDP	; stbtt__track_vertex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z
_TEXT	SEGMENT
tv457 = -916						; size = 4
tv386 = -916						; size = 4
tv376 = -916						; size = 4
tv365 = -916						; size = 4
tv340 = -916						; size = 4
tv293 = -916						; size = 4
tv208 = -916						; size = 4
tv170 = -916						; size = 4
_y$1 = -524						; size = 2
_x$2 = -512						; size = 2
_v$3 = -500						; size = 4
_n$4 = -488						; size = 4
_m$5 = -476						; size = 4
_mtx$6 = -464						; size = 24
_tmp$7 = -432						; size = 4
_comp_verts$8 = -420					; size = 4
_i$9 = -408						; size = 4
_comp_num_verts$10 = -396				; size = 4
_gidx$11 = -384						; size = 2
_flags$12 = -372					; size = 2
_comp$13 = -360						; size = 4
_more$14 = -348						; size = 4
_dy$15 = -336						; size = 2
_dx$16 = -324						; size = 2
_points$17 = -312					; size = 4
_scy$18 = -300						; size = 4
_scx$19 = -288						; size = 4
_sy$20 = -276						; size = 4
_sx$21 = -264						; size = 4
_cy$22 = -252						; size = 4
_cx$23 = -240						; size = 4
_y$24 = -228						; size = 4
_x$25 = -216						; size = 4
_start_off$26 = -204					; size = 4
_off$27 = -192						; size = 4
_was_off$28 = -180					; size = 4
_next_move$29 = -168					; size = 4
_n$30 = -156						; size = 4
_m$31 = -144						; size = 4
_j$32 = -132						; size = 4
_i$33 = -120						; size = 4
_ins$34 = -108						; size = 4
_flagcount$35 = -93					; size = 1
_flags$36 = -81						; size = 1
_g$ = -72						; size = 4
_num_vertices$ = -60					; size = 4
_vertices$ = -48					; size = 4
_data$ = -36						; size = 4
_endPtsOfContours$ = -24				; size = 4
_numberOfContours$ = -12				; size = 2
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_pvertices$ = 16					; size = 4
?stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeTT, COMDAT

; 1640 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 03 00
	00		 sub	 esp, 916		; 00000394H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fc ff
	ff		 lea	 edi, DWORD PTR [ebp-916]
  00012	b9 e5 00 00 00	 mov	 ecx, 229		; 000000e5H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1641 :    stbtt_int16 numberOfContours;
; 1642 :    stbtt_uint8 *endPtsOfContours;
; 1643 :    stbtt_uint8 *data = info->data;

  00032	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	89 4d dc	 mov	 DWORD PTR _data$[ebp], ecx

; 1644 :    stbtt_vertex *vertices=0;

  0003b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _vertices$[ebp], 0

; 1645 :    int num_vertices=0;

  00042	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _num_vertices$[ebp], 0

; 1646 :    int g = stbtt__GetGlyfOffset(info, glyph_index);

  00049	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 b8	 mov	 DWORD PTR _g$[ebp], eax

; 1647 : 
; 1648 :    *pvertices = NULL;

  0005c	8b 45 10	 mov	 eax, DWORD PTR _pvertices$[ebp]
  0005f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1649 : 
; 1650 :    if (g < 0) return 0;

  00065	83 7d b8 00	 cmp	 DWORD PTR _g$[ebp], 0
  00069	7d 07		 jge	 SHORT $LN19@stbtt__Get
  0006b	33 c0		 xor	 eax, eax
  0006d	e9 43 10 00 00	 jmp	 $LN1@stbtt__Get
$LN19@stbtt__Get:

; 1651 : 
; 1652 :    numberOfContours = ttSHORT(data + g);

  00072	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  00075	03 45 b8	 add	 eax, DWORD PTR _g$[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0007e	83 c4 04	 add	 esp, 4
  00081	66 89 45 f4	 mov	 WORD PTR _numberOfContours$[ebp], ax

; 1653 : 
; 1654 :    if (numberOfContours > 0) {

  00085	0f bf 45 f4	 movsx	 eax, WORD PTR _numberOfContours$[ebp]
  00089	85 c0		 test	 eax, eax
  0008b	0f 8e a0 07 00
	00		 jle	 $LN20@stbtt__Get

; 1655 :       stbtt_uint8 flags=0,flagcount;

  00091	c6 45 af 00	 mov	 BYTE PTR _flags$36[ebp], 0

; 1656 :       stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;

  00095	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$32[ebp], 0
  0009f	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _was_off$28[ebp], 0
  000a9	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _start_off$26[ebp], 0

; 1657 :       stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
; 1658 :       stbtt_uint8 *points;
; 1659 :       endPtsOfContours = (data + g + 10);

  000b3	8b 45 b8	 mov	 eax, DWORD PTR _g$[ebp]
  000b6	8b 4d dc	 mov	 ecx, DWORD PTR _data$[ebp]
  000b9	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  000bd	89 55 e8	 mov	 DWORD PTR _endPtsOfContours$[ebp], edx

; 1660 :       ins = ttUSHORT(data + g + 10 + numberOfContours * 2);

  000c0	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  000c3	03 45 b8	 add	 eax, DWORD PTR _g$[ebp]
  000c6	0f bf 4d f4	 movsx	 ecx, WORD PTR _numberOfContours$[ebp]
  000ca	8d 54 48 0a	 lea	 edx, DWORD PTR [eax+ecx*2+10]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  000d4	83 c4 04	 add	 esp, 4
  000d7	0f b7 c0	 movzx	 eax, ax
  000da	89 45 94	 mov	 DWORD PTR _ins$34[ebp], eax

; 1661 :       points = data + g + 10 + numberOfContours * 2 + 2 + ins;

  000dd	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  000e0	03 45 b8	 add	 eax, DWORD PTR _g$[ebp]
  000e3	0f bf 4d f4	 movsx	 ecx, WORD PTR _numberOfContours$[ebp]
  000e7	03 45 94	 add	 eax, DWORD PTR _ins$34[ebp]
  000ea	8d 54 48 0c	 lea	 edx, DWORD PTR [eax+ecx*2+12]
  000ee	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _points$17[ebp], edx

; 1662 : 
; 1663 :       n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

  000f4	0f bf 45 f4	 movsx	 eax, WORD PTR _numberOfContours$[ebp]
  000f8	8b 4d e8	 mov	 ecx, DWORD PTR _endPtsOfContours$[ebp]
  000fb	8d 54 41 fe	 lea	 edx, DWORD PTR [ecx+eax*2-2]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00105	83 c4 04	 add	 esp, 4
  00108	0f b7 c0	 movzx	 eax, ax
  0010b	83 c0 01	 add	 eax, 1
  0010e	89 85 64 ff ff
	ff		 mov	 DWORD PTR _n$30[ebp], eax

; 1664 : 
; 1665 :       m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need

  00114	0f bf 45 f4	 movsx	 eax, WORD PTR _numberOfContours$[ebp]
  00118	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _n$30[ebp]
  0011e	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00121	89 95 70 ff ff
	ff		 mov	 DWORD PTR _m$31[ebp], edx

; 1666 :       vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);

  00127	6b 85 70 ff ff
	ff 0e		 imul	 eax, DWORD PTR _m$31[ebp], 14
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00134	83 c4 04	 add	 esp, 4
  00137	89 45 d0	 mov	 DWORD PTR _vertices$[ebp], eax

; 1667 :       if (vertices == 0)

  0013a	83 7d d0 00	 cmp	 DWORD PTR _vertices$[ebp], 0
  0013e	75 07		 jne	 SHORT $LN22@stbtt__Get

; 1668 :          return 0;

  00140	33 c0		 xor	 eax, eax
  00142	e9 6e 0f 00 00	 jmp	 $LN1@stbtt__Get
$LN22@stbtt__Get:

; 1669 : 
; 1670 :       next_move = 0;

  00147	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _next_move$29[ebp], 0

; 1671 :       flagcount=0;

  00151	c6 45 a3 00	 mov	 BYTE PTR _flagcount$35[ebp], 0

; 1672 : 
; 1673 :       // in first pass, we load uninterpreted data into the allocated array
; 1674 :       // above, shifted to the end of the array so we won't overwrite it when
; 1675 :       // we create our final data starting from the front
; 1676 : 
; 1677 :       off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

  00155	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _m$31[ebp]
  0015b	2b 85 64 ff ff
	ff		 sub	 eax, DWORD PTR _n$30[ebp]
  00161	89 85 40 ff ff
	ff		 mov	 DWORD PTR _off$27[ebp], eax

; 1678 : 
; 1679 :       // first load flags
; 1680 : 
; 1681 :       for (i=0; i < n; ++i) {

  00167	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _i$33[ebp], 0
  0016e	eb 09		 jmp	 SHORT $LN4@stbtt__Get
$LN2@stbtt__Get:
  00170	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  00173	83 c0 01	 add	 eax, 1
  00176	89 45 88	 mov	 DWORD PTR _i$33[ebp], eax
$LN4@stbtt__Get:
  00179	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  0017c	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _n$30[ebp]
  00182	7d 67		 jge	 SHORT $LN3@stbtt__Get

; 1682 :          if (flagcount == 0) {

  00184	0f b6 45 a3	 movzx	 eax, BYTE PTR _flagcount$35[ebp]
  00188	85 c0		 test	 eax, eax
  0018a	75 3f		 jne	 SHORT $LN23@stbtt__Get

; 1683 :             flags = *points++;

  0018c	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _points$17[ebp]
  00192	8a 08		 mov	 cl, BYTE PTR [eax]
  00194	88 4d af	 mov	 BYTE PTR _flags$36[ebp], cl
  00197	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  0019d	83 c2 01	 add	 edx, 1
  001a0	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _points$17[ebp], edx

; 1684 :             if (flags & 8)

  001a6	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  001aa	83 e0 08	 and	 eax, 8
  001ad	74 1a		 je	 SHORT $LN25@stbtt__Get

; 1685 :                flagcount = *points++;

  001af	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _points$17[ebp]
  001b5	8a 08		 mov	 cl, BYTE PTR [eax]
  001b7	88 4d a3	 mov	 BYTE PTR _flagcount$35[ebp], cl
  001ba	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  001c0	83 c2 01	 add	 edx, 1
  001c3	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _points$17[ebp], edx
$LN25@stbtt__Get:

; 1686 :          } else

  001c9	eb 08		 jmp	 SHORT $LN24@stbtt__Get
$LN23@stbtt__Get:

; 1687 :             --flagcount;

  001cb	8a 45 a3	 mov	 al, BYTE PTR _flagcount$35[ebp]
  001ce	2c 01		 sub	 al, 1
  001d0	88 45 a3	 mov	 BYTE PTR _flagcount$35[ebp], al
$LN24@stbtt__Get:

; 1688 :          vertices[off+i].type = flags;

  001d3	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  001d9	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  001dc	6b c8 0e	 imul	 ecx, eax, 14
  001df	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  001e2	8a 45 af	 mov	 al, BYTE PTR _flags$36[ebp]
  001e5	88 44 0a 0c	 mov	 BYTE PTR [edx+ecx+12], al

; 1689 :       }

  001e9	eb 85		 jmp	 SHORT $LN2@stbtt__Get
$LN3@stbtt__Get:

; 1690 : 
; 1691 :       // now load x coordinates
; 1692 :       x=0;

  001eb	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$25[ebp], 0

; 1693 :       for (i=0; i < n; ++i) {

  001f5	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _i$33[ebp], 0
  001fc	eb 09		 jmp	 SHORT $LN7@stbtt__Get
$LN5@stbtt__Get:
  001fe	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  00201	83 c0 01	 add	 eax, 1
  00204	89 45 88	 mov	 DWORD PTR _i$33[ebp], eax
$LN7@stbtt__Get:
  00207	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  0020a	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _n$30[ebp]
  00210	0f 8d e9 00 00
	00		 jge	 $LN6@stbtt__Get

; 1694 :          flags = vertices[off+i].type;

  00216	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  0021c	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  0021f	6b c8 0e	 imul	 ecx, eax, 14
  00222	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  00225	8a 44 0a 0c	 mov	 al, BYTE PTR [edx+ecx+12]
  00229	88 45 af	 mov	 BYTE PTR _flags$36[ebp], al

; 1695 :          if (flags & 2) {

  0022c	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  00230	83 e0 02	 and	 eax, 2
  00233	74 5b		 je	 SHORT $LN26@stbtt__Get

; 1696 :             stbtt_int16 dx = *points++;

  00235	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _points$17[ebp]
  0023b	66 0f b6 08	 movzx	 cx, BYTE PTR [eax]
  0023f	66 89 8d bc fe
	ff ff		 mov	 WORD PTR _dx$16[ebp], cx
  00246	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  0024c	83 c2 01	 add	 edx, 1
  0024f	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _points$17[ebp], edx

; 1697 :             x += (flags & 16) ? dx : -dx; // ???

  00255	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  00259	83 e0 10	 and	 eax, 16			; 00000010H
  0025c	74 0f		 je	 SHORT $LN64@stbtt__Get
  0025e	0f bf 8d bc fe
	ff ff		 movsx	 ecx, WORD PTR _dx$16[ebp]
  00265	89 8d 6c fc ff
	ff		 mov	 DWORD PTR tv170[ebp], ecx
  0026b	eb 0f		 jmp	 SHORT $LN65@stbtt__Get
$LN64@stbtt__Get:
  0026d	0f bf 95 bc fe
	ff ff		 movsx	 edx, WORD PTR _dx$16[ebp]
  00274	f7 da		 neg	 edx
  00276	89 95 6c fc ff
	ff		 mov	 DWORD PTR tv170[ebp], edx
$LN65@stbtt__Get:
  0027c	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$25[ebp]
  00282	03 85 6c fc ff
	ff		 add	 eax, DWORD PTR tv170[ebp]
  00288	89 85 28 ff ff
	ff		 mov	 DWORD PTR _x$25[ebp], eax

; 1698 :          } else {

  0028e	eb 50		 jmp	 SHORT $LN28@stbtt__Get
$LN26@stbtt__Get:

; 1699 :             if (!(flags & 16)) {

  00290	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  00294	83 e0 10	 and	 eax, 16			; 00000010H
  00297	75 47		 jne	 SHORT $LN28@stbtt__Get

; 1700 :                x = x + (stbtt_int16) (points[0]*256 + points[1]);

  00299	b8 01 00 00 00	 mov	 eax, 1
  0029e	6b c8 00	 imul	 ecx, eax, 0
  002a1	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  002a7	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  002ab	c1 e0 08	 shl	 eax, 8
  002ae	b9 01 00 00 00	 mov	 ecx, 1
  002b3	c1 e1 00	 shl	 ecx, 0
  002b6	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  002bc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  002c0	03 c1		 add	 eax, ecx
  002c2	0f bf d0	 movsx	 edx, ax
  002c5	03 95 28 ff ff
	ff		 add	 edx, DWORD PTR _x$25[ebp]
  002cb	89 95 28 ff ff
	ff		 mov	 DWORD PTR _x$25[ebp], edx

; 1701 :                points += 2;

  002d1	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _points$17[ebp]
  002d7	83 c0 02	 add	 eax, 2
  002da	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _points$17[ebp], eax
$LN28@stbtt__Get:

; 1702 :             }
; 1703 :          }
; 1704 :          vertices[off+i].x = (stbtt_int16) x;

  002e0	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  002e6	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  002e9	6b c8 0e	 imul	 ecx, eax, 14
  002ec	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  002ef	66 8b 85 28 ff
	ff ff		 mov	 ax, WORD PTR _x$25[ebp]
  002f6	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 1705 :       }

  002fa	e9 ff fe ff ff	 jmp	 $LN5@stbtt__Get
$LN6@stbtt__Get:

; 1706 : 
; 1707 :       // now load y coordinates
; 1708 :       y=0;

  002ff	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _y$24[ebp], 0

; 1709 :       for (i=0; i < n; ++i) {

  00309	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _i$33[ebp], 0
  00310	eb 09		 jmp	 SHORT $LN10@stbtt__Get
$LN8@stbtt__Get:
  00312	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  00315	83 c0 01	 add	 eax, 1
  00318	89 45 88	 mov	 DWORD PTR _i$33[ebp], eax
$LN10@stbtt__Get:
  0031b	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  0031e	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _n$30[ebp]
  00324	0f 8d ea 00 00
	00		 jge	 $LN9@stbtt__Get

; 1710 :          flags = vertices[off+i].type;

  0032a	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  00330	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  00333	6b c8 0e	 imul	 ecx, eax, 14
  00336	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  00339	8a 44 0a 0c	 mov	 al, BYTE PTR [edx+ecx+12]
  0033d	88 45 af	 mov	 BYTE PTR _flags$36[ebp], al

; 1711 :          if (flags & 4) {

  00340	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  00344	83 e0 04	 and	 eax, 4
  00347	74 5b		 je	 SHORT $LN29@stbtt__Get

; 1712 :             stbtt_int16 dy = *points++;

  00349	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _points$17[ebp]
  0034f	66 0f b6 08	 movzx	 cx, BYTE PTR [eax]
  00353	66 89 8d b0 fe
	ff ff		 mov	 WORD PTR _dy$15[ebp], cx
  0035a	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  00360	83 c2 01	 add	 edx, 1
  00363	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _points$17[ebp], edx

; 1713 :             y += (flags & 32) ? dy : -dy; // ???

  00369	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  0036d	83 e0 20	 and	 eax, 32			; 00000020H
  00370	74 0f		 je	 SHORT $LN66@stbtt__Get
  00372	0f bf 8d b0 fe
	ff ff		 movsx	 ecx, WORD PTR _dy$15[ebp]
  00379	89 8d 6c fc ff
	ff		 mov	 DWORD PTR tv208[ebp], ecx
  0037f	eb 0f		 jmp	 SHORT $LN67@stbtt__Get
$LN66@stbtt__Get:
  00381	0f bf 95 b0 fe
	ff ff		 movsx	 edx, WORD PTR _dy$15[ebp]
  00388	f7 da		 neg	 edx
  0038a	89 95 6c fc ff
	ff		 mov	 DWORD PTR tv208[ebp], edx
$LN67@stbtt__Get:
  00390	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _y$24[ebp]
  00396	03 85 6c fc ff
	ff		 add	 eax, DWORD PTR tv208[ebp]
  0039c	89 85 1c ff ff
	ff		 mov	 DWORD PTR _y$24[ebp], eax

; 1714 :          } else {

  003a2	eb 50		 jmp	 SHORT $LN31@stbtt__Get
$LN29@stbtt__Get:

; 1715 :             if (!(flags & 32)) {

  003a4	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  003a8	83 e0 20	 and	 eax, 32			; 00000020H
  003ab	75 47		 jne	 SHORT $LN31@stbtt__Get

; 1716 :                y = y + (stbtt_int16) (points[0]*256 + points[1]);

  003ad	b8 01 00 00 00	 mov	 eax, 1
  003b2	6b c8 00	 imul	 ecx, eax, 0
  003b5	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  003bb	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  003bf	c1 e0 08	 shl	 eax, 8
  003c2	b9 01 00 00 00	 mov	 ecx, 1
  003c7	c1 e1 00	 shl	 ecx, 0
  003ca	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _points$17[ebp]
  003d0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  003d4	03 c1		 add	 eax, ecx
  003d6	0f bf d0	 movsx	 edx, ax
  003d9	03 95 1c ff ff
	ff		 add	 edx, DWORD PTR _y$24[ebp]
  003df	89 95 1c ff ff
	ff		 mov	 DWORD PTR _y$24[ebp], edx

; 1717 :                points += 2;

  003e5	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _points$17[ebp]
  003eb	83 c0 02	 add	 eax, 2
  003ee	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _points$17[ebp], eax
$LN31@stbtt__Get:

; 1718 :             }
; 1719 :          }
; 1720 :          vertices[off+i].y = (stbtt_int16) y;

  003f4	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  003fa	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  003fd	6b c8 0e	 imul	 ecx, eax, 14
  00400	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  00403	66 8b 85 1c ff
	ff ff		 mov	 ax, WORD PTR _y$24[ebp]
  0040a	66 89 44 0a 02	 mov	 WORD PTR [edx+ecx+2], ax

; 1721 :       }

  0040f	e9 fe fe ff ff	 jmp	 $LN8@stbtt__Get
$LN9@stbtt__Get:

; 1722 : 
; 1723 :       // now convert them to our format
; 1724 :       num_vertices=0;

  00414	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _num_vertices$[ebp], 0

; 1725 :       sx = sy = cx = cy = scx = scy = 0;

  0041b	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _scy$18[ebp], 0
  00425	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _scy$18[ebp]
  0042b	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _scx$19[ebp], eax
  00431	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _scx$19[ebp]
  00437	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _cy$22[ebp], ecx
  0043d	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy$22[ebp]
  00443	89 95 10 ff ff
	ff		 mov	 DWORD PTR _cx$23[ebp], edx
  00449	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _cx$23[ebp]
  0044f	89 85 ec fe ff
	ff		 mov	 DWORD PTR _sy$20[ebp], eax
  00455	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _sy$20[ebp]
  0045b	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _sx$21[ebp], ecx

; 1726 :       for (i=0; i < n; ++i) {

  00461	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _i$33[ebp], 0
  00468	eb 09		 jmp	 SHORT $LN13@stbtt__Get
$LN11@stbtt__Get:
  0046a	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  0046d	83 c0 01	 add	 eax, 1
  00470	89 45 88	 mov	 DWORD PTR _i$33[ebp], eax
$LN13@stbtt__Get:
  00473	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  00476	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _n$30[ebp]
  0047c	0f 8d 5f 03 00
	00		 jge	 $LN12@stbtt__Get

; 1727 :          flags = vertices[off+i].type;

  00482	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  00488	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  0048b	6b c8 0e	 imul	 ecx, eax, 14
  0048e	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  00491	8a 44 0a 0c	 mov	 al, BYTE PTR [edx+ecx+12]
  00495	88 45 af	 mov	 BYTE PTR _flags$36[ebp], al

; 1728 :          x     = (stbtt_int16) vertices[off+i].x;

  00498	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  0049e	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  004a1	6b c8 0e	 imul	 ecx, eax, 14
  004a4	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  004a7	0f bf 04 0a	 movsx	 eax, WORD PTR [edx+ecx]
  004ab	89 85 28 ff ff
	ff		 mov	 DWORD PTR _x$25[ebp], eax

; 1729 :          y     = (stbtt_int16) vertices[off+i].y;

  004b1	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _off$27[ebp]
  004b7	03 45 88	 add	 eax, DWORD PTR _i$33[ebp]
  004ba	6b c8 0e	 imul	 ecx, eax, 14
  004bd	8b 55 d0	 mov	 edx, DWORD PTR _vertices$[ebp]
  004c0	0f bf 44 0a 02	 movsx	 eax, WORD PTR [edx+ecx+2]
  004c5	89 85 1c ff ff
	ff		 mov	 DWORD PTR _y$24[ebp], eax

; 1730 : 
; 1731 :          if (next_move == i) {

  004cb	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _next_move$29[ebp]
  004d1	3b 45 88	 cmp	 eax, DWORD PTR _i$33[ebp]
  004d4	0f 85 e1 01 00
	00		 jne	 $LN32@stbtt__Get

; 1732 :             if (i != 0)

  004da	83 7d 88 00	 cmp	 DWORD PTR _i$33[ebp], 0
  004de	74 4b		 je	 SHORT $LN34@stbtt__Get

; 1733 :                num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

  004e0	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy$22[ebp]
  004e6	50		 push	 eax
  004e7	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _cx$23[ebp]
  004ed	51		 push	 ecx
  004ee	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _scy$18[ebp]
  004f4	52		 push	 edx
  004f5	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _scx$19[ebp]
  004fb	50		 push	 eax
  004fc	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _sy$20[ebp]
  00502	51		 push	 ecx
  00503	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _sx$21[ebp]
  00509	52		 push	 edx
  0050a	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _start_off$26[ebp]
  00510	50		 push	 eax
  00511	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _was_off$28[ebp]
  00517	51		 push	 ecx
  00518	8b 55 c4	 mov	 edx, DWORD PTR _num_vertices$[ebp]
  0051b	52		 push	 edx
  0051c	8b 45 d0	 mov	 eax, DWORD PTR _vertices$[ebp]
  0051f	50		 push	 eax
  00520	e8 00 00 00 00	 call	 ?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
  00525	83 c4 28	 add	 esp, 40			; 00000028H
  00528	89 45 c4	 mov	 DWORD PTR _num_vertices$[ebp], eax
$LN34@stbtt__Get:

; 1734 : 
; 1735 :             // now start the new one               
; 1736 :             start_off = !(flags & 1);

  0052b	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  0052f	83 e0 01	 and	 eax, 1
  00532	75 0c		 jne	 SHORT $LN68@stbtt__Get
  00534	c7 85 6c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv293[ebp], 1
  0053e	eb 0a		 jmp	 SHORT $LN69@stbtt__Get
$LN68@stbtt__Get:
  00540	c7 85 6c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv293[ebp], 0
$LN69@stbtt__Get:
  0054a	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR tv293[ebp]
  00550	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _start_off$26[ebp], ecx

; 1737 :             if (start_off) {

  00556	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR _start_off$26[ebp], 0
  0055d	0f 84 c8 00 00
	00		 je	 $LN35@stbtt__Get

; 1738 :                // if we start off with an off-curve point, then when we need to find a point on the curve
; 1739 :                // where we can start, and we need to save some state for when we wraparound.
; 1740 :                scx = x;

  00563	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$25[ebp]
  00569	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _scx$19[ebp], eax

; 1741 :                scy = y;

  0056f	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _y$24[ebp]
  00575	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _scy$18[ebp], eax

; 1742 :                if (!(vertices[off+i+1].type & 1)) {

  0057b	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  0057e	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _off$27[ebp]
  00584	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00588	6b c2 0e	 imul	 eax, edx, 14
  0058b	8b 4d d0	 mov	 ecx, DWORD PTR _vertices$[ebp]
  0058e	0f b6 54 01 0c	 movzx	 edx, BYTE PTR [ecx+eax+12]
  00593	83 e2 01	 and	 edx, 1
  00596	75 4d		 jne	 SHORT $LN37@stbtt__Get

; 1743 :                   // next point is also a curve point, so interpolate an on-point curve
; 1744 :                   sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;

  00598	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  0059b	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _off$27[ebp]
  005a1	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  005a5	6b c2 0e	 imul	 eax, edx, 14
  005a8	8b 4d d0	 mov	 ecx, DWORD PTR _vertices$[ebp]
  005ab	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  005af	03 95 28 ff ff
	ff		 add	 edx, DWORD PTR _x$25[ebp]
  005b5	d1 fa		 sar	 edx, 1
  005b7	89 95 f8 fe ff
	ff		 mov	 DWORD PTR _sx$21[ebp], edx

; 1745 :                   sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;

  005bd	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  005c0	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _off$27[ebp]
  005c6	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  005ca	6b c2 0e	 imul	 eax, edx, 14
  005cd	8b 4d d0	 mov	 ecx, DWORD PTR _vertices$[ebp]
  005d0	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  005d5	03 95 1c ff ff
	ff		 add	 edx, DWORD PTR _y$24[ebp]
  005db	d1 fa		 sar	 edx, 1
  005dd	89 95 ec fe ff
	ff		 mov	 DWORD PTR _sy$20[ebp], edx

; 1746 :                } else {

  005e3	eb 44		 jmp	 SHORT $LN38@stbtt__Get
$LN37@stbtt__Get:

; 1747 :                   // otherwise just use the next point as our start point
; 1748 :                   sx = (stbtt_int32) vertices[off+i+1].x;

  005e5	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  005e8	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _off$27[ebp]
  005ee	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  005f2	6b c2 0e	 imul	 eax, edx, 14
  005f5	8b 4d d0	 mov	 ecx, DWORD PTR _vertices$[ebp]
  005f8	0f bf 14 01	 movsx	 edx, WORD PTR [ecx+eax]
  005fc	89 95 f8 fe ff
	ff		 mov	 DWORD PTR _sx$21[ebp], edx

; 1749 :                   sy = (stbtt_int32) vertices[off+i+1].y;

  00602	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  00605	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _off$27[ebp]
  0060b	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0060f	6b c2 0e	 imul	 eax, edx, 14
  00612	8b 4d d0	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00615	0f bf 54 01 02	 movsx	 edx, WORD PTR [ecx+eax+2]
  0061a	89 95 ec fe ff
	ff		 mov	 DWORD PTR _sy$20[ebp], edx

; 1750 :                   ++i; // we're using point i+1 as the starting point, so skip it

  00620	8b 45 88	 mov	 eax, DWORD PTR _i$33[ebp]
  00623	83 c0 01	 add	 eax, 1
  00626	89 45 88	 mov	 DWORD PTR _i$33[ebp], eax
$LN38@stbtt__Get:

; 1751 :                }
; 1752 :             } else {

  00629	eb 18		 jmp	 SHORT $LN36@stbtt__Get
$LN35@stbtt__Get:

; 1753 :                sx = x;

  0062b	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$25[ebp]
  00631	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _sx$21[ebp], eax

; 1754 :                sy = y;

  00637	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _y$24[ebp]
  0063d	89 85 ec fe ff
	ff		 mov	 DWORD PTR _sy$20[ebp], eax
$LN36@stbtt__Get:

; 1755 :             }
; 1756 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);

  00643	6b 45 c4 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  00647	03 45 d0	 add	 eax, DWORD PTR _vertices$[ebp]
  0064a	89 85 6c fc ff
	ff		 mov	 DWORD PTR tv340[ebp], eax
  00650	8b 4d c4	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  00653	83 c1 01	 add	 ecx, 1
  00656	89 4d c4	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  00659	6a 00		 push	 0
  0065b	6a 00		 push	 0
  0065d	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _sy$20[ebp]
  00663	52		 push	 edx
  00664	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _sx$21[ebp]
  0066a	50		 push	 eax
  0066b	6a 01		 push	 1
  0066d	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR tv340[ebp]
  00673	51		 push	 ecx
  00674	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  00679	83 c4 18	 add	 esp, 24			; 00000018H

; 1757 :             was_off = 0;

  0067c	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _was_off$28[ebp], 0

; 1758 :             next_move = 1 + ttUSHORT(endPtsOfContours+j*2);

  00686	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _j$32[ebp]
  0068c	8b 4d e8	 mov	 ecx, DWORD PTR _endPtsOfContours$[ebp]
  0068f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00692	52		 push	 edx
  00693	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00698	83 c4 04	 add	 esp, 4
  0069b	0f b7 c0	 movzx	 eax, ax
  0069e	83 c0 01	 add	 eax, 1
  006a1	89 85 58 ff ff
	ff		 mov	 DWORD PTR _next_move$29[ebp], eax

; 1759 :             ++j;

  006a7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _j$32[ebp]
  006ad	83 c0 01	 add	 eax, 1
  006b0	89 85 7c ff ff
	ff		 mov	 DWORD PTR _j$32[ebp], eax

; 1760 :          } else {

  006b6	e9 21 01 00 00	 jmp	 $LN40@stbtt__Get
$LN32@stbtt__Get:

; 1761 :             if (!(flags & 1)) { // if it's a curve

  006bb	0f b6 45 af	 movzx	 eax, BYTE PTR _flags$36[ebp]
  006bf	83 e0 01	 and	 eax, 1
  006c2	0f 85 83 00 00
	00		 jne	 $LN39@stbtt__Get

; 1762 :                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint

  006c8	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _was_off$28[ebp], 0
  006cf	74 53		 je	 SHORT $LN41@stbtt__Get

; 1763 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);

  006d1	6b 45 c4 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  006d5	03 45 d0	 add	 eax, DWORD PTR _vertices$[ebp]
  006d8	89 85 6c fc ff
	ff		 mov	 DWORD PTR tv365[ebp], eax
  006de	8b 4d c4	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  006e1	83 c1 01	 add	 ecx, 1
  006e4	89 4d c4	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  006e7	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy$22[ebp]
  006ed	52		 push	 edx
  006ee	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _cx$23[ebp]
  006f4	50		 push	 eax
  006f5	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _cy$22[ebp]
  006fb	03 8d 1c ff ff
	ff		 add	 ecx, DWORD PTR _y$24[ebp]
  00701	d1 f9		 sar	 ecx, 1
  00703	51		 push	 ecx
  00704	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _cx$23[ebp]
  0070a	03 95 28 ff ff
	ff		 add	 edx, DWORD PTR _x$25[ebp]
  00710	d1 fa		 sar	 edx, 1
  00712	52		 push	 edx
  00713	6a 03		 push	 3
  00715	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR tv365[ebp]
  0071b	50		 push	 eax
  0071c	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  00721	83 c4 18	 add	 esp, 24			; 00000018H
$LN41@stbtt__Get:

; 1764 :                cx = x;

  00724	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$25[ebp]
  0072a	89 85 10 ff ff
	ff		 mov	 DWORD PTR _cx$23[ebp], eax

; 1765 :                cy = y;

  00730	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _y$24[ebp]
  00736	89 85 04 ff ff
	ff		 mov	 DWORD PTR _cy$22[ebp], eax

; 1766 :                was_off = 1;

  0073c	c7 85 4c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _was_off$28[ebp], 1

; 1767 :             } else {

  00746	e9 91 00 00 00	 jmp	 $LN40@stbtt__Get
$LN39@stbtt__Get:

; 1768 :                if (was_off)

  0074b	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _was_off$28[ebp], 0
  00752	74 45		 je	 SHORT $LN42@stbtt__Get

; 1769 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);

  00754	6b 45 c4 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  00758	03 45 d0	 add	 eax, DWORD PTR _vertices$[ebp]
  0075b	89 85 6c fc ff
	ff		 mov	 DWORD PTR tv376[ebp], eax
  00761	8b 4d c4	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  00764	83 c1 01	 add	 ecx, 1
  00767	89 4d c4	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  0076a	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _cy$22[ebp]
  00770	52		 push	 edx
  00771	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _cx$23[ebp]
  00777	50		 push	 eax
  00778	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _y$24[ebp]
  0077e	51		 push	 ecx
  0077f	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _x$25[ebp]
  00785	52		 push	 edx
  00786	6a 03		 push	 3
  00788	8b 85 6c fc ff
	ff		 mov	 eax, DWORD PTR tv376[ebp]
  0078e	50		 push	 eax
  0078f	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  00794	83 c4 18	 add	 esp, 24			; 00000018H
  00797	eb 39		 jmp	 SHORT $LN43@stbtt__Get
$LN42@stbtt__Get:

; 1770 :                else
; 1771 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);

  00799	6b 45 c4 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  0079d	03 45 d0	 add	 eax, DWORD PTR _vertices$[ebp]
  007a0	89 85 6c fc ff
	ff		 mov	 DWORD PTR tv386[ebp], eax
  007a6	8b 4d c4	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  007a9	83 c1 01	 add	 ecx, 1
  007ac	89 4d c4	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  007af	6a 00		 push	 0
  007b1	6a 00		 push	 0
  007b3	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _y$24[ebp]
  007b9	52		 push	 edx
  007ba	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _x$25[ebp]
  007c0	50		 push	 eax
  007c1	6a 02		 push	 2
  007c3	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR tv386[ebp]
  007c9	51		 push	 ecx
  007ca	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  007cf	83 c4 18	 add	 esp, 24			; 00000018H
$LN43@stbtt__Get:

; 1772 :                was_off = 0;

  007d2	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _was_off$28[ebp], 0
$LN40@stbtt__Get:

; 1773 :             }
; 1774 :          }
; 1775 :       }

  007dc	e9 89 fc ff ff	 jmp	 $LN11@stbtt__Get
$LN12@stbtt__Get:

; 1776 :       num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

  007e1	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _cy$22[ebp]
  007e7	50		 push	 eax
  007e8	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _cx$23[ebp]
  007ee	51		 push	 ecx
  007ef	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _scy$18[ebp]
  007f5	52		 push	 edx
  007f6	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _scx$19[ebp]
  007fc	50		 push	 eax
  007fd	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _sy$20[ebp]
  00803	51		 push	 ecx
  00804	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _sx$21[ebp]
  0080a	52		 push	 edx
  0080b	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _start_off$26[ebp]
  00811	50		 push	 eax
  00812	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _was_off$28[ebp]
  00818	51		 push	 ecx
  00819	8b 55 c4	 mov	 edx, DWORD PTR _num_vertices$[ebp]
  0081c	52		 push	 edx
  0081d	8b 45 d0	 mov	 eax, DWORD PTR _vertices$[ebp]
  00820	50		 push	 eax
  00821	e8 00 00 00 00	 call	 ?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
  00826	83 c4 28	 add	 esp, 40			; 00000028H
  00829	89 45 c4	 mov	 DWORD PTR _num_vertices$[ebp], eax
  0082c	e9 79 08 00 00	 jmp	 $LN61@stbtt__Get
$LN20@stbtt__Get:

; 1777 :    } else if (numberOfContours == -1) {

  00831	0f bf 45 f4	 movsx	 eax, WORD PTR _numberOfContours$[ebp]
  00835	83 f8 ff	 cmp	 eax, -1
  00838	0f 85 37 08 00
	00		 jne	 $LN44@stbtt__Get

; 1778 :       // Compound shapes.
; 1779 :       int more = 1;

  0083e	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _more$14[ebp], 1

; 1780 :       stbtt_uint8 *comp = data + g + 10;

  00848	8b 45 b8	 mov	 eax, DWORD PTR _g$[ebp]
  0084b	8b 4d dc	 mov	 ecx, DWORD PTR _data$[ebp]
  0084e	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00852	89 95 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], edx

; 1781 :       num_vertices = 0;

  00858	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _num_vertices$[ebp], 0

; 1782 :       vertices = 0;

  0085f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _vertices$[ebp], 0
$LN14@stbtt__Get:

; 1783 :       while (more) {

  00866	83 bd a4 fe ff
	ff 00		 cmp	 DWORD PTR _more$14[ebp], 0
  0086d	0f 84 00 08 00
	00		 je	 $LN15@stbtt__Get

; 1784 :          stbtt_uint16 flags, gidx;
; 1785 :          int comp_num_verts = 0, i;

  00873	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _comp_num_verts$10[ebp], 0

; 1786 :          stbtt_vertex *comp_verts = 0, *tmp = 0;

  0087d	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _comp_verts$8[ebp], 0
  00887	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmp$7[ebp], 0

; 1787 :          float mtx[6] = {1,0,0,1,0,0}, m, n;

  00891	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00899	f3 0f 11 85 30
	fe ff ff	 movss	 DWORD PTR _mtx$6[ebp], xmm0
  008a1	0f 57 c0	 xorps	 xmm0, xmm0
  008a4	f3 0f 11 85 34
	fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+4], xmm0
  008ac	0f 57 c0	 xorps	 xmm0, xmm0
  008af	f3 0f 11 85 38
	fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+8], xmm0
  008b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008bf	f3 0f 11 85 3c
	fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+12], xmm0
  008c7	0f 57 c0	 xorps	 xmm0, xmm0
  008ca	f3 0f 11 85 40
	fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+16], xmm0
  008d2	0f 57 c0	 xorps	 xmm0, xmm0
  008d5	f3 0f 11 85 44
	fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+20], xmm0

; 1788 :          
; 1789 :          flags = ttSHORT(comp); comp+=2;

  008dd	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  008e3	50		 push	 eax
  008e4	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  008e9	83 c4 04	 add	 esp, 4
  008ec	66 89 85 8c fe
	ff ff		 mov	 WORD PTR _flags$12[ebp], ax
  008f3	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  008f9	83 c0 02	 add	 eax, 2
  008fc	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1790 :          gidx = ttSHORT(comp); comp+=2;

  00902	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00908	50		 push	 eax
  00909	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0090e	83 c4 04	 add	 esp, 4
  00911	66 89 85 80 fe
	ff ff		 mov	 WORD PTR _gidx$11[ebp], ax
  00918	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  0091e	83 c0 02	 add	 eax, 2
  00921	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1791 : 
; 1792 :          if (flags & 2) { // XY values

  00927	0f b7 85 8c fe
	ff ff		 movzx	 eax, WORD PTR _flags$12[ebp]
  0092e	83 e0 02	 and	 eax, 2
  00931	0f 84 d6 00 00
	00		 je	 $LN46@stbtt__Get

; 1793 :             if (flags & 1) { // shorts

  00937	0f b7 85 8c fe
	ff ff		 movzx	 eax, WORD PTR _flags$12[ebp]
  0093e	83 e0 01	 and	 eax, 1
  00941	74 6e		 je	 SHORT $LN48@stbtt__Get

; 1794 :                mtx[4] = ttSHORT(comp); comp+=2;

  00943	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00949	50		 push	 eax
  0094a	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0094f	83 c4 04	 add	 esp, 4
  00952	0f bf c8	 movsx	 ecx, ax
  00955	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00959	ba 04 00 00 00	 mov	 edx, 4
  0095e	c1 e2 02	 shl	 edx, 2
  00961	f3 0f 11 84 15
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+edx], xmm0
  0096a	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00970	83 c0 02	 add	 eax, 2
  00973	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1795 :                mtx[5] = ttSHORT(comp); comp+=2;

  00979	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  0097f	50		 push	 eax
  00980	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00985	83 c4 04	 add	 esp, 4
  00988	0f bf c8	 movsx	 ecx, ax
  0098b	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0098f	ba 04 00 00 00	 mov	 edx, 4
  00994	6b c2 05	 imul	 eax, edx, 5
  00997	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  009a0	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  009a6	83 c0 02	 add	 eax, 2
  009a9	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1796 :             } else {

  009af	eb 5a		 jmp	 SHORT $LN49@stbtt__Get
$LN48@stbtt__Get:

; 1797 :                mtx[4] = ttCHAR(comp); comp+=1;

  009b1	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  009b7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  009ba	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  009be	ba 04 00 00 00	 mov	 edx, 4
  009c3	c1 e2 02	 shl	 edx, 2
  009c6	f3 0f 11 84 15
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+edx], xmm0
  009cf	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  009d5	83 c0 01	 add	 eax, 1
  009d8	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1798 :                mtx[5] = ttCHAR(comp); comp+=1;

  009de	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  009e4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  009e7	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  009eb	ba 04 00 00 00	 mov	 edx, 4
  009f0	6b c2 05	 imul	 eax, edx, 5
  009f3	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  009fc	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00a02	83 c0 01	 add	 eax, 1
  00a05	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax
$LN49@stbtt__Get:

; 1799 :             }
; 1800 :          }

  00a0b	eb 2d		 jmp	 SHORT $LN70@stbtt__Get
$LN46@stbtt__Get:

; 1801 :          else {
; 1802 :             // @TODO handle matching point
; 1803 :             STBTT_assert(0);

  00a0d	33 c0		 xor	 eax, eax
  00a0f	75 29		 jne	 SHORT $LN70@stbtt__Get
  00a11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA
  00a17	81 c1 a3 00 00
	00		 add	 ecx, 163		; 000000a3H
  00a1d	8b f4		 mov	 esi, esp
  00a1f	51		 push	 ecx
  00a20	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00a25	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  00a2a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00a30	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a33	3b f4		 cmp	 esi, esp
  00a35	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN70@stbtt__Get:

; 1804 :          }
; 1805 :          if (flags & (1<<3)) { // WE_HAVE_A_SCALE

  00a3a	0f b7 85 8c fe
	ff ff		 movzx	 eax, WORD PTR _flags$12[ebp]
  00a41	83 e0 08	 and	 eax, 8
  00a44	0f 84 93 00 00
	00		 je	 $LN50@stbtt__Get

; 1806 :             mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

  00a4a	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00a50	50		 push	 eax
  00a51	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00a56	83 c4 04	 add	 esp, 4
  00a59	0f bf c8	 movsx	 ecx, ax
  00a5c	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00a60	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00a68	f3 0f 11 85 6c
	fc ff ff	 movss	 DWORD PTR tv457[ebp], xmm0
  00a70	ba 04 00 00 00	 mov	 edx, 4
  00a75	6b c2 03	 imul	 eax, edx, 3
  00a78	f3 0f 10 85 6c
	fc ff ff	 movss	 xmm0, DWORD PTR tv457[ebp]
  00a80	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  00a89	b9 04 00 00 00	 mov	 ecx, 4
  00a8e	6b d1 00	 imul	 edx, ecx, 0
  00a91	f3 0f 10 85 6c
	fc ff ff	 movss	 xmm0, DWORD PTR tv457[ebp]
  00a99	f3 0f 11 84 15
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+edx], xmm0
  00aa2	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00aa8	83 c0 02	 add	 eax, 2
  00aab	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1807 :             mtx[1] = mtx[2] = 0;

  00ab1	b8 04 00 00 00	 mov	 eax, 4
  00ab6	d1 e0		 shl	 eax, 1
  00ab8	0f 57 c0	 xorps	 xmm0, xmm0
  00abb	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  00ac4	b9 04 00 00 00	 mov	 ecx, 4
  00ac9	c1 e1 00	 shl	 ecx, 0
  00acc	0f 57 c0	 xorps	 xmm0, xmm0
  00acf	f3 0f 11 84 0d
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+ecx], xmm0
  00ad8	e9 c1 01 00 00	 jmp	 $LN54@stbtt__Get
$LN50@stbtt__Get:

; 1808 :          } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE

  00add	0f b7 85 8c fe
	ff ff		 movzx	 eax, WORD PTR _flags$12[ebp]
  00ae4	83 e0 40	 and	 eax, 64			; 00000040H
  00ae7	0f 84 a8 00 00
	00		 je	 $LN52@stbtt__Get

; 1809 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

  00aed	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00af3	50		 push	 eax
  00af4	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00af9	83 c4 04	 add	 esp, 4
  00afc	0f bf c8	 movsx	 ecx, ax
  00aff	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00b03	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00b0b	ba 04 00 00 00	 mov	 edx, 4
  00b10	6b c2 00	 imul	 eax, edx, 0
  00b13	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  00b1c	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00b22	83 c0 02	 add	 eax, 2
  00b25	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1810 :             mtx[1] = mtx[2] = 0;

  00b2b	b8 04 00 00 00	 mov	 eax, 4
  00b30	d1 e0		 shl	 eax, 1
  00b32	0f 57 c0	 xorps	 xmm0, xmm0
  00b35	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  00b3e	b9 04 00 00 00	 mov	 ecx, 4
  00b43	c1 e1 00	 shl	 ecx, 0
  00b46	0f 57 c0	 xorps	 xmm0, xmm0
  00b49	f3 0f 11 84 0d
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+ecx], xmm0

; 1811 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

  00b52	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00b58	50		 push	 eax
  00b59	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00b5e	83 c4 04	 add	 esp, 4
  00b61	0f bf c8	 movsx	 ecx, ax
  00b64	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00b68	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00b70	ba 04 00 00 00	 mov	 edx, 4
  00b75	6b c2 03	 imul	 eax, edx, 3
  00b78	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  00b81	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00b87	83 c0 02	 add	 eax, 2
  00b8a	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax
  00b90	e9 09 01 00 00	 jmp	 $LN54@stbtt__Get
$LN52@stbtt__Get:

; 1812 :          } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO

  00b95	0f b7 85 8c fe
	ff ff		 movzx	 eax, WORD PTR _flags$12[ebp]
  00b9c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00ba1	0f 84 f7 00 00
	00		 je	 $LN54@stbtt__Get

; 1813 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

  00ba7	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00bad	50		 push	 eax
  00bae	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00bb3	83 c4 04	 add	 esp, 4
  00bb6	0f bf c8	 movsx	 ecx, ax
  00bb9	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00bbd	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00bc5	ba 04 00 00 00	 mov	 edx, 4
  00bca	6b c2 00	 imul	 eax, edx, 0
  00bcd	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  00bd6	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00bdc	83 c0 02	 add	 eax, 2
  00bdf	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1814 :             mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;

  00be5	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00beb	50		 push	 eax
  00bec	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00bf1	83 c4 04	 add	 esp, 4
  00bf4	0f bf c8	 movsx	 ecx, ax
  00bf7	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00bfb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00c03	ba 04 00 00 00	 mov	 edx, 4
  00c08	c1 e2 00	 shl	 edx, 0
  00c0b	f3 0f 11 84 15
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+edx], xmm0
  00c14	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00c1a	83 c0 02	 add	 eax, 2
  00c1d	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1815 :             mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;

  00c23	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00c29	50		 push	 eax
  00c2a	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00c2f	83 c4 04	 add	 esp, 4
  00c32	0f bf c8	 movsx	 ecx, ax
  00c35	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00c39	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00c41	ba 04 00 00 00	 mov	 edx, 4
  00c46	d1 e2		 shl	 edx, 1
  00c48	f3 0f 11 84 15
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+edx], xmm0
  00c51	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00c57	83 c0 02	 add	 eax, 2
  00c5a	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax

; 1816 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

  00c60	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00c66	50		 push	 eax
  00c67	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00c6c	83 c4 04	 add	 esp, 4
  00c6f	0f bf c8	 movsx	 ecx, ax
  00c72	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00c76	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@46800000
  00c7e	ba 04 00 00 00	 mov	 edx, 4
  00c83	6b c2 03	 imul	 eax, edx, 3
  00c86	f3 0f 11 84 05
	30 fe ff ff	 movss	 DWORD PTR _mtx$6[ebp+eax], xmm0
  00c8f	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _comp$13[ebp]
  00c95	83 c0 02	 add	 eax, 2
  00c98	89 85 98 fe ff
	ff		 mov	 DWORD PTR _comp$13[ebp], eax
$LN54@stbtt__Get:

; 1817 :          }
; 1818 :          
; 1819 :          // Find transformation scales.
; 1820 :          m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);

  00c9e	b8 04 00 00 00	 mov	 eax, 4
  00ca3	6b c8 00	 imul	 ecx, eax, 0
  00ca6	ba 04 00 00 00	 mov	 edx, 4
  00cab	6b c2 00	 imul	 eax, edx, 0
  00cae	f3 0f 10 84 0d
	30 fe ff ff	 movss	 xmm0, DWORD PTR _mtx$6[ebp+ecx]
  00cb7	f3 0f 59 84 05
	30 fe ff ff	 mulss	 xmm0, DWORD PTR _mtx$6[ebp+eax]
  00cc0	b9 04 00 00 00	 mov	 ecx, 4
  00cc5	c1 e1 00	 shl	 ecx, 0
  00cc8	ba 04 00 00 00	 mov	 edx, 4
  00ccd	c1 e2 00	 shl	 edx, 0
  00cd0	f3 0f 10 8c 0d
	30 fe ff ff	 movss	 xmm1, DWORD PTR _mtx$6[ebp+ecx]
  00cd9	f3 0f 59 8c 15
	30 fe ff ff	 mulss	 xmm1, DWORD PTR _mtx$6[ebp+edx]
  00ce2	f3 0f 58 c1	 addss	 xmm0, xmm1
  00ce6	51		 push	 ecx
  00ce7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cec	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  00cf1	83 c4 04	 add	 esp, 4
  00cf4	d9 9d 24 fe ff
	ff		 fstp	 DWORD PTR _m$5[ebp]

; 1821 :          n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

  00cfa	b8 04 00 00 00	 mov	 eax, 4
  00cff	d1 e0		 shl	 eax, 1
  00d01	b9 04 00 00 00	 mov	 ecx, 4
  00d06	d1 e1		 shl	 ecx, 1
  00d08	f3 0f 10 84 05
	30 fe ff ff	 movss	 xmm0, DWORD PTR _mtx$6[ebp+eax]
  00d11	f3 0f 59 84 0d
	30 fe ff ff	 mulss	 xmm0, DWORD PTR _mtx$6[ebp+ecx]
  00d1a	ba 04 00 00 00	 mov	 edx, 4
  00d1f	6b c2 03	 imul	 eax, edx, 3
  00d22	b9 04 00 00 00	 mov	 ecx, 4
  00d27	6b d1 03	 imul	 edx, ecx, 3
  00d2a	f3 0f 10 8c 05
	30 fe ff ff	 movss	 xmm1, DWORD PTR _mtx$6[ebp+eax]
  00d33	f3 0f 59 8c 15
	30 fe ff ff	 mulss	 xmm1, DWORD PTR _mtx$6[ebp+edx]
  00d3c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00d40	51		 push	 ecx
  00d41	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d46	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  00d4b	83 c4 04	 add	 esp, 4
  00d4e	d9 9d 18 fe ff
	ff		 fstp	 DWORD PTR _n$4[ebp]

; 1822 : 
; 1823 :          // Get indexed glyph.
; 1824 :          comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

  00d54	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _comp_verts$8[ebp]
  00d5a	50		 push	 eax
  00d5b	0f b7 8d 80 fe
	ff ff		 movzx	 ecx, WORD PTR _gidx$11[ebp]
  00d62	51		 push	 ecx
  00d63	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00d66	52		 push	 edx
  00d67	e8 00 00 00 00	 call	 _stbtt_GetGlyphShape
  00d6c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d6f	89 85 74 fe ff
	ff		 mov	 DWORD PTR _comp_num_verts$10[ebp], eax

; 1825 :          if (comp_num_verts > 0) {

  00d75	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _comp_num_verts$10[ebp], 0
  00d7c	0f 8e dc 02 00
	00		 jle	 $LN55@stbtt__Get

; 1826 :             // Transform vertices.
; 1827 :             for (i = 0; i < comp_num_verts; ++i) {

  00d82	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$9[ebp], 0
  00d8c	eb 0f		 jmp	 SHORT $LN18@stbtt__Get
$LN16@stbtt__Get:
  00d8e	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _i$9[ebp]
  00d94	83 c0 01	 add	 eax, 1
  00d97	89 85 68 fe ff
	ff		 mov	 DWORD PTR _i$9[ebp], eax
$LN18@stbtt__Get:
  00d9d	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _i$9[ebp]
  00da3	3b 85 74 fe ff
	ff		 cmp	 eax, DWORD PTR _comp_num_verts$10[ebp]
  00da9	0f 8d e4 01 00
	00		 jge	 $LN17@stbtt__Get

; 1828 :                stbtt_vertex* v = &comp_verts[i];

  00daf	6b 85 68 fe ff
	ff 0e		 imul	 eax, DWORD PTR _i$9[ebp], 14
  00db6	03 85 5c fe ff
	ff		 add	 eax, DWORD PTR _comp_verts$8[ebp]
  00dbc	89 85 0c fe ff
	ff		 mov	 DWORD PTR _v$3[ebp], eax

; 1829 :                stbtt_vertex_type x,y;
; 1830 :                x=v->x; y=v->y;

  00dc2	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _v$3[ebp]
  00dc8	66 8b 08	 mov	 cx, WORD PTR [eax]
  00dcb	66 89 8d 00 fe
	ff ff		 mov	 WORD PTR _x$2[ebp], cx
  00dd2	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _v$3[ebp]
  00dd8	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00ddc	66 89 8d f4 fd
	ff ff		 mov	 WORD PTR _y$1[ebp], cx

; 1831 :                v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

  00de3	b8 04 00 00 00	 mov	 eax, 4
  00de8	6b c8 00	 imul	 ecx, eax, 0
  00deb	0f bf 95 00 fe
	ff ff		 movsx	 edx, WORD PTR _x$2[ebp]
  00df2	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00df6	f3 0f 59 84 0d
	30 fe ff ff	 mulss	 xmm0, DWORD PTR _mtx$6[ebp+ecx]
  00dff	b8 04 00 00 00	 mov	 eax, 4
  00e04	d1 e0		 shl	 eax, 1
  00e06	0f bf 8d f4 fd
	ff ff		 movsx	 ecx, WORD PTR _y$1[ebp]
  00e0d	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00e11	f3 0f 59 8c 05
	30 fe ff ff	 mulss	 xmm1, DWORD PTR _mtx$6[ebp+eax]
  00e1a	f3 0f 58 c1	 addss	 xmm0, xmm1
  00e1e	ba 04 00 00 00	 mov	 edx, 4
  00e23	c1 e2 02	 shl	 edx, 2
  00e26	f3 0f 58 84 15
	30 fe ff ff	 addss	 xmm0, DWORD PTR _mtx$6[ebp+edx]
  00e2f	f3 0f 59 85 24
	fe ff ff	 mulss	 xmm0, DWORD PTR _m$5[ebp]
  00e37	f3 0f 2c c0	 cvttss2si eax, xmm0
  00e3b	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _v$3[ebp]
  00e41	66 89 01	 mov	 WORD PTR [ecx], ax

; 1832 :                v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

  00e44	b8 04 00 00 00	 mov	 eax, 4
  00e49	c1 e0 00	 shl	 eax, 0
  00e4c	0f bf 8d 00 fe
	ff ff		 movsx	 ecx, WORD PTR _x$2[ebp]
  00e53	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00e57	f3 0f 59 84 05
	30 fe ff ff	 mulss	 xmm0, DWORD PTR _mtx$6[ebp+eax]
  00e60	ba 04 00 00 00	 mov	 edx, 4
  00e65	6b c2 03	 imul	 eax, edx, 3
  00e68	0f bf 8d f4 fd
	ff ff		 movsx	 ecx, WORD PTR _y$1[ebp]
  00e6f	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00e73	f3 0f 59 8c 05
	30 fe ff ff	 mulss	 xmm1, DWORD PTR _mtx$6[ebp+eax]
  00e7c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00e80	ba 04 00 00 00	 mov	 edx, 4
  00e85	6b c2 05	 imul	 eax, edx, 5
  00e88	f3 0f 58 84 05
	30 fe ff ff	 addss	 xmm0, DWORD PTR _mtx$6[ebp+eax]
  00e91	f3 0f 59 85 18
	fe ff ff	 mulss	 xmm0, DWORD PTR _n$4[ebp]
  00e99	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00e9d	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _v$3[ebp]
  00ea3	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 1833 :                x=v->cx; y=v->cy;

  00ea7	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _v$3[ebp]
  00ead	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  00eb1	66 89 8d 00 fe
	ff ff		 mov	 WORD PTR _x$2[ebp], cx
  00eb8	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _v$3[ebp]
  00ebe	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  00ec2	66 89 8d f4 fd
	ff ff		 mov	 WORD PTR _y$1[ebp], cx

; 1834 :                v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

  00ec9	b8 04 00 00 00	 mov	 eax, 4
  00ece	6b c8 00	 imul	 ecx, eax, 0
  00ed1	0f bf 95 00 fe
	ff ff		 movsx	 edx, WORD PTR _x$2[ebp]
  00ed8	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00edc	f3 0f 59 84 0d
	30 fe ff ff	 mulss	 xmm0, DWORD PTR _mtx$6[ebp+ecx]
  00ee5	b8 04 00 00 00	 mov	 eax, 4
  00eea	d1 e0		 shl	 eax, 1
  00eec	0f bf 8d f4 fd
	ff ff		 movsx	 ecx, WORD PTR _y$1[ebp]
  00ef3	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00ef7	f3 0f 59 8c 05
	30 fe ff ff	 mulss	 xmm1, DWORD PTR _mtx$6[ebp+eax]
  00f00	f3 0f 58 c1	 addss	 xmm0, xmm1
  00f04	ba 04 00 00 00	 mov	 edx, 4
  00f09	c1 e2 02	 shl	 edx, 2
  00f0c	f3 0f 58 84 15
	30 fe ff ff	 addss	 xmm0, DWORD PTR _mtx$6[ebp+edx]
  00f15	f3 0f 59 85 24
	fe ff ff	 mulss	 xmm0, DWORD PTR _m$5[ebp]
  00f1d	f3 0f 2c c0	 cvttss2si eax, xmm0
  00f21	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _v$3[ebp]
  00f27	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 1835 :                v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

  00f2b	b8 04 00 00 00	 mov	 eax, 4
  00f30	c1 e0 00	 shl	 eax, 0
  00f33	0f bf 8d 00 fe
	ff ff		 movsx	 ecx, WORD PTR _x$2[ebp]
  00f3a	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00f3e	f3 0f 59 84 05
	30 fe ff ff	 mulss	 xmm0, DWORD PTR _mtx$6[ebp+eax]
  00f47	ba 04 00 00 00	 mov	 edx, 4
  00f4c	6b c2 03	 imul	 eax, edx, 3
  00f4f	0f bf 8d f4 fd
	ff ff		 movsx	 ecx, WORD PTR _y$1[ebp]
  00f56	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00f5a	f3 0f 59 8c 05
	30 fe ff ff	 mulss	 xmm1, DWORD PTR _mtx$6[ebp+eax]
  00f63	f3 0f 58 c1	 addss	 xmm0, xmm1
  00f67	ba 04 00 00 00	 mov	 edx, 4
  00f6c	6b c2 05	 imul	 eax, edx, 5
  00f6f	f3 0f 58 84 05
	30 fe ff ff	 addss	 xmm0, DWORD PTR _mtx$6[ebp+eax]
  00f78	f3 0f 59 85 18
	fe ff ff	 mulss	 xmm0, DWORD PTR _n$4[ebp]
  00f80	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00f84	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _v$3[ebp]
  00f8a	66 89 4a 06	 mov	 WORD PTR [edx+6], cx

; 1836 :             }

  00f8e	e9 fb fd ff ff	 jmp	 $LN16@stbtt__Get
$LN17@stbtt__Get:

; 1837 :             // Append vertices.
; 1838 :             tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);

  00f93	8b 45 c4	 mov	 eax, DWORD PTR _num_vertices$[ebp]
  00f96	03 85 74 fe ff
	ff		 add	 eax, DWORD PTR _comp_num_verts$10[ebp]
  00f9c	6b c8 0e	 imul	 ecx, eax, 14
  00f9f	51		 push	 ecx
  00fa0	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00fa5	83 c4 04	 add	 esp, 4
  00fa8	89 85 50 fe ff
	ff		 mov	 DWORD PTR _tmp$7[ebp], eax

; 1839 :             if (!tmp) {

  00fae	83 bd 50 fe ff
	ff 00		 cmp	 DWORD PTR _tmp$7[ebp], 0
  00fb5	75 31		 jne	 SHORT $LN56@stbtt__Get

; 1840 :                if (vertices) STBTT_free(vertices, info->userdata);

  00fb7	83 7d d0 00	 cmp	 DWORD PTR _vertices$[ebp], 0
  00fbb	74 0c		 je	 SHORT $LN57@stbtt__Get
  00fbd	8b 45 d0	 mov	 eax, DWORD PTR _vertices$[ebp]
  00fc0	50		 push	 eax
  00fc1	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00fc6	83 c4 04	 add	 esp, 4
$LN57@stbtt__Get:

; 1841 :                if (comp_verts) STBTT_free(comp_verts, info->userdata);

  00fc9	83 bd 5c fe ff
	ff 00		 cmp	 DWORD PTR _comp_verts$8[ebp], 0
  00fd0	74 0f		 je	 SHORT $LN58@stbtt__Get
  00fd2	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _comp_verts$8[ebp]
  00fd8	50		 push	 eax
  00fd9	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00fde	83 c4 04	 add	 esp, 4
$LN58@stbtt__Get:

; 1842 :                return 0;

  00fe1	33 c0		 xor	 eax, eax
  00fe3	e9 cd 00 00 00	 jmp	 $LN1@stbtt__Get
$LN56@stbtt__Get:

; 1843 :             }
; 1844 :             if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex)); //-V595

  00fe8	83 7d c4 00	 cmp	 DWORD PTR _num_vertices$[ebp], 0
  00fec	7e 18		 jle	 SHORT $LN59@stbtt__Get
  00fee	6b 45 c4 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  00ff2	50		 push	 eax
  00ff3	8b 4d d0	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00ff6	51		 push	 ecx
  00ff7	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR _tmp$7[ebp]
  00ffd	52		 push	 edx
  00ffe	e8 00 00 00 00	 call	 _memcpy
  01003	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN59@stbtt__Get:

; 1845 :             STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));

  01006	6b 85 74 fe ff
	ff 0e		 imul	 eax, DWORD PTR _comp_num_verts$10[ebp], 14
  0100d	50		 push	 eax
  0100e	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR _comp_verts$8[ebp]
  01014	51		 push	 ecx
  01015	6b 55 c4 0e	 imul	 edx, DWORD PTR _num_vertices$[ebp], 14
  01019	03 95 50 fe ff
	ff		 add	 edx, DWORD PTR _tmp$7[ebp]
  0101f	52		 push	 edx
  01020	e8 00 00 00 00	 call	 _memcpy
  01025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1846 :             if (vertices) STBTT_free(vertices, info->userdata);

  01028	83 7d d0 00	 cmp	 DWORD PTR _vertices$[ebp], 0
  0102c	74 0c		 je	 SHORT $LN60@stbtt__Get
  0102e	8b 45 d0	 mov	 eax, DWORD PTR _vertices$[ebp]
  01031	50		 push	 eax
  01032	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  01037	83 c4 04	 add	 esp, 4
$LN60@stbtt__Get:

; 1847 :             vertices = tmp;

  0103a	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR _tmp$7[ebp]
  01040	89 45 d0	 mov	 DWORD PTR _vertices$[ebp], eax

; 1848 :             STBTT_free(comp_verts, info->userdata);

  01043	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _comp_verts$8[ebp]
  01049	50		 push	 eax
  0104a	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0104f	83 c4 04	 add	 esp, 4

; 1849 :             num_vertices += comp_num_verts;

  01052	8b 45 c4	 mov	 eax, DWORD PTR _num_vertices$[ebp]
  01055	03 85 74 fe ff
	ff		 add	 eax, DWORD PTR _comp_num_verts$10[ebp]
  0105b	89 45 c4	 mov	 DWORD PTR _num_vertices$[ebp], eax
$LN55@stbtt__Get:

; 1850 :          }
; 1851 :          // More components ?
; 1852 :          more = flags & (1<<5);

  0105e	0f b7 85 8c fe
	ff ff		 movzx	 eax, WORD PTR _flags$12[ebp]
  01065	83 e0 20	 and	 eax, 32			; 00000020H
  01068	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _more$14[ebp], eax

; 1853 :       }

  0106e	e9 f3 f7 ff ff	 jmp	 $LN14@stbtt__Get
$LN15@stbtt__Get:

; 1854 :    } else if (numberOfContours < 0) {

  01073	eb 35		 jmp	 SHORT $LN61@stbtt__Get
$LN44@stbtt__Get:
  01075	0f bf 45 f4	 movsx	 eax, WORD PTR _numberOfContours$[ebp]
  01079	85 c0		 test	 eax, eax
  0107b	7d 2d		 jge	 SHORT $LN61@stbtt__Get

; 1855 :       // @TODO other compound variations?
; 1856 :       STBTT_assert(0);

  0107d	33 c0		 xor	 eax, eax
  0107f	75 29		 jne	 SHORT $LN71@stbtt__Get
  01081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z@4JA
  01087	81 c1 d8 00 00
	00		 add	 ecx, 216		; 000000d8H
  0108d	8b f4		 mov	 esi, esp
  0108f	51		 push	 ecx
  01090	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  01095	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  0109a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  010a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  010a3	3b f4		 cmp	 esi, esp
  010a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN71@stbtt__Get:
$LN61@stbtt__Get:

; 1857 :    } else {
; 1858 :       // numberOfCounters == 0, do nothing
; 1859 :    }
; 1860 : 
; 1861 :    *pvertices = vertices;

  010aa	8b 45 10	 mov	 eax, DWORD PTR _pvertices$[ebp]
  010ad	8b 4d d0	 mov	 ecx, DWORD PTR _vertices$[ebp]
  010b0	89 08		 mov	 DWORD PTR [eax], ecx

; 1862 :    return num_vertices;

  010b2	8b 45 c4	 mov	 eax, DWORD PTR _num_vertices$[ebp]
$LN1@stbtt__Get:

; 1863 : }

  010b5	52		 push	 edx
  010b6	8b cd		 mov	 ecx, ebp
  010b8	50		 push	 eax
  010b9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN75@stbtt__Get
  010bf	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  010c4	58		 pop	 eax
  010c5	5a		 pop	 edx
  010c6	5f		 pop	 edi
  010c7	5e		 pop	 esi
  010c8	5b		 pop	 ebx
  010c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010cc	33 cd		 xor	 ecx, ebp
  010ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010d3	81 c4 94 03 00
	00		 add	 esp, 916		; 00000394H
  010d9	3b ec		 cmp	 ebp, esp
  010db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  010e0	8b e5		 mov	 esp, ebp
  010e2	5d		 pop	 ebp
  010e3	c3		 ret	 0
$LN75@stbtt__Get:
  010e4	02 00 00 00	 DD	 2
  010e8	00 00 00 00	 DD	 $LN74@stbtt__Get
$LN74@stbtt__Get:
  010ec	5c fe ff ff	 DD	 -420			; fffffe5cH
  010f0	04 00 00 00	 DD	 4
  010f4	00 00 00 00	 DD	 $LN72@stbtt__Get
  010f8	30 fe ff ff	 DD	 -464			; fffffe30H
  010fc	18 00 00 00	 DD	 24			; 00000018H
  01100	00 00 00 00	 DD	 $LN73@stbtt__Get
$LN73@stbtt__Get:
  01104	6d		 DB	 109			; 0000006dH
  01105	74		 DB	 116			; 00000074H
  01106	78		 DB	 120			; 00000078H
  01107	00		 DB	 0
$LN72@stbtt__Get:
  01108	63		 DB	 99			; 00000063H
  01109	6f		 DB	 111			; 0000006fH
  0110a	6d		 DB	 109			; 0000006dH
  0110b	70		 DB	 112			; 00000070H
  0110c	5f		 DB	 95			; 0000005fH
  0110d	76		 DB	 118			; 00000076H
  0110e	65		 DB	 101			; 00000065H
  0110f	72		 DB	 114			; 00000072H
  01110	74		 DB	 116			; 00000074H
  01111	73		 DB	 115			; 00000073H
  01112	00		 DB	 0
?stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeTT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z
_TEXT	SEGMENT
tv141 = -196						; size = 4
tv131 = -196						; size = 4
tv88 = -196						; size = 4
tv78 = -196						; size = 4
_vertices$ = 8						; size = 4
_num_vertices$ = 12					; size = 4
_was_off$ = 16						; size = 4
_start_off$ = 20					; size = 4
_sx$ = 24						; size = 4
_sy$ = 28						; size = 4
_scx$ = 32						; size = 4
_scy$ = 36						; size = 4
_cx$ = 40						; size = 4
_cy$ = 44						; size = 4
?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z PROC ; stbtt__close_shape, COMDAT

; 1625 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :    if (start_off) {

  00028	83 7d 14 00	 cmp	 DWORD PTR _start_off$[ebp], 0
  0002c	0f 84 80 00 00
	00		 je	 $LN2@stbtt__clo

; 1627 :       if (was_off)

  00032	83 7d 10 00	 cmp	 DWORD PTR _was_off$[ebp], 0
  00036	74 41		 je	 SHORT $LN4@stbtt__clo

; 1628 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

  00038	6b 45 0c 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  0003c	03 45 08	 add	 eax, DWORD PTR _vertices$[ebp]
  0003f	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  00048	83 c1 01	 add	 ecx, 1
  0004b	89 4d 0c	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  0004e	8b 55 2c	 mov	 edx, DWORD PTR _cy$[ebp]
  00051	52		 push	 edx
  00052	8b 45 28	 mov	 eax, DWORD PTR _cx$[ebp]
  00055	50		 push	 eax
  00056	8b 4d 2c	 mov	 ecx, DWORD PTR _cy$[ebp]
  00059	03 4d 24	 add	 ecx, DWORD PTR _scy$[ebp]
  0005c	d1 f9		 sar	 ecx, 1
  0005e	51		 push	 ecx
  0005f	8b 55 28	 mov	 edx, DWORD PTR _cx$[ebp]
  00062	03 55 20	 add	 edx, DWORD PTR _scx$[ebp]
  00065	d1 fa		 sar	 edx, 1
  00067	52		 push	 edx
  00068	6a 03		 push	 3
  0006a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  00076	83 c4 18	 add	 esp, 24			; 00000018H
$LN4@stbtt__clo:

; 1629 :       stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);

  00079	6b 45 0c 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  0007d	03 45 08	 add	 eax, DWORD PTR _vertices$[ebp]
  00080	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  00089	83 c1 01	 add	 ecx, 1
  0008c	89 4d 0c	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  0008f	8b 55 24	 mov	 edx, DWORD PTR _scy$[ebp]
  00092	52		 push	 edx
  00093	8b 45 20	 mov	 eax, DWORD PTR _scx$[ebp]
  00096	50		 push	 eax
  00097	8b 4d 1c	 mov	 ecx, DWORD PTR _sy$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 18	 mov	 edx, DWORD PTR _sx$[ebp]
  0009e	52		 push	 edx
  0009f	6a 03		 push	 3
  000a1	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv88[ebp]
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  000ad	83 c4 18	 add	 esp, 24			; 00000018H

; 1630 :    } else {

  000b0	eb 72		 jmp	 SHORT $LN3@stbtt__clo
$LN2@stbtt__clo:

; 1631 :       if (was_off)

  000b2	83 7d 10 00	 cmp	 DWORD PTR _was_off$[ebp], 0
  000b6	74 39		 je	 SHORT $LN5@stbtt__clo

; 1632 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);

  000b8	6b 45 0c 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  000bc	03 45 08	 add	 eax, DWORD PTR _vertices$[ebp]
  000bf	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv131[ebp], eax
  000c5	8b 4d 0c	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  000c8	83 c1 01	 add	 ecx, 1
  000cb	89 4d 0c	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  000ce	8b 55 2c	 mov	 edx, DWORD PTR _cy$[ebp]
  000d1	52		 push	 edx
  000d2	8b 45 28	 mov	 eax, DWORD PTR _cx$[ebp]
  000d5	50		 push	 eax
  000d6	8b 4d 1c	 mov	 ecx, DWORD PTR _sy$[ebp]
  000d9	51		 push	 ecx
  000da	8b 55 18	 mov	 edx, DWORD PTR _sx$[ebp]
  000dd	52		 push	 edx
  000de	6a 03		 push	 3
  000e0	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv131[ebp]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  000ec	83 c4 18	 add	 esp, 24			; 00000018H
  000ef	eb 33		 jmp	 SHORT $LN3@stbtt__clo
$LN5@stbtt__clo:

; 1633 :       else
; 1634 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);

  000f1	6b 45 0c 0e	 imul	 eax, DWORD PTR _num_vertices$[ebp], 14
  000f5	03 45 08	 add	 eax, DWORD PTR _vertices$[ebp]
  000f8	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
  000fe	8b 4d 0c	 mov	 ecx, DWORD PTR _num_vertices$[ebp]
  00101	83 c1 01	 add	 ecx, 1
  00104	89 4d 0c	 mov	 DWORD PTR _num_vertices$[ebp], ecx
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	8b 55 1c	 mov	 edx, DWORD PTR _sy$[ebp]
  0010e	52		 push	 edx
  0010f	8b 45 18	 mov	 eax, DWORD PTR _sx$[ebp]
  00112	50		 push	 eax
  00113	6a 02		 push	 2
  00115	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv141[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
  00121	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@stbtt__clo:

; 1635 :    }
; 1636 :    return num_vertices;

  00124	8b 45 0c	 mov	 eax, DWORD PTR _num_vertices$[ebp]

; 1637 : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00130	3b ec		 cmp	 ebp, esp
  00132	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z ENDP ; stbtt__close_shape
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyphInfoT2@@YAHPBUstbtt_fontinfo@@HPAH111@Z
_TEXT	SEGMENT
tv81 = -268						; size = 4
tv79 = -268						; size = 4
tv76 = -268						; size = 4
tv73 = -268						; size = 4
tv70 = -268						; size = 4
_r$ = -68						; size = 4
_c$ = -56						; size = 48
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
?stbtt__GetGlyphInfoT2@@YAHPBUstbtt_fontinfo@@HPAH111@Z PROC ; stbtt__GetGlyphInfoT2, COMDAT

; 2255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2256 :    stbtt__csctx c = STBTT__CSCTX_INIT(1);

  00032	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _c$[ebp], 1
  00039	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _c$[ebp+4], 0
  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 45 d0	 movss	 DWORD PTR _c$[ebp+8], xmm0
  00048	0f 57 c0	 xorps	 xmm0, xmm0
  0004b	f3 0f 11 45 d4	 movss	 DWORD PTR _c$[ebp+12], xmm0
  00050	0f 57 c0	 xorps	 xmm0, xmm0
  00053	f3 0f 11 45 d8	 movss	 DWORD PTR _c$[ebp+16], xmm0
  00058	0f 57 c0	 xorps	 xmm0, xmm0
  0005b	f3 0f 11 45 dc	 movss	 DWORD PTR _c$[ebp+20], xmm0
  00060	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _c$[ebp+24], 0
  00067	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _c$[ebp+28], 0
  0006e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _c$[ebp+32], 0
  00075	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _c$[ebp+36], 0
  0007c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _c$[ebp+40], 0
  00083	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _c$[ebp+44], 0

; 2257 :    int r = stbtt__run_charstring(info, glyph_index, &c);

  0008a	8d 45 c8	 lea	 eax, DWORD PTR _c$[ebp]
  0008d	50		 push	 eax
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph_index$[ebp]
  00091	51		 push	 ecx
  00092	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ; stbtt__run_charstring
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	89 45 bc	 mov	 DWORD PTR _r$[ebp], eax

; 2258 :    if (x0)  *x0 = r ? c.min_x : 0;

  000a1	83 7d 10 00	 cmp	 DWORD PTR _x0$[ebp], 0
  000a5	74 26		 je	 SHORT $LN2@stbtt__Get
  000a7	83 7d bc 00	 cmp	 DWORD PTR _r$[ebp], 0
  000ab	74 0b		 je	 SHORT $LN7@stbtt__Get
  000ad	8b 45 e0	 mov	 eax, DWORD PTR _c$[ebp+24]
  000b0	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  000b6	eb 0a		 jmp	 SHORT $LN8@stbtt__Get
$LN7@stbtt__Get:
  000b8	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN8@stbtt__Get:
  000c2	8b 4d 10	 mov	 ecx, DWORD PTR _x0$[ebp]
  000c5	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv70[ebp]
  000cb	89 11		 mov	 DWORD PTR [ecx], edx
$LN2@stbtt__Get:

; 2259 :    if (y0)  *y0 = r ? c.min_y : 0;

  000cd	83 7d 14 00	 cmp	 DWORD PTR _y0$[ebp], 0
  000d1	74 26		 je	 SHORT $LN3@stbtt__Get
  000d3	83 7d bc 00	 cmp	 DWORD PTR _r$[ebp], 0
  000d7	74 0b		 je	 SHORT $LN9@stbtt__Get
  000d9	8b 45 e8	 mov	 eax, DWORD PTR _c$[ebp+32]
  000dc	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  000e2	eb 0a		 jmp	 SHORT $LN10@stbtt__Get
$LN9@stbtt__Get:
  000e4	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN10@stbtt__Get:
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR _y0$[ebp]
  000f1	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  000f7	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@stbtt__Get:

; 2260 :    if (x1)  *x1 = r ? c.max_x : 0;

  000f9	83 7d 18 00	 cmp	 DWORD PTR _x1$[ebp], 0
  000fd	74 26		 je	 SHORT $LN4@stbtt__Get
  000ff	83 7d bc 00	 cmp	 DWORD PTR _r$[ebp], 0
  00103	74 0b		 je	 SHORT $LN11@stbtt__Get
  00105	8b 45 e4	 mov	 eax, DWORD PTR _c$[ebp+28]
  00108	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  0010e	eb 0a		 jmp	 SHORT $LN12@stbtt__Get
$LN11@stbtt__Get:
  00110	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv76[ebp], 0
$LN12@stbtt__Get:
  0011a	8b 4d 18	 mov	 ecx, DWORD PTR _x1$[ebp]
  0011d	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  00123	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@stbtt__Get:

; 2261 :    if (y1)  *y1 = r ? c.max_y : 0;

  00125	83 7d 1c 00	 cmp	 DWORD PTR _y1$[ebp], 0
  00129	74 26		 je	 SHORT $LN5@stbtt__Get
  0012b	83 7d bc 00	 cmp	 DWORD PTR _r$[ebp], 0
  0012f	74 0b		 je	 SHORT $LN13@stbtt__Get
  00131	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp+36]
  00134	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  0013a	eb 0a		 jmp	 SHORT $LN14@stbtt__Get
$LN13@stbtt__Get:
  0013c	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
$LN14@stbtt__Get:
  00146	8b 4d 1c	 mov	 ecx, DWORD PTR _y1$[ebp]
  00149	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  0014f	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@stbtt__Get:

; 2262 :    return r ? c.num_vertices : 0;

  00151	83 7d bc 00	 cmp	 DWORD PTR _r$[ebp], 0
  00155	74 0b		 je	 SHORT $LN15@stbtt__Get
  00157	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp+44]
  0015a	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  00160	eb 0a		 jmp	 SHORT $LN16@stbtt__Get
$LN15@stbtt__Get:
  00162	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv81[ebp], 0
$LN16@stbtt__Get:
  0016c	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]

; 2263 : }

  00172	52		 push	 edx
  00173	8b cd		 mov	 ecx, ebp
  00175	50		 push	 eax
  00176	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@stbtt__Get
  0017c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00181	58		 pop	 eax
  00182	5a		 pop	 edx
  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00189	33 cd		 xor	 ecx, ebp
  0018b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00190	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00196	3b ec		 cmp	 ebp, esp
  00198	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c3		 ret	 0
  001a1	0f 1f 00	 npad	 3
$LN19@stbtt__Get:
  001a4	01 00 00 00	 DD	 1
  001a8	00 00 00 00	 DD	 $LN18@stbtt__Get
$LN18@stbtt__Get:
  001ac	c8 ff ff ff	 DD	 -56			; ffffffc8H
  001b0	30 00 00 00	 DD	 48			; 00000030H
  001b4	00 00 00 00	 DD	 $LN17@stbtt__Get
$LN17@stbtt__Get:
  001b8	63		 DB	 99			; 00000063H
  001b9	00		 DB	 0
?stbtt__GetGlyphInfoT2@@YAHPBUstbtt_fontinfo@@HPAH111@Z ENDP ; stbtt__GetGlyphInfoT2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z
_TEXT	SEGMENT
tv153 = -220						; size = 4
_g2$ = -20						; size = 4
_g1$ = -8						; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z PROC	; stbtt__GetGlyfOffset, COMDAT

; 1569 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1570 :    int g1,g2;
; 1571 : 
; 1572 :    STBTT_assert(!info->cff.size);

  00028	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002b	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0002f	74 26		 je	 SHORT $LN7@stbtt__Get
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z@4JA
  00037	83 c1 03	 add	 ecx, 3
  0003a	8b f4		 mov	 esi, esp
  0003c	51		 push	 ecx
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	3b f4		 cmp	 esi, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@stbtt__Get:

; 1573 : 
; 1574 :    if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range

  00057	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph_index$[ebp]
  0005d	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00060	7c 08		 jl	 SHORT $LN2@stbtt__Get
  00062	83 c8 ff	 or	 eax, -1
  00065	e9 dd 00 00 00	 jmp	 $LN1@stbtt__Get
$LN2@stbtt__Get:

; 1575 :    if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

  0006a	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0006d	83 78 30 02	 cmp	 DWORD PTR [eax+48], 2
  00071	7c 08		 jl	 SHORT $LN3@stbtt__Get
  00073	83 c8 ff	 or	 eax, -1
  00076	e9 cc 00 00 00	 jmp	 $LN1@stbtt__Get
$LN3@stbtt__Get:

; 1576 : 
; 1577 :    if (info->indexToLocFormat == 0) {

  0007b	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0007e	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00082	75 57		 jne	 SHORT $LN4@stbtt__Get

; 1578 :       g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

  00084	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008a	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0008d	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00090	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  00093	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  0009c	83 c4 04	 add	 esp, 4
  0009f	0f b7 d0	 movzx	 edx, ax
  000a2	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000a5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000a8	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  000ab	89 55 f8	 mov	 DWORD PTR _g1$[ebp], edx

; 1579 :       g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

  000ae	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000b1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b4	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000b7	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  000ba	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  000bd	8d 4c 41 02	 lea	 ecx, DWORD PTR [ecx+eax*2+2]
  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  000c7	83 c4 04	 add	 esp, 4
  000ca	0f b7 d0	 movzx	 edx, ax
  000cd	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000d0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000d3	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  000d6	89 55 ec	 mov	 DWORD PTR _g2$[ebp], edx

; 1580 :    } else {

  000d9	eb 49		 jmp	 SHORT $LN5@stbtt__Get
$LN4@stbtt__Get:

; 1581 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

  000db	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e1	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000e4	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  000e7	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  000ea	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  000f3	83 c4 04	 add	 esp, 4
  000f6	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000f9	03 42 18	 add	 eax, DWORD PTR [edx+24]
  000fc	89 45 f8	 mov	 DWORD PTR _g1$[ebp], eax

; 1582 :       g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);

  000ff	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00102	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00105	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00108	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  0010b	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  0010e	8d 4c 81 04	 lea	 ecx, DWORD PTR [ecx+eax*4+4]
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  00118	83 c4 04	 add	 esp, 4
  0011b	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0011e	03 42 18	 add	 eax, DWORD PTR [edx+24]
  00121	89 45 ec	 mov	 DWORD PTR _g2$[ebp], eax
$LN5@stbtt__Get:

; 1583 :    }
; 1584 : 
; 1585 :    return g1==g2 ? -1 : g1; // if length is 0, return -1

  00124	8b 45 f8	 mov	 eax, DWORD PTR _g1$[ebp]
  00127	3b 45 ec	 cmp	 eax, DWORD PTR _g2$[ebp]
  0012a	75 0c		 jne	 SHORT $LN8@stbtt__Get
  0012c	c7 85 24 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv153[ebp], -1
  00136	eb 09		 jmp	 SHORT $LN9@stbtt__Get
$LN8@stbtt__Get:
  00138	8b 4d f8	 mov	 ecx, DWORD PTR _g1$[ebp]
  0013b	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv153[ebp], ecx
$LN9@stbtt__Get:
  00141	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
$LN1@stbtt__Get:

; 1586 : }

  00147	5f		 pop	 edi
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx
  0014a	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00150	3b ec		 cmp	 ebp, esp
  00152	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z ENDP	; stbtt__GetGlyfOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_type$ = 12						; size = 1
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_cx$ = 24						; size = 4
_cy$ = 28						; size = 4
?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z PROC	; stbtt_setvertex, COMDAT

; 1560 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1561 :    v->type = type;

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	8a 4d 0c	 mov	 cl, BYTE PTR _type$[ebp]
  0002e	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 1562 :    v->x = (stbtt_int16) x;

  00031	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00034	66 8b 4d 10	 mov	 cx, WORD PTR _x$[ebp]
  00038	66 89 08	 mov	 WORD PTR [eax], cx

; 1563 :    v->y = (stbtt_int16) y;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0003e	66 8b 4d 14	 mov	 cx, WORD PTR _y$[ebp]
  00042	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 1564 :    v->cx = (stbtt_int16) cx;

  00046	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00049	66 8b 4d 18	 mov	 cx, WORD PTR _cx$[ebp]
  0004d	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 1565 :    v->cy = (stbtt_int16) cy;

  00051	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00054	66 8b 4d 1c	 mov	 cx, WORD PTR _cy$[ebp]
  00058	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 1566 : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ENDP	; stbtt_setvertex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt_InitFont_internal@@YAHPAUstbtt_fontinfo@@PAEH@Z
_TEXT	SEGMENT
tv322 = -1092						; size = 4
tv316 = -1092						; size = 4
$T1 = -1084						; size = 12
$T2 = -1064						; size = 12
$T3 = -1044						; size = 12
$T4 = -1024						; size = 12
$T5 = -1004						; size = 12
$T6 = -984						; size = 12
$T7 = -964						; size = 12
$T8 = -944						; size = 12
$T9 = -924						; size = 12
$T10 = -904						; size = 12
$T11 = -884						; size = 12
$T12 = -864						; size = 12
$T13 = -844						; size = 12
$T14 = -824						; size = 12
$T15 = -804						; size = 12
$T16 = -784						; size = 12
$T17 = -764						; size = 12
$T18 = -744						; size = 12
$T19 = -724						; size = 12
$T20 = -704						; size = 12
$T21 = -684						; size = 12
$T22 = -664						; size = 12
$T23 = -644						; size = 12
$T24 = -624						; size = 12
$T25 = -604						; size = 12
$T26 = -584						; size = 12
_encoding_record$27 = -180				; size = 4
_cff$28 = -168						; size = 4
_fdselectoff$29 = -156					; size = 4
_fdarrayoff$30 = -144					; size = 4
_charstrings$31 = -132					; size = 4
_cstype$32 = -120					; size = 4
_topdictidx$33 = -108					; size = 12
_topdict$34 = -88					; size = 12
_b$35 = -68						; size = 12
_numTables$ = -48					; size = 4
_i$ = -36						; size = 4
_t$ = -24						; size = 4
_cmap$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_data$ = 12						; size = 4
_fontstart$ = 16					; size = 4
?stbtt_InitFont_internal@@YAHPAUstbtt_fontinfo@@PAEH@Z PROC ; stbtt_InitFont_internal, COMDAT

; 1351 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 04 00
	00		 sub	 esp, 1092		; 00000444H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd bc fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1092]
  00012	b9 11 01 00 00	 mov	 ecx, 273		; 00000111H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1352 :    stbtt_uint32 cmap, t;
; 1353 :    stbtt_int32 i,numTables;
; 1354 : 
; 1355 :    info->data = data;

  00032	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00038	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1356 :    info->fontstart = fontstart;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _fontstart$[ebp]
  00041	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1357 :    info->cff = stbtt__new_buf(NULL, 0);

  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	8d 85 a4 fd ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	89 8d b8 fd ff
	ff		 mov	 DWORD PTR $T26[ebp], ecx
  0005f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00062	89 95 bc fd ff
	ff		 mov	 DWORD PTR $T26[ebp+4], edx
  00068	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006b	89 85 c0 fd ff
	ff		 mov	 DWORD PTR $T26[ebp+8], eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00074	83 c1 34	 add	 ecx, 52			; 00000034H
  00077	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR $T26[ebp]
  0007d	89 11		 mov	 DWORD PTR [ecx], edx
  0007f	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR $T26[ebp+4]
  00085	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00088	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR $T26[ebp+8]
  0008e	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1358 : 
; 1359 :    cmap = stbtt__find_table(data, fontstart, "cmap");       // required

  00091	68 00 00 00 00	 push	 OFFSET ??_C@_04EICJPCEA@cmap@
  00096	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  00099	50		 push	 eax
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	89 45 f4	 mov	 DWORD PTR _cmap$[ebp], eax

; 1360 :    info->loca = stbtt__find_table(data, fontstart, "loca"); // required

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_04DACNFKGE@loca@
  000ae	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  000b1	50		 push	 eax
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000be	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000c1	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1361 :    info->head = stbtt__find_table(data, fontstart, "head"); // required

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_04NEODDMOL@head@
  000c9	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000dc	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1362 :    info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required

  000df	68 00 00 00 00	 push	 OFFSET ??_C@_04LLIHEPK@glyf@
  000e4	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000f7	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 1363 :    info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required

  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_04FMPHLIKP@hhea@
  000ff	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  00102	50		 push	 eax
  00103	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  0010c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010f	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00112	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 1364 :    info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required

  00115	68 00 00 00 00	 push	 OFFSET ??_C@_04ONMNCIMC@hmtx@
  0011a	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012a	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0012d	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 1365 :    info->kern = stbtt__find_table(data, fontstart, "kern"); // not required

  00130	68 00 00 00 00	 push	 OFFSET ??_C@_04HHMMLDJI@kern@
  00135	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  00138	50		 push	 eax
  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  00142	83 c4 0c	 add	 esp, 12			; 0000000cH
  00145	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00148	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 1366 :    info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_04PCFDEHHD@GPOS@
  00150	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  00153	50		 push	 eax
  00154	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00157	51		 push	 ecx
  00158	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00163	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 1367 : 
; 1368 :    if (!cmap || !info->head || !info->hhea || !info->hmtx)

  00166	83 7d f4 00	 cmp	 DWORD PTR _cmap$[ebp], 0
  0016a	74 1b		 je	 SHORT $LN10@stbtt_Init
  0016c	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0016f	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00173	74 12		 je	 SHORT $LN10@stbtt_Init
  00175	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00178	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0017c	74 09		 je	 SHORT $LN10@stbtt_Init
  0017e	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00181	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00185	75 07		 jne	 SHORT $LN9@stbtt_Init
$LN10@stbtt_Init:

; 1369 :       return 0;

  00187	33 c0		 xor	 eax, eax
  00189	e9 8a 06 00 00	 jmp	 $LN1@stbtt_Init
$LN9@stbtt_Init:

; 1370 :    if (info->glyf) {

  0018e	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00191	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00195	74 15		 je	 SHORT $LN11@stbtt_Init

; 1371 :       // required for truetype
; 1372 :       if (!info->loca) return 0;

  00197	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0019a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0019e	75 07		 jne	 SHORT $LN13@stbtt_Init
  001a0	33 c0		 xor	 eax, eax
  001a2	e9 71 06 00 00	 jmp	 $LN1@stbtt_Init
$LN13@stbtt_Init:

; 1373 :    } else {

  001a7	e9 fd 04 00 00	 jmp	 $LN12@stbtt_Init
$LN11@stbtt_Init:

; 1374 :       // initialization for CFF / Type2 fonts (OTF)
; 1375 :       stbtt__buf b, topdict, topdictidx;
; 1376 :       stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;

  001ac	c7 45 88 02 00
	00 00		 mov	 DWORD PTR _cstype$32[ebp], 2
  001b3	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _charstrings$31[ebp], 0
  001bd	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _fdarrayoff$30[ebp], 0
  001c7	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _fdselectoff$29[ebp], 0

; 1377 :       stbtt_uint32 cff;
; 1378 : 
; 1379 :       cff = stbtt__find_table(data, fontstart, "CFF ");

  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_04HJGCPIEK@CFF?5@
  001d6	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  001d9	50		 push	 eax
  001da	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e6	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cff$28[ebp], eax

; 1380 :       if (!cff) return 0;

  001ec	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR _cff$28[ebp], 0
  001f3	75 07		 jne	 SHORT $LN14@stbtt_Init
  001f5	33 c0		 xor	 eax, eax
  001f7	e9 1c 06 00 00	 jmp	 $LN1@stbtt_Init
$LN14@stbtt_Init:

; 1381 : 
; 1382 :       info->fontdicts = stbtt__new_buf(NULL, 0);

  001fc	6a 00		 push	 0
  001fe	6a 00		 push	 0
  00200	8d 85 7c fd ff
	ff		 lea	 eax, DWORD PTR $T23[ebp]
  00206	50		 push	 eax
  00207	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  0020c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00211	89 8d 90 fd ff
	ff		 mov	 DWORD PTR $T24[ebp], ecx
  00217	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0021a	89 95 94 fd ff
	ff		 mov	 DWORD PTR $T24[ebp+4], edx
  00220	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00223	89 85 98 fd ff
	ff		 mov	 DWORD PTR $T24[ebp+8], eax
  00229	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  0022c	83 c1 64	 add	 ecx, 100		; 00000064H
  0022f	8b 95 90 fd ff
	ff		 mov	 edx, DWORD PTR $T24[ebp]
  00235	89 11		 mov	 DWORD PTR [ecx], edx
  00237	8b 85 94 fd ff
	ff		 mov	 eax, DWORD PTR $T24[ebp+4]
  0023d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00240	8b 95 98 fd ff
	ff		 mov	 edx, DWORD PTR $T24[ebp+8]
  00246	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1383 :       info->fdselect = stbtt__new_buf(NULL, 0);

  00249	6a 00		 push	 0
  0024b	6a 00		 push	 0
  0024d	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  00259	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025e	89 8d 68 fd ff
	ff		 mov	 DWORD PTR $T22[ebp], ecx
  00264	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00267	89 95 6c fd ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  0026d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00270	89 85 70 fd ff
	ff		 mov	 DWORD PTR $T22[ebp+8], eax
  00276	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  00279	83 c1 70	 add	 ecx, 112		; 00000070H
  0027c	8b 95 68 fd ff
	ff		 mov	 edx, DWORD PTR $T22[ebp]
  00282	89 11		 mov	 DWORD PTR [ecx], edx
  00284	8b 85 6c fd ff
	ff		 mov	 eax, DWORD PTR $T22[ebp+4]
  0028a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0028d	8b 95 70 fd ff
	ff		 mov	 edx, DWORD PTR $T22[ebp+8]
  00293	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1384 : 
; 1385 :       // @TODO this should use size from table (not 512MB)
; 1386 :       info->cff = stbtt__new_buf(data+cff, 512*1024*1024);

  00296	68 00 00 00 20	 push	 536870912		; 20000000H
  0029b	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0029e	03 85 58 ff ff
	ff		 add	 eax, DWORD PTR _cff$28[ebp]
  002a4	50		 push	 eax
  002a5	8d 8d 2c fd ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  002ab	51		 push	 ecx
  002ac	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  002b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b4	8b 10		 mov	 edx, DWORD PTR [eax]
  002b6	89 95 40 fd ff
	ff		 mov	 DWORD PTR $T20[ebp], edx
  002bc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002bf	89 8d 44 fd ff
	ff		 mov	 DWORD PTR $T20[ebp+4], ecx
  002c5	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  002c8	89 95 48 fd ff
	ff		 mov	 DWORD PTR $T20[ebp+8], edx
  002ce	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  002d1	83 c0 34	 add	 eax, 52			; 00000034H
  002d4	8b 8d 40 fd ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp]
  002da	89 08		 mov	 DWORD PTR [eax], ecx
  002dc	8b 95 44 fd ff
	ff		 mov	 edx, DWORD PTR $T20[ebp+4]
  002e2	89 50 04	 mov	 DWORD PTR [eax+4], edx
  002e5	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp+8]
  002eb	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1387 :       b = info->cff;

  002ee	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  002f1	83 c0 34	 add	 eax, 52			; 00000034H
  002f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f6	89 4d bc	 mov	 DWORD PTR _b$35[ebp], ecx
  002f9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002fc	89 55 c0	 mov	 DWORD PTR _b$35[ebp+4], edx
  002ff	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00302	89 45 c4	 mov	 DWORD PTR _b$35[ebp+8], eax

; 1388 : 
; 1389 :       // read the header
; 1390 :       stbtt__buf_skip(&b, 2);

  00305	6a 02		 push	 2
  00307	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  00310	83 c4 08	 add	 esp, 8

; 1391 :       stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

  00313	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  00316	50		 push	 eax
  00317	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  0031c	83 c4 04	 add	 esp, 4
  0031f	0f b6 c8	 movzx	 ecx, al
  00322	51		 push	 ecx
  00323	8d 55 bc	 lea	 edx, DWORD PTR _b$35[ebp]
  00326	52		 push	 edx
  00327	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  0032c	83 c4 08	 add	 esp, 8

; 1392 : 
; 1393 :       // @TODO the name INDEX could list multiple fonts,
; 1394 :       // but we just use the first one.
; 1395 :       stbtt__cff_get_index(&b);  // name INDEX

  0032f	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  00332	50		 push	 eax
  00333	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00339	51		 push	 ecx
  0033a	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
  0033f	83 c4 08	 add	 esp, 8
  00342	8b 10		 mov	 edx, DWORD PTR [eax]
  00344	89 95 18 fd ff
	ff		 mov	 DWORD PTR $T18[ebp], edx
  0034a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0034d	89 8d 1c fd ff
	ff		 mov	 DWORD PTR $T18[ebp+4], ecx
  00353	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00356	89 95 20 fd ff
	ff		 mov	 DWORD PTR $T18[ebp+8], edx

; 1396 :       topdictidx = stbtt__cff_get_index(&b);

  0035c	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  0035f	50		 push	 eax
  00360	8d 8d dc fc ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00366	51		 push	 ecx
  00367	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
  0036c	83 c4 08	 add	 esp, 8
  0036f	8b 10		 mov	 edx, DWORD PTR [eax]
  00371	89 95 f0 fc ff
	ff		 mov	 DWORD PTR $T16[ebp], edx
  00377	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0037a	89 8d f4 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+4], ecx
  00380	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00383	89 95 f8 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+8], edx
  00389	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  0038f	89 45 94	 mov	 DWORD PTR _topdictidx$33[ebp], eax
  00392	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp+4]
  00398	89 4d 98	 mov	 DWORD PTR _topdictidx$33[ebp+4], ecx
  0039b	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR $T16[ebp+8]
  003a1	89 55 9c	 mov	 DWORD PTR _topdictidx$33[ebp+8], edx

; 1397 :       topdict = stbtt__cff_index_get(topdictidx, 0);

  003a4	6a 00		 push	 0
  003a6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  003a9	8b c4		 mov	 eax, esp
  003ab	8b 4d 94	 mov	 ecx, DWORD PTR _topdictidx$33[ebp]
  003ae	89 08		 mov	 DWORD PTR [eax], ecx
  003b0	8b 55 98	 mov	 edx, DWORD PTR _topdictidx$33[ebp+4]
  003b3	89 50 04	 mov	 DWORD PTR [eax+4], edx
  003b6	8b 4d 9c	 mov	 ecx, DWORD PTR _topdictidx$33[ebp+8]
  003b9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  003bc	8d 95 b4 fc ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  003c2	52		 push	 edx
  003c3	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  003c8	83 c4 14	 add	 esp, 20			; 00000014H
  003cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003cd	89 8d c8 fc ff
	ff		 mov	 DWORD PTR $T14[ebp], ecx
  003d3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003d6	89 95 cc fc ff
	ff		 mov	 DWORD PTR $T14[ebp+4], edx
  003dc	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  003df	89 85 d0 fc ff
	ff		 mov	 DWORD PTR $T14[ebp+8], eax
  003e5	8b 8d c8 fc ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  003eb	89 4d a8	 mov	 DWORD PTR _topdict$34[ebp], ecx
  003ee	8b 95 cc fc ff
	ff		 mov	 edx, DWORD PTR $T14[ebp+4]
  003f4	89 55 ac	 mov	 DWORD PTR _topdict$34[ebp+4], edx
  003f7	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR $T14[ebp+8]
  003fd	89 45 b0	 mov	 DWORD PTR _topdict$34[ebp+8], eax

; 1398 :       stbtt__cff_get_index(&b);  // string INDEX

  00400	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  00403	50		 push	 eax
  00404	8d 8d 8c fc ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0040a	51		 push	 ecx
  0040b	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
  00410	83 c4 08	 add	 esp, 8
  00413	8b 10		 mov	 edx, DWORD PTR [eax]
  00415	89 95 a0 fc ff
	ff		 mov	 DWORD PTR $T12[ebp], edx
  0041b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0041e	89 8d a4 fc ff
	ff		 mov	 DWORD PTR $T12[ebp+4], ecx
  00424	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00427	89 95 a8 fc ff
	ff		 mov	 DWORD PTR $T12[ebp+8], edx

; 1399 :       info->gsubrs = stbtt__cff_get_index(&b);

  0042d	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  00430	50		 push	 eax
  00431	8d 8d 64 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00437	51		 push	 ecx
  00438	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
  0043d	83 c4 08	 add	 esp, 8
  00440	8b 10		 mov	 edx, DWORD PTR [eax]
  00442	89 95 78 fc ff
	ff		 mov	 DWORD PTR $T10[ebp], edx
  00448	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0044b	89 8d 7c fc ff
	ff		 mov	 DWORD PTR $T10[ebp+4], ecx
  00451	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00454	89 95 80 fc ff
	ff		 mov	 DWORD PTR $T10[ebp+8], edx
  0045a	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0045d	83 c0 4c	 add	 eax, 76			; 0000004cH
  00460	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  00466	89 08		 mov	 DWORD PTR [eax], ecx
  00468	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR $T10[ebp+4]
  0046e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00471	8b 8d 80 fc ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp+8]
  00477	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1400 : 
; 1401 :       stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);

  0047a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _charstrings$31[ebp]
  00480	50		 push	 eax
  00481	6a 01		 push	 1
  00483	6a 11		 push	 17			; 00000011H
  00485	8d 4d a8	 lea	 ecx, DWORD PTR _topdict$34[ebp]
  00488	51		 push	 ecx
  00489	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints
  0048e	83 c4 10	 add	 esp, 16			; 00000010H

; 1402 :       stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);

  00491	8d 45 88	 lea	 eax, DWORD PTR _cstype$32[ebp]
  00494	50		 push	 eax
  00495	6a 01		 push	 1
  00497	68 06 01 00 00	 push	 262			; 00000106H
  0049c	8d 4d a8	 lea	 ecx, DWORD PTR _topdict$34[ebp]
  0049f	51		 push	 ecx
  004a0	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints
  004a5	83 c4 10	 add	 esp, 16			; 00000010H

; 1403 :       stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);

  004a8	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _fdarrayoff$30[ebp]
  004ae	50		 push	 eax
  004af	6a 01		 push	 1
  004b1	68 24 01 00 00	 push	 292			; 00000124H
  004b6	8d 4d a8	 lea	 ecx, DWORD PTR _topdict$34[ebp]
  004b9	51		 push	 ecx
  004ba	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints
  004bf	83 c4 10	 add	 esp, 16			; 00000010H

; 1404 :       stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);

  004c2	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _fdselectoff$29[ebp]
  004c8	50		 push	 eax
  004c9	6a 01		 push	 1
  004cb	68 25 01 00 00	 push	 293			; 00000125H
  004d0	8d 4d a8	 lea	 ecx, DWORD PTR _topdict$34[ebp]
  004d3	51		 push	 ecx
  004d4	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints
  004d9	83 c4 10	 add	 esp, 16			; 00000010H

; 1405 :       info->subrs = stbtt__get_subrs(b, topdict);

  004dc	83 ec 0c	 sub	 esp, 12			; 0000000cH
  004df	8b c4		 mov	 eax, esp
  004e1	8b 4d a8	 mov	 ecx, DWORD PTR _topdict$34[ebp]
  004e4	89 08		 mov	 DWORD PTR [eax], ecx
  004e6	8b 55 ac	 mov	 edx, DWORD PTR _topdict$34[ebp+4]
  004e9	89 50 04	 mov	 DWORD PTR [eax+4], edx
  004ec	8b 4d b0	 mov	 ecx, DWORD PTR _topdict$34[ebp+8]
  004ef	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  004f2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  004f5	8b d4		 mov	 edx, esp
  004f7	8b 45 bc	 mov	 eax, DWORD PTR _b$35[ebp]
  004fa	89 02		 mov	 DWORD PTR [edx], eax
  004fc	8b 4d c0	 mov	 ecx, DWORD PTR _b$35[ebp+4]
  004ff	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00502	8b 45 c4	 mov	 eax, DWORD PTR _b$35[ebp+8]
  00505	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00508	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0050e	51		 push	 ecx
  0050f	e8 00 00 00 00	 call	 ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
  00514	83 c4 1c	 add	 esp, 28			; 0000001cH
  00517	8b 10		 mov	 edx, DWORD PTR [eax]
  00519	89 95 50 fc ff
	ff		 mov	 DWORD PTR $T8[ebp], edx
  0051f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00522	89 8d 54 fc ff
	ff		 mov	 DWORD PTR $T8[ebp+4], ecx
  00528	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0052b	89 95 58 fc ff
	ff		 mov	 DWORD PTR $T8[ebp+8], edx
  00531	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00534	83 c0 58	 add	 eax, 88			; 00000058H
  00537	8b 8d 50 fc ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  0053d	89 08		 mov	 DWORD PTR [eax], ecx
  0053f	8b 95 54 fc ff
	ff		 mov	 edx, DWORD PTR $T8[ebp+4]
  00545	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00548	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp+8]
  0054e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1406 : 
; 1407 :       // we only support Type 2 charstrings
; 1408 :       if (cstype != 2) return 0;

  00551	83 7d 88 02	 cmp	 DWORD PTR _cstype$32[ebp], 2
  00555	74 07		 je	 SHORT $LN15@stbtt_Init
  00557	33 c0		 xor	 eax, eax
  00559	e9 ba 02 00 00	 jmp	 $LN1@stbtt_Init
$LN15@stbtt_Init:

; 1409 :       if (charstrings == 0) return 0;

  0055e	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR _charstrings$31[ebp], 0
  00565	75 07		 jne	 SHORT $LN16@stbtt_Init
  00567	33 c0		 xor	 eax, eax
  00569	e9 aa 02 00 00	 jmp	 $LN1@stbtt_Init
$LN16@stbtt_Init:

; 1410 : 
; 1411 :       if (fdarrayoff) {

  0056e	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _fdarrayoff$30[ebp], 0
  00575	0f 84 ce 00 00
	00		 je	 $LN17@stbtt_Init

; 1412 :          // looks like a CID font
; 1413 :          if (!fdselectoff) return 0;

  0057b	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _fdselectoff$29[ebp], 0
  00582	75 07		 jne	 SHORT $LN18@stbtt_Init
  00584	33 c0		 xor	 eax, eax
  00586	e9 8d 02 00 00	 jmp	 $LN1@stbtt_Init
$LN18@stbtt_Init:

; 1414 :          stbtt__buf_seek(&b, fdarrayoff);

  0058b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _fdarrayoff$30[ebp]
  00591	50		 push	 eax
  00592	8d 4d bc	 lea	 ecx, DWORD PTR _b$35[ebp]
  00595	51		 push	 ecx
  00596	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  0059b	83 c4 08	 add	 esp, 8

; 1415 :          info->fontdicts = stbtt__cff_get_index(&b);

  0059e	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  005a1	50		 push	 eax
  005a2	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  005a8	51		 push	 ecx
  005a9	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
  005ae	83 c4 08	 add	 esp, 8
  005b1	8b 10		 mov	 edx, DWORD PTR [eax]
  005b3	89 95 28 fc ff
	ff		 mov	 DWORD PTR $T6[ebp], edx
  005b9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005bc	89 8d 2c fc ff
	ff		 mov	 DWORD PTR $T6[ebp+4], ecx
  005c2	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  005c5	89 95 30 fc ff
	ff		 mov	 DWORD PTR $T6[ebp+8], edx
  005cb	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  005ce	83 c0 64	 add	 eax, 100		; 00000064H
  005d1	8b 8d 28 fc ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  005d7	89 08		 mov	 DWORD PTR [eax], ecx
  005d9	8b 95 2c fc ff
	ff		 mov	 edx, DWORD PTR $T6[ebp+4]
  005df	89 50 04	 mov	 DWORD PTR [eax+4], edx
  005e2	8b 8d 30 fc ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp+8]
  005e8	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1416 :          info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);

  005eb	8b 45 c4	 mov	 eax, DWORD PTR _b$35[ebp+8]
  005ee	2b 85 64 ff ff
	ff		 sub	 eax, DWORD PTR _fdselectoff$29[ebp]
  005f4	50		 push	 eax
  005f5	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _fdselectoff$29[ebp]
  005fb	51		 push	 ecx
  005fc	8d 55 bc	 lea	 edx, DWORD PTR _b$35[ebp]
  005ff	52		 push	 edx
  00600	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
  0060c	83 c4 10	 add	 esp, 16			; 00000010H
  0060f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00611	89 8d 00 fc ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  00617	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0061a	89 95 04 fc ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  00620	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00623	89 85 08 fc ff
	ff		 mov	 DWORD PTR $T4[ebp+8], eax
  00629	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  0062c	83 c1 70	 add	 ecx, 112		; 00000070H
  0062f	8b 95 00 fc ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  00635	89 11		 mov	 DWORD PTR [ecx], edx
  00637	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+4]
  0063d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00640	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+8]
  00646	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN17@stbtt_Init:

; 1417 :       }
; 1418 : 
; 1419 :       stbtt__buf_seek(&b, charstrings);

  00649	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _charstrings$31[ebp]
  0064f	50		 push	 eax
  00650	8d 4d bc	 lea	 ecx, DWORD PTR _b$35[ebp]
  00653	51		 push	 ecx
  00654	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  00659	83 c4 08	 add	 esp, 8

; 1420 :       info->charstrings = stbtt__cff_get_index(&b);

  0065c	8d 45 bc	 lea	 eax, DWORD PTR _b$35[ebp]
  0065f	50		 push	 eax
  00660	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00666	51		 push	 ecx
  00667	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
  0066c	83 c4 08	 add	 esp, 8
  0066f	8b 10		 mov	 edx, DWORD PTR [eax]
  00671	89 95 d8 fb ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  00677	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0067a	89 8d dc fb ff
	ff		 mov	 DWORD PTR $T2[ebp+4], ecx
  00680	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00683	89 95 e0 fb ff
	ff		 mov	 DWORD PTR $T2[ebp+8], edx
  00689	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0068c	83 c0 40	 add	 eax, 64			; 00000040H
  0068f	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00695	89 08		 mov	 DWORD PTR [eax], ecx
  00697	8b 95 dc fb ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  0069d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  006a0	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+8]
  006a6	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN12@stbtt_Init:

; 1421 :    }
; 1422 : 
; 1423 :    t = stbtt__find_table(data, fontstart, "maxp");

  006a9	68 00 00 00 00	 push	 OFFSET ??_C@_04KODIGLGG@maxp@
  006ae	8b 45 10	 mov	 eax, DWORD PTR _fontstart$[ebp]
  006b1	50		 push	 eax
  006b2	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  006b5	51		 push	 ecx
  006b6	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPAEIPBD@Z ; stbtt__find_table
  006bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  006be	89 45 e8	 mov	 DWORD PTR _t$[ebp], eax

; 1424 :    if (t)

  006c1	83 7d e8 00	 cmp	 DWORD PTR _t$[ebp], 0
  006c5	74 1e		 je	 SHORT $LN19@stbtt_Init

; 1425 :       info->numGlyphs = ttUSHORT(data+t+4);

  006c7	8b 45 e8	 mov	 eax, DWORD PTR _t$[ebp]
  006ca	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  006cd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  006d1	52		 push	 edx
  006d2	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  006d7	83 c4 04	 add	 esp, 4
  006da	0f b7 c0	 movzx	 eax, ax
  006dd	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  006e0	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  006e3	eb 0a		 jmp	 SHORT $LN20@stbtt_Init
$LN19@stbtt_Init:

; 1426 :    else
; 1427 :       info->numGlyphs = 0xffff;

  006e5	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  006e8	c7 40 0c ff ff
	00 00		 mov	 DWORD PTR [eax+12], 65535 ; 0000ffffH
$LN20@stbtt_Init:

; 1428 : 
; 1429 :    // find a cmap encoding table we understand *now* to avoid searching
; 1430 :    // later. (todo: could make this installable)
; 1431 :    // the same regardless of glyph.
; 1432 :    numTables = ttUSHORT(data + cmap + 2);

  006ef	8b 45 f4	 mov	 eax, DWORD PTR _cmap$[ebp]
  006f2	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  006f5	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  006f9	52		 push	 edx
  006fa	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  006ff	83 c4 04	 add	 esp, 4
  00702	0f b7 c0	 movzx	 eax, ax
  00705	89 45 d0	 mov	 DWORD PTR _numTables$[ebp], eax

; 1433 :    info->index_map = 0;

  00708	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0070b	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 1434 :    for (i=0; i < numTables; ++i) {

  00712	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00719	eb 09		 jmp	 SHORT $LN4@stbtt_Init
$LN2@stbtt_Init:
  0071b	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  0071e	83 c0 01	 add	 eax, 1
  00721	89 45 dc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt_Init:
  00724	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00727	3b 45 d0	 cmp	 eax, DWORD PTR _numTables$[ebp]
  0072a	0f 8d b7 00 00
	00		 jge	 $LN3@stbtt_Init

; 1435 :       stbtt_uint32 encoding_record = cmap + 4 + 8 * i;

  00730	8b 45 dc	 mov	 eax, DWORD PTR _i$[ebp]
  00733	8b 4d f4	 mov	 ecx, DWORD PTR _cmap$[ebp]
  00736	8d 54 c1 04	 lea	 edx, DWORD PTR [ecx+eax*8+4]
  0073a	89 95 4c ff ff
	ff		 mov	 DWORD PTR _encoding_record$27[ebp], edx

; 1436 :       // find an encoding we understand:
; 1437 :       switch(ttUSHORT(data+encoding_record)) {

  00740	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  00743	03 85 4c ff ff
	ff		 add	 eax, DWORD PTR _encoding_record$27[ebp]
  00749	50		 push	 eax
  0074a	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  0074f	83 c4 04	 add	 esp, 4
  00752	0f b7 c8	 movzx	 ecx, ax
  00755	89 8d bc fb ff
	ff		 mov	 DWORD PTR tv316[ebp], ecx
  0075b	83 bd bc fb ff
	ff 00		 cmp	 DWORD PTR tv316[ebp], 0
  00762	74 5f		 je	 SHORT $LN23@stbtt_Init
  00764	83 bd bc fb ff
	ff 03		 cmp	 DWORD PTR tv316[ebp], 3
  0076b	74 02		 je	 SHORT $LN21@stbtt_Init
  0076d	eb 73		 jmp	 SHORT $LN5@stbtt_Init
$LN21@stbtt_Init:

; 1438 :          case STBTT_PLATFORM_ID_MICROSOFT:
; 1439 :             switch (ttUSHORT(data+encoding_record+2)) {

  0076f	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _encoding_record$27[ebp]
  00775	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  00778	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  0077c	52		 push	 edx
  0077d	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00782	83 c4 04	 add	 esp, 4
  00785	0f b7 c0	 movzx	 eax, ax
  00788	89 85 bc fb ff
	ff		 mov	 DWORD PTR tv322[ebp], eax
  0078e	83 bd bc fb ff
	ff 01		 cmp	 DWORD PTR tv322[ebp], 1
  00795	74 0b		 je	 SHORT $LN22@stbtt_Init
  00797	83 bd bc fb ff
	ff 0a		 cmp	 DWORD PTR tv322[ebp], 10 ; 0000000aH
  0079e	74 02		 je	 SHORT $LN22@stbtt_Init
  007a0	eb 1f		 jmp	 SHORT $LN7@stbtt_Init
$LN22@stbtt_Init:

; 1440 :                case STBTT_MS_EID_UNICODE_BMP:
; 1441 :                case STBTT_MS_EID_UNICODE_FULL:
; 1442 :                   // MS/Unicode
; 1443 :                   info->index_map = cmap + ttULONG(data+encoding_record+4);

  007a2	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _encoding_record$27[ebp]
  007a8	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  007ab	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  007af	52		 push	 edx
  007b0	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  007b5	83 c4 04	 add	 esp, 4
  007b8	03 45 f4	 add	 eax, DWORD PTR _cmap$[ebp]
  007bb	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  007be	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN7@stbtt_Init:

; 1444 :                   break;
; 1445 :             }
; 1446 :             break;

  007c1	eb 1f		 jmp	 SHORT $LN5@stbtt_Init
$LN23@stbtt_Init:

; 1447 :         case STBTT_PLATFORM_ID_UNICODE:
; 1448 :             // Mac/iOS has these
; 1449 :             // all the encodingIDs are unicode, so we don't bother to check it
; 1450 :             info->index_map = cmap + ttULONG(data+encoding_record+4);

  007c3	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _encoding_record$27[ebp]
  007c9	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  007cc	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  007d0	52		 push	 edx
  007d1	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  007d6	83 c4 04	 add	 esp, 4
  007d9	03 45 f4	 add	 eax, DWORD PTR _cmap$[ebp]
  007dc	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  007df	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN5@stbtt_Init:

; 1451 :             break;
; 1452 :       }
; 1453 :    }

  007e2	e9 34 ff ff ff	 jmp	 $LN2@stbtt_Init
$LN3@stbtt_Init:

; 1454 :    if (info->index_map == 0)

  007e7	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  007ea	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  007ee	75 04		 jne	 SHORT $LN24@stbtt_Init

; 1455 :       return 0;

  007f0	33 c0		 xor	 eax, eax
  007f2	eb 24		 jmp	 SHORT $LN1@stbtt_Init
$LN24@stbtt_Init:

; 1456 : 
; 1457 :    info->indexToLocFormat = ttUSHORT(data+info->head + 50);

  007f4	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  007f7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  007fa	8b 55 0c	 mov	 edx, DWORD PTR _data$[ebp]
  007fd	8d 44 0a 32	 lea	 eax, DWORD PTR [edx+ecx+50]
  00801	50		 push	 eax
  00802	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00807	83 c4 04	 add	 esp, 4
  0080a	0f b7 c8	 movzx	 ecx, ax
  0080d	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00810	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 1458 :    return 1;

  00813	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_Init:

; 1459 : }

  00818	52		 push	 edx
  00819	8b cd		 mov	 ecx, ebp
  0081b	50		 push	 eax
  0081c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN34@stbtt_Init
  00822	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00827	58		 pop	 eax
  00828	5a		 pop	 edx
  00829	5f		 pop	 edi
  0082a	5e		 pop	 esi
  0082b	5b		 pop	 ebx
  0082c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0082f	33 cd		 xor	 ecx, ebp
  00831	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00836	81 c4 44 04 00
	00		 add	 esp, 1092		; 00000444H
  0083c	3b ec		 cmp	 ebp, esp
  0083e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00843	8b e5		 mov	 esp, ebp
  00845	5d		 pop	 ebp
  00846	c3		 ret	 0
  00847	90		 npad	 1
$LN34@stbtt_Init:
  00848	07 00 00 00	 DD	 7
  0084c	00 00 00 00	 DD	 $LN33@stbtt_Init
$LN33@stbtt_Init:
  00850	bc ff ff ff	 DD	 -68			; ffffffbcH
  00854	0c 00 00 00	 DD	 12			; 0000000cH
  00858	00 00 00 00	 DD	 $LN26@stbtt_Init
  0085c	a8 ff ff ff	 DD	 -88			; ffffffa8H
  00860	0c 00 00 00	 DD	 12			; 0000000cH
  00864	00 00 00 00	 DD	 $LN27@stbtt_Init
  00868	94 ff ff ff	 DD	 -108			; ffffff94H
  0086c	0c 00 00 00	 DD	 12			; 0000000cH
  00870	00 00 00 00	 DD	 $LN28@stbtt_Init
  00874	88 ff ff ff	 DD	 -120			; ffffff88H
  00878	04 00 00 00	 DD	 4
  0087c	00 00 00 00	 DD	 $LN29@stbtt_Init
  00880	7c ff ff ff	 DD	 -132			; ffffff7cH
  00884	04 00 00 00	 DD	 4
  00888	00 00 00 00	 DD	 $LN30@stbtt_Init
  0088c	70 ff ff ff	 DD	 -144			; ffffff70H
  00890	04 00 00 00	 DD	 4
  00894	00 00 00 00	 DD	 $LN31@stbtt_Init
  00898	64 ff ff ff	 DD	 -156			; ffffff64H
  0089c	04 00 00 00	 DD	 4
  008a0	00 00 00 00	 DD	 $LN32@stbtt_Init
$LN32@stbtt_Init:
  008a4	66		 DB	 102			; 00000066H
  008a5	64		 DB	 100			; 00000064H
  008a6	73		 DB	 115			; 00000073H
  008a7	65		 DB	 101			; 00000065H
  008a8	6c		 DB	 108			; 0000006cH
  008a9	65		 DB	 101			; 00000065H
  008aa	63		 DB	 99			; 00000063H
  008ab	74		 DB	 116			; 00000074H
  008ac	6f		 DB	 111			; 0000006fH
  008ad	66		 DB	 102			; 00000066H
  008ae	66		 DB	 102			; 00000066H
  008af	00		 DB	 0
$LN31@stbtt_Init:
  008b0	66		 DB	 102			; 00000066H
  008b1	64		 DB	 100			; 00000064H
  008b2	61		 DB	 97			; 00000061H
  008b3	72		 DB	 114			; 00000072H
  008b4	72		 DB	 114			; 00000072H
  008b5	61		 DB	 97			; 00000061H
  008b6	79		 DB	 121			; 00000079H
  008b7	6f		 DB	 111			; 0000006fH
  008b8	66		 DB	 102			; 00000066H
  008b9	66		 DB	 102			; 00000066H
  008ba	00		 DB	 0
$LN30@stbtt_Init:
  008bb	63		 DB	 99			; 00000063H
  008bc	68		 DB	 104			; 00000068H
  008bd	61		 DB	 97			; 00000061H
  008be	72		 DB	 114			; 00000072H
  008bf	73		 DB	 115			; 00000073H
  008c0	74		 DB	 116			; 00000074H
  008c1	72		 DB	 114			; 00000072H
  008c2	69		 DB	 105			; 00000069H
  008c3	6e		 DB	 110			; 0000006eH
  008c4	67		 DB	 103			; 00000067H
  008c5	73		 DB	 115			; 00000073H
  008c6	00		 DB	 0
$LN29@stbtt_Init:
  008c7	63		 DB	 99			; 00000063H
  008c8	73		 DB	 115			; 00000073H
  008c9	74		 DB	 116			; 00000074H
  008ca	79		 DB	 121			; 00000079H
  008cb	70		 DB	 112			; 00000070H
  008cc	65		 DB	 101			; 00000065H
  008cd	00		 DB	 0
$LN28@stbtt_Init:
  008ce	74		 DB	 116			; 00000074H
  008cf	6f		 DB	 111			; 0000006fH
  008d0	70		 DB	 112			; 00000070H
  008d1	64		 DB	 100			; 00000064H
  008d2	69		 DB	 105			; 00000069H
  008d3	63		 DB	 99			; 00000063H
  008d4	74		 DB	 116			; 00000074H
  008d5	69		 DB	 105			; 00000069H
  008d6	64		 DB	 100			; 00000064H
  008d7	78		 DB	 120			; 00000078H
  008d8	00		 DB	 0
$LN27@stbtt_Init:
  008d9	74		 DB	 116			; 00000074H
  008da	6f		 DB	 111			; 0000006fH
  008db	70		 DB	 112			; 00000070H
  008dc	64		 DB	 100			; 00000064H
  008dd	69		 DB	 105			; 00000069H
  008de	63		 DB	 99			; 00000063H
  008df	74		 DB	 116			; 00000074H
  008e0	00		 DB	 0
$LN26@stbtt_Init:
  008e1	62		 DB	 98			; 00000062H
  008e2	00		 DB	 0
?stbtt_InitFont_internal@@YAHPAUstbtt_fontinfo@@PAEH@Z ENDP ; stbtt_InitFont_internal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
_TEXT	SEGMENT
$T1 = -400						; size = 12
$T2 = -380						; size = 12
$T3 = -360						; size = 12
$T4 = -340						; size = 12
$T5 = -320						; size = 12
$T6 = -300						; size = 12
$T7 = -280						; size = 12
$T8 = -260						; size = 12
_pdict$ = -48						; size = 12
_private_loc$ = -28					; size = 8
_subrsoff$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
$T9 = 8							; size = 4
_cff$ = 12						; size = 12
_fontdict$ = 24						; size = 12
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z PROC		; stbtt__get_subrs, COMDAT

; 1338 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00012	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1339 :    stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _subrsoff$[ebp], 0
  00039	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _private_loc$[ebp], 0
  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _private_loc$[ebp+4], 0

; 1340 :    stbtt__buf pdict;
; 1341 :    stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);

  00047	8d 45 e4	 lea	 eax, DWORD PTR _private_loc$[ebp]
  0004a	50		 push	 eax
  0004b	6a 02		 push	 2
  0004d	6a 12		 push	 18			; 00000012H
  0004f	8d 4d 18	 lea	 ecx, DWORD PTR _fontdict$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 1342 :    if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);

  0005b	b8 04 00 00 00	 mov	 eax, 4
  00060	c1 e0 00	 shl	 eax, 0
  00063	83 7c 05 e4 00	 cmp	 DWORD PTR _private_loc$[ebp+eax], 0
  00068	74 0f		 je	 SHORT $LN3@stbtt__get
  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	6b c8 00	 imul	 ecx, eax, 0
  00072	83 7c 0d e4 00	 cmp	 DWORD PTR _private_loc$[ebp+ecx], 0
  00077	75 52		 jne	 SHORT $LN2@stbtt__get
$LN3@stbtt__get:
  00079	6a 00		 push	 0
  0007b	6a 00		 push	 0
  0007d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	89 8d fc fe ff
	ff		 mov	 DWORD PTR $T8[ebp], ecx
  00094	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00097	89 95 00 ff ff
	ff		 mov	 DWORD PTR $T8[ebp+4], edx
  0009d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a0	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T8[ebp+8], eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR $T9[ebp]
  000a9	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR $T8[ebp]
  000af	89 11		 mov	 DWORD PTR [ecx], edx
  000b1	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp+4]
  000b7	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000ba	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR $T8[ebp+8]
  000c0	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000c3	8b 45 08	 mov	 eax, DWORD PTR $T9[ebp]
  000c6	e9 34 01 00 00	 jmp	 $LN1@stbtt__get
$LN2@stbtt__get:

; 1343 :    pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

  000cb	b8 04 00 00 00	 mov	 eax, 4
  000d0	6b c8 00	 imul	 ecx, eax, 0
  000d3	8b 54 0d e4	 mov	 edx, DWORD PTR _private_loc$[ebp+ecx]
  000d7	52		 push	 edx
  000d8	b8 04 00 00 00	 mov	 eax, 4
  000dd	c1 e0 00	 shl	 eax, 0
  000e0	8b 4c 05 e4	 mov	 ecx, DWORD PTR _private_loc$[ebp+eax]
  000e4	51		 push	 ecx
  000e5	8d 55 0c	 lea	 edx, DWORD PTR _cff$[ebp]
  000e8	52		 push	 edx
  000e9	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
  000f5	83 c4 10	 add	 esp, 16			; 00000010H
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	89 8d d4 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  00100	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00103	89 95 d8 fe ff
	ff		 mov	 DWORD PTR $T6[ebp+4], edx
  00109	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0010c	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T6[ebp+8], eax
  00112	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  00118	89 4d d0	 mov	 DWORD PTR _pdict$[ebp], ecx
  0011b	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR $T6[ebp+4]
  00121	89 55 d4	 mov	 DWORD PTR _pdict$[ebp+4], edx
  00124	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+8]
  0012a	89 45 d8	 mov	 DWORD PTR _pdict$[ebp+8], eax

; 1344 :    stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);

  0012d	8d 45 f4	 lea	 eax, DWORD PTR _subrsoff$[ebp]
  00130	50		 push	 eax
  00131	6a 01		 push	 1
  00133	6a 13		 push	 19			; 00000013H
  00135	8d 4d d0	 lea	 ecx, DWORD PTR _pdict$[ebp]
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 ?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints
  0013e	83 c4 10	 add	 esp, 16			; 00000010H

; 1345 :    if (!subrsoff) return stbtt__new_buf(NULL, 0);

  00141	83 7d f4 00	 cmp	 DWORD PTR _subrsoff$[ebp], 0
  00145	75 4f		 jne	 SHORT $LN4@stbtt__get
  00147	6a 00		 push	 0
  00149	6a 00		 push	 0
  0014b	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015c	89 8d ac fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  00162	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00165	89 95 b0 fe ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  0016b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0016e	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp+8], eax
  00174	8b 4d 08	 mov	 ecx, DWORD PTR $T9[ebp]
  00177	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  0017d	89 11		 mov	 DWORD PTR [ecx], edx
  0017f	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+4]
  00185	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00188	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+8]
  0018e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00191	8b 45 08	 mov	 eax, DWORD PTR $T9[ebp]
  00194	eb 69		 jmp	 SHORT $LN1@stbtt__get
$LN4@stbtt__get:

; 1346 :    stbtt__buf_seek(&cff, private_loc[1]+subrsoff);

  00196	b8 04 00 00 00	 mov	 eax, 4
  0019b	c1 e0 00	 shl	 eax, 0
  0019e	8b 4c 05 e4	 mov	 ecx, DWORD PTR _private_loc$[ebp+eax]
  001a2	03 4d f4	 add	 ecx, DWORD PTR _subrsoff$[ebp]
  001a5	51		 push	 ecx
  001a6	8d 55 0c	 lea	 edx, DWORD PTR _cff$[ebp]
  001a9	52		 push	 edx
  001aa	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  001af	83 c4 08	 add	 esp, 8

; 1347 :    return stbtt__cff_get_index(&cff);

  001b2	8d 45 0c	 lea	 eax, DWORD PTR _cff$[ebp]
  001b5	50		 push	 eax
  001b6	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001bc	51		 push	 ecx
  001bd	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
  001c2	83 c4 08	 add	 esp, 8
  001c5	8b 10		 mov	 edx, DWORD PTR [eax]
  001c7	89 95 84 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  001cd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d0	89 8d 88 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], ecx
  001d6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001d9	89 95 8c fe ff
	ff		 mov	 DWORD PTR $T2[ebp+8], edx
  001df	8b 45 08	 mov	 eax, DWORD PTR $T9[ebp]
  001e2	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  001e8	89 08		 mov	 DWORD PTR [eax], ecx
  001ea	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  001f0	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001f3	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+8]
  001f9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001fc	8b 45 08	 mov	 eax, DWORD PTR $T9[ebp]
$LN1@stbtt__get:

; 1348 : }

  001ff	52		 push	 edx
  00200	8b cd		 mov	 ecx, ebp
  00202	50		 push	 eax
  00203	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@stbtt__get
  00209	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0020e	58		 pop	 eax
  0020f	5a		 pop	 edx
  00210	5f		 pop	 edi
  00211	5e		 pop	 esi
  00212	5b		 pop	 ebx
  00213	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00216	33 cd		 xor	 ecx, ebp
  00218	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021d	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  00223	3b ec		 cmp	 ebp, esp
  00225	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022a	8b e5		 mov	 esp, ebp
  0022c	5d		 pop	 ebp
  0022d	c3		 ret	 0
  0022e	66 90		 npad	 2
$LN10@stbtt__get:
  00230	03 00 00 00	 DD	 3
  00234	00 00 00 00	 DD	 $LN9@stbtt__get
$LN9@stbtt__get:
  00238	f4 ff ff ff	 DD	 -12			; fffffff4H
  0023c	04 00 00 00	 DD	 4
  00240	00 00 00 00	 DD	 $LN6@stbtt__get
  00244	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00248	08 00 00 00	 DD	 8
  0024c	00 00 00 00	 DD	 $LN7@stbtt__get
  00250	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00254	0c 00 00 00	 DD	 12			; 0000000cH
  00258	00 00 00 00	 DD	 $LN8@stbtt__get
$LN8@stbtt__get:
  0025c	70		 DB	 112			; 00000070H
  0025d	64		 DB	 100			; 00000064H
  0025e	69		 DB	 105			; 00000069H
  0025f	63		 DB	 99			; 00000063H
  00260	74		 DB	 116			; 00000074H
  00261	00		 DB	 0
$LN7@stbtt__get:
  00262	70		 DB	 112			; 00000070H
  00263	72		 DB	 114			; 00000072H
  00264	69		 DB	 105			; 00000069H
  00265	76		 DB	 118			; 00000076H
  00266	61		 DB	 97			; 00000061H
  00267	74		 DB	 116			; 00000074H
  00268	65		 DB	 101			; 00000065H
  00269	5f		 DB	 95			; 0000005fH
  0026a	6c		 DB	 108			; 0000006cH
  0026b	6f		 DB	 111			; 0000006fH
  0026c	63		 DB	 99			; 00000063H
  0026d	00		 DB	 0
$LN6@stbtt__get:
  0026e	73		 DB	 115			; 00000073H
  0026f	75		 DB	 117			; 00000075H
  00270	62		 DB	 98			; 00000062H
  00271	72		 DB	 114			; 00000072H
  00272	73		 DB	 115			; 00000073H
  00273	6f		 DB	 111			; 0000006fH
  00274	66		 DB	 102			; 00000066H
  00275	66		 DB	 102			; 00000066H
  00276	00		 DB	 0
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ENDP		; stbtt__get_subrs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt_GetFontOffsetForIndex_internal@@YAHPAEH@Z
_TEXT	SEGMENT
tv68 = -208						; size = 4
_n$1 = -8						; size = 4
_font_collection$ = 8					; size = 4
_index$ = 12						; size = 4
?stbtt_GetFontOffsetForIndex_internal@@YAHPAEH@Z PROC	; stbtt_GetFontOffsetForIndex_internal, COMDAT

; 1303 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1304 :    // if it's just a font, there's only one valid index
; 1305 :    if (stbtt__isfont(font_collection))

  00028	8b 45 08	 mov	 eax, DWORD PTR _font_collection$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?stbtt__isfont@@YAHPAE@Z ; stbtt__isfont
  00031	83 c4 04	 add	 esp, 4
  00034	85 c0		 test	 eax, eax
  00036	74 27		 je	 SHORT $LN2@stbtt_GetF

; 1306 :       return index == 0 ? 0 : -1;

  00038	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  0003c	75 0c		 jne	 SHORT $LN8@stbtt_GetF
  0003e	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00048	eb 0a		 jmp	 SHORT $LN9@stbtt_GetF
$LN8@stbtt_GetF:
  0004a	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv68[ebp], -1
$LN9@stbtt_GetF:
  00054	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]
  0005a	e9 f5 00 00 00	 jmp	 $LN1@stbtt_GetF
$LN2@stbtt_GetF:

; 1307 : 
; 1308 :    // check if it's a TTC
; 1309 :    if (stbtt_tag(font_collection, "ttcf")) {

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	6b c8 00	 imul	 ecx, eax, 0
  00067	8b 55 08	 mov	 edx, DWORD PTR _font_collection$[ebp]
  0006a	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	6b d1 00	 imul	 edx, ecx, 0
  00076	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04KIOEMAHO@ttcf@[edx]
  0007d	3b c1		 cmp	 eax, ecx
  0007f	0f 85 cc 00 00
	00		 jne	 $LN3@stbtt_GetF
  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	c1 e0 00	 shl	 eax, 0
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _font_collection$[ebp]
  00090	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	c1 e0 00	 shl	 eax, 0
  0009c	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04KIOEMAHO@ttcf@[eax]
  000a3	3b d1		 cmp	 edx, ecx
  000a5	0f 85 a6 00 00
	00		 jne	 $LN3@stbtt_GetF
  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	d1 e0		 shl	 eax, 1
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR _font_collection$[ebp]
  000b5	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	d1 e0		 shl	 eax, 1
  000c0	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04KIOEMAHO@ttcf@[eax]
  000c7	3b d1		 cmp	 edx, ecx
  000c9	0f 85 82 00 00
	00		 jne	 $LN3@stbtt_GetF
  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	6b c8 03	 imul	 ecx, eax, 3
  000d7	8b 55 08	 mov	 edx, DWORD PTR _font_collection$[ebp]
  000da	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000de	b9 01 00 00 00	 mov	 ecx, 1
  000e3	6b d1 03	 imul	 edx, ecx, 3
  000e6	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04KIOEMAHO@ttcf@[edx]
  000ed	3b c1		 cmp	 eax, ecx
  000ef	75 60		 jne	 SHORT $LN3@stbtt_GetF

; 1310 :       // version 1?
; 1311 :       if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {

  000f1	8b 45 08	 mov	 eax, DWORD PTR _font_collection$[ebp]
  000f4	83 c0 04	 add	 eax, 4
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  000fd	83 c4 04	 add	 esp, 4
  00100	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00105	74 16		 je	 SHORT $LN5@stbtt_GetF
  00107	8b 45 08	 mov	 eax, DWORD PTR _font_collection$[ebp]
  0010a	83 c0 04	 add	 eax, 4
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  00113	83 c4 04	 add	 esp, 4
  00116	3d 00 00 02 00	 cmp	 eax, 131072		; 00020000H
  0011b	75 34		 jne	 SHORT $LN3@stbtt_GetF
$LN5@stbtt_GetF:

; 1312 :          stbtt_int32 n = ttLONG(font_collection+8);

  0011d	8b 45 08	 mov	 eax, DWORD PTR _font_collection$[ebp]
  00120	83 c0 08	 add	 eax, 8
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ?ttLONG@@YAHPAE@Z	; ttLONG
  00129	83 c4 04	 add	 esp, 4
  0012c	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax

; 1313 :          if (index >= n)

  0012f	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00132	3b 45 f8	 cmp	 eax, DWORD PTR _n$1[ebp]
  00135	7c 05		 jl	 SHORT $LN6@stbtt_GetF

; 1314 :             return -1;

  00137	83 c8 ff	 or	 eax, -1
  0013a	eb 18		 jmp	 SHORT $LN1@stbtt_GetF
$LN6@stbtt_GetF:

; 1315 :          return ttULONG(font_collection+12+index*4);

  0013c	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0013f	8b 4d 08	 mov	 ecx, DWORD PTR _font_collection$[ebp]
  00142	8d 54 81 0c	 lea	 edx, DWORD PTR [ecx+eax*4+12]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  0014c	83 c4 04	 add	 esp, 4
  0014f	eb 03		 jmp	 SHORT $LN1@stbtt_GetF
$LN3@stbtt_GetF:

; 1316 :       }
; 1317 :    }
; 1318 :    return -1;

  00151	83 c8 ff	 or	 eax, -1
$LN1@stbtt_GetF:

; 1319 : }

  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	5b		 pop	 ebx
  00157	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0015d	3b ec		 cmp	 ebp, esp
  0015f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
?stbtt_GetFontOffsetForIndex_internal@@YAHPAEH@Z ENDP	; stbtt_GetFontOffsetForIndex_internal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__find_table@@YAIPAEIPBD@Z
_TEXT	SEGMENT
_loc$1 = -44						; size = 4
_i$ = -32						; size = 4
_tabledir$ = -20					; size = 4
_num_tables$ = -8					; size = 4
_data$ = 8						; size = 4
_fontstart$ = 12					; size = 4
_tag$ = 16						; size = 4
?stbtt__find_table@@YAIPAEIPBD@Z PROC			; stbtt__find_table, COMDAT

; 1290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1291 :    stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _fontstart$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0002e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00038	83 c4 04	 add	 esp, 4
  0003b	0f b7 c0	 movzx	 eax, ax
  0003e	89 45 f8	 mov	 DWORD PTR _num_tables$[ebp], eax

; 1292 :    stbtt_uint32 tabledir = fontstart + 12;

  00041	8b 45 0c	 mov	 eax, DWORD PTR _fontstart$[ebp]
  00044	83 c0 0c	 add	 eax, 12			; 0000000cH
  00047	89 45 ec	 mov	 DWORD PTR _tabledir$[ebp], eax

; 1293 :    stbtt_int32 i;
; 1294 :    for (i=0; i < num_tables; ++i) {

  0004a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00051	eb 09		 jmp	 SHORT $LN4@stbtt__fin
$LN2@stbtt__fin:
  00053	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt__fin:
  0005c	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0005f	3b 45 f8	 cmp	 eax, DWORD PTR _num_tables$[ebp]
  00062	0f 8d bc 00 00
	00		 jge	 $LN3@stbtt__fin

; 1295 :       stbtt_uint32 loc = tabledir + 16*i;

  00068	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	c1 e0 04	 shl	 eax, 4
  0006e	03 45 ec	 add	 eax, DWORD PTR _tabledir$[ebp]
  00071	89 45 d4	 mov	 DWORD PTR _loc$1[ebp], eax

; 1296 :       if (stbtt_tag(data+loc+0, tag))

  00074	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00077	03 45 d4	 add	 eax, DWORD PTR _loc$1[ebp]
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	6b d1 00	 imul	 edx, ecx, 0
  00082	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00086	b9 01 00 00 00	 mov	 ecx, 1
  0008b	6b d1 00	 imul	 edx, ecx, 0
  0008e	8b 4d 10	 mov	 ecx, DWORD PTR _tag$[ebp]
  00091	0f be 14 11	 movsx	 edx, BYTE PTR [ecx+edx]
  00095	3b c2		 cmp	 eax, edx
  00097	0f 85 82 00 00
	00		 jne	 $LN5@stbtt__fin
  0009d	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000a0	03 45 d4	 add	 eax, DWORD PTR _loc$1[ebp]
  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	c1 e1 00	 shl	 ecx, 0
  000ab	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	c1 e0 00	 shl	 eax, 0
  000b7	8b 4d 10	 mov	 ecx, DWORD PTR _tag$[ebp]
  000ba	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  000be	3b d0		 cmp	 edx, eax
  000c0	75 5d		 jne	 SHORT $LN5@stbtt__fin
  000c2	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000c5	03 45 d4	 add	 eax, DWORD PTR _loc$1[ebp]
  000c8	b9 01 00 00 00	 mov	 ecx, 1
  000cd	d1 e1		 shl	 ecx, 1
  000cf	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  000d3	b8 01 00 00 00	 mov	 eax, 1
  000d8	d1 e0		 shl	 eax, 1
  000da	8b 4d 10	 mov	 ecx, DWORD PTR _tag$[ebp]
  000dd	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  000e1	3b d0		 cmp	 edx, eax
  000e3	75 3a		 jne	 SHORT $LN5@stbtt__fin
  000e5	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000e8	03 45 d4	 add	 eax, DWORD PTR _loc$1[ebp]
  000eb	b9 01 00 00 00	 mov	 ecx, 1
  000f0	6b d1 03	 imul	 edx, ecx, 3
  000f3	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  000f7	b9 01 00 00 00	 mov	 ecx, 1
  000fc	6b d1 03	 imul	 edx, ecx, 3
  000ff	8b 4d 10	 mov	 ecx, DWORD PTR _tag$[ebp]
  00102	0f be 14 11	 movsx	 edx, BYTE PTR [ecx+edx]
  00106	3b c2		 cmp	 eax, edx
  00108	75 15		 jne	 SHORT $LN5@stbtt__fin

; 1297 :          return ttULONG(data+loc+8);

  0010a	8b 45 d4	 mov	 eax, DWORD PTR _loc$1[ebp]
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00110	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  0011a	83 c4 04	 add	 esp, 4
  0011d	eb 07		 jmp	 SHORT $LN1@stbtt__fin
$LN5@stbtt__fin:

; 1298 :    }

  0011f	e9 2f ff ff ff	 jmp	 $LN2@stbtt__fin
$LN3@stbtt__fin:

; 1299 :    return 0;

  00124	33 c0		 xor	 eax, eax
$LN1@stbtt__fin:

; 1300 : }

  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0012f	3b ec		 cmp	 ebp, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
?stbtt__find_table@@YAIPAEIPBD@Z ENDP			; stbtt__find_table
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__isfont@@YAHPAE@Z
_TEXT	SEGMENT
_font$ = 8						; size = 4
?stbtt__isfont@@YAHPAE@Z PROC				; stbtt__isfont, COMDAT

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1279 :    // check the version number
; 1280 :    if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  00033	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00037	83 f8 31	 cmp	 eax, 49			; 00000031H
  0003a	75 42		 jne	 SHORT $LN2@stbtt__isf
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	c1 e0 00	 shl	 eax, 0
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  00047	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0004b	85 d2		 test	 edx, edx
  0004d	75 2f		 jne	 SHORT $LN2@stbtt__isf
  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	d1 e0		 shl	 eax, 1
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  00059	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0005d	85 d2		 test	 edx, edx
  0005f	75 1d		 jne	 SHORT $LN2@stbtt__isf
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	6b c8 03	 imul	 ecx, eax, 3
  00069	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  0006c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00070	85 c0		 test	 eax, eax
  00072	75 0a		 jne	 SHORT $LN2@stbtt__isf
  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	e9 05 02 00 00	 jmp	 $LN1@stbtt__isf
$LN2@stbtt__isf:

; 1281 :    if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

  0007e	b8 01 00 00 00	 mov	 eax, 1
  00083	6b c8 00	 imul	 ecx, eax, 0
  00086	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  00089	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	6b d1 00	 imul	 edx, ecx, 0
  00095	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LBBEMOBJ@typ1@[edx]
  0009c	3b c1		 cmp	 eax, ecx
  0009e	75 6e		 jne	 SHORT $LN3@stbtt__isf
  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	c1 e0 00	 shl	 eax, 0
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  000ab	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	c1 e0 00	 shl	 eax, 0
  000b7	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LBBEMOBJ@typ1@[eax]
  000be	3b d1		 cmp	 edx, ecx
  000c0	75 4c		 jne	 SHORT $LN3@stbtt__isf
  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	d1 e0		 shl	 eax, 1
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  000cc	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	d1 e0		 shl	 eax, 1
  000d7	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LBBEMOBJ@typ1@[eax]
  000de	3b d1		 cmp	 edx, ecx
  000e0	75 2c		 jne	 SHORT $LN3@stbtt__isf
  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	6b c8 03	 imul	 ecx, eax, 3
  000ea	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  000ed	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000f1	b9 01 00 00 00	 mov	 ecx, 1
  000f6	6b d1 03	 imul	 edx, ecx, 3
  000f9	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LBBEMOBJ@typ1@[edx]
  00100	3b c1		 cmp	 eax, ecx
  00102	75 0a		 jne	 SHORT $LN3@stbtt__isf
  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	e9 75 01 00 00	 jmp	 $LN1@stbtt__isf
$LN3@stbtt__isf:

; 1282 :    if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

  0010e	b8 01 00 00 00	 mov	 eax, 1
  00113	6b c8 00	 imul	 ecx, eax, 0
  00116	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  00119	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0011d	b9 01 00 00 00	 mov	 ecx, 1
  00122	6b d1 00	 imul	 edx, ecx, 0
  00125	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LLEFIKCJ@OTTO@[edx]
  0012c	3b c1		 cmp	 eax, ecx
  0012e	75 6e		 jne	 SHORT $LN4@stbtt__isf
  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	c1 e0 00	 shl	 eax, 0
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  0013b	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	c1 e0 00	 shl	 eax, 0
  00147	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LLEFIKCJ@OTTO@[eax]
  0014e	3b d1		 cmp	 edx, ecx
  00150	75 4c		 jne	 SHORT $LN4@stbtt__isf
  00152	b8 01 00 00 00	 mov	 eax, 1
  00157	d1 e0		 shl	 eax, 1
  00159	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  0015c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00160	b8 01 00 00 00	 mov	 eax, 1
  00165	d1 e0		 shl	 eax, 1
  00167	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LLEFIKCJ@OTTO@[eax]
  0016e	3b d1		 cmp	 edx, ecx
  00170	75 2c		 jne	 SHORT $LN4@stbtt__isf
  00172	b8 01 00 00 00	 mov	 eax, 1
  00177	6b c8 03	 imul	 ecx, eax, 3
  0017a	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  0017d	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00181	b9 01 00 00 00	 mov	 ecx, 1
  00186	6b d1 03	 imul	 edx, ecx, 3
  00189	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LLEFIKCJ@OTTO@[edx]
  00190	3b c1		 cmp	 eax, ecx
  00192	75 0a		 jne	 SHORT $LN4@stbtt__isf
  00194	b8 01 00 00 00	 mov	 eax, 1
  00199	e9 e5 00 00 00	 jmp	 $LN1@stbtt__isf
$LN4@stbtt__isf:

; 1283 :    if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0

  0019e	b8 01 00 00 00	 mov	 eax, 1
  001a3	6b c8 00	 imul	 ecx, eax, 0
  001a6	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  001a9	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001ad	85 c0		 test	 eax, eax
  001af	75 43		 jne	 SHORT $LN5@stbtt__isf
  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	c1 e0 00	 shl	 eax, 0
  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  001bc	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001c0	83 fa 01	 cmp	 edx, 1
  001c3	75 2f		 jne	 SHORT $LN5@stbtt__isf
  001c5	b8 01 00 00 00	 mov	 eax, 1
  001ca	d1 e0		 shl	 eax, 1
  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  001cf	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001d3	85 d2		 test	 edx, edx
  001d5	75 1d		 jne	 SHORT $LN5@stbtt__isf
  001d7	b8 01 00 00 00	 mov	 eax, 1
  001dc	6b c8 03	 imul	 ecx, eax, 3
  001df	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  001e2	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001e6	85 c0		 test	 eax, eax
  001e8	75 0a		 jne	 SHORT $LN5@stbtt__isf
  001ea	b8 01 00 00 00	 mov	 eax, 1
  001ef	e9 8f 00 00 00	 jmp	 $LN1@stbtt__isf
$LN5@stbtt__isf:

; 1284 :    if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	6b c8 00	 imul	 ecx, eax, 0
  001fc	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  001ff	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00203	b9 01 00 00 00	 mov	 ecx, 1
  00208	6b d1 00	 imul	 edx, ecx, 0
  0020b	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LOAJBDKD@true@[edx]
  00212	3b c1		 cmp	 eax, ecx
  00214	75 6b		 jne	 SHORT $LN6@stbtt__isf
  00216	b8 01 00 00 00	 mov	 eax, 1
  0021b	c1 e0 00	 shl	 eax, 0
  0021e	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  00221	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00225	b8 01 00 00 00	 mov	 eax, 1
  0022a	c1 e0 00	 shl	 eax, 0
  0022d	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LOAJBDKD@true@[eax]
  00234	3b d1		 cmp	 edx, ecx
  00236	75 49		 jne	 SHORT $LN6@stbtt__isf
  00238	b8 01 00 00 00	 mov	 eax, 1
  0023d	d1 e0		 shl	 eax, 1
  0023f	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  00242	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00246	b8 01 00 00 00	 mov	 eax, 1
  0024b	d1 e0		 shl	 eax, 1
  0024d	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LOAJBDKD@true@[eax]
  00254	3b d1		 cmp	 edx, ecx
  00256	75 29		 jne	 SHORT $LN6@stbtt__isf
  00258	b8 01 00 00 00	 mov	 eax, 1
  0025d	6b c8 03	 imul	 ecx, eax, 3
  00260	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  00263	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00267	b9 01 00 00 00	 mov	 ecx, 1
  0026c	6b d1 03	 imul	 edx, ecx, 3
  0026f	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_04LOAJBDKD@true@[edx]
  00276	3b c1		 cmp	 eax, ecx
  00278	75 07		 jne	 SHORT $LN6@stbtt__isf
  0027a	b8 01 00 00 00	 mov	 eax, 1
  0027f	eb 02		 jmp	 SHORT $LN1@stbtt__isf
$LN6@stbtt__isf:

; 1285 :    return 0;

  00281	33 c0		 xor	 eax, eax
$LN1@stbtt__isf:

; 1286 : }

  00283	5f		 pop	 edi
  00284	5e		 pop	 esi
  00285	5b		 pop	 ebx
  00286	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0028c	3b ec		 cmp	 ebp, esp
  0028e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00293	8b e5		 mov	 esp, ebp
  00295	5d		 pop	 ebp
  00296	c3		 ret	 0
?stbtt__isfont@@YAHPAE@Z ENDP				; stbtt__isfont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?ttLONG@@YAHPAE@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttLONG@@YAHPAE@Z PROC					; ttLONG, COMDAT

; 1272 : static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00037	c1 e0 18	 shl	 eax, 24			; 00000018H
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	c1 e1 00	 shl	 ecx, 0
  00042	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00045	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00049	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0004c	03 c1		 add	 eax, ecx
  0004e	ba 01 00 00 00	 mov	 edx, 1
  00053	d1 e2		 shl	 edx, 1
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00058	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  0005c	c1 e2 08	 shl	 edx, 8
  0005f	03 c2		 add	 eax, edx
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	6b d1 03	 imul	 edx, ecx, 3
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0006c	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00070	03 c2		 add	 eax, edx
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?ttLONG@@YAHPAE@Z ENDP					; ttLONG
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?ttULONG@@YAIPAE@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttULONG@@YAIPAE@Z PROC					; ttULONG, COMDAT

; 1271 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00037	c1 e0 18	 shl	 eax, 24			; 00000018H
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	c1 e1 00	 shl	 ecx, 0
  00042	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00045	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00049	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0004c	03 c1		 add	 eax, ecx
  0004e	ba 01 00 00 00	 mov	 edx, 1
  00053	d1 e2		 shl	 edx, 1
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00058	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  0005c	c1 e2 08	 shl	 edx, 8
  0005f	03 c2		 add	 eax, edx
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	6b d1 03	 imul	 edx, ecx, 3
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0006c	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00070	03 c2		 add	 eax, edx
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?ttULONG@@YAIPAE@Z ENDP					; ttULONG
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?ttSHORT@@YAFPAE@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttSHORT@@YAFPAE@Z PROC					; ttSHORT, COMDAT

; 1270 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00037	c1 e0 08	 shl	 eax, 8
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	c1 e1 00	 shl	 ecx, 0
  00042	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00045	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00049	03 c1		 add	 eax, ecx
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?ttSHORT@@YAFPAE@Z ENDP					; ttSHORT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?ttUSHORT@@YAGPAE@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttUSHORT@@YAGPAE@Z PROC				; ttUSHORT, COMDAT

; 1269 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00033	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00037	c1 e0 08	 shl	 eax, 8
  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	c1 e1 00	 shl	 ecx, 0
  00042	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00045	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00049	03 c1		 add	 eax, ecx
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?ttUSHORT@@YAGPAE@Z ENDP				; ttUSHORT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
_TEXT	SEGMENT
$T1 = -276						; size = 12
$T2 = -256						; size = 12
_end$ = -44						; size = 4
_start$ = -32						; size = 4
_offsize$ = -20						; size = 4
_count$ = -8						; size = 4
$T3 = 8							; size = 4
_b$ = 12						; size = 12
_i$ = 24						; size = 4
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z PROC	; stbtt__cff_index_get, COMDAT

; 1244 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1245 :    int count, offsize, start, end;
; 1246 :    stbtt__buf_seek(&b, 0);

  00028	6a 00		 push	 0
  0002a	8d 45 0c	 lea	 eax, DWORD PTR _b$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  00033	83 c4 08	 add	 esp, 8

; 1247 :    count = stbtt__buf_get16(&b);

  00036	6a 02		 push	 2
  00038	8d 45 0c	 lea	 eax, DWORD PTR _b$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  00041	83 c4 08	 add	 esp, 8
  00044	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 1248 :    offsize = stbtt__buf_get8(&b);

  00047	8d 45 0c	 lea	 eax, DWORD PTR _b$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00050	83 c4 04	 add	 esp, 4
  00053	0f b6 c8	 movzx	 ecx, al
  00056	89 4d ec	 mov	 DWORD PTR _offsize$[ebp], ecx

; 1249 :    STBTT_assert(i >= 0 && i < count);

  00059	83 7d 18 00	 cmp	 DWORD PTR _i$[ebp], 0
  0005d	7c 08		 jl	 SHORT $LN3@stbtt__cff
  0005f	8b 45 18	 mov	 eax, DWORD PTR _i$[ebp]
  00062	3b 45 f8	 cmp	 eax, DWORD PTR _count$[ebp]
  00065	7c 26		 jl	 SHORT $LN4@stbtt__cff
$LN3@stbtt__cff:
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__cff_index_get@@YA?AUstbtt__buf@@U2@H@Z@4JA
  0006d	83 c1 05	 add	 ecx, 5
  00070	8b f4		 mov	 esi, esp
  00072	51		 push	 ecx
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@stbtt__cff:

; 1250 :    STBTT_assert(offsize >= 1 && offsize <= 4);

  0008d	83 7d ec 01	 cmp	 DWORD PTR _offsize$[ebp], 1
  00091	7c 06		 jl	 SHORT $LN5@stbtt__cff
  00093	83 7d ec 04	 cmp	 DWORD PTR _offsize$[ebp], 4
  00097	7e 25		 jle	 SHORT $LN6@stbtt__cff
$LN5@stbtt__cff:
  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__cff_index_get@@YA?AUstbtt__buf@@U2@H@Z@4JA
  0009e	83 c0 06	 add	 eax, 6
  000a1	8b f4		 mov	 esi, esp
  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	3b f4		 cmp	 esi, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@stbtt__cff:

; 1251 :    stbtt__buf_skip(&b, i*offsize);

  000be	8b 45 18	 mov	 eax, DWORD PTR _i$[ebp]
  000c1	0f af 45 ec	 imul	 eax, DWORD PTR _offsize$[ebp]
  000c5	50		 push	 eax
  000c6	8d 4d 0c	 lea	 ecx, DWORD PTR _b$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  000cf	83 c4 08	 add	 esp, 8

; 1252 :    start = stbtt__buf_get(&b, offsize);

  000d2	8b 45 ec	 mov	 eax, DWORD PTR _offsize$[ebp]
  000d5	50		 push	 eax
  000d6	8d 4d 0c	 lea	 ecx, DWORD PTR _b$[ebp]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000df	83 c4 08	 add	 esp, 8
  000e2	89 45 e0	 mov	 DWORD PTR _start$[ebp], eax

; 1253 :    end = stbtt__buf_get(&b, offsize);

  000e5	8b 45 ec	 mov	 eax, DWORD PTR _offsize$[ebp]
  000e8	50		 push	 eax
  000e9	8d 4d 0c	 lea	 ecx, DWORD PTR _b$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000f2	83 c4 08	 add	 esp, 8
  000f5	89 45 d4	 mov	 DWORD PTR _end$[ebp], eax

; 1254 :    return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);

  000f8	8b 45 d4	 mov	 eax, DWORD PTR _end$[ebp]
  000fb	2b 45 e0	 sub	 eax, DWORD PTR _start$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00102	83 c1 01	 add	 ecx, 1
  00105	0f af 4d ec	 imul	 ecx, DWORD PTR _offsize$[ebp]
  00109	8b 55 e0	 mov	 edx, DWORD PTR _start$[ebp]
  0010c	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00110	50		 push	 eax
  00111	8d 4d 0c	 lea	 ecx, DWORD PTR _b$[ebp]
  00114	51		 push	 ecx
  00115	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0011b	52		 push	 edx
  0011c	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
  00121	83 c4 10	 add	 esp, 16			; 00000010H
  00124	8b 08		 mov	 ecx, DWORD PTR [eax]
  00126	89 8d 00 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  0012c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0012f	89 95 04 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  00135	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00138	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], eax
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR $T3[ebp]
  00141	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00147	89 11		 mov	 DWORD PTR [ecx], edx
  00149	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+4]
  0014f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00152	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+8]
  00158	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0015b	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]

; 1255 : }

  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	5b		 pop	 ebx
  00161	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00167	3b ec		 cmp	 ebp, esp
  00169	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ENDP	; stbtt__cff_index_get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_index_count@@YAHPAUstbtt__buf@@@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?stbtt__cff_index_count@@YAHPAUstbtt__buf@@@Z PROC	; stbtt__cff_index_count, COMDAT

; 1238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1239 :    stbtt__buf_seek(b, 0);

  00028	6a 00		 push	 0
  0002a	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  00033	83 c4 08	 add	 esp, 8

; 1240 :    return stbtt__buf_get16(b);

  00036	6a 02		 push	 2
  00038	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  00041	83 c4 08	 add	 esp, 8

; 1241 : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?stbtt__cff_index_count@@YAHPAUstbtt__buf@@@Z ENDP	; stbtt__cff_index_count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z
_TEXT	SEGMENT
$T1 = -264						; size = 12
$T2 = -244						; size = 12
_operands$ = -32					; size = 12
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_b$ = 8							; size = 4
_key$ = 12						; size = 4
_outcount$ = 16						; size = 4
_out$ = 20						; size = 4
?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z PROC	; stbtt__dict_get_ints, COMDAT

; 1230 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1231 :    int i;
; 1232 :    stbtt__buf operands = stbtt__dict_get(b, key);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _b$[ebp]
  00039	51		 push	 ecx
  0003a	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PAU1@H@Z ; stbtt__dict_get
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	89 8d 0c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00051	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00054	89 95 10 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0005a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005d	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], eax
  00063	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00069	89 4d e0	 mov	 DWORD PTR _operands$[ebp], ecx
  0006c	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00072	89 55 e4	 mov	 DWORD PTR _operands$[ebp+4], edx
  00075	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+8]
  0007b	89 45 e8	 mov	 DWORD PTR _operands$[ebp+8], eax

; 1233 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  0007e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00085	eb 09		 jmp	 SHORT $LN4@stbtt__dic
$LN2@stbtt__dic:
  00087	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0008a	83 c0 01	 add	 eax, 1
  0008d	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt__dic:
  00090	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00093	3b 45 10	 cmp	 eax, DWORD PTR _outcount$[ebp]
  00096	7d 1f		 jge	 SHORT $LN1@stbtt__dic
  00098	8b 45 e4	 mov	 eax, DWORD PTR _operands$[ebp+4]
  0009b	3b 45 e8	 cmp	 eax, DWORD PTR _operands$[ebp+8]
  0009e	7d 17		 jge	 SHORT $LN1@stbtt__dic

; 1234 :       out[i] = stbtt__cff_int(&operands);

  000a0	8d 45 e0	 lea	 eax, DWORD PTR _operands$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z ; stbtt__cff_int
  000a9	83 c4 04	 add	 esp, 4
  000ac	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000af	8b 55 14	 mov	 edx, DWORD PTR _out$[ebp]
  000b2	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  000b5	eb d0		 jmp	 SHORT $LN2@stbtt__dic
$LN1@stbtt__dic:

; 1235 : }

  000b7	52		 push	 edx
  000b8	8b cd		 mov	 ecx, ebp
  000ba	50		 push	 eax
  000bb	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@stbtt__dic
  000c1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000c6	58		 pop	 eax
  000c7	5a		 pop	 edx
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  000db	3b ec		 cmp	 ebp, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
  000e6	66 90		 npad	 2
$LN8@stbtt__dic:
  000e8	01 00 00 00	 DD	 1
  000ec	00 00 00 00	 DD	 $LN7@stbtt__dic
$LN7@stbtt__dic:
  000f0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  000f4	0c 00 00 00	 DD	 12			; 0000000cH
  000f8	00 00 00 00	 DD	 $LN6@stbtt__dic
$LN6@stbtt__dic:
  000fc	6f		 DB	 111			; 0000006fH
  000fd	70		 DB	 112			; 00000070H
  000fe	65		 DB	 101			; 00000065H
  000ff	72		 DB	 114			; 00000072H
  00100	61		 DB	 97			; 00000061H
  00101	6e		 DB	 110			; 0000006eH
  00102	64		 DB	 100			; 00000064H
  00103	73		 DB	 115			; 00000073H
  00104	00		 DB	 0
?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ENDP	; stbtt__dict_get_ints
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__dict_get@@YA?AUstbtt__buf@@PAU1@H@Z
_TEXT	SEGMENT
$T1 = -304						; size = 12
$T2 = -284						; size = 12
$T3 = -264						; size = 12
$T4 = -244						; size = 12
_op$5 = -32						; size = 4
_end$6 = -20						; size = 4
_start$7 = -8						; size = 4
$T8 = 8							; size = 4
_b$ = 12						; size = 4
_key$ = 16						; size = 4
?stbtt__dict_get@@YA?AUstbtt__buf@@PAU1@H@Z PROC	; stbtt__dict_get, COMDAT

; 1215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd cc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-308]
  00012	b9 4d 00 00 00	 mov	 ecx, 77			; 0000004dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1216 :    stbtt__buf_seek(b, 0);

  00028	6a 00		 push	 0
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  00033	83 c4 08	 add	 esp, 8
$LN2@stbtt__dic:

; 1217 :    while (b->cursor < b->size) {

  00036	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0003c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003f	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00042	0f 8d cb 00 00
	00		 jge	 $LN3@stbtt__dic

; 1218 :       int start = b->cursor, end, op;

  00048	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004e	89 4d f8	 mov	 DWORD PTR _start$7[ebp], ecx
$LN4@stbtt__dic:

; 1219 :       while (stbtt__buf_peek8(b) >= 28)

  00051	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_peek8
  0005a	83 c4 04	 add	 esp, 4
  0005d	0f b6 c8	 movzx	 ecx, al
  00060	83 f9 1c	 cmp	 ecx, 28			; 0000001cH
  00063	7c 0e		 jl	 SHORT $LN5@stbtt__dic

; 1220 :          stbtt__cff_skip_operand(b);

  00065	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z ; stbtt__cff_skip_operand
  0006e	83 c4 04	 add	 esp, 4
  00071	eb de		 jmp	 SHORT $LN4@stbtt__dic
$LN5@stbtt__dic:

; 1221 :       end = b->cursor;

  00073	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00076	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00079	89 4d ec	 mov	 DWORD PTR _end$6[ebp], ecx

; 1222 :       op = stbtt__buf_get8(b);

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00085	83 c4 04	 add	 esp, 4
  00088	0f b6 c8	 movzx	 ecx, al
  0008b	89 4d e0	 mov	 DWORD PTR _op$5[ebp], ecx

; 1223 :       if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

  0008e	83 7d e0 0c	 cmp	 DWORD PTR _op$5[ebp], 12 ; 0000000cH
  00092	75 18		 jne	 SHORT $LN6@stbtt__dic
  00094	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  0009d	83 c4 04	 add	 esp, 4
  000a0	0f b6 c8	 movzx	 ecx, al
  000a3	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  000a9	89 4d e0	 mov	 DWORD PTR _op$5[ebp], ecx
$LN6@stbtt__dic:

; 1224 :       if (op == key) return stbtt__buf_range(b, start, end-start);

  000ac	8b 45 e0	 mov	 eax, DWORD PTR _op$5[ebp]
  000af	3b 45 10	 cmp	 eax, DWORD PTR _key$[ebp]
  000b2	75 5a		 jne	 SHORT $LN7@stbtt__dic
  000b4	8b 45 ec	 mov	 eax, DWORD PTR _end$6[ebp]
  000b7	2b 45 f8	 sub	 eax, DWORD PTR _start$7[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _start$7[ebp]
  000be	51		 push	 ecx
  000bf	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  000c2	52		 push	 edx
  000c3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
  000cf	83 c4 10	 add	 esp, 16			; 00000010H
  000d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d4	89 8d 0c ff ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  000da	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000dd	89 95 10 ff ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  000e3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000e6	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T4[ebp+8], eax
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR $T8[ebp]
  000ef	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  000f5	89 11		 mov	 DWORD PTR [ecx], edx
  000f7	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+4]
  000fd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00100	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+8]
  00106	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00109	8b 45 08	 mov	 eax, DWORD PTR $T8[ebp]
  0010c	eb 56		 jmp	 SHORT $LN1@stbtt__dic
$LN7@stbtt__dic:

; 1225 :    }

  0010e	e9 23 ff ff ff	 jmp	 $LN2@stbtt__dic
$LN3@stbtt__dic:

; 1226 :    return stbtt__buf_range(b, 0, 0);

  00113	6a 00		 push	 0
  00115	6a 00		 push	 0
  00117	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0011a	50		 push	 eax
  0011b	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
  00127	83 c4 10	 add	 esp, 16			; 00000010H
  0012a	8b 10		 mov	 edx, DWORD PTR [eax]
  0012c	89 95 e4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  00132	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00135	89 8d e8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], ecx
  0013b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0013e	89 95 ec fe ff
	ff		 mov	 DWORD PTR $T2[ebp+8], edx
  00144	8b 45 08	 mov	 eax, DWORD PTR $T8[ebp]
  00147	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0014d	89 08		 mov	 DWORD PTR [eax], ecx
  0014f	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00155	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00158	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+8]
  0015e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00161	8b 45 08	 mov	 eax, DWORD PTR $T8[ebp]
$LN1@stbtt__dic:

; 1227 : }

  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	5b		 pop	 ebx
  00167	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  0016d	3b ec		 cmp	 ebp, esp
  0016f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
?stbtt__dict_get@@YA?AUstbtt__buf@@PAU1@H@Z ENDP	; stbtt__dict_get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z
_TEXT	SEGMENT
_b0$ = -20						; size = 4
_v$ = -8						; size = 4
_b$ = 8							; size = 4
?stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z PROC	; stbtt__cff_skip_operand, COMDAT

; 1199 : static void stbtt__cff_skip_operand(stbtt__buf *b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1200 :    int v, b0 = stbtt__buf_peek8(b);

  00028	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_peek8
  00031	83 c4 04	 add	 esp, 4
  00034	0f b6 c8	 movzx	 ecx, al
  00037	89 4d ec	 mov	 DWORD PTR _b0$[ebp], ecx

; 1201 :    STBTT_assert(b0 >= 28);

  0003a	83 7d ec 1c	 cmp	 DWORD PTR _b0$[ebp], 28	; 0000001cH
  0003e	7d 25		 jge	 SHORT $LN9@stbtt__cff
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z@4JA
  00045	83 c0 02	 add	 eax, 2
  00048	8b f4		 mov	 esi, esp
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@stbtt__cff:

; 1202 :    if (b0 == 30) {

  00065	83 7d ec 1e	 cmp	 DWORD PTR _b0$[ebp], 30	; 0000001eH
  00069	75 4a		 jne	 SHORT $LN4@stbtt__cff

; 1203 :       stbtt__buf_skip(b, 1);

  0006b	6a 01		 push	 1
  0006d	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  00076	83 c4 08	 add	 esp, 8
$LN2@stbtt__cff:

; 1204 :       while (b->cursor < b->size) {

  00079	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _b$[ebp]
  0007f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00082	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00085	7d 2c		 jge	 SHORT $LN3@stbtt__cff

; 1205 :          v = stbtt__buf_get8(b);

  00087	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00090	83 c4 04	 add	 esp, 4
  00093	0f b6 c8	 movzx	 ecx, al
  00096	89 4d f8	 mov	 DWORD PTR _v$[ebp], ecx

; 1206 :          if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

  00099	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0009c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0009f	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000a2	74 0b		 je	 SHORT $LN7@stbtt__cff
  000a4	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  000a7	c1 f8 04	 sar	 eax, 4
  000aa	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000ad	75 02		 jne	 SHORT $LN6@stbtt__cff
$LN7@stbtt__cff:

; 1207 :             break;

  000af	eb 02		 jmp	 SHORT $LN3@stbtt__cff
$LN6@stbtt__cff:

; 1208 :       }

  000b1	eb c6		 jmp	 SHORT $LN2@stbtt__cff
$LN3@stbtt__cff:

; 1209 :    } else {

  000b3	eb 0c		 jmp	 SHORT $LN1@stbtt__cff
$LN4@stbtt__cff:

; 1210 :       stbtt__cff_int(b);

  000b5	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z ; stbtt__cff_int
  000be	83 c4 04	 add	 esp, 4
$LN1@stbtt__cff:

; 1211 :    }
; 1212 : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ca	3b ec		 cmp	 ebp, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z ENDP	; stbtt__cff_skip_operand
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z
_TEXT	SEGMENT
_b0$ = -8						; size = 4
_b$ = 8							; size = 4
?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z PROC		; stbtt__cff_int, COMDAT

; 1188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1189 :    int b0 = stbtt__buf_get8(b);

  00028	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00031	83 c4 04	 add	 esp, 4
  00034	0f b6 c8	 movzx	 ecx, al
  00037	89 4d f8	 mov	 DWORD PTR _b0$[ebp], ecx

; 1190 :    if (b0 >= 32 && b0 <= 246)       return b0 - 139;

  0003a	83 7d f8 20	 cmp	 DWORD PTR _b0$[ebp], 32	; 00000020H
  0003e	7c 1b		 jl	 SHORT $LN2@stbtt__cff
  00040	81 7d f8 f6 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 246 ; 000000f6H
  00047	7f 12		 jg	 SHORT $LN2@stbtt__cff
  00049	8b 45 f8	 mov	 eax, DWORD PTR _b0$[ebp]
  0004c	2d 8b 00 00 00	 sub	 eax, 139		; 0000008bH
  00051	e9 d1 00 00 00	 jmp	 $LN1@stbtt__cff
  00056	e9 a0 00 00 00	 jmp	 $LN3@stbtt__cff
$LN2@stbtt__cff:

; 1191 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

  0005b	81 7d f8 f7 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 247 ; 000000f7H
  00062	7c 2f		 jl	 SHORT $LN4@stbtt__cff
  00064	81 7d f8 fa 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 250 ; 000000faH
  0006b	7f 26		 jg	 SHORT $LN4@stbtt__cff
  0006d	8b 75 f8	 mov	 esi, DWORD PTR _b0$[ebp]
  00070	81 ee f7 00 00
	00		 sub	 esi, 247		; 000000f7H
  00076	c1 e6 08	 shl	 esi, 8
  00079	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00082	83 c4 04	 add	 esp, 4
  00085	0f b6 c8	 movzx	 ecx, al
  00088	8d 44 0e 6c	 lea	 eax, DWORD PTR [esi+ecx+108]
  0008c	e9 96 00 00 00	 jmp	 $LN1@stbtt__cff
  00091	eb 68		 jmp	 SHORT $LN3@stbtt__cff
$LN4@stbtt__cff:

; 1192 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

  00093	81 7d f8 fb 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 251 ; 000000fbH
  0009a	7c 31		 jl	 SHORT $LN6@stbtt__cff
  0009c	81 7d f8 fe 00
	00 00		 cmp	 DWORD PTR _b0$[ebp], 254 ; 000000feH
  000a3	7f 28		 jg	 SHORT $LN6@stbtt__cff
  000a5	8b 75 f8	 mov	 esi, DWORD PTR _b0$[ebp]
  000a8	81 ee fb 00 00
	00		 sub	 esi, 251		; 000000fbH
  000ae	f7 de		 neg	 esi
  000b0	c1 e6 08	 shl	 esi, 8
  000b3	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  000bc	83 c4 04	 add	 esp, 4
  000bf	0f b6 c8	 movzx	 ecx, al
  000c2	2b f1		 sub	 esi, ecx
  000c4	83 ee 6c	 sub	 esi, 108		; 0000006cH
  000c7	8b c6		 mov	 eax, esi
  000c9	eb 5c		 jmp	 SHORT $LN1@stbtt__cff
  000cb	eb 2e		 jmp	 SHORT $LN3@stbtt__cff
$LN6@stbtt__cff:

; 1193 :    else if (b0 == 28)               return stbtt__buf_get16(b);

  000cd	83 7d f8 1c	 cmp	 DWORD PTR _b0$[ebp], 28	; 0000001cH
  000d1	75 12		 jne	 SHORT $LN8@stbtt__cff
  000d3	6a 02		 push	 2
  000d5	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000de	83 c4 08	 add	 esp, 8
  000e1	eb 44		 jmp	 SHORT $LN1@stbtt__cff
  000e3	eb 16		 jmp	 SHORT $LN3@stbtt__cff
$LN8@stbtt__cff:

; 1194 :    else if (b0 == 29)               return stbtt__buf_get32(b);

  000e5	83 7d f8 1d	 cmp	 DWORD PTR _b0$[ebp], 29	; 0000001dH
  000e9	75 10		 jne	 SHORT $LN3@stbtt__cff
  000eb	6a 04		 push	 4
  000ed	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000f6	83 c4 08	 add	 esp, 8
  000f9	eb 2c		 jmp	 SHORT $LN1@stbtt__cff
$LN3@stbtt__cff:

; 1195 :    STBTT_assert(0);

  000fb	33 c0		 xor	 eax, eax
  000fd	75 26		 jne	 SHORT $LN12@stbtt__cff
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt__cff_int@@YAIPAUstbtt__buf@@@Z@4JA
  00105	83 c1 07	 add	 ecx, 7
  00108	8b f4		 mov	 esi, esp
  0010a	51		 push	 ecx
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	3b f4		 cmp	 esi, esp
  00120	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@stbtt__cff:

; 1196 :    return 0;

  00125	33 c0		 xor	 eax, eax
$LN1@stbtt__cff:

; 1197 : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00130	3b ec		 cmp	 ebp, esp
  00132	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z ENDP		; stbtt__cff_int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z
_TEXT	SEGMENT
$T1 = -264						; size = 12
$T2 = -244						; size = 12
_offsize$ = -32						; size = 4
_start$ = -20						; size = 4
_count$ = -8						; size = 4
$T3 = 8							; size = 4
_b$ = 12						; size = 4
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z PROC	; stbtt__cff_get_index, COMDAT

; 1174 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1175 :    int count, start, offsize;
; 1176 :    start = b->cursor;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d ec	 mov	 DWORD PTR _start$[ebp], ecx

; 1177 :    count = stbtt__buf_get16(b);

  00031	6a 02		 push	 2
  00033	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  0003c	83 c4 08	 add	 esp, 8
  0003f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 1178 :    if (count) {

  00042	83 7d f8 00	 cmp	 DWORD PTR _count$[ebp], 0
  00046	74 77		 je	 SHORT $LN2@stbtt__cff

; 1179 :       offsize = stbtt__buf_get8(b);

  00048	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00051	83 c4 04	 add	 esp, 4
  00054	0f b6 c8	 movzx	 ecx, al
  00057	89 4d e0	 mov	 DWORD PTR _offsize$[ebp], ecx

; 1180 :       STBTT_assert(offsize >= 1 && offsize <= 4);

  0005a	83 7d e0 01	 cmp	 DWORD PTR _offsize$[ebp], 1
  0005e	7c 06		 jl	 SHORT $LN4@stbtt__cff
  00060	83 7d e0 04	 cmp	 DWORD PTR _offsize$[ebp], 4
  00064	7e 25		 jle	 SHORT $LN5@stbtt__cff
$LN4@stbtt__cff:
  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU2@@Z@4JA
  0006b	83 c0 06	 add	 eax, 6
  0006e	8b f4		 mov	 esi, esp
  00070	50		 push	 eax
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	3b f4		 cmp	 esi, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@stbtt__cff:

; 1181 :       stbtt__buf_skip(b, offsize * count);

  0008b	8b 45 e0	 mov	 eax, DWORD PTR _offsize$[ebp]
  0008e	0f af 45 f8	 imul	 eax, DWORD PTR _count$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  0009c	83 c4 08	 add	 esp, 8

; 1182 :       stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);

  0009f	8b 45 e0	 mov	 eax, DWORD PTR _offsize$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ; stbtt__buf_get
  000ac	83 c4 08	 add	 esp, 8
  000af	83 e8 01	 sub	 eax, 1
  000b2	50		 push	 eax
  000b3	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  000b6	52		 push	 edx
  000b7	e8 00 00 00 00	 call	 ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_skip
  000bc	83 c4 08	 add	 esp, 8
$LN2@stbtt__cff:

; 1183 :    }
; 1184 :    return stbtt__buf_range(b, start, b->cursor - start);

  000bf	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  000c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c5	2b 4d ec	 sub	 ecx, DWORD PTR _start$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 ec	 mov	 edx, DWORD PTR _start$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  000d0	50		 push	 eax
  000d1	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
  000dd	83 c4 10	 add	 esp, 16			; 00000010H
  000e0	8b 10		 mov	 edx, DWORD PTR [eax]
  000e2	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  000e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000eb	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], ecx
  000f1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000f4	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], edx
  000fa	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
  000fd	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx
  00105	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010e	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+8]
  00114	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00117	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]

; 1185 : }

  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00123	3b ec		 cmp	 ebp, esp
  00125	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ENDP	; stbtt__cff_get_index
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z
_TEXT	SEGMENT
$T1 = -248						; size = 12
$T2 = -228						; size = 12
_r$ = -16						; size = 12
$T3 = 8							; size = 4
_b$ = 12						; size = 4
_o$ = 16						; size = 4
_s$ = 20						; size = 4
?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z PROC	; stbtt__buf_range, COMDAT

; 1165 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1166 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	89 8d 1c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00043	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00046	89 95 20 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  0004c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0004f	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], eax
  00055	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0005b	89 4d f0	 mov	 DWORD PTR _r$[ebp], ecx
  0005e	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00064	89 55 f4	 mov	 DWORD PTR _r$[ebp+4], edx
  00067	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+8]
  0006d	89 45 f8	 mov	 DWORD PTR _r$[ebp+8], eax

; 1167 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  00070	83 7d 10 00	 cmp	 DWORD PTR _o$[ebp], 0
  00074	7c 1f		 jl	 SHORT $LN3@stbtt__buf
  00076	83 7d 14 00	 cmp	 DWORD PTR _s$[ebp], 0
  0007a	7c 19		 jl	 SHORT $LN3@stbtt__buf
  0007c	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0007f	8b 4d 10	 mov	 ecx, DWORD PTR _o$[ebp]
  00082	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00085	7f 0e		 jg	 SHORT $LN3@stbtt__buf
  00087	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0008a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008d	2b 4d 10	 sub	 ecx, DWORD PTR _o$[ebp]
  00090	39 4d 14	 cmp	 DWORD PTR _s$[ebp], ecx
  00093	7e 19		 jle	 SHORT $LN2@stbtt__buf
$LN3@stbtt__buf:
  00095	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
  00098	8b 4d f0	 mov	 ecx, DWORD PTR _r$[ebp]
  0009b	89 08		 mov	 DWORD PTR [eax], ecx
  0009d	8b 55 f4	 mov	 edx, DWORD PTR _r$[ebp+4]
  000a0	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _r$[ebp+8]
  000a6	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a9	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
  000ac	eb 28		 jmp	 SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1168 :    r.data = b->data + o;

  000ae	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  000b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b3	03 4d 10	 add	 ecx, DWORD PTR _o$[ebp]
  000b6	89 4d f0	 mov	 DWORD PTR _r$[ebp], ecx

; 1169 :    r.size = s;

  000b9	8b 45 14	 mov	 eax, DWORD PTR _s$[ebp]
  000bc	89 45 f8	 mov	 DWORD PTR _r$[ebp+8], eax

; 1170 :    return r;

  000bf	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
  000c2	8b 4d f0	 mov	 ecx, DWORD PTR _r$[ebp]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx
  000c7	8b 55 f4	 mov	 edx, DWORD PTR _r$[ebp+4]
  000ca	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _r$[ebp+8]
  000d0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000d3	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
$LN1@stbtt__buf:

; 1171 : }

  000d6	52		 push	 edx
  000d7	8b cd		 mov	 ecx, ebp
  000d9	50		 push	 eax
  000da	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@stbtt__buf
  000e0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000e5	58		 pop	 eax
  000e6	5a		 pop	 edx
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
  000fb	90		 npad	 1
$LN7@stbtt__buf:
  000fc	01 00 00 00	 DD	 1
  00100	00 00 00 00	 DD	 $LN6@stbtt__buf
$LN6@stbtt__buf:
  00104	f0 ff ff ff	 DD	 -16			; fffffff0H
  00108	0c 00 00 00	 DD	 12			; 0000000cH
  0010c	00 00 00 00	 DD	 $LN5@stbtt__buf
$LN5@stbtt__buf:
  00110	72		 DB	 114			; 00000072H
  00111	00		 DB	 0
?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ENDP	; stbtt__buf_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z
_TEXT	SEGMENT
_r$ = -16						; size = 12
$T1 = 8							; size = 4
_p$ = 12						; size = 4
_size$ = 16						; size = 4
?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z PROC		; stbtt__new_buf, COMDAT

; 1152 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-212]
  00012	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1153 :    stbtt__buf r;
; 1154 :    STBTT_assert(size < 0x40000000);

  00028	81 7d 10 00 00
	00 40		 cmp	 DWORD PTR _size$[ebp], 1073741824 ; 40000000H
  0002f	72 25		 jb	 SHORT $LN3@stbtt__new
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z@4JA
  00036	83 c0 02	 add	 eax, 2
  00039	8b f4		 mov	 esi, esp
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@stbtt__new:

; 1155 :    r.data = (stbtt_uint8*) p;

  00056	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00059	89 45 f0	 mov	 DWORD PTR _r$[ebp], eax

; 1156 :    r.size = (int) size;

  0005c	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  0005f	89 45 f8	 mov	 DWORD PTR _r$[ebp+8], eax

; 1157 :    r.cursor = 0;

  00062	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp+4], 0

; 1158 :    return r;

  00069	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _r$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
  00071	8b 55 f4	 mov	 edx, DWORD PTR _r$[ebp+4]
  00074	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _r$[ebp+8]
  0007a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0007d	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]

; 1159 : }

  00080	52		 push	 edx
  00081	8b cd		 mov	 ecx, ebp
  00083	50		 push	 eax
  00084	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@stbtt__new
  0008a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008f	58		 pop	 eax
  00090	5a		 pop	 edx
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
  000a5	0f 1f 00	 npad	 3
$LN6@stbtt__new:
  000a8	01 00 00 00	 DD	 1
  000ac	00 00 00 00	 DD	 $LN5@stbtt__new
$LN5@stbtt__new:
  000b0	f0 ff ff ff	 DD	 -16			; fffffff0H
  000b4	0c 00 00 00	 DD	 12			; 0000000cH
  000b8	00 00 00 00	 DD	 $LN4@stbtt__new
$LN4@stbtt__new:
  000bc	72		 DB	 114			; 00000072H
  000bd	00		 DB	 0
?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ENDP		; stbtt__new_buf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_v$ = -8						; size = 4
_b$ = 8							; size = 4
_n$ = 12						; size = 4
?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z PROC		; stbtt__buf_get, COMDAT

; 1142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1143 :    stbtt_uint32 v = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0

; 1144 :    int i;
; 1145 :    STBTT_assert(n >= 1 && n <= 4);

  0002f	83 7d 0c 01	 cmp	 DWORD PTR _n$[ebp], 1
  00033	7c 06		 jl	 SHORT $LN6@stbtt__buf
  00035	83 7d 0c 04	 cmp	 DWORD PTR _n$[ebp], 4
  00039	7e 25		 jle	 SHORT $LN7@stbtt__buf
$LN6@stbtt__buf:
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z@4JA
  00040	83 c0 03	 add	 eax, 3
  00043	8b f4		 mov	 esi, esp
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@stbtt__buf:

; 1146 :    for (i = 0; i < n; i++)

  00060	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00067	eb 09		 jmp	 SHORT $LN4@stbtt__buf
$LN2@stbtt__buf:
  00069	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0006c	83 c0 01	 add	 eax, 1
  0006f	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt__buf:
  00072	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00075	3b 45 0c	 cmp	 eax, DWORD PTR _n$[ebp]
  00078	7d 1c		 jge	 SHORT $LN3@stbtt__buf

; 1147 :       v = (v << 8) | stbtt__buf_get8(b);

  0007a	8b 75 f8	 mov	 esi, DWORD PTR _v$[ebp]
  0007d	c1 e6 08	 shl	 esi, 8
  00080	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ; stbtt__buf_get8
  00089	83 c4 04	 add	 esp, 4
  0008c	0f b6 c8	 movzx	 ecx, al
  0008f	0b f1		 or	 esi, ecx
  00091	89 75 f8	 mov	 DWORD PTR _v$[ebp], esi
  00094	eb d3		 jmp	 SHORT $LN2@stbtt__buf
$LN3@stbtt__buf:

; 1148 :    return v;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]

; 1149 : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a2	3b ec		 cmp	 ebp, esp
  000a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ENDP		; stbtt__buf_get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
_o$ = 12						; size = 4
?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z PROC		; stbtt__buf_skip, COMDAT

; 1137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1138 :    stbtt__buf_seek(b, b->cursor + o);

  00028	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	03 4d 0c	 add	 ecx, DWORD PTR _o$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _b$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ; stbtt__buf_seek
  0003b	83 c4 08	 add	 esp, 8

; 1139 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ENDP		; stbtt__buf_skip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z
_TEXT	SEGMENT
tv77 = -196						; size = 4
_b$ = 8							; size = 4
_o$ = 12						; size = 4
?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z PROC		; stbtt__buf_seek, COMDAT

; 1131 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1132 :    STBTT_assert(!(o > b->size || o < 0));

  00028	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _o$[ebp]
  0002e	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00031	7f 06		 jg	 SHORT $LN3@stbtt__buf
  00033	83 7d 0c 00	 cmp	 DWORD PTR _o$[ebp], 0
  00037	7d 26		 jge	 SHORT $LN4@stbtt__buf
$LN3@stbtt__buf:
  00039	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z@4JA
  0003f	83 c2 01	 add	 edx, 1
  00042	8b f4		 mov	 esi, esp
  00044	52		 push	 edx
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@stbtt__buf:

; 1133 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _o$[ebp]
  00065	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00068	7f 11		 jg	 SHORT $LN5@stbtt__buf
  0006a	83 7d 0c 00	 cmp	 DWORD PTR _o$[ebp], 0
  0006e	7c 0b		 jl	 SHORT $LN5@stbtt__buf
  00070	8b 55 0c	 mov	 edx, DWORD PTR _o$[ebp]
  00073	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], edx
  00079	eb 0c		 jmp	 SHORT $LN6@stbtt__buf
$LN5@stbtt__buf:
  0007b	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0007e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00081	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
$LN6@stbtt__buf:
  00087	8b 55 08	 mov	 edx, DWORD PTR _b$[ebp]
  0008a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  00090	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1134 : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ENDP		; stbtt__buf_seek
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z PROC		; stbtt__buf_peek8, COMDAT

; 1124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1125 :    if (b->cursor >= b->size)

  00028	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _b$[ebp]
  0002e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00031	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00034	7c 04		 jl	 SHORT $LN2@stbtt__buf

; 1126 :       return 0;

  00036	32 c0		 xor	 al, al
  00038	eb 0e		 jmp	 SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1127 :    return b->data[b->cursor];

  0003a	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	8b 55 08	 mov	 edx, DWORD PTR _b$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
$LN1@stbtt__buf:

; 1128 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z ENDP		; stbtt__buf_peek8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT ?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z
_TEXT	SEGMENT
tv74 = -193						; size = 1
_b$ = 8							; size = 4
?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z PROC		; stbtt__buf_get8, COMDAT

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1118 :    if (b->cursor >= b->size)

  00028	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _b$[ebp]
  0002e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00031	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00034	7c 04		 jl	 SHORT $LN2@stbtt__buf

; 1119 :       return 0;

  00036	32 c0		 xor	 al, al
  00038	eb 29		 jmp	 SHORT $LN1@stbtt__buf
$LN2@stbtt__buf:

; 1120 :    return b->data[b->cursor++];

  0003a	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	8b 55 08	 mov	 edx, DWORD PTR _b$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00048	88 8d 3f ff ff
	ff		 mov	 BYTE PTR tv74[ebp], cl
  0004e	8b 55 08	 mov	 edx, DWORD PTR _b$[ebp]
  00051	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00054	83 c0 01	 add	 eax, 1
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _b$[ebp]
  0005a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005d	8a 85 3f ff ff
	ff		 mov	 al, BYTE PTR tv74[ebp]
$LN1@stbtt__buf:

; 1121 : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ENDP		; stbtt__buf_get8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_Rasterize
_TEXT	SEGMENT
tv65 = -248						; size = 4
_windings$ = -48					; size = 4
_winding_lengths$ = -36					; size = 4
_winding_count$ = -24					; size = 4
_scale$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_result$ = 8						; size = 4
_flatness_in_pixels$ = 12				; size = 4
_vertices$ = 16						; size = 4
_num_verts$ = 20					; size = 4
_scale_x$ = 24						; size = 4
_scale_y$ = 28						; size = 4
_shift_x$ = 32						; size = 4
_shift_y$ = 36						; size = 4
_x_off$ = 40						; size = 4
_y_off$ = 44						; size = 4
_invert$ = 48						; size = 4
_userdata$ = 52						; size = 4
_stbtt_Rasterize PROC					; COMDAT

; 3536 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3537 :    float scale            = scale_x > scale_y ? scale_y : scale_x;

  00032	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _scale_x$[ebp]
  00037	0f 2f 45 1c	 comiss	 xmm0, DWORD PTR _scale_y$[ebp]
  0003b	76 0f		 jbe	 SHORT $LN4@stbtt_Rast
  0003d	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_y$[ebp]
  00042	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
  0004a	eb 0d		 jmp	 SHORT $LN5@stbtt_Rast
$LN4@stbtt_Rast:
  0004c	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _scale_x$[ebp]
  00051	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
$LN5@stbtt_Rast:
  00059	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR tv65[ebp]
  00061	f3 0f 11 45 f4	 movss	 DWORD PTR _scale$[ebp], xmm0

; 3538 :    int winding_count      = 0;

  00066	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _winding_count$[ebp], 0

; 3539 :    int *winding_lengths   = NULL;

  0006d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _winding_lengths$[ebp], 0

; 3540 :    stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

  00074	8b 45 34	 mov	 eax, DWORD PTR _userdata$[ebp]
  00077	50		 push	 eax
  00078	8d 4d e8	 lea	 ecx, DWORD PTR _winding_count$[ebp]
  0007b	51		 push	 ecx
  0007c	8d 55 dc	 lea	 edx, DWORD PTR _winding_lengths$[ebp]
  0007f	52		 push	 edx
  00080	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _flatness_in_pixels$[ebp]
  00085	f3 0f 5e 45 f4	 divss	 xmm0, DWORD PTR _scale$[ebp]
  0008a	51		 push	 ecx
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	8b 45 14	 mov	 eax, DWORD PTR _num_verts$[ebp]
  00093	50		 push	 eax
  00094	8b 4d 10	 mov	 ecx, DWORD PTR _vertices$[ebp]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ?stbtt_FlattenCurves@@YAPAUstbtt__point@@PAUstbtt_vertex@@HMPAPAHPAHPAX@Z ; stbtt_FlattenCurves
  0009d	83 c4 18	 add	 esp, 24			; 00000018H
  000a0	89 45 d0	 mov	 DWORD PTR _windings$[ebp], eax

; 3541 :    if (windings) {

  000a3	83 7d d0 00	 cmp	 DWORD PTR _windings$[ebp], 0
  000a7	74 6c		 je	 SHORT $LN2@stbtt_Rast

; 3542 :       stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

  000a9	8b 45 34	 mov	 eax, DWORD PTR _userdata$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d 30	 mov	 ecx, DWORD PTR _invert$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 2c	 mov	 edx, DWORD PTR _y_off$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 28	 mov	 eax, DWORD PTR _x_off$[ebp]
  000b8	50		 push	 eax
  000b9	51		 push	 ecx
  000ba	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _shift_y$[ebp]
  000bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c4	51		 push	 ecx
  000c5	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _shift_x$[ebp]
  000ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cf	51		 push	 ecx
  000d0	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_y$[ebp]
  000d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000da	51		 push	 ecx
  000db	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _scale_x$[ebp]
  000e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _winding_count$[ebp]
  000e8	51		 push	 ecx
  000e9	8b 55 dc	 mov	 edx, DWORD PTR _winding_lengths$[ebp]
  000ec	52		 push	 edx
  000ed	8b 45 d0	 mov	 eax, DWORD PTR _windings$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _result$[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 ?stbtt__rasterize@@YAXPAUstbtt__bitmap@@PAUstbtt__point@@PAHHMMMMHHHPAX@Z ; stbtt__rasterize
  000fa	83 c4 30	 add	 esp, 48			; 00000030H

; 3543 :       STBTT_free(winding_lengths, userdata);

  000fd	8b 45 dc	 mov	 eax, DWORD PTR _winding_lengths$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00106	83 c4 04	 add	 esp, 4

; 3544 :       STBTT_free(windings, userdata);

  00109	8b 45 d0	 mov	 eax, DWORD PTR _windings$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00112	83 c4 04	 add	 esp, 4
$LN2@stbtt_Rast:

; 3545 :    }
; 3546 : }

  00115	52		 push	 edx
  00116	8b cd		 mov	 ecx, ebp
  00118	50		 push	 eax
  00119	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@stbtt_Rast
  0011f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00124	58		 pop	 eax
  00125	5a		 pop	 edx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012c	33 cd		 xor	 ecx, ebp
  0012e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00133	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  00139	3b ec		 cmp	 ebp, esp
  0013b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
$LN9@stbtt_Rast:
  00144	02 00 00 00	 DD	 2
  00148	00 00 00 00	 DD	 $LN8@stbtt_Rast
$LN8@stbtt_Rast:
  0014c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00150	04 00 00 00	 DD	 4
  00154	00 00 00 00	 DD	 $LN6@stbtt_Rast
  00158	dc ff ff ff	 DD	 -36			; ffffffdcH
  0015c	04 00 00 00	 DD	 4
  00160	00 00 00 00	 DD	 $LN7@stbtt_Rast
$LN7@stbtt_Rast:
  00164	77		 DB	 119			; 00000077H
  00165	69		 DB	 105			; 00000069H
  00166	6e		 DB	 110			; 0000006eH
  00167	64		 DB	 100			; 00000064H
  00168	69		 DB	 105			; 00000069H
  00169	6e		 DB	 110			; 0000006eH
  0016a	67		 DB	 103			; 00000067H
  0016b	5f		 DB	 95			; 0000005fH
  0016c	6c		 DB	 108			; 0000006cH
  0016d	65		 DB	 101			; 00000065H
  0016e	6e		 DB	 110			; 0000006eH
  0016f	67		 DB	 103			; 00000067H
  00170	74		 DB	 116			; 00000074H
  00171	68		 DB	 104			; 00000068H
  00172	73		 DB	 115			; 00000073H
  00173	00		 DB	 0
$LN6@stbtt_Rast:
  00174	77		 DB	 119			; 00000077H
  00175	69		 DB	 105			; 00000069H
  00176	6e		 DB	 110			; 0000006eH
  00177	64		 DB	 100			; 00000064H
  00178	69		 DB	 105			; 00000069H
  00179	6e		 DB	 110			; 0000006eH
  0017a	67		 DB	 103			; 00000067H
  0017b	5f		 DB	 95			; 0000005fH
  0017c	63		 DB	 99			; 00000063H
  0017d	6f		 DB	 111			; 0000006fH
  0017e	75		 DB	 117			; 00000075H
  0017f	6e		 DB	 110			; 0000006eH
  00180	74		 DB	 116			; 00000074H
  00181	00		 DB	 0
_stbtt_Rasterize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetGlyphBitmapBoxSubpixel
_TEXT	SEGMENT
_y1$ = -48						; size = 4
_x1$ = -36						; size = 4
_y0$ = -24						; size = 4
_x0$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_font$ = 8						; size = 4
_glyph$ = 12						; size = 4
_scale_x$ = 16						; size = 4
_scale_y$ = 20						; size = 4
_shift_x$ = 24						; size = 4
_shift_y$ = 28						; size = 4
_ix0$ = 32						; size = 4
_iy0$ = 36						; size = 4
_ix1$ = 40						; size = 4
_iy1$ = 44						; size = 4
_stbtt_GetGlyphBitmapBoxSubpixel PROC			; COMDAT

; 2630 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2631 :    int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x0$[ebp], 0
  00039	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _y0$[ebp], 0

; 2632 :    if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {

  00040	8d 45 d0	 lea	 eax, DWORD PTR _y1$[ebp]
  00043	50		 push	 eax
  00044	8d 4d dc	 lea	 ecx, DWORD PTR _x1$[ebp]
  00047	51		 push	 ecx
  00048	8d 55 e8	 lea	 edx, DWORD PTR _y0$[ebp]
  0004b	52		 push	 edx
  0004c	8d 45 f4	 lea	 eax, DWORD PTR _x0$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _stbtt_GetGlyphBox
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	85 c0		 test	 eax, eax
  00062	75 41		 jne	 SHORT $LN2@stbtt_GetG

; 2633 :       // e.g. space character
; 2634 :       if (ix0) *ix0 = 0;

  00064	83 7d 20 00	 cmp	 DWORD PTR _ix0$[ebp], 0
  00068	74 09		 je	 SHORT $LN4@stbtt_GetG
  0006a	8b 45 20	 mov	 eax, DWORD PTR _ix0$[ebp]
  0006d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN4@stbtt_GetG:

; 2635 :       if (iy0) *iy0 = 0;

  00073	83 7d 24 00	 cmp	 DWORD PTR _iy0$[ebp], 0
  00077	74 09		 je	 SHORT $LN5@stbtt_GetG
  00079	8b 45 24	 mov	 eax, DWORD PTR _iy0$[ebp]
  0007c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN5@stbtt_GetG:

; 2636 :       if (ix1) *ix1 = 0;

  00082	83 7d 28 00	 cmp	 DWORD PTR _ix1$[ebp], 0
  00086	74 09		 je	 SHORT $LN6@stbtt_GetG
  00088	8b 45 28	 mov	 eax, DWORD PTR _ix1$[ebp]
  0008b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN6@stbtt_GetG:

; 2637 :       if (iy1) *iy1 = 0;

  00091	83 7d 2c 00	 cmp	 DWORD PTR _iy1$[ebp], 0
  00095	74 09		 je	 SHORT $LN7@stbtt_GetG
  00097	8b 45 2c	 mov	 eax, DWORD PTR _iy1$[ebp]
  0009a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN7@stbtt_GetG:

; 2638 :    } else {

  000a0	e9 bc 00 00 00	 jmp	 $LN11@stbtt_GetG
$LN2@stbtt_GetG:

; 2639 :       // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
; 2640 :       if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);

  000a5	83 7d 20 00	 cmp	 DWORD PTR _ix0$[ebp], 0
  000a9	74 27		 je	 SHORT $LN8@stbtt_GetG
  000ab	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _x0$[ebp]
  000b0	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _scale_x$[ebp]
  000b5	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _shift_x$[ebp]
  000ba	51		 push	 ecx
  000bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c0	e8 00 00 00 00	 call	 ?ImFloorStd@@YAMM@Z	; ImFloorStd
  000c5	83 c4 04	 add	 esp, 4
  000c8	e8 00 00 00 00	 call	 __ftol2_sse
  000cd	8b 4d 20	 mov	 ecx, DWORD PTR _ix0$[ebp]
  000d0	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@stbtt_GetG:

; 2641 :       if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  000d2	83 7d 24 00	 cmp	 DWORD PTR _iy0$[ebp], 0
  000d6	74 2b		 je	 SHORT $LN9@stbtt_GetG
  000d8	8b 45 d0	 mov	 eax, DWORD PTR _y1$[ebp]
  000db	f7 d8		 neg	 eax
  000dd	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e1	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _scale_y$[ebp]
  000e6	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _shift_y$[ebp]
  000eb	51		 push	 ecx
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	e8 00 00 00 00	 call	 ?ImFloorStd@@YAMM@Z	; ImFloorStd
  000f6	83 c4 04	 add	 esp, 4
  000f9	e8 00 00 00 00	 call	 __ftol2_sse
  000fe	8b 4d 24	 mov	 ecx, DWORD PTR _iy0$[ebp]
  00101	89 01		 mov	 DWORD PTR [ecx], eax
$LN9@stbtt_GetG:

; 2642 :       if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);

  00103	83 7d 28 00	 cmp	 DWORD PTR _ix1$[ebp], 0
  00107	74 27		 je	 SHORT $LN10@stbtt_GetG
  00109	f3 0f 2a 45 dc	 cvtsi2ss xmm0, DWORD PTR _x1$[ebp]
  0010e	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _scale_x$[ebp]
  00113	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _shift_x$[ebp]
  00118	51		 push	 ecx
  00119	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011e	e8 00 00 00 00	 call	 ?ImCeil@@YAMM@Z		; ImCeil
  00123	83 c4 04	 add	 esp, 4
  00126	e8 00 00 00 00	 call	 __ftol2_sse
  0012b	8b 4d 28	 mov	 ecx, DWORD PTR _ix1$[ebp]
  0012e	89 01		 mov	 DWORD PTR [ecx], eax
$LN10@stbtt_GetG:

; 2643 :       if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);

  00130	83 7d 2c 00	 cmp	 DWORD PTR _iy1$[ebp], 0
  00134	74 2b		 je	 SHORT $LN11@stbtt_GetG
  00136	8b 45 e8	 mov	 eax, DWORD PTR _y0$[ebp]
  00139	f7 d8		 neg	 eax
  0013b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0013f	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _scale_y$[ebp]
  00144	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _shift_y$[ebp]
  00149	51		 push	 ecx
  0014a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014f	e8 00 00 00 00	 call	 ?ImCeil@@YAMM@Z		; ImCeil
  00154	83 c4 04	 add	 esp, 4
  00157	e8 00 00 00 00	 call	 __ftol2_sse
  0015c	8b 4d 2c	 mov	 ecx, DWORD PTR _iy1$[ebp]
  0015f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@stbtt_GetG:

; 2644 :    }
; 2645 : }

  00161	52		 push	 edx
  00162	8b cd		 mov	 ecx, ebp
  00164	50		 push	 eax
  00165	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@stbtt_GetG
  0016b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00170	58		 pop	 eax
  00171	5a		 pop	 edx
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00178	33 cd		 xor	 ecx, ebp
  0017a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017f	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  00185	3b ec		 cmp	 ebp, esp
  00187	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
$LN18@stbtt_GetG:
  00190	04 00 00 00	 DD	 4
  00194	00 00 00 00	 DD	 $LN17@stbtt_GetG
$LN17@stbtt_GetG:
  00198	f4 ff ff ff	 DD	 -12			; fffffff4H
  0019c	04 00 00 00	 DD	 4
  001a0	00 00 00 00	 DD	 $LN13@stbtt_GetG
  001a4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  001a8	04 00 00 00	 DD	 4
  001ac	00 00 00 00	 DD	 $LN14@stbtt_GetG
  001b0	dc ff ff ff	 DD	 -36			; ffffffdcH
  001b4	04 00 00 00	 DD	 4
  001b8	00 00 00 00	 DD	 $LN15@stbtt_GetG
  001bc	d0 ff ff ff	 DD	 -48			; ffffffd0H
  001c0	04 00 00 00	 DD	 4
  001c4	00 00 00 00	 DD	 $LN16@stbtt_GetG
$LN16@stbtt_GetG:
  001c8	79		 DB	 121			; 00000079H
  001c9	31		 DB	 49			; 00000031H
  001ca	00		 DB	 0
$LN15@stbtt_GetG:
  001cb	78		 DB	 120			; 00000078H
  001cc	31		 DB	 49			; 00000031H
  001cd	00		 DB	 0
$LN14@stbtt_GetG:
  001ce	79		 DB	 121			; 00000079H
  001cf	30		 DB	 48			; 00000030H
  001d0	00		 DB	 0
$LN13@stbtt_GetG:
  001d1	78		 DB	 120			; 00000078H
  001d2	30		 DB	 48			; 00000030H
  001d3	00		 DB	 0
_stbtt_GetGlyphBitmapBoxSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetGlyphBitmapBox
_TEXT	SEGMENT
_font$ = 8						; size = 4
_glyph$ = 12						; size = 4
_scale_x$ = 16						; size = 4
_scale_y$ = 20						; size = 4
_ix0$ = 24						; size = 4
_iy0$ = 28						; size = 4
_ix1$ = 32						; size = 4
_iy1$ = 36						; size = 4
_stbtt_GetGlyphBitmapBox PROC				; COMDAT

; 2648 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2649 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

  00028	8b 45 24	 mov	 eax, DWORD PTR _iy1$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 20	 mov	 ecx, DWORD PTR _ix1$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 1c	 mov	 edx, DWORD PTR _iy0$[ebp]
  00033	52		 push	 edx
  00034	8b 45 18	 mov	 eax, DWORD PTR _ix0$[ebp]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	0f 57 c0	 xorps	 xmm0, xmm0
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	51		 push	 ecx
  00042	0f 57 c0	 xorps	 xmm0, xmm0
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	51		 push	 ecx
  0004b	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale_y$[ebp]
  00050	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00055	51		 push	 ecx
  00056	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _scale_x$[ebp]
  0005b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR _font$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 _stbtt_GetGlyphBitmapBoxSubpixel
  0006d	83 c4 28	 add	 esp, 40			; 00000028H

; 2650 : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_stbtt_GetGlyphBitmapBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_MakeGlyphBitmapSubpixel
_TEXT	SEGMENT
_gbm$ = -72						; size = 16
_num_verts$ = -48					; size = 4
_vertices$ = -36					; size = 4
_iy0$ = -24						; size = 4
_ix0$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_output$ = 12						; size = 4
_out_w$ = 16						; size = 4
_out_h$ = 20						; size = 4
_out_stride$ = 24					; size = 4
_scale_x$ = 28						; size = 4
_scale_y$ = 32						; size = 4
_shift_x$ = 36						; size = 4
_shift_y$ = 40						; size = 4
_glyph$ = 44						; size = 4
_stbtt_MakeGlyphBitmapSubpixel PROC			; COMDAT

; 3599 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3600 :    int ix0,iy0;
; 3601 :    stbtt_vertex *vertices;
; 3602 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

  00032	8d 45 dc	 lea	 eax, DWORD PTR _vertices$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 2c	 mov	 ecx, DWORD PTR _glyph$[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _stbtt_GetGlyphShape
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	89 45 d0	 mov	 DWORD PTR _num_verts$[ebp], eax

; 3603 :    stbtt__bitmap gbm;   
; 3604 : 
; 3605 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);

  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	8d 45 e8	 lea	 eax, DWORD PTR _iy0$[ebp]
  00050	50		 push	 eax
  00051	8d 4d f4	 lea	 ecx, DWORD PTR _ix0$[ebp]
  00054	51		 push	 ecx
  00055	51		 push	 ecx
  00056	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _shift_y$[ebp]
  0005b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00060	51		 push	 ecx
  00061	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _shift_x$[ebp]
  00066	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006b	51		 push	 ecx
  0006c	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _scale_y$[ebp]
  00071	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00076	51		 push	 ecx
  00077	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_x$[ebp]
  0007c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00081	8b 55 2c	 mov	 edx, DWORD PTR _glyph$[ebp]
  00084	52		 push	 edx
  00085	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _stbtt_GetGlyphBitmapBoxSubpixel
  0008e	83 c4 28	 add	 esp, 40			; 00000028H

; 3606 :    gbm.pixels = output;

  00091	8b 45 0c	 mov	 eax, DWORD PTR _output$[ebp]
  00094	89 45 c4	 mov	 DWORD PTR _gbm$[ebp+12], eax

; 3607 :    gbm.w = out_w;

  00097	8b 45 10	 mov	 eax, DWORD PTR _out_w$[ebp]
  0009a	89 45 b8	 mov	 DWORD PTR _gbm$[ebp], eax

; 3608 :    gbm.h = out_h;

  0009d	8b 45 14	 mov	 eax, DWORD PTR _out_h$[ebp]
  000a0	89 45 bc	 mov	 DWORD PTR _gbm$[ebp+4], eax

; 3609 :    gbm.stride = out_stride;

  000a3	8b 45 18	 mov	 eax, DWORD PTR _out_stride$[ebp]
  000a6	89 45 c0	 mov	 DWORD PTR _gbm$[ebp+8], eax

; 3610 : 
; 3611 :    if (gbm.w && gbm.h)

  000a9	83 7d b8 00	 cmp	 DWORD PTR _gbm$[ebp], 0
  000ad	74 64		 je	 SHORT $LN2@stbtt_Make
  000af	83 7d bc 00	 cmp	 DWORD PTR _gbm$[ebp+4], 0
  000b3	74 5e		 je	 SHORT $LN2@stbtt_Make

; 3612 :       stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

  000b5	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	51		 push	 ecx
  000bb	6a 01		 push	 1
  000bd	8b 55 e8	 mov	 edx, DWORD PTR _iy0$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _ix0$[ebp]
  000c4	50		 push	 eax
  000c5	51		 push	 ecx
  000c6	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _shift_y$[ebp]
  000cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d0	51		 push	 ecx
  000d1	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _shift_x$[ebp]
  000d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000db	51		 push	 ecx
  000dc	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _scale_y$[ebp]
  000e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e6	51		 push	 ecx
  000e7	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _scale_x$[ebp]
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	8b 4d d0	 mov	 ecx, DWORD PTR _num_verts$[ebp]
  000f4	51		 push	 ecx
  000f5	8b 55 dc	 mov	 edx, DWORD PTR _vertices$[ebp]
  000f8	52		 push	 edx
  000f9	51		 push	 ecx
  000fa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  00102	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00107	8d 45 b8	 lea	 eax, DWORD PTR _gbm$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 _stbtt_Rasterize
  00110	83 c4 30	 add	 esp, 48			; 00000030H
$LN2@stbtt_Make:

; 3613 : 
; 3614 :    STBTT_free(vertices, info->userdata);

  00113	8b 45 dc	 mov	 eax, DWORD PTR _vertices$[ebp]
  00116	50		 push	 eax
  00117	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0011c	83 c4 04	 add	 esp, 4

; 3615 : }

  0011f	52		 push	 edx
  00120	8b cd		 mov	 ecx, ebp
  00122	50		 push	 eax
  00123	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@stbtt_Make
  00129	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012e	58		 pop	 eax
  0012f	5a		 pop	 edx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00143	3b ec		 cmp	 ebp, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
  0014e	66 90		 npad	 2
$LN9@stbtt_Make:
  00150	04 00 00 00	 DD	 4
  00154	00 00 00 00	 DD	 $LN8@stbtt_Make
$LN8@stbtt_Make:
  00158	f4 ff ff ff	 DD	 -12			; fffffff4H
  0015c	04 00 00 00	 DD	 4
  00160	00 00 00 00	 DD	 $LN4@stbtt_Make
  00164	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00168	04 00 00 00	 DD	 4
  0016c	00 00 00 00	 DD	 $LN5@stbtt_Make
  00170	dc ff ff ff	 DD	 -36			; ffffffdcH
  00174	04 00 00 00	 DD	 4
  00178	00 00 00 00	 DD	 $LN6@stbtt_Make
  0017c	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00180	10 00 00 00	 DD	 16			; 00000010H
  00184	00 00 00 00	 DD	 $LN7@stbtt_Make
$LN7@stbtt_Make:
  00188	67		 DB	 103			; 00000067H
  00189	62		 DB	 98			; 00000062H
  0018a	6d		 DB	 109			; 0000006dH
  0018b	00		 DB	 0
$LN6@stbtt_Make:
  0018c	76		 DB	 118			; 00000076H
  0018d	65		 DB	 101			; 00000065H
  0018e	72		 DB	 114			; 00000072H
  0018f	74		 DB	 116			; 00000074H
  00190	69		 DB	 105			; 00000069H
  00191	63		 DB	 99			; 00000063H
  00192	65		 DB	 101			; 00000065H
  00193	73		 DB	 115			; 00000073H
  00194	00		 DB	 0
$LN5@stbtt_Make:
  00195	69		 DB	 105			; 00000069H
  00196	79		 DB	 121			; 00000079H
  00197	30		 DB	 48			; 00000030H
  00198	00		 DB	 0
$LN4@stbtt_Make:
  00199	69		 DB	 105			; 00000069H
  0019a	78		 DB	 120			; 00000078H
  0019b	30		 DB	 48			; 00000030H
  0019c	00		 DB	 0
_stbtt_MakeGlyphBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetGlyphShape
_TEXT	SEGMENT
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_pvertices$ = 16					; size = 4
_stbtt_GetGlyphShape PROC				; COMDAT

; 2266 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2267 :    if (!info->cff.size)

  00028	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002b	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0002f	75 18		 jne	 SHORT $LN2@stbtt_GetG

; 2268 :       return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

  00031	8b 45 10	 mov	 eax, DWORD PTR _pvertices$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph_index$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	eb 16		 jmp	 SHORT $LN1@stbtt_GetG
  00047	eb 14		 jmp	 SHORT $LN1@stbtt_GetG
$LN2@stbtt_GetG:

; 2269 :    else
; 2270 :       return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

  00049	8b 45 10	 mov	 eax, DWORD PTR _pvertices$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph_index$[ebp]
  00050	51		 push	 ecx
  00051	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 ?stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeT2
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@stbtt_GetG:

; 2271 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_stbtt_GetGlyphShape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetGlyphBox
_TEXT	SEGMENT
_g$1 = -8						; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
_stbtt_GetGlyphBox PROC					; COMDAT

; 1591 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1592 :    if (info->cff.size) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002b	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0002f	74 25		 je	 SHORT $LN2@stbtt_GetG

; 1593 :       stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);

  00031	8b 45 1c	 mov	 eax, DWORD PTR _y1$[ebp]
  00034	50		 push	 eax
  00035	8b 4d 18	 mov	 ecx, DWORD PTR _x1$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 14	 mov	 edx, DWORD PTR _y0$[ebp]
  0003c	52		 push	 edx
  0003d	8b 45 10	 mov	 eax, DWORD PTR _x0$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _glyph_index$[ebp]
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?stbtt__GetGlyphInfoT2@@YAHPBUstbtt_fontinfo@@HPAH111@Z ; stbtt__GetGlyphInfoT2
  0004e	83 c4 18	 add	 esp, 24			; 00000018H

; 1594 :    } else {

  00051	e9 b0 00 00 00	 jmp	 $LN3@stbtt_GetG
$LN2@stbtt_GetG:

; 1595 :       int g = stbtt__GetGlyfOffset(info, glyph_index);

  00056	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
  00063	83 c4 08	 add	 esp, 8
  00066	89 45 f8	 mov	 DWORD PTR _g$1[ebp], eax

; 1596 :       if (g < 0) return 0;

  00069	83 7d f8 00	 cmp	 DWORD PTR _g$1[ebp], 0
  0006d	7d 07		 jge	 SHORT $LN4@stbtt_GetG
  0006f	33 c0		 xor	 eax, eax
  00071	e9 95 00 00 00	 jmp	 $LN1@stbtt_GetG
$LN4@stbtt_GetG:

; 1597 : 
; 1598 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

  00076	83 7d 10 00	 cmp	 DWORD PTR _x0$[ebp], 0
  0007a	74 1e		 je	 SHORT $LN5@stbtt_GetG
  0007c	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0007f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00082	8b 55 f8	 mov	 edx, DWORD PTR _g$1[ebp]
  00085	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0008f	83 c4 04	 add	 esp, 4
  00092	0f bf c8	 movsx	 ecx, ax
  00095	8b 55 10	 mov	 edx, DWORD PTR _x0$[ebp]
  00098	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@stbtt_GetG:

; 1599 :       if (y0) *y0 = ttSHORT(info->data + g + 4);

  0009a	83 7d 14 00	 cmp	 DWORD PTR _y0$[ebp], 0
  0009e	74 1e		 je	 SHORT $LN6@stbtt_GetG
  000a0	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a6	8b 55 f8	 mov	 edx, DWORD PTR _g$1[ebp]
  000a9	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  000b3	83 c4 04	 add	 esp, 4
  000b6	0f bf c8	 movsx	 ecx, ax
  000b9	8b 55 14	 mov	 edx, DWORD PTR _y0$[ebp]
  000bc	89 0a		 mov	 DWORD PTR [edx], ecx
$LN6@stbtt_GetG:

; 1600 :       if (x1) *x1 = ttSHORT(info->data + g + 6);

  000be	83 7d 18 00	 cmp	 DWORD PTR _x1$[ebp], 0
  000c2	74 1e		 je	 SHORT $LN7@stbtt_GetG
  000c4	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ca	8b 55 f8	 mov	 edx, DWORD PTR _g$1[ebp]
  000cd	8d 44 11 06	 lea	 eax, DWORD PTR [ecx+edx+6]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  000d7	83 c4 04	 add	 esp, 4
  000da	0f bf c8	 movsx	 ecx, ax
  000dd	8b 55 18	 mov	 edx, DWORD PTR _x1$[ebp]
  000e0	89 0a		 mov	 DWORD PTR [edx], ecx
$LN7@stbtt_GetG:

; 1601 :       if (y1) *y1 = ttSHORT(info->data + g + 8);

  000e2	83 7d 1c 00	 cmp	 DWORD PTR _y1$[ebp], 0
  000e6	74 1e		 je	 SHORT $LN3@stbtt_GetG
  000e8	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _g$1[ebp]
  000f1	8d 44 11 08	 lea	 eax, DWORD PTR [ecx+edx+8]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  000fb	83 c4 04	 add	 esp, 4
  000fe	0f bf c8	 movsx	 ecx, ax
  00101	8b 55 1c	 mov	 edx, DWORD PTR _y1$[ebp]
  00104	89 0a		 mov	 DWORD PTR [edx], ecx
$LN3@stbtt_GetG:

; 1602 :    }
; 1603 :    return 1;

  00106	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_GetG:

; 1604 : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00114	3b ec		 cmp	 ebp, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
_stbtt_GetGlyphBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetGlyphHMetrics
_TEXT	SEGMENT
_numOfLongHorMetrics$ = -8				; size = 2
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_advanceWidth$ = 16					; size = 4
_leftSideBearing$ = 20					; size = 4
_stbtt_GetGlyphHMetrics PROC				; COMDAT

; 2274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2275 :    stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);

  00028	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00031	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00034	8d 4c 01 22	 lea	 ecx, DWORD PTR [ecx+eax+34]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  0003e	83 c4 04	 add	 esp, 4
  00041	66 89 45 f8	 mov	 WORD PTR _numOfLongHorMetrics$[ebp], ax

; 2276 :    if (glyph_index < numOfLongHorMetrics) {

  00045	0f b7 45 f8	 movzx	 eax, WORD PTR _numOfLongHorMetrics$[ebp]
  00049	39 45 0c	 cmp	 DWORD PTR _glyph_index$[ebp], eax
  0004c	7d 55		 jge	 SHORT $LN2@stbtt_GetG

; 2277 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

  0004e	83 7d 10 00	 cmp	 DWORD PTR _advanceWidth$[ebp], 0
  00052	74 23		 je	 SHORT $LN4@stbtt_GetG
  00054	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00057	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005a	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0005d	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  00060	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  00063	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0006c	83 c4 04	 add	 esp, 4
  0006f	0f bf d0	 movsx	 edx, ax
  00072	8b 45 10	 mov	 eax, DWORD PTR _advanceWidth$[ebp]
  00075	89 10		 mov	 DWORD PTR [eax], edx
$LN4@stbtt_GetG:

; 2278 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);

  00077	83 7d 14 00	 cmp	 DWORD PTR _leftSideBearing$[ebp], 0
  0007b	74 24		 je	 SHORT $LN5@stbtt_GetG
  0007d	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00080	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00083	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00086	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  00089	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  0008c	8d 4c 81 02	 lea	 ecx, DWORD PTR [ecx+eax*4+2]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00096	83 c4 04	 add	 esp, 4
  00099	0f bf d0	 movsx	 edx, ax
  0009c	8b 45 14	 mov	 eax, DWORD PTR _leftSideBearing$[ebp]
  0009f	89 10		 mov	 DWORD PTR [eax], edx
$LN5@stbtt_GetG:

; 2279 :    } else {

  000a1	eb 61		 jmp	 SHORT $LN1@stbtt_GetG
$LN2@stbtt_GetG:

; 2280 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));

  000a3	83 7d 10 00	 cmp	 DWORD PTR _advanceWidth$[ebp], 0
  000a7	74 25		 je	 SHORT $LN6@stbtt_GetG
  000a9	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000ac	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000af	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000b2	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  000b5	0f b7 45 f8	 movzx	 eax, WORD PTR _numOfLongHorMetrics$[ebp]
  000b9	8d 4c 81 fc	 lea	 ecx, DWORD PTR [ecx+eax*4-4]
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  000c3	83 c4 04	 add	 esp, 4
  000c6	0f bf d0	 movsx	 edx, ax
  000c9	8b 45 10	 mov	 eax, DWORD PTR _advanceWidth$[ebp]
  000cc	89 10		 mov	 DWORD PTR [eax], edx
$LN6@stbtt_GetG:

; 2281 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));

  000ce	83 7d 14 00	 cmp	 DWORD PTR _leftSideBearing$[ebp], 0
  000d2	74 30		 je	 SHORT $LN1@stbtt_GetG
  000d4	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  000d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000da	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  000dd	03 4a 20	 add	 ecx, DWORD PTR [edx+32]
  000e0	0f b7 45 f8	 movzx	 eax, WORD PTR _numOfLongHorMetrics$[ebp]
  000e4	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  000e7	0f b7 55 f8	 movzx	 edx, WORD PTR _numOfLongHorMetrics$[ebp]
  000eb	8b 45 0c	 mov	 eax, DWORD PTR _glyph_index$[ebp]
  000ee	2b c2		 sub	 eax, edx
  000f0	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  000f9	83 c4 04	 add	 esp, 4
  000fc	0f bf d0	 movsx	 edx, ax
  000ff	8b 45 14	 mov	 eax, DWORD PTR _leftSideBearing$[ebp]
  00102	89 10		 mov	 DWORD PTR [eax], edx
$LN1@stbtt_GetG:

; 2282 :    }
; 2283 : }

  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx
  00107	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0010d	3b ec		 cmp	 ebp, esp
  0010f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
_stbtt_GetGlyphHMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetFontVMetrics
_TEXT	SEGMENT
_info$ = 8						; size = 4
_ascent$ = 12						; size = 4
_descent$ = 16						; size = 4
_lineGap$ = 20						; size = 4
_stbtt_GetFontVMetrics PROC				; COMDAT

; 2582 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2583 :    if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);

  00028	83 7d 0c 00	 cmp	 DWORD PTR _ascent$[ebp], 0
  0002c	74 21		 je	 SHORT $LN2@stbtt_GetF
  0002e	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00031	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00034	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00037	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0003a	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00044	83 c4 04	 add	 esp, 4
  00047	0f bf d0	 movsx	 edx, ax
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _ascent$[ebp]
  0004d	89 10		 mov	 DWORD PTR [eax], edx
$LN2@stbtt_GetF:

; 2584 :    if (descent) *descent = ttSHORT(info->data+info->hhea + 6);

  0004f	83 7d 10 00	 cmp	 DWORD PTR _descent$[ebp], 0
  00053	74 21		 je	 SHORT $LN3@stbtt_GetF
  00055	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00058	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005b	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  0005e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00061	8d 4c 01 06	 lea	 ecx, DWORD PTR [ecx+eax+6]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0006b	83 c4 04	 add	 esp, 4
  0006e	0f bf d0	 movsx	 edx, ax
  00071	8b 45 10	 mov	 eax, DWORD PTR _descent$[ebp]
  00074	89 10		 mov	 DWORD PTR [eax], edx
$LN3@stbtt_GetF:

; 2585 :    if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);

  00076	83 7d 14 00	 cmp	 DWORD PTR _lineGap$[ebp], 0
  0007a	74 21		 je	 SHORT $LN1@stbtt_GetF
  0007c	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0007f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00082	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00085	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00088	8d 4c 01 08	 lea	 ecx, DWORD PTR [ecx+eax+8]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00092	83 c4 04	 add	 esp, 4
  00095	0f bf d0	 movsx	 edx, ax
  00098	8b 45 14	 mov	 eax, DWORD PTR _lineGap$[ebp]
  0009b	89 10		 mov	 DWORD PTR [eax], edx
$LN1@stbtt_GetF:

; 2586 : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_stbtt_GetFontVMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_ScaleForMappingEmToPixels
_TEXT	SEGMENT
tv81 = -208						; size = 4
_unitsPerEm$ = -8					; size = 4
_info$ = 8						; size = 4
_pixels$ = 12						; size = 4
_stbtt_ScaleForMappingEmToPixels PROC			; COMDAT

; 2614 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2615 :    int unitsPerEm = ttUSHORT(info->data + info->head + 18);

  00028	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00031	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00034	8d 4c 01 12	 lea	 ecx, DWORD PTR [ecx+eax+18]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  0003e	83 c4 04	 add	 esp, 4
  00041	0f b7 d0	 movzx	 edx, ax
  00044	89 55 f8	 mov	 DWORD PTR _unitsPerEm$[ebp], edx

; 2616 :    return pixels / unitsPerEm;

  00047	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _unitsPerEm$[ebp]
  0004c	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _pixels$[ebp]
  00051	f3 0f 5e c8	 divss	 xmm1, xmm0
  00055	f3 0f 11 8d 30
	ff ff ff	 movss	 DWORD PTR tv81[ebp], xmm1
  0005d	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv81[ebp]

; 2617 : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_stbtt_ScaleForMappingEmToPixels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_ScaleForPixelHeight
_TEXT	SEGMENT
tv94 = -208						; size = 4
_fheight$ = -8						; size = 4
_info$ = 8						; size = 4
_height$ = 12						; size = 4
_stbtt_ScaleForPixelHeight PROC				; COMDAT

; 2608 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2609 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  00028	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00031	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00034	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0003e	83 c4 04	 add	 esp, 4
  00041	0f bf f0	 movsx	 esi, ax
  00044	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00047	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _info$[ebp]
  0004d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00050	8d 44 10 06	 lea	 eax, DWORD PTR [eax+edx+6]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  0005a	83 c4 04	 add	 esp, 4
  0005d	0f bf c8	 movsx	 ecx, ax
  00060	2b f1		 sub	 esi, ecx
  00062	89 75 f8	 mov	 DWORD PTR _fheight$[ebp], esi

; 2610 :    return (float) height / fheight;

  00065	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _fheight$[ebp]
  0006a	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _height$[ebp]
  0006f	f3 0f 5e c8	 divss	 xmm1, xmm0
  00073	f3 0f 11 8d 30
	ff ff ff	 movss	 DWORD PTR tv94[ebp], xmm1
  0007b	d9 85 30 ff ff
	ff		 fld	 DWORD PTR tv94[ebp]

; 2611 : }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_stbtt_ScaleForPixelHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_FindGlyphIndex
_TEXT	SEGMENT
_start_glyph$1 = -272					; size = 4
_end_char$2 = -260					; size = 4
_start_char$3 = -248					; size = 4
_mid$4 = -236						; size = 4
_high$5 = -224						; size = 4
_low$6 = -212						; size = 4
_ngroups$7 = -200					; size = 4
_item$8 = -188						; size = 2
_start$9 = -176						; size = 2
_offset$10 = -164					; size = 2
_end$11 = -152						; size = 2
_search$12 = -140					; size = 4
_endCount$13 = -128					; size = 4
_rangeShift$14 = -116					; size = 2
_entrySelector$15 = -104				; size = 2
_searchRange$16 = -92					; size = 2
_segcount$17 = -80					; size = 2
_count$18 = -68						; size = 4
_first$19 = -56						; size = 4
_bytes$20 = -44						; size = 4
_format$ = -32						; size = 2
_index_map$ = -20					; size = 4
_data$ = -8						; size = 4
_info$ = 8						; size = 4
_unicode_codepoint$ = 12				; size = 4
_stbtt_FindGlyphIndex PROC				; COMDAT

; 1462 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 01 00
	00		 sub	 esp, 468		; 000001d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-468]
  00012	b9 75 00 00 00	 mov	 ecx, 117		; 00000075H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1463 :    stbtt_uint8 *data = info->data;

  00028	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	89 4d f8	 mov	 DWORD PTR _data$[ebp], ecx

; 1464 :    stbtt_uint32 index_map = info->index_map;

  00031	8b 45 08	 mov	 eax, DWORD PTR _info$[ebp]
  00034	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00037	89 4d ec	 mov	 DWORD PTR _index_map$[ebp], ecx

; 1465 : 
; 1466 :    stbtt_uint16 format = ttUSHORT(data + index_map + 0);

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  0003d	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00046	83 c4 04	 add	 esp, 4
  00049	66 89 45 e0	 mov	 WORD PTR _format$[ebp], ax

; 1467 :    if (format == 0) { // apple byte encoding

  0004d	0f b7 45 e0	 movzx	 eax, WORD PTR _format$[ebp]
  00051	85 c0		 test	 eax, eax
  00053	75 43		 jne	 SHORT $LN6@stbtt_Find

; 1468 :       stbtt_int32 bytes = ttUSHORT(data + index_map + 2);

  00055	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  0005b	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00065	83 c4 04	 add	 esp, 4
  00068	0f b7 c0	 movzx	 eax, ax
  0006b	89 45 d4	 mov	 DWORD PTR _bytes$20[ebp], eax

; 1469 :       if (unicode_codepoint < bytes-6)

  0006e	8b 45 d4	 mov	 eax, DWORD PTR _bytes$20[ebp]
  00071	83 e8 06	 sub	 eax, 6
  00074	39 45 0c	 cmp	 DWORD PTR _unicode_codepoint$[ebp], eax
  00077	7d 13		 jge	 SHORT $LN8@stbtt_Find

; 1470 :          return ttBYTE(data + index_map + 6 + unicode_codepoint);

  00079	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  0007c	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _unicode_codepoint$[ebp]
  00082	0f b6 44 08 06	 movzx	 eax, BYTE PTR [eax+ecx+6]
  00087	e9 b5 04 00 00	 jmp	 $LN1@stbtt_Find
$LN8@stbtt_Find:

; 1471 :       return 0;

  0008c	33 c0		 xor	 eax, eax
  0008e	e9 ae 04 00 00	 jmp	 $LN1@stbtt_Find
  00093	e9 7d 04 00 00	 jmp	 $LN7@stbtt_Find
$LN6@stbtt_Find:

; 1472 :    } else if (format == 6) {

  00098	0f b7 45 e0	 movzx	 eax, WORD PTR _format$[ebp]
  0009c	83 f8 06	 cmp	 eax, 6
  0009f	75 72		 jne	 SHORT $LN9@stbtt_Find

; 1473 :       stbtt_uint32 first = ttUSHORT(data + index_map + 6);

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  000a7	8d 54 01 06	 lea	 edx, DWORD PTR [ecx+eax+6]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  000b1	83 c4 04	 add	 esp, 4
  000b4	0f b7 c0	 movzx	 eax, ax
  000b7	89 45 c8	 mov	 DWORD PTR _first$19[ebp], eax

; 1474 :       stbtt_uint32 count = ttUSHORT(data + index_map + 8);

  000ba	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  000c0	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  000ca	83 c4 04	 add	 esp, 4
  000cd	0f b7 c0	 movzx	 eax, ax
  000d0	89 45 bc	 mov	 DWORD PTR _count$18[ebp], eax

; 1475 :       if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)

  000d3	8b 45 0c	 mov	 eax, DWORD PTR _unicode_codepoint$[ebp]
  000d6	3b 45 c8	 cmp	 eax, DWORD PTR _first$19[ebp]
  000d9	72 2c		 jb	 SHORT $LN11@stbtt_Find
  000db	8b 45 c8	 mov	 eax, DWORD PTR _first$19[ebp]
  000de	03 45 bc	 add	 eax, DWORD PTR _count$18[ebp]
  000e1	39 45 0c	 cmp	 DWORD PTR _unicode_codepoint$[ebp], eax
  000e4	73 21		 jae	 SHORT $LN11@stbtt_Find

; 1476 :          return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);

  000e6	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  000e9	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  000ec	8b 4d 0c	 mov	 ecx, DWORD PTR _unicode_codepoint$[ebp]
  000ef	2b 4d c8	 sub	 ecx, DWORD PTR _first$19[ebp]
  000f2	8d 54 48 0a	 lea	 edx, DWORD PTR [eax+ecx*2+10]
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  000fc	83 c4 04	 add	 esp, 4
  000ff	0f b7 c0	 movzx	 eax, ax
  00102	e9 3a 04 00 00	 jmp	 $LN1@stbtt_Find
$LN11@stbtt_Find:

; 1477 :       return 0;

  00107	33 c0		 xor	 eax, eax
  00109	e9 33 04 00 00	 jmp	 $LN1@stbtt_Find
  0010e	e9 02 04 00 00	 jmp	 $LN7@stbtt_Find
$LN9@stbtt_Find:

; 1478 :    } else if (format == 2) {

  00113	0f b7 45 e0	 movzx	 eax, WORD PTR _format$[ebp]
  00117	83 f8 02	 cmp	 eax, 2
  0011a	75 36		 jne	 SHORT $LN12@stbtt_Find

; 1479 :       STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean

  0011c	33 c0		 xor	 eax, eax
  0011e	75 26		 jne	 SHORT $LN30@stbtt_Find
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt_FindGlyphIndex@@9@4JA
  00126	83 c1 11	 add	 ecx, 17			; 00000011H
  00129	8b f4		 mov	 esi, esp
  0012b	51		 push	 ecx
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013f	3b f4		 cmp	 esi, esp
  00141	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN30@stbtt_Find:

; 1480 :       return 0;

  00146	33 c0		 xor	 eax, eax
  00148	e9 f4 03 00 00	 jmp	 $LN1@stbtt_Find
  0014d	e9 c3 03 00 00	 jmp	 $LN7@stbtt_Find
$LN12@stbtt_Find:

; 1481 :    } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges

  00152	0f b7 45 e0	 movzx	 eax, WORD PTR _format$[ebp]
  00156	83 f8 04	 cmp	 eax, 4
  00159	0f 85 83 02 00
	00		 jne	 $LN14@stbtt_Find

; 1482 :       stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;

  0015f	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  00162	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  00165	8d 54 01 06	 lea	 edx, DWORD PTR [ecx+eax+6]
  00169	52		 push	 edx
  0016a	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  0016f	83 c4 04	 add	 esp, 4
  00172	0f b7 c0	 movzx	 eax, ax
  00175	d1 f8		 sar	 eax, 1
  00177	66 89 45 b0	 mov	 WORD PTR _segcount$17[ebp], ax

; 1483 :       stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;

  0017b	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  0017e	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  00181	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  0018b	83 c4 04	 add	 esp, 4
  0018e	0f b7 c0	 movzx	 eax, ax
  00191	d1 f8		 sar	 eax, 1
  00193	66 89 45 a4	 mov	 WORD PTR _searchRange$16[ebp], ax

; 1484 :       stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);

  00197	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  0019a	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  0019d	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  001a1	52		 push	 edx
  001a2	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  001a7	83 c4 04	 add	 esp, 4
  001aa	66 89 45 98	 mov	 WORD PTR _entrySelector$15[ebp], ax

; 1485 :       stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

  001ae	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  001b1	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  001b4	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  001b8	52		 push	 edx
  001b9	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  001be	83 c4 04	 add	 esp, 4
  001c1	0f b7 c0	 movzx	 eax, ax
  001c4	d1 f8		 sar	 eax, 1
  001c6	66 89 45 8c	 mov	 WORD PTR _rangeShift$14[ebp], ax

; 1486 : 
; 1487 :       // do a binary search of the segments
; 1488 :       stbtt_uint32 endCount = index_map + 14;

  001ca	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  001cd	83 c0 0e	 add	 eax, 14			; 0000000eH
  001d0	89 45 80	 mov	 DWORD PTR _endCount$13[ebp], eax

; 1489 :       stbtt_uint32 search = endCount;

  001d3	8b 45 80	 mov	 eax, DWORD PTR _endCount$13[ebp]
  001d6	89 85 74 ff ff
	ff		 mov	 DWORD PTR _search$12[ebp], eax

; 1490 : 
; 1491 :       if (unicode_codepoint > 0xffff)

  001dc	81 7d 0c ff ff
	00 00		 cmp	 DWORD PTR _unicode_codepoint$[ebp], 65535 ; 0000ffffH
  001e3	7e 07		 jle	 SHORT $LN16@stbtt_Find

; 1492 :          return 0;

  001e5	33 c0		 xor	 eax, eax
  001e7	e9 55 03 00 00	 jmp	 $LN1@stbtt_Find
$LN16@stbtt_Find:

; 1493 : 
; 1494 :       // they lie from endCount .. endCount + segCount
; 1495 :       // but searchRange is the nearest power of two, so...
; 1496 :       if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))

  001ec	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  001ef	03 85 74 ff ff
	ff		 add	 eax, DWORD PTR _search$12[ebp]
  001f5	0f b7 4d 8c	 movzx	 ecx, WORD PTR _rangeShift$14[ebp]
  001f9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  001fc	52		 push	 edx
  001fd	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00202	83 c4 04	 add	 esp, 4
  00205	0f b7 c0	 movzx	 eax, ax
  00208	39 45 0c	 cmp	 DWORD PTR _unicode_codepoint$[ebp], eax
  0020b	7c 13		 jl	 SHORT $LN17@stbtt_Find

; 1497 :          search += rangeShift*2;

  0020d	0f b7 45 8c	 movzx	 eax, WORD PTR _rangeShift$14[ebp]
  00211	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _search$12[ebp]
  00217	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0021a	89 95 74 ff ff
	ff		 mov	 DWORD PTR _search$12[ebp], edx
$LN17@stbtt_Find:

; 1498 : 
; 1499 :       // now decrement to bias correctly to find smallest
; 1500 :       search -= 2;

  00220	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _search$12[ebp]
  00226	83 e8 02	 sub	 eax, 2
  00229	89 85 74 ff ff
	ff		 mov	 DWORD PTR _search$12[ebp], eax
$LN2@stbtt_Find:

; 1501 :       while (entrySelector) {

  0022f	0f b7 45 98	 movzx	 eax, WORD PTR _entrySelector$15[ebp]
  00233	85 c0		 test	 eax, eax
  00235	74 58		 je	 SHORT $LN3@stbtt_Find

; 1502 :          stbtt_uint16 end;
; 1503 :          searchRange >>= 1;

  00237	66 8b 45 a4	 mov	 ax, WORD PTR _searchRange$16[ebp]
  0023b	66 d1 e8	 shr	 ax, 1
  0023e	66 89 45 a4	 mov	 WORD PTR _searchRange$16[ebp], ax

; 1504 :          end = ttUSHORT(data + search + searchRange*2);

  00242	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  00245	03 85 74 ff ff
	ff		 add	 eax, DWORD PTR _search$12[ebp]
  0024b	0f b7 4d a4	 movzx	 ecx, WORD PTR _searchRange$16[ebp]
  0024f	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00258	83 c4 04	 add	 esp, 4
  0025b	66 89 85 68 ff
	ff ff		 mov	 WORD PTR _end$11[ebp], ax

; 1505 :          if (unicode_codepoint > end)

  00262	0f b7 85 68 ff
	ff ff		 movzx	 eax, WORD PTR _end$11[ebp]
  00269	39 45 0c	 cmp	 DWORD PTR _unicode_codepoint$[ebp], eax
  0026c	7e 13		 jle	 SHORT $LN18@stbtt_Find

; 1506 :             search += searchRange*2;

  0026e	0f b7 45 a4	 movzx	 eax, WORD PTR _searchRange$16[ebp]
  00272	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _search$12[ebp]
  00278	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0027b	89 95 74 ff ff
	ff		 mov	 DWORD PTR _search$12[ebp], edx
$LN18@stbtt_Find:

; 1507 :          --entrySelector;

  00281	66 8b 45 98	 mov	 ax, WORD PTR _entrySelector$15[ebp]
  00285	66 83 e8 01	 sub	 ax, 1
  00289	66 89 45 98	 mov	 WORD PTR _entrySelector$15[ebp], ax

; 1508 :       }

  0028d	eb a0		 jmp	 SHORT $LN2@stbtt_Find
$LN3@stbtt_Find:

; 1509 :       search += 2;

  0028f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _search$12[ebp]
  00295	83 c0 02	 add	 eax, 2
  00298	89 85 74 ff ff
	ff		 mov	 DWORD PTR _search$12[ebp], eax

; 1510 : 
; 1511 :       {
; 1512 :          stbtt_uint16 offset, start;
; 1513 :          stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

  0029e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _search$12[ebp]
  002a4	2b 45 80	 sub	 eax, DWORD PTR _endCount$13[ebp]
  002a7	d1 e8		 shr	 eax, 1
  002a9	66 89 85 44 ff
	ff ff		 mov	 WORD PTR _item$8[ebp], ax

; 1514 : 
; 1515 :          STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));

  002b0	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  002b3	03 45 80	 add	 eax, DWORD PTR _endCount$13[ebp]
  002b6	0f b7 8d 44 ff
	ff ff		 movzx	 ecx, WORD PTR _item$8[ebp]
  002bd	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  002c0	52		 push	 edx
  002c1	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  002c6	83 c4 04	 add	 esp, 4
  002c9	0f b7 c0	 movzx	 eax, ax
  002cc	39 45 0c	 cmp	 DWORD PTR _unicode_codepoint$[ebp], eax
  002cf	7e 26		 jle	 SHORT $LN31@stbtt_Find
  002d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt_FindGlyphIndex@@9@4JA
  002d7	83 c1 35	 add	 ecx, 53			; 00000035H
  002da	8b f4		 mov	 esi, esp
  002dc	51		 push	 ecx
  002dd	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  002e2	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@EBGBJFDE@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  002ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f0	3b f4		 cmp	 esi, esp
  002f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN31@stbtt_Find:

; 1516 :          start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);

  002f7	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  002fa	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  002fd	0f b7 4d b0	 movzx	 ecx, WORD PTR _segcount$17[ebp]
  00301	8d 54 48 0e	 lea	 edx, DWORD PTR [eax+ecx*2+14]
  00305	0f b7 85 44 ff
	ff ff		 movzx	 eax, WORD PTR _item$8[ebp]
  0030c	8d 4c 42 02	 lea	 ecx, DWORD PTR [edx+eax*2+2]
  00310	51		 push	 ecx
  00311	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00316	83 c4 04	 add	 esp, 4
  00319	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _start$9[ebp], ax

; 1517 :          if (unicode_codepoint < start)

  00320	0f b7 85 50 ff
	ff ff		 movzx	 eax, WORD PTR _start$9[ebp]
  00327	39 45 0c	 cmp	 DWORD PTR _unicode_codepoint$[ebp], eax
  0032a	7d 07		 jge	 SHORT $LN19@stbtt_Find

; 1518 :             return 0;

  0032c	33 c0		 xor	 eax, eax
  0032e	e9 0e 02 00 00	 jmp	 $LN1@stbtt_Find
$LN19@stbtt_Find:

; 1519 : 
; 1520 :          offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);

  00333	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  00336	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  00339	0f b7 4d b0	 movzx	 ecx, WORD PTR _segcount$17[ebp]
  0033d	6b d1 06	 imul	 edx, ecx, 6
  00340	8d 44 10 0e	 lea	 eax, DWORD PTR [eax+edx+14]
  00344	0f b7 8d 44 ff
	ff ff		 movzx	 ecx, WORD PTR _item$8[ebp]
  0034b	8d 54 48 02	 lea	 edx, DWORD PTR [eax+ecx*2+2]
  0034f	52		 push	 edx
  00350	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  00355	83 c4 04	 add	 esp, 4
  00358	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _offset$10[ebp], ax

; 1521 :          if (offset == 0)

  0035f	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _offset$10[ebp]
  00366	85 c0		 test	 eax, eax
  00368	75 30		 jne	 SHORT $LN20@stbtt_Find

; 1522 :             return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

  0036a	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  0036d	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  00370	0f b7 4d b0	 movzx	 ecx, WORD PTR _segcount$17[ebp]
  00374	8d 54 88 0e	 lea	 edx, DWORD PTR [eax+ecx*4+14]
  00378	0f b7 85 44 ff
	ff ff		 movzx	 eax, WORD PTR _item$8[ebp]
  0037f	8d 4c 42 02	 lea	 ecx, DWORD PTR [edx+eax*2+2]
  00383	51		 push	 ecx
  00384	e8 00 00 00 00	 call	 ?ttSHORT@@YAFPAE@Z	; ttSHORT
  00389	83 c4 04	 add	 esp, 4
  0038c	0f bf d0	 movsx	 edx, ax
  0038f	03 55 0c	 add	 edx, DWORD PTR _unicode_codepoint$[ebp]
  00392	0f b7 c2	 movzx	 eax, dx
  00395	e9 a7 01 00 00	 jmp	 $LN1@stbtt_Find
$LN20@stbtt_Find:

; 1523 : 
; 1524 :          return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);

  0039a	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _offset$10[ebp]
  003a1	03 45 f8	 add	 eax, DWORD PTR _data$[ebp]
  003a4	0f b7 8d 50 ff
	ff ff		 movzx	 ecx, WORD PTR _start$9[ebp]
  003ab	8b 55 0c	 mov	 edx, DWORD PTR _unicode_codepoint$[ebp]
  003ae	2b d1		 sub	 edx, ecx
  003b0	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  003b3	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  003b6	0f b7 4d b0	 movzx	 ecx, WORD PTR _segcount$17[ebp]
  003ba	6b d1 06	 imul	 edx, ecx, 6
  003bd	8d 44 10 0e	 lea	 eax, DWORD PTR [eax+edx+14]
  003c1	0f b7 8d 44 ff
	ff ff		 movzx	 ecx, WORD PTR _item$8[ebp]
  003c8	8d 54 48 02	 lea	 edx, DWORD PTR [eax+ecx*2+2]
  003cc	52		 push	 edx
  003cd	e8 00 00 00 00	 call	 ?ttUSHORT@@YAGPAE@Z	; ttUSHORT
  003d2	83 c4 04	 add	 esp, 4
  003d5	0f b7 c0	 movzx	 eax, ax
  003d8	e9 64 01 00 00	 jmp	 $LN1@stbtt_Find
  003dd	e9 33 01 00 00	 jmp	 $LN7@stbtt_Find
$LN14@stbtt_Find:

; 1525 :       }
; 1526 :    } else if (format == 12 || format == 13) {

  003e2	0f b7 45 e0	 movzx	 eax, WORD PTR _format$[ebp]
  003e6	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  003e9	74 0d		 je	 SHORT $LN22@stbtt_Find
  003eb	0f b7 45 e0	 movzx	 eax, WORD PTR _format$[ebp]
  003ef	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  003f2	0f 85 1d 01 00
	00		 jne	 $LN7@stbtt_Find
$LN22@stbtt_Find:

; 1527 :       stbtt_uint32 ngroups = ttULONG(data+index_map+12);

  003f8	8b 45 ec	 mov	 eax, DWORD PTR _index_map$[ebp]
  003fb	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  003fe	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  00402	52		 push	 edx
  00403	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  00408	83 c4 04	 add	 esp, 4
  0040b	89 85 38 ff ff
	ff		 mov	 DWORD PTR _ngroups$7[ebp], eax

; 1528 :       stbtt_int32 low,high;
; 1529 :       low = 0; high = (stbtt_int32)ngroups;

  00411	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _low$6[ebp], 0
  0041b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _ngroups$7[ebp]
  00421	89 85 20 ff ff
	ff		 mov	 DWORD PTR _high$5[ebp], eax
$LN4@stbtt_Find:

; 1530 :       // Binary search the right group.
; 1531 :       while (low < high) {

  00427	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _low$6[ebp]
  0042d	3b 85 20 ff ff
	ff		 cmp	 eax, DWORD PTR _high$5[ebp]
  00433	0f 8d d8 00 00
	00		 jge	 $LN5@stbtt_Find

; 1532 :          stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high

  00439	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _high$5[ebp]
  0043f	2b 85 2c ff ff
	ff		 sub	 eax, DWORD PTR _low$6[ebp]
  00445	d1 f8		 sar	 eax, 1
  00447	03 85 2c ff ff
	ff		 add	 eax, DWORD PTR _low$6[ebp]
  0044d	89 85 14 ff ff
	ff		 mov	 DWORD PTR _mid$4[ebp], eax

; 1533 :          stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);

  00453	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  00456	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  00459	6b 8d 14 ff ff
	ff 0c		 imul	 ecx, DWORD PTR _mid$4[ebp], 12
  00460	8d 54 08 10	 lea	 edx, DWORD PTR [eax+ecx+16]
  00464	52		 push	 edx
  00465	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  0046a	83 c4 04	 add	 esp, 4
  0046d	89 85 08 ff ff
	ff		 mov	 DWORD PTR _start_char$3[ebp], eax

; 1534 :          stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);

  00473	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  00476	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  00479	6b 8d 14 ff ff
	ff 0c		 imul	 ecx, DWORD PTR _mid$4[ebp], 12
  00480	8d 54 08 14	 lea	 edx, DWORD PTR [eax+ecx+20]
  00484	52		 push	 edx
  00485	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  0048a	83 c4 04	 add	 esp, 4
  0048d	89 85 fc fe ff
	ff		 mov	 DWORD PTR _end_char$2[ebp], eax

; 1535 :          if ((stbtt_uint32) unicode_codepoint < start_char)

  00493	8b 45 0c	 mov	 eax, DWORD PTR _unicode_codepoint$[ebp]
  00496	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR _start_char$3[ebp]
  0049c	73 0e		 jae	 SHORT $LN23@stbtt_Find

; 1536 :             high = mid;

  0049e	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _mid$4[ebp]
  004a4	89 85 20 ff ff
	ff		 mov	 DWORD PTR _high$5[ebp], eax
  004aa	eb 60		 jmp	 SHORT $LN24@stbtt_Find
$LN23@stbtt_Find:

; 1537 :          else if ((stbtt_uint32) unicode_codepoint > end_char)

  004ac	8b 45 0c	 mov	 eax, DWORD PTR _unicode_codepoint$[ebp]
  004af	3b 85 fc fe ff
	ff		 cmp	 eax, DWORD PTR _end_char$2[ebp]
  004b5	76 11		 jbe	 SHORT $LN25@stbtt_Find

; 1538 :             low = mid+1;

  004b7	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _mid$4[ebp]
  004bd	83 c0 01	 add	 eax, 1
  004c0	89 85 2c ff ff
	ff		 mov	 DWORD PTR _low$6[ebp], eax
  004c6	eb 44		 jmp	 SHORT $LN24@stbtt_Find
$LN25@stbtt_Find:

; 1539 :          else {
; 1540 :             stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);

  004c8	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  004cb	03 45 ec	 add	 eax, DWORD PTR _index_map$[ebp]
  004ce	6b 8d 14 ff ff
	ff 0c		 imul	 ecx, DWORD PTR _mid$4[ebp], 12
  004d5	8d 54 08 18	 lea	 edx, DWORD PTR [eax+ecx+24]
  004d9	52		 push	 edx
  004da	e8 00 00 00 00	 call	 ?ttULONG@@YAIPAE@Z	; ttULONG
  004df	83 c4 04	 add	 esp, 4
  004e2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _start_glyph$1[ebp], eax

; 1541 :             if (format == 12)

  004e8	0f b7 45 e0	 movzx	 eax, WORD PTR _format$[ebp]
  004ec	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  004ef	75 13		 jne	 SHORT $LN27@stbtt_Find

; 1542 :                return start_glyph + unicode_codepoint-start_char;

  004f1	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _start_glyph$1[ebp]
  004f7	03 45 0c	 add	 eax, DWORD PTR _unicode_codepoint$[ebp]
  004fa	2b 85 08 ff ff
	ff		 sub	 eax, DWORD PTR _start_char$3[ebp]
  00500	eb 3f		 jmp	 SHORT $LN1@stbtt_Find
  00502	eb 08		 jmp	 SHORT $LN24@stbtt_Find
$LN27@stbtt_Find:

; 1543 :             else // format == 13
; 1544 :                return start_glyph;

  00504	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _start_glyph$1[ebp]
  0050a	eb 35		 jmp	 SHORT $LN1@stbtt_Find
$LN24@stbtt_Find:

; 1545 :          }
; 1546 :       }

  0050c	e9 16 ff ff ff	 jmp	 $LN4@stbtt_Find
$LN5@stbtt_Find:

; 1547 :       return 0; // not found

  00511	33 c0		 xor	 eax, eax
  00513	eb 2c		 jmp	 SHORT $LN1@stbtt_Find
$LN7@stbtt_Find:

; 1548 :    }
; 1549 :    // @TODO
; 1550 :    STBTT_assert(0);

  00515	33 c0		 xor	 eax, eax
  00517	75 26		 jne	 SHORT $LN32@stbtt_Find
  00519	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbtt_FindGlyphIndex@@9@4JA
  0051f	83 c1 58	 add	 ecx, 88			; 00000058H
  00522	8b f4		 mov	 esi, esp
  00524	51		 push	 ecx
  00525	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@IHJHACNI@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0052a	68 00 00 00 00	 push	 OFFSET ??_C@_13COJANIEC@?$AA0@
  0052f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00535	83 c4 0c	 add	 esp, 12			; 0000000cH
  00538	3b f4		 cmp	 esi, esp
  0053a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN32@stbtt_Find:

; 1551 :    return 0;

  0053f	33 c0		 xor	 eax, eax
$LN1@stbtt_Find:

; 1552 : }

  00541	5f		 pop	 edi
  00542	5e		 pop	 esi
  00543	5b		 pop	 ebx
  00544	81 c4 d4 01 00
	00		 add	 esp, 468		; 000001d4H
  0054a	3b ec		 cmp	 ebp, esp
  0054c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00551	8b e5		 mov	 esp, ebp
  00553	5d		 pop	 ebp
  00554	c3		 ret	 0
_stbtt_FindGlyphIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_InitFont
_TEXT	SEGMENT
_info$ = 8						; size = 4
_data$ = 12						; size = 4
_offset$ = 16						; size = 4
_stbtt_InitFont PROC					; COMDAT

; 4785 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4786 :    return stbtt_InitFont_internal(info, (unsigned char *) data, offset);

  00028	8b 45 10	 mov	 eax, DWORD PTR _offset$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _data$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _info$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?stbtt_InitFont_internal@@YAHPAUstbtt_fontinfo@@PAEH@Z ; stbtt_InitFont_internal
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4787 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_stbtt_InitFont ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetFontOffsetForIndex
_TEXT	SEGMENT
_data$ = 8						; size = 4
_index$ = 12						; size = 4
_stbtt_GetFontOffsetForIndex PROC			; COMDAT

; 4775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4776 :    return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   

  00028	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?stbtt_GetFontOffsetForIndex_internal@@YAHPAEH@Z ; stbtt_GetFontOffsetForIndex_internal
  00035	83 c4 08	 add	 esp, 8

; 4777 : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_stbtt_GetFontOffsetForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_PackFontRangesRenderIntoRects
_TEXT	SEGMENT
tv511 = -496						; size = 8
tv481 = -496						; size = 8
tv507 = -488						; size = 4
tv477 = -488						; size = 4
tv500 = -484						; size = 8
tv470 = -484						; size = 8
tv420 = -484						; size = 8
tv409 = -484						; size = 8
tv496 = -476						; size = 4
tv466 = -476						; size = 4
tv416 = -476						; size = 4
tv405 = -476						; size = 4
tv167 = -476						; size = 4
tv79 = -476						; size = 4
_pad$1 = -276						; size = 2
_glyph$2 = -264						; size = 4
_codepoint$3 = -252					; size = 4
_y1$4 = -240						; size = 4
_x1$5 = -228						; size = 4
_y0$6 = -216						; size = 4
_x0$7 = -204						; size = 4
_lsb$8 = -192						; size = 4
_advance$9 = -180					; size = 4
_bc$10 = -168						; size = 4
_r$11 = -156						; size = 4
_sub_y$12 = -144					; size = 4
_sub_x$13 = -132					; size = 4
_recip_v$14 = -120					; size = 4
_recip_h$15 = -108					; size = 4
_scale$16 = -96						; size = 4
_fh$17 = -84						; size = 4
_old_v_over$ = -72					; size = 4
_old_h_over$ = -60					; size = 4
_return_value$ = -48					; size = 4
_k$ = -36						; size = 4
_j$ = -24						; size = 4
_i$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_spc$ = 8						; size = 4
_info$ = 12						; size = 4
_ranges$ = 16						; size = 4
_num_ranges$ = 20					; size = 4
_rects$ = 24						; size = 4
_stbtt_PackFontRangesRenderIntoRects PROC		; COMDAT

; 4046 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 01 00
	00		 sub	 esp, 496		; 000001f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-496]
  00012	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4047 :    int i,j,k, return_value = 1;

  00032	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _return_value$[ebp], 1

; 4048 : 
; 4049 :    // save current values
; 4050 :    int old_h_over = spc->h_oversample;

  00039	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  0003c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003f	89 4d c4	 mov	 DWORD PTR _old_h_over$[ebp], ecx

; 4051 :    int old_v_over = spc->v_oversample;

  00042	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00045	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00048	89 4d b8	 mov	 DWORD PTR _old_v_over$[ebp], ecx

; 4052 : 
; 4053 :    k = 0;

  0004b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 4054 :    for (i=0; i < num_ranges; ++i) {

  00052	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00059	eb 09		 jmp	 SHORT $LN4@stbtt_Pack
$LN2@stbtt_Pack:
  0005b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbtt_Pack:
  00064	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00067	3b 45 14	 cmp	 eax, DWORD PTR _num_ranges$[ebp]
  0006a	0f 8d 62 06 00
	00		 jge	 $LN3@stbtt_Pack

; 4055 :       float fh = ranges[i].font_size;

  00070	6b 45 f4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  00074	8b 4d 10	 mov	 ecx, DWORD PTR _ranges$[ebp]
  00077	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0007c	f3 0f 11 45 ac	 movss	 DWORD PTR _fh$17[ebp], xmm0

; 4056 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

  00081	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fh$17[ebp]
  00086	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0008d	76 1f		 jbe	 SHORT $LN13@stbtt_Pack
  0008f	51		 push	 ecx
  00090	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fh$17[ebp]
  00095	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _info$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _stbtt_ScaleForPixelHeight
  000a3	83 c4 08	 add	 esp, 8
  000a6	d9 9d 24 fe ff
	ff		 fstp	 DWORD PTR tv79[ebp]
  000ac	eb 24		 jmp	 SHORT $LN14@stbtt_Pack
$LN13@stbtt_Pack:
  000ae	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fh$17[ebp]
  000b3	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000ba	51		 push	 ecx
  000bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _info$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _stbtt_ScaleForMappingEmToPixels
  000c9	83 c4 08	 add	 esp, 8
  000cc	d9 9d 24 fe ff
	ff		 fstp	 DWORD PTR tv79[ebp]
$LN14@stbtt_Pack:
  000d2	f3 0f 10 85 24
	fe ff ff	 movss	 xmm0, DWORD PTR tv79[ebp]
  000da	f3 0f 11 45 a0	 movss	 DWORD PTR _scale$16[ebp], xmm0

; 4057 :       float recip_h,recip_v,sub_x,sub_y;
; 4058 :       spc->h_oversample = ranges[i].h_oversample;

  000df	6b 45 f4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  000e3	8b 4d 10	 mov	 ecx, DWORD PTR _ranges$[ebp]
  000e6	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  000eb	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  000ee	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 4059 :       spc->v_oversample = ranges[i].v_oversample;

  000f1	6b 45 f4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  000f5	8b 4d 10	 mov	 ecx, DWORD PTR _ranges$[ebp]
  000f8	0f b6 54 01 15	 movzx	 edx, BYTE PTR [ecx+eax+21]
  000fd	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00100	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 4060 :       recip_h = 1.0f / spc->h_oversample;

  00103	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00106	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00109	89 8d 24 fe ff
	ff		 mov	 DWORD PTR tv405[ebp], ecx
  0010f	f2 0f 2a 85 24
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv405[ebp]
  00117	8b 95 24 fe ff
	ff		 mov	 edx, DWORD PTR tv405[ebp]
  0011d	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  00120	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  00129	f2 0f 11 85 1c
	fe ff ff	 movsd	 QWORD PTR tv409[ebp], xmm0
  00131	f2 0f 5a 85 1c
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv409[ebp]
  00139	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00141	f3 0f 5e c8	 divss	 xmm1, xmm0
  00145	f3 0f 11 4d 94	 movss	 DWORD PTR _recip_h$15[ebp], xmm1

; 4061 :       recip_v = 1.0f / spc->v_oversample;

  0014a	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  0014d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00150	89 8d 24 fe ff
	ff		 mov	 DWORD PTR tv416[ebp], ecx
  00156	f2 0f 2a 85 24
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv416[ebp]
  0015e	8b 95 24 fe ff
	ff		 mov	 edx, DWORD PTR tv416[ebp]
  00164	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  00167	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  00170	f2 0f 11 85 1c
	fe ff ff	 movsd	 QWORD PTR tv420[ebp], xmm0
  00178	f2 0f 5a 85 1c
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv420[ebp]
  00180	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00188	f3 0f 5e c8	 divss	 xmm1, xmm0
  0018c	f3 0f 11 4d 88	 movss	 DWORD PTR _recip_v$14[ebp], xmm1

; 4062 :       sub_x = stbtt__oversample_shift(spc->h_oversample);

  00191	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00194	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00197	51		 push	 ecx
  00198	e8 00 00 00 00	 call	 ?stbtt__oversample_shift@@YAMH@Z ; stbtt__oversample_shift
  0019d	83 c4 04	 add	 esp, 4
  001a0	d9 9d 7c ff ff
	ff		 fstp	 DWORD PTR _sub_x$13[ebp]

; 4063 :       sub_y = stbtt__oversample_shift(spc->v_oversample);

  001a6	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  001a9	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001ac	51		 push	 ecx
  001ad	e8 00 00 00 00	 call	 ?stbtt__oversample_shift@@YAMH@Z ; stbtt__oversample_shift
  001b2	83 c4 04	 add	 esp, 4
  001b5	d9 9d 70 ff ff
	ff		 fstp	 DWORD PTR _sub_y$12[ebp]

; 4064 :       for (j=0; j < ranges[i].num_chars; ++j) {

  001bb	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  001c2	eb 09		 jmp	 SHORT $LN7@stbtt_Pack
$LN5@stbtt_Pack:
  001c4	8b 45 e8	 mov	 eax, DWORD PTR _j$[ebp]
  001c7	83 c0 01	 add	 eax, 1
  001ca	89 45 e8	 mov	 DWORD PTR _j$[ebp], eax
$LN7@stbtt_Pack:
  001cd	6b 45 f4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  001d1	8b 4d 10	 mov	 ecx, DWORD PTR _ranges$[ebp]
  001d4	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  001d7	3b 54 01 0c	 cmp	 edx, DWORD PTR [ecx+eax+12]
  001db	0f 8d ec 04 00
	00		 jge	 $LN6@stbtt_Pack

; 4065 :          stbrp_rect *r = &rects[k];

  001e1	8b 45 dc	 mov	 eax, DWORD PTR _k$[ebp]
  001e4	c1 e0 04	 shl	 eax, 4
  001e7	03 45 18	 add	 eax, DWORD PTR _rects$[ebp]
  001ea	89 85 64 ff ff
	ff		 mov	 DWORD PTR _r$11[ebp], eax

; 4066 :          if (r->was_packed && r->w != 0 && r->h != 0) {

  001f0	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  001f6	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  001fa	0f 84 b8 04 00
	00		 je	 $LN8@stbtt_Pack
  00200	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00206	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0020a	85 c9		 test	 ecx, ecx
  0020c	0f 84 a6 04 00
	00		 je	 $LN8@stbtt_Pack
  00212	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00218	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  0021c	85 c9		 test	 ecx, ecx
  0021e	0f 84 94 04 00
	00		 je	 $LN8@stbtt_Pack

; 4067 :             stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];

  00224	6b 45 f4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  00228	6b 4d e8 1c	 imul	 ecx, DWORD PTR _j$[ebp], 28
  0022c	8b 55 10	 mov	 edx, DWORD PTR _ranges$[ebp]
  0022f	03 4c 02 10	 add	 ecx, DWORD PTR [edx+eax+16]
  00233	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _bc$10[ebp], ecx

; 4068 :             int advance, lsb, x0,y0,x1,y1;
; 4069 :             int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

  00239	6b 45 f4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  0023d	8b 4d 10	 mov	 ecx, DWORD PTR _ranges$[ebp]
  00240	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  00245	75 16		 jne	 SHORT $LN15@stbtt_Pack
  00247	6b 55 f4 18	 imul	 edx, DWORD PTR _i$[ebp], 24
  0024b	8b 45 10	 mov	 eax, DWORD PTR _ranges$[ebp]
  0024e	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  00252	03 4d e8	 add	 ecx, DWORD PTR _j$[ebp]
  00255	89 8d 24 fe ff
	ff		 mov	 DWORD PTR tv167[ebp], ecx
  0025b	eb 17		 jmp	 SHORT $LN16@stbtt_Pack
$LN15@stbtt_Pack:
  0025d	6b 55 f4 18	 imul	 edx, DWORD PTR _i$[ebp], 24
  00261	8b 45 10	 mov	 eax, DWORD PTR _ranges$[ebp]
  00264	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  00268	8b 55 e8	 mov	 edx, DWORD PTR _j$[ebp]
  0026b	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0026e	89 85 24 fe ff
	ff		 mov	 DWORD PTR tv167[ebp], eax
$LN16@stbtt_Pack:
  00274	8b 8d 24 fe ff
	ff		 mov	 ecx, DWORD PTR tv167[ebp]
  0027a	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _codepoint$3[ebp], ecx

; 4070 :             int glyph = stbtt_FindGlyphIndex(info, codepoint);

  00280	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _codepoint$3[ebp]
  00286	50		 push	 eax
  00287	8b 4d 0c	 mov	 ecx, DWORD PTR _info$[ebp]
  0028a	51		 push	 ecx
  0028b	e8 00 00 00 00	 call	 _stbtt_FindGlyphIndex
  00290	83 c4 08	 add	 esp, 8
  00293	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _glyph$2[ebp], eax

; 4071 :             stbrp_coord pad = (stbrp_coord) spc->padding;

  00299	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  0029c	66 8b 48 14	 mov	 cx, WORD PTR [eax+20]
  002a0	66 89 8d ec fe
	ff ff		 mov	 WORD PTR _pad$1[ebp], cx

; 4072 : 
; 4073 :             // pad on left and top
; 4074 :             r->x += pad;

  002a7	0f b7 85 ec fe
	ff ff		 movzx	 eax, WORD PTR _pad$1[ebp]
  002ae	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  002b4	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  002b8	03 d0		 add	 edx, eax
  002ba	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  002c0	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 4075 :             r->y += pad;

  002c4	0f b7 85 ec fe
	ff ff		 movzx	 eax, WORD PTR _pad$1[ebp]
  002cb	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  002d1	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  002d5	03 d0		 add	 edx, eax
  002d7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  002dd	66 89 50 0a	 mov	 WORD PTR [eax+10], dx

; 4076 :             r->w -= pad;

  002e1	0f b7 85 ec fe
	ff ff		 movzx	 eax, WORD PTR _pad$1[ebp]
  002e8	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  002ee	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  002f2	2b d0		 sub	 edx, eax
  002f4	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  002fa	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 4077 :             r->h -= pad;

  002fe	0f b7 85 ec fe
	ff ff		 movzx	 eax, WORD PTR _pad$1[ebp]
  00305	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  0030b	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  0030f	2b d0		 sub	 edx, eax
  00311	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00317	66 89 50 06	 mov	 WORD PTR [eax+6], dx

; 4078 :             stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);

  0031b	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _lsb$8[ebp]
  00321	50		 push	 eax
  00322	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _advance$9[ebp]
  00328	51		 push	 ecx
  00329	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _glyph$2[ebp]
  0032f	52		 push	 edx
  00330	8b 45 0c	 mov	 eax, DWORD PTR _info$[ebp]
  00333	50		 push	 eax
  00334	e8 00 00 00 00	 call	 _stbtt_GetGlyphHMetrics
  00339	83 c4 10	 add	 esp, 16			; 00000010H

; 4079 :             stbtt_GetGlyphBitmapBox(info, glyph,

  0033c	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _y1$4[ebp]
  00342	50		 push	 eax
  00343	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _x1$5[ebp]
  00349	51		 push	 ecx
  0034a	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR _y0$6[ebp]
  00350	52		 push	 edx
  00351	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _x0$7[ebp]
  00357	50		 push	 eax
  00358	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  0035b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0035e	89 95 24 fe ff
	ff		 mov	 DWORD PTR tv466[ebp], edx
  00364	f2 0f 2a 85 24
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv466[ebp]
  0036c	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR tv466[ebp]
  00372	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00375	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0037e	f2 0f 11 85 1c
	fe ff ff	 movsd	 QWORD PTR tv470[ebp], xmm0
  00386	f2 0f 5a 85 1c
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv470[ebp]
  0038e	f3 0f 59 45 a0	 mulss	 xmm0, DWORD PTR _scale$16[ebp]
  00393	51		 push	 ecx
  00394	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00399	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  0039c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0039f	89 95 18 fe ff
	ff		 mov	 DWORD PTR tv477[ebp], edx
  003a5	f2 0f 2a 85 18
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv477[ebp]
  003ad	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR tv477[ebp]
  003b3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003b6	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  003bf	f2 0f 11 85 10
	fe ff ff	 movsd	 QWORD PTR tv481[ebp], xmm0
  003c7	f2 0f 5a 85 10
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv481[ebp]
  003cf	f3 0f 59 45 a0	 mulss	 xmm0, DWORD PTR _scale$16[ebp]
  003d4	51		 push	 ecx
  003d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003da	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _glyph$2[ebp]
  003e0	51		 push	 ecx
  003e1	8b 55 0c	 mov	 edx, DWORD PTR _info$[ebp]
  003e4	52		 push	 edx
  003e5	e8 00 00 00 00	 call	 _stbtt_GetGlyphBitmapBox
  003ea	83 c4 20	 add	 esp, 32			; 00000020H

; 4080 :                                     scale * spc->h_oversample,
; 4081 :                                     scale * spc->v_oversample,
; 4082 :                                     &x0,&y0,&x1,&y1);
; 4083 :             stbtt_MakeGlyphBitmapSubpixel(info,

  003ed	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _glyph$2[ebp]
  003f3	50		 push	 eax
  003f4	51		 push	 ecx
  003f5	0f 57 c0	 xorps	 xmm0, xmm0
  003f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fd	51		 push	 ecx
  003fe	0f 57 c0	 xorps	 xmm0, xmm0
  00401	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00406	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  00409	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0040c	89 95 24 fe ff
	ff		 mov	 DWORD PTR tv496[ebp], edx
  00412	f2 0f 2a 85 24
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv496[ebp]
  0041a	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR tv496[ebp]
  00420	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00423	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0042c	f2 0f 11 85 1c
	fe ff ff	 movsd	 QWORD PTR tv500[ebp], xmm0
  00434	f2 0f 5a 85 1c
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv500[ebp]
  0043c	f3 0f 59 45 a0	 mulss	 xmm0, DWORD PTR _scale$16[ebp]
  00441	51		 push	 ecx
  00442	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00447	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  0044a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0044d	89 95 18 fe ff
	ff		 mov	 DWORD PTR tv507[ebp], edx
  00453	f2 0f 2a 85 18
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv507[ebp]
  0045b	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR tv507[ebp]
  00461	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00464	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0046d	f2 0f 11 85 10
	fe ff ff	 movsd	 QWORD PTR tv511[ebp], xmm0
  00475	f2 0f 5a 85 10
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv511[ebp]
  0047d	f3 0f 59 45 a0	 mulss	 xmm0, DWORD PTR _scale$16[ebp]
  00482	51		 push	 ecx
  00483	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00488	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  0048b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0048e	52		 push	 edx
  0048f	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00495	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00499	8b 55 08	 mov	 edx, DWORD PTR _spc$[ebp]
  0049c	2b 4a 20	 sub	 ecx, DWORD PTR [edx+32]
  0049f	83 c1 01	 add	 ecx, 1
  004a2	51		 push	 ecx
  004a3	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  004a9	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  004ad	8b 55 08	 mov	 edx, DWORD PTR _spc$[ebp]
  004b0	2b 4a 1c	 sub	 ecx, DWORD PTR [edx+28]
  004b3	83 c1 01	 add	 ecx, 1
  004b6	51		 push	 ecx
  004b7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  004bd	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  004c1	8b 55 08	 mov	 edx, DWORD PTR _spc$[ebp]
  004c4	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  004c7	03 c1		 add	 eax, ecx
  004c9	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  004cf	0f b7 51 0a	 movzx	 edx, WORD PTR [ecx+10]
  004d3	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  004d6	0f af 51 10	 imul	 edx, DWORD PTR [ecx+16]
  004da	03 c2		 add	 eax, edx
  004dc	50		 push	 eax
  004dd	8b 55 0c	 mov	 edx, DWORD PTR _info$[ebp]
  004e0	52		 push	 edx
  004e1	e8 00 00 00 00	 call	 _stbtt_MakeGlyphBitmapSubpixel
  004e6	83 c4 28	 add	 esp, 40			; 00000028H

; 4084 :                                           spc->pixels + r->x + r->y*spc->stride_in_bytes,
; 4085 :                                           r->w - spc->h_oversample+1,
; 4086 :                                           r->h - spc->v_oversample+1,
; 4087 :                                           spc->stride_in_bytes,
; 4088 :                                           scale * spc->h_oversample,
; 4089 :                                           scale * spc->v_oversample,
; 4090 :                                           0,0,
; 4091 :                                           glyph);
; 4092 : 
; 4093 :             if (spc->h_oversample > 1)

  004e9	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  004ec	83 78 1c 01	 cmp	 DWORD PTR [eax+28], 1
  004f0	76 52		 jbe	 SHORT $LN10@stbtt_Pack

; 4094 :                stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

  004f2	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  004f5	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  004f8	51		 push	 ecx
  004f9	8b 55 08	 mov	 edx, DWORD PTR _spc$[ebp]
  004fc	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  004ff	50		 push	 eax
  00500	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  00506	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  0050a	52		 push	 edx
  0050b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00511	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00515	51		 push	 ecx
  00516	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _r$11[ebp]
  0051c	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  00520	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  00523	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00526	03 d0		 add	 edx, eax
  00528	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  0052e	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  00532	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00535	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00539	03 d1		 add	 edx, ecx
  0053b	52		 push	 edx
  0053c	e8 00 00 00 00	 call	 ?stbtt__h_prefilter@@YAXPAEHHHI@Z ; stbtt__h_prefilter
  00541	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@stbtt_Pack:

; 4095 :                                   r->w, r->h, spc->stride_in_bytes,
; 4096 :                                   spc->h_oversample);
; 4097 : 
; 4098 :             if (spc->v_oversample > 1)

  00544	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00547	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  0054b	76 52		 jbe	 SHORT $LN11@stbtt_Pack

; 4099 :                stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

  0054d	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00550	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00553	51		 push	 ecx
  00554	8b 55 08	 mov	 edx, DWORD PTR _spc$[ebp]
  00557	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0055a	50		 push	 eax
  0055b	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  00561	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  00565	52		 push	 edx
  00566	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  0056c	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00570	51		 push	 ecx
  00571	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _r$11[ebp]
  00577	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  0057b	8b 4d 08	 mov	 ecx, DWORD PTR _spc$[ebp]
  0057e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00581	03 d0		 add	 edx, eax
  00583	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00589	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  0058d	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00590	0f af 48 10	 imul	 ecx, DWORD PTR [eax+16]
  00594	03 d1		 add	 edx, ecx
  00596	52		 push	 edx
  00597	e8 00 00 00 00	 call	 ?stbtt__v_prefilter@@YAXPAEHHHI@Z ; stbtt__v_prefilter
  0059c	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@stbtt_Pack:

; 4100 :                                   r->w, r->h, spc->stride_in_bytes,
; 4101 :                                   spc->v_oversample);
; 4102 : 
; 4103 :             bc->x0       = (stbtt_int16)  r->x;

  0059f	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _bc$10[ebp]
  005a5	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  005ab	66 8b 51 08	 mov	 dx, WORD PTR [ecx+8]
  005af	66 89 10	 mov	 WORD PTR [eax], dx

; 4104 :             bc->y0       = (stbtt_int16)  r->y;

  005b2	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _bc$10[ebp]
  005b8	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _r$11[ebp]
  005be	66 8b 51 0a	 mov	 dx, WORD PTR [ecx+10]
  005c2	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 4105 :             bc->x1       = (stbtt_int16) (r->x + r->w);

  005c6	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  005cc	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  005d0	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _r$11[ebp]
  005d6	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  005da	03 c8		 add	 ecx, eax
  005dc	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _bc$10[ebp]
  005e2	66 89 4a 04	 mov	 WORD PTR [edx+4], cx

; 4106 :             bc->y1       = (stbtt_int16) (r->y + r->h);

  005e6	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  005ec	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  005f0	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _r$11[ebp]
  005f6	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  005fa	03 c8		 add	 ecx, eax
  005fc	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _bc$10[ebp]
  00602	66 89 4a 06	 mov	 WORD PTR [edx+6], cx

; 4107 :             bc->xadvance =                scale * advance;

  00606	f3 0f 2a 85 4c
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _advance$9[ebp]
  0060e	f3 0f 59 45 a0	 mulss	 xmm0, DWORD PTR _scale$16[ebp]
  00613	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _bc$10[ebp]
  00619	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 4108 :             bc->xoff     =       (float)  x0 * recip_h + sub_x;

  0061e	f3 0f 2a 85 34
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _x0$7[ebp]
  00626	f3 0f 59 45 94	 mulss	 xmm0, DWORD PTR _recip_h$15[ebp]
  0062b	f3 0f 58 85 7c
	ff ff ff	 addss	 xmm0, DWORD PTR _sub_x$13[ebp]
  00633	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _bc$10[ebp]
  00639	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 4109 :             bc->yoff     =       (float)  y0 * recip_v + sub_y;

  0063e	f3 0f 2a 85 28
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _y0$6[ebp]
  00646	f3 0f 59 45 88	 mulss	 xmm0, DWORD PTR _recip_v$14[ebp]
  0064b	f3 0f 58 85 70
	ff ff ff	 addss	 xmm0, DWORD PTR _sub_y$12[ebp]
  00653	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _bc$10[ebp]
  00659	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 4110 :             bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;

  0065e	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00664	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00668	03 8d 34 ff ff
	ff		 add	 ecx, DWORD PTR _x0$7[ebp]
  0066e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00672	f3 0f 59 45 94	 mulss	 xmm0, DWORD PTR _recip_h$15[ebp]
  00677	f3 0f 58 85 7c
	ff ff ff	 addss	 xmm0, DWORD PTR _sub_x$13[ebp]
  0067f	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _bc$10[ebp]
  00685	f3 0f 11 42 14	 movss	 DWORD PTR [edx+20], xmm0

; 4111 :             bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;

  0068a	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _r$11[ebp]
  00690	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00694	03 8d 28 ff ff
	ff		 add	 ecx, DWORD PTR _y0$6[ebp]
  0069a	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0069e	f3 0f 59 45 88	 mulss	 xmm0, DWORD PTR _recip_v$14[ebp]
  006a3	f3 0f 58 85 70
	ff ff ff	 addss	 xmm0, DWORD PTR _sub_y$12[ebp]
  006ab	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _bc$10[ebp]
  006b1	f3 0f 11 42 18	 movss	 DWORD PTR [edx+24], xmm0

; 4112 :          } else {

  006b6	eb 07		 jmp	 SHORT $LN9@stbtt_Pack
$LN8@stbtt_Pack:

; 4113 :             return_value = 0; // if any fail, report failure

  006b8	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _return_value$[ebp], 0
$LN9@stbtt_Pack:

; 4114 :          }
; 4115 : 
; 4116 :          ++k;

  006bf	8b 45 dc	 mov	 eax, DWORD PTR _k$[ebp]
  006c2	83 c0 01	 add	 eax, 1
  006c5	89 45 dc	 mov	 DWORD PTR _k$[ebp], eax

; 4117 :       }

  006c8	e9 f7 fa ff ff	 jmp	 $LN5@stbtt_Pack
$LN6@stbtt_Pack:

; 4118 :    }

  006cd	e9 89 f9 ff ff	 jmp	 $LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 4119 : 
; 4120 :    // restore original values
; 4121 :    spc->h_oversample = old_h_over;

  006d2	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  006d5	8b 4d c4	 mov	 ecx, DWORD PTR _old_h_over$[ebp]
  006d8	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 4122 :    spc->v_oversample = old_v_over;

  006db	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  006de	8b 4d b8	 mov	 ecx, DWORD PTR _old_v_over$[ebp]
  006e1	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 4123 : 
; 4124 :    return return_value;

  006e4	8b 45 d0	 mov	 eax, DWORD PTR _return_value$[ebp]

; 4125 : }

  006e7	52		 push	 edx
  006e8	8b cd		 mov	 ecx, ebp
  006ea	50		 push	 eax
  006eb	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@stbtt_Pack
  006f1	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006f6	58		 pop	 eax
  006f7	5a		 pop	 edx
  006f8	5f		 pop	 edi
  006f9	5e		 pop	 esi
  006fa	5b		 pop	 ebx
  006fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006fe	33 cd		 xor	 ecx, ebp
  00700	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00705	81 c4 f0 01 00
	00		 add	 esp, 496		; 000001f0H
  0070b	3b ec		 cmp	 ebp, esp
  0070d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00712	8b e5		 mov	 esp, ebp
  00714	5d		 pop	 ebp
  00715	c3		 ret	 0
  00716	66 90		 npad	 2
$LN24@stbtt_Pack:
  00718	06 00 00 00	 DD	 6
  0071c	00 00 00 00	 DD	 $LN23@stbtt_Pack
$LN23@stbtt_Pack:
  00720	4c ff ff ff	 DD	 -180			; ffffff4cH
  00724	04 00 00 00	 DD	 4
  00728	00 00 00 00	 DD	 $LN17@stbtt_Pack
  0072c	40 ff ff ff	 DD	 -192			; ffffff40H
  00730	04 00 00 00	 DD	 4
  00734	00 00 00 00	 DD	 $LN18@stbtt_Pack
  00738	34 ff ff ff	 DD	 -204			; ffffff34H
  0073c	04 00 00 00	 DD	 4
  00740	00 00 00 00	 DD	 $LN19@stbtt_Pack
  00744	28 ff ff ff	 DD	 -216			; ffffff28H
  00748	04 00 00 00	 DD	 4
  0074c	00 00 00 00	 DD	 $LN20@stbtt_Pack
  00750	1c ff ff ff	 DD	 -228			; ffffff1cH
  00754	04 00 00 00	 DD	 4
  00758	00 00 00 00	 DD	 $LN21@stbtt_Pack
  0075c	10 ff ff ff	 DD	 -240			; ffffff10H
  00760	04 00 00 00	 DD	 4
  00764	00 00 00 00	 DD	 $LN22@stbtt_Pack
$LN22@stbtt_Pack:
  00768	79		 DB	 121			; 00000079H
  00769	31		 DB	 49			; 00000031H
  0076a	00		 DB	 0
$LN21@stbtt_Pack:
  0076b	78		 DB	 120			; 00000078H
  0076c	31		 DB	 49			; 00000031H
  0076d	00		 DB	 0
$LN20@stbtt_Pack:
  0076e	79		 DB	 121			; 00000079H
  0076f	30		 DB	 48			; 00000030H
  00770	00		 DB	 0
$LN19@stbtt_Pack:
  00771	78		 DB	 120			; 00000078H
  00772	30		 DB	 48			; 00000030H
  00773	00		 DB	 0
$LN18@stbtt_Pack:
  00774	6c		 DB	 108			; 0000006cH
  00775	73		 DB	 115			; 00000073H
  00776	62		 DB	 98			; 00000062H
  00777	00		 DB	 0
$LN17@stbtt_Pack:
  00778	61		 DB	 97			; 00000061H
  00779	64		 DB	 100			; 00000064H
  0077a	76		 DB	 118			; 00000076H
  0077b	61		 DB	 97			; 00000061H
  0077c	6e		 DB	 110			; 0000006eH
  0077d	63		 DB	 99			; 00000063H
  0077e	65		 DB	 101			; 00000065H
  0077f	00		 DB	 0
_stbtt_PackFontRangesRenderIntoRects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_GetPackedQuad
_TEXT	SEGMENT
tv182 = -256						; size = 4
tv174 = -256						; size = 4
_y$1 = -56						; size = 4
_x$2 = -44						; size = 4
_b$ = -32						; size = 4
_iph$ = -20						; size = 4
_ipw$ = -8						; size = 4
_chardata$ = 8						; size = 4
_pw$ = 12						; size = 4
_ph$ = 16						; size = 4
_char_index$ = 20					; size = 4
_xpos$ = 24						; size = 4
_ypos$ = 28						; size = 4
_q$ = 32						; size = 4
_align_to_integer$ = 36					; size = 4
_stbtt_GetPackedQuad PROC				; COMDAT

; 4194 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4195 :    float ipw = 1.0f / pw, iph = 1.0f / ph;

  00028	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _pw$[ebp]
  0002d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00035	f3 0f 5e c8	 divss	 xmm1, xmm0
  00039	f3 0f 11 4d f8	 movss	 DWORD PTR _ipw$[ebp], xmm1
  0003e	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _ph$[ebp]
  00043	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0004b	f3 0f 5e c8	 divss	 xmm1, xmm0
  0004f	f3 0f 11 4d ec	 movss	 DWORD PTR _iph$[ebp], xmm1

; 4196 :    const stbtt_packedchar *b = chardata + char_index;

  00054	6b 45 14 1c	 imul	 eax, DWORD PTR _char_index$[ebp], 28
  00058	03 45 08	 add	 eax, DWORD PTR _chardata$[ebp]
  0005b	89 45 e0	 mov	 DWORD PTR _b$[ebp], eax

; 4197 : 
; 4198 :    if (align_to_integer) {

  0005e	83 7d 24 00	 cmp	 DWORD PTR _align_to_integer$[ebp], 0
  00062	0f 84 d5 00 00
	00		 je	 $LN2@stbtt_GetP

; 4199 :       float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);

  00068	8b 45 18	 mov	 eax, DWORD PTR _xpos$[ebp]
  0006b	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  0006e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00072	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  00077	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0007f	51		 push	 ecx
  00080	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00085	e8 00 00 00 00	 call	 ?ImFloorStd@@YAMM@Z	; ImFloorStd
  0008a	83 c4 04	 add	 esp, 4
  0008d	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv174[ebp]
  00093	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR tv174[ebp]
  0009b	f3 0f 2c d0	 cvttss2si edx, xmm0
  0009f	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000a3	f3 0f 11 45 d4	 movss	 DWORD PTR _x$2[ebp], xmm0

; 4200 :       float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);

  000a8	8b 45 1c	 mov	 eax, DWORD PTR _ypos$[ebp]
  000ab	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  000ae	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000b2	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  000b7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000bf	51		 push	 ecx
  000c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c5	e8 00 00 00 00	 call	 ?ImFloorStd@@YAMM@Z	; ImFloorStd
  000ca	83 c4 04	 add	 esp, 4
  000cd	d9 9d 00 ff ff
	ff		 fstp	 DWORD PTR tv182[ebp]
  000d3	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR tv182[ebp]
  000db	f3 0f 2c d0	 cvttss2si edx, xmm0
  000df	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000e3	f3 0f 11 45 c8	 movss	 DWORD PTR _y$1[ebp], xmm0

; 4201 :       q->x0 = x;

  000e8	8b 45 20	 mov	 eax, DWORD PTR _q$[ebp]
  000eb	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _x$2[ebp]
  000f0	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 4202 :       q->y0 = y;

  000f4	8b 45 20	 mov	 eax, DWORD PTR _q$[ebp]
  000f7	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y$1[ebp]
  000fc	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 4203 :       q->x1 = x + b->xoff2 - b->xoff;

  00101	8b 45 e0	 mov	 eax, DWORD PTR _b$[ebp]
  00104	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _x$2[ebp]
  00109	f3 0f 58 40 14	 addss	 xmm0, DWORD PTR [eax+20]
  0010e	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  00111	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00116	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  00119	f3 0f 11 42 10	 movss	 DWORD PTR [edx+16], xmm0

; 4204 :       q->y1 = y + b->yoff2 - b->yoff;

  0011e	8b 45 e0	 mov	 eax, DWORD PTR _b$[ebp]
  00121	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _y$1[ebp]
  00126	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [eax+24]
  0012b	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  0012e	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]
  00133	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  00136	f3 0f 11 42 14	 movss	 DWORD PTR [edx+20], xmm0

; 4205 :    } else {

  0013b	eb 5b		 jmp	 SHORT $LN3@stbtt_GetP
$LN2@stbtt_GetP:

; 4206 :       q->x0 = *xpos + b->xoff;

  0013d	8b 45 18	 mov	 eax, DWORD PTR _xpos$[ebp]
  00140	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  00143	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00147	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  0014c	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  0014f	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 4207 :       q->y0 = *ypos + b->yoff;

  00153	8b 45 1c	 mov	 eax, DWORD PTR _ypos$[ebp]
  00156	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  00159	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0015d	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  00162	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  00165	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 4208 :       q->x1 = *xpos + b->xoff2;

  0016a	8b 45 18	 mov	 eax, DWORD PTR _xpos$[ebp]
  0016d	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  00170	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00174	f3 0f 58 41 14	 addss	 xmm0, DWORD PTR [ecx+20]
  00179	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  0017c	f3 0f 11 42 10	 movss	 DWORD PTR [edx+16], xmm0

; 4209 :       q->y1 = *ypos + b->yoff2;

  00181	8b 45 1c	 mov	 eax, DWORD PTR _ypos$[ebp]
  00184	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  00187	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0018b	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00190	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  00193	f3 0f 11 42 14	 movss	 DWORD PTR [edx+20], xmm0
$LN3@stbtt_GetP:

; 4210 :    }
; 4211 : 
; 4212 :    q->s0 = b->x0 * ipw;

  00198	8b 45 e0	 mov	 eax, DWORD PTR _b$[ebp]
  0019b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0019e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001a2	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _ipw$[ebp]
  001a7	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  001aa	f3 0f 11 42 08	 movss	 DWORD PTR [edx+8], xmm0

; 4213 :    q->t0 = b->y0 * iph;

  001af	8b 45 e0	 mov	 eax, DWORD PTR _b$[ebp]
  001b2	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  001b6	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001ba	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _iph$[ebp]
  001bf	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  001c2	f3 0f 11 42 0c	 movss	 DWORD PTR [edx+12], xmm0

; 4214 :    q->s1 = b->x1 * ipw;

  001c7	8b 45 e0	 mov	 eax, DWORD PTR _b$[ebp]
  001ca	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  001ce	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001d2	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _ipw$[ebp]
  001d7	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  001da	f3 0f 11 42 18	 movss	 DWORD PTR [edx+24], xmm0

; 4215 :    q->t1 = b->y1 * iph;

  001df	8b 45 e0	 mov	 eax, DWORD PTR _b$[ebp]
  001e2	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  001e6	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001ea	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _iph$[ebp]
  001ef	8b 55 20	 mov	 edx, DWORD PTR _q$[ebp]
  001f2	f3 0f 11 42 1c	 movss	 DWORD PTR [edx+28], xmm0

; 4216 : 
; 4217 :    *xpos += b->xadvance;

  001f7	8b 45 18	 mov	 eax, DWORD PTR _xpos$[ebp]
  001fa	8b 4d e0	 mov	 ecx, DWORD PTR _b$[ebp]
  001fd	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00201	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  00206	8b 55 18	 mov	 edx, DWORD PTR _xpos$[ebp]
  00209	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 4218 : }

  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi
  0020f	5b		 pop	 ebx
  00210	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  00216	3b ec		 cmp	 ebp, esp
  00218	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021d	8b e5		 mov	 esp, ebp
  0021f	5d		 pop	 ebp
  00220	c3		 ret	 0
_stbtt_GetPackedQuad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_PackEnd
_TEXT	SEGMENT
_spc$ = 8						; size = 4
_stbtt_PackEnd PROC					; COMDAT

; 3830 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3831 :    STBTT_free(spc->nodes    , spc->user_allocator_context);

  00028	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  0002b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00034	83 c4 04	 add	 esp, 4

; 3832 :    STBTT_free(spc->pack_info, spc->user_allocator_context);

  00037	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00043	83 c4 04	 add	 esp, 4

; 3833 : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_stbtt_PackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_truetype.h
;	COMDAT _stbtt_PackBegin
_TEXT	SEGMENT
tv85 = -232						; size = 4
_nodes$ = -32						; size = 4
_num_nodes$ = -20					; size = 4
_context$ = -8						; size = 4
_spc$ = 8						; size = 4
_pixels$ = 12						; size = 4
_pw$ = 16						; size = 4
_ph$ = 20						; size = 4
_stride_in_bytes$ = 24					; size = 4
_padding$ = 28						; size = 4
_alloc_context$ = 32					; size = 4
_stbtt_PackBegin PROC					; COMDAT

; 3798 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __15A8FCCD_imstb_truetype@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3799 :    stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);

  00028	6a 30		 push	 48			; 00000030H
  0002a	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f8	 mov	 DWORD PTR _context$[ebp], eax

; 3800 :    int            num_nodes = pw - padding;

  00035	8b 45 10	 mov	 eax, DWORD PTR _pw$[ebp]
  00038	2b 45 1c	 sub	 eax, DWORD PTR _padding$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR _num_nodes$[ebp], eax

; 3801 :    stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

  0003e	8b 45 ec	 mov	 eax, DWORD PTR _num_nodes$[ebp]
  00041	c1 e0 03	 shl	 eax, 3
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 e0	 mov	 DWORD PTR _nodes$[ebp], eax

; 3802 : 
; 3803 :    if (context == NULL || nodes == NULL) {

  00050	83 7d f8 00	 cmp	 DWORD PTR _context$[ebp], 0
  00054	74 06		 je	 SHORT $LN3@stbtt_Pack
  00056	83 7d e0 00	 cmp	 DWORD PTR _nodes$[ebp], 0
  0005a	75 2b		 jne	 SHORT $LN2@stbtt_Pack
$LN3@stbtt_Pack:

; 3804 :       if (context != NULL) STBTT_free(context, alloc_context);

  0005c	83 7d f8 00	 cmp	 DWORD PTR _context$[ebp], 0
  00060	74 0c		 je	 SHORT $LN4@stbtt_Pack
  00062	8b 45 f8	 mov	 eax, DWORD PTR _context$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0006b	83 c4 04	 add	 esp, 4
$LN4@stbtt_Pack:

; 3805 :       if (nodes   != NULL) STBTT_free(nodes  , alloc_context);

  0006e	83 7d e0 00	 cmp	 DWORD PTR _nodes$[ebp], 0
  00072	74 0c		 je	 SHORT $LN5@stbtt_Pack
  00074	8b 45 e0	 mov	 eax, DWORD PTR _nodes$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN5@stbtt_Pack:

; 3806 :       return 0;

  00080	33 c0		 xor	 eax, eax
  00082	e9 c5 00 00 00	 jmp	 $LN1@stbtt_Pack
$LN2@stbtt_Pack:

; 3807 :    }
; 3808 : 
; 3809 :    spc->user_allocator_context = alloc_context;

  00087	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  0008a	8b 4d 20	 mov	 ecx, DWORD PTR _alloc_context$[ebp]
  0008d	89 08		 mov	 DWORD PTR [eax], ecx

; 3810 :    spc->width = pw;

  0008f	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR _pw$[ebp]
  00095	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 3811 :    spc->height = ph;

  00098	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  0009b	8b 4d 14	 mov	 ecx, DWORD PTR _ph$[ebp]
  0009e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3812 :    spc->pixels = pixels;

  000a1	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  000a4	8b 4d 0c	 mov	 ecx, DWORD PTR _pixels$[ebp]
  000a7	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 3813 :    spc->pack_info = context;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _context$[ebp]
  000b0	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3814 :    spc->nodes = nodes;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  000b6	8b 4d e0	 mov	 ecx, DWORD PTR _nodes$[ebp]
  000b9	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 3815 :    spc->padding = padding;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  000bf	8b 4d 1c	 mov	 ecx, DWORD PTR _padding$[ebp]
  000c2	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 3816 :    spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;

  000c5	83 7d 18 00	 cmp	 DWORD PTR _stride_in_bytes$[ebp], 0
  000c9	74 0b		 je	 SHORT $LN8@stbtt_Pack
  000cb	8b 45 18	 mov	 eax, DWORD PTR _stride_in_bytes$[ebp]
  000ce	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  000d4	eb 09		 jmp	 SHORT $LN9@stbtt_Pack
$LN8@stbtt_Pack:
  000d6	8b 4d 10	 mov	 ecx, DWORD PTR _pw$[ebp]
  000d9	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], ecx
$LN9@stbtt_Pack:
  000df	8b 55 08	 mov	 edx, DWORD PTR _spc$[ebp]
  000e2	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv85[ebp]
  000e8	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 3817 :    spc->h_oversample = 1;

  000eb	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  000ee	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [eax+28], 1

; 3818 :    spc->v_oversample = 1;

  000f5	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  000f8	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 3819 :    spc->skip_missing = 0;

  000ff	8b 45 08	 mov	 eax, DWORD PTR _spc$[ebp]
  00102	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 3820 : 
; 3821 :    stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

  00109	8b 45 ec	 mov	 eax, DWORD PTR _num_nodes$[ebp]
  0010c	50		 push	 eax
  0010d	8b 4d e0	 mov	 ecx, DWORD PTR _nodes$[ebp]
  00110	51		 push	 ecx
  00111	8b 55 14	 mov	 edx, DWORD PTR _ph$[ebp]
  00114	2b 55 1c	 sub	 edx, DWORD PTR _padding$[ebp]
  00117	52		 push	 edx
  00118	8b 45 10	 mov	 eax, DWORD PTR _pw$[ebp]
  0011b	2b 45 1c	 sub	 eax, DWORD PTR _padding$[ebp]
  0011e	50		 push	 eax
  0011f	8b 4d f8	 mov	 ecx, DWORD PTR _context$[ebp]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 _stbrp_init_target
  00128	83 c4 14	 add	 esp, 20			; 00000014H

; 3822 : 
; 3823 :    if (pixels)

  0012b	83 7d 0c 00	 cmp	 DWORD PTR _pixels$[ebp], 0
  0012f	74 16		 je	 SHORT $LN6@stbtt_Pack

; 3824 :       STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

  00131	8b 45 10	 mov	 eax, DWORD PTR _pw$[ebp]
  00134	0f af 45 14	 imul	 eax, DWORD PTR _ph$[ebp]
  00138	50		 push	 eax
  00139	6a 00		 push	 0
  0013b	8b 4d 0c	 mov	 ecx, DWORD PTR _pixels$[ebp]
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 _memset
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@stbtt_Pack:

; 3825 : 
; 3826 :    return 1;

  00147	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_Pack:

; 3827 : }

  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00155	3b ec		 cmp	 ebp, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
_stbtt_PackBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT ?rect_original_order@@YAHPBX0@Z
_TEXT	SEGMENT
tv70 = -224						; size = 4
tv71 = -220						; size = 4
_q$ = -20						; size = 4
_p$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?rect_original_order@@YAHPBX0@Z PROC			; rect_original_order, COMDAT

; 546  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 547  :    const stbrp_rect *p = (const stbrp_rect *) a;

  00028	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 548  :    const stbrp_rect *q = (const stbrp_rect *) b;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00031	89 45 ec	 mov	 DWORD PTR _q$[ebp], eax

; 549  :    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _q$[ebp]
  0003a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0003d	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00040	7d 0c		 jge	 SHORT $LN5@rect_origi
  00042	c7 85 24 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv71[ebp], -1
  0004c	eb 30		 jmp	 SHORT $LN6@rect_origi
$LN5@rect_origi:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _q$[ebp]
  00054	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00057	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  0005a	7e 0c		 jle	 SHORT $LN3@rect_origi
  0005c	c7 85 20 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv70[ebp], 1
  00066	eb 0a		 jmp	 SHORT $LN4@rect_origi
$LN3@rect_origi:
  00068	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN4@rect_origi:
  00072	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  00078	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
$LN6@rect_origi:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]

; 550  : }

  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?rect_original_order@@YAHPBX0@Z ENDP			; rect_original_order
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT ?rect_height_compare@@YAHPBX0@Z
_TEXT	SEGMENT
tv84 = -224						; size = 4
tv85 = -220						; size = 4
_q$ = -20						; size = 4
_p$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?rect_height_compare@@YAHPBX0@Z PROC			; rect_height_compare, COMDAT

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 535  :    const stbrp_rect *p = (const stbrp_rect *) a;

  00028	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 536  :    const stbrp_rect *q = (const stbrp_rect *) b;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00031	89 45 ec	 mov	 DWORD PTR _q$[ebp], eax

; 537  :    if (p->h > q->h)

  00034	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00037	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  0003b	8b 55 ec	 mov	 edx, DWORD PTR _q$[ebp]
  0003e	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00042	3b c8		 cmp	 ecx, eax
  00044	7e 05		 jle	 SHORT $LN2@rect_heigh

; 538  :       return -1;

  00046	83 c8 ff	 or	 eax, -1
  00049	eb 71		 jmp	 SHORT $LN1@rect_heigh
$LN2@rect_heigh:

; 539  :    if (p->h < q->h)

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0004e	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00052	8b 55 ec	 mov	 edx, DWORD PTR _q$[ebp]
  00055	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00059	3b c8		 cmp	 ecx, eax
  0005b	7d 07		 jge	 SHORT $LN3@rect_heigh

; 540  :       return  1;

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	eb 58		 jmp	 SHORT $LN1@rect_heigh
$LN3@rect_heigh:

; 541  :    return (p->w > q->w) ? -1 : (p->w < q->w);

  00064	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00067	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  0006b	8b 55 ec	 mov	 edx, DWORD PTR _q$[ebp]
  0006e	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00072	3b c8		 cmp	 ecx, eax
  00074	7e 0c		 jle	 SHORT $LN7@rect_heigh
  00076	c7 85 24 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv85[ebp], -1
  00080	eb 34		 jmp	 SHORT $LN8@rect_heigh
$LN7@rect_heigh:
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00085	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  00089	8b 45 ec	 mov	 eax, DWORD PTR _q$[ebp]
  0008c	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00090	3b d1		 cmp	 edx, ecx
  00092	7d 0c		 jge	 SHORT $LN5@rect_heigh
  00094	c7 85 20 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv84[ebp], 1
  0009e	eb 0a		 jmp	 SHORT $LN6@rect_heigh
$LN5@rect_heigh:
  000a0	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN6@rect_heigh:
  000aa	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv84[ebp]
  000b0	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv85[ebp], edx
$LN8@rect_heigh:
  000b6	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv85[ebp]
$LN1@rect_heigh:

; 542  : }

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  000c5	3b ec		 cmp	 ebp, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
?rect_height_compare@@YAHPBX0@Z ENDP			; rect_height_compare
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z
_TEXT	SEGMENT
$T1 = -308						; size = 12
$T2 = -288						; size = 12
_count$3 = -76						; size = 4
_next$4 = -64						; size = 4
_next$5 = -52						; size = 4
_cur$ = -40						; size = 4
_node$ = -28						; size = 4
_res$ = -16						; size = 12
$T6 = 8							; size = 4
_context$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z PROC ; stbrp__skyline_pack_rectangle, COMDAT

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00012	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 455  :    // find best position according to heuristic
; 456  :    stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);

  00028	8b 45 14	 mov	 eax, DWORD PTR _height$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 0c	 mov	 edx, DWORD PTR _context$[ebp]
  00033	52		 push	 edx
  00034	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ; stbrp__skyline_find_best_pos
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	89 8d e0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  0004b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004e	89 95 e4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], edx
  00054	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00057	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+8], eax
  0005d	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00063	89 4d f0	 mov	 DWORD PTR _res$[ebp], ecx
  00066	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  0006c	89 55 f4	 mov	 DWORD PTR _res$[ebp+4], edx
  0006f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+8]
  00075	89 45 f8	 mov	 DWORD PTR _res$[ebp+8], eax

; 457  :    stbrp_node *node, *cur;
; 458  : 
; 459  :    // bail if:
; 460  :    //    1. it failed
; 461  :    //    2. the best node doesn't fit (we don't always check this)
; 462  :    //    3. we're out of memory
; 463  :    if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {

  00078	83 7d f8 00	 cmp	 DWORD PTR _res$[ebp+8], 0
  0007c	74 17		 je	 SHORT $LN11@stbrp__sky
  0007e	8b 45 f4	 mov	 eax, DWORD PTR _res$[ebp+4]
  00081	03 45 14	 add	 eax, DWORD PTR _height$[ebp]
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _context$[ebp]
  00087	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0008a	7f 09		 jg	 SHORT $LN11@stbrp__sky
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  0008f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00093	75 23		 jne	 SHORT $LN10@stbrp__sky
$LN11@stbrp__sky:

; 464  :       res.prev_link = NULL;

  00095	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _res$[ebp+8], 0

; 465  :       return res;

  0009c	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  0009f	8b 4d f0	 mov	 ecx, DWORD PTR _res$[ebp]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
  000a4	8b 55 f4	 mov	 edx, DWORD PTR _res$[ebp+4]
  000a7	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+8]
  000ad	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000b0	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  000b3	e9 e8 01 00 00	 jmp	 $LN1@stbrp__sky
$LN10@stbrp__sky:

; 466  :    }
; 467  : 
; 468  :    // on success, create new node
; 469  :    node = context->free_head;

  000b8	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  000bb	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000be	89 4d e4	 mov	 DWORD PTR _node$[ebp], ecx

; 470  :    node->x = (stbrp_coord) res.x;

  000c1	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  000c4	66 8b 4d f0	 mov	 cx, WORD PTR _res$[ebp]
  000c8	66 89 08	 mov	 WORD PTR [eax], cx

; 471  :    node->y = (stbrp_coord) (res.y + height);

  000cb	8b 45 f4	 mov	 eax, DWORD PTR _res$[ebp+4]
  000ce	03 45 14	 add	 eax, DWORD PTR _height$[ebp]
  000d1	8b 4d e4	 mov	 ecx, DWORD PTR _node$[ebp]
  000d4	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 472  : 
; 473  :    context->free_head = node->next;

  000d8	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  000db	8b 4d e4	 mov	 ecx, DWORD PTR _node$[ebp]
  000de	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e1	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 474  : 
; 475  :    // insert the new node into the right starting point, and
; 476  :    // let 'cur' point to the remaining nodes needing to be
; 477  :    // stiched back in
; 478  : 
; 479  :    cur = *res.prev_link;

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _res$[ebp+8]
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	89 4d d8	 mov	 DWORD PTR _cur$[ebp], ecx

; 480  :    if (cur->x < res.x) {

  000ec	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  000ef	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000f2	3b 4d f0	 cmp	 ecx, DWORD PTR _res$[ebp]
  000f5	7d 1a		 jge	 SHORT $LN12@stbrp__sky

; 481  :       // preserve the existing one, so start testing with the next one
; 482  :       stbrp_node *next = cur->next;

  000f7	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  000fa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fd	89 4d cc	 mov	 DWORD PTR _next$5[ebp], ecx

; 483  :       cur->next = node;

  00100	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00103	8b 4d e4	 mov	 ecx, DWORD PTR _node$[ebp]
  00106	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 484  :       cur = next;

  00109	8b 45 cc	 mov	 eax, DWORD PTR _next$5[ebp]
  0010c	89 45 d8	 mov	 DWORD PTR _cur$[ebp], eax

; 485  :    } else {

  0010f	eb 08		 jmp	 SHORT $LN2@stbrp__sky
$LN12@stbrp__sky:

; 486  :       *res.prev_link = node;

  00111	8b 45 f8	 mov	 eax, DWORD PTR _res$[ebp+8]
  00114	8b 4d e4	 mov	 ecx, DWORD PTR _node$[ebp]
  00117	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@stbrp__sky:

; 487  :    }
; 488  : 
; 489  :    // from here, traverse cur and free the nodes, until we get to one
; 490  :    // that shouldn't be freed
; 491  :    while (cur->next && cur->next->x <= res.x + width) {

  00119	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  0011c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00120	74 39		 je	 SHORT $LN3@stbrp__sky
  00122	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00125	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00128	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0012b	8b 45 f0	 mov	 eax, DWORD PTR _res$[ebp]
  0012e	03 45 10	 add	 eax, DWORD PTR _width$[ebp]
  00131	3b d0		 cmp	 edx, eax
  00133	7f 26		 jg	 SHORT $LN3@stbrp__sky

; 492  :       stbrp_node *next = cur->next;

  00135	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013b	89 4d c0	 mov	 DWORD PTR _next$4[ebp], ecx

; 493  :       // move the current node to the free list
; 494  :       cur->next = context->free_head;

  0013e	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00141	8b 4d 0c	 mov	 ecx, DWORD PTR _context$[ebp]
  00144	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00147	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 495  :       context->free_head = cur;

  0014a	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  0014d	8b 4d d8	 mov	 ecx, DWORD PTR _cur$[ebp]
  00150	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 496  :       cur = next;

  00153	8b 45 c0	 mov	 eax, DWORD PTR _next$4[ebp]
  00156	89 45 d8	 mov	 DWORD PTR _cur$[ebp], eax

; 497  :    }

  00159	eb be		 jmp	 SHORT $LN2@stbrp__sky
$LN3@stbrp__sky:

; 498  : 
; 499  :    // stitch the list back in
; 500  :    node->next = cur;

  0015b	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0015e	8b 4d d8	 mov	 ecx, DWORD PTR _cur$[ebp]
  00161	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 501  : 
; 502  :    if (cur->x < res.x + width)

  00164	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00167	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0016a	8b 55 f0	 mov	 edx, DWORD PTR _res$[ebp]
  0016d	03 55 10	 add	 edx, DWORD PTR _width$[ebp]
  00170	3b ca		 cmp	 ecx, edx
  00172	7d 0c		 jge	 SHORT $LN14@stbrp__sky

; 503  :       cur->x = (stbrp_coord) (res.x + width);

  00174	8b 45 f0	 mov	 eax, DWORD PTR _res$[ebp]
  00177	03 45 10	 add	 eax, DWORD PTR _width$[ebp]
  0017a	8b 4d d8	 mov	 ecx, DWORD PTR _cur$[ebp]
  0017d	66 89 01	 mov	 WORD PTR [ecx], ax
$LN14@stbrp__sky:

; 504  : 
; 505  : #ifdef _DEBUG
; 506  :    cur = context->active_head;

  00180	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  00183	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00186	89 4d d8	 mov	 DWORD PTR _cur$[ebp], ecx
$LN4@stbrp__sky:

; 507  :    while (cur->x < context->width) {

  00189	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  0018c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0018f	8b 55 0c	 mov	 edx, DWORD PTR _context$[ebp]
  00192	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00194	7d 43		 jge	 SHORT $LN5@stbrp__sky

; 508  :       STBRP_ASSERT(cur->x < cur->next->x);

  00196	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00199	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0019c	8b 55 d8	 mov	 edx, DWORD PTR _cur$[ebp]
  0019f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001a2	0f b7 10	 movzx	 edx, WORD PTR [eax]
  001a5	3b ca		 cmp	 ecx, edx
  001a7	7c 25		 jl	 SHORT $LN16@stbrp__sky
  001a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
  001ae	83 c0 36	 add	 eax, 54			; 00000036H
  001b1	8b f4		 mov	 esi, esp
  001b3	50		 push	 eax
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@NCKIDPDA@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?5?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn@
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c7	3b f4		 cmp	 esi, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@stbrp__sky:

; 509  :       cur = cur->next;

  001ce	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  001d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d4	89 4d d8	 mov	 DWORD PTR _cur$[ebp], ecx

; 510  :    }

  001d7	eb b0		 jmp	 SHORT $LN4@stbrp__sky
$LN5@stbrp__sky:

; 511  :    STBRP_ASSERT(cur->next == NULL);

  001d9	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  001dc	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  001e0	74 26		 je	 SHORT $LN17@stbrp__sky
  001e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
  001e8	83 c1 39	 add	 ecx, 57			; 00000039H
  001eb	8b f4		 mov	 esi, esp
  001ed	51		 push	 ecx
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001f3	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@NJIDGHPD@?$AAc?$AAu?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00201	3b f4		 cmp	 esi, esp
  00203	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN17@stbrp__sky:

; 512  : 
; 513  :    {
; 514  :       int count=0;

  00208	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _count$3[ebp], 0

; 515  :       cur = context->active_head;

  0020f	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  00212	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00215	89 4d d8	 mov	 DWORD PTR _cur$[ebp], ecx
$LN6@stbrp__sky:

; 516  :       while (cur) {

  00218	83 7d d8 00	 cmp	 DWORD PTR _cur$[ebp], 0
  0021c	74 14		 je	 SHORT $LN7@stbrp__sky

; 517  :          cur = cur->next;

  0021e	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00221	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00224	89 4d d8	 mov	 DWORD PTR _cur$[ebp], ecx

; 518  :          ++count;

  00227	8b 45 b4	 mov	 eax, DWORD PTR _count$3[ebp]
  0022a	83 c0 01	 add	 eax, 1
  0022d	89 45 b4	 mov	 DWORD PTR _count$3[ebp], eax

; 519  :       }

  00230	eb e6		 jmp	 SHORT $LN6@stbrp__sky
$LN7@stbrp__sky:

; 520  :       cur = context->free_head;

  00232	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  00235	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00238	89 4d d8	 mov	 DWORD PTR _cur$[ebp], ecx
$LN8@stbrp__sky:

; 521  :       while (cur) {

  0023b	83 7d d8 00	 cmp	 DWORD PTR _cur$[ebp], 0
  0023f	74 14		 je	 SHORT $LN9@stbrp__sky

; 522  :          cur = cur->next;

  00241	8b 45 d8	 mov	 eax, DWORD PTR _cur$[ebp]
  00244	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00247	89 4d d8	 mov	 DWORD PTR _cur$[ebp], ecx

; 523  :          ++count;

  0024a	8b 45 b4	 mov	 eax, DWORD PTR _count$3[ebp]
  0024d	83 c0 01	 add	 eax, 1
  00250	89 45 b4	 mov	 DWORD PTR _count$3[ebp], eax

; 524  :       }

  00253	eb e6		 jmp	 SHORT $LN8@stbrp__sky
$LN9@stbrp__sky:

; 525  :       STBRP_ASSERT(count == context->num_nodes+2);

  00255	8b 45 0c	 mov	 eax, DWORD PTR _context$[ebp]
  00258	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0025b	83 c1 02	 add	 ecx, 2
  0025e	39 4d b4	 cmp	 DWORD PTR _count$3[ebp], ecx
  00261	74 26		 je	 SHORT $LN18@stbrp__sky
  00263	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
  00269	83 c2 47	 add	 edx, 71			; 00000047H
  0026c	8b f4		 mov	 esi, esp
  0026e	52		 push	 edx
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00274	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@MABMKAHD@?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx@
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0027f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00282	3b f4		 cmp	 esi, esp
  00284	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN18@stbrp__sky:

; 526  :    }
; 527  : #endif
; 528  : 
; 529  :    return res;

  00289	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  0028c	8b 4d f0	 mov	 ecx, DWORD PTR _res$[ebp]
  0028f	89 08		 mov	 DWORD PTR [eax], ecx
  00291	8b 55 f4	 mov	 edx, DWORD PTR _res$[ebp+4]
  00294	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00297	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+8]
  0029a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0029d	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
$LN1@stbrp__sky:

; 530  : }

  002a0	52		 push	 edx
  002a1	8b cd		 mov	 ecx, ebp
  002a3	50		 push	 eax
  002a4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@stbrp__sky
  002aa	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002af	58		 pop	 eax
  002b0	5a		 pop	 edx
  002b1	5f		 pop	 edi
  002b2	5e		 pop	 esi
  002b3	5b		 pop	 ebx
  002b4	81 c4 38 01 00
	00		 add	 esp, 312		; 00000138H
  002ba	3b ec		 cmp	 ebp, esp
  002bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c1	8b e5		 mov	 esp, ebp
  002c3	5d		 pop	 ebp
  002c4	c3		 ret	 0
  002c5	0f 1f 00	 npad	 3
$LN21@stbrp__sky:
  002c8	01 00 00 00	 DD	 1
  002cc	00 00 00 00	 DD	 $LN20@stbrp__sky
$LN20@stbrp__sky:
  002d0	f0 ff ff ff	 DD	 -16			; fffffff0H
  002d4	0c 00 00 00	 DD	 12			; 0000000cH
  002d8	00 00 00 00	 DD	 $LN19@stbrp__sky
$LN19@stbrp__sky:
  002dc	72		 DB	 114			; 00000072H
  002dd	65		 DB	 101			; 00000065H
  002de	73		 DB	 115			; 00000073H
  002df	00		 DB	 0
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_pack_rectangle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z
_TEXT	SEGMENT
tv143 = -364						; size = 4
_waste$1 = -164						; size = 4
_y$2 = -152						; size = 4
_xpos$3 = -140						; size = 4
_waste$4 = -128						; size = 4
_y$5 = -116						; size = 4
_best$ = -104						; size = 4
_tail$ = -92						; size = 4
_node$ = -80						; size = 4
_prev$ = -68						; size = 4
_fr$ = -56						; size = 12
_best_y$ = -36						; size = 4
_best_x$ = -24						; size = 4
_best_waste$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
$T6 = 8							; size = 4
_c$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z PROC ; stbrp__skyline_find_best_pos, COMDAT

; 352  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 94 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-364]
  00012	b9 5b 00 00 00	 mov	 ecx, 91			; 0000005bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 353  :    int best_waste = (1<<30), best_x, best_y = (1 << 30);

  00032	c7 45 f4 00 00
	00 40		 mov	 DWORD PTR _best_waste$[ebp], 1073741824 ; 40000000H
  00039	c7 45 dc 00 00
	00 40		 mov	 DWORD PTR _best_y$[ebp], 1073741824 ; 40000000H

; 354  :    stbrp__findresult fr;
; 355  :    stbrp_node **prev, *node, *tail, **best = NULL;

  00040	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _best$[ebp], 0

; 356  : 
; 357  :    // align to multiple of c->align
; 358  :    width = (width + c->align - 1);

  00047	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0004a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004d	8b 55 10	 mov	 edx, DWORD PTR _width$[ebp]
  00050	8d 44 0a ff	 lea	 eax, DWORD PTR [edx+ecx-1]
  00054	89 45 10	 mov	 DWORD PTR _width$[ebp], eax

; 359  :    width -= width % c->align;

  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  0005a	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0005d	99		 cdq
  0005e	f7 79 08	 idiv	 DWORD PTR [ecx+8]
  00061	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00064	2b c2		 sub	 eax, edx
  00066	89 45 10	 mov	 DWORD PTR _width$[ebp], eax

; 360  :    STBRP_ASSERT(width % c->align == 0);

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  0006c	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0006f	99		 cdq
  00070	f7 79 08	 idiv	 DWORD PTR [ecx+8]
  00073	85 d2		 test	 edx, edx
  00075	74 26		 je	 SHORT $LN24@stbrp__sky
  00077	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
  0007d	83 c2 08	 add	 edx, 8
  00080	8b f4		 mov	 esi, esp
  00082	52		 push	 edx
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN24@stbrp__sky:

; 361  : 
; 362  :    // if it can't possibly fit, bail immediately
; 363  :    if (width > c->width || height > c->height) {

  0009d	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  000a3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a5	7f 0b		 jg	 SHORT $LN11@stbrp__sky
  000a7	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000aa	8b 4d 14	 mov	 ecx, DWORD PTR _height$[ebp]
  000ad	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000b0	7e 30		 jle	 SHORT $LN10@stbrp__sky
$LN11@stbrp__sky:

; 364  :       fr.prev_link = NULL;

  000b2	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _fr$[ebp+8], 0

; 365  :       fr.x = fr.y = 0;

  000b9	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _fr$[ebp+4], 0
  000c0	8b 45 cc	 mov	 eax, DWORD PTR _fr$[ebp+4]
  000c3	89 45 c8	 mov	 DWORD PTR _fr$[ebp], eax

; 366  :       return fr;

  000c6	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  000c9	8b 4d c8	 mov	 ecx, DWORD PTR _fr$[ebp]
  000cc	89 08		 mov	 DWORD PTR [eax], ecx
  000ce	8b 55 cc	 mov	 edx, DWORD PTR _fr$[ebp+4]
  000d1	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000d4	8b 4d d0	 mov	 ecx, DWORD PTR _fr$[ebp+8]
  000d7	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000da	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  000dd	e9 c4 02 00 00	 jmp	 $LN1@stbrp__sky
$LN10@stbrp__sky:

; 367  :    }
; 368  : 
; 369  :    node = c->active_head;

  000e2	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000e5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000e8	89 4d b0	 mov	 DWORD PTR _node$[ebp], ecx

; 370  :    prev = &c->active_head;

  000eb	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000ee	83 c0 18	 add	 eax, 24			; 00000018H
  000f1	89 45 bc	 mov	 DWORD PTR _prev$[ebp], eax
$LN2@stbrp__sky:

; 371  :    while (node->x + width <= c->width) {

  000f4	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  000f7	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000fa	03 4d 10	 add	 ecx, DWORD PTR _width$[ebp]
  000fd	8b 55 0c	 mov	 edx, DWORD PTR _c$[ebp]
  00100	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00102	0f 8f 90 00 00
	00		 jg	 $LN3@stbrp__sky

; 372  :       int y,waste;
; 373  :       y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);

  00108	8d 45 80	 lea	 eax, DWORD PTR _waste$4[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  0010f	51		 push	 ecx
  00110	8b 55 b0	 mov	 edx, DWORD PTR _node$[ebp]
  00113	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00116	50		 push	 eax
  00117	8b 4d b0	 mov	 ecx, DWORD PTR _node$[ebp]
  0011a	51		 push	 ecx
  0011b	8b 55 0c	 mov	 edx, DWORD PTR _c$[ebp]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 ?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z ; stbrp__skyline_find_min_y
  00124	83 c4 14	 add	 esp, 20			; 00000014H
  00127	89 45 8c	 mov	 DWORD PTR _y$5[ebp], eax

; 374  :       if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL

  0012a	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0012d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00131	75 16		 jne	 SHORT $LN12@stbrp__sky

; 375  :          // bottom left
; 376  :          if (y < best_y) {

  00133	8b 45 8c	 mov	 eax, DWORD PTR _y$5[ebp]
  00136	3b 45 dc	 cmp	 eax, DWORD PTR _best_y$[ebp]
  00139	7d 0c		 jge	 SHORT $LN14@stbrp__sky

; 377  :             best_y = y;

  0013b	8b 45 8c	 mov	 eax, DWORD PTR _y$5[ebp]
  0013e	89 45 dc	 mov	 DWORD PTR _best_y$[ebp], eax

; 378  :             best = prev;

  00141	8b 45 bc	 mov	 eax, DWORD PTR _prev$[ebp]
  00144	89 45 98	 mov	 DWORD PTR _best$[ebp], eax
$LN14@stbrp__sky:

; 379  :          }
; 380  :       } else {

  00147	eb 38		 jmp	 SHORT $LN13@stbrp__sky
$LN12@stbrp__sky:

; 381  :          // best-fit
; 382  :          if (y + height <= c->height) {

  00149	8b 45 8c	 mov	 eax, DWORD PTR _y$5[ebp]
  0014c	03 45 14	 add	 eax, DWORD PTR _height$[ebp]
  0014f	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  00152	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00155	7f 2a		 jg	 SHORT $LN13@stbrp__sky

; 383  :             // can only use it if it first vertically
; 384  :             if (y < best_y || (y == best_y && waste < best_waste)) {

  00157	8b 45 8c	 mov	 eax, DWORD PTR _y$5[ebp]
  0015a	3b 45 dc	 cmp	 eax, DWORD PTR _best_y$[ebp]
  0015d	7c 10		 jl	 SHORT $LN17@stbrp__sky
  0015f	8b 45 8c	 mov	 eax, DWORD PTR _y$5[ebp]
  00162	3b 45 dc	 cmp	 eax, DWORD PTR _best_y$[ebp]
  00165	75 1a		 jne	 SHORT $LN13@stbrp__sky
  00167	8b 45 80	 mov	 eax, DWORD PTR _waste$4[ebp]
  0016a	3b 45 f4	 cmp	 eax, DWORD PTR _best_waste$[ebp]
  0016d	7d 12		 jge	 SHORT $LN13@stbrp__sky
$LN17@stbrp__sky:

; 385  :                best_y = y;

  0016f	8b 45 8c	 mov	 eax, DWORD PTR _y$5[ebp]
  00172	89 45 dc	 mov	 DWORD PTR _best_y$[ebp], eax

; 386  :                best_waste = waste;

  00175	8b 45 80	 mov	 eax, DWORD PTR _waste$4[ebp]
  00178	89 45 f4	 mov	 DWORD PTR _best_waste$[ebp], eax

; 387  :                best = prev;

  0017b	8b 45 bc	 mov	 eax, DWORD PTR _prev$[ebp]
  0017e	89 45 98	 mov	 DWORD PTR _best$[ebp], eax
$LN13@stbrp__sky:

; 388  :             }
; 389  :          }
; 390  :       }
; 391  :       prev = &node->next;

  00181	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  00184	83 c0 04	 add	 eax, 4
  00187	89 45 bc	 mov	 DWORD PTR _prev$[ebp], eax

; 392  :       node = node->next;

  0018a	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  0018d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00190	89 4d b0	 mov	 DWORD PTR _node$[ebp], ecx

; 393  :    }

  00193	e9 5c ff ff ff	 jmp	 $LN2@stbrp__sky
$LN3@stbrp__sky:

; 394  : 
; 395  :    best_x = (best == NULL) ? 0 : (*best)->x;

  00198	83 7d 98 00	 cmp	 DWORD PTR _best$[ebp], 0
  0019c	75 0c		 jne	 SHORT $LN25@stbrp__sky
  0019e	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv143[ebp], 0
  001a8	eb 0e		 jmp	 SHORT $LN26@stbrp__sky
$LN25@stbrp__sky:
  001aa	8b 45 98	 mov	 eax, DWORD PTR _best$[ebp]
  001ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  001af	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  001b2	89 95 94 fe ff
	ff		 mov	 DWORD PTR tv143[ebp], edx
$LN26@stbrp__sky:
  001b8	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  001be	89 45 e8	 mov	 DWORD PTR _best_x$[ebp], eax

; 396  : 
; 397  :    // if doing best-fit (BF), we also have to try aligning right edge to each node position
; 398  :    //
; 399  :    // e.g, if fitting
; 400  :    //
; 401  :    //     ____________________
; 402  :    //    |____________________|
; 403  :    //
; 404  :    //            into
; 405  :    //
; 406  :    //   |                         |
; 407  :    //   |             ____________|
; 408  :    //   |____________|
; 409  :    //
; 410  :    // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
; 411  :    //
; 412  :    // This makes BF take about 2x the time
; 413  : 
; 414  :    if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {

  001c1	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  001c4	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  001c8	0f 85 af 01 00
	00		 jne	 $LN18@stbrp__sky

; 415  :       tail = c->active_head;

  001ce	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  001d1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001d4	89 4d a4	 mov	 DWORD PTR _tail$[ebp], ecx

; 416  :       node = c->active_head;

  001d7	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  001da	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001dd	89 4d b0	 mov	 DWORD PTR _node$[ebp], ecx

; 417  :       prev = &c->active_head;

  001e0	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  001e3	83 c0 18	 add	 eax, 24			; 00000018H
  001e6	89 45 bc	 mov	 DWORD PTR _prev$[ebp], eax
$LN4@stbrp__sky:

; 418  :       // find first node that's admissible
; 419  :       while (tail->x < width)

  001e9	8b 45 a4	 mov	 eax, DWORD PTR _tail$[ebp]
  001ec	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001ef	3b 4d 10	 cmp	 ecx, DWORD PTR _width$[ebp]
  001f2	7d 0b		 jge	 SHORT $LN6@stbrp__sky

; 420  :          tail = tail->next;

  001f4	8b 45 a4	 mov	 eax, DWORD PTR _tail$[ebp]
  001f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001fa	89 4d a4	 mov	 DWORD PTR _tail$[ebp], ecx
  001fd	eb ea		 jmp	 SHORT $LN4@stbrp__sky
$LN6@stbrp__sky:

; 421  :       while (tail) {

  001ff	83 7d a4 00	 cmp	 DWORD PTR _tail$[ebp], 0
  00203	0f 84 74 01 00
	00		 je	 $LN18@stbrp__sky

; 422  :          int xpos = tail->x - width;

  00209	8b 45 a4	 mov	 eax, DWORD PTR _tail$[ebp]
  0020c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0020f	2b 4d 10	 sub	 ecx, DWORD PTR _width$[ebp]
  00212	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _xpos$3[ebp], ecx

; 423  :          int y,waste;
; 424  :          STBRP_ASSERT(xpos >= 0);

  00218	79 25		 jns	 SHORT $LN8@stbrp__sky
  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
  0021f	83 c0 48	 add	 eax, 72			; 00000048H
  00222	8b f4		 mov	 esi, esp
  00224	50		 push	 eax
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00235	83 c4 0c	 add	 esp, 12			; 0000000cH
  00238	3b f4		 cmp	 esi, esp
  0023a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@stbrp__sky:

; 425  :          // find the left position that matches this
; 426  :          while (node->next->x <= xpos) {

  0023f	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  00242	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00245	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00248	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _xpos$3[ebp]
  0024e	7f 14		 jg	 SHORT $LN9@stbrp__sky

; 427  :             prev = &node->next;

  00250	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  00253	83 c0 04	 add	 eax, 4
  00256	89 45 bc	 mov	 DWORD PTR _prev$[ebp], eax

; 428  :             node = node->next;

  00259	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  0025c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0025f	89 4d b0	 mov	 DWORD PTR _node$[ebp], ecx

; 429  :          }

  00262	eb db		 jmp	 SHORT $LN8@stbrp__sky
$LN9@stbrp__sky:

; 430  :          STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);

  00264	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  00267	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026a	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0026d	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _xpos$3[ebp]
  00273	7e 0e		 jle	 SHORT $LN28@stbrp__sky
  00275	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  00278	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0027b	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _xpos$3[ebp]
  00281	7e 26		 jle	 SHORT $LN29@stbrp__sky
$LN28@stbrp__sky:
  00283	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
  00289	83 c2 4e	 add	 edx, 78			; 0000004eH
  0028c	8b f4		 mov	 esi, esp
  0028e	52		 push	 edx
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a2	3b f4		 cmp	 esi, esp
  002a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN29@stbrp__sky:

; 431  :          y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);

  002a9	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _waste$1[ebp]
  002af	50		 push	 eax
  002b0	8b 4d 10	 mov	 ecx, DWORD PTR _width$[ebp]
  002b3	51		 push	 ecx
  002b4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _xpos$3[ebp]
  002ba	52		 push	 edx
  002bb	8b 45 b0	 mov	 eax, DWORD PTR _node$[ebp]
  002be	50		 push	 eax
  002bf	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  002c2	51		 push	 ecx
  002c3	e8 00 00 00 00	 call	 ?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z ; stbrp__skyline_find_min_y
  002c8	83 c4 14	 add	 esp, 20			; 00000014H
  002cb	89 85 68 ff ff
	ff		 mov	 DWORD PTR _y$2[ebp], eax

; 432  :          if (y + height <= c->height) {

  002d1	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _y$2[ebp]
  002d7	03 45 14	 add	 eax, DWORD PTR _height$[ebp]
  002da	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  002dd	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  002e0	0f 8f 89 00 00
	00		 jg	 $LN19@stbrp__sky

; 433  :             if (y <= best_y) {

  002e6	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _y$2[ebp]
  002ec	3b 45 dc	 cmp	 eax, DWORD PTR _best_y$[ebp]
  002ef	7f 7e		 jg	 SHORT $LN19@stbrp__sky

; 434  :                if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {

  002f1	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _y$2[ebp]
  002f7	3b 45 dc	 cmp	 eax, DWORD PTR _best_y$[ebp]
  002fa	7c 21		 jl	 SHORT $LN22@stbrp__sky
  002fc	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _waste$1[ebp]
  00302	3b 45 f4	 cmp	 eax, DWORD PTR _best_waste$[ebp]
  00305	7c 16		 jl	 SHORT $LN22@stbrp__sky
  00307	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _waste$1[ebp]
  0030d	3b 45 f4	 cmp	 eax, DWORD PTR _best_waste$[ebp]
  00310	75 5d		 jne	 SHORT $LN19@stbrp__sky
  00312	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _xpos$3[ebp]
  00318	3b 45 e8	 cmp	 eax, DWORD PTR _best_x$[ebp]
  0031b	7d 52		 jge	 SHORT $LN19@stbrp__sky
$LN22@stbrp__sky:

; 435  :                   best_x = xpos;

  0031d	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _xpos$3[ebp]
  00323	89 45 e8	 mov	 DWORD PTR _best_x$[ebp], eax

; 436  :                   STBRP_ASSERT(y <= best_y);

  00326	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _y$2[ebp]
  0032c	3b 45 dc	 cmp	 eax, DWORD PTR _best_y$[ebp]
  0032f	7e 26		 jle	 SHORT $LN30@stbrp__sky
  00331	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z@4JA
  00337	83 c1 54	 add	 ecx, 84			; 00000054H
  0033a	8b f4		 mov	 esi, esp
  0033c	51		 push	 ecx
  0033d	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00342	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@JNFMLHFF@?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAe?$AAs?$AAt?$AA_?$AAy@
  00347	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0034d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00350	3b f4		 cmp	 esi, esp
  00352	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN30@stbrp__sky:

; 437  :                   best_y = y;

  00357	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _y$2[ebp]
  0035d	89 45 dc	 mov	 DWORD PTR _best_y$[ebp], eax

; 438  :                   best_waste = waste;

  00360	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _waste$1[ebp]
  00366	89 45 f4	 mov	 DWORD PTR _best_waste$[ebp], eax

; 439  :                   best = prev;

  00369	8b 45 bc	 mov	 eax, DWORD PTR _prev$[ebp]
  0036c	89 45 98	 mov	 DWORD PTR _best$[ebp], eax
$LN19@stbrp__sky:

; 440  :                }
; 441  :             }
; 442  :          }
; 443  :          tail = tail->next;

  0036f	8b 45 a4	 mov	 eax, DWORD PTR _tail$[ebp]
  00372	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00375	89 4d a4	 mov	 DWORD PTR _tail$[ebp], ecx

; 444  :       }         

  00378	e9 82 fe ff ff	 jmp	 $LN6@stbrp__sky
$LN18@stbrp__sky:

; 445  :    }
; 446  : 
; 447  :    fr.prev_link = best;

  0037d	8b 45 98	 mov	 eax, DWORD PTR _best$[ebp]
  00380	89 45 d0	 mov	 DWORD PTR _fr$[ebp+8], eax

; 448  :    fr.x = best_x;

  00383	8b 45 e8	 mov	 eax, DWORD PTR _best_x$[ebp]
  00386	89 45 c8	 mov	 DWORD PTR _fr$[ebp], eax

; 449  :    fr.y = best_y;

  00389	8b 45 dc	 mov	 eax, DWORD PTR _best_y$[ebp]
  0038c	89 45 cc	 mov	 DWORD PTR _fr$[ebp+4], eax

; 450  :    return fr;

  0038f	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  00392	8b 4d c8	 mov	 ecx, DWORD PTR _fr$[ebp]
  00395	89 08		 mov	 DWORD PTR [eax], ecx
  00397	8b 55 cc	 mov	 edx, DWORD PTR _fr$[ebp+4]
  0039a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0039d	8b 4d d0	 mov	 ecx, DWORD PTR _fr$[ebp+8]
  003a0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  003a3	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
$LN1@stbrp__sky:

; 451  : }

  003a6	52		 push	 edx
  003a7	8b cd		 mov	 ecx, ebp
  003a9	50		 push	 eax
  003aa	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN35@stbrp__sky
  003b0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003b5	58		 pop	 eax
  003b6	5a		 pop	 edx
  003b7	5f		 pop	 edi
  003b8	5e		 pop	 esi
  003b9	5b		 pop	 ebx
  003ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bd	33 cd		 xor	 ecx, ebp
  003bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c4	81 c4 6c 01 00
	00		 add	 esp, 364		; 0000016cH
  003ca	3b ec		 cmp	 ebp, esp
  003cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d1	8b e5		 mov	 esp, ebp
  003d3	5d		 pop	 ebp
  003d4	c3		 ret	 0
  003d5	0f 1f 00	 npad	 3
$LN35@stbrp__sky:
  003d8	03 00 00 00	 DD	 3
  003dc	00 00 00 00	 DD	 $LN34@stbrp__sky
$LN34@stbrp__sky:
  003e0	c8 ff ff ff	 DD	 -56			; ffffffc8H
  003e4	0c 00 00 00	 DD	 12			; 0000000cH
  003e8	00 00 00 00	 DD	 $LN31@stbrp__sky
  003ec	80 ff ff ff	 DD	 -128			; ffffff80H
  003f0	04 00 00 00	 DD	 4
  003f4	00 00 00 00	 DD	 $LN32@stbrp__sky
  003f8	5c ff ff ff	 DD	 -164			; ffffff5cH
  003fc	04 00 00 00	 DD	 4
  00400	00 00 00 00	 DD	 $LN33@stbrp__sky
$LN33@stbrp__sky:
  00404	77		 DB	 119			; 00000077H
  00405	61		 DB	 97			; 00000061H
  00406	73		 DB	 115			; 00000073H
  00407	74		 DB	 116			; 00000074H
  00408	65		 DB	 101			; 00000065H
  00409	00		 DB	 0
$LN32@stbrp__sky:
  0040a	77		 DB	 119			; 00000077H
  0040b	61		 DB	 97			; 00000061H
  0040c	73		 DB	 115			; 00000073H
  0040d	74		 DB	 116			; 00000074H
  0040e	65		 DB	 101			; 00000065H
  0040f	00		 DB	 0
$LN31@stbrp__sky:
  00410	66		 DB	 102			; 00000066H
  00411	72		 DB	 114			; 00000072H
  00412	00		 DB	 0
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_find_best_pos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT ?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z
_TEXT	SEGMENT
_under_width$1 = -68					; size = 4
_waste_area$ = -56					; size = 4
_visited_width$ = -44					; size = 4
_min_y$ = -32						; size = 4
_x1$ = -20						; size = 4
_node$ = -8						; size = 4
_c$ = 8							; size = 4
_first$ = 12						; size = 4
_x0$ = 16						; size = 4
_width$ = 20						; size = 4
_pwaste$ = 24						; size = 4
?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z PROC ; stbrp__skyline_find_min_y, COMDAT

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 297  :    stbrp_node *node = first;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _first$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _node$[ebp], eax

; 298  :    int x1 = x0 + width;

  0002e	8b 45 10	 mov	 eax, DWORD PTR _x0$[ebp]
  00031	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR _x1$[ebp], eax

; 299  :    int min_y, visited_width, waste_area;
; 300  : 
; 301  :    STBRP__NOTUSED(c);
; 302  : 
; 303  :    STBRP_ASSERT(first->x <= x0);

  00037	8b 45 0c	 mov	 eax, DWORD PTR _first$[ebp]
  0003a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0003d	3b 4d 10	 cmp	 ecx, DWORD PTR _x0$[ebp]
  00040	7e 26		 jle	 SHORT $LN10@stbrp__sky
  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z@4JA
  00048	83 c2 07	 add	 edx, 7
  0004b	8b f4		 mov	 esi, esp
  0004d	52		 push	 edx
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@stbrp__sky:

; 304  : 
; 305  :    #if 0
; 306  :    // skip in case we're past the node
; 307  :    while (node->next->x <= x0)
; 308  :       ++node;
; 309  :    #else
; 310  :    STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency

  00068	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00071	3b 55 10	 cmp	 edx, DWORD PTR _x0$[ebp]
  00074	7f 25		 jg	 SHORT $LN11@stbrp__sky
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z@4JA
  0007b	83 c0 0e	 add	 eax, 14			; 0000000eH
  0007e	8b f4		 mov	 esi, esp
  00080	50		 push	 eax
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@stbrp__sky:

; 311  :    #endif
; 312  : 
; 313  :    STBRP_ASSERT(node->x <= x0);

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0009e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000a1	3b 4d 10	 cmp	 ecx, DWORD PTR _x0$[ebp]
  000a4	7e 26		 jle	 SHORT $LN12@stbrp__sky
  000a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z@4JA
  000ac	83 c2 11	 add	 edx, 17			; 00000011H
  000af	8b f4		 mov	 esi, esp
  000b1	52		 push	 edx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	3b f4		 cmp	 esi, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@stbrp__sky:

; 314  : 
; 315  :    min_y = 0;

  000cc	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _min_y$[ebp], 0

; 316  :    waste_area = 0;

  000d3	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _waste_area$[ebp], 0

; 317  :    visited_width = 0;

  000da	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _visited_width$[ebp], 0
$LN2@stbrp__sky:

; 318  :    while (node->x < x1) {

  000e1	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  000e4	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000e7	3b 4d ec	 cmp	 ecx, DWORD PTR _x1$[ebp]
  000ea	0f 8d b7 00 00
	00		 jge	 $LN3@stbrp__sky

; 319  :       if (node->y > min_y) {

  000f0	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  000f3	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  000f7	3b 4d e0	 cmp	 ecx, DWORD PTR _min_y$[ebp]
  000fa	7e 56		 jle	 SHORT $LN4@stbrp__sky

; 320  :          // raise min_y higher.
; 321  :          // we've accounted for all waste up to min_y,
; 322  :          // but we'll now add more waste for everything we've visted
; 323  :          waste_area += visited_width * (node->y - min_y);

  000fc	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  000ff	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00103	2b 4d e0	 sub	 ecx, DWORD PTR _min_y$[ebp]
  00106	0f af 4d d4	 imul	 ecx, DWORD PTR _visited_width$[ebp]
  0010a	03 4d c8	 add	 ecx, DWORD PTR _waste_area$[ebp]
  0010d	89 4d c8	 mov	 DWORD PTR _waste_area$[ebp], ecx

; 324  :          min_y = node->y;

  00110	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00113	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00117	89 4d e0	 mov	 DWORD PTR _min_y$[ebp], ecx

; 325  :          // the first time through, visited_width might be reduced
; 326  :          if (node->x < x0)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0011d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00120	3b 4d 10	 cmp	 ecx, DWORD PTR _x0$[ebp]
  00123	7d 14		 jge	 SHORT $LN6@stbrp__sky

; 327  :             visited_width += node->next->x - x0;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0012e	2b 55 10	 sub	 edx, DWORD PTR _x0$[ebp]
  00131	03 55 d4	 add	 edx, DWORD PTR _visited_width$[ebp]
  00134	89 55 d4	 mov	 DWORD PTR _visited_width$[ebp], edx
  00137	eb 17		 jmp	 SHORT $LN7@stbrp__sky
$LN6@stbrp__sky:

; 328  :          else
; 329  :             visited_width += node->next->x - node->x;

  00139	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0013c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00142	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00145	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00148	2b d1		 sub	 edx, ecx
  0014a	03 55 d4	 add	 edx, DWORD PTR _visited_width$[ebp]
  0014d	89 55 d4	 mov	 DWORD PTR _visited_width$[ebp], edx
$LN7@stbrp__sky:

; 330  :       } else {

  00150	eb 47		 jmp	 SHORT $LN5@stbrp__sky
$LN4@stbrp__sky:

; 331  :          // add waste area
; 332  :          int under_width = node->next->x - node->x;

  00152	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00155	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00158	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0015b	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0015e	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00161	2b d1		 sub	 edx, ecx
  00163	89 55 bc	 mov	 DWORD PTR _under_width$1[ebp], edx

; 333  :          if (under_width + visited_width > width)

  00166	8b 45 bc	 mov	 eax, DWORD PTR _under_width$1[ebp]
  00169	03 45 d4	 add	 eax, DWORD PTR _visited_width$[ebp]
  0016c	3b 45 14	 cmp	 eax, DWORD PTR _width$[ebp]
  0016f	7e 09		 jle	 SHORT $LN8@stbrp__sky

; 334  :             under_width = width - visited_width;

  00171	8b 45 14	 mov	 eax, DWORD PTR _width$[ebp]
  00174	2b 45 d4	 sub	 eax, DWORD PTR _visited_width$[ebp]
  00177	89 45 bc	 mov	 DWORD PTR _under_width$1[ebp], eax
$LN8@stbrp__sky:

; 335  :          waste_area += under_width * (min_y - node->y);

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0017d	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00181	8b 55 e0	 mov	 edx, DWORD PTR _min_y$[ebp]
  00184	2b d1		 sub	 edx, ecx
  00186	0f af 55 bc	 imul	 edx, DWORD PTR _under_width$1[ebp]
  0018a	03 55 c8	 add	 edx, DWORD PTR _waste_area$[ebp]
  0018d	89 55 c8	 mov	 DWORD PTR _waste_area$[ebp], edx

; 336  :          visited_width += under_width;

  00190	8b 45 d4	 mov	 eax, DWORD PTR _visited_width$[ebp]
  00193	03 45 bc	 add	 eax, DWORD PTR _under_width$1[ebp]
  00196	89 45 d4	 mov	 DWORD PTR _visited_width$[ebp], eax
$LN5@stbrp__sky:

; 337  :       }
; 338  :       node = node->next;

  00199	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0019c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019f	89 4d f8	 mov	 DWORD PTR _node$[ebp], ecx

; 339  :    }

  001a2	e9 3a ff ff ff	 jmp	 $LN2@stbrp__sky
$LN3@stbrp__sky:

; 340  : 
; 341  :    *pwaste = waste_area;

  001a7	8b 45 18	 mov	 eax, DWORD PTR _pwaste$[ebp]
  001aa	8b 4d c8	 mov	 ecx, DWORD PTR _waste_area$[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 342  :    return min_y;

  001af	8b 45 e0	 mov	 eax, DWORD PTR _min_y$[ebp]

; 343  : }

  001b2	5f		 pop	 edi
  001b3	5e		 pop	 esi
  001b4	5b		 pop	 ebx
  001b5	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  001bb	3b ec		 cmp	 ebp, esp
  001bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z ENDP ; stbrp__skyline_find_min_y
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT _stbrp_setup_allow_out_of_mem
_TEXT	SEGMENT
_context$ = 8						; size = 4
_allow_out_of_mem$ = 12					; size = 4
_stbrp_setup_allow_out_of_mem PROC			; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 244  :    if (allow_out_of_mem)

  00028	83 7d 0c 00	 cmp	 DWORD PTR _allow_out_of_mem$[ebp], 0
  0002c	74 0c		 je	 SHORT $LN2@stbrp_setu

; 245  :       // if it's ok to run out of memory, then don't bother aligning them;
; 246  :       // this gives better packing, but may fail due to OOM (even though
; 247  :       // the rectangles easily fit). @TODO a smarter approach would be to only
; 248  :       // quantize once we've hit OOM, then we could get rid of this parameter.
; 249  :       context->align = 1;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  00031	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [eax+8], 1
  00038	eb 1c		 jmp	 SHORT $LN1@stbrp_setu
$LN2@stbrp_setu:

; 250  :    else {
; 251  :       // if it's not ok to run out of memory, then quantize the widths
; 252  :       // so that num_nodes is always enough nodes.
; 253  :       //
; 254  :       // I.e. num_nodes * align >= width
; 255  :       //                  align >= width / num_nodes
; 256  :       //                  align = ceil(width/num_nodes)
; 257  : 
; 258  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  00042	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00045	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  0004c	99		 cdq
  0004d	f7 79 14	 idiv	 DWORD PTR [ecx+20]
  00050	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  00053	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN1@stbrp_setu:

; 259  :    }
; 260  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_stbrp_setup_allow_out_of_mem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT _stbrp_init_target
_TEXT	SEGMENT
_i$ = -8						; size = 4
_context$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_nodes$ = 20						; size = 4
_num_nodes$ = 24					; size = 4
_stbrp_init_target PROC					; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 264  :    int i;
; 265  : #ifndef STBRP_LARGE_RECTS
; 266  :    STBRP_ASSERT(width <= 0xffff && height <= 0xffff);

  00028	81 7d 0c ff ff
	00 00		 cmp	 DWORD PTR _width$[ebp], 65535 ; 0000ffffH
  0002f	7f 09		 jg	 SHORT $LN6@stbrp_init
  00031	81 7d 10 ff ff
	00 00		 cmp	 DWORD PTR _height$[ebp], 65535 ; 0000ffffH
  00038	7e 25		 jle	 SHORT $LN7@stbrp_init
$LN6@stbrp_init:
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??stbrp_init_target@@9@4JA
  0003f	83 c0 03	 add	 eax, 3
  00042	8b f4		 mov	 esi, esp
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@FGNPCGLM@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@stbrp_init:

; 267  : #endif
; 268  : 
; 269  :    for (i=0; i < num_nodes-1; ++i)

  0005f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00066	eb 09		 jmp	 SHORT $LN4@stbrp_init
$LN2@stbrp_init:
  00068	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	83 c0 01	 add	 eax, 1
  0006e	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbrp_init:
  00071	8b 45 18	 mov	 eax, DWORD PTR _num_nodes$[ebp]
  00074	83 e8 01	 sub	 eax, 1
  00077	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0007a	7d 16		 jge	 SHORT $LN3@stbrp_init

; 270  :       nodes[i].next = &nodes[i+1];

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	8b 4d 14	 mov	 ecx, DWORD PTR _nodes$[ebp]
  00082	8d 54 c1 08	 lea	 edx, DWORD PTR [ecx+eax*8+8]
  00086	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00089	8b 4d 14	 mov	 ecx, DWORD PTR _nodes$[ebp]
  0008c	89 54 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], edx
  00090	eb d6		 jmp	 SHORT $LN2@stbrp_init
$LN3@stbrp_init:

; 271  :    nodes[i].next = NULL;

  00092	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00095	8b 4d 14	 mov	 ecx, DWORD PTR _nodes$[ebp]
  00098	c7 44 c1 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*8+4], 0

; 272  :    context->init_mode = STBRP__INIT_skyline;

  000a0	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000a3	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 273  :    context->heuristic = STBRP_HEURISTIC_Skyline_default;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000ad	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 274  :    context->free_head = &nodes[0];

  000b4	b8 08 00 00 00	 mov	 eax, 8
  000b9	6b c8 00	 imul	 ecx, eax, 0
  000bc	03 4d 14	 add	 ecx, DWORD PTR _nodes$[ebp]
  000bf	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  000c2	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 275  :    context->active_head = &context->extra[0];

  000c5	b8 08 00 00 00	 mov	 eax, 8
  000ca	6b c8 00	 imul	 ecx, eax, 0
  000cd	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  000d0	8d 44 0a 20	 lea	 eax, DWORD PTR [edx+ecx+32]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  000d7	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 276  :    context->width = width;

  000da	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _width$[ebp]
  000e0	89 08		 mov	 DWORD PTR [eax], ecx

; 277  :    context->height = height;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000e5	8b 4d 10	 mov	 ecx, DWORD PTR _height$[ebp]
  000e8	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 278  :    context->num_nodes = num_nodes;

  000eb	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000ee	8b 4d 18	 mov	 ecx, DWORD PTR _num_nodes$[ebp]
  000f1	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 279  :    stbrp_setup_allow_out_of_mem(context, 0);

  000f4	6a 00		 push	 0
  000f6	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _stbrp_setup_allow_out_of_mem
  000ff	83 c4 08	 add	 esp, 8

; 280  : 
; 281  :    // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
; 282  :    context->extra[0].x = 0;

  00102	b8 08 00 00 00	 mov	 eax, 8
  00107	6b c8 00	 imul	 ecx, eax, 0
  0010a	33 d2		 xor	 edx, edx
  0010c	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  0010f	66 89 54 08 20	 mov	 WORD PTR [eax+ecx+32], dx

; 283  :    context->extra[0].y = 0;

  00114	b8 08 00 00 00	 mov	 eax, 8
  00119	6b c8 00	 imul	 ecx, eax, 0
  0011c	33 d2		 xor	 edx, edx
  0011e	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  00121	66 89 54 08 22	 mov	 WORD PTR [eax+ecx+34], dx

; 284  :    context->extra[0].next = &context->extra[1];

  00126	b8 08 00 00 00	 mov	 eax, 8
  0012b	c1 e0 00	 shl	 eax, 0
  0012e	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  00131	8d 54 01 20	 lea	 edx, DWORD PTR [ecx+eax+32]
  00135	b8 08 00 00 00	 mov	 eax, 8
  0013a	6b c8 00	 imul	 ecx, eax, 0
  0013d	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  00140	89 54 08 24	 mov	 DWORD PTR [eax+ecx+36], edx

; 285  :    context->extra[1].x = (stbrp_coord) width;

  00144	b8 08 00 00 00	 mov	 eax, 8
  00149	c1 e0 00	 shl	 eax, 0
  0014c	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  0014f	66 8b 55 0c	 mov	 dx, WORD PTR _width$[ebp]
  00153	66 89 54 01 20	 mov	 WORD PTR [ecx+eax+32], dx

; 286  : #ifdef STBRP_LARGE_RECTS
; 287  :    context->extra[1].y = (1<<30);
; 288  : #else
; 289  :    context->extra[1].y = 65535;

  00158	b8 08 00 00 00	 mov	 eax, 8
  0015d	c1 e0 00	 shl	 eax, 0
  00160	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00165	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  00168	66 89 4c 02 22	 mov	 WORD PTR [edx+eax+34], cx

; 290  : #endif
; 291  :    context->extra[1].next = NULL;

  0016d	b8 08 00 00 00	 mov	 eax, 8
  00172	c1 e0 00	 shl	 eax, 0
  00175	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  00178	c7 44 01 24 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+36], 0

; 292  : }

  00180	5f		 pop	 edi
  00181	5e		 pop	 esi
  00182	5b		 pop	 ebx
  00183	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00189	3b ec		 cmp	 ebp, esp
  0018b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00190	8b e5		 mov	 esp, ebp
  00192	5d		 pop	 ebp
  00193	c3		 ret	 0
_stbrp_init_target ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imstb_rectpack.h
;	COMDAT _stbrp_pack_rects
_TEXT	SEGMENT
tv169 = -280						; size = 4
$T1 = -272						; size = 12
$T2 = -252						; size = 12
_fr$3 = -40						; size = 12
_all_rects_packed$ = -20				; size = 4
_i$ = -8						; size = 4
_context$ = 8						; size = 4
_rects$ = 12						; size = 4
_num_rects$ = 16					; size = 4
_stbrp_pack_rects PROC					; COMDAT

; 559  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __285947CA_imstb_rectpack@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 560  :    int i, all_rects_packed = 1;

  00028	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _all_rects_packed$[ebp], 1

; 561  : 
; 562  :    // we use the 'was_packed' field internally to allow sorting/unsorting
; 563  :    for (i=0; i < num_rects; ++i) {

  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00036	eb 09		 jmp	 SHORT $LN4@stbrp_pack
$LN2@stbrp_pack:
  00038	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	83 c0 01	 add	 eax, 1
  0003e	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@stbrp_pack:
  00041	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00044	3b 45 10	 cmp	 eax, DWORD PTR _num_rects$[ebp]
  00047	7d 12		 jge	 SHORT $LN3@stbrp_pack

; 564  :       rects[i].was_packed = i;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	c1 e0 04	 shl	 eax, 4
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  00052	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00055	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 565  :    }

  00059	eb dd		 jmp	 SHORT $LN2@stbrp_pack
$LN3@stbrp_pack:

; 566  : 
; 567  :    // sort according to heuristic
; 568  :    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

  0005b	8b f4		 mov	 esi, esp
  0005d	68 00 00 00 00	 push	 OFFSET ?rect_height_compare@@YAHPBX0@Z ; rect_height_compare
  00062	6a 10		 push	 16			; 00000010H
  00064	8b 45 10	 mov	 eax, DWORD PTR _num_rects$[ebp]
  00067	50		 push	 eax
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  0006b	51		 push	 ecx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__qsort
  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 569  : 
; 570  :    for (i=0; i < num_rects; ++i) {

  0007c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00083	eb 09		 jmp	 SHORT $LN7@stbrp_pack
$LN5@stbrp_pack:
  00085	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@stbrp_pack:
  0008e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00091	3b 45 10	 cmp	 eax, DWORD PTR _num_rects$[ebp]
  00094	0f 8d 06 01 00
	00		 jge	 $LN6@stbrp_pack

; 571  :       if (rects[i].w == 0 || rects[i].h == 0) {

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0009d	c1 e0 04	 shl	 eax, 4
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  000a3	0f b7 54 01 04	 movzx	 edx, WORD PTR [ecx+eax+4]
  000a8	85 d2		 test	 edx, edx
  000aa	74 12		 je	 SHORT $LN13@stbrp_pack
  000ac	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000af	c1 e0 04	 shl	 eax, 4
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  000b5	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  000ba	85 d2		 test	 edx, edx
  000bc	75 25		 jne	 SHORT $LN11@stbrp_pack
$LN13@stbrp_pack:

; 572  :          rects[i].x = rects[i].y = 0;  // empty rect needs no space

  000be	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c1	c1 e0 04	 shl	 eax, 4
  000c4	33 c9		 xor	 ecx, ecx
  000c6	8b 55 0c	 mov	 edx, DWORD PTR _rects$[ebp]
  000c9	66 89 4c 02 0a	 mov	 WORD PTR [edx+eax+10], cx
  000ce	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000d1	c1 e0 04	 shl	 eax, 4
  000d4	33 c9		 xor	 ecx, ecx
  000d6	8b 55 0c	 mov	 edx, DWORD PTR _rects$[ebp]
  000d9	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx

; 573  :       } else {

  000de	e9 b8 00 00 00	 jmp	 $LN12@stbrp_pack
$LN11@stbrp_pack:

; 574  :          stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e6	c1 e0 04	 shl	 eax, 4
  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  000ec	0f b7 54 01 06	 movzx	 edx, WORD PTR [ecx+eax+6]
  000f1	52		 push	 edx
  000f2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f5	c1 e0 04	 shl	 eax, 4
  000f8	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  000fb	0f b7 54 01 04	 movzx	 edx, WORD PTR [ecx+eax+4]
  00100	52		 push	 edx
  00101	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  00104	50		 push	 eax
  00105	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ; stbrp__skyline_pack_rectangle
  00111	83 c4 10	 add	 esp, 16			; 00000010H
  00114	8b 10		 mov	 edx, DWORD PTR [eax]
  00116	89 95 04 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  0011c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011f	89 8d 08 ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], ecx
  00125	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00128	89 95 0c ff ff
	ff		 mov	 DWORD PTR $T2[ebp+8], edx
  0012e	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00134	89 45 d8	 mov	 DWORD PTR _fr$3[ebp], eax
  00137	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+4]
  0013d	89 4d dc	 mov	 DWORD PTR _fr$3[ebp+4], ecx
  00140	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+8]
  00146	89 55 e0	 mov	 DWORD PTR _fr$3[ebp+8], edx

; 575  :          if (fr.prev_link) {

  00149	83 7d e0 00	 cmp	 DWORD PTR _fr$3[ebp+8], 0
  0014d	74 26		 je	 SHORT $LN14@stbrp_pack

; 576  :             rects[i].x = (stbrp_coord) fr.x;

  0014f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00152	c1 e0 04	 shl	 eax, 4
  00155	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  00158	66 8b 55 d8	 mov	 dx, WORD PTR _fr$3[ebp]
  0015c	66 89 54 01 08	 mov	 WORD PTR [ecx+eax+8], dx

; 577  :             rects[i].y = (stbrp_coord) fr.y;

  00161	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00164	c1 e0 04	 shl	 eax, 4
  00167	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  0016a	66 8b 55 dc	 mov	 dx, WORD PTR _fr$3[ebp+4]
  0016e	66 89 54 01 0a	 mov	 WORD PTR [ecx+eax+10], dx

; 578  :          } else {

  00173	eb 26		 jmp	 SHORT $LN12@stbrp_pack
$LN14@stbrp_pack:

; 579  :             rects[i].x = rects[i].y = STBRP__MAXVAL;

  00175	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00178	c1 e0 04	 shl	 eax, 4
  0017b	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00180	8b 55 0c	 mov	 edx, DWORD PTR _rects$[ebp]
  00183	66 89 4c 02 0a	 mov	 WORD PTR [edx+eax+10], cx
  00188	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0018b	c1 e0 04	 shl	 eax, 4
  0018e	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00193	8b 55 0c	 mov	 edx, DWORD PTR _rects$[ebp]
  00196	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx
$LN12@stbrp_pack:

; 580  :          }
; 581  :       }
; 582  :    }

  0019b	e9 e5 fe ff ff	 jmp	 $LN5@stbrp_pack
$LN6@stbrp_pack:

; 583  : 
; 584  :    // unsort
; 585  :    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

  001a0	8b f4		 mov	 esi, esp
  001a2	68 00 00 00 00	 push	 OFFSET ?rect_original_order@@YAHPBX0@Z ; rect_original_order
  001a7	6a 10		 push	 16			; 00000010H
  001a9	8b 45 10	 mov	 eax, DWORD PTR _num_rects$[ebp]
  001ac	50		 push	 eax
  001ad	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  001b0	51		 push	 ecx
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__qsort
  001b7	83 c4 10	 add	 esp, 16			; 00000010H
  001ba	3b f4		 cmp	 esi, esp
  001bc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 586  : 
; 587  :    // set was_packed flags and all_rects_packed status
; 588  :    for (i=0; i < num_rects; ++i) {

  001c1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001c8	eb 09		 jmp	 SHORT $LN10@stbrp_pack
$LN8@stbrp_pack:
  001ca	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001cd	83 c0 01	 add	 eax, 1
  001d0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN10@stbrp_pack:
  001d3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001d6	3b 45 10	 cmp	 eax, DWORD PTR _num_rects$[ebp]
  001d9	7d 6e		 jge	 SHORT $LN9@stbrp_pack

; 589  :       rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);

  001db	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001de	c1 e0 04	 shl	 eax, 4
  001e1	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  001e4	0f b7 54 01 08	 movzx	 edx, WORD PTR [ecx+eax+8]
  001e9	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  001ef	75 22		 jne	 SHORT $LN18@stbrp_pack
  001f1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001f4	c1 e0 04	 shl	 eax, 4
  001f7	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  001fa	0f b7 54 01 0a	 movzx	 edx, WORD PTR [ecx+eax+10]
  001ff	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00205	75 0c		 jne	 SHORT $LN18@stbrp_pack
  00207	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv169[ebp], 0
  00211	eb 0a		 jmp	 SHORT $LN19@stbrp_pack
$LN18@stbrp_pack:
  00213	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv169[ebp], 1
$LN19@stbrp_pack:
  0021d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00220	c1 e0 04	 shl	 eax, 4
  00223	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  00226	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv169[ebp]
  0022c	89 54 01 0c	 mov	 DWORD PTR [ecx+eax+12], edx

; 590  :       if (!rects[i].was_packed)

  00230	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00233	c1 e0 04	 shl	 eax, 4
  00236	8b 4d 0c	 mov	 ecx, DWORD PTR _rects$[ebp]
  00239	83 7c 01 0c 00	 cmp	 DWORD PTR [ecx+eax+12], 0
  0023e	75 07		 jne	 SHORT $LN16@stbrp_pack

; 591  :          all_rects_packed = 0;

  00240	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _all_rects_packed$[ebp], 0
$LN16@stbrp_pack:

; 592  :    }

  00247	eb 81		 jmp	 SHORT $LN8@stbrp_pack
$LN9@stbrp_pack:

; 593  : 
; 594  :    // return the all_rects_packed status
; 595  :    return all_rects_packed;

  00249	8b 45 ec	 mov	 eax, DWORD PTR _all_rects_packed$[ebp]

; 596  : }

  0024c	52		 push	 edx
  0024d	8b cd		 mov	 ecx, ebp
  0024f	50		 push	 eax
  00250	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN22@stbrp_pack
  00256	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0025b	58		 pop	 eax
  0025c	5a		 pop	 edx
  0025d	5f		 pop	 edi
  0025e	5e		 pop	 esi
  0025f	5b		 pop	 ebx
  00260	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00266	3b ec		 cmp	 ebp, esp
  00268	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0026d	8b e5		 mov	 esp, ebp
  0026f	5d		 pop	 ebp
  00270	c3		 ret	 0
  00271	0f 1f 00	 npad	 3
$LN22@stbrp_pack:
  00274	01 00 00 00	 DD	 1
  00278	00 00 00 00	 DD	 $LN21@stbrp_pack
$LN21@stbrp_pack:
  0027c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00280	0c 00 00 00	 DD	 12			; 0000000cH
  00284	00 00 00 00	 DD	 $LN20@stbrp_pack
$LN20@stbrp_pack:
  00288	66		 DB	 102			; 00000066H
  00289	72		 DB	 114			; 00000072H
  0028a	00		 DB	 0
_stbrp_pack_rects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQBEPAEHHHHH@Z
_TEXT	SEGMENT
_i$1 = -32						; size = 4
_j$2 = -20						; size = 4
_data$ = -8						; size = 4
_table$ = 8						; size = 4
_pixels$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_w$ = 24						; size = 4
_h$ = 28						; size = 4
_stride$ = 32						; size = 4
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQBEPAEHHHHH@Z PROC ; ImFontAtlasBuildMultiplyRectAlpha8, COMDAT

; 1840 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1841 :     unsigned char* data = pixels + x + y * stride;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _pixels$[ebp]
  0002b	03 45 10	 add	 eax, DWORD PTR _x$[ebp]
  0002e	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00031	0f af 4d 20	 imul	 ecx, DWORD PTR _stride$[ebp]
  00035	03 c1		 add	 eax, ecx
  00037	89 45 f8	 mov	 DWORD PTR _data$[ebp], eax

; 1842 :     for (int j = h; j > 0; j--, data += stride)

  0003a	8b 45 1c	 mov	 eax, DWORD PTR _h$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR _j$2[ebp], eax
  00040	eb 12		 jmp	 SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
  00042	8b 45 ec	 mov	 eax, DWORD PTR _j$2[ebp]
  00045	83 e8 01	 sub	 eax, 1
  00048	89 45 ec	 mov	 DWORD PTR _j$2[ebp], eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _data$[ebp]
  0004e	03 4d 20	 add	 ecx, DWORD PTR _stride$[ebp]
  00051	89 4d f8	 mov	 DWORD PTR _data$[ebp], ecx
$LN4@ImFontAtla:
  00054	83 7d ec 00	 cmp	 DWORD PTR _j$2[ebp], 0
  00058	7e 35		 jle	 SHORT $LN1@ImFontAtla

; 1843 :         for (int i = 0; i < w; i++)

  0005a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
  00063	8b 45 e0	 mov	 eax, DWORD PTR _i$1[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 e0	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@ImFontAtla:
  0006c	8b 45 e0	 mov	 eax, DWORD PTR _i$1[ebp]
  0006f	3b 45 18	 cmp	 eax, DWORD PTR _w$[ebp]
  00072	7d 19		 jge	 SHORT $LN6@ImFontAtla

; 1844 :             data[i] = table[data[i]];

  00074	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  00077	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  0007a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _data$[ebp]
  00080	03 55 e0	 add	 edx, DWORD PTR _i$1[ebp]
  00083	8b 45 08	 mov	 eax, DWORD PTR _table$[ebp]
  00086	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00089	88 0a		 mov	 BYTE PTR [edx], cl
  0008b	eb d6		 jmp	 SHORT $LN5@ImFontAtla
$LN6@ImFontAtla:
  0008d	eb b3		 jmp	 SHORT $LN2@ImFontAtla
$LN1@ImFontAtla:

; 1845 : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQBEPAEHHHHH@Z ENDP ; ImFontAtlasBuildMultiplyRectAlpha8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQAEM@Z
_TEXT	SEGMENT
tv82 = -228						; size = 8
tv78 = -220						; size = 4
tv74 = -220						; size = 4
_value$1 = -20						; size = 4
_i$2 = -8						; size = 4
_out_table$ = 8						; size = 4
_in_brighten_factor$ = 12				; size = 4
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQAEM@Z PROC ; ImFontAtlasBuildMultiplyCalcLookupTable, COMDAT

; 1831 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1832 :     for (unsigned int i = 0; i < 256; i++)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@ImFontAtla:
  0003a	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _i$2[ebp], 256 ; 00000100H
  00041	73 76		 jae	 SHORT $LN3@ImFontAtla

; 1833 :     {
; 1834 :         unsigned int value = (unsigned int)(i * in_brighten_factor);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00046	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  0004c	f2 0f 2a 85 24
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv78[ebp]
  00054	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  0005a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0005d	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00066	f2 0f 11 85 1c
	ff ff ff	 movsd	 QWORD PTR tv82[ebp], xmm0
  0006e	f2 0f 5a 85 1c
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv82[ebp]
  00076	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _in_brighten_factor$[ebp]
  0007b	e8 00 00 00 00	 call	 __ftoui3
  00080	89 45 ec	 mov	 DWORD PTR _value$1[ebp], eax

; 1835 :         out_table[i] = value > 255 ? 255 : (value & 0xFF);

  00083	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _value$1[ebp], 255 ; 000000ffH
  0008a	76 0c		 jbe	 SHORT $LN6@ImFontAtla
  0008c	c7 85 24 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv74[ebp], 255 ; 000000ffH
  00096	eb 0e		 jmp	 SHORT $LN7@ImFontAtla
$LN6@ImFontAtla:
  00098	8b 45 ec	 mov	 eax, DWORD PTR _value$1[ebp]
  0009b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a0	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
$LN7@ImFontAtla:
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _out_table$[ebp]
  000a9	03 4d f8	 add	 ecx, DWORD PTR _i$2[ebp]
  000ac	8a 95 24 ff ff
	ff		 mov	 dl, BYTE PTR tv74[ebp]
  000b2	88 11		 mov	 BYTE PTR [ecx], dl

; 1836 :     }

  000b4	e9 78 ff ff ff	 jmp	 $LN2@ImFontAtla
$LN3@ImFontAtla:

; 1837 : }

  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000c2	3b ec		 cmp	 ebp, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQAEM@Z ENDP ; ImFontAtlasBuildMultiplyCalcLookupTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z
_TEXT	SEGMENT
_j$1 = -116						; size = 4
_ellipsis_variants$2 = -104				; size = 4
_font$3 = -92						; size = 4
_i$4 = -80						; size = 4
_i$5 = -68						; size = 4
_uv1$6 = -56						; size = 8
_uv0$7 = -40						; size = 8
_r$8 = -24						; size = 4
_i$9 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_atlas$ = 8						; size = 4
?ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z PROC	; ImFontAtlasBuildFinish, COMDAT

; 2223 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd c8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-312]
  00012	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2224 :     // Render into our custom data block
; 2225 :     ImFontAtlasBuildRenderDefaultTexData(atlas);

  00032	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRenderDefaultTexData@@YAXPAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderDefaultTexData
  0003b	83 c4 04	 add	 esp, 4

; 2226 : 
; 2227 :     // Register custom rectangle glyphs
; 2228 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

  0003e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$9[ebp], 0
  00045	eb 09		 jmp	 SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
  00047	8b 45 f4	 mov	 eax, DWORD PTR _i$9[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 f4	 mov	 DWORD PTR _i$9[ebp], eax
$LN4@ImFontAtla:
  00050	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00053	8b 4d f4	 mov	 ecx, DWORD PTR _i$9[ebp]
  00056	3b 48 40	 cmp	 ecx, DWORD PTR [eax+64]
  00059	0f 8d 1e 01 00
	00		 jge	 $LN3@ImFontAtla

; 2229 :     {
; 2230 :         const ImFontAtlasCustomRect& r = atlas->CustomRects[i];

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _i$9[ebp]
  00062	50		 push	 eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00066	83 c1 40	 add	 ecx, 64			; 00000040H
  00069	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  0006e	89 45 e8	 mov	 DWORD PTR _r$8[ebp], eax

; 2231 :         if (r.Font == NULL || r.ID >= 0x110000)

  00071	8b 45 e8	 mov	 eax, DWORD PTR _r$8[ebp]
  00074	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00078	74 0b		 je	 SHORT $LN15@ImFontAtla
  0007a	8b 45 e8	 mov	 eax, DWORD PTR _r$8[ebp]
  0007d	81 38 00 00 11
	00		 cmp	 DWORD PTR [eax], 1114112 ; 00110000H
  00083	72 02		 jb	 SHORT $LN14@ImFontAtla
$LN15@ImFontAtla:

; 2232 :             continue;

  00085	eb c0		 jmp	 SHORT $LN2@ImFontAtla
$LN14@ImFontAtla:

; 2233 : 
; 2234 :         IM_ASSERT(r.Font->ContainerAtlas == atlas);

  00087	8b 45 e8	 mov	 eax, DWORD PTR _r$8[ebp]
  0008a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0008d	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00090	3b 55 08	 cmp	 edx, DWORD PTR _atlas$[ebp]
  00093	74 25		 je	 SHORT $LN20@ImFontAtla
  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z@4JA
  0009a	83 c0 0b	 add	 eax, 11			; 0000000bH
  0009d	8b f4		 mov	 esi, esp
  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@GJDLMPMC@?$AAr?$AA?4?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn@
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	3b f4		 cmp	 esi, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@ImFontAtla:

; 2235 :         ImVec2 uv0, uv1;

  000ba	8d 4d d8	 lea	 ecx, DWORD PTR _uv0$7[ebp]
  000bd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  000c2	8d 4d c8	 lea	 ecx, DWORD PTR _uv1$6[ebp]
  000c5	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2

; 2236 :         atlas->CalcCustomRectUV(&r, &uv0, &uv1);

  000ca	8d 45 c8	 lea	 eax, DWORD PTR _uv1$6[ebp]
  000cd	50		 push	 eax
  000ce	8d 4d d8	 lea	 ecx, DWORD PTR _uv0$7[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 e8	 mov	 edx, DWORD PTR _r$8[ebp]
  000d5	52		 push	 edx
  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  000d9	e8 00 00 00 00	 call	 ?CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z ; ImFontAtlas::CalcCustomRectUV

; 2237 :         r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);

  000de	8b 45 e8	 mov	 eax, DWORD PTR _r$8[ebp]
  000e1	51		 push	 ecx
  000e2	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ec	51		 push	 ecx
  000ed	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _uv1$6[ebp+4]
  000f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f7	51		 push	 ecx
  000f8	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _uv1$6[ebp]
  000fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00102	51		 push	 ecx
  00103	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _uv0$7[ebp+4]
  00108	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010d	51		 push	 ecx
  0010e	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _uv0$7[ebp]
  00113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00118	8b 4d e8	 mov	 ecx, DWORD PTR _r$8[ebp]
  0011b	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  0011f	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00123	8b 45 e8	 mov	 eax, DWORD PTR _r$8[ebp]
  00126	f3 0f 58 40 14	 addss	 xmm0, DWORD PTR [eax+20]
  0012b	51		 push	 ecx
  0012c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00131	8b 4d e8	 mov	 ecx, DWORD PTR _r$8[ebp]
  00134	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  00138	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0013c	8b 45 e8	 mov	 eax, DWORD PTR _r$8[ebp]
  0013f	f3 0f 58 40 10	 addss	 xmm0, DWORD PTR [eax+16]
  00144	51		 push	 ecx
  00145	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014a	8b 4d e8	 mov	 ecx, DWORD PTR _r$8[ebp]
  0014d	51		 push	 ecx
  0014e	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [ecx+20]
  00153	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00158	8b 55 e8	 mov	 edx, DWORD PTR _r$8[ebp]
  0015b	51		 push	 ecx
  0015c	f3 0f 10 42 10	 movss	 xmm0, DWORD PTR [edx+16]
  00161	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00166	8b 45 e8	 mov	 eax, DWORD PTR _r$8[ebp]
  00169	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0016c	51		 push	 ecx
  0016d	8b 55 e8	 mov	 edx, DWORD PTR _r$8[ebp]
  00170	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00173	e8 00 00 00 00	 call	 ?AddGlyph@ImFont@@QAEXGMMMMMMMMM@Z ; ImFont::AddGlyph

; 2238 :     }

  00178	e9 ca fe ff ff	 jmp	 $LN2@ImFontAtla
$LN3@ImFontAtla:

; 2239 : 
; 2240 :     // Build all fonts lookup tables
; 2241 :     for (int i = 0; i < atlas->Fonts.Size; i++)

  0017d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00184	eb 09		 jmp	 SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
  00186	8b 45 bc	 mov	 eax, DWORD PTR _i$5[ebp]
  00189	83 c0 01	 add	 eax, 1
  0018c	89 45 bc	 mov	 DWORD PTR _i$5[ebp], eax
$LN7@ImFontAtla:
  0018f	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00192	8b 4d bc	 mov	 ecx, DWORD PTR _i$5[ebp]
  00195	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  00198	7d 31		 jge	 SHORT $LN6@ImFontAtla

; 2242 :         if (atlas->Fonts[i]->DirtyLookupTables)

  0019a	8b 45 bc	 mov	 eax, DWORD PTR _i$5[ebp]
  0019d	50		 push	 eax
  0019e	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  001a1	83 c1 34	 add	 ecx, 52			; 00000034H
  001a4	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  001a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ab	0f b6 51 58	 movzx	 edx, BYTE PTR [ecx+88]
  001af	85 d2		 test	 edx, edx
  001b1	74 16		 je	 SHORT $LN16@ImFontAtla

; 2243 :             atlas->Fonts[i]->BuildLookupTable();

  001b3	8b 45 bc	 mov	 eax, DWORD PTR _i$5[ebp]
  001b6	50		 push	 eax
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  001ba	83 c1 34	 add	 ecx, 52			; 00000034H
  001bd	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  001c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c4	e8 00 00 00 00	 call	 ?BuildLookupTable@ImFont@@QAEXXZ ; ImFont::BuildLookupTable
$LN16@ImFontAtla:
  001c9	eb bb		 jmp	 SHORT $LN5@ImFontAtla
$LN6@ImFontAtla:

; 2244 : 
; 2245 :     // Ellipsis character is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
; 2246 :     // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
; 2247 :     // FIXME: Also note that 0x2026 is currently seldomly included in our font ranges. Because of this we are more likely to use three individual dots.
; 2248 :     for (int i = 0; i < atlas->Fonts.size(); i++)

  001cb	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  001d2	eb 09		 jmp	 SHORT $LN10@ImFontAtla
$LN8@ImFontAtla:
  001d4	8b 45 b0	 mov	 eax, DWORD PTR _i$4[ebp]
  001d7	83 c0 01	 add	 eax, 1
  001da	89 45 b0	 mov	 DWORD PTR _i$4[ebp], eax
$LN10@ImFontAtla:
  001dd	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  001e0	83 c1 34	 add	 ecx, 52			; 00000034H
  001e3	e8 00 00 00 00	 call	 ?size@?$ImVector@PAUImFont@@@@QBEHXZ ; ImVector<ImFont *>::size
  001e8	39 45 b0	 cmp	 DWORD PTR _i$4[ebp], eax
  001eb	7d 7c		 jge	 SHORT $LN9@ImFontAtla

; 2249 :     {
; 2250 :         ImFont* font = atlas->Fonts[i];

  001ed	8b 45 b0	 mov	 eax, DWORD PTR _i$4[ebp]
  001f0	50		 push	 eax
  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  001f4	83 c1 34	 add	 ecx, 52			; 00000034H
  001f7	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  001fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fe	89 4d a4	 mov	 DWORD PTR _font$3[ebp], ecx

; 2251 :         if (font->EllipsisChar != (ImWchar)-1)

  00201	8b 45 a4	 mov	 eax, DWORD PTR _font$3[ebp]
  00204	0f b7 48 44	 movzx	 ecx, WORD PTR [eax+68]
  00208	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0020e	74 02		 je	 SHORT $LN17@ImFontAtla

; 2252 :             continue;

  00210	eb c2		 jmp	 SHORT $LN8@ImFontAtla
$LN17@ImFontAtla:

; 2253 :         const ImWchar ellipsis_variants[] = { (ImWchar)0x2026, (ImWchar)0x0085 };

  00212	b8 26 20 00 00	 mov	 eax, 8230		; 00002026H
  00217	66 89 45 98	 mov	 WORD PTR _ellipsis_variants$2[ebp], ax
  0021b	b8 85 00 00 00	 mov	 eax, 133		; 00000085H
  00220	66 89 45 9a	 mov	 WORD PTR _ellipsis_variants$2[ebp+2], ax

; 2254 :         for (int j = 0; j < IM_ARRAYSIZE(ellipsis_variants); j++)

  00224	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _j$1[ebp], 0
  0022b	eb 09		 jmp	 SHORT $LN13@ImFontAtla
$LN11@ImFontAtla:
  0022d	8b 45 8c	 mov	 eax, DWORD PTR _j$1[ebp]
  00230	83 c0 01	 add	 eax, 1
  00233	89 45 8c	 mov	 DWORD PTR _j$1[ebp], eax
$LN13@ImFontAtla:
  00236	83 7d 8c 02	 cmp	 DWORD PTR _j$1[ebp], 2
  0023a	7d 28		 jge	 SHORT $LN12@ImFontAtla

; 2255 :             if (font->FindGlyphNoFallback(ellipsis_variants[j]) != NULL) // Verify glyph exists

  0023c	8b 45 8c	 mov	 eax, DWORD PTR _j$1[ebp]
  0023f	0f b7 4c 45 98	 movzx	 ecx, WORD PTR _ellipsis_variants$2[ebp+eax*2]
  00244	51		 push	 ecx
  00245	8b 4d a4	 mov	 ecx, DWORD PTR _font$3[ebp]
  00248	e8 00 00 00 00	 call	 ?FindGlyphNoFallback@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyphNoFallback
  0024d	85 c0		 test	 eax, eax
  0024f	74 11		 je	 SHORT $LN18@ImFontAtla

; 2256 :             {
; 2257 :                 font->EllipsisChar = ellipsis_variants[j];

  00251	8b 45 a4	 mov	 eax, DWORD PTR _font$3[ebp]
  00254	8b 4d 8c	 mov	 ecx, DWORD PTR _j$1[ebp]
  00257	66 8b 54 4d 98	 mov	 dx, WORD PTR _ellipsis_variants$2[ebp+ecx*2]
  0025c	66 89 50 44	 mov	 WORD PTR [eax+68], dx

; 2258 :                 break;

  00260	eb 02		 jmp	 SHORT $LN12@ImFontAtla
$LN18@ImFontAtla:

; 2259 :             }

  00262	eb c9		 jmp	 SHORT $LN11@ImFontAtla
$LN12@ImFontAtla:

; 2260 :     }

  00264	e9 6b ff ff ff	 jmp	 $LN8@ImFontAtla
$LN9@ImFontAtla:

; 2261 : }

  00269	52		 push	 edx
  0026a	8b cd		 mov	 ecx, ebp
  0026c	50		 push	 eax
  0026d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@ImFontAtla
  00273	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00278	58		 pop	 eax
  00279	5a		 pop	 edx
  0027a	5f		 pop	 edi
  0027b	5e		 pop	 esi
  0027c	5b		 pop	 ebx
  0027d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00280	33 cd		 xor	 ecx, ebp
  00282	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00287	81 c4 38 01 00
	00		 add	 esp, 312		; 00000138H
  0028d	3b ec		 cmp	 ebp, esp
  0028f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00294	8b e5		 mov	 esp, ebp
  00296	5d		 pop	 ebp
  00297	c3		 ret	 0
$LN25@ImFontAtla:
  00298	03 00 00 00	 DD	 3
  0029c	00 00 00 00	 DD	 $LN24@ImFontAtla
$LN24@ImFontAtla:
  002a0	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002a4	08 00 00 00	 DD	 8
  002a8	00 00 00 00	 DD	 $LN21@ImFontAtla
  002ac	c8 ff ff ff	 DD	 -56			; ffffffc8H
  002b0	08 00 00 00	 DD	 8
  002b4	00 00 00 00	 DD	 $LN22@ImFontAtla
  002b8	98 ff ff ff	 DD	 -104			; ffffff98H
  002bc	04 00 00 00	 DD	 4
  002c0	00 00 00 00	 DD	 $LN23@ImFontAtla
$LN23@ImFontAtla:
  002c4	65		 DB	 101			; 00000065H
  002c5	6c		 DB	 108			; 0000006cH
  002c6	6c		 DB	 108			; 0000006cH
  002c7	69		 DB	 105			; 00000069H
  002c8	70		 DB	 112			; 00000070H
  002c9	73		 DB	 115			; 00000073H
  002ca	69		 DB	 105			; 00000069H
  002cb	73		 DB	 115			; 00000073H
  002cc	5f		 DB	 95			; 0000005fH
  002cd	76		 DB	 118			; 00000076H
  002ce	61		 DB	 97			; 00000061H
  002cf	72		 DB	 114			; 00000072H
  002d0	69		 DB	 105			; 00000069H
  002d1	61		 DB	 97			; 00000061H
  002d2	6e		 DB	 110			; 0000006eH
  002d3	74		 DB	 116			; 00000074H
  002d4	73		 DB	 115			; 00000073H
  002d5	00		 DB	 0
$LN22@ImFontAtla:
  002d6	75		 DB	 117			; 00000075H
  002d7	76		 DB	 118			; 00000076H
  002d8	31		 DB	 49			; 00000031H
  002d9	00		 DB	 0
$LN21@ImFontAtla:
  002da	75		 DB	 117			; 00000075H
  002db	76		 DB	 118			; 00000076H
  002dc	30		 DB	 48			; 00000030H
  002dd	00		 DB	 0
?ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z ENDP	; ImFontAtlasBuildFinish
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z
_TEXT	SEGMENT
_i$2 = -80						; size = 4
_i$3 = -68						; size = 4
_pack_rects$ = -56					; size = 12
_user_rects$ = -36					; size = 4
_pack_context$ = -24					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_atlas$ = 8						; size = 4
_stbrp_context_opaque$ = 12				; size = 4
?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z PROC ; ImFontAtlasBuildPackCustomRects, COMDAT

; 2165 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00020	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2166 :     stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _stbrp_context_opaque$[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR _pack_context$[ebp], eax

; 2167 :     IM_ASSERT(pack_context != NULL);

  00050	83 7d e8 00	 cmp	 DWORD PTR _pack_context$[ebp], 0
  00054	75 25		 jne	 SHORT $LN10@ImFontAtla
  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z@4JA
  0005b	83 c0 02	 add	 eax, 2
  0005e	8b f4		 mov	 esi, esp
  00060	50		 push	 eax
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	3b f4		 cmp	 esi, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@ImFontAtla:

; 2168 : 
; 2169 :     ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0007e	83 c0 40	 add	 eax, 64			; 00000040H
  00081	89 45 dc	 mov	 DWORD PTR _user_rects$[ebp], eax

; 2170 :     IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.

  00084	8b 45 dc	 mov	 eax, DWORD PTR _user_rects$[ebp]
  00087	83 38 01	 cmp	 DWORD PTR [eax], 1
  0008a	7d 26		 jge	 SHORT $LN11@ImFontAtla
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z@4JA
  00092	83 c1 05	 add	 ecx, 5
  00095	8b f4		 mov	 esi, esp
  00097	51		 push	 ecx
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	3b f4		 cmp	 esi, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@ImFontAtla:

; 2171 : 
; 2172 :     ImVector<stbrp_rect> pack_rects;

  000b2	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  000b5	e8 00 00 00 00	 call	 ??0?$ImVector@Ustbrp_rect@@@@QAE@XZ ; ImVector<stbrp_rect>::ImVector<stbrp_rect>
  000ba	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2173 :     pack_rects.resize(user_rects.Size);

  000c1	8b 45 dc	 mov	 eax, DWORD PTR _user_rects$[ebp]
  000c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c6	51		 push	 ecx
  000c7	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  000ca	e8 00 00 00 00	 call	 ?resize@?$ImVector@Ustbrp_rect@@@@QAEXH@Z ; ImVector<stbrp_rect>::resize

; 2174 :     memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());

  000cf	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  000d2	e8 00 00 00 00	 call	 ?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QBEHXZ ; ImVector<stbrp_rect>::size_in_bytes
  000d7	50		 push	 eax
  000d8	6a 00		 push	 0
  000da	8b 45 d0	 mov	 eax, DWORD PTR _pack_rects$[ebp+8]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _memset
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2175 :     for (int i = 0; i < user_rects.Size; i++)

  000e6	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  000ed	eb 09		 jmp	 SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
  000ef	8b 45 bc	 mov	 eax, DWORD PTR _i$3[ebp]
  000f2	83 c0 01	 add	 eax, 1
  000f5	89 45 bc	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@ImFontAtla:
  000f8	8b 45 dc	 mov	 eax, DWORD PTR _user_rects$[ebp]
  000fb	8b 4d bc	 mov	 ecx, DWORD PTR _i$3[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	7d 46		 jge	 SHORT $LN3@ImFontAtla

; 2176 :     {
; 2177 :         pack_rects[i].w = user_rects[i].Width;

  00102	8b 45 bc	 mov	 eax, DWORD PTR _i$3[ebp]
  00105	50		 push	 eax
  00106	8b 4d dc	 mov	 ecx, DWORD PTR _user_rects$[ebp]
  00109	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  0010e	8b f0		 mov	 esi, eax
  00110	8b 4d bc	 mov	 ecx, DWORD PTR _i$3[ebp]
  00113	51		 push	 ecx
  00114	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  00117	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  0011c	66 8b 56 04	 mov	 dx, WORD PTR [esi+4]
  00120	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 2178 :         pack_rects[i].h = user_rects[i].Height;

  00124	8b 45 bc	 mov	 eax, DWORD PTR _i$3[ebp]
  00127	50		 push	 eax
  00128	8b 4d dc	 mov	 ecx, DWORD PTR _user_rects$[ebp]
  0012b	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  00130	8b f0		 mov	 esi, eax
  00132	8b 4d bc	 mov	 ecx, DWORD PTR _i$3[ebp]
  00135	51		 push	 ecx
  00136	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  00139	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  0013e	66 8b 56 06	 mov	 dx, WORD PTR [esi+6]
  00142	66 89 50 06	 mov	 WORD PTR [eax+6], dx

; 2179 :     }

  00146	eb a7		 jmp	 SHORT $LN2@ImFontAtla
$LN3@ImFontAtla:

; 2180 :     stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);

  00148	8b 45 c8	 mov	 eax, DWORD PTR _pack_rects$[ebp]
  0014b	50		 push	 eax
  0014c	6a 00		 push	 0
  0014e	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  00151	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  00156	50		 push	 eax
  00157	8b 4d e8	 mov	 ecx, DWORD PTR _pack_context$[ebp]
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 _stbrp_pack_rects
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2181 :     for (int i = 0; i < pack_rects.Size; i++)

  00163	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0016a	eb 09		 jmp	 SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
  0016c	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  0016f	83 c0 01	 add	 eax, 1
  00172	89 45 b0	 mov	 DWORD PTR _i$2[ebp], eax
$LN7@ImFontAtla:
  00175	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  00178	3b 45 c8	 cmp	 eax, DWORD PTR _pack_rects$[ebp]
  0017b	0f 8d 04 01 00
	00		 jge	 $LN6@ImFontAtla

; 2182 :         if (pack_rects[i].was_packed)

  00181	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  00184	50		 push	 eax
  00185	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  00188	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  0018d	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00191	0f 84 e9 00 00
	00		 je	 $LN8@ImFontAtla

; 2183 :         {
; 2184 :             user_rects[i].X = pack_rects[i].x;

  00197	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  0019a	50		 push	 eax
  0019b	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  0019e	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  001a3	8b f0		 mov	 esi, eax
  001a5	8b 4d b0	 mov	 ecx, DWORD PTR _i$2[ebp]
  001a8	51		 push	 ecx
  001a9	8b 4d dc	 mov	 ecx, DWORD PTR _user_rects$[ebp]
  001ac	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  001b1	66 8b 56 08	 mov	 dx, WORD PTR [esi+8]
  001b5	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 2185 :             user_rects[i].Y = pack_rects[i].y;

  001b9	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  001bc	50		 push	 eax
  001bd	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  001c0	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  001c5	8b f0		 mov	 esi, eax
  001c7	8b 4d b0	 mov	 ecx, DWORD PTR _i$2[ebp]
  001ca	51		 push	 ecx
  001cb	8b 4d dc	 mov	 ecx, DWORD PTR _user_rects$[ebp]
  001ce	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  001d3	66 8b 56 0a	 mov	 dx, WORD PTR [esi+10]
  001d7	66 89 50 0a	 mov	 WORD PTR [eax+10], dx

; 2186 :             IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);

  001db	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  001de	50		 push	 eax
  001df	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  001e2	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  001e7	0f b7 70 04	 movzx	 esi, WORD PTR [eax+4]
  001eb	8b 4d b0	 mov	 ecx, DWORD PTR _i$2[ebp]
  001ee	51		 push	 ecx
  001ef	8b 4d dc	 mov	 ecx, DWORD PTR _user_rects$[ebp]
  001f2	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  001f7	0f b7 50 04	 movzx	 edx, WORD PTR [eax+4]
  001fb	3b f2		 cmp	 esi, edx
  001fd	75 24		 jne	 SHORT $LN12@ImFontAtla
  001ff	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  00202	50		 push	 eax
  00203	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  00206	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  0020b	0f b7 70 06	 movzx	 esi, WORD PTR [eax+6]
  0020f	8b 4d b0	 mov	 ecx, DWORD PTR _i$2[ebp]
  00212	51		 push	 ecx
  00213	8b 4d dc	 mov	 ecx, DWORD PTR _user_rects$[ebp]
  00216	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  0021b	0f b7 50 06	 movzx	 edx, WORD PTR [eax+6]
  0021f	3b f2		 cmp	 esi, edx
  00221	74 25		 je	 SHORT $LN13@ImFontAtla
$LN12@ImFontAtla:
  00223	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z@4JA
  00228	83 c0 15	 add	 eax, 21			; 00000015H
  0022b	8b f4		 mov	 esi, esp
  0022d	50		 push	 eax
  0022e	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0023e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00241	3b f4		 cmp	 esi, esp
  00243	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@ImFontAtla:

; 2187 :             atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);

  00248	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  0024b	50		 push	 eax
  0024c	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  0024f	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  00254	0f b7 70 0a	 movzx	 esi, WORD PTR [eax+10]
  00258	8b 4d b0	 mov	 ecx, DWORD PTR _i$2[ebp]
  0025b	51		 push	 ecx
  0025c	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  0025f	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  00264	0f b7 50 06	 movzx	 edx, WORD PTR [eax+6]
  00268	03 f2		 add	 esi, edx
  0026a	56		 push	 esi
  0026b	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0026e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  00277	83 c4 08	 add	 esp, 8
  0027a	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  0027d	89 42 20	 mov	 DWORD PTR [edx+32], eax
$LN8@ImFontAtla:

; 2188 :         }

  00280	e9 e7 fe ff ff	 jmp	 $LN5@ImFontAtla
$LN6@ImFontAtla:

; 2189 : }

  00285	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0028c	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  0028f	e8 00 00 00 00	 call	 ??1?$ImVector@Ustbrp_rect@@@@QAE@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
  00294	52		 push	 edx
  00295	8b cd		 mov	 ecx, ebp
  00297	50		 push	 eax
  00298	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@ImFontAtla
  0029e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002a3	58		 pop	 eax
  002a4	5a		 pop	 edx
  002a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002af	59		 pop	 ecx
  002b0	5f		 pop	 edi
  002b1	5e		 pop	 esi
  002b2	5b		 pop	 ebx
  002b3	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b6	33 cd		 xor	 ecx, ebp
  002b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bd	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  002c3	3b ec		 cmp	 ebp, esp
  002c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ca	8b e5		 mov	 esp, ebp
  002cc	5d		 pop	 ebp
  002cd	c3		 ret	 0
  002ce	66 90		 npad	 2
$LN18@ImFontAtla:
  002d0	01 00 00 00	 DD	 1
  002d4	00 00 00 00	 DD	 $LN17@ImFontAtla
$LN17@ImFontAtla:
  002d8	c8 ff ff ff	 DD	 -56			; ffffffc8H
  002dc	0c 00 00 00	 DD	 12			; 0000000cH
  002e0	00 00 00 00	 DD	 $LN15@ImFontAtla
$LN15@ImFontAtla:
  002e4	70		 DB	 112			; 00000070H
  002e5	61		 DB	 97			; 00000061H
  002e6	63		 DB	 99			; 00000063H
  002e7	6b		 DB	 107			; 0000006bH
  002e8	5f		 DB	 95			; 0000005fH
  002e9	72		 DB	 114			; 00000072H
  002ea	65		 DB	 101			; 00000065H
  002eb	63		 DB	 99			; 00000063H
  002ec	74		 DB	 116			; 00000074H
  002ed	73		 DB	 115			; 00000073H
  002ee	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _pack_rects$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbrp_rect@@@@QAE@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a e8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-280]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z ENDP ; ImFontAtlasBuildPackCustomRects
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildSetupFont@@YAXPAUImFontAtlas@@PAUImFont@@PAUImFontConfig@@MM@Z
_TEXT	SEGMENT
_atlas$ = 8						; size = 4
_font$ = 12						; size = 4
_font_config$ = 16					; size = 4
_ascent$ = 20						; size = 4
_descent$ = 24						; size = 4
?ImFontAtlasBuildSetupFont@@YAXPAUImFontAtlas@@PAUImFont@@PAUImFontConfig@@MM@Z PROC ; ImFontAtlasBuildSetupFont, COMDAT

; 2151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2152 :     if (!font_config->MergeMode)

  00028	8b 45 10	 mov	 eax, DWORD PTR _font_config$[ebp]
  0002b	0f b6 48 3c	 movzx	 ecx, BYTE PTR [eax+60]
  0002f	85 c9		 test	 ecx, ecx
  00031	75 40		 jne	 SHORT $LN2@ImFontAtla

; 2153 :     {
; 2154 :         font->ClearOutputData();

  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _font$[ebp]
  00036	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QAEXXZ ; ImFont::ClearOutputData

; 2155 :         font->FontSize = font_config->SizePixels;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _font$[ebp]
  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _font_config$[ebp]
  00041	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00044	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2156 :         font->ConfigData = font_config;

  00047	8b 45 0c	 mov	 eax, DWORD PTR _font$[ebp]
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _font_config$[ebp]
  0004d	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 2157 :         font->ContainerAtlas = atlas;

  00050	8b 45 0c	 mov	 eax, DWORD PTR _font$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00056	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 2158 :         font->Ascent = ascent;

  00059	8b 45 0c	 mov	 eax, DWORD PTR _font$[ebp]
  0005c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _ascent$[ebp]
  00061	f3 0f 11 40 4c	 movss	 DWORD PTR [eax+76], xmm0

; 2159 :         font->Descent = descent;

  00066	8b 45 0c	 mov	 eax, DWORD PTR _font$[ebp]
  00069	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _descent$[ebp]
  0006e	f3 0f 11 40 50	 movss	 DWORD PTR [eax+80], xmm0
$LN2@ImFontAtla:

; 2160 :     }
; 2161 :     font->ConfigDataCount++;

  00073	8b 45 0c	 mov	 eax, DWORD PTR _font$[ebp]
  00076	66 8b 48 40	 mov	 cx, WORD PTR [eax+64]
  0007a	66 83 c1 01	 add	 cx, 1
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _font$[ebp]
  00081	66 89 4a 40	 mov	 WORD PTR [edx+64], cx

; 2162 : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?ImFontAtlasBuildSetupFont@@YAXPAUImFontAtlas@@PAUImFont@@PAUImFontConfig@@MM@Z ENDP ; ImFontAtlasBuildSetupFont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPAUImFontAtlas@@@Z
_TEXT	SEGMENT
_atlas$ = 8						; size = 4
?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRegisterDefaultCustomRects, COMDAT

; 2141 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2142 :     if (atlas->CustomRectIds[0] >= 0)

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00033	83 7c 0a 58 00	 cmp	 DWORD PTR [edx+ecx+88], 0
  00038	7c 02		 jl	 SHORT $LN2@ImFontAtla

; 2143 :         return;

  0003a	eb 50		 jmp	 SHORT $LN1@ImFontAtla
$LN2@ImFontAtla:

; 2144 :     if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

  0003c	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	83 e1 02	 and	 ecx, 2
  00045	75 25		 jne	 SHORT $LN3@ImFontAtla

; 2145 :         atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1, FONT_ATLAS_DEFAULT_TEX_DATA_H);

  00047	6a 1b		 push	 27			; 0000001bH
  00049	68 d9 00 00 00	 push	 217			; 000000d9H
  0004e	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00056	e8 00 00 00 00	 call	 ?AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z ; ImFontAtlas::AddCustomRectRegular
  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	6b d1 00	 imul	 edx, ecx, 0
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00066	89 44 11 58	 mov	 DWORD PTR [ecx+edx+88], eax
  0006a	eb 20		 jmp	 SHORT $LN1@ImFontAtla
$LN3@ImFontAtla:

; 2146 :     else
; 2147 :         atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);

  0006c	6a 02		 push	 2
  0006e	6a 02		 push	 2
  00070	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00078	e8 00 00 00 00	 call	 ?AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z ; ImFontAtlas::AddCustomRectRegular
  0007d	b9 04 00 00 00	 mov	 ecx, 4
  00082	6b d1 00	 imul	 edx, ecx, 0
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00088	89 44 11 58	 mov	 DWORD PTR [ecx+edx+88], eax
$LN1@ImFontAtla:

; 2148 : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRegisterDefaultCustomRects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z
_TEXT	SEGMENT
tv551 = -1856						; size = 4
tv552 = -1852						; size = 4
tv1218 = -1848						; size = 4
tv808 = -1848						; size = 4
tv762 = -1848						; size = 4
tv753 = -1848						; size = 4
tv613 = -1848						; size = 4
tv553 = -1848						; size = 4
tv465 = -1848						; size = 4
tv223 = -1848						; size = 4
$T2 = -1837						; size = 1
$T3 = -1828						; size = 8
$T4 = -1809						; size = 1
$T5 = -1797						; size = 1
$T6 = -1788						; size = 8
$T7 = -1772						; size = 8
_src_i$8 = -1180					; size = 4
_dummy_y$9 = -1168					; size = 4
_dummy_x$10 = -1156					; size = 4
_q$11 = -1144						; size = 32
_char_off_x$12 = -1104					; size = 4
_char_advance_x_mod$13 = -1092				; size = 4
_char_advance_x_org$14 = -1080				; size = 4
_pc$15 = -1068						; size = 4
_codepoint$16 = -1056					; size = 4
_glyph_i$17 = -1044					; size = 4
_font_off_y$18 = -1032					; size = 4
_font_off_x$19 = -1020					; size = 4
_descent$20 = -1008					; size = 4
_ascent$21 = -996					; size = 4
_unscaled_line_gap$22 = -984				; size = 4
_unscaled_descent$23 = -972				; size = 4
_unscaled_ascent$24 = -960				; size = 4
_font_scale$25 = -948					; size = 4
_dst_font$26 = -936					; size = 4
_cfg$27 = -924						; size = 4
_src_tmp$28 = -912					; size = 4
_src_i$29 = -900					; size = 4
_glyph_i$30 = -888					; size = 4
_r$31 = -876						; size = 4
_multiply_table$32 = -864				; size = 256
_src_tmp$33 = -600					; size = 4
_cfg$34 = -588						; size = 4
_src_i$35 = -576					; size = 4
_glyph_i$36 = -564					; size = 4
_src_tmp$37 = -552					; size = 4
_src_i$38 = -540					; size = 4
_spc$ = -528						; size = 44
_TEX_HEIGHT_MAX$ = -476					; size = 4
_surface_sqrt$ = -464					; size = 4
_glyph_index_in_font$39 = -452				; size = 4
_y1$40 = -440						; size = 4
_x1$41 = -428						; size = 4
_y0$42 = -416						; size = 4
_x0$43 = -404						; size = 4
_glyph_i$44 = -392					; size = 4
_padding$45 = -380					; size = 4
_scale$46 = -368					; size = 4
_cfg$47 = -356						; size = 4
_src_tmp$48 = -344					; size = 4
_src_i$49 = -332					; size = 4
_buf_packedchars_out_n$ = -320				; size = 4
_buf_rects_out_n$ = -308				; size = 4
_total_surface$ = -296					; size = 4
_buf_packedchars$ = -284				; size = 12
_buf_rects$ = -264					; size = 12
_dst_i$50 = -244					; size = 4
_src_tmp$51 = -232					; size = 4
_src_i$52 = -220					; size = 4
_codepoint$53 = -208					; size = 4
_src_range$54 = -196					; size = 4
_dst_tmp$55 = -184					; size = 4
_src_tmp$56 = -172					; size = 4
_src_i$57 = -160					; size = 4
_total_glyphs_count$ = -148				; size = 4
_src_range$58 = -136					; size = 4
_dst_tmp$59 = -124					; size = 4
_font_offset$60 = -112					; size = 4
_output_i$61 = -100					; size = 4
_cfg$62 = -88						; size = 4
_src_tmp$63 = -76					; size = 4
_src_i$64 = -64						; size = 4
_dst_tmp_array$ = -52					; size = 12
_src_tmp_array$ = -32					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_atlas$ = 8						; size = 4
?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildWithStbTruetype, COMDAT

; 1885 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 34 07 00
	00		 sub	 esp, 1844		; 00000734H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd c0 f8 ff
	ff		 lea	 edi, DWORD PTR [ebp-1856]
  00020	b9 cd 01 00 00	 mov	 ecx, 461		; 000001cdH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1886 :     IM_ASSERT(atlas->ConfigData.Size > 0);

  0004a	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0004d	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00051	7f 26		 jg	 SHORT $LN70@ImFontAtla
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA
  00059	83 c1 01	 add	 ecx, 1
  0005c	8b f4		 mov	 esi, esp
  0005e	51		 push	 ecx
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN70@ImFontAtla:

; 1887 : 
; 1888 :     ImFontAtlasBuildRegisterDefaultCustomRects(atlas);

  00079	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRegisterDefaultCustomRects@@YAXPAUImFontAtlas@@@Z ; ImFontAtlasBuildRegisterDefaultCustomRects
  00082	83 c4 04	 add	 esp, 4

; 1889 : 
; 1890 :     // Clear atlas
; 1891 :     atlas->TexID = (ImTextureID)NULL;

  00085	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00088	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1892 :     atlas->TexWidth = atlas->TexHeight = 0;

  0008f	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00092	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  0009c	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1893 :     atlas->TexUvScale = ImVec2(0.0f, 0.0f);

  000a3	51		 push	 ecx
  000a4	0f 57 c0	 xorps	 xmm0, xmm0
  000a7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ac	51		 push	 ecx
  000ad	0f 57 c0	 xorps	 xmm0, xmm0
  000b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b5	8d 8d 14 f9 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  000bb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c5	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  000c8	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  000cb	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 1894 :     atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);

  000ce	51		 push	 ecx
  000cf	0f 57 c0	 xorps	 xmm0, xmm0
  000d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d7	51		 push	 ecx
  000d8	0f 57 c0	 xorps	 xmm0, xmm0
  000db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e0	8d 8d 04 f9 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000e6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f0	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  000f3	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  000f6	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 1895 :     atlas->ClearTexData();

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  000fc	e8 00 00 00 00	 call	 ?ClearTexData@ImFontAtlas@@QAEXXZ ; ImFontAtlas::ClearTexData

; 1896 : 
; 1897 :     // Temporary storage for building
; 1898 :     ImVector<ImFontBuildSrcData> src_tmp_array;

  00101	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00104	e8 00 00 00 00	 call	 ??0?$ImVector@UImFontBuildSrcData@@@@QAE@XZ ; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
  00109	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1899 :     ImVector<ImFontBuildDstData> dst_tmp_array;

  00110	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  00113	e8 00 00 00 00	 call	 ??0?$ImVector@UImFontBuildDstData@@@@QAE@XZ ; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
  00118	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1900 :     src_tmp_array.resize(atlas->ConfigData.Size);

  0011c	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0011f	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00122	51		 push	 ecx
  00123	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00126	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImFontBuildSrcData@@@@QAEXH@Z ; ImVector<ImFontBuildSrcData>::resize

; 1901 :     dst_tmp_array.resize(atlas->Fonts.Size);

  0012b	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0012e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00131	51		 push	 ecx
  00132	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  00135	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImFontBuildDstData@@@@QAEXH@Z ; ImVector<ImFontBuildDstData>::resize

; 1902 :     memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());

  0013a	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  0013d	e8 00 00 00 00	 call	 ?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QBEHXZ ; ImVector<ImFontBuildSrcData>::size_in_bytes
  00142	50		 push	 eax
  00143	6a 00		 push	 0
  00145	8b 45 e8	 mov	 eax, DWORD PTR _src_tmp_array$[ebp+8]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _memset
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1903 :     memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

  00151	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  00154	e8 00 00 00 00	 call	 ?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QBEHXZ ; ImVector<ImFontBuildDstData>::size_in_bytes
  00159	50		 push	 eax
  0015a	6a 00		 push	 0
  0015c	8b 45 d4	 mov	 eax, DWORD PTR _dst_tmp_array$[ebp+8]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _memset
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1904 : 
; 1905 :     // 1. Initialize font loading structure, check font data validity
; 1906 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

  00168	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _src_i$64[ebp], 0
  0016f	eb 09		 jmp	 SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
  00171	8b 45 c0	 mov	 eax, DWORD PTR _src_i$64[ebp]
  00174	83 c0 01	 add	 eax, 1
  00177	89 45 c0	 mov	 DWORD PTR _src_i$64[ebp], eax
$LN4@ImFontAtla:
  0017a	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0017d	8b 4d c0	 mov	 ecx, DWORD PTR _src_i$64[ebp]
  00180	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00183	0f 8d c1 02 00
	00		 jge	 $LN3@ImFontAtla

; 1907 :     {
; 1908 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

  00189	8b 45 c0	 mov	 eax, DWORD PTR _src_i$64[ebp]
  0018c	50		 push	 eax
  0018d	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00190	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  00195	89 45 b4	 mov	 DWORD PTR _src_tmp$63[ebp], eax

; 1909 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

  00198	8b 45 c0	 mov	 eax, DWORD PTR _src_i$64[ebp]
  0019b	50		 push	 eax
  0019c	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  0019f	83 c1 4c	 add	 ecx, 76			; 0000004cH
  001a2	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  001a7	89 45 a8	 mov	 DWORD PTR _cfg$62[ebp], eax

; 1910 :         IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

  001aa	8b 45 a8	 mov	 eax, DWORD PTR _cfg$62[ebp]
  001ad	83 78 74 00	 cmp	 DWORD PTR [eax+116], 0
  001b1	74 20		 je	 SHORT $LN72@ImFontAtla
  001b3	8b 4d a8	 mov	 ecx, DWORD PTR _cfg$62[ebp]
  001b6	8b 49 74	 mov	 ecx, DWORD PTR [ecx+116]
  001b9	e8 00 00 00 00	 call	 ?IsLoaded@ImFont@@QBE_NXZ ; ImFont::IsLoaded
  001be	0f b6 d0	 movzx	 edx, al
  001c1	85 d2		 test	 edx, edx
  001c3	74 33		 je	 SHORT $LN71@ImFontAtla
  001c5	8b 45 a8	 mov	 eax, DWORD PTR _cfg$62[ebp]
  001c8	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  001cb	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001ce	3b 55 08	 cmp	 edx, DWORD PTR _atlas$[ebp]
  001d1	74 25		 je	 SHORT $LN71@ImFontAtla
$LN72@ImFontAtla:
  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA
  001d8	83 c0 19	 add	 eax, 25			; 00000019H
  001db	8b f4		 mov	 esi, esp
  001dd	50		 push	 eax
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001e3	68 00 00 00 00	 push	 OFFSET ??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f1	3b f4		 cmp	 esi, esp
  001f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN71@ImFontAtla:

; 1911 : 
; 1912 :         // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
; 1913 :         src_tmp.DstIndex = -1;

  001f8	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  001fb	c7 80 a0 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+160], -1

; 1914 :         for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)

  00205	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _output_i$61[ebp], 0
  0020c	eb 09		 jmp	 SHORT $LN7@ImFontAtla
$LN5@ImFontAtla:
  0020e	8b 45 9c	 mov	 eax, DWORD PTR _output_i$61[ebp]
  00211	83 c0 01	 add	 eax, 1
  00214	89 45 9c	 mov	 DWORD PTR _output_i$61[ebp], eax
$LN7@ImFontAtla:
  00217	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0021a	8b 4d 9c	 mov	 ecx, DWORD PTR _output_i$61[ebp]
  0021d	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  00220	7d 33		 jge	 SHORT $LN6@ImFontAtla
  00222	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  00225	83 b8 a0 00 00
	00 ff		 cmp	 DWORD PTR [eax+160], -1
  0022c	75 27		 jne	 SHORT $LN6@ImFontAtla

; 1915 :             if (cfg.DstFont == atlas->Fonts[output_i])

  0022e	8b 45 9c	 mov	 eax, DWORD PTR _output_i$61[ebp]
  00231	50		 push	 eax
  00232	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00235	83 c1 34	 add	 ecx, 52			; 00000034H
  00238	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  0023d	8b 4d a8	 mov	 ecx, DWORD PTR _cfg$62[ebp]
  00240	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00243	3b 10		 cmp	 edx, DWORD PTR [eax]
  00245	75 0c		 jne	 SHORT $LN53@ImFontAtla

; 1916 :                 src_tmp.DstIndex = output_i;

  00247	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  0024a	8b 4d 9c	 mov	 ecx, DWORD PTR _output_i$61[ebp]
  0024d	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx
$LN53@ImFontAtla:
  00253	eb b9		 jmp	 SHORT $LN5@ImFontAtla
$LN6@ImFontAtla:

; 1917 :         IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?

  00255	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  00258	83 b8 a0 00 00
	00 ff		 cmp	 DWORD PTR [eax+160], -1
  0025f	75 26		 jne	 SHORT $LN73@ImFontAtla
  00261	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA
  00267	83 c1 20	 add	 ecx, 32			; 00000020H
  0026a	8b f4		 mov	 esi, esp
  0026c	51		 push	 ecx
  0026d	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00272	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0027d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00280	3b f4		 cmp	 esi, esp
  00282	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN73@ImFontAtla:

; 1918 :         if (src_tmp.DstIndex == -1)

  00287	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  0028a	83 b8 a0 00 00
	00 ff		 cmp	 DWORD PTR [eax+160], -1
  00291	75 2d		 jne	 SHORT $LN54@ImFontAtla

; 1919 :             return false;

  00293	c6 85 fb f8 ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
  0029a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0029e	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  002a1	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
  002a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002ad	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  002b0	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
  002b5	8a 85 fb f8 ff
	ff		 mov	 al, BYTE PTR $T5[ebp]
  002bb	e9 be 12 00 00	 jmp	 $LN1@ImFontAtla
$LN54@ImFontAtla:

; 1920 : 
; 1921 :         // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
; 1922 :         const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);

  002c0	8b 45 a8	 mov	 eax, DWORD PTR _cfg$62[ebp]
  002c3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002c6	51		 push	 ecx
  002c7	8b 55 a8	 mov	 edx, DWORD PTR _cfg$62[ebp]
  002ca	8b 02		 mov	 eax, DWORD PTR [edx]
  002cc	50		 push	 eax
  002cd	e8 00 00 00 00	 call	 _stbtt_GetFontOffsetForIndex
  002d2	83 c4 08	 add	 esp, 8
  002d5	89 45 90	 mov	 DWORD PTR _font_offset$60[ebp], eax

; 1923 :         IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");

  002d8	83 7d 90 00	 cmp	 DWORD PTR _font_offset$60[ebp], 0
  002dc	7c 09		 jl	 SHORT $LN74@ImFontAtla
  002de	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DC@IFELKFNN@FontData?5is?5incorrect?0?5or?5FontN@
  002e3	85 c0		 test	 eax, eax
  002e5	75 26		 jne	 SHORT $LN75@ImFontAtla
$LN74@ImFontAtla:
  002e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA
  002ed	83 c1 26	 add	 ecx, 38			; 00000026H
  002f0	8b f4		 mov	 esi, esp
  002f2	51		 push	 ecx
  002f3	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00303	83 c4 0c	 add	 esp, 12			; 0000000cH
  00306	3b f4		 cmp	 esi, esp
  00308	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN75@ImFontAtla:

; 1924 :         if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))

  0030d	8b 45 90	 mov	 eax, DWORD PTR _font_offset$60[ebp]
  00310	50		 push	 eax
  00311	8b 4d a8	 mov	 ecx, DWORD PTR _cfg$62[ebp]
  00314	8b 11		 mov	 edx, DWORD PTR [ecx]
  00316	52		 push	 edx
  00317	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 _stbtt_InitFont
  00320	83 c4 0c	 add	 esp, 12			; 0000000cH
  00323	85 c0		 test	 eax, eax
  00325	75 2d		 jne	 SHORT $LN55@ImFontAtla

; 1925 :             return false;

  00327	c6 85 ef f8 ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
  0032e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00332	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  00335	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
  0033a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00341	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00344	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
  00349	8a 85 ef f8 ff
	ff		 mov	 al, BYTE PTR $T4[ebp]
  0034f	e9 2a 12 00 00	 jmp	 $LN1@ImFontAtla
$LN55@ImFontAtla:

; 1926 : 
; 1927 :         // Measure highest codepoints
; 1928 :         ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];

  00354	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  00357	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0035d	51		 push	 ecx
  0035e	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  00361	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildDstData@@@@QAEAAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
  00366	89 45 84	 mov	 DWORD PTR _dst_tmp$59[ebp], eax

; 1929 :         src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();

  00369	8b 45 a8	 mov	 eax, DWORD PTR _cfg$62[ebp]
  0036c	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00370	74 0e		 je	 SHORT $LN76@ImFontAtla
  00372	8b 4d a8	 mov	 ecx, DWORD PTR _cfg$62[ebp]
  00375	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00378	89 95 c8 f8 ff
	ff		 mov	 DWORD PTR tv223[ebp], edx
  0037e	eb 0e		 jmp	 SHORT $LN77@ImFontAtla
$LN76@ImFontAtla:
  00380	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00383	e8 00 00 00 00	 call	 ?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesDefault
  00388	89 85 c8 f8 ff
	ff		 mov	 DWORD PTR tv223[ebp], eax
$LN77@ImFontAtla:
  0038e	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  00391	8b 8d c8 f8 ff
	ff		 mov	 ecx, DWORD PTR tv223[ebp]
  00397	89 88 9c 00 00
	00		 mov	 DWORD PTR [eax+156], ecx

; 1930 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

  0039d	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  003a0	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  003a6	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _src_range$58[ebp], ecx
  003ac	eb 0f		 jmp	 SHORT $LN10@ImFontAtla
$LN8@ImFontAtla:
  003ae	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _src_range$58[ebp]
  003b4	83 c0 04	 add	 eax, 4
  003b7	89 85 78 ff ff
	ff		 mov	 DWORD PTR _src_range$58[ebp], eax
$LN10@ImFontAtla:
  003bd	b8 02 00 00 00	 mov	 eax, 2
  003c2	6b c8 00	 imul	 ecx, eax, 0
  003c5	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _src_range$58[ebp]
  003cb	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  003cf	85 c0		 test	 eax, eax
  003d1	74 46		 je	 SHORT $LN9@ImFontAtla
  003d3	b8 02 00 00 00	 mov	 eax, 2
  003d8	c1 e0 00	 shl	 eax, 0
  003db	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _src_range$58[ebp]
  003e1	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  003e5	85 d2		 test	 edx, edx
  003e7	74 30		 je	 SHORT $LN9@ImFontAtla

; 1931 :             src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);

  003e9	b8 02 00 00 00	 mov	 eax, 2
  003ee	c1 e0 00	 shl	 eax, 0
  003f1	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _src_range$58[ebp]
  003f7	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  003fb	52		 push	 edx
  003fc	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  003ff	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00405	51		 push	 ecx
  00406	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  0040b	83 c4 08	 add	 esp, 8
  0040e	8b 55 b4	 mov	 edx, DWORD PTR _src_tmp$63[ebp]
  00411	89 82 a4 00 00
	00		 mov	 DWORD PTR [edx+164], eax
  00417	eb 95		 jmp	 SHORT $LN8@ImFontAtla
$LN9@ImFontAtla:

; 1932 :         dst_tmp.SrcCount++;

  00419	8b 45 84	 mov	 eax, DWORD PTR _dst_tmp$59[ebp]
  0041c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0041e	83 c1 01	 add	 ecx, 1
  00421	8b 55 84	 mov	 edx, DWORD PTR _dst_tmp$59[ebp]
  00424	89 0a		 mov	 DWORD PTR [edx], ecx

; 1933 :         dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);

  00426	8b 45 b4	 mov	 eax, DWORD PTR _src_tmp$63[ebp]
  00429	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0042f	51		 push	 ecx
  00430	8b 55 84	 mov	 edx, DWORD PTR _dst_tmp$59[ebp]
  00433	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00436	50		 push	 eax
  00437	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  0043c	83 c4 08	 add	 esp, 8
  0043f	8b 4d 84	 mov	 ecx, DWORD PTR _dst_tmp$59[ebp]
  00442	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1934 :     }

  00445	e9 27 fd ff ff	 jmp	 $LN2@ImFontAtla
$LN3@ImFontAtla:

; 1935 : 
; 1936 :     // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
; 1937 :     int total_glyphs_count = 0;

  0044a	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _total_glyphs_count$[ebp], 0

; 1938 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00454	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _src_i$57[ebp], 0
  0045e	eb 0f		 jmp	 SHORT $LN13@ImFontAtla
$LN11@ImFontAtla:
  00460	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _src_i$57[ebp]
  00466	83 c0 01	 add	 eax, 1
  00469	89 85 60 ff ff
	ff		 mov	 DWORD PTR _src_i$57[ebp], eax
$LN13@ImFontAtla:
  0046f	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _src_i$57[ebp]
  00475	3b 45 e0	 cmp	 eax, DWORD PTR _src_tmp_array$[ebp]
  00478	0f 8d d8 01 00
	00		 jge	 $LN12@ImFontAtla

; 1939 :     {
; 1940 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

  0047e	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _src_i$57[ebp]
  00484	50		 push	 eax
  00485	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00488	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  0048d	89 85 54 ff ff
	ff		 mov	 DWORD PTR _src_tmp$56[ebp], eax

; 1941 :         ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];

  00493	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _src_tmp$56[ebp]
  00499	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0049f	51		 push	 ecx
  004a0	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  004a3	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildDstData@@@@QAEAAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
  004a8	89 85 48 ff ff
	ff		 mov	 DWORD PTR _dst_tmp$55[ebp], eax

; 1942 :         src_tmp.GlyphsSet.Resize(src_tmp.GlyphsHighest + 1);

  004ae	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _src_tmp$56[ebp]
  004b4	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  004ba	83 c1 01	 add	 ecx, 1
  004bd	51		 push	 ecx
  004be	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$56[ebp]
  004c4	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  004ca	e8 00 00 00 00	 call	 ?Resize@ImBoolVector@@QAEXH@Z ; ImBoolVector::Resize

; 1943 :         if (dst_tmp.GlyphsSet.Storage.empty())

  004cf	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$55[ebp]
  004d5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  004d8	e8 00 00 00 00	 call	 ?empty@?$ImVector@H@@QBE_NXZ ; ImVector<int>::empty
  004dd	0f b6 c0	 movzx	 eax, al
  004e0	85 c0		 test	 eax, eax
  004e2	74 1b		 je	 SHORT $LN56@ImFontAtla

; 1944 :             dst_tmp.GlyphsSet.Resize(dst_tmp.GlyphsHighest + 1);

  004e4	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$55[ebp]
  004ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004ed	83 c1 01	 add	 ecx, 1
  004f0	51		 push	 ecx
  004f1	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$55[ebp]
  004f7	83 c1 0c	 add	 ecx, 12			; 0000000cH
  004fa	e8 00 00 00 00	 call	 ?Resize@ImBoolVector@@QAEXH@Z ; ImBoolVector::Resize
$LN56@ImFontAtla:

; 1945 : 
; 1946 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

  004ff	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _src_tmp$56[ebp]
  00505	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  0050b	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _src_range$54[ebp], ecx
  00511	eb 0f		 jmp	 SHORT $LN16@ImFontAtla
$LN14@ImFontAtla:
  00513	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _src_range$54[ebp]
  00519	83 c0 04	 add	 eax, 4
  0051c	89 85 3c ff ff
	ff		 mov	 DWORD PTR _src_range$54[ebp], eax
$LN16@ImFontAtla:
  00522	b8 02 00 00 00	 mov	 eax, 2
  00527	6b c8 00	 imul	 ecx, eax, 0
  0052a	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _src_range$54[ebp]
  00530	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00534	85 c0		 test	 eax, eax
  00536	0f 84 15 01 00
	00		 je	 $LN15@ImFontAtla
  0053c	b8 02 00 00 00	 mov	 eax, 2
  00541	c1 e0 00	 shl	 eax, 0
  00544	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _src_range$54[ebp]
  0054a	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0054e	85 d2		 test	 edx, edx
  00550	0f 84 fb 00 00
	00		 je	 $LN15@ImFontAtla

; 1947 :             for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)

  00556	b8 02 00 00 00	 mov	 eax, 2
  0055b	6b c8 00	 imul	 ecx, eax, 0
  0055e	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _src_range$54[ebp]
  00564	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00568	89 85 30 ff ff
	ff		 mov	 DWORD PTR _codepoint$53[ebp], eax
  0056e	eb 0f		 jmp	 SHORT $LN19@ImFontAtla
$LN17@ImFontAtla:
  00570	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _codepoint$53[ebp]
  00576	83 c0 01	 add	 eax, 1
  00579	89 85 30 ff ff
	ff		 mov	 DWORD PTR _codepoint$53[ebp], eax
$LN19@ImFontAtla:
  0057f	b8 02 00 00 00	 mov	 eax, 2
  00584	c1 e0 00	 shl	 eax, 0
  00587	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _src_range$54[ebp]
  0058d	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00591	39 95 30 ff ff
	ff		 cmp	 DWORD PTR _codepoint$53[ebp], edx
  00597	0f 87 af 00 00
	00		 ja	 $LN18@ImFontAtla

; 1948 :             {
; 1949 :                 if (dst_tmp.GlyphsSet.GetBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)

  0059d	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _codepoint$53[ebp]
  005a3	50		 push	 eax
  005a4	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$55[ebp]
  005aa	83 c1 0c	 add	 ecx, 12			; 0000000cH
  005ad	e8 00 00 00 00	 call	 ?GetBit@ImBoolVector@@QBE_NH@Z ; ImBoolVector::GetBit
  005b2	0f b6 c8	 movzx	 ecx, al
  005b5	85 c9		 test	 ecx, ecx
  005b7	74 02		 je	 SHORT $LN57@ImFontAtla

; 1950 :                     continue;

  005b9	eb b5		 jmp	 SHORT $LN17@ImFontAtla
$LN57@ImFontAtla:

; 1951 :                 if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?

  005bb	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _codepoint$53[ebp]
  005c1	50		 push	 eax
  005c2	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$56[ebp]
  005c8	51		 push	 ecx
  005c9	e8 00 00 00 00	 call	 _stbtt_FindGlyphIndex
  005ce	83 c4 08	 add	 esp, 8
  005d1	85 c0		 test	 eax, eax
  005d3	75 02		 jne	 SHORT $LN58@ImFontAtla

; 1952 :                     continue;

  005d5	eb 99		 jmp	 SHORT $LN17@ImFontAtla
$LN58@ImFontAtla:

; 1953 : 
; 1954 :                 // Add to avail set/counters
; 1955 :                 src_tmp.GlyphsCount++;

  005d7	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _src_tmp$56[ebp]
  005dd	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  005e3	83 c1 01	 add	 ecx, 1
  005e6	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _src_tmp$56[ebp]
  005ec	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 1956 :                 dst_tmp.GlyphsCount++;

  005f2	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _dst_tmp$55[ebp]
  005f8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005fb	83 c1 01	 add	 ecx, 1
  005fe	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _dst_tmp$55[ebp]
  00604	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1957 :                 src_tmp.GlyphsSet.SetBit(codepoint, true);

  00607	6a 01		 push	 1
  00609	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _codepoint$53[ebp]
  0060f	50		 push	 eax
  00610	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$56[ebp]
  00616	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  0061c	e8 00 00 00 00	 call	 ?SetBit@ImBoolVector@@QAEXH_N@Z ; ImBoolVector::SetBit

; 1958 :                 dst_tmp.GlyphsSet.SetBit(codepoint, true);

  00621	6a 01		 push	 1
  00623	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _codepoint$53[ebp]
  00629	50		 push	 eax
  0062a	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _dst_tmp$55[ebp]
  00630	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00633	e8 00 00 00 00	 call	 ?SetBit@ImBoolVector@@QAEXH_N@Z ; ImBoolVector::SetBit

; 1959 :                 total_glyphs_count++;

  00638	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _total_glyphs_count$[ebp]
  0063e	83 c0 01	 add	 eax, 1
  00641	89 85 6c ff ff
	ff		 mov	 DWORD PTR _total_glyphs_count$[ebp], eax

; 1960 :             }

  00647	e9 24 ff ff ff	 jmp	 $LN17@ImFontAtla
$LN18@ImFontAtla:
  0064c	e9 c2 fe ff ff	 jmp	 $LN14@ImFontAtla
$LN15@ImFontAtla:

; 1961 :     }

  00651	e9 0a fe ff ff	 jmp	 $LN11@ImFontAtla
$LN12@ImFontAtla:

; 1962 : 
; 1963 :     // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
; 1964 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00656	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _src_i$52[ebp], 0
  00660	eb 0f		 jmp	 SHORT $LN22@ImFontAtla
$LN20@ImFontAtla:
  00662	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _src_i$52[ebp]
  00668	83 c0 01	 add	 eax, 1
  0066b	89 85 24 ff ff
	ff		 mov	 DWORD PTR _src_i$52[ebp], eax
$LN22@ImFontAtla:
  00671	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _src_i$52[ebp]
  00677	3b 45 e0	 cmp	 eax, DWORD PTR _src_tmp_array$[ebp]
  0067a	0f 8d a9 00 00
	00		 jge	 $LN21@ImFontAtla

; 1965 :     {
; 1966 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

  00680	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _src_i$52[ebp]
  00686	50		 push	 eax
  00687	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  0068a	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  0068f	89 85 18 ff ff
	ff		 mov	 DWORD PTR _src_tmp$51[ebp], eax

; 1967 :         src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);

  00695	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _src_tmp$51[ebp]
  0069b	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  006a1	51		 push	 ecx
  006a2	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$51[ebp]
  006a8	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  006ae	e8 00 00 00 00	 call	 ?reserve@?$ImVector@H@@QAEXH@Z ; ImVector<int>::reserve

; 1968 :         UnpackBoolVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);

  006b3	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _src_tmp$51[ebp]
  006b9	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  006be	50		 push	 eax
  006bf	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$51[ebp]
  006c5	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  006cb	51		 push	 ecx
  006cc	e8 00 00 00 00	 call	 ?UnpackBoolVectorToFlatIndexList@@YAXPBUImBoolVector@@PAU?$ImVector@H@@@Z ; UnpackBoolVectorToFlatIndexList
  006d1	83 c4 08	 add	 esp, 8

; 1969 :         src_tmp.GlyphsSet.Clear();

  006d4	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$51[ebp]
  006da	81 c1 ac 00 00
	00		 add	 ecx, 172		; 000000acH
  006e0	e8 00 00 00 00	 call	 ?Clear@ImBoolVector@@QAEXXZ ; ImBoolVector::Clear

; 1970 :         IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);

  006e5	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _src_tmp$51[ebp]
  006eb	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$51[ebp]
  006f1	8b 90 b8 00 00
	00		 mov	 edx, DWORD PTR [eax+184]
  006f7	3b 91 a8 00 00
	00		 cmp	 edx, DWORD PTR [ecx+168]
  006fd	74 25		 je	 SHORT $LN78@ImFontAtla
  006ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA
  00704	83 c0 55	 add	 eax, 85			; 00000055H
  00707	8b f4		 mov	 esi, esp
  00709	50		 push	 eax
  0070a	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0070f	68 00 00 00 00	 push	 OFFSET ??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@
  00714	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0071a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0071d	3b f4		 cmp	 esi, esp
  0071f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN78@ImFontAtla:

; 1971 :     }

  00724	e9 39 ff ff ff	 jmp	 $LN20@ImFontAtla
$LN21@ImFontAtla:

; 1972 :     for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)

  00729	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dst_i$50[ebp], 0
  00733	eb 0f		 jmp	 SHORT $LN25@ImFontAtla
$LN23@ImFontAtla:
  00735	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _dst_i$50[ebp]
  0073b	83 c0 01	 add	 eax, 1
  0073e	89 85 0c ff ff
	ff		 mov	 DWORD PTR _dst_i$50[ebp], eax
$LN25@ImFontAtla:
  00744	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _dst_i$50[ebp]
  0074a	3b 45 cc	 cmp	 eax, DWORD PTR _dst_tmp_array$[ebp]
  0074d	7d 1b		 jge	 SHORT $LN24@ImFontAtla

; 1973 :         dst_tmp_array[dst_i].GlyphsSet.Clear();

  0074f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _dst_i$50[ebp]
  00755	50		 push	 eax
  00756	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  00759	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildDstData@@@@QAEAAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
  0075e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00761	8b c8		 mov	 ecx, eax
  00763	e8 00 00 00 00	 call	 ?Clear@ImBoolVector@@QAEXXZ ; ImBoolVector::Clear
  00768	eb cb		 jmp	 SHORT $LN23@ImFontAtla
$LN24@ImFontAtla:

; 1974 :     dst_tmp_array.clear();

  0076a	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  0076d	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImFontBuildDstData@@@@QAEXXZ ; ImVector<ImFontBuildDstData>::clear

; 1975 : 
; 1976 :     // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
; 1977 :     // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
; 1978 :     ImVector<stbrp_rect> buf_rects;

  00772	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_rects$[ebp]
  00778	e8 00 00 00 00	 call	 ??0?$ImVector@Ustbrp_rect@@@@QAE@XZ ; ImVector<stbrp_rect>::ImVector<stbrp_rect>
  0077d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1979 :     ImVector<stbtt_packedchar> buf_packedchars;

  00781	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_packedchars$[ebp]
  00787	e8 00 00 00 00	 call	 ??0?$ImVector@Ustbtt_packedchar@@@@QAE@XZ ; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
  0078c	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1980 :     buf_rects.resize(total_glyphs_count);

  00790	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _total_glyphs_count$[ebp]
  00796	50		 push	 eax
  00797	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_rects$[ebp]
  0079d	e8 00 00 00 00	 call	 ?resize@?$ImVector@Ustbrp_rect@@@@QAEXH@Z ; ImVector<stbrp_rect>::resize

; 1981 :     buf_packedchars.resize(total_glyphs_count);

  007a2	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _total_glyphs_count$[ebp]
  007a8	50		 push	 eax
  007a9	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_packedchars$[ebp]
  007af	e8 00 00 00 00	 call	 ?resize@?$ImVector@Ustbtt_packedchar@@@@QAEXH@Z ; ImVector<stbtt_packedchar>::resize

; 1982 :     memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());

  007b4	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_rects$[ebp]
  007ba	e8 00 00 00 00	 call	 ?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QBEHXZ ; ImVector<stbrp_rect>::size_in_bytes
  007bf	50		 push	 eax
  007c0	6a 00		 push	 0
  007c2	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _buf_rects$[ebp+8]
  007c8	50		 push	 eax
  007c9	e8 00 00 00 00	 call	 _memset
  007ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1983 :     memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

  007d1	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_packedchars$[ebp]
  007d7	e8 00 00 00 00	 call	 ?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QBEHXZ ; ImVector<stbtt_packedchar>::size_in_bytes
  007dc	50		 push	 eax
  007dd	6a 00		 push	 0
  007df	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _buf_packedchars$[ebp+8]
  007e5	50		 push	 eax
  007e6	e8 00 00 00 00	 call	 _memset
  007eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1984 : 
; 1985 :     // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
; 1986 :     int total_surface = 0;

  007ee	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _total_surface$[ebp], 0

; 1987 :     int buf_rects_out_n = 0;

  007f8	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _buf_rects_out_n$[ebp], 0

; 1988 :     int buf_packedchars_out_n = 0;

  00802	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _buf_packedchars_out_n$[ebp], 0

; 1989 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  0080c	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _src_i$49[ebp], 0
  00816	eb 0f		 jmp	 SHORT $LN28@ImFontAtla
$LN26@ImFontAtla:
  00818	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _src_i$49[ebp]
  0081e	83 c0 01	 add	 eax, 1
  00821	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _src_i$49[ebp], eax
$LN28@ImFontAtla:
  00827	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _src_i$49[ebp]
  0082d	3b 45 e0	 cmp	 eax, DWORD PTR _src_tmp_array$[ebp]
  00830	0f 8d 8b 03 00
	00		 jge	 $LN27@ImFontAtla

; 1990 :     {
; 1991 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

  00836	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _src_i$49[ebp]
  0083c	50		 push	 eax
  0083d	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00840	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  00845	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _src_tmp$48[ebp], eax

; 1992 :         if (src_tmp.GlyphsCount == 0)

  0084b	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  00851	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00858	75 02		 jne	 SHORT $LN59@ImFontAtla

; 1993 :             continue;

  0085a	eb bc		 jmp	 SHORT $LN26@ImFontAtla
$LN59@ImFontAtla:

; 1994 : 
; 1995 :         src_tmp.Rects = &buf_rects[buf_rects_out_n];

  0085c	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _buf_rects_out_n$[ebp]
  00862	50		 push	 eax
  00863	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_rects$[ebp]
  00869	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
  0086e	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  00874	89 81 94 00 00
	00		 mov	 DWORD PTR [ecx+148], eax

; 1996 :         src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];

  0087a	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _buf_packedchars_out_n$[ebp]
  00880	50		 push	 eax
  00881	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_packedchars$[ebp]
  00887	e8 00 00 00 00	 call	 ??A?$ImVector@Ustbtt_packedchar@@@@QAEAAUstbtt_packedchar@@H@Z ; ImVector<stbtt_packedchar>::operator[]
  0088c	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  00892	89 81 98 00 00
	00		 mov	 DWORD PTR [ecx+152], eax

; 1997 :         buf_rects_out_n += src_tmp.GlyphsCount;

  00898	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  0089e	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _buf_rects_out_n$[ebp]
  008a4	03 88 a8 00 00
	00		 add	 ecx, DWORD PTR [eax+168]
  008aa	89 8d cc fe ff
	ff		 mov	 DWORD PTR _buf_rects_out_n$[ebp], ecx

; 1998 :         buf_packedchars_out_n += src_tmp.GlyphsCount;

  008b0	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  008b6	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _buf_packedchars_out_n$[ebp]
  008bc	03 88 a8 00 00
	00		 add	 ecx, DWORD PTR [eax+168]
  008c2	89 8d c0 fe ff
	ff		 mov	 DWORD PTR _buf_packedchars_out_n$[ebp], ecx

; 1999 : 
; 2000 :         // Convert our ranges in the format stb_truetype wants
; 2001 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

  008c8	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _src_i$49[ebp]
  008ce	50		 push	 eax
  008cf	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  008d2	83 c1 4c	 add	 ecx, 76			; 0000004cH
  008d5	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  008da	89 85 9c fe ff
	ff		 mov	 DWORD PTR _cfg$47[ebp], eax

; 2002 :         src_tmp.PackRange.font_size = cfg.SizePixels;

  008e0	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  008e6	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _cfg$47[ebp]
  008ec	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  008ef	89 50 7c	 mov	 DWORD PTR [eax+124], edx

; 2003 :         src_tmp.PackRange.first_unicode_codepoint_in_range = 0;

  008f2	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  008f8	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+128], 0

; 2004 :         src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;

  00902	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  00908	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  0090e	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00914	89 90 84 00 00
	00		 mov	 DWORD PTR [eax+132], edx

; 2005 :         src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;

  0091a	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  00920	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  00926	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  0092c	89 90 88 00 00
	00		 mov	 DWORD PTR [eax+136], edx

; 2006 :         src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;

  00932	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  00938	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  0093e	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00944	89 90 8c 00 00
	00		 mov	 DWORD PTR [eax+140], edx

; 2007 :         src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;

  0094a	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  00950	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _cfg$47[ebp]
  00956	8a 51 14	 mov	 dl, BYTE PTR [ecx+20]
  00959	88 90 90 00 00
	00		 mov	 BYTE PTR [eax+144], dl

; 2008 :         src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

  0095f	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  00965	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _cfg$47[ebp]
  0096b	8a 51 18	 mov	 dl, BYTE PTR [ecx+24]
  0096e	88 90 91 00 00
	00		 mov	 BYTE PTR [eax+145], dl

; 2009 : 
; 2010 :         // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
; 2011 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

  00974	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _cfg$47[ebp]
  0097a	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0097f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00986	76 28		 jbe	 SHORT $LN79@ImFontAtla
  00988	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _cfg$47[ebp]
  0098e	51		 push	 ecx
  0098f	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  00994	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00999	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _src_tmp$48[ebp]
  0099f	52		 push	 edx
  009a0	e8 00 00 00 00	 call	 _stbtt_ScaleForPixelHeight
  009a5	83 c4 08	 add	 esp, 8
  009a8	d9 9d c8 f8 ff
	ff		 fstp	 DWORD PTR tv465[ebp]
  009ae	eb 2d		 jmp	 SHORT $LN80@ImFontAtla
$LN79@ImFontAtla:
  009b0	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _cfg$47[ebp]
  009b6	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  009bb	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  009c2	51		 push	 ecx
  009c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009c8	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  009ce	51		 push	 ecx
  009cf	e8 00 00 00 00	 call	 _stbtt_ScaleForMappingEmToPixels
  009d4	83 c4 08	 add	 esp, 8
  009d7	d9 9d c8 f8 ff
	ff		 fstp	 DWORD PTR tv465[ebp]
$LN80@ImFontAtla:
  009dd	f3 0f 10 85 c8
	f8 ff ff	 movss	 xmm0, DWORD PTR tv465[ebp]
  009e5	f3 0f 11 85 90
	fe ff ff	 movss	 DWORD PTR _scale$46[ebp], xmm0

; 2012 :         const int padding = atlas->TexGlyphPadding;

  009ed	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  009f0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  009f3	89 8d 84 fe ff
	ff		 mov	 DWORD PTR _padding$45[ebp], ecx

; 2013 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)

  009f9	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _glyph_i$44[ebp], 0
  00a03	eb 0f		 jmp	 SHORT $LN31@ImFontAtla
$LN29@ImFontAtla:
  00a05	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _glyph_i$44[ebp]
  00a0b	83 c0 01	 add	 eax, 1
  00a0e	89 85 78 fe ff
	ff		 mov	 DWORD PTR _glyph_i$44[ebp], eax
$LN31@ImFontAtla:
  00a14	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _src_tmp$48[ebp]
  00a1a	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$44[ebp]
  00a20	3b 88 b8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+184]
  00a26	0f 8d 90 01 00
	00		 jge	 $LN30@ImFontAtla

; 2014 :         {
; 2015 :             int x0, y0, x1, y1;
; 2016 :             const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);

  00a2c	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _glyph_i$44[ebp]
  00a32	50		 push	 eax
  00a33	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  00a39	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00a3f	e8 00 00 00 00	 call	 ??A?$ImVector@H@@QAEAAHH@Z ; ImVector<int>::operator[]
  00a44	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a46	51		 push	 ecx
  00a47	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _src_tmp$48[ebp]
  00a4d	52		 push	 edx
  00a4e	e8 00 00 00 00	 call	 _stbtt_FindGlyphIndex
  00a53	83 c4 08	 add	 esp, 8
  00a56	89 85 3c fe ff
	ff		 mov	 DWORD PTR _glyph_index_in_font$39[ebp], eax

; 2017 :             IM_ASSERT(glyph_index_in_font != 0);

  00a5c	83 bd 3c fe ff
	ff 00		 cmp	 DWORD PTR _glyph_index_in_font$39[ebp], 0
  00a63	75 27		 jne	 SHORT $LN81@ImFontAtla
  00a65	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z@4JA
  00a6a	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00a6f	8b f4		 mov	 esi, esp
  00a71	50		 push	 eax
  00a72	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00a77	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@
  00a7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00a82	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a85	3b f4		 cmp	 esi, esp
  00a87	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN81@ImFontAtla:

; 2018 :             stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);

  00a8c	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR _y1$40[ebp]
  00a92	50		 push	 eax
  00a93	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _x1$41[ebp]
  00a99	51		 push	 ecx
  00a9a	8d 95 60 fe ff
	ff		 lea	 edx, DWORD PTR _y0$42[ebp]
  00aa0	52		 push	 edx
  00aa1	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _x0$43[ebp]
  00aa7	50		 push	 eax
  00aa8	51		 push	 ecx
  00aa9	0f 57 c0	 xorps	 xmm0, xmm0
  00aac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ab1	51		 push	 ecx
  00ab2	0f 57 c0	 xorps	 xmm0, xmm0
  00ab5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aba	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _cfg$47[ebp]
  00ac0	f3 0f 2a 41 18	 cvtsi2ss xmm0, DWORD PTR [ecx+24]
  00ac5	f3 0f 59 85 90
	fe ff ff	 mulss	 xmm0, DWORD PTR _scale$46[ebp]
  00acd	51		 push	 ecx
  00ace	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ad3	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR _cfg$47[ebp]
  00ad9	f3 0f 2a 42 14	 cvtsi2ss xmm0, DWORD PTR [edx+20]
  00ade	f3 0f 59 85 90
	fe ff ff	 mulss	 xmm0, DWORD PTR _scale$46[ebp]
  00ae6	51		 push	 ecx
  00ae7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aec	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR _glyph_index_in_font$39[ebp]
  00af2	50		 push	 eax
  00af3	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  00af9	51		 push	 ecx
  00afa	e8 00 00 00 00	 call	 _stbtt_GetGlyphBitmapBoxSubpixel
  00aff	83 c4 28	 add	 esp, 40			; 00000028H

; 2019 :             src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);

  00b02	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _x1$41[ebp]
  00b08	2b 85 6c fe ff
	ff		 sub	 eax, DWORD PTR _x0$43[ebp]
  00b0e	03 85 84 fe ff
	ff		 add	 eax, DWORD PTR _padding$45[ebp]
  00b14	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _cfg$47[ebp]
  00b1a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00b1d	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  00b21	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$44[ebp]
  00b27	c1 e1 04	 shl	 ecx, 4
  00b2a	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _src_tmp$48[ebp]
  00b30	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [edx+148]
  00b36	66 89 44 0a 04	 mov	 WORD PTR [edx+ecx+4], ax

; 2020 :             src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);

  00b3b	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR _y1$40[ebp]
  00b41	2b 85 60 fe ff
	ff		 sub	 eax, DWORD PTR _y0$42[ebp]
  00b47	03 85 84 fe ff
	ff		 add	 eax, DWORD PTR _padding$45[ebp]
  00b4d	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR _cfg$47[ebp]
  00b53	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00b56	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  00b5a	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$44[ebp]
  00b60	c1 e1 04	 shl	 ecx, 4
  00b63	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _src_tmp$48[ebp]
  00b69	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [edx+148]
  00b6f	66 89 44 0a 06	 mov	 WORD PTR [edx+ecx+6], ax

; 2021 :             total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;

  00b74	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _glyph_i$44[ebp]
  00b7a	c1 e0 04	 shl	 eax, 4
  00b7d	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$48[ebp]
  00b83	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00b89	0f b7 44 02 04	 movzx	 eax, WORD PTR [edx+eax+4]
  00b8e	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$44[ebp]
  00b94	c1 e1 04	 shl	 ecx, 4
  00b97	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _src_tmp$48[ebp]
  00b9d	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [edx+148]
  00ba3	0f b7 4c 0a 06	 movzx	 ecx, WORD PTR [edx+ecx+6]
  00ba8	0f af c1	 imul	 eax, ecx
  00bab	03 85 d8 fe ff
	ff		 add	 eax, DWORD PTR _total_surface$[ebp]
  00bb1	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _total_surface$[ebp], eax

; 2022 :         }

  00bb7	e9 49 fe ff ff	 jmp	 $LN29@ImFontAtla
$LN30@ImFontAtla:

; 2023 :     }

  00bbc	e9 57 fc ff ff	 jmp	 $LN26@ImFontAtla
$LN27@ImFontAtla:

; 2024 : 
; 2025 :     // We need a width for the skyline algorithm, any width!
; 2026 :     // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
; 2027 :     // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
; 2028 :     const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;

  00bc1	f3 0f 2a 85 d8
	fe ff ff	 cvtsi2ss xmm0, DWORD PTR _total_surface$[ebp]
  00bc9	51		 push	 ecx
  00bca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bcf	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  00bd4	83 c4 04	 add	 esp, 4
  00bd7	d9 9d c8 f8 ff
	ff		 fstp	 DWORD PTR tv1218[ebp]
  00bdd	f3 0f 10 85 c8
	f8 ff ff	 movss	 xmm0, DWORD PTR tv1218[ebp]
  00be5	f3 0f 2c c0	 cvttss2si eax, xmm0
  00be9	83 c0 01	 add	 eax, 1
  00bec	89 85 30 fe ff
	ff		 mov	 DWORD PTR _surface_sqrt$[ebp], eax

; 2029 :     atlas->TexHeight = 0;

  00bf2	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00bf5	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2030 :     if (atlas->TexDesiredWidth > 0)

  00bfc	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00bff	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00c03	7e 11		 jle	 SHORT $LN60@ImFontAtla

; 2031 :         atlas->TexWidth = atlas->TexDesiredWidth;

  00c05	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00c08	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00c0b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00c0e	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  00c11	e9 85 00 00 00	 jmp	 $LN61@ImFontAtla
$LN60@ImFontAtla:

; 2032 :     else
; 2033 :         atlas->TexWidth = (surface_sqrt >= 4096*0.7f) ? 4096 : (surface_sqrt >= 2048*0.7f) ? 2048 : (surface_sqrt >= 1024*0.7f) ? 1024 : 512;

  00c16	f3 0f 2a 85 30
	fe ff ff	 cvtsi2ss xmm0, DWORD PTR _surface_sqrt$[ebp]
  00c1e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@45333333
  00c25	72 0c		 jb	 SHORT $LN86@ImFontAtla
  00c27	c7 85 c8 f8 ff
	ff 00 10 00 00	 mov	 DWORD PTR tv553[ebp], 4096 ; 00001000H
  00c31	eb 5c		 jmp	 SHORT $LN87@ImFontAtla
$LN86@ImFontAtla:
  00c33	f3 0f 2a 85 30
	fe ff ff	 cvtsi2ss xmm0, DWORD PTR _surface_sqrt$[ebp]
  00c3b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@44b33333
  00c42	72 0c		 jb	 SHORT $LN84@ImFontAtla
  00c44	c7 85 c4 f8 ff
	ff 00 08 00 00	 mov	 DWORD PTR tv552[ebp], 2048 ; 00000800H
  00c4e	eb 33		 jmp	 SHORT $LN85@ImFontAtla
$LN84@ImFontAtla:
  00c50	f3 0f 2a 85 30
	fe ff ff	 cvtsi2ss xmm0, DWORD PTR _surface_sqrt$[ebp]
  00c58	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@44333333
  00c5f	72 0c		 jb	 SHORT $LN82@ImFontAtla
  00c61	c7 85 c0 f8 ff
	ff 00 04 00 00	 mov	 DWORD PTR tv551[ebp], 1024 ; 00000400H
  00c6b	eb 0a		 jmp	 SHORT $LN83@ImFontAtla
$LN82@ImFontAtla:
  00c6d	c7 85 c0 f8 ff
	ff 00 02 00 00	 mov	 DWORD PTR tv551[ebp], 512 ; 00000200H
$LN83@ImFontAtla:
  00c77	8b 85 c0 f8 ff
	ff		 mov	 eax, DWORD PTR tv551[ebp]
  00c7d	89 85 c4 f8 ff
	ff		 mov	 DWORD PTR tv552[ebp], eax
$LN85@ImFontAtla:
  00c83	8b 8d c4 f8 ff
	ff		 mov	 ecx, DWORD PTR tv552[ebp]
  00c89	89 8d c8 f8 ff
	ff		 mov	 DWORD PTR tv553[ebp], ecx
$LN87@ImFontAtla:
  00c8f	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00c92	8b 85 c8 f8 ff
	ff		 mov	 eax, DWORD PTR tv553[ebp]
  00c98	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN61@ImFontAtla:

; 2034 : 
; 2035 :     // 5. Start packing
; 2036 :     // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
; 2037 :     const int TEX_HEIGHT_MAX = 1024 * 32;

  00c9b	c7 85 24 fe ff
	ff 00 80 00 00	 mov	 DWORD PTR _TEX_HEIGHT_MAX$[ebp], 32768 ; 00008000H

; 2038 :     stbtt_pack_context spc = {};

  00ca5	6a 2c		 push	 44			; 0000002cH
  00ca7	6a 00		 push	 0
  00ca9	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _spc$[ebp]
  00caf	50		 push	 eax
  00cb0	e8 00 00 00 00	 call	 _memset
  00cb5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2039 :     stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);

  00cb8	6a 00		 push	 0
  00cba	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00cbd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00cc0	51		 push	 ecx
  00cc1	6a 00		 push	 0
  00cc3	68 00 80 00 00	 push	 32768			; 00008000H
  00cc8	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00ccb	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00cce	50		 push	 eax
  00ccf	6a 00		 push	 0
  00cd1	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _spc$[ebp]
  00cd7	51		 push	 ecx
  00cd8	e8 00 00 00 00	 call	 _stbtt_PackBegin
  00cdd	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2040 :     ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

  00ce0	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _spc$[ebp+4]
  00ce6	50		 push	 eax
  00ce7	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00cea	51		 push	 ecx
  00ceb	e8 00 00 00 00	 call	 ?ImFontAtlasBuildPackCustomRects@@YAXPAUImFontAtlas@@PAX@Z ; ImFontAtlasBuildPackCustomRects
  00cf0	83 c4 08	 add	 esp, 8

; 2041 : 
; 2042 :     // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
; 2043 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00cf3	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _src_i$38[ebp], 0
  00cfd	eb 0f		 jmp	 SHORT $LN34@ImFontAtla
$LN32@ImFontAtla:
  00cff	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _src_i$38[ebp]
  00d05	83 c0 01	 add	 eax, 1
  00d08	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _src_i$38[ebp], eax
$LN34@ImFontAtla:
  00d0e	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _src_i$38[ebp]
  00d14	3b 45 e0	 cmp	 eax, DWORD PTR _src_tmp_array$[ebp]
  00d17	0f 8d f0 00 00
	00		 jge	 $LN33@ImFontAtla

; 2044 :     {
; 2045 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

  00d1d	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _src_i$38[ebp]
  00d23	50		 push	 eax
  00d24	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00d27	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  00d2c	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _src_tmp$37[ebp], eax

; 2046 :         if (src_tmp.GlyphsCount == 0)

  00d32	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$37[ebp]
  00d38	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00d3f	75 02		 jne	 SHORT $LN62@ImFontAtla

; 2047 :             continue;

  00d41	eb bc		 jmp	 SHORT $LN32@ImFontAtla
$LN62@ImFontAtla:

; 2048 : 
; 2049 :         stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

  00d43	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$37[ebp]
  00d49	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00d4f	51		 push	 ecx
  00d50	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _src_tmp$37[ebp]
  00d56	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [edx+148]
  00d5c	50		 push	 eax
  00d5d	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR _spc$[ebp+4]
  00d63	51		 push	 ecx
  00d64	e8 00 00 00 00	 call	 _stbrp_pack_rects
  00d69	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2050 : 
; 2051 :         // Extend texture height and mark missing glyphs as non-packed so we won't render them.
; 2052 :         // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
; 2053 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

  00d6c	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _glyph_i$36[ebp], 0
  00d76	eb 0f		 jmp	 SHORT $LN37@ImFontAtla
$LN35@ImFontAtla:
  00d78	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _glyph_i$36[ebp]
  00d7e	83 c0 01	 add	 eax, 1
  00d81	89 85 cc fd ff
	ff		 mov	 DWORD PTR _glyph_i$36[ebp], eax
$LN37@ImFontAtla:
  00d87	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$37[ebp]
  00d8d	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$36[ebp]
  00d93	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  00d99	7d 6d		 jge	 SHORT $LN36@ImFontAtla

; 2054 :             if (src_tmp.Rects[glyph_i].was_packed)

  00d9b	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _glyph_i$36[ebp]
  00da1	c1 e0 04	 shl	 eax, 4
  00da4	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$37[ebp]
  00daa	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00db0	83 7c 02 0c 00	 cmp	 DWORD PTR [edx+eax+12], 0
  00db5	74 4c		 je	 SHORT $LN63@ImFontAtla

; 2055 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

  00db7	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _glyph_i$36[ebp]
  00dbd	c1 e0 04	 shl	 eax, 4
  00dc0	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$37[ebp]
  00dc6	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00dcc	0f b7 44 02 0a	 movzx	 eax, WORD PTR [edx+eax+10]
  00dd1	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$36[ebp]
  00dd7	c1 e1 04	 shl	 ecx, 4
  00dda	8b 95 d8 fd ff
	ff		 mov	 edx, DWORD PTR _src_tmp$37[ebp]
  00de0	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [edx+148]
  00de6	0f b7 4c 0a 06	 movzx	 ecx, WORD PTR [edx+ecx+6]
  00deb	03 c1		 add	 eax, ecx
  00ded	50		 push	 eax
  00dee	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00df1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00df4	50		 push	 eax
  00df5	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  00dfa	83 c4 08	 add	 esp, 8
  00dfd	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00e00	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN63@ImFontAtla:
  00e03	e9 70 ff ff ff	 jmp	 $LN35@ImFontAtla
$LN36@ImFontAtla:

; 2056 :     }

  00e08	e9 f2 fe ff ff	 jmp	 $LN32@ImFontAtla
$LN33@ImFontAtla:

; 2057 : 
; 2058 :     // 7. Allocate texture
; 2059 :     atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);

  00e0d	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00e10	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00e13	83 e1 01	 and	 ecx, 1
  00e16	74 11		 je	 SHORT $LN88@ImFontAtla
  00e18	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  00e1b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00e1e	83 c0 01	 add	 eax, 1
  00e21	89 85 c8 f8 ff
	ff		 mov	 DWORD PTR tv613[ebp], eax
  00e27	eb 15		 jmp	 SHORT $LN89@ImFontAtla
$LN88@ImFontAtla:
  00e29	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00e2c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00e2f	52		 push	 edx
  00e30	e8 00 00 00 00	 call	 ?ImUpperPowerOfTwo@@YAHH@Z ; ImUpperPowerOfTwo
  00e35	83 c4 04	 add	 esp, 4
  00e38	89 85 c8 f8 ff
	ff		 mov	 DWORD PTR tv613[ebp], eax
$LN89@ImFontAtla:
  00e3e	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00e41	8b 8d c8 f8 ff
	ff		 mov	 ecx, DWORD PTR tv613[ebp]
  00e47	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 2060 :     atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);

  00e4a	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00e4d	f3 0f 2a 40 20	 cvtsi2ss xmm0, DWORD PTR [eax+32]
  00e52	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00e5a	f3 0f 5e c8	 divss	 xmm1, xmm0
  00e5e	51		 push	 ecx
  00e5f	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00e64	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00e67	f3 0f 2a 41 1c	 cvtsi2ss xmm0, DWORD PTR [ecx+28]
  00e6c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00e74	f3 0f 5e c8	 divss	 xmm1, xmm0
  00e78	51		 push	 ecx
  00e79	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00e7e	8d 8d dc f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00e84	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00e89	8b 10		 mov	 edx, DWORD PTR [eax]
  00e8b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00e8e	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00e91	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00e94	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 2061 :     atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);

  00e97	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00e9a	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00e9d	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00ea0	0f af 51 20	 imul	 edx, DWORD PTR [ecx+32]
  00ea4	52		 push	 edx
  00ea5	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00eaa	83 c4 04	 add	 esp, 4
  00ead	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00eb0	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 2062 :     memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);

  00eb3	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00eb6	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00eb9	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00ebc	0f af 51 20	 imul	 edx, DWORD PTR [ecx+32]
  00ec0	52		 push	 edx
  00ec1	6a 00		 push	 0
  00ec3	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00ec6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00ec9	51		 push	 ecx
  00eca	e8 00 00 00 00	 call	 _memset
  00ecf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2063 :     spc.pixels = atlas->TexPixelsAlpha8;

  00ed2	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00ed5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00ed8	89 8d 14 fe ff
	ff		 mov	 DWORD PTR _spc$[ebp+36], ecx

; 2064 :     spc.height = atlas->TexHeight;

  00ede	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  00ee1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00ee4	89 8d fc fd ff
	ff		 mov	 DWORD PTR _spc$[ebp+12], ecx

; 2065 : 
; 2066 :     // 8. Render/rasterize font characters into the texture
; 2067 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00eea	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _src_i$35[ebp], 0
  00ef4	eb 0f		 jmp	 SHORT $LN40@ImFontAtla
$LN38@ImFontAtla:
  00ef6	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_i$35[ebp]
  00efc	83 c0 01	 add	 eax, 1
  00eff	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _src_i$35[ebp], eax
$LN40@ImFontAtla:
  00f05	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_i$35[ebp]
  00f0b	3b 45 e0	 cmp	 eax, DWORD PTR _src_tmp_array$[ebp]
  00f0e	0f 8d 70 01 00
	00		 jge	 $LN39@ImFontAtla

; 2068 :     {
; 2069 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

  00f14	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_i$35[ebp]
  00f1a	50		 push	 eax
  00f1b	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  00f1e	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00f21	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  00f26	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _cfg$34[ebp], eax

; 2070 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

  00f2c	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _src_i$35[ebp]
  00f32	50		 push	 eax
  00f33	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00f36	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  00f3b	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _src_tmp$33[ebp], eax

; 2071 :         if (src_tmp.GlyphsCount == 0)

  00f41	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$33[ebp]
  00f47	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00f4e	75 02		 jne	 SHORT $LN64@ImFontAtla

; 2072 :             continue;

  00f50	eb a4		 jmp	 SHORT $LN38@ImFontAtla
$LN64@ImFontAtla:

; 2073 : 
; 2074 :         stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

  00f52	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$33[ebp]
  00f58	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00f5e	51		 push	 ecx
  00f5f	6a 01		 push	 1
  00f61	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _src_tmp$33[ebp]
  00f67	83 c2 7c	 add	 edx, 124		; 0000007cH
  00f6a	52		 push	 edx
  00f6b	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$33[ebp]
  00f71	50		 push	 eax
  00f72	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _spc$[ebp]
  00f78	51		 push	 ecx
  00f79	e8 00 00 00 00	 call	 _stbtt_PackFontRangesRenderIntoRects
  00f7e	83 c4 14	 add	 esp, 20			; 00000014H

; 2075 : 
; 2076 :         // Apply multiply operator
; 2077 :         if (cfg.RasterizerMultiply != 1.0f)

  00f81	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _cfg$34[ebp]
  00f87	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  00f8c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  00f93	9f		 lahf
  00f94	f6 c4 44	 test	 ah, 68			; 00000044H
  00f97	0f 8b d2 00 00
	00		 jnp	 $LN42@ImFontAtla

; 2078 :         {
; 2079 :             unsigned char multiply_table[256];
; 2080 :             ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);

  00f9d	8b 85 b4 fd ff
	ff		 mov	 eax, DWORD PTR _cfg$34[ebp]
  00fa3	51		 push	 ecx
  00fa4	f3 0f 10 40 44	 movss	 xmm0, DWORD PTR [eax+68]
  00fa9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fae	8d 8d a0 fc ff
	ff		 lea	 ecx, DWORD PTR _multiply_table$32[ebp]
  00fb4	51		 push	 ecx
  00fb5	e8 00 00 00 00	 call	 ?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQAEM@Z ; ImFontAtlasBuildMultiplyCalcLookupTable
  00fba	83 c4 08	 add	 esp, 8

; 2081 :             stbrp_rect* r = &src_tmp.Rects[0];

  00fbd	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00fc2	6b c8 00	 imul	 ecx, eax, 0
  00fc5	8b 95 a8 fd ff
	ff		 mov	 edx, DWORD PTR _src_tmp$33[ebp]
  00fcb	03 8a 94 00 00
	00		 add	 ecx, DWORD PTR [edx+148]
  00fd1	89 8d 94 fc ff
	ff		 mov	 DWORD PTR _r$31[ebp], ecx

; 2082 :             for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)

  00fd7	c7 85 88 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _glyph_i$30[ebp], 0
  00fe1	eb 1e		 jmp	 SHORT $LN43@ImFontAtla
$LN41@ImFontAtla:
  00fe3	8b 85 88 fc ff
	ff		 mov	 eax, DWORD PTR _glyph_i$30[ebp]
  00fe9	83 c0 01	 add	 eax, 1
  00fec	89 85 88 fc ff
	ff		 mov	 DWORD PTR _glyph_i$30[ebp], eax
  00ff2	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR _r$31[ebp]
  00ff8	83 c1 10	 add	 ecx, 16			; 00000010H
  00ffb	89 8d 94 fc ff
	ff		 mov	 DWORD PTR _r$31[ebp], ecx
$LN43@ImFontAtla:
  01001	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$33[ebp]
  01007	8b 8d 88 fc ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$30[ebp]
  0100d	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  01013	7d 5a		 jge	 SHORT $LN42@ImFontAtla

; 2083 :                 if (r->was_packed)

  01015	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR _r$31[ebp]
  0101b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0101f	74 49		 je	 SHORT $LN66@ImFontAtla

; 2084 :                     ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);

  01021	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  01024	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01027	51		 push	 ecx
  01028	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR _r$31[ebp]
  0102e	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  01032	50		 push	 eax
  01033	8b 8d 94 fc ff
	ff		 mov	 ecx, DWORD PTR _r$31[ebp]
  01039	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  0103d	52		 push	 edx
  0103e	8b 85 94 fc ff
	ff		 mov	 eax, DWORD PTR _r$31[ebp]
  01044	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  01048	51		 push	 ecx
  01049	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR _r$31[ebp]
  0104f	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  01053	50		 push	 eax
  01054	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  01057	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0105a	52		 push	 edx
  0105b	8d 85 a0 fc ff
	ff		 lea	 eax, DWORD PTR _multiply_table$32[ebp]
  01061	50		 push	 eax
  01062	e8 00 00 00 00	 call	 ?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQBEPAEHHHHH@Z ; ImFontAtlasBuildMultiplyRectAlpha8
  01067	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN66@ImFontAtla:
  0106a	e9 74 ff ff ff	 jmp	 $LN41@ImFontAtla
$LN42@ImFontAtla:

; 2085 :         }
; 2086 :         src_tmp.Rects = NULL;

  0106f	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _src_tmp$33[ebp]
  01075	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+148], 0

; 2087 :     }

  0107f	e9 72 fe ff ff	 jmp	 $LN38@ImFontAtla
$LN39@ImFontAtla:

; 2088 : 
; 2089 :     // End packing
; 2090 :     stbtt_PackEnd(&spc);

  01084	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _spc$[ebp]
  0108a	50		 push	 eax
  0108b	e8 00 00 00 00	 call	 _stbtt_PackEnd
  01090	83 c4 04	 add	 esp, 4

; 2091 :     buf_rects.clear();

  01093	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_rects$[ebp]
  01099	e8 00 00 00 00	 call	 ?clear@?$ImVector@Ustbrp_rect@@@@QAEXXZ ; ImVector<stbrp_rect>::clear

; 2092 : 
; 2093 :     // 9. Setup ImFont and glyphs for runtime
; 2094 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  0109e	c7 85 7c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _src_i$29[ebp], 0
  010a8	eb 0f		 jmp	 SHORT $LN46@ImFontAtla
$LN44@ImFontAtla:
  010aa	8b 85 7c fc ff
	ff		 mov	 eax, DWORD PTR _src_i$29[ebp]
  010b0	83 c0 01	 add	 eax, 1
  010b3	89 85 7c fc ff
	ff		 mov	 DWORD PTR _src_i$29[ebp], eax
$LN46@ImFontAtla:
  010b9	8b 85 7c fc ff
	ff		 mov	 eax, DWORD PTR _src_i$29[ebp]
  010bf	3b 45 e0	 cmp	 eax, DWORD PTR _src_tmp_array$[ebp]
  010c2	0f 8d 24 04 00
	00		 jge	 $LN45@ImFontAtla

; 2095 :     {
; 2096 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];

  010c8	8b 85 7c fc ff
	ff		 mov	 eax, DWORD PTR _src_i$29[ebp]
  010ce	50		 push	 eax
  010cf	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  010d2	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  010d7	89 85 70 fc ff
	ff		 mov	 DWORD PTR _src_tmp$28[ebp], eax

; 2097 :         if (src_tmp.GlyphsCount == 0)

  010dd	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _src_tmp$28[ebp]
  010e3	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  010ea	75 02		 jne	 SHORT $LN67@ImFontAtla

; 2098 :             continue;

  010ec	eb bc		 jmp	 SHORT $LN44@ImFontAtla
$LN67@ImFontAtla:

; 2099 : 
; 2100 :         ImFontConfig& cfg = atlas->ConfigData[src_i];

  010ee	8b 85 7c fc ff
	ff		 mov	 eax, DWORD PTR _src_i$29[ebp]
  010f4	50		 push	 eax
  010f5	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  010f8	83 c1 4c	 add	 ecx, 76			; 0000004cH
  010fb	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  01100	89 85 64 fc ff
	ff		 mov	 DWORD PTR _cfg$27[ebp], eax

; 2101 :         ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)

  01106	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _cfg$27[ebp]
  0110c	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0110f	89 8d 58 fc ff
	ff		 mov	 DWORD PTR _dst_font$26[ebp], ecx

; 2102 : 
; 2103 :         const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);

  01115	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _cfg$27[ebp]
  0111b	51		 push	 ecx
  0111c	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  01121	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01126	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$28[ebp]
  0112c	51		 push	 ecx
  0112d	e8 00 00 00 00	 call	 _stbtt_ScaleForPixelHeight
  01132	83 c4 08	 add	 esp, 8
  01135	d9 9d 4c fc ff
	ff		 fstp	 DWORD PTR _font_scale$25[ebp]

; 2104 :         int unscaled_ascent, unscaled_descent, unscaled_line_gap;
; 2105 :         stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

  0113b	8d 85 28 fc ff
	ff		 lea	 eax, DWORD PTR _unscaled_line_gap$22[ebp]
  01141	50		 push	 eax
  01142	8d 8d 34 fc ff
	ff		 lea	 ecx, DWORD PTR _unscaled_descent$23[ebp]
  01148	51		 push	 ecx
  01149	8d 95 40 fc ff
	ff		 lea	 edx, DWORD PTR _unscaled_ascent$24[ebp]
  0114f	52		 push	 edx
  01150	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _src_tmp$28[ebp]
  01156	50		 push	 eax
  01157	e8 00 00 00 00	 call	 _stbtt_GetFontVMetrics
  0115c	83 c4 10	 add	 esp, 16			; 00000010H

; 2106 : 
; 2107 :         const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));

  0115f	f3 0f 2a 85 40
	fc ff ff	 cvtsi2ss xmm0, DWORD PTR _unscaled_ascent$24[ebp]
  01167	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0116e	76 0c		 jbe	 SHORT $LN90@ImFontAtla
  01170	c7 85 c8 f8 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv753[ebp], 1
  0117a	eb 0a		 jmp	 SHORT $LN91@ImFontAtla
$LN90@ImFontAtla:
  0117c	c7 85 c8 f8 ff
	ff ff ff ff ff	 mov	 DWORD PTR tv753[ebp], -1
$LN91@ImFontAtla:
  01186	f3 0f 2a 85 40
	fc ff ff	 cvtsi2ss xmm0, DWORD PTR _unscaled_ascent$24[ebp]
  0118e	f3 0f 59 85 4c
	fc ff ff	 mulss	 xmm0, DWORD PTR _font_scale$25[ebp]
  01196	f3 0f 2a 8d c8
	f8 ff ff	 cvtsi2ss xmm1, DWORD PTR tv753[ebp]
  0119e	f3 0f 58 c1	 addss	 xmm0, xmm1
  011a2	51		 push	 ecx
  011a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011a8	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  011ad	83 c4 04	 add	 esp, 4
  011b0	d9 9d 1c fc ff
	ff		 fstp	 DWORD PTR _ascent$21[ebp]

; 2108 :         const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));

  011b6	f3 0f 2a 85 34
	fc ff ff	 cvtsi2ss xmm0, DWORD PTR _unscaled_descent$23[ebp]
  011be	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  011c5	76 0c		 jbe	 SHORT $LN92@ImFontAtla
  011c7	c7 85 c8 f8 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv762[ebp], 1
  011d1	eb 0a		 jmp	 SHORT $LN93@ImFontAtla
$LN92@ImFontAtla:
  011d3	c7 85 c8 f8 ff
	ff ff ff ff ff	 mov	 DWORD PTR tv762[ebp], -1
$LN93@ImFontAtla:
  011dd	f3 0f 2a 85 34
	fc ff ff	 cvtsi2ss xmm0, DWORD PTR _unscaled_descent$23[ebp]
  011e5	f3 0f 59 85 4c
	fc ff ff	 mulss	 xmm0, DWORD PTR _font_scale$25[ebp]
  011ed	f3 0f 2a 8d c8
	f8 ff ff	 cvtsi2ss xmm1, DWORD PTR tv762[ebp]
  011f5	f3 0f 58 c1	 addss	 xmm0, xmm1
  011f9	51		 push	 ecx
  011fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011ff	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  01204	83 c4 04	 add	 esp, 4
  01207	d9 9d 10 fc ff
	ff		 fstp	 DWORD PTR _descent$20[ebp]

; 2109 :         ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);

  0120d	51		 push	 ecx
  0120e	f3 0f 10 85 10
	fc ff ff	 movss	 xmm0, DWORD PTR _descent$20[ebp]
  01216	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0121b	51		 push	 ecx
  0121c	f3 0f 10 85 1c
	fc ff ff	 movss	 xmm0, DWORD PTR _ascent$21[ebp]
  01224	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01229	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _cfg$27[ebp]
  0122f	50		 push	 eax
  01230	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR _dst_font$26[ebp]
  01236	51		 push	 ecx
  01237	8b 55 08	 mov	 edx, DWORD PTR _atlas$[ebp]
  0123a	52		 push	 edx
  0123b	e8 00 00 00 00	 call	 ?ImFontAtlasBuildSetupFont@@YAXPAUImFontAtlas@@PAUImFont@@PAUImFontConfig@@MM@Z ; ImFontAtlasBuildSetupFont
  01240	83 c4 14	 add	 esp, 20			; 00000014H

; 2110 :         const float font_off_x = cfg.GlyphOffset.x;

  01243	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _cfg$27[ebp]
  01249	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  0124e	f3 0f 11 85 04
	fc ff ff	 movss	 DWORD PTR _font_off_x$19[ebp], xmm0

; 2111 :         const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);

  01256	8b 85 58 fc ff
	ff		 mov	 eax, DWORD PTR _dst_font$26[ebp]
  0125c	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [eax+76]
  01261	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  01269	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0126d	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  01271	8b 95 64 fc ff
	ff		 mov	 edx, DWORD PTR _cfg$27[ebp]
  01277	f3 0f 58 42 2c	 addss	 xmm0, DWORD PTR [edx+44]
  0127c	f3 0f 11 85 f8
	fb ff ff	 movss	 DWORD PTR _font_off_y$18[ebp], xmm0

; 2112 : 
; 2113 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

  01284	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _glyph_i$17[ebp], 0
  0128e	eb 0f		 jmp	 SHORT $LN49@ImFontAtla
$LN47@ImFontAtla:
  01290	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _glyph_i$17[ebp]
  01296	83 c0 01	 add	 eax, 1
  01299	89 85 ec fb ff
	ff		 mov	 DWORD PTR _glyph_i$17[ebp], eax
$LN49@ImFontAtla:
  0129f	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _src_tmp$28[ebp]
  012a5	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _glyph_i$17[ebp]
  012ab	3b 88 a8 00 00
	00		 cmp	 ecx, DWORD PTR [eax+168]
  012b1	0f 8d 30 02 00
	00		 jge	 $LN48@ImFontAtla

; 2114 :         {
; 2115 :             const int codepoint = src_tmp.GlyphsList[glyph_i];

  012b7	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _glyph_i$17[ebp]
  012bd	50		 push	 eax
  012be	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$28[ebp]
  012c4	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  012ca	e8 00 00 00 00	 call	 ??A?$ImVector@H@@QAEAAHH@Z ; ImVector<int>::operator[]
  012cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  012d1	89 8d e0 fb ff
	ff		 mov	 DWORD PTR _codepoint$16[ebp], ecx

; 2116 :             const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];

  012d7	6b 85 ec fb ff
	ff 1c		 imul	 eax, DWORD PTR _glyph_i$17[ebp], 28
  012de	8b 8d 70 fc ff
	ff		 mov	 ecx, DWORD PTR _src_tmp$28[ebp]
  012e4	03 81 98 00 00
	00		 add	 eax, DWORD PTR [ecx+152]
  012ea	89 85 d4 fb ff
	ff		 mov	 DWORD PTR _pc$15[ebp], eax

; 2117 : 
; 2118 :             const float char_advance_x_org = pc.xadvance;

  012f0	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _pc$15[ebp]
  012f6	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  012fb	f3 0f 11 85 c8
	fb ff ff	 movss	 DWORD PTR _char_advance_x_org$14[ebp], xmm0

; 2119 :             const float char_advance_x_mod = ImClamp(char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX);

  01303	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _cfg$27[ebp]
  01309	51		 push	 ecx
  0130a	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  0130f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01314	8b 8d 64 fc ff
	ff		 mov	 ecx, DWORD PTR _cfg$27[ebp]
  0131a	51		 push	 ecx
  0131b	f3 0f 10 41 34	 movss	 xmm0, DWORD PTR [ecx+52]
  01320	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01325	51		 push	 ecx
  01326	f3 0f 10 85 c8
	fb ff ff	 movss	 xmm0, DWORD PTR _char_advance_x_org$14[ebp]
  0132e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01333	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  01338	83 c4 0c	 add	 esp, 12			; 0000000cH
  0133b	d9 9d bc fb ff
	ff		 fstp	 DWORD PTR _char_advance_x_mod$13[ebp]

; 2120 :             float char_off_x = font_off_x;

  01341	f3 0f 10 85 04
	fc ff ff	 movss	 xmm0, DWORD PTR _font_off_x$19[ebp]
  01349	f3 0f 11 85 b0
	fb ff ff	 movss	 DWORD PTR _char_off_x$12[ebp], xmm0

; 2121 :             if (char_advance_x_org != char_advance_x_mod)

  01351	f3 0f 10 85 c8
	fb ff ff	 movss	 xmm0, DWORD PTR _char_advance_x_org$14[ebp]
  01359	0f 2e 85 bc fb
	ff ff		 ucomiss xmm0, DWORD PTR _char_advance_x_mod$13[ebp]
  01360	9f		 lahf
  01361	f6 c4 44	 test	 ah, 68			; 00000044H
  01364	7b 74		 jnp	 SHORT $LN68@ImFontAtla

; 2122 :                 char_off_x += cfg.PixelSnapH ? ImFloor((char_advance_x_mod - char_advance_x_org) * 0.5f) : (char_advance_x_mod - char_advance_x_org) * 0.5f;

  01366	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _cfg$27[ebp]
  0136c	0f b6 48 1c	 movzx	 ecx, BYTE PTR [eax+28]
  01370	85 c9		 test	 ecx, ecx
  01372	74 2e		 je	 SHORT $LN94@ImFontAtla
  01374	f3 0f 10 85 bc
	fb ff ff	 movss	 xmm0, DWORD PTR _char_advance_x_mod$13[ebp]
  0137c	f3 0f 5c 85 c8
	fb ff ff	 subss	 xmm0, DWORD PTR _char_advance_x_org$14[ebp]
  01384	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0138c	51		 push	 ecx
  0138d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01392	e8 00 00 00 00	 call	 ?ImFloor@@YAMM@Z	; ImFloor
  01397	83 c4 04	 add	 esp, 4
  0139a	d9 9d c8 f8 ff
	ff		 fstp	 DWORD PTR tv808[ebp]
  013a0	eb 20		 jmp	 SHORT $LN95@ImFontAtla
$LN94@ImFontAtla:
  013a2	f3 0f 10 85 bc
	fb ff ff	 movss	 xmm0, DWORD PTR _char_advance_x_mod$13[ebp]
  013aa	f3 0f 5c 85 c8
	fb ff ff	 subss	 xmm0, DWORD PTR _char_advance_x_org$14[ebp]
  013b2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  013ba	f3 0f 11 85 c8
	f8 ff ff	 movss	 DWORD PTR tv808[ebp], xmm0
$LN95@ImFontAtla:
  013c2	f3 0f 10 85 b0
	fb ff ff	 movss	 xmm0, DWORD PTR _char_off_x$12[ebp]
  013ca	f3 0f 58 85 c8
	f8 ff ff	 addss	 xmm0, DWORD PTR tv808[ebp]
  013d2	f3 0f 11 85 b0
	fb ff ff	 movss	 DWORD PTR _char_off_x$12[ebp], xmm0
$LN68@ImFontAtla:

; 2123 : 
; 2124 :             // Register glyph
; 2125 :             stbtt_aligned_quad q;
; 2126 :             float dummy_x = 0.0f, dummy_y = 0.0f;

  013da	0f 57 c0	 xorps	 xmm0, xmm0
  013dd	f3 0f 11 85 7c
	fb ff ff	 movss	 DWORD PTR _dummy_x$10[ebp], xmm0
  013e5	0f 57 c0	 xorps	 xmm0, xmm0
  013e8	f3 0f 11 85 70
	fb ff ff	 movss	 DWORD PTR _dummy_y$9[ebp], xmm0

; 2127 :             stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &dummy_x, &dummy_y, &q, 0);

  013f0	6a 00		 push	 0
  013f2	8d 85 88 fb ff
	ff		 lea	 eax, DWORD PTR _q$11[ebp]
  013f8	50		 push	 eax
  013f9	8d 8d 70 fb ff
	ff		 lea	 ecx, DWORD PTR _dummy_y$9[ebp]
  013ff	51		 push	 ecx
  01400	8d 95 7c fb ff
	ff		 lea	 edx, DWORD PTR _dummy_x$10[ebp]
  01406	52		 push	 edx
  01407	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _glyph_i$17[ebp]
  0140d	50		 push	 eax
  0140e	8b 4d 08	 mov	 ecx, DWORD PTR _atlas$[ebp]
  01411	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  01414	52		 push	 edx
  01415	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  01418	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0141b	51		 push	 ecx
  0141c	8b 95 70 fc ff
	ff		 mov	 edx, DWORD PTR _src_tmp$28[ebp]
  01422	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  01428	50		 push	 eax
  01429	e8 00 00 00 00	 call	 _stbtt_GetPackedQuad
  0142e	83 c4 20	 add	 esp, 32			; 00000020H

; 2128 :             dst_font->AddGlyph((ImWchar)codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod);

  01431	51		 push	 ecx
  01432	f3 0f 10 85 bc
	fb ff ff	 movss	 xmm0, DWORD PTR _char_advance_x_mod$13[ebp]
  0143a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0143f	51		 push	 ecx
  01440	f3 0f 10 85 a4
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp+28]
  01448	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0144d	51		 push	 ecx
  0144e	f3 0f 10 85 a0
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp+24]
  01456	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0145b	51		 push	 ecx
  0145c	f3 0f 10 85 94
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp+12]
  01464	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01469	51		 push	 ecx
  0146a	f3 0f 10 85 90
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp+8]
  01472	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01477	f3 0f 10 85 9c
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp+20]
  0147f	f3 0f 58 85 f8
	fb ff ff	 addss	 xmm0, DWORD PTR _font_off_y$18[ebp]
  01487	51		 push	 ecx
  01488	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0148d	f3 0f 10 85 98
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp+16]
  01495	f3 0f 58 85 b0
	fb ff ff	 addss	 xmm0, DWORD PTR _char_off_x$12[ebp]
  0149d	51		 push	 ecx
  0149e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014a3	f3 0f 10 85 8c
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp+4]
  014ab	f3 0f 58 85 f8
	fb ff ff	 addss	 xmm0, DWORD PTR _font_off_y$18[ebp]
  014b3	51		 push	 ecx
  014b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014b9	f3 0f 10 85 88
	fb ff ff	 movss	 xmm0, DWORD PTR _q$11[ebp]
  014c1	f3 0f 58 85 b0
	fb ff ff	 addss	 xmm0, DWORD PTR _char_off_x$12[ebp]
  014c9	51		 push	 ecx
  014ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  014cf	0f b7 85 e0 fb
	ff ff		 movzx	 eax, WORD PTR _codepoint$16[ebp]
  014d6	50		 push	 eax
  014d7	8b 8d 58 fc ff
	ff		 mov	 ecx, DWORD PTR _dst_font$26[ebp]
  014dd	e8 00 00 00 00	 call	 ?AddGlyph@ImFont@@QAEXGMMMMMMMMM@Z ; ImFont::AddGlyph

; 2129 :         }

  014e2	e9 a9 fd ff ff	 jmp	 $LN47@ImFontAtla
$LN48@ImFontAtla:

; 2130 :     }

  014e7	e9 be fb ff ff	 jmp	 $LN44@ImFontAtla
$LN45@ImFontAtla:

; 2131 : 
; 2132 :     // Cleanup temporary (ImVector doesn't honor destructor)
; 2133 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  014ec	c7 85 64 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _src_i$8[ebp], 0
  014f6	eb 0f		 jmp	 SHORT $LN52@ImFontAtla
$LN50@ImFontAtla:
  014f8	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _src_i$8[ebp]
  014fe	83 c0 01	 add	 eax, 1
  01501	89 85 64 fb ff
	ff		 mov	 DWORD PTR _src_i$8[ebp], eax
$LN52@ImFontAtla:
  01507	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _src_i$8[ebp]
  0150d	3b 45 e0	 cmp	 eax, DWORD PTR _src_tmp_array$[ebp]
  01510	7d 1a		 jge	 SHORT $LN51@ImFontAtla

; 2134 :         src_tmp_array[src_i].~ImFontBuildSrcData();

  01512	6a 00		 push	 0
  01514	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR _src_i$8[ebp]
  0151a	50		 push	 eax
  0151b	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  0151e	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontBuildSrcData@@@@QAEAAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
  01523	8b c8		 mov	 ecx, eax
  01525	e8 00 00 00 00	 call	 ??_GImFontBuildSrcData@@QAEPAXI@Z
  0152a	eb cc		 jmp	 SHORT $LN50@ImFontAtla
$LN51@ImFontAtla:

; 2135 : 
; 2136 :     ImFontAtlasBuildFinish(atlas);

  0152c	8b 45 08	 mov	 eax, DWORD PTR _atlas$[ebp]
  0152f	50		 push	 eax
  01530	e8 00 00 00 00	 call	 ?ImFontAtlasBuildFinish@@YAXPAUImFontAtlas@@@Z ; ImFontAtlasBuildFinish
  01535	83 c4 04	 add	 esp, 4

; 2137 :     return true;

  01538	c6 85 d3 f8 ff
	ff 01		 mov	 BYTE PTR $T2[ebp], 1
  0153f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  01543	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_packedchars$[ebp]
  01549	e8 00 00 00 00	 call	 ??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ ; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
  0154e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01552	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_rects$[ebp]
  01558	e8 00 00 00 00	 call	 ??1?$ImVector@Ustbrp_rect@@@@QAE@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
  0155d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01561	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  01564	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
  01569	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01570	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  01573	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
  01578	8a 85 d3 f8 ff
	ff		 mov	 al, BYTE PTR $T2[ebp]
$LN1@ImFontAtla:

; 2138 : }

  0157e	52		 push	 edx
  0157f	8b cd		 mov	 ecx, ebp
  01581	50		 push	 eax
  01582	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN118@ImFontAtla
  01588	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0158d	58		 pop	 eax
  0158e	5a		 pop	 edx
  0158f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01592	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01599	59		 pop	 ecx
  0159a	5f		 pop	 edi
  0159b	5e		 pop	 esi
  0159c	5b		 pop	 ebx
  0159d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015a0	33 cd		 xor	 ecx, ebp
  015a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015a7	81 c4 40 07 00
	00		 add	 esp, 1856		; 00000740H
  015ad	3b ec		 cmp	 ebp, esp
  015af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  015b4	8b e5		 mov	 esp, ebp
  015b6	5d		 pop	 ebp
  015b7	c3		 ret	 0
$LN118@ImFontAtla:
  015b8	10 00 00 00	 DD	 16			; 00000010H
  015bc	00 00 00 00	 DD	 $LN117@ImFontAtla
$LN117@ImFontAtla:
  015c0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  015c4	0c 00 00 00	 DD	 12			; 0000000cH
  015c8	00 00 00 00	 DD	 $LN100@ImFontAtla
  015cc	cc ff ff ff	 DD	 -52			; ffffffccH
  015d0	0c 00 00 00	 DD	 12			; 0000000cH
  015d4	00 00 00 00	 DD	 $LN101@ImFontAtla
  015d8	f8 fe ff ff	 DD	 -264			; fffffef8H
  015dc	0c 00 00 00	 DD	 12			; 0000000cH
  015e0	00 00 00 00	 DD	 $LN102@ImFontAtla
  015e4	e4 fe ff ff	 DD	 -284			; fffffee4H
  015e8	0c 00 00 00	 DD	 12			; 0000000cH
  015ec	00 00 00 00	 DD	 $LN103@ImFontAtla
  015f0	6c fe ff ff	 DD	 -404			; fffffe6cH
  015f4	04 00 00 00	 DD	 4
  015f8	00 00 00 00	 DD	 $LN104@ImFontAtla
  015fc	60 fe ff ff	 DD	 -416			; fffffe60H
  01600	04 00 00 00	 DD	 4
  01604	00 00 00 00	 DD	 $LN105@ImFontAtla
  01608	54 fe ff ff	 DD	 -428			; fffffe54H
  0160c	04 00 00 00	 DD	 4
  01610	00 00 00 00	 DD	 $LN106@ImFontAtla
  01614	48 fe ff ff	 DD	 -440			; fffffe48H
  01618	04 00 00 00	 DD	 4
  0161c	00 00 00 00	 DD	 $LN107@ImFontAtla
  01620	f0 fd ff ff	 DD	 -528			; fffffdf0H
  01624	2c 00 00 00	 DD	 44			; 0000002cH
  01628	00 00 00 00	 DD	 $LN108@ImFontAtla
  0162c	a0 fc ff ff	 DD	 -864			; fffffca0H
  01630	00 01 00 00	 DD	 256			; 00000100H
  01634	00 00 00 00	 DD	 $LN109@ImFontAtla
  01638	40 fc ff ff	 DD	 -960			; fffffc40H
  0163c	04 00 00 00	 DD	 4
  01640	00 00 00 00	 DD	 $LN110@ImFontAtla
  01644	34 fc ff ff	 DD	 -972			; fffffc34H
  01648	04 00 00 00	 DD	 4
  0164c	00 00 00 00	 DD	 $LN111@ImFontAtla
  01650	28 fc ff ff	 DD	 -984			; fffffc28H
  01654	04 00 00 00	 DD	 4
  01658	00 00 00 00	 DD	 $LN112@ImFontAtla
  0165c	88 fb ff ff	 DD	 -1144			; fffffb88H
  01660	20 00 00 00	 DD	 32			; 00000020H
  01664	00 00 00 00	 DD	 $LN113@ImFontAtla
  01668	7c fb ff ff	 DD	 -1156			; fffffb7cH
  0166c	04 00 00 00	 DD	 4
  01670	00 00 00 00	 DD	 $LN114@ImFontAtla
  01674	70 fb ff ff	 DD	 -1168			; fffffb70H
  01678	04 00 00 00	 DD	 4
  0167c	00 00 00 00	 DD	 $LN115@ImFontAtla
$LN115@ImFontAtla:
  01680	64		 DB	 100			; 00000064H
  01681	75		 DB	 117			; 00000075H
  01682	6d		 DB	 109			; 0000006dH
  01683	6d		 DB	 109			; 0000006dH
  01684	79		 DB	 121			; 00000079H
  01685	5f		 DB	 95			; 0000005fH
  01686	79		 DB	 121			; 00000079H
  01687	00		 DB	 0
$LN114@ImFontAtla:
  01688	64		 DB	 100			; 00000064H
  01689	75		 DB	 117			; 00000075H
  0168a	6d		 DB	 109			; 0000006dH
  0168b	6d		 DB	 109			; 0000006dH
  0168c	79		 DB	 121			; 00000079H
  0168d	5f		 DB	 95			; 0000005fH
  0168e	78		 DB	 120			; 00000078H
  0168f	00		 DB	 0
$LN113@ImFontAtla:
  01690	71		 DB	 113			; 00000071H
  01691	00		 DB	 0
$LN112@ImFontAtla:
  01692	75		 DB	 117			; 00000075H
  01693	6e		 DB	 110			; 0000006eH
  01694	73		 DB	 115			; 00000073H
  01695	63		 DB	 99			; 00000063H
  01696	61		 DB	 97			; 00000061H
  01697	6c		 DB	 108			; 0000006cH
  01698	65		 DB	 101			; 00000065H
  01699	64		 DB	 100			; 00000064H
  0169a	5f		 DB	 95			; 0000005fH
  0169b	6c		 DB	 108			; 0000006cH
  0169c	69		 DB	 105			; 00000069H
  0169d	6e		 DB	 110			; 0000006eH
  0169e	65		 DB	 101			; 00000065H
  0169f	5f		 DB	 95			; 0000005fH
  016a0	67		 DB	 103			; 00000067H
  016a1	61		 DB	 97			; 00000061H
  016a2	70		 DB	 112			; 00000070H
  016a3	00		 DB	 0
$LN111@ImFontAtla:
  016a4	75		 DB	 117			; 00000075H
  016a5	6e		 DB	 110			; 0000006eH
  016a6	73		 DB	 115			; 00000073H
  016a7	63		 DB	 99			; 00000063H
  016a8	61		 DB	 97			; 00000061H
  016a9	6c		 DB	 108			; 0000006cH
  016aa	65		 DB	 101			; 00000065H
  016ab	64		 DB	 100			; 00000064H
  016ac	5f		 DB	 95			; 0000005fH
  016ad	64		 DB	 100			; 00000064H
  016ae	65		 DB	 101			; 00000065H
  016af	73		 DB	 115			; 00000073H
  016b0	63		 DB	 99			; 00000063H
  016b1	65		 DB	 101			; 00000065H
  016b2	6e		 DB	 110			; 0000006eH
  016b3	74		 DB	 116			; 00000074H
  016b4	00		 DB	 0
$LN110@ImFontAtla:
  016b5	75		 DB	 117			; 00000075H
  016b6	6e		 DB	 110			; 0000006eH
  016b7	73		 DB	 115			; 00000073H
  016b8	63		 DB	 99			; 00000063H
  016b9	61		 DB	 97			; 00000061H
  016ba	6c		 DB	 108			; 0000006cH
  016bb	65		 DB	 101			; 00000065H
  016bc	64		 DB	 100			; 00000064H
  016bd	5f		 DB	 95			; 0000005fH
  016be	61		 DB	 97			; 00000061H
  016bf	73		 DB	 115			; 00000073H
  016c0	63		 DB	 99			; 00000063H
  016c1	65		 DB	 101			; 00000065H
  016c2	6e		 DB	 110			; 0000006eH
  016c3	74		 DB	 116			; 00000074H
  016c4	00		 DB	 0
$LN109@ImFontAtla:
  016c5	6d		 DB	 109			; 0000006dH
  016c6	75		 DB	 117			; 00000075H
  016c7	6c		 DB	 108			; 0000006cH
  016c8	74		 DB	 116			; 00000074H
  016c9	69		 DB	 105			; 00000069H
  016ca	70		 DB	 112			; 00000070H
  016cb	6c		 DB	 108			; 0000006cH
  016cc	79		 DB	 121			; 00000079H
  016cd	5f		 DB	 95			; 0000005fH
  016ce	74		 DB	 116			; 00000074H
  016cf	61		 DB	 97			; 00000061H
  016d0	62		 DB	 98			; 00000062H
  016d1	6c		 DB	 108			; 0000006cH
  016d2	65		 DB	 101			; 00000065H
  016d3	00		 DB	 0
$LN108@ImFontAtla:
  016d4	73		 DB	 115			; 00000073H
  016d5	70		 DB	 112			; 00000070H
  016d6	63		 DB	 99			; 00000063H
  016d7	00		 DB	 0
$LN107@ImFontAtla:
  016d8	79		 DB	 121			; 00000079H
  016d9	31		 DB	 49			; 00000031H
  016da	00		 DB	 0
$LN106@ImFontAtla:
  016db	78		 DB	 120			; 00000078H
  016dc	31		 DB	 49			; 00000031H
  016dd	00		 DB	 0
$LN105@ImFontAtla:
  016de	79		 DB	 121			; 00000079H
  016df	30		 DB	 48			; 00000030H
  016e0	00		 DB	 0
$LN104@ImFontAtla:
  016e1	78		 DB	 120			; 00000078H
  016e2	30		 DB	 48			; 00000030H
  016e3	00		 DB	 0
$LN103@ImFontAtla:
  016e4	62		 DB	 98			; 00000062H
  016e5	75		 DB	 117			; 00000075H
  016e6	66		 DB	 102			; 00000066H
  016e7	5f		 DB	 95			; 0000005fH
  016e8	70		 DB	 112			; 00000070H
  016e9	61		 DB	 97			; 00000061H
  016ea	63		 DB	 99			; 00000063H
  016eb	6b		 DB	 107			; 0000006bH
  016ec	65		 DB	 101			; 00000065H
  016ed	64		 DB	 100			; 00000064H
  016ee	63		 DB	 99			; 00000063H
  016ef	68		 DB	 104			; 00000068H
  016f0	61		 DB	 97			; 00000061H
  016f1	72		 DB	 114			; 00000072H
  016f2	73		 DB	 115			; 00000073H
  016f3	00		 DB	 0
$LN102@ImFontAtla:
  016f4	62		 DB	 98			; 00000062H
  016f5	75		 DB	 117			; 00000075H
  016f6	66		 DB	 102			; 00000066H
  016f7	5f		 DB	 95			; 0000005fH
  016f8	72		 DB	 114			; 00000072H
  016f9	65		 DB	 101			; 00000065H
  016fa	63		 DB	 99			; 00000063H
  016fb	74		 DB	 116			; 00000074H
  016fc	73		 DB	 115			; 00000073H
  016fd	00		 DB	 0
$LN101@ImFontAtla:
  016fe	64		 DB	 100			; 00000064H
  016ff	73		 DB	 115			; 00000073H
  01700	74		 DB	 116			; 00000074H
  01701	5f		 DB	 95			; 0000005fH
  01702	74		 DB	 116			; 00000074H
  01703	6d		 DB	 109			; 0000006dH
  01704	70		 DB	 112			; 00000070H
  01705	5f		 DB	 95			; 0000005fH
  01706	61		 DB	 97			; 00000061H
  01707	72		 DB	 114			; 00000072H
  01708	72		 DB	 114			; 00000072H
  01709	61		 DB	 97			; 00000061H
  0170a	79		 DB	 121			; 00000079H
  0170b	00		 DB	 0
$LN100@ImFontAtla:
  0170c	73		 DB	 115			; 00000073H
  0170d	72		 DB	 114			; 00000072H
  0170e	63		 DB	 99			; 00000063H
  0170f	5f		 DB	 95			; 0000005fH
  01710	74		 DB	 116			; 00000074H
  01711	6d		 DB	 109			; 0000006dH
  01712	70		 DB	 112			; 00000070H
  01713	5f		 DB	 95			; 0000005fH
  01714	61		 DB	 97			; 00000061H
  01715	72		 DB	 114			; 00000072H
  01716	72		 DB	 114			; 00000072H
  01717	61		 DB	 97			; 00000061H
  01718	79		 DB	 121			; 00000079H
  01719	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _src_tmp_array$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontBuildSrcData@@@@QAE@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR _dst_tmp_array$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontBuildDstData@@@@QAE@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$2:
  00010	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_rects$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbrp_rect@@@@QAE@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
__unwindfunclet$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z$3:
  0001b	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _buf_packedchars$[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbtt_packedchar@@@@QAE@XZ ; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
  00026	cc		 int	 3
  00027	cc		 int	 3
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
__ehhandler$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z:
  0002b	90		 npad	 1
  0002c	90		 npad	 1
  0002d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00031	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00034	8b 8a bc f8 ff
	ff		 mov	 ecx, DWORD PTR [edx-1860]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00044	33 c8		 xor	 ecx, eax
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z
  00050	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildWithStbTruetype
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ShadeVertsLinearUV@ImGui@@YAXPAUImDrawList@@HHABUImVec2@@111_N@Z
_TEXT	SEGMENT
tv80 = -476						; size = 4
tv75 = -472						; size = 4
$T1 = -464						; size = 8
$T2 = -448						; size = 8
$T3 = -432						; size = 8
$T4 = -416						; size = 8
$T5 = -400						; size = 8
$T6 = -384						; size = 8
$T7 = -368						; size = 8
$T8 = -352						; size = 8
$T9 = -336						; size = 8
_vertex$10 = -128					; size = 4
_vertex$11 = -116					; size = 4
_max$12 = -104						; size = 8
_min$13 = -88						; size = 8
_vert_end$ = -72					; size = 4
_vert_start$ = -60					; size = 4
_scale$ = -48						; size = 8
_uv_size$ = -32						; size = 8
_size$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_draw_list$ = 8						; size = 4
_vert_start_idx$ = 12					; size = 4
_vert_end_idx$ = 16					; size = 4
_a$ = 20						; size = 4
_b$ = 24						; size = 4
_uv_a$ = 28						; size = 4
_uv_b$ = 32						; size = 4
_clamp$ = 36						; size = 1
?ShadeVertsLinearUV@ImGui@@YAXPAUImDrawList@@HHABUImVec2@@111_N@Z PROC ; ImGui::ShadeVertsLinearUV, COMDAT

; 1423 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 01 00
	00		 sub	 esp, 476		; 000001dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-476]
  00012	b9 77 00 00 00	 mov	 ecx, 119		; 00000077H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1424 :     const ImVec2 size = b - a;

  00032	8b 45 14	 mov	 eax, DWORD PTR _a$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 18	 mov	 ecx, DWORD PTR _b$[ebp]
  00039	51		 push	 ecx
  0003a	8d 55 f0	 lea	 edx, DWORD PTR _size$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1425 :     const ImVec2 uv_size = uv_b - uv_a;

  00046	8b 45 1c	 mov	 eax, DWORD PTR _uv_a$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 20	 mov	 ecx, DWORD PTR _uv_b$[ebp]
  0004d	51		 push	 ecx
  0004e	8d 55 e0	 lea	 edx, DWORD PTR _uv_size$[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1426 :     const ImVec2 scale = ImVec2(

  0005a	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _size$[ebp+4]
  0005f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00066	9f		 lahf
  00067	f6 c4 44	 test	 ah, 68			; 00000044H
  0006a	7b 14		 jnp	 SHORT $LN11@ShadeVerts
  0006c	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _uv_size$[ebp+4]
  00071	f3 0f 5e 45 f4	 divss	 xmm0, DWORD PTR _size$[ebp+4]
  00076	f3 0f 11 85 28
	fe ff ff	 movss	 DWORD PTR tv75[ebp], xmm0
  0007e	eb 0b		 jmp	 SHORT $LN12@ShadeVerts
$LN11@ShadeVerts:
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	f3 0f 11 85 28
	fe ff ff	 movss	 DWORD PTR tv75[ebp], xmm0
$LN12@ShadeVerts:
  0008b	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _size$[ebp]
  00090	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00097	9f		 lahf
  00098	f6 c4 44	 test	 ah, 68			; 00000044H
  0009b	7b 14		 jnp	 SHORT $LN13@ShadeVerts
  0009d	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _uv_size$[ebp]
  000a2	f3 0f 5e 45 f0	 divss	 xmm0, DWORD PTR _size$[ebp]
  000a7	f3 0f 11 85 24
	fe ff ff	 movss	 DWORD PTR tv80[ebp], xmm0
  000af	eb 0b		 jmp	 SHORT $LN14@ShadeVerts
$LN13@ShadeVerts:
  000b1	0f 57 c0	 xorps	 xmm0, xmm0
  000b4	f3 0f 11 85 24
	fe ff ff	 movss	 DWORD PTR tv80[ebp], xmm0
$LN14@ShadeVerts:
  000bc	51		 push	 ecx
  000bd	f3 0f 10 85 28
	fe ff ff	 movss	 xmm0, DWORD PTR tv75[ebp]
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	51		 push	 ecx
  000cb	f3 0f 10 85 24
	fe ff ff	 movss	 xmm0, DWORD PTR tv80[ebp]
  000d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d8	8d 4d d0	 lea	 ecx, DWORD PTR _scale$[ebp]
  000db	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 1427 :         size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
; 1428 :         size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);
; 1429 : 
; 1430 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

  000e0	6b 45 0c 14	 imul	 eax, DWORD PTR _vert_start_idx$[ebp], 20
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  000e7	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  000ea	89 45 c4	 mov	 DWORD PTR _vert_start$[ebp], eax

; 1431 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

  000ed	6b 45 10 14	 imul	 eax, DWORD PTR _vert_end_idx$[ebp], 20
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  000f4	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  000f7	89 45 b8	 mov	 DWORD PTR _vert_end$[ebp], eax

; 1432 :     if (clamp)

  000fa	0f b6 45 24	 movzx	 eax, BYTE PTR _clamp$[ebp]
  000fe	85 c0		 test	 eax, eax
  00100	0f 84 db 00 00
	00		 je	 $LN8@ShadeVerts

; 1433 :     {
; 1434 :         const ImVec2 min = ImMin(uv_a, uv_b);

  00106	8b 45 20	 mov	 eax, DWORD PTR _uv_b$[ebp]
  00109	50		 push	 eax
  0010a	8b 4d 1c	 mov	 ecx, DWORD PTR _uv_a$[ebp]
  0010d	51		 push	 ecx
  0010e	8d 55 a8	 lea	 edx, DWORD PTR _min$13[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 ?ImMin@@YA?AUImVec2@@ABU1@0@Z ; ImMin
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1435 :         const ImVec2 max = ImMax(uv_a, uv_b);

  0011a	8b 45 20	 mov	 eax, DWORD PTR _uv_b$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d 1c	 mov	 ecx, DWORD PTR _uv_a$[ebp]
  00121	51		 push	 ecx
  00122	8d 55 98	 lea	 edx, DWORD PTR _max$12[ebp]
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 ?ImMax@@YA?AUImVec2@@ABU1@0@Z ; ImMax
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1436 :         for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)

  0012e	8b 45 c4	 mov	 eax, DWORD PTR _vert_start$[ebp]
  00131	89 45 8c	 mov	 DWORD PTR _vertex$11[ebp], eax
  00134	eb 09		 jmp	 SHORT $LN4@ShadeVerts
$LN2@ShadeVerts:
  00136	8b 45 8c	 mov	 eax, DWORD PTR _vertex$11[ebp]
  00139	83 c0 14	 add	 eax, 20			; 00000014H
  0013c	89 45 8c	 mov	 DWORD PTR _vertex$11[ebp], eax
$LN4@ShadeVerts:
  0013f	8b 45 8c	 mov	 eax, DWORD PTR _vertex$11[ebp]
  00142	3b 45 b8	 cmp	 eax, DWORD PTR _vert_end$[ebp]
  00145	0f 83 91 00 00
	00		 jae	 $LN3@ShadeVerts

; 1437 :             vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);

  0014b	8b 45 9c	 mov	 eax, DWORD PTR _max$12[ebp+4]
  0014e	50		 push	 eax
  0014f	8b 4d 98	 mov	 ecx, DWORD PTR _max$12[ebp]
  00152	51		 push	 ecx
  00153	8d 55 a8	 lea	 edx, DWORD PTR _min$13[ebp]
  00156	52		 push	 edx
  00157	8d 45 d0	 lea	 eax, DWORD PTR _scale$[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d 14	 mov	 ecx, DWORD PTR _a$[ebp]
  0015e	51		 push	 ecx
  0015f	8b 55 8c	 mov	 edx, DWORD PTR _vertex$11[ebp]
  00162	51		 push	 ecx
  00163	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00168	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016d	8b 45 8c	 mov	 eax, DWORD PTR _vertex$11[ebp]
  00170	51		 push	 ecx
  00171	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00175	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017a	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00180	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00185	50		 push	 eax
  00186	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH
  00195	50		 push	 eax
  00196	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0019c	52		 push	 edx
  0019d	e8 00 00 00 00	 call	 ?ImMul@@YA?AUImVec2@@ABU1@0@Z ; ImMul
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a5	50		 push	 eax
  001a6	8b 45 1c	 mov	 eax, DWORD PTR _uv_a$[ebp]
  001a9	50		 push	 eax
  001aa	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b9	50		 push	 eax
  001ba	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 ?ImClamp@@YA?AUImVec2@@ABU1@0U1@@Z ; ImClamp
  001c6	83 c4 14	 add	 esp, 20			; 00000014H
  001c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ce	8b 45 8c	 mov	 eax, DWORD PTR _vertex$11[ebp]
  001d1	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001d4	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  001d7	e9 5a ff ff ff	 jmp	 $LN2@ShadeVerts
$LN3@ShadeVerts:

; 1438 :     }

  001dc	e9 8e 00 00 00	 jmp	 $LN6@ShadeVerts
$LN8@ShadeVerts:

; 1439 :     else
; 1440 :     {
; 1441 :         for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)

  001e1	8b 45 c4	 mov	 eax, DWORD PTR _vert_start$[ebp]
  001e4	89 45 80	 mov	 DWORD PTR _vertex$10[ebp], eax
  001e7	eb 09		 jmp	 SHORT $LN7@ShadeVerts
$LN5@ShadeVerts:
  001e9	8b 45 80	 mov	 eax, DWORD PTR _vertex$10[ebp]
  001ec	83 c0 14	 add	 eax, 20			; 00000014H
  001ef	89 45 80	 mov	 DWORD PTR _vertex$10[ebp], eax
$LN7@ShadeVerts:
  001f2	8b 45 80	 mov	 eax, DWORD PTR _vertex$10[ebp]
  001f5	3b 45 b8	 cmp	 eax, DWORD PTR _vert_end$[ebp]
  001f8	73 75		 jae	 SHORT $LN6@ShadeVerts

; 1442 :             vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);

  001fa	8d 45 d0	 lea	 eax, DWORD PTR _scale$[ebp]
  001fd	50		 push	 eax
  001fe	8b 4d 14	 mov	 ecx, DWORD PTR _a$[ebp]
  00201	51		 push	 ecx
  00202	8b 55 80	 mov	 edx, DWORD PTR _vertex$10[ebp]
  00205	51		 push	 ecx
  00206	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0020b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00210	8b 45 80	 mov	 eax, DWORD PTR _vertex$10[ebp]
  00213	51		 push	 ecx
  00214	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00218	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021d	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00223	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00228	50		 push	 eax
  00229	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00235	83 c4 0c	 add	 esp, 12			; 0000000cH
  00238	50		 push	 eax
  00239	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0023f	52		 push	 edx
  00240	e8 00 00 00 00	 call	 ?ImMul@@YA?AUImVec2@@ABU1@0@Z ; ImMul
  00245	83 c4 0c	 add	 esp, 12			; 0000000cH
  00248	50		 push	 eax
  00249	8b 45 1c	 mov	 eax, DWORD PTR _uv_a$[ebp]
  0024c	50		 push	 eax
  0024d	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00253	51		 push	 ecx
  00254	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00259	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025c	8b 10		 mov	 edx, DWORD PTR [eax]
  0025e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00261	8b 4d 80	 mov	 ecx, DWORD PTR _vertex$10[ebp]
  00264	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00267	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0026a	e9 7a ff ff ff	 jmp	 $LN5@ShadeVerts
$LN6@ShadeVerts:

; 1443 :     }
; 1444 : }

  0026f	52		 push	 edx
  00270	8b cd		 mov	 ecx, ebp
  00272	50		 push	 eax
  00273	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN21@ShadeVerts
  00279	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0027e	58		 pop	 eax
  0027f	5a		 pop	 edx
  00280	5f		 pop	 edi
  00281	5e		 pop	 esi
  00282	5b		 pop	 ebx
  00283	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00286	33 cd		 xor	 ecx, ebp
  00288	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028d	81 c4 dc 01 00
	00		 add	 esp, 476		; 000001dcH
  00293	3b ec		 cmp	 ebp, esp
  00295	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029a	8b e5		 mov	 esp, ebp
  0029c	5d		 pop	 ebp
  0029d	c3		 ret	 0
  0029e	66 90		 npad	 2
$LN21@ShadeVerts:
  002a0	05 00 00 00	 DD	 5
  002a4	00 00 00 00	 DD	 $LN20@ShadeVerts
$LN20@ShadeVerts:
  002a8	f0 ff ff ff	 DD	 -16			; fffffff0H
  002ac	08 00 00 00	 DD	 8
  002b0	00 00 00 00	 DD	 $LN15@ShadeVerts
  002b4	e0 ff ff ff	 DD	 -32			; ffffffe0H
  002b8	08 00 00 00	 DD	 8
  002bc	00 00 00 00	 DD	 $LN16@ShadeVerts
  002c0	d0 ff ff ff	 DD	 -48			; ffffffd0H
  002c4	08 00 00 00	 DD	 8
  002c8	00 00 00 00	 DD	 $LN17@ShadeVerts
  002cc	a8 ff ff ff	 DD	 -88			; ffffffa8H
  002d0	08 00 00 00	 DD	 8
  002d4	00 00 00 00	 DD	 $LN18@ShadeVerts
  002d8	98 ff ff ff	 DD	 -104			; ffffff98H
  002dc	08 00 00 00	 DD	 8
  002e0	00 00 00 00	 DD	 $LN19@ShadeVerts
$LN19@ShadeVerts:
  002e4	6d		 DB	 109			; 0000006dH
  002e5	61		 DB	 97			; 00000061H
  002e6	78		 DB	 120			; 00000078H
  002e7	00		 DB	 0
$LN18@ShadeVerts:
  002e8	6d		 DB	 109			; 0000006dH
  002e9	69		 DB	 105			; 00000069H
  002ea	6e		 DB	 110			; 0000006eH
  002eb	00		 DB	 0
$LN17@ShadeVerts:
  002ec	73		 DB	 115			; 00000073H
  002ed	63		 DB	 99			; 00000063H
  002ee	61		 DB	 97			; 00000061H
  002ef	6c		 DB	 108			; 0000006cH
  002f0	65		 DB	 101			; 00000065H
  002f1	00		 DB	 0
$LN16@ShadeVerts:
  002f2	75		 DB	 117			; 00000075H
  002f3	76		 DB	 118			; 00000076H
  002f4	5f		 DB	 95			; 0000005fH
  002f5	73		 DB	 115			; 00000073H
  002f6	69		 DB	 105			; 00000069H
  002f7	7a		 DB	 122			; 0000007aH
  002f8	65		 DB	 101			; 00000065H
  002f9	00		 DB	 0
$LN15@ShadeVerts:
  002fa	73		 DB	 115			; 00000073H
  002fb	69		 DB	 105			; 00000069H
  002fc	7a		 DB	 122			; 0000007aH
  002fd	65		 DB	 101			; 00000065H
  002fe	00		 DB	 0
?ShadeVertsLinearUV@ImGui@@YAXPAUImDrawList@@HHABUImVec2@@111_N@Z ENDP ; ImGui::ShadeVertsLinearUV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPAUImDrawList@@HHUImVec2@@1II@Z
_TEXT	SEGMENT
tv165 = -340						; size = 4
$T1 = -332						; size = 8
_b$2 = -124						; size = 4
_g$3 = -112						; size = 4
_r$4 = -100						; size = 4
_t$5 = -88						; size = 4
_d$6 = -76						; size = 4
_vert$7 = -64						; size = 4
_vert_end$ = -52					; size = 4
_vert_start$ = -40					; size = 4
_gradient_inv_length2$ = -28				; size = 4
_gradient_extent$ = -16					; size = 8
__$ArrayPad$ = -4					; size = 4
_draw_list$ = 8						; size = 4
_vert_start_idx$ = 12					; size = 4
_vert_end_idx$ = 16					; size = 4
_gradient_p0$ = 20					; size = 8
_gradient_p1$ = 28					; size = 8
_col0$ = 36						; size = 4
_col1$ = 40						; size = 4
?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPAUImDrawList@@HHUImVec2@@1II@Z PROC ; ImGui::ShadeVertsLinearColorGradientKeepAlpha, COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ac fe ff
	ff		 lea	 edi, DWORD PTR [ebp-340]
  00012	b9 55 00 00 00	 mov	 ecx, 85			; 00000055H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1406 :     ImVec2 gradient_extent = gradient_p1 - gradient_p0;

  00032	8d 45 14	 lea	 eax, DWORD PTR _gradient_p0$[ebp]
  00035	50		 push	 eax
  00036	8d 4d 1c	 lea	 ecx, DWORD PTR _gradient_p1$[ebp]
  00039	51		 push	 ecx
  0003a	8d 55 f0	 lea	 edx, DWORD PTR _gradient_extent$[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1407 :     float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _gradient_extent$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?ImLengthSqr@@YAMABUImVec2@@@Z ; ImLengthSqr
  0004f	83 c4 04	 add	 esp, 4
  00052	d9 9d ac fe ff
	ff		 fstp	 DWORD PTR tv165[ebp]
  00058	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00060	f3 0f 5e 85 ac
	fe ff ff	 divss	 xmm0, DWORD PTR tv165[ebp]
  00068	f3 0f 11 45 e4	 movss	 DWORD PTR _gradient_inv_length2$[ebp], xmm0

; 1408 :     ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;

  0006d	6b 45 0c 14	 imul	 eax, DWORD PTR _vert_start_idx$[ebp], 20
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00074	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  00077	89 45 d8	 mov	 DWORD PTR _vert_start$[ebp], eax

; 1409 :     ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;

  0007a	6b 45 10 14	 imul	 eax, DWORD PTR _vert_end_idx$[ebp], 20
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00081	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  00084	89 45 cc	 mov	 DWORD PTR _vert_end$[ebp], eax

; 1410 :     for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)

  00087	8b 45 d8	 mov	 eax, DWORD PTR _vert_start$[ebp]
  0008a	89 45 c0	 mov	 DWORD PTR _vert$7[ebp], eax
  0008d	eb 09		 jmp	 SHORT $LN4@ShadeVerts
$LN2@ShadeVerts:
  0008f	8b 45 c0	 mov	 eax, DWORD PTR _vert$7[ebp]
  00092	83 c0 14	 add	 eax, 20			; 00000014H
  00095	89 45 c0	 mov	 DWORD PTR _vert$7[ebp], eax
$LN4@ShadeVerts:
  00098	8b 45 c0	 mov	 eax, DWORD PTR _vert$7[ebp]
  0009b	3b 45 cc	 cmp	 eax, DWORD PTR _vert_end$[ebp]
  0009e	0f 83 0a 01 00
	00		 jae	 $LN3@ShadeVerts

; 1411 :     {
; 1412 :         float d = ImDot(vert->pos - gradient_p0, gradient_extent);

  000a4	8d 45 f0	 lea	 eax, DWORD PTR _gradient_extent$[ebp]
  000a7	50		 push	 eax
  000a8	8d 4d 14	 lea	 ecx, DWORD PTR _gradient_p0$[ebp]
  000ab	51		 push	 ecx
  000ac	8b 55 c0	 mov	 edx, DWORD PTR _vert$7[ebp]
  000af	52		 push	 edx
  000b0	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?ImDot@@YAMABUImVec2@@0@Z ; ImDot
  000c5	83 c4 08	 add	 esp, 8
  000c8	d9 5d b4	 fstp	 DWORD PTR _d$6[ebp]

; 1413 :         float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);

  000cb	51		 push	 ecx
  000cc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d9	51		 push	 ecx
  000da	0f 57 c0	 xorps	 xmm0, xmm0
  000dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e2	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _d$6[ebp]
  000e7	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _gradient_inv_length2$[ebp]
  000ec	51		 push	 ecx
  000ed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f2	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fa	d9 5d a8	 fstp	 DWORD PTR _t$5[ebp]

; 1414 :         int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);

  000fd	51		 push	 ecx
  000fe	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _t$5[ebp]
  00103	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00108	8b 45 28	 mov	 eax, DWORD PTR _col1$[ebp]
  0010b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00110	50		 push	 eax
  00111	8b 4d 24	 mov	 ecx, DWORD PTR _col0$[ebp]
  00114	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH
  00123	89 45 9c	 mov	 DWORD PTR _r$4[ebp], eax

; 1415 :         int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);

  00126	51		 push	 ecx
  00127	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _t$5[ebp]
  0012c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00131	8b 45 28	 mov	 eax, DWORD PTR _col1$[ebp]
  00134	c1 e8 08	 shr	 eax, 8
  00137	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0013c	50		 push	 eax
  0013d	8b 4d 24	 mov	 ecx, DWORD PTR _col0$[ebp]
  00140	c1 e9 08	 shr	 ecx, 8
  00143	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00149	51		 push	 ecx
  0014a	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00152	89 45 90	 mov	 DWORD PTR _g$3[ebp], eax

; 1416 :         int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);

  00155	51		 push	 ecx
  00156	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _t$5[ebp]
  0015b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00160	8b 45 28	 mov	 eax, DWORD PTR _col1$[ebp]
  00163	c1 e8 10	 shr	 eax, 16			; 00000010H
  00166	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016b	50		 push	 eax
  0016c	8b 4d 24	 mov	 ecx, DWORD PTR _col0$[ebp]
  0016f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00172	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00178	51		 push	 ecx
  00179	e8 00 00 00 00	 call	 ??$ImLerp@H@@YAHHHM@Z	; ImLerp<int>
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00181	89 45 84	 mov	 DWORD PTR _b$2[ebp], eax

; 1417 :         vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);

  00184	8b 45 90	 mov	 eax, DWORD PTR _g$3[ebp]
  00187	c1 e0 08	 shl	 eax, 8
  0018a	0b 45 9c	 or	 eax, DWORD PTR _r$4[ebp]
  0018d	8b 4d 84	 mov	 ecx, DWORD PTR _b$2[ebp]
  00190	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00193	0b c1		 or	 eax, ecx
  00195	8b 55 c0	 mov	 edx, DWORD PTR _vert$7[ebp]
  00198	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0019b	81 e1 00 00 00
	ff		 and	 ecx, -16777216		; ff000000H
  001a1	0b c1		 or	 eax, ecx
  001a3	8b 55 c0	 mov	 edx, DWORD PTR _vert$7[ebp]
  001a6	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1418 :     }

  001a9	e9 e1 fe ff ff	 jmp	 $LN2@ShadeVerts
$LN3@ShadeVerts:

; 1419 : }

  001ae	52		 push	 edx
  001af	8b cd		 mov	 ecx, ebp
  001b1	50		 push	 eax
  001b2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@ShadeVerts
  001b8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001bd	58		 pop	 eax
  001be	5a		 pop	 edx
  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5b		 pop	 ebx
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c5	33 cd		 xor	 ecx, ebp
  001c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cc	81 c4 54 01 00
	00		 add	 esp, 340		; 00000154H
  001d2	3b ec		 cmp	 ebp, esp
  001d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c3		 ret	 0
  001dd	0f 1f 00	 npad	 3
$LN8@ShadeVerts:
  001e0	01 00 00 00	 DD	 1
  001e4	00 00 00 00	 DD	 $LN7@ShadeVerts
$LN7@ShadeVerts:
  001e8	f0 ff ff ff	 DD	 -16			; fffffff0H
  001ec	08 00 00 00	 DD	 8
  001f0	00 00 00 00	 DD	 $LN6@ShadeVerts
$LN6@ShadeVerts:
  001f4	67		 DB	 103			; 00000067H
  001f5	72		 DB	 114			; 00000072H
  001f6	61		 DB	 97			; 00000061H
  001f7	64		 DB	 100			; 00000064H
  001f8	69		 DB	 105			; 00000069H
  001f9	65		 DB	 101			; 00000065H
  001fa	6e		 DB	 110			; 0000006eH
  001fb	74		 DB	 116			; 00000074H
  001fc	5f		 DB	 95			; 0000005fH
  001fd	65		 DB	 101			; 00000065H
  001fe	78		 DB	 120			; 00000078H
  001ff	74		 DB	 116			; 00000074H
  00200	65		 DB	 101			; 00000065H
  00201	6e		 DB	 110			; 0000006eH
  00202	74		 DB	 116			; 00000074H
  00203	00		 DB	 0
?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPAUImDrawList@@HHUImVec2@@1II@Z ENDP ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?RenderRectFilledRangeH@ImGui@@YAXPAUImDrawList@@ABUImRect@@IMMM@Z
_TEXT	SEGMENT
tv408 = -520						; size = 4
$T1 = -512						; size = 8
$T2 = -496						; size = 8
$T3 = -480						; size = 8
$T4 = -464						; size = 8
$T5 = -448						; size = 8
$T6 = -432						; size = 8
$T7 = -416						; size = 8
$T8 = -400						; size = 8
$T9 = -384						; size = 8
$T10 = -368						; size = 8
$T11 = -352						; size = 8
$T12 = -336						; size = 8
_x1$13 = -128						; size = 4
_arc1_e$14 = -116					; size = 4
_arc1_b$15 = -104					; size = 4
_x0$ = -92						; size = 4
_half_pi$ = -80						; size = 4
_arc0_e$ = -68						; size = 4
_arc0_b$ = -56						; size = 4
_inv_rounding$ = -44					; size = 4
_p1$ = -32						; size = 8
_p0$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_draw_list$ = 8						; size = 4
_rect$ = 12						; size = 4
_col$ = 16						; size = 4
_x_start_norm$ = 20					; size = 4
_x_end_norm$ = 24					; size = 4
_rounding$ = 28						; size = 4
?RenderRectFilledRangeH@ImGui@@YAXPAUImDrawList@@ABUImRect@@IMMM@Z PROC ; ImGui::RenderRectFilledRangeH, COMDAT

; 3124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-520]
  00012	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3125 :     if (x_end_norm == x_start_norm)

  00032	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _x_end_norm$[ebp]
  00037	0f 2e 45 14	 ucomiss xmm0, DWORD PTR _x_start_norm$[ebp]
  0003b	9f		 lahf
  0003c	f6 c4 44	 test	 ah, 68			; 00000044H
  0003f	7a 05		 jp	 SHORT $LN2@RenderRect

; 3126 :         return;

  00041	e9 4d 06 00 00	 jmp	 $LN1@RenderRect
$LN2@RenderRect:

; 3127 :     if (x_start_norm > x_end_norm)

  00046	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _x_start_norm$[ebp]
  0004b	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _x_end_norm$[ebp]
  0004f	76 10		 jbe	 SHORT $LN3@RenderRect

; 3128 :         ImSwap(x_start_norm, x_end_norm);

  00051	8d 45 18	 lea	 eax, DWORD PTR _x_end_norm$[ebp]
  00054	50		 push	 eax
  00055	8d 4d 14	 lea	 ecx, DWORD PTR _x_start_norm$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$ImSwap@M@@YAXAAM0@Z	; ImSwap<float>
  0005e	83 c4 08	 add	 esp, 8
$LN3@RenderRect:

; 3129 : 
; 3130 :     ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);

  00061	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  00064	51		 push	 ecx
  00065	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0006a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006f	51		 push	 ecx
  00070	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _x_start_norm$[ebp]
  00075	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  0007d	51		 push	 ecx
  0007e	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00088	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  0008b	51		 push	 ecx
  0008c	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00090	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00095	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  0009a	83 c4 08	 add	 esp, 8
  0009d	d9 1c 24	 fstp	 DWORD PTR [esp]
  000a0	8d 4d f0	 lea	 ecx, DWORD PTR _p0$[ebp]
  000a3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 3131 :     ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  000ab	51		 push	 ecx
  000ac	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b6	51		 push	 ecx
  000b7	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _x_end_norm$[ebp]
  000bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  000c4	51		 push	 ecx
  000c5	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  000ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cf	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  000d2	51		 push	 ecx
  000d3	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  000d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000dc	e8 00 00 00 00	 call	 ??$ImLerp@M@@YAMMMM@Z	; ImLerp<float>
  000e1	83 c4 08	 add	 esp, 8
  000e4	d9 1c 24	 fstp	 DWORD PTR [esp]
  000e7	8d 4d e0	 lea	 ecx, DWORD PTR _p1$[ebp]
  000ea	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 3132 :     if (rounding == 0.0f)

  000ef	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  000f4	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  000fb	9f		 lahf
  000fc	f6 c4 44	 test	 ah, 68			; 00000044H
  000ff	7a 24		 jp	 SHORT $LN4@RenderRect

; 3133 :     {
; 3134 :         draw_list->AddRectFilled(p0, p1, col, 0.0f);

  00101	6a 0f		 push	 15			; 0000000fH
  00103	51		 push	 ecx
  00104	0f 57 c0	 xorps	 xmm0, xmm0
  00107	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010c	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  0010f	50		 push	 eax
  00110	8d 4d e0	 lea	 ecx, DWORD PTR _p1$[ebp]
  00113	51		 push	 ecx
  00114	8d 55 f0	 lea	 edx, DWORD PTR _p0$[ebp]
  00117	52		 push	 edx
  00118	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0011b	e8 00 00 00 00	 call	 ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 3135 :         return;

  00120	e9 6e 05 00 00	 jmp	 $LN1@RenderRect
$LN4@RenderRect:

; 3136 :     }
; 3137 : 
; 3138 :     rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);

  00125	51		 push	 ecx
  00126	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0012b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00130	51		 push	 ecx
  00131	0f 57 c0	 xorps	 xmm0, xmm0
  00134	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00139	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0013c	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  0013f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00144	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00149	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00151	51		 push	 ecx
  00152	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00157	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  0015a	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0015d	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00162	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00166	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0016e	51		 push	 ecx
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00179	83 c4 08	 add	 esp, 8
  0017c	d9 9d f8 fd ff
	ff		 fstp	 DWORD PTR tv408[ebp]
  00182	f3 0f 10 85 f8
	fd ff ff	 movss	 xmm0, DWORD PTR tv408[ebp]
  0018a	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00192	51		 push	 ecx
  00193	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00198	e8 00 00 00 00	 call	 ??$ImClamp@M@@YAMMMM@Z	; ImClamp<float>
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a0	d9 5d 1c	 fstp	 DWORD PTR _rounding$[ebp]

; 3139 :     const float inv_rounding = 1.0f / rounding;

  001a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ab	f3 0f 5e 45 1c	 divss	 xmm0, DWORD PTR _rounding$[ebp]
  001b0	f3 0f 11 45 d4	 movss	 DWORD PTR _inv_rounding$[ebp], xmm0

; 3140 :     const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);

  001b5	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  001b8	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _p0$[ebp]
  001bd	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  001c1	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _inv_rounding$[ebp]
  001c6	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  001ce	f3 0f 5c c8	 subss	 xmm1, xmm0
  001d2	51		 push	 ecx
  001d3	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  001d8	e8 00 00 00 00	 call	 ?ImAcos01@@YAMM@Z	; ImAcos01
  001dd	83 c4 04	 add	 esp, 4
  001e0	d9 5d c8	 fstp	 DWORD PTR _arc0_b$[ebp]

; 3141 :     const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);

  001e3	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  001e6	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _p1$[ebp]
  001eb	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  001ef	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _inv_rounding$[ebp]
  001f4	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  001fc	f3 0f 5c c8	 subss	 xmm1, xmm0
  00200	51		 push	 ecx
  00201	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00206	e8 00 00 00 00	 call	 ?ImAcos01@@YAMM@Z	; ImAcos01
  0020b	83 c4 04	 add	 esp, 4
  0020e	d9 5d bc	 fstp	 DWORD PTR _arc0_e$[ebp]

; 3142 :     const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.

  00211	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fc90fdb
  00219	f3 0f 11 45 b0	 movss	 DWORD PTR _half_pi$[ebp], xmm0

; 3143 :     const float x0 = ImMax(p0.x, rect.Min.x + rounding);

  0021e	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  00221	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00225	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  0022a	51		 push	 ecx
  0022b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00230	51		 push	 ecx
  00231	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _p0$[ebp]
  00236	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023b	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00240	83 c4 08	 add	 esp, 8
  00243	d9 5d a4	 fstp	 DWORD PTR _x0$[ebp]

; 3144 :     if (arc0_b == arc0_e)

  00246	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _arc0_b$[ebp]
  0024b	0f 2e 45 bc	 ucomiss xmm0, DWORD PTR _arc0_e$[ebp]
  0024f	9f		 lahf
  00250	f6 c4 44	 test	 ah, 68			; 00000044H
  00253	7a 59		 jp	 SHORT $LN5@RenderRect

; 3145 :     {
; 3146 :         draw_list->PathLineTo(ImVec2(x0, p1.y));

  00255	51		 push	 ecx
  00256	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  0025b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00260	51		 push	 ecx
  00261	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x0$[ebp]
  00266	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026b	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00271	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00276	50		 push	 eax
  00277	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0027a	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 3147 :         draw_list->PathLineTo(ImVec2(x0, p0.y));

  0027f	51		 push	 ecx
  00280	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _p0$[ebp+4]
  00285	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028a	51		 push	 ecx
  0028b	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x0$[ebp]
  00290	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00295	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0029b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002a0	50		 push	 eax
  002a1	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  002a4	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 3148 :     }

  002a9	e9 71 01 00 00	 jmp	 $LN8@RenderRect
$LN5@RenderRect:

; 3149 :     else if (arc0_b == 0.0f && arc0_e == half_pi)

  002ae	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _arc0_b$[ebp]
  002b3	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  002ba	9f		 lahf
  002bb	f6 c4 44	 test	 ah, 68			; 00000044H
  002be	0f 8a 97 00 00
	00		 jp	 $LN7@RenderRect
  002c4	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _arc0_e$[ebp]
  002c9	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3fc90fdb
  002d0	9f		 lahf
  002d1	f6 c4 44	 test	 ah, 68			; 00000044H
  002d4	0f 8a 81 00 00
	00		 jp	 $LN7@RenderRect

; 3150 :     {
; 3151 :         draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL

  002da	6a 06		 push	 6
  002dc	6a 03		 push	 3
  002de	51		 push	 ecx
  002df	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  002e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e9	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  002ee	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _rounding$[ebp]
  002f3	51		 push	 ecx
  002f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f9	51		 push	 ecx
  002fa	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x0$[ebp]
  002ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00304	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0030a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0030f	50		 push	 eax
  00310	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00313	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 3152 :         draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR

  00318	6a 09		 push	 9
  0031a	6a 06		 push	 6
  0031c	51		 push	 ecx
  0031d	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00322	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00327	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _p0$[ebp+4]
  0032c	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  00331	51		 push	 ecx
  00332	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00337	51		 push	 ecx
  00338	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x0$[ebp]
  0033d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00342	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00348	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0034d	50		 push	 eax
  0034e	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00351	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 3153 :     }

  00356	e9 c4 00 00 00	 jmp	 $LN8@RenderRect
$LN7@RenderRect:

; 3154 :     else
; 3155 :     {
; 3156 :         draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL

  0035b	6a 03		 push	 3
  0035d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40490fdb
  00365	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _arc0_b$[ebp]
  0036a	51		 push	 ecx
  0036b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00370	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40490fdb
  00378	f3 0f 5c 45 bc	 subss	 xmm0, DWORD PTR _arc0_e$[ebp]
  0037d	51		 push	 ecx
  0037e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00383	51		 push	 ecx
  00384	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00389	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038e	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  00393	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _rounding$[ebp]
  00398	51		 push	 ecx
  00399	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039e	51		 push	 ecx
  0039f	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x0$[ebp]
  003a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a9	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  003af	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003b4	50		 push	 eax
  003b5	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  003b8	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 3157 :         draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR

  003bd	6a 03		 push	 3
  003bf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40490fdb
  003c7	f3 0f 58 45 bc	 addss	 xmm0, DWORD PTR _arc0_e$[ebp]
  003cc	51		 push	 ecx
  003cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40490fdb
  003da	f3 0f 58 45 c8	 addss	 xmm0, DWORD PTR _arc0_b$[ebp]
  003df	51		 push	 ecx
  003e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003e5	51		 push	 ecx
  003e6	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  003eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003f0	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _p0$[ebp+4]
  003f5	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  003fa	51		 push	 ecx
  003fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00400	51		 push	 ecx
  00401	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _x0$[ebp]
  00406	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0040b	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00411	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00416	50		 push	 eax
  00417	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0041a	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
$LN8@RenderRect:

; 3158 :     }
; 3159 :     if (p1.x > rect.Min.x + rounding)

  0041f	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  00422	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00426	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  0042b	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _p1$[ebp]
  00430	0f 2f c8	 comiss	 xmm1, xmm0
  00433	0f 86 4e 02 00
	00		 jbe	 $LN13@RenderRect

; 3160 :     {
; 3161 :         const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);

  00439	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0043c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00441	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _p1$[ebp]
  00446	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _inv_rounding$[ebp]
  0044b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00453	f3 0f 5c c8	 subss	 xmm1, xmm0
  00457	51		 push	 ecx
  00458	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0045d	e8 00 00 00 00	 call	 ?ImAcos01@@YAMM@Z	; ImAcos01
  00462	83 c4 04	 add	 esp, 4
  00465	d9 5d 98	 fstp	 DWORD PTR _arc1_b$15[ebp]

; 3162 :         const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);

  00468	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0046b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00470	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _p0$[ebp]
  00475	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _inv_rounding$[ebp]
  0047a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00482	f3 0f 5c c8	 subss	 xmm1, xmm0
  00486	51		 push	 ecx
  00487	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0048c	e8 00 00 00 00	 call	 ?ImAcos01@@YAMM@Z	; ImAcos01
  00491	83 c4 04	 add	 esp, 4
  00494	d9 5d 8c	 fstp	 DWORD PTR _arc1_e$14[ebp]

; 3163 :         const float x1 = ImMin(p1.x, rect.Max.x - rounding);

  00497	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0049a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0049f	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _rounding$[ebp]
  004a4	51		 push	 ecx
  004a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004aa	51		 push	 ecx
  004ab	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _p1$[ebp]
  004b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b5	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  004ba	83 c4 08	 add	 esp, 8
  004bd	d9 5d 80	 fstp	 DWORD PTR _x1$13[ebp]

; 3164 :         if (arc1_b == arc1_e)

  004c0	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _arc1_b$15[ebp]
  004c5	0f 2e 45 8c	 ucomiss xmm0, DWORD PTR _arc1_e$14[ebp]
  004c9	9f		 lahf
  004ca	f6 c4 44	 test	 ah, 68			; 00000044H
  004cd	7a 59		 jp	 SHORT $LN10@RenderRect

; 3165 :         {
; 3166 :             draw_list->PathLineTo(ImVec2(x1, p0.y));

  004cf	51		 push	 ecx
  004d0	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _p0$[ebp+4]
  004d5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004da	51		 push	 ecx
  004db	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  004e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e5	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  004eb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  004f0	50		 push	 eax
  004f1	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  004f4	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 3167 :             draw_list->PathLineTo(ImVec2(x1, p1.y));

  004f9	51		 push	 ecx
  004fa	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  004ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00504	51		 push	 ecx
  00505	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  0050a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0050f	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00515	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0051a	50		 push	 eax
  0051b	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0051e	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 3168 :         }

  00523	e9 5f 01 00 00	 jmp	 $LN13@RenderRect
$LN10@RenderRect:

; 3169 :         else if (arc1_b == 0.0f && arc1_e == half_pi)

  00528	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _arc1_b$15[ebp]
  0052d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00534	9f		 lahf
  00535	f6 c4 44	 test	 ah, 68			; 00000044H
  00538	0f 8a 97 00 00
	00		 jp	 $LN12@RenderRect
  0053e	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _arc1_e$14[ebp]
  00543	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3fc90fdb
  0054a	9f		 lahf
  0054b	f6 c4 44	 test	 ah, 68			; 00000044H
  0054e	0f 8a 81 00 00
	00		 jp	 $LN12@RenderRect

; 3170 :         {
; 3171 :             draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR

  00554	6a 0c		 push	 12			; 0000000cH
  00556	6a 09		 push	 9
  00558	51		 push	 ecx
  00559	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0055e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00563	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _p0$[ebp+4]
  00568	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  0056d	51		 push	 ecx
  0056e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00573	51		 push	 ecx
  00574	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  00579	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0057e	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00584	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00589	50		 push	 eax
  0058a	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0058d	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 3172 :             draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR

  00592	6a 03		 push	 3
  00594	6a 00		 push	 0
  00596	51		 push	 ecx
  00597	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0059c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a1	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  005a6	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _rounding$[ebp]
  005ab	51		 push	 ecx
  005ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b1	51		 push	 ecx
  005b2	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  005b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005bc	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  005c2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  005c7	50		 push	 eax
  005c8	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  005cb	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 3173 :         }

  005d0	e9 b2 00 00 00	 jmp	 $LN13@RenderRect
$LN12@RenderRect:

; 3174 :         else
; 3175 :         {
; 3176 :             draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR

  005d5	6a 03		 push	 3
  005d7	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _arc1_b$15[ebp]
  005dc	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  005e3	51		 push	 ecx
  005e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005e9	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _arc1_e$14[ebp]
  005ee	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  005f5	51		 push	 ecx
  005f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005fb	51		 push	 ecx
  005fc	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00601	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00606	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _p0$[ebp+4]
  0060b	f3 0f 58 45 1c	 addss	 xmm0, DWORD PTR _rounding$[ebp]
  00610	51		 push	 ecx
  00611	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00616	51		 push	 ecx
  00617	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  0061c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00621	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00627	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0062c	50		 push	 eax
  0062d	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00630	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 3177 :             draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR

  00635	6a 03		 push	 3
  00637	51		 push	 ecx
  00638	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _arc1_e$14[ebp]
  0063d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00642	51		 push	 ecx
  00643	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _arc1_b$15[ebp]
  00648	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0064d	51		 push	 ecx
  0064e	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00653	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00658	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  0065d	f3 0f 5c 45 1c	 subss	 xmm0, DWORD PTR _rounding$[ebp]
  00662	51		 push	 ecx
  00663	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00668	51		 push	 ecx
  00669	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _x1$13[ebp]
  0066e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00673	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00679	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0067e	50		 push	 eax
  0067f	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00682	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
$LN13@RenderRect:

; 3178 :         }
; 3179 :     }
; 3180 :     draw_list->PathFillConvex(col);

  00687	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  0068a	50		 push	 eax
  0068b	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0068e	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex
$LN1@RenderRect:

; 3181 : }

  00693	52		 push	 edx
  00694	8b cd		 mov	 ecx, ebp
  00696	50		 push	 eax
  00697	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@RenderRect
  0069d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  006a2	58		 pop	 eax
  006a3	5a		 pop	 edx
  006a4	5f		 pop	 edi
  006a5	5e		 pop	 esi
  006a6	5b		 pop	 ebx
  006a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006aa	33 cd		 xor	 ecx, ebp
  006ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006b1	81 c4 08 02 00
	00		 add	 esp, 520		; 00000208H
  006b7	3b ec		 cmp	 ebp, esp
  006b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006be	8b e5		 mov	 esp, ebp
  006c0	5d		 pop	 ebp
  006c1	c3		 ret	 0
  006c2	66 90		 npad	 2
$LN18@RenderRect:
  006c4	02 00 00 00	 DD	 2
  006c8	00 00 00 00	 DD	 $LN17@RenderRect
$LN17@RenderRect:
  006cc	f0 ff ff ff	 DD	 -16			; fffffff0H
  006d0	08 00 00 00	 DD	 8
  006d4	00 00 00 00	 DD	 $LN15@RenderRect
  006d8	e0 ff ff ff	 DD	 -32			; ffffffe0H
  006dc	08 00 00 00	 DD	 8
  006e0	00 00 00 00	 DD	 $LN16@RenderRect
$LN16@RenderRect:
  006e4	70		 DB	 112			; 00000070H
  006e5	31		 DB	 49			; 00000031H
  006e6	00		 DB	 0
$LN15@RenderRect:
  006e7	70		 DB	 112			; 00000070H
  006e8	30		 DB	 48			; 00000030H
  006e9	00		 DB	 0
?RenderRectFilledRangeH@ImGui@@YAXPAUImDrawList@@ABUImRect@@IMMM@Z ENDP ; ImGui::RenderRectFilledRangeH
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z
_TEXT	SEGMENT
tv64 = -324						; size = 4
$T1 = -316						; size = 8
$T2 = -300						; size = 8
$T3 = -284						; size = 8
$T4 = -268						; size = 8
$T5 = -252						; size = 8
$T6 = -236						; size = 8
$T7 = -220						; size = 8
$T8 = -204						; size = 8
_draw_list$ = 8						; size = 4
_pos$ = 12						; size = 8
_half_sz$ = 20						; size = 8
_direction$ = 28					; size = 4
_col$ = 32						; size = 4
?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z PROC ; ImGui::RenderArrowPointingAt, COMDAT

; 3103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd bc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-324]
  00012	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3104 :     switch (direction)

  00028	8b 45 1c	 mov	 eax, DWORD PTR _direction$[ebp]
  0002b	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00031	83 bd bc fe ff
	ff 03		 cmp	 DWORD PTR tv64[ebp], 3
  00038	0f 87 b9 01 00
	00		 ja	 $LN2@RenderArro
  0003e	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  00044	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN10@RenderArro[ecx*4]
$LN4@RenderArro:

; 3105 :     {
; 3106 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

  0004b	8b 45 20	 mov	 eax, DWORD PTR _col$[ebp]
  0004e	50		 push	 eax
  0004f	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  00052	51		 push	 ecx
  00053	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00058	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  0005d	51		 push	 ecx
  0005e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00063	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00068	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _half_sz$[ebp]
  0006d	51		 push	 ecx
  0006e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00073	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00079	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0007e	50		 push	 eax
  0007f	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00084	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  00089	51		 push	 ecx
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00094	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _half_sz$[ebp]
  00099	51		 push	 ecx
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  000a5	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000aa	50		 push	 eax
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  000ae	e8 00 00 00 00	 call	 ?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
  000b3	e9 3f 01 00 00	 jmp	 $LN1@RenderArro
$LN5@RenderArro:

; 3107 :     case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;

  000b8	8b 45 20	 mov	 eax, DWORD PTR _col$[ebp]
  000bb	50		 push	 eax
  000bc	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  000bf	51		 push	 ecx
  000c0	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  000c5	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  000ca	51		 push	 ecx
  000cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d0	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  000d5	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _half_sz$[ebp]
  000da	51		 push	 ecx
  000db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e0	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000e6	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000eb	50		 push	 eax
  000ec	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  000f1	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  000f6	51		 push	 ecx
  000f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fc	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00101	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _half_sz$[ebp]
  00106	51		 push	 ecx
  00107	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010c	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00112	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00117	50		 push	 eax
  00118	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0011b	e8 00 00 00 00	 call	 ?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
  00120	e9 d2 00 00 00	 jmp	 $LN1@RenderArro
$LN6@RenderArro:

; 3108 :     case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;

  00125	8b 45 20	 mov	 eax, DWORD PTR _col$[ebp]
  00128	50		 push	 eax
  00129	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  0012c	51		 push	 ecx
  0012d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00132	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  00137	51		 push	 ecx
  00138	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00142	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _half_sz$[ebp]
  00147	51		 push	 ecx
  00148	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014d	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00153	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00158	50		 push	 eax
  00159	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  0015e	f3 0f 58 45 18	 addss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  00163	51		 push	 ecx
  00164	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00169	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  0016e	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _half_sz$[ebp]
  00173	51		 push	 ecx
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0017f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00184	50		 push	 eax
  00185	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00188	e8 00 00 00 00	 call	 ?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
  0018d	eb 68		 jmp	 SHORT $LN1@RenderArro
$LN7@RenderArro:

; 3109 :     case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;

  0018f	8b 45 20	 mov	 eax, DWORD PTR _col$[ebp]
  00192	50		 push	 eax
  00193	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  00196	51		 push	 ecx
  00197	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  0019c	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  001a1	51		 push	 ecx
  001a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a7	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  001ac	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _half_sz$[ebp]
  001b1	51		 push	 ecx
  001b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b7	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001bd	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001c2	50		 push	 eax
  001c3	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  001c8	f3 0f 5c 45 18	 subss	 xmm0, DWORD PTR _half_sz$[ebp+4]
  001cd	51		 push	 ecx
  001ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d3	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _pos$[ebp]
  001d8	f3 0f 5c 45 14	 subss	 xmm0, DWORD PTR _half_sz$[ebp]
  001dd	51		 push	 ecx
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001e9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001ee	50		 push	 eax
  001ef	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  001f2	e8 00 00 00 00	 call	 ?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
$LN2@RenderArro:
$LN1@RenderArro:

; 3110 :     case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
; 3111 :     }
; 3112 : }

  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5b		 pop	 ebx
  001fa	81 c4 44 01 00
	00		 add	 esp, 324		; 00000144H
  00200	3b ec		 cmp	 ebp, esp
  00202	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
  0020b	90		 npad	 1
$LN10@RenderArro:
  0020c	00 00 00 00	 DD	 $LN4@RenderArro
  00210	00 00 00 00	 DD	 $LN5@RenderArro
  00214	00 00 00 00	 DD	 $LN6@RenderArro
  00218	00 00 00 00	 DD	 $LN7@RenderArro
?RenderArrowPointingAt@ImGui@@YAXPAUImDrawList@@UImVec2@@1HI@Z ENDP ; ImGui::RenderArrowPointingAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z
_TEXT	SEGMENT
$T1 = -608						; size = 8
$T2 = -592						; size = 8
$T3 = -576						; size = 8
$T4 = -560						; size = 8
$T5 = -544						; size = 8
$T6 = -528						; size = 8
$T7 = -512						; size = 8
$T8 = -496						; size = 8
$T9 = -480						; size = 8
$T10 = -464						; size = 8
$T11 = -448						; size = 8
$T12 = -432						; size = 8
$T13 = -416						; size = 8
$T14 = -400						; size = 8
$T15 = -384						; size = 8
$T16 = -368						; size = 8
$T17 = -352						; size = 8
$T18 = -336						; size = 8
$T19 = -320						; size = 8
$T20 = -304						; size = 8
_tex_id$21 = -96					; size = 4
_uv$ = -84						; size = 32
_size$ = -44						; size = 8
_offset$ = -28						; size = 8
_font_atlas$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_draw_list$ = 8						; size = 4
_pos$ = 12						; size = 8
_scale$ = 20						; size = 4
_mouse_cursor$ = 24					; size = 4
_col_fill$ = 28						; size = 4
_col_border$ = 32					; size = 4
_col_shadow$ = 36					; size = 4
?RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z PROC ; ImGui::RenderMouseCursor, COMDAT

; 3081 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 02 00
	00		 sub	 esp, 612		; 00000264H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 9c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-612]
  00012	b9 99 00 00 00	 mov	 ecx, 153		; 00000099H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3082 :     if (mouse_cursor == ImGuiMouseCursor_None)

  00032	83 7d 18 ff	 cmp	 DWORD PTR _mouse_cursor$[ebp], -1
  00036	75 05		 jne	 SHORT $LN2@RenderMous

; 3083 :         return;

  00038	e9 80 03 00 00	 jmp	 $LN1@RenderMous
$LN2@RenderMous:

; 3084 :     IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);

  0003d	83 7d 18 ff	 cmp	 DWORD PTR _mouse_cursor$[ebp], -1
  00041	7e 06		 jle	 SHORT $LN5@RenderMous
  00043	83 7d 18 09	 cmp	 DWORD PTR _mouse_cursor$[ebp], 9
  00047	7c 25		 jl	 SHORT $LN6@RenderMous
$LN5@RenderMous:
  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z@4JA
  0004e	83 c0 03	 add	 eax, 3
  00051	8b f4		 mov	 esi, esp
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@RenderMous:

; 3085 : 
; 3086 :     ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00071	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00074	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00077	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0007a	89 45 f4	 mov	 DWORD PTR _font_atlas$[ebp], eax

; 3087 :     ImVec2 offset, size, uv[4];

  0007d	8d 4d e4	 lea	 ecx, DWORD PTR _offset$[ebp]
  00080	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00085	8d 4d d4	 lea	 ecx, DWORD PTR _size$[ebp]
  00088	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  0008d	68 00 00 00 00	 push	 OFFSET ??0ImVec2@@QAE@XZ ; ImVec2::ImVec2
  00092	6a 04		 push	 4
  00094	6a 08		 push	 8
  00096	8d 45 ac	 lea	 eax, DWORD PTR _uv$[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z

; 3088 :     if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))

  0009f	b8 08 00 00 00	 mov	 eax, 8
  000a4	d1 e0		 shl	 eax, 1
  000a6	8d 4c 05 ac	 lea	 ecx, DWORD PTR _uv$[ebp+eax]
  000aa	51		 push	 ecx
  000ab	ba 08 00 00 00	 mov	 edx, 8
  000b0	6b c2 00	 imul	 eax, edx, 0
  000b3	8d 4c 05 ac	 lea	 ecx, DWORD PTR _uv$[ebp+eax]
  000b7	51		 push	 ecx
  000b8	8d 55 d4	 lea	 edx, DWORD PTR _size$[ebp]
  000bb	52		 push	 edx
  000bc	8d 45 e4	 lea	 eax, DWORD PTR _offset$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d 18	 mov	 ecx, DWORD PTR _mouse_cursor$[ebp]
  000c3	51		 push	 ecx
  000c4	8b 4d f4	 mov	 ecx, DWORD PTR _font_atlas$[ebp]
  000c7	e8 00 00 00 00	 call	 ?GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU2@1@Z ; ImFontAtlas::GetMouseCursorTexData
  000cc	0f b6 d0	 movzx	 edx, al
  000cf	85 d2		 test	 edx, edx
  000d1	0f 84 e6 02 00
	00		 je	 $LN3@RenderMous

; 3089 :     {
; 3090 :         pos -= offset;

  000d7	8d 45 e4	 lea	 eax, DWORD PTR _offset$[ebp]
  000da	50		 push	 eax
  000db	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ??Z@YAAAUImVec2@@AAU0@ABU0@@Z ; operator-=
  000e4	83 c4 08	 add	 esp, 8

; 3091 :         const ImTextureID tex_id = font_atlas->TexID;

  000e7	8b 45 f4	 mov	 eax, DWORD PTR _font_atlas$[ebp]
  000ea	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ed	89 4d a0	 mov	 DWORD PTR _tex_id$21[ebp], ecx

; 3092 :         draw_list->PushTextureID(tex_id);

  000f0	8b 45 a0	 mov	 eax, DWORD PTR _tex_id$21[ebp]
  000f3	50		 push	 eax
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  000f7	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QAEXPAX@Z ; ImDrawList::PushTextureID

; 3093 :         draw_list->AddImage(tex_id, pos + ImVec2(1,0)*scale, pos + ImVec2(1,0)*scale + size*scale, uv[2], uv[3], col_shadow);

  000fc	8b 45 24	 mov	 eax, DWORD PTR _col_shadow$[ebp]
  000ff	50		 push	 eax
  00100	b9 08 00 00 00	 mov	 ecx, 8
  00105	6b d1 03	 imul	 edx, ecx, 3
  00108	8d 44 15 ac	 lea	 eax, DWORD PTR _uv$[ebp+edx]
  0010c	50		 push	 eax
  0010d	b9 08 00 00 00	 mov	 ecx, 8
  00112	d1 e1		 shl	 ecx, 1
  00114	8d 54 0d ac	 lea	 edx, DWORD PTR _uv$[ebp+ecx]
  00118	52		 push	 edx
  00119	51		 push	 ecx
  0011a	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0011f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00124	8d 45 d4	 lea	 eax, DWORD PTR _size$[ebp]
  00127	50		 push	 eax
  00128	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH
  00137	50		 push	 eax
  00138	51		 push	 ecx
  00139	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0013e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00143	51		 push	 ecx
  00144	0f 57 c0	 xorps	 xmm0, xmm0
  00147	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014c	51		 push	 ecx
  0014d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00155	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015a	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00160	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00165	50		 push	 eax
  00166	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR $T18[ebp]
  0016c	52		 push	 edx
  0016d	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH
  00175	50		 push	 eax
  00176	8d 45 0c	 lea	 eax, DWORD PTR _pos$[ebp]
  00179	50		 push	 eax
  0017a	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00180	51		 push	 ecx
  00181	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00186	83 c4 0c	 add	 esp, 12			; 0000000cH
  00189	50		 push	 eax
  0018a	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH
  00199	50		 push	 eax
  0019a	51		 push	 ecx
  0019b	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  001a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a5	51		 push	 ecx
  001a6	0f 57 c0	 xorps	 xmm0, xmm0
  001a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ae	51		 push	 ecx
  001af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bc	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  001c2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001c7	50		 push	 eax
  001c8	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d7	50		 push	 eax
  001d8	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  001db	51		 push	 ecx
  001dc	8d 95 60 fe ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001eb	50		 push	 eax
  001ec	8b 45 a0	 mov	 eax, DWORD PTR _tex_id$21[ebp]
  001ef	50		 push	 eax
  001f0	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  001f3	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 3094 :         draw_list->AddImage(tex_id, pos + ImVec2(2,0)*scale, pos + ImVec2(2,0)*scale + size*scale, uv[2], uv[3], col_shadow);

  001f8	8b 45 24	 mov	 eax, DWORD PTR _col_shadow$[ebp]
  001fb	50		 push	 eax
  001fc	b9 08 00 00 00	 mov	 ecx, 8
  00201	6b d1 03	 imul	 edx, ecx, 3
  00204	8d 44 15 ac	 lea	 eax, DWORD PTR _uv$[ebp+edx]
  00208	50		 push	 eax
  00209	b9 08 00 00 00	 mov	 ecx, 8
  0020e	d1 e1		 shl	 ecx, 1
  00210	8d 54 0d ac	 lea	 edx, DWORD PTR _uv$[ebp+ecx]
  00214	52		 push	 edx
  00215	51		 push	 ecx
  00216	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0021b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00220	8d 45 d4	 lea	 eax, DWORD PTR _size$[ebp]
  00223	50		 push	 eax
  00224	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0022a	51		 push	 ecx
  0022b	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH
  00233	50		 push	 eax
  00234	51		 push	 ecx
  00235	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0023a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023f	51		 push	 ecx
  00240	0f 57 c0	 xorps	 xmm0, xmm0
  00243	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00248	51		 push	 ecx
  00249	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00251	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00256	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0025c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00261	50		 push	 eax
  00262	8d 95 30 fe ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  00268	52		 push	 edx
  00269	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  0026e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00271	50		 push	 eax
  00272	8d 45 0c	 lea	 eax, DWORD PTR _pos$[ebp]
  00275	50		 push	 eax
  00276	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0027c	51		 push	 ecx
  0027d	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00282	83 c4 0c	 add	 esp, 12			; 0000000cH
  00285	50		 push	 eax
  00286	8d 95 10 fe ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  0028c	52		 push	 edx
  0028d	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00292	83 c4 0c	 add	 esp, 12			; 0000000cH
  00295	50		 push	 eax
  00296	51		 push	 ecx
  00297	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  0029c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a1	51		 push	 ecx
  002a2	0f 57 c0	 xorps	 xmm0, xmm0
  002a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002aa	51		 push	 ecx
  002ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  002b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b8	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  002be	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002c3	50		 push	 eax
  002c4	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  002d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d3	50		 push	 eax
  002d4	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  002d7	51		 push	 ecx
  002d8	8d 95 e0 fd ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  002de	52		 push	 edx
  002df	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  002e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e7	50		 push	 eax
  002e8	8b 45 a0	 mov	 eax, DWORD PTR _tex_id$21[ebp]
  002eb	50		 push	 eax
  002ec	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  002ef	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 3095 :         draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[2], uv[3], col_border);

  002f4	8b 45 20	 mov	 eax, DWORD PTR _col_border$[ebp]
  002f7	50		 push	 eax
  002f8	b9 08 00 00 00	 mov	 ecx, 8
  002fd	6b d1 03	 imul	 edx, ecx, 3
  00300	8d 44 15 ac	 lea	 eax, DWORD PTR _uv$[ebp+edx]
  00304	50		 push	 eax
  00305	b9 08 00 00 00	 mov	 ecx, 8
  0030a	d1 e1		 shl	 ecx, 1
  0030c	8d 54 0d ac	 lea	 edx, DWORD PTR _uv$[ebp+ecx]
  00310	52		 push	 edx
  00311	51		 push	 ecx
  00312	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  00317	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0031c	8d 45 d4	 lea	 eax, DWORD PTR _size$[ebp]
  0031f	50		 push	 eax
  00320	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00326	51		 push	 ecx
  00327	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  0032c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032f	50		 push	 eax
  00330	8d 55 0c	 lea	 edx, DWORD PTR _pos$[ebp]
  00333	52		 push	 edx
  00334	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0033a	50		 push	 eax
  0033b	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00340	83 c4 0c	 add	 esp, 12			; 0000000cH
  00343	50		 push	 eax
  00344	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  00347	51		 push	 ecx
  00348	8b 55 a0	 mov	 edx, DWORD PTR _tex_id$21[ebp]
  0034b	52		 push	 edx
  0034c	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0034f	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 3096 :         draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[0], uv[1], col_fill);

  00354	8b 45 1c	 mov	 eax, DWORD PTR _col_fill$[ebp]
  00357	50		 push	 eax
  00358	b9 08 00 00 00	 mov	 ecx, 8
  0035d	c1 e1 00	 shl	 ecx, 0
  00360	8d 54 0d ac	 lea	 edx, DWORD PTR _uv$[ebp+ecx]
  00364	52		 push	 edx
  00365	b8 08 00 00 00	 mov	 eax, 8
  0036a	6b c8 00	 imul	 ecx, eax, 0
  0036d	8d 54 0d ac	 lea	 edx, DWORD PTR _uv$[ebp+ecx]
  00371	52		 push	 edx
  00372	51		 push	 ecx
  00373	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _scale$[ebp]
  00378	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0037d	8d 45 d4	 lea	 eax, DWORD PTR _size$[ebp]
  00380	50		 push	 eax
  00381	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00387	51		 push	 ecx
  00388	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  0038d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00390	50		 push	 eax
  00391	8d 55 0c	 lea	 edx, DWORD PTR _pos$[ebp]
  00394	52		 push	 edx
  00395	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0039b	50		 push	 eax
  0039c	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  003a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a4	50		 push	 eax
  003a5	8d 4d 0c	 lea	 ecx, DWORD PTR _pos$[ebp]
  003a8	51		 push	 ecx
  003a9	8b 55 a0	 mov	 edx, DWORD PTR _tex_id$21[ebp]
  003ac	52		 push	 edx
  003ad	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  003b0	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 3097 :         draw_list->PopTextureID();

  003b5	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  003b8	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QAEXXZ ; ImDrawList::PopTextureID
$LN3@RenderMous:
$LN1@RenderMous:

; 3098 :     }
; 3099 : }

  003bd	52		 push	 edx
  003be	8b cd		 mov	 ecx, ebp
  003c0	50		 push	 eax
  003c1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@RenderMous
  003c7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003cc	58		 pop	 eax
  003cd	5a		 pop	 edx
  003ce	5f		 pop	 edi
  003cf	5e		 pop	 esi
  003d0	5b		 pop	 ebx
  003d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d4	33 cd		 xor	 ecx, ebp
  003d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003db	81 c4 64 02 00
	00		 add	 esp, 612		; 00000264H
  003e1	3b ec		 cmp	 ebp, esp
  003e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003e8	8b e5		 mov	 esp, ebp
  003ea	5d		 pop	 ebp
  003eb	c3		 ret	 0
$LN11@RenderMous:
  003ec	03 00 00 00	 DD	 3
  003f0	00 00 00 00	 DD	 $LN10@RenderMous
$LN10@RenderMous:
  003f4	e4 ff ff ff	 DD	 -28			; ffffffe4H
  003f8	08 00 00 00	 DD	 8
  003fc	00 00 00 00	 DD	 $LN7@RenderMous
  00400	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00404	08 00 00 00	 DD	 8
  00408	00 00 00 00	 DD	 $LN8@RenderMous
  0040c	ac ff ff ff	 DD	 -84			; ffffffacH
  00410	20 00 00 00	 DD	 32			; 00000020H
  00414	00 00 00 00	 DD	 $LN9@RenderMous
$LN9@RenderMous:
  00418	75		 DB	 117			; 00000075H
  00419	76		 DB	 118			; 00000076H
  0041a	00		 DB	 0
$LN8@RenderMous:
  0041b	73		 DB	 115			; 00000073H
  0041c	69		 DB	 105			; 00000069H
  0041d	7a		 DB	 122			; 0000007aH
  0041e	65		 DB	 101			; 00000065H
  0041f	00		 DB	 0
$LN7@RenderMous:
  00420	6f		 DB	 111			; 0000006fH
  00421	66		 DB	 102			; 00000066H
  00422	66		 DB	 102			; 00000066H
  00423	73		 DB	 115			; 00000073H
  00424	65		 DB	 101			; 00000065H
  00425	74		 DB	 116			; 00000074H
  00426	00		 DB	 0
?RenderMouseCursor@ImGui@@YAXPAUImDrawList@@UImVec2@@MHIII@Z ENDP ; ImGui::RenderMouseCursor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ??0ImDrawListSharedData@@QAE@XZ
_TEXT	SEGMENT
$T1 = -264						; size = 8
$T2 = -248						; size = 16
_a$3 = -32						; size = 4
_i$4 = -20						; size = 4
_this$ = -8						; size = 4
??0ImDrawListSharedData@@QAE@XZ PROC			; ImDrawListSharedData::ImDrawListSharedData, COMDAT
; _this$ = ecx

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00013	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 14	 add	 ecx, 20			; 00000014H
  0003b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@XZ	; ImVec4::ImVec4
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h

; 853  :     ImDrawListFlags InitialFlags;               // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

  00040	68 00 00 00 00	 push	 OFFSET ??0ImVec2@@QAE@XZ ; ImVec2::ImVec2
  00045	6a 0c		 push	 12			; 0000000cH
  00047	6a 08		 push	 8
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	83 c0 28	 add	 eax, 40			; 00000028H
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp

; 348  :     Font = NULL;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 349  :     FontSize = 0.0f;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	0f 57 c0	 xorps	 xmm0, xmm0
  00065	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 350  :     CurveTessellationTol = 0.0f;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	0f 57 c0	 xorps	 xmm0, xmm0
  00070	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 351  :     ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);

  00075	51		 push	 ecx
  00076	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46000000
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	51		 push	 ecx
  00084	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46000000
  0008c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00091	51		 push	 ecx
  00092	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c6000000
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	51		 push	 ecx
  000a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c6000000
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b3	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	83 c1 14	 add	 ecx, 20			; 00000014H
  000be	8b 10		 mov	 edx, DWORD PTR [eax]
  000c0	89 11		 mov	 DWORD PTR [ecx], edx
  000c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000c8	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000cb	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000ce	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000d1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 352  :     InitialFlags = ImDrawListFlags_None;

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 353  : 
; 354  :     // Const data
; 355  :     for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)

  000de	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  000e5	eb 09		 jmp	 SHORT $LN4@ImDrawList
$LN2@ImDrawList:
  000e7	8b 45 ec	 mov	 eax, DWORD PTR _i$4[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 45 ec	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@ImDrawList:
  000f0	83 7d ec 0c	 cmp	 DWORD PTR _i$4[ebp], 12	; 0000000cH
  000f4	7d 68		 jge	 SHORT $LN3@ImDrawList

; 356  :     {
; 357  :         const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);

  000f6	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _i$4[ebp]
  000fb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00103	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  0010b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41400000
  00113	f3 0f 11 45 e0	 movss	 DWORD PTR _a$3[ebp], xmm0

; 358  :         CircleVtx12[i] = ImVec2(ImCos(a), ImSin(a));

  00118	51		 push	 ecx
  00119	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _a$3[ebp]
  0011e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00123	e8 00 00 00 00	 call	 ?ImSin@@YAMM@Z		; ImSin
  00128	d9 1c 24	 fstp	 DWORD PTR [esp]
  0012b	51		 push	 ecx
  0012c	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _a$3[ebp]
  00131	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00136	e8 00 00 00 00	 call	 ?ImCos@@YAMM@Z		; ImCos
  0013b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0013e	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00144	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0014e	8b 45 ec	 mov	 eax, DWORD PTR _i$4[ebp]
  00151	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00154	89 4c c6 28	 mov	 DWORD PTR [esi+eax*8+40], ecx
  00158	89 54 c6 2c	 mov	 DWORD PTR [esi+eax*8+44], edx

; 359  :     }

  0015c	eb 89		 jmp	 SHORT $LN2@ImDrawList
$LN3@ImDrawList:

; 360  : }

  0015e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx
  00164	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  0016a	3b ec		 cmp	 ebp, esp
  0016c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
??0ImDrawListSharedData@@QAE@XZ ENDP			; ImDrawListSharedData::ImDrawListSharedData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1ImBoolVector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1ImBoolVector@@QAE@XZ PROC				; ImBoolVector::~ImBoolVector, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$ImVector@H@@QAE@XZ	; ImVector<int>::~ImVector<int>
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1ImBoolVector@@QAE@XZ ENDP				; ImBoolVector::~ImBoolVector
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?SetBit@ImBoolVector@@QAEXH_N@Z
_TEXT	SEGMENT
tv80 = -232						; size = 4
tv73 = -232						; size = 4
_mask$ = -32						; size = 4
_off$ = -20						; size = 4
_this$ = -8						; size = 4
_n$ = 8							; size = 4
_v$ = 12						; size = 1
?SetBit@ImBoolVector@@QAEXH_N@Z PROC			; ImBoolVector::SetBit, COMDAT
; _this$ = ecx

; 357  :     void            SetBit(int n, bool v)   { int off = (n >> 5); int mask = 1 << (n & 31); if (v) Storage[off] |= mask; else Storage[off] &= ~mask; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00030	c1 f8 05	 sar	 eax, 5
  00033	89 45 ec	 mov	 DWORD PTR _off$[ebp], eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00039	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	d3 e0		 shl	 eax, cl
  00043	89 45 e0	 mov	 DWORD PTR _mask$[ebp], eax
  00046	0f b6 45 0c	 movzx	 eax, BYTE PTR _v$[ebp]
  0004a	85 c0		 test	 eax, eax
  0004c	74 27		 je	 SHORT $LN2@SetBit
  0004e	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  00051	50		 push	 eax
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??A?$ImVector@H@@QAEAAHH@Z ; ImVector<int>::operator[]
  0005a	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  00060	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	0b 55 e0	 or	 edx, DWORD PTR _mask$[ebp]
  0006b	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  00071	89 10		 mov	 DWORD PTR [eax], edx
  00073	eb 27		 jmp	 SHORT $LN1@SetBit
$LN2@SetBit:
  00075	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  00078	50		 push	 eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ??A?$ImVector@H@@QAEAAHH@Z ; ImVector<int>::operator[]
  00081	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  00087	8b 4d e0	 mov	 ecx, DWORD PTR _mask$[ebp]
  0008a	f7 d1		 not	 ecx
  0008c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv80[ebp]
  00092	23 0a		 and	 ecx, DWORD PTR [edx]
  00094	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@SetBit:
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?SetBit@ImBoolVector@@QAEXH_N@Z ENDP			; ImBoolVector::SetBit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?GetBit@ImBoolVector@@QBE_NH@Z
_TEXT	SEGMENT
tv73 = -232						; size = 4
_mask$ = -32						; size = 4
_off$ = -20						; size = 4
_this$ = -8						; size = 4
_n$ = 8							; size = 4
?GetBit@ImBoolVector@@QBE_NH@Z PROC			; ImBoolVector::GetBit, COMDAT
; _this$ = ecx

; 356  :     bool            GetBit(int n) const     { int off = (n >> 5); int mask = 1 << (n & 31); return (Storage[off] & mask) != 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00030	c1 f8 05	 sar	 eax, 5
  00033	89 45 ec	 mov	 DWORD PTR _off$[ebp], eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00039	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	d3 e0		 shl	 eax, cl
  00043	89 45 e0	 mov	 DWORD PTR _mask$[ebp], eax
  00046	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??A?$ImVector@H@@QBEABHH@Z ; ImVector<int>::operator[]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	23 4d e0	 and	 ecx, DWORD PTR _mask$[ebp]
  00057	74 0c		 je	 SHORT $LN3@GetBit
  00059	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv73[ebp], 1
  00063	eb 0a		 jmp	 SHORT $LN4@GetBit
$LN3@GetBit:
  00065	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN4@GetBit:
  0006f	8a 85 18 ff ff
	ff		 mov	 al, BYTE PTR tv73[ebp]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?GetBit@ImBoolVector@@QBE_NH@Z ENDP			; ImBoolVector::GetBit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Clear@ImBoolVector@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@ImBoolVector@@QAEXXZ PROC			; ImBoolVector::Clear, COMDAT
; _this$ = ecx

; 355  :     void            Clear()                 { Storage.clear(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?clear@?$ImVector@H@@QAEXXZ ; ImVector<int>::clear
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?Clear@ImBoolVector@@QAEXXZ ENDP			; ImBoolVector::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?Resize@ImBoolVector@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?Resize@ImBoolVector@@QAEXH@Z PROC			; ImBoolVector::Resize, COMDAT
; _this$ = ecx

; 354  :     void            Resize(int sz)          { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _sz$[ebp]
  00030	83 c0 1f	 add	 eax, 31			; 0000001fH
  00033	c1 f8 05	 sar	 eax, 5
  00036	50		 push	 eax
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?resize@?$ImVector@H@@QAEXH@Z ; ImVector<int>::resize
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	c1 e1 02	 shl	 ecx, 2
  00047	51		 push	 ecx
  00048	6a 00		 push	 0
  0004a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _memset
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?Resize@ImBoolVector@@QAEXH@Z ENDP			; ImBoolVector::Resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@H@@QAEXABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@H@@QAEXABH@Z PROC			; ImVector<int>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@H@@QBEHH@Z ; ImVector<int>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@H@@QAEXH@Z ; ImVector<int>::reserve
$LN2@push_back:
  00054	6a 04		 push	 4
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@H@@QAEXABH@Z ENDP			; ImVector<int>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@H@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@H@@QAEXH@Z PROC			; ImVector<int>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 02	 shl	 eax, 2
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 02	 shl	 ecx, 2
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@H@@QAEXH@Z ENDP			; ImVector<int>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@H@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@H@@QAEXH@Z PROC			; ImVector<int>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@H@@QBEHH@Z ; ImVector<int>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@H@@QAEXH@Z ; ImVector<int>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@H@@QAEXH@Z ENDP			; ImVector<int>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@H@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@H@@QBEHH@Z PROC		; ImVector<int>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@H@@QBEHH@Z ENDP		; ImVector<int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?end@?$ImVector@H@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?end@?$ImVector@H@@QBEPBHXZ PROC			; ImVector<int>::end, COMDAT
; _this$ = ecx

; 1279 :     inline const T*     end() const                         { return Data + Size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00038	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?end@?$ImVector@H@@QBEPBHXZ ENDP			; ImVector<int>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?begin@?$ImVector@H@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?begin@?$ImVector@H@@QBEPBHXZ PROC			; ImVector<int>::begin, COMDAT
; _this$ = ecx

; 1277 :     inline const T*     begin() const                       { return Data; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?begin@?$ImVector@H@@QBEPBHXZ ENDP			; ImVector<int>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@H@@QAEXXZ PROC			; ImVector<int>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@H@@QAEXXZ ENDP			; ImVector<int>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@H@@QBEABHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@H@@QBEABHH@Z PROC				; ImVector<int>::operator[], COMDAT
; _this$ = ecx

; 1273 :     inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f9 04 00 00	 push	 1273			; 000004f9H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@H@@QBEABHH@Z ENDP				; ImVector<int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@H@@QAEAAHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@H@@QAEAAHH@Z PROC				; ImVector<int>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@H@@QAEAAHH@Z ENDP				; ImVector<int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@H@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@H@@QBE_NXZ PROC			; ImVector<int>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@H@@QBE_NXZ ENDP			; ImVector<int>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@H@@QAE@XZ PROC				; ImVector<int>::~ImVector<int>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@H@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@H@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@H@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@H@@QAE@XZ ENDP				; ImVector<int>::~ImVector<int>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImMul@@YA?AUImVec2@@ABU1@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
?ImMul@@YA?AUImVec2@@ABU1@0@Z PROC			; ImMul, COMDAT

; 338  : static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [ecx+4]
  00038	51		 push	 ecx
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00041	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00044	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00048	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?ImMul@@YA?AUImVec2@@ABU1@0@Z ENDP			; ImMul
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMax@M@@YAMMM@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>, COMDAT

; 315  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _lhs$[ebp]
  0002d	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _rhs$[ebp]
  00031	72 0f		 jb	 SHORT $LN3@ImMax
  00033	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _lhs$[ebp]
  00038	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
  00040	eb 0d		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  00042	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rhs$[ebp]
  00047	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
$LN4@ImMax:
  0004f	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv65[ebp]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??$ImMin@M@@YAMMM@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>, COMDAT

; 314  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rhs$[ebp]
  0002d	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _lhs$[ebp]
  00031	76 0f		 jbe	 SHORT $LN3@ImMin
  00033	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _lhs$[ebp]
  00038	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
  00040	eb 0d		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  00042	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rhs$[ebp]
  00047	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv65[ebp], xmm0
$LN4@ImMin:
  0004f	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv65[ebp]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImDot@@YAMABUImVec2@@0@Z
_TEXT	SEGMENT
tv79 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?ImDot@@YAMABUImVec2@@0@Z PROC				; ImDot, COMDAT

; 335  : static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00032	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  00036	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00039	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0003c	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00041	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00046	f3 0f 58 c1	 addss	 xmm0, xmm1
  0004a	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv79[ebp], xmm0
  00052	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv79[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?ImDot@@YAMABUImVec2@@0@Z ENDP				; ImDot
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImFloor@@YAMM@Z
_TEXT	SEGMENT
tv68 = -200						; size = 4
tv67 = -196						; size = 4
_f$ = 8							; size = 4
?ImFloor@@YAMM@Z PROC					; ImFloor, COMDAT

; 332  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	f3 0f 2c 45 08	 cvttss2si eax, DWORD PTR _f$[ebp]
  0002d	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  00033	db 85 3c ff ff
	ff		 fild	 DWORD PTR tv67[ebp]
  00039	d9 9d 38 ff ff
	ff		 fstp	 DWORD PTR tv68[ebp]
  0003f	d9 85 38 ff ff
	ff		 fld	 DWORD PTR tv68[ebp]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImLengthSqr@@YAMABUImVec2@@@Z
_TEXT	SEGMENT
tv79 = -196						; size = 4
_lhs$ = 8						; size = 4
?ImLengthSqr@@YAMABUImVec2@@@Z PROC			; ImLengthSqr, COMDAT

; 329  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00032	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  00036	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00039	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0003c	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00041	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00046	f3 0f 58 c1	 addss	 xmm0, xmm1
  0004a	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv79[ebp], xmm0
  00052	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv79[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?ImLengthSqr@@YAMABUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
_t$ = 20						; size = 4
?ImLerp@@YA?AUImVec4@@ABU1@0M@Z PROC			; ImLerp, COMDAT

; 327  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  0002e	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00033	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]
  00038	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _t$[ebp]
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]
  00040	f3 0f 58 42 0c	 addss	 xmm0, DWORD PTR [edx+12]
  00045	51		 push	 ecx
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00051	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00056	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0005b	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _t$[ebp]
  00060	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]
  00063	f3 0f 58 42 08	 addss	 xmm0, DWORD PTR [edx+8]
  00068	51		 push	 ecx
  00069	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006e	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  00071	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00074	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00079	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0007e	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _t$[ebp]
  00083	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]
  00086	f3 0f 58 42 04	 addss	 xmm0, DWORD PTR [edx+4]
  0008b	51		 push	 ecx
  0008c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00091	8b 45 10	 mov	 eax, DWORD PTR _b$[ebp]
  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _a$[ebp]
  00097	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0009b	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0009f	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _t$[ebp]
  000a4	8b 55 0c	 mov	 edx, DWORD PTR _a$[ebp]
  000a7	f3 0f 58 02	 addss	 xmm0, DWORD PTR [edx]
  000ab	51		 push	 ecx
  000ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b4	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  000b9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000c5	3b ec		 cmp	 ebp, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImClamp@@YA?AUImVec2@@ABU1@0U1@@Z
_TEXT	SEGMENT
tv83 = -208						; size = 4
tv84 = -204						; size = 4
tv73 = -200						; size = 4
tv74 = -196						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
_mn$ = 16						; size = 4
_mx$ = 20						; size = 8
?ImClamp@@YA?AUImVec2@@ABU1@0U1@@Z PROC			; ImClamp, COMDAT

; 324  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _mn$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  00037	76 12		 jbe	 SHORT $LN5@ImClamp
  00039	8b 55 10	 mov	 edx, DWORD PTR _mn$[ebp]
  0003c	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00041	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
  00049	eb 3d		 jmp	 SHORT $LN6@ImClamp
$LN5@ImClamp:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0004e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00053	0f 2f 45 18	 comiss	 xmm0, DWORD PTR _mx$[ebp+4]
  00057	76 0f		 jbe	 SHORT $LN3@ImClamp
  00059	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _mx$[ebp+4]
  0005e	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv73[ebp], xmm0
  00066	eb 10		 jmp	 SHORT $LN4@ImClamp
$LN3@ImClamp:
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0006b	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00070	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv73[ebp], xmm0
$LN4@ImClamp:
  00078	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv73[ebp]
  00080	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
$LN6@ImClamp:
  00088	8b 55 10	 mov	 edx, DWORD PTR _mn$[ebp]
  0008b	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0008e	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00092	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00095	76 11		 jbe	 SHORT $LN9@ImClamp
  00097	8b 4d 10	 mov	 ecx, DWORD PTR _mn$[ebp]
  0009a	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0009e	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR tv84[ebp], xmm0
  000a6	eb 3b		 jmp	 SHORT $LN10@ImClamp
$LN9@ImClamp:
  000a8	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  000ab	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  000af	0f 2f 45 14	 comiss	 xmm0, DWORD PTR _mx$[ebp]
  000b3	76 0f		 jbe	 SHORT $LN7@ImClamp
  000b5	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _mx$[ebp]
  000ba	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv83[ebp], xmm0
  000c2	eb 0f		 jmp	 SHORT $LN8@ImClamp
$LN7@ImClamp:
  000c4	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  000c7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000cb	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR tv83[ebp], xmm0
$LN8@ImClamp:
  000d3	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR tv83[ebp]
  000db	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR tv84[ebp], xmm0
$LN10@ImClamp:
  000e3	51		 push	 ecx
  000e4	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv74[ebp]
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	51		 push	 ecx
  000f2	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR tv84[ebp]
  000fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00102	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00107	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00113	3b ec		 cmp	 ebp, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?ImClamp@@YA?AUImVec2@@ABU1@0U1@@Z ENDP			; ImClamp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImMax@@YA?AUImVec2@@ABU1@0@Z
_TEXT	SEGMENT
tv78 = -200						; size = 4
tv71 = -196						; size = 4
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
?ImMax@@YA?AUImVec2@@ABU1@0@Z PROC			; ImMax, COMDAT

; 323  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  00037	72 12		 jb	 SHORT $LN3@ImMax
  00039	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003c	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00041	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
  00049	eb 10		 jmp	 SHORT $LN4@ImMax
$LN3@ImMax:
  0004b	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  0004e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00053	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
$LN4@ImMax:
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0005e	8b 55 10	 mov	 edx, DWORD PTR _rhs$[ebp]
  00061	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00065	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  00068	72 11		 jb	 SHORT $LN5@ImMax
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0006d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00071	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
  00079	eb 0f		 jmp	 SHORT $LN6@ImMax
$LN5@ImMax:
  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0007e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00082	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
$LN6@ImMax:
  0008a	51		 push	 ecx
  0008b	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv71[ebp]
  00093	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00098	51		 push	 ecx
  00099	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv78[ebp]
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ae	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?ImMax@@YA?AUImVec2@@ABU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImMin@@YA?AUImVec2@@ABU1@0@Z
_TEXT	SEGMENT
tv78 = -200						; size = 4
tv71 = -196						; size = 4
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
?ImMin@@YA?AUImVec2@@ABU1@0@Z PROC			; ImMin, COMDAT

; 322  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	0f 2f 41 04	 comiss	 xmm0, DWORD PTR [ecx+4]
  00037	76 12		 jbe	 SHORT $LN3@ImMin
  00039	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  0003c	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00041	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
  00049	eb 10		 jmp	 SHORT $LN4@ImMin
$LN3@ImMin:
  0004b	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  0004e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00053	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR tv71[ebp], xmm0
$LN4@ImMin:
  0005b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00061	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00065	0f 2f 02	 comiss	 xmm0, DWORD PTR [edx]
  00068	76 11		 jbe	 SHORT $LN5@ImMin
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0006d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00071	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
  00079	eb 0f		 jmp	 SHORT $LN6@ImMin
$LN5@ImMin:
  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0007e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00082	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
$LN6@ImMin:
  0008a	51		 push	 ecx
  0008b	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv71[ebp]
  00093	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00098	51		 push	 ecx
  00099	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR tv78[ebp]
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a9	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000ae	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?ImMin@@YA?AUImVec2@@ABU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImCeil@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImCeil@@YAMM@Z PROC					; ImCeil, COMDAT

; 310  : static inline float  ImCeil(float x)                                            { return ceilf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _ceilf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImCeil@@YAMM@Z ENDP					; ImCeil
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImFloorStd@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImFloorStd@@YAMM@Z PROC				; ImFloorStd, COMDAT

; 309  : static inline float  ImFloorStd(float x)                                        { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _floorf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImFloorStd@@YAMM@Z ENDP				; ImFloorStd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImAcos@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImAcos@@YAMM@Z PROC					; ImAcos, COMDAT

; 306  : static inline float  ImAcos(float x)                                            { return acosf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _acosf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImAcos@@YAMM@Z ENDP					; ImAcos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImSin@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImSin@@YAMM@Z PROC					; ImSin, COMDAT

; 305  : static inline float  ImSin(float x)                                             { return sinf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _sinf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImSin@@YAMM@Z ENDP					; ImSin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImCos@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImCos@@YAMM@Z PROC					; ImCos, COMDAT

; 304  : static inline float  ImCos(float x)                                             { return cosf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _cosf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImCos@@YAMM@Z ENDP					; ImCos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImSqrt@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImSqrt@@YAMM@Z PROC					; ImSqrt, COMDAT

; 299  : static inline float  ImSqrt(float x)                                            { return sqrtf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _sqrtf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImSqrt@@YAMM@Z ENDP					; ImSqrt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImFabs@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ImFabs@@YAMM@Z PROC					; ImFabs, COMDAT

; 298  : static inline float  ImFabs(float x)                                            { return fabsf(x); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	e8 00 00 00 00	 call	 _fabsf
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ImFabs@@YAMM@Z ENDP					; ImFabs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??Z@YAAAUImVec2@@AAU0@ABU0@@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??Z@YAAAUImVec2@@AAU0@ABU0@@Z PROC			; operator-=, COMDAT

; 261  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00032	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00036	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00039	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
  0003d	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00043	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00048	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _lhs$[ebp]
  00050	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
  00055	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??Z@YAAAUImVec2@@AAU0@ABU0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??D@YA?AUImVec2@@ABU0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??D@YA?AUImVec2@@ABU0@0@Z PROC				; operator*, COMDAT

; 258  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [ecx+4]
  00038	51		 push	 ecx
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00041	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00044	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00048	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
??D@YA?AUImVec2@@ABU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??G@YA?AUImVec2@@ABU0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??G@YA?AUImVec2@@ABU0@0@Z PROC				; operator-, COMDAT

; 257  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00038	51		 push	 ecx
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00041	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00044	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00048	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
??G@YA?AUImVec2@@ABU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??H@YA?AUImVec2@@ABU0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??H@YA?AUImVec2@@ABU0@0@Z PROC				; operator+, COMDAT

; 256  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00033	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00038	51		 push	 ecx
  00039	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _lhs$[ebp]
  00041	8b 45 10	 mov	 eax, DWORD PTR _rhs$[ebp]
  00044	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00048	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
??H@YA?AUImVec2@@ABU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ??D@YA?AUImVec2@@ABU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??D@YA?AUImVec2@@ABU0@M@Z PROC				; operator*, COMDAT

; 254  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 0c	 mov	 eax, DWORD PTR _lhs$[ebp]
  0002b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00030	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _rhs$[ebp]
  00035	51		 push	 ecx
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0003e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00042	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _rhs$[ebp]
  00047	51		 push	 ecx
  00048	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??D@YA?AUImVec2@@ABU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankW@@YA_NI@Z
_TEXT	SEGMENT
tv67 = -196						; size = 4
_c$ = 8							; size = 4
?ImCharIsBlankW@@YA_NI@Z PROC				; ImCharIsBlankW, COMDAT

; 240  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	83 7d 08 20	 cmp	 DWORD PTR _c$[ebp], 32	; 00000020H
  0002c	74 1b		 je	 SHORT $LN3@ImCharIsBl
  0002e	83 7d 08 09	 cmp	 DWORD PTR _c$[ebp], 9
  00032	74 15		 je	 SHORT $LN3@ImCharIsBl
  00034	81 7d 08 00 30
	00 00		 cmp	 DWORD PTR _c$[ebp], 12288 ; 00003000H
  0003b	74 0c		 je	 SHORT $LN3@ImCharIsBl
  0003d	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00047	eb 0a		 jmp	 SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
  00049	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
$LN4@ImCharIsBl:
  00053	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv67[ebp]
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?ImCharIsBlankW@@YA_NI@Z ENDP				; ImCharIsBlankW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankA@@YA_ND@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_c$ = 8							; size = 1
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA, COMDAT

; 239  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f be 45 08	 movsx	 eax, BYTE PTR _c$[ebp]
  0002c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0002f	74 15		 je	 SHORT $LN3@ImCharIsBl
  00031	0f be 4d 08	 movsx	 ecx, BYTE PTR _c$[ebp]
  00035	83 f9 09	 cmp	 ecx, 9
  00038	74 0c		 je	 SHORT $LN3@ImCharIsBl
  0003a	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00044	eb 0a		 jmp	 SHORT $LN4@ImCharIsBl
$LN3@ImCharIsBl:
  00046	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
$LN4@ImCharIsBl:
  00050	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv68[ebp]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_internal.h
;	COMDAT ?ImUpperPowerOfTwo@@YAHH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?ImUpperPowerOfTwo@@YAHH@Z PROC				; ImUpperPowerOfTwo, COMDAT

; 218  : static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __71512A68_imgui_internal@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	83 e8 01	 sub	 eax, 1
  0002e	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  00031	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00034	d1 f8		 sar	 eax, 1
  00036	0b 45 08	 or	 eax, DWORD PTR _v$[ebp]
  00039	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  0003c	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0003f	c1 f8 02	 sar	 eax, 2
  00042	0b 45 08	 or	 eax, DWORD PTR _v$[ebp]
  00045	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  00048	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	0b 45 08	 or	 eax, DWORD PTR _v$[ebp]
  00051	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  00054	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00057	c1 f8 08	 sar	 eax, 8
  0005a	0b 45 08	 or	 eax, DWORD PTR _v$[ebp]
  0005d	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  00060	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00063	c1 f8 10	 sar	 eax, 16			; 00000010H
  00066	0b 45 08	 or	 eax, DWORD PTR _v$[ebp]
  00069	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  0006c	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 08	 mov	 DWORD PTR _v$[ebp], eax
  00075	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?ImUpperPowerOfTwo@@YAHH@Z ENDP				; ImUpperPowerOfTwo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 760  :             return (float)sqrt(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sqrt
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 761  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 749  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 750  :             return (float)sin(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _sin
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 751  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv74 = -196						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 685  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 686  :             return (float)floor(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	8b f4		 mov	 esi, esp
  0002f	83 ec 08	 sub	 esp, 8
  00032	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__floor
  0003d	83 c4 08	 add	 esp, 8
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv74[ebp]
  0004d	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv74[ebp]

; 687  :         }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 671  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 672  :             return (float)fabs(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _fabs
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 673  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 648  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 649  :             return (float)cos(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _cos
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 650  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv74 = -196						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 643  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 644  :             return (float)ceil(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	8b f4		 mov	 esi, esp
  0002f	83 ec 08	 sub	 esp, 8
  00032	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ceil
  0003d	83 c4 08	 add	 esp, 8
  00040	3b f4		 cmp	 esi, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv74[ebp]
  0004d	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv74[ebp]

; 645  :         }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_ceilf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 623  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __E2865EBA_corecrt_math@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 624  :             return (float)acos(_X);

  00028	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0002d	83 ec 08	 sub	 esp, 8
  00030	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00035	e8 00 00 00 00	 call	 _acos
  0003a	83 c4 08	 add	 esp, 8
  0003d	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv72[ebp]
  00043	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv72[ebp]

; 625  :         }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_acosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GImFont@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GImFont@@QAEPAXI@Z PROC				; ImFont::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1ImFont@@QAE@XZ	; ImFont::~ImFont
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0e		 je	 SHORT $LN2@scalar
  00033	6a 5c		 push	 92			; 0000005cH
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003e	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
??_GImFont@@QAEPAXI@Z ENDP				; ImFont::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?SetFallbackChar@ImFont@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$ = 8							; size = 2
?SetFallbackChar@ImFont@@QAEXG@Z PROC			; ImFont::SetFallbackChar, COMDAT
; _this$ = ecx

; 2601 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2602 :     FallbackChar = c;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	66 8b 4d 08	 mov	 cx, WORD PTR _c$[ebp]
  00034	66 89 48 42	 mov	 WORD PTR [eax+66], cx

; 2603 :     BuildLookupTable();

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?BuildLookupTable@ImFont@@QAEXXZ ; ImFont::BuildLookupTable

; 2604 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?SetFallbackChar@ImFont@@QAEXG@Z ENDP			; ImFont::SetFallbackChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddRemapChar@ImFont@@QAEXGG_N@Z
_TEXT	SEGMENT
tv150 = -220						; size = 4
tv137 = -218						; size = 2
_index_size$ = -20					; size = 4
_this$ = -8						; size = 4
_dst$ = 8						; size = 2
_src$ = 12						; size = 2
_overwrite_dst$ = 16					; size = 1
?AddRemapChar@ImFont@@QAEXGG_N@Z PROC			; ImFont::AddRemapChar, COMDAT
; _this$ = ecx

; 2641 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2642 :     IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00034	7f 26		 jg	 SHORT $LN5@AddRemapCh
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??AddRemapChar@ImFont@@QAEXGG_N@Z@4JA
  0003c	83 c1 01	 add	 ecx, 1
  0003f	8b f4		 mov	 esi, esp
  00041	51		 push	 ecx
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@OHOOGJPG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAL?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?4?$AAS?$AAi?$AAz@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@AddRemapCh:

; 2643 :     unsigned int index_size = (unsigned int)IndexLookup.Size;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00062	89 4d ec	 mov	 DWORD PTR _index_size$[ebp], ecx

; 2644 : 
; 2645 :     if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists

  00065	0f b7 45 08	 movzx	 eax, WORD PTR _dst$[ebp]
  00069	3b 45 ec	 cmp	 eax, DWORD PTR _index_size$[ebp]
  0006c	73 22		 jae	 SHORT $LN2@AddRemapCh
  0006e	0f b7 45 08	 movzx	 eax, WORD PTR _dst$[ebp]
  00072	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00078	0f b7 04 42	 movzx	 eax, WORD PTR [edx+eax*2]
  0007c	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00081	75 0d		 jne	 SHORT $LN2@AddRemapCh
  00083	0f b6 45 10	 movzx	 eax, BYTE PTR _overwrite_dst$[ebp]
  00087	85 c0		 test	 eax, eax
  00089	75 05		 jne	 SHORT $LN2@AddRemapCh

; 2646 :         return;

  0008b	e9 b8 00 00 00	 jmp	 $LN1@AddRemapCh
$LN2@AddRemapCh:

; 2647 :     if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op

  00090	0f b7 45 0c	 movzx	 eax, WORD PTR _src$[ebp]
  00094	3b 45 ec	 cmp	 eax, DWORD PTR _index_size$[ebp]
  00097	72 0e		 jb	 SHORT $LN3@AddRemapCh
  00099	0f b7 45 08	 movzx	 eax, WORD PTR _dst$[ebp]
  0009d	3b 45 ec	 cmp	 eax, DWORD PTR _index_size$[ebp]
  000a0	72 05		 jb	 SHORT $LN3@AddRemapCh

; 2648 :         return;

  000a2	e9 a1 00 00 00	 jmp	 $LN1@AddRemapCh
$LN3@AddRemapCh:

; 2649 : 
; 2650 :     GrowIndex(dst + 1);

  000a7	0f b7 45 08	 movzx	 eax, WORD PTR _dst$[ebp]
  000ab	83 c0 01	 add	 eax, 1
  000ae	50		 push	 eax
  000af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?GrowIndex@ImFont@@QAEXH@Z ; ImFont::GrowIndex

; 2651 :     IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;

  000b7	0f b7 45 0c	 movzx	 eax, WORD PTR _src$[ebp]
  000bb	3b 45 ec	 cmp	 eax, DWORD PTR _index_size$[ebp]
  000be	73 17		 jae	 SHORT $LN6@AddRemapCh
  000c0	0f b7 4d 0c	 movzx	 ecx, WORD PTR _src$[ebp]
  000c4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000ca	66 8b 0c 48	 mov	 cx, WORD PTR [eax+ecx*2]
  000ce	66 89 8d 26 ff
	ff ff		 mov	 WORD PTR tv137[ebp], cx
  000d5	eb 0c		 jmp	 SHORT $LN7@AddRemapCh
$LN6@AddRemapCh:
  000d7	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000dc	66 89 95 26 ff
	ff ff		 mov	 WORD PTR tv137[ebp], dx
$LN7@AddRemapCh:
  000e3	0f b7 45 08	 movzx	 eax, WORD PTR _dst$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	83 c1 14	 add	 ecx, 20			; 00000014H
  000ee	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  000f3	66 8b 8d 26 ff
	ff ff		 mov	 cx, WORD PTR tv137[ebp]
  000fa	66 89 08	 mov	 WORD PTR [eax], cx

; 2652 :     IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;

  000fd	0f b7 45 0c	 movzx	 eax, WORD PTR _src$[ebp]
  00101	3b 45 ec	 cmp	 eax, DWORD PTR _index_size$[ebp]
  00104	73 19		 jae	 SHORT $LN8@AddRemapCh
  00106	0f b7 4d 0c	 movzx	 ecx, WORD PTR _src$[ebp]
  0010a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00110	f3 0f 10 04 88	 movss	 xmm0, DWORD PTR [eax+ecx*4]
  00115	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv150[ebp], xmm0
  0011d	eb 10		 jmp	 SHORT $LN9@AddRemapCh
$LN8@AddRemapCh:
  0011f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00127	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR tv150[ebp], xmm0
$LN9@AddRemapCh:
  0012f	0f b7 4d 08	 movzx	 ecx, WORD PTR _dst$[ebp]
  00133	51		 push	 ecx
  00134	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QAEAAMH@Z ; ImVector<float>::operator[]
  0013c	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR tv150[ebp]
  00144	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN1@AddRemapCh:

; 2653 : }

  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx
  0014b	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00151	3b ec		 cmp	 ebp, esp
  00153	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 0c 00	 ret	 12			; 0000000cH
?AddRemapChar@ImFont@@QAEXGG_N@Z ENDP			; ImFont::AddRemapChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddGlyph@ImFont@@QAEXGMMMMMMMMM@Z
_TEXT	SEGMENT
_glyph$ = -20						; size = 4
_this$ = -8						; size = 4
_codepoint$ = 8						; size = 2
_x0$ = 12						; size = 4
_y0$ = 16						; size = 4
_x1$ = 20						; size = 4
_y1$ = 24						; size = 4
_u0$ = 28						; size = 4
_v0$ = 32						; size = 4
_u1$ = 36						; size = 4
_v1$ = 40						; size = 4
_advance_x$ = 44					; size = 4
?AddGlyph@ImFont@@QAEXGMMMMMMMMM@Z PROC			; ImFont::AddGlyph, COMDAT
; _this$ = ecx

; 2618 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2619 :     Glyphs.resize(Glyphs.Size + 1);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00033	83 c1 01	 add	 ecx, 1
  00036	51		 push	 ecx
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 20	 add	 ecx, 32			; 00000020H
  0003d	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImFontGlyph@@@@QAEXH@Z ; ImVector<ImFontGlyph>::resize

; 2620 :     ImFontGlyph& glyph = Glyphs.back();

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 20	 add	 ecx, 32			; 00000020H
  00048	e8 00 00 00 00	 call	 ?back@?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
  0004d	89 45 ec	 mov	 DWORD PTR _glyph$[ebp], eax

; 2621 :     glyph.Codepoint = (ImWchar)codepoint;

  00050	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  00053	66 8b 4d 08	 mov	 cx, WORD PTR _codepoint$[ebp]
  00057	66 89 08	 mov	 WORD PTR [eax], cx

; 2622 :     glyph.X0 = x0;

  0005a	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  0005d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _x0$[ebp]
  00062	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 2623 :     glyph.Y0 = y0;

  00067	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  0006a	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _y0$[ebp]
  0006f	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 2624 :     glyph.X1 = x1;

  00074	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  00077	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _x1$[ebp]
  0007c	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 2625 :     glyph.Y1 = y1;

  00081	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  00084	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _y1$[ebp]
  00089	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 2626 :     glyph.U0 = u0;

  0008e	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  00091	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _u0$[ebp]
  00096	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 2627 :     glyph.V0 = v0;

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  0009e	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _v0$[ebp]
  000a3	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 2628 :     glyph.U1 = u1;

  000a8	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  000ab	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _u1$[ebp]
  000b0	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 2629 :     glyph.V1 = v1;

  000b5	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  000b8	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _v1$[ebp]
  000bd	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 2630 :     glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000c8	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _advance_x$[ebp]
  000cd	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [ecx+32]
  000d2	8b 55 ec	 mov	 edx, DWORD PTR _glyph$[ebp]
  000d5	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0

; 2631 : 
; 2632 :     if (ConfigData->PixelSnapH)

  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000e0	0f b6 51 1c	 movzx	 edx, BYTE PTR [ecx+28]
  000e4	85 d2		 test	 edx, edx
  000e6	74 20		 je	 SHORT $LN2@AddGlyph

; 2633 :         glyph.AdvanceX = IM_ROUND(glyph.AdvanceX);

  000e8	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  000eb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000f0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000f8	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000fc	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00100	8b 55 ec	 mov	 edx, DWORD PTR _glyph$[ebp]
  00103	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
$LN2@AddGlyph:

; 2634 : 
; 2635 :     // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
; 2636 :     DirtyLookupTables = true;

  00108	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	c6 40 58 01	 mov	 BYTE PTR [eax+88], 1

; 2637 :     MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);

  0010f	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  00112	8b 4d ec	 mov	 ecx, DWORD PTR _glyph$[ebp]
  00115	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  0011a	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  0011f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00122	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00125	f3 0f 2a 48 1c	 cvtsi2ss xmm1, DWORD PTR [eax+28]
  0012a	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0012e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3ffeb852
  00136	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0013a	8b 55 ec	 mov	 edx, DWORD PTR _glyph$[ebp]
  0013d	8b 45 ec	 mov	 eax, DWORD PTR _glyph$[ebp]
  00140	f3 0f 10 42 24	 movss	 xmm0, DWORD PTR [edx+36]
  00145	f3 0f 5c 40 1c	 subss	 xmm0, DWORD PTR [eax+28]
  0014a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0014d	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00150	f3 0f 2a 48 20	 cvtsi2ss xmm1, DWORD PTR [eax+32]
  00155	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00159	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3ffeb852
  00161	f3 0f 2c d0	 cvttss2si edx, xmm0
  00165	0f af ca	 imul	 ecx, edx
  00168	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0016b	03 48 54	 add	 ecx, DWORD PTR [eax+84]
  0016e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00171	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 2638 : }

  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
  00177	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0017d	3b ec		 cmp	 ebp, esp
  0017f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c2 28 00	 ret	 40			; 00000028H
?AddGlyph@ImFont@@QAEXGMMMMMMMMM@Z ENDP			; ImFont::AddGlyph
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GrowIndex@ImFont@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -222						; size = 2
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?GrowIndex@ImFont@@QAEXH@Z PROC				; ImFont::GrowIndex, COMDAT
; _this$ = ecx

; 2607 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00013	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2608 :     IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 14	 cmp	 edx, DWORD PTR [ecx+20]
  00038	74 25		 je	 SHORT $LN4@GrowIndex
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GrowIndex@ImFont@@QAEXH@Z@4JA
  0003f	83 c0 01	 add	 eax, 1
  00042	8b f4		 mov	 esi, esp
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@GrowIndex:

; 2609 :     if (new_size <= IndexLookup.Size)

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00065	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00068	7f 02		 jg	 SHORT $LN2@GrowIndex

; 2610 :         return;

  0006a	eb 45		 jmp	 SHORT $LN1@GrowIndex
$LN2@GrowIndex:

; 2611 :     IndexAdvanceX.resize(new_size, -1.0f);

  0006c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00074	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR $T2[ebp], xmm0
  0007c	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00082	50		 push	 eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00086	51		 push	 ecx
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?resize@?$ImVector@M@@QAEXHABM@Z ; ImVector<float>::resize

; 2612 :     IndexLookup.resize(new_size, (ImWchar)-1);

  0008f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00094	66 89 85 22 ff
	ff ff		 mov	 WORD PTR $T1[ebp], ax
  0009b	8d 8d 22 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 08	 mov	 edx, DWORD PTR _new_size$[ebp]
  000a5	52		 push	 edx
  000a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	83 c1 14	 add	 ecx, 20			; 00000014H
  000ac	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXHABG@Z ; ImVector<unsigned short>::resize
$LN1@GrowIndex:

; 2613 : }

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?GrowIndex@ImFont@@QAEXH@Z ENDP				; ImFont::GrowIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ClearOutputData@ImFont@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ClearOutputData@ImFont@@QAEXXZ PROC			; ImFont::ClearOutputData, COMDAT
; _this$ = ecx

; 2548 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2549 :     FontSize = 0.0f;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 2550 :     FallbackAdvanceX = 0.0f;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 2551 :     Glyphs.clear();

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 20	 add	 ecx, 32			; 00000020H
  00049	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImFontGlyph@@@@QAEXXZ ; ImVector<ImFontGlyph>::clear

; 2552 :     IndexAdvanceX.clear();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?clear@?$ImVector@M@@QAEXXZ ; ImVector<float>::clear

; 2553 :     IndexLookup.clear();

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	83 c1 14	 add	 ecx, 20			; 00000014H
  0005c	e8 00 00 00 00	 call	 ?clear@?$ImVector@G@@QAEXXZ ; ImVector<unsigned short>::clear

; 2554 :     FallbackGlyph = NULL;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2555 :     ContainerAtlas = NULL;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 2556 :     DirtyLookupTables = true;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	c6 40 58 01	 mov	 BYTE PTR [eax+88], 1

; 2557 :     Ascent = Descent = 0.0f;

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	0f 57 c0	 xorps	 xmm0, xmm0
  00082	f3 0f 11 40 50	 movss	 DWORD PTR [eax+80], xmm0
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	0f 57 c0	 xorps	 xmm0, xmm0
  0008d	f3 0f 11 41 4c	 movss	 DWORD PTR [ecx+76], xmm0

; 2558 :     MetricsTotalSurface = 0;

  00092	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 2559 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?ClearOutputData@ImFont@@QAEXXZ ENDP			; ImFont::ClearOutputData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?BuildLookupTable@ImFont@@QAEXXZ
_TEXT	SEGMENT
tv202 = -280						; size = 4
_i$1 = -80						; size = 4
_tab_glyph$2 = -68					; size = 4
_codepoint$3 = -56					; size = 4
_i$4 = -44						; size = 4
_i$5 = -32						; size = 4
_max_codepoint$ = -20					; size = 4
_this$ = -8						; size = 4
?BuildLookupTable@ImFont@@QAEXXZ PROC			; ImFont::BuildLookupTable, COMDAT
; _this$ = ecx

; 2562 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00013	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2563 :     int max_codepoint = 0;

  0002d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _max_codepoint$[ebp], 0

; 2564 :     for (int i = 0; i != Glyphs.Size; i++)

  00034	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@BuildLooku
$LN2@BuildLooku:
  0003d	8b 45 e0	 mov	 eax, DWORD PTR _i$5[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 e0	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@BuildLooku:
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d e0	 mov	 ecx, DWORD PTR _i$5[ebp]
  0004c	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  0004f	74 24		 je	 SHORT $LN3@BuildLooku

; 2565 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

  00051	8b 45 e0	 mov	 eax, DWORD PTR _i$5[ebp]
  00054	50		 push	 eax
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 20	 add	 ecx, 32			; 00000020H
  0005b	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
  00060	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00063	51		 push	 ecx
  00064	8b 55 ec	 mov	 edx, DWORD PTR _max_codepoint$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 ??$ImMax@H@@YAHHH@Z	; ImMax<int>
  0006d	83 c4 08	 add	 esp, 8
  00070	89 45 ec	 mov	 DWORD PTR _max_codepoint$[ebp], eax
  00073	eb c8		 jmp	 SHORT $LN2@BuildLooku
$LN3@BuildLooku:

; 2566 : 
; 2567 :     IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved

  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	81 78 20 ff ff
	00 00		 cmp	 DWORD PTR [eax+32], 65535 ; 0000ffffH
  0007f	7c 26		 jl	 SHORT $LN15@BuildLooku
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??BuildLookupTable@ImFont@@QAEXXZ@4JA
  00087	83 c1 05	 add	 ecx, 5
  0008a	8b f4		 mov	 esi, esp
  0008c	51		 push	 ecx
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	3b f4		 cmp	 esi, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN15@BuildLooku:

; 2568 :     IndexAdvanceX.clear();

  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	e8 00 00 00 00	 call	 ?clear@?$ImVector@M@@QAEXXZ ; ImVector<float>::clear

; 2569 :     IndexLookup.clear();

  000af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	83 c1 14	 add	 ecx, 20			; 00000014H
  000b5	e8 00 00 00 00	 call	 ?clear@?$ImVector@G@@QAEXXZ ; ImVector<unsigned short>::clear

; 2570 :     DirtyLookupTables = false;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	c6 40 58 00	 mov	 BYTE PTR [eax+88], 0

; 2571 :     GrowIndex(max_codepoint + 1);

  000c1	8b 45 ec	 mov	 eax, DWORD PTR _max_codepoint$[ebp]
  000c4	83 c0 01	 add	 eax, 1
  000c7	50		 push	 eax
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?GrowIndex@ImFont@@QAEXH@Z ; ImFont::GrowIndex

; 2572 :     for (int i = 0; i < Glyphs.Size; i++)

  000d0	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  000d7	eb 09		 jmp	 SHORT $LN7@BuildLooku
$LN5@BuildLooku:
  000d9	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 d4	 mov	 DWORD PTR _i$4[ebp], eax
$LN7@BuildLooku:
  000e2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	8b 4d d4	 mov	 ecx, DWORD PTR _i$4[ebp]
  000e8	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  000eb	7d 4f		 jge	 SHORT $LN6@BuildLooku

; 2573 :     {
; 2574 :         int codepoint = (int)Glyphs[i].Codepoint;

  000ed	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	83 c1 20	 add	 ecx, 32			; 00000020H
  000f7	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
  000fc	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000ff	89 4d c8	 mov	 DWORD PTR _codepoint$3[ebp], ecx

; 2575 :         IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;

  00102	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  00105	50		 push	 eax
  00106	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	83 c1 20	 add	 ecx, 32			; 00000020H
  0010c	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
  00111	8b f0		 mov	 esi, eax
  00113	8b 4d c8	 mov	 ecx, DWORD PTR _codepoint$3[ebp]
  00116	51		 push	 ecx
  00117	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QAEAAMH@Z ; ImVector<float>::operator[]
  0011f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00122	89 10		 mov	 DWORD PTR [eax], edx

; 2576 :         IndexLookup[codepoint] = (ImWchar)i;

  00124	8b 45 c8	 mov	 eax, DWORD PTR _codepoint$3[ebp]
  00127	50		 push	 eax
  00128	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	83 c1 14	 add	 ecx, 20			; 00000014H
  0012e	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  00133	66 8b 4d d4	 mov	 cx, WORD PTR _i$4[ebp]
  00137	66 89 08	 mov	 WORD PTR [eax], cx

; 2577 :     }

  0013a	eb 9d		 jmp	 SHORT $LN5@BuildLooku
$LN6@BuildLooku:

; 2578 : 
; 2579 :     // Create a glyph to handle TAB
; 2580 :     // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
; 2581 :     if (FindGlyph((ImWchar)' '))

  0013c	6a 20		 push	 32			; 00000020H
  0013e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyph
  00146	85 c0		 test	 eax, eax
  00148	0f 84 a4 00 00
	00		 je	 $LN11@BuildLooku

; 2582 :     {
; 2583 :         if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times

  0014e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	83 c1 20	 add	 ecx, 32			; 00000020H
  00154	e8 00 00 00 00	 call	 ?back@?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
  00159	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0015c	83 f8 09	 cmp	 eax, 9
  0015f	74 15		 je	 SHORT $LN12@BuildLooku

; 2584 :             Glyphs.resize(Glyphs.Size + 1);

  00161	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00164	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00167	83 c1 01	 add	 ecx, 1
  0016a	51		 push	 ecx
  0016b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	83 c1 20	 add	 ecx, 32			; 00000020H
  00171	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImFontGlyph@@@@QAEXH@Z ; ImVector<ImFontGlyph>::resize
$LN12@BuildLooku:

; 2585 :         ImFontGlyph& tab_glyph = Glyphs.back();

  00176	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	83 c1 20	 add	 ecx, 32			; 00000020H
  0017c	e8 00 00 00 00	 call	 ?back@?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
  00181	89 45 bc	 mov	 DWORD PTR _tab_glyph$2[ebp], eax

; 2586 :         tab_glyph = *FindGlyph((ImWchar)' ');

  00184	6a 20		 push	 32			; 00000020H
  00186	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	e8 00 00 00 00	 call	 ?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyph
  0018e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00193	8b f0		 mov	 esi, eax
  00195	8b 7d bc	 mov	 edi, DWORD PTR _tab_glyph$2[ebp]
  00198	f3 a5		 rep movsd

; 2587 :         tab_glyph.Codepoint = '\t';

  0019a	b8 09 00 00 00	 mov	 eax, 9
  0019f	8b 4d bc	 mov	 ecx, DWORD PTR _tab_glyph$2[ebp]
  001a2	66 89 01	 mov	 WORD PTR [ecx], ax

; 2588 :         tab_glyph.AdvanceX *= IM_TABSIZE;

  001a5	8b 45 bc	 mov	 eax, DWORD PTR _tab_glyph$2[ebp]
  001a8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001ad	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40800000
  001b5	8b 4d bc	 mov	 ecx, DWORD PTR _tab_glyph$2[ebp]
  001b8	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 2589 :         IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;

  001bd	8b 45 bc	 mov	 eax, DWORD PTR _tab_glyph$2[ebp]
  001c0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001c3	51		 push	 ecx
  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QAEAAMH@Z ; ImVector<float>::operator[]
  001cc	8b 55 bc	 mov	 edx, DWORD PTR _tab_glyph$2[ebp]
  001cf	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001d2	89 08		 mov	 DWORD PTR [eax], ecx

; 2590 :         IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size-1);

  001d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
  001da	83 ee 01	 sub	 esi, 1
  001dd	8b 4d bc	 mov	 ecx, DWORD PTR _tab_glyph$2[ebp]
  001e0	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  001e3	52		 push	 edx
  001e4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e7	83 c1 14	 add	 ecx, 20			; 00000014H
  001ea	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  001ef	66 89 30	 mov	 WORD PTR [eax], si
$LN11@BuildLooku:

; 2591 :     }
; 2592 : 
; 2593 :     FallbackGlyph = FindGlyphNoFallback(FallbackChar);

  001f2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001f5	0f b7 48 42	 movzx	 ecx, WORD PTR [eax+66]
  001f9	51		 push	 ecx
  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fd	e8 00 00 00 00	 call	 ?FindGlyphNoFallback@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyphNoFallback
  00202	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00205	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 2594 :     FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;

  00208	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0020f	74 15		 je	 SHORT $LN16@BuildLooku
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00214	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00217	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0021c	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR tv202[ebp], xmm0
  00224	eb 0b		 jmp	 SHORT $LN17@BuildLooku
$LN16@BuildLooku:
  00226	0f 57 c0	 xorps	 xmm0, xmm0
  00229	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR tv202[ebp], xmm0
$LN17@BuildLooku:
  00231	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00234	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR tv202[ebp]
  0023c	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 2595 :     for (int i = 0; i < max_codepoint + 1; i++)

  00241	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00248	eb 09		 jmp	 SHORT $LN10@BuildLooku
$LN8@BuildLooku:
  0024a	8b 45 b0	 mov	 eax, DWORD PTR _i$1[ebp]
  0024d	83 c0 01	 add	 eax, 1
  00250	89 45 b0	 mov	 DWORD PTR _i$1[ebp], eax
$LN10@BuildLooku:
  00253	8b 45 ec	 mov	 eax, DWORD PTR _max_codepoint$[ebp]
  00256	83 c0 01	 add	 eax, 1
  00259	39 45 b0	 cmp	 DWORD PTR _i$1[ebp], eax
  0025c	7d 2a		 jge	 SHORT $LN9@BuildLooku

; 2596 :         if (IndexAdvanceX[i] < 0.0f)

  0025e	8b 45 b0	 mov	 eax, DWORD PTR _i$1[ebp]
  00261	50		 push	 eax
  00262	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00265	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QAEAAMH@Z ; ImVector<float>::operator[]
  0026a	0f 57 c0	 xorps	 xmm0, xmm0
  0026d	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00270	76 14		 jbe	 SHORT $LN13@BuildLooku

; 2597 :             IndexAdvanceX[i] = FallbackAdvanceX;

  00272	8b 45 b0	 mov	 eax, DWORD PTR _i$1[ebp]
  00275	50		 push	 eax
  00276	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	e8 00 00 00 00	 call	 ??A?$ImVector@M@@QAEAAMH@Z ; ImVector<float>::operator[]
  0027e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00281	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00284	89 10		 mov	 DWORD PTR [eax], edx
$LN13@BuildLooku:
  00286	eb c2		 jmp	 SHORT $LN8@BuildLooku
$LN9@BuildLooku:

; 2598 : }

  00288	5f		 pop	 edi
  00289	5e		 pop	 esi
  0028a	5b		 pop	 ebx
  0028b	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00291	3b ec		 cmp	 ebp, esp
  00293	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00298	8b e5		 mov	 esp, ebp
  0029a	5d		 pop	 ebp
  0029b	c3		 ret	 0
?BuildLookupTable@ImFont@@QAEXXZ ENDP			; ImFont::BuildLookupTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z
_TEXT	SEGMENT
tv437 = -536						; size = 4
tv152 = -536						; size = 4
tv136 = -536						; size = 4
tv87 = -533						; size = 1
_v2$1 = -336						; size = 4
_u2$2 = -324						; size = 4
_v1$3 = -312						; size = 4
_u1$4 = -300						; size = 4
_y2$5 = -288						; size = 4
_y1$6 = -276						; size = 4
_x2$7 = -264						; size = 4
_x1$8 = -252						; size = 4
_glyph$9 = -240						; size = 4
_char_width$10 = -228					; size = 4
_c$11 = -216						; size = 4
_c$12 = -201						; size = 1
_vtx_current_idx$ = -192				; size = 4
_idx_write$ = -180					; size = 4
_vtx_write$ = -168					; size = 4
_idx_expected_size$ = -156				; size = 4
_idx_count_max$ = -144					; size = 4
_vtx_count_max$ = -132					; size = 4
_y_end$13 = -120					; size = 4
_s_end$14 = -108					; size = 4
_s$ = -96						; size = 4
_word_wrap_eol$ = -84					; size = 4
_word_wrap_enabled$ = -69				; size = 1
_line_height$ = -60					; size = 4
_scale$ = -48						; size = 4
_y$ = -36						; size = 4
_x$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_draw_list$ = 8						; size = 4
_size$ = 12						; size = 4
_pos$ = 16						; size = 8
_col$ = 24						; size = 4
_clip_rect$ = 28					; size = 4
_text_begin$ = 32					; size = 4
_text_end$ = 36						; size = 4
_wrap_width$ = 40					; size = 4
_cpu_fine_clip$ = 44					; size = 1
?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z PROC ; ImFont::RenderText, COMDAT
; _this$ = ecx

; 2883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd e8 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-536]
  00013	b9 86 00 00 00	 mov	 ecx, 134		; 00000086H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2884 :     if (!text_end)

  00037	83 7d 24 00	 cmp	 DWORD PTR _text_end$[ebp], 0
  0003b	75 12		 jne	 SHORT $LN10@RenderText

; 2885 :         text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.

  0003d	8b 45 20	 mov	 eax, DWORD PTR _text_begin$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strlen
  00046	83 c4 04	 add	 esp, 4
  00049	03 45 20	 add	 eax, DWORD PTR _text_begin$[ebp]
  0004c	89 45 24	 mov	 DWORD PTR _text_end$[ebp], eax
$LN10@RenderText:

; 2886 : 
; 2887 :     // Align to be pixel perfect
; 2888 :     pos.x = IM_FLOOR(pos.x + DisplayOffset.x);

  0004f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00052	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00057	f3 0f 58 40 30	 addss	 xmm0, DWORD PTR [eax+48]
  0005c	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00060	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00064	f3 0f 11 45 10	 movss	 DWORD PTR _pos$[ebp], xmm0

; 2889 :     pos.y = IM_FLOOR(pos.y + DisplayOffset.y);

  00069	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00071	f3 0f 58 40 34	 addss	 xmm0, DWORD PTR [eax+52]
  00076	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0007a	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0007e	f3 0f 11 45 14	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 2890 :     float x = pos.x;

  00083	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp]
  00088	f3 0f 11 45 e8	 movss	 DWORD PTR _x$[ebp], xmm0

; 2891 :     float y = pos.y;

  0008d	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  00092	f3 0f 11 45 dc	 movss	 DWORD PTR _y$[ebp], xmm0

; 2892 :     if (y > clip_rect.w)

  00097	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0009a	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  0009f	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  000a3	76 05		 jbe	 SHORT $LN11@RenderText

; 2893 :         return;

  000a5	e9 1f 0a 00 00	 jmp	 $LN1@RenderText
$LN11@RenderText:

; 2894 : 
; 2895 :     const float scale = size / FontSize;

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _size$[ebp]
  000b2	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  000b7	f3 0f 11 45 d0	 movss	 DWORD PTR _scale$[ebp], xmm0

; 2896 :     const float line_height = FontSize * scale;

  000bc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  000c4	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  000c9	f3 0f 11 45 c4	 movss	 DWORD PTR _line_height$[ebp], xmm0

; 2897 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

  000ce	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _wrap_width$[ebp]
  000d3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000da	76 09		 jbe	 SHORT $LN40@RenderText
  000dc	c6 85 eb fd ff
	ff 01		 mov	 BYTE PTR tv87[ebp], 1
  000e3	eb 07		 jmp	 SHORT $LN41@RenderText
$LN40@RenderText:
  000e5	c6 85 eb fd ff
	ff 00		 mov	 BYTE PTR tv87[ebp], 0
$LN41@RenderText:
  000ec	8a 85 eb fd ff
	ff		 mov	 al, BYTE PTR tv87[ebp]
  000f2	88 45 bb	 mov	 BYTE PTR _word_wrap_enabled$[ebp], al

; 2898 :     const char* word_wrap_eol = NULL;

  000f5	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _word_wrap_eol$[ebp], 0

; 2899 : 
; 2900 :     // Fast-forward to first visible line
; 2901 :     const char* s = text_begin;

  000fc	8b 45 20	 mov	 eax, DWORD PTR _text_begin$[ebp]
  000ff	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 2902 :     if (y + line_height < clip_rect.y && !word_wrap_enabled)

  00102	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  00107	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  0010c	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0010f	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00114	0f 2f c8	 comiss	 xmm1, xmm0
  00117	76 76		 jbe	 SHORT $LN3@RenderText
  00119	0f b6 45 bb	 movzx	 eax, BYTE PTR _word_wrap_enabled$[ebp]
  0011d	85 c0		 test	 eax, eax
  0011f	75 6e		 jne	 SHORT $LN3@RenderText
$LN2@RenderText:

; 2903 :         while (y + line_height < clip_rect.y && s < text_end)

  00121	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  00126	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  0012b	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0012e	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00133	0f 2f c8	 comiss	 xmm1, xmm0
  00136	76 57		 jbe	 SHORT $LN3@RenderText
  00138	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  0013b	3b 45 24	 cmp	 eax, DWORD PTR _text_end$[ebp]
  0013e	73 4f		 jae	 SHORT $LN3@RenderText

; 2904 :         {
; 2905 :             s = (const char*)memchr(s, '\n', text_end - s);

  00140	8b 45 24	 mov	 eax, DWORD PTR _text_end$[ebp]
  00143	2b 45 a0	 sub	 eax, DWORD PTR _s$[ebp]
  00146	50		 push	 eax
  00147	6a 0a		 push	 10			; 0000000aH
  00149	8b 4d a0	 mov	 ecx, DWORD PTR _s$[ebp]
  0014c	51		 push	 ecx
  0014d	e8 00 00 00 00	 call	 _memchr
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
  00155	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 2906 :             s = s ? s + 1 : text_end;

  00158	83 7d a0 00	 cmp	 DWORD PTR _s$[ebp], 0
  0015c	74 0e		 je	 SHORT $LN42@RenderText
  0015e	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00161	83 c0 01	 add	 eax, 1
  00164	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv136[ebp], eax
  0016a	eb 09		 jmp	 SHORT $LN43@RenderText
$LN42@RenderText:
  0016c	8b 4d 24	 mov	 ecx, DWORD PTR _text_end$[ebp]
  0016f	89 8d e8 fd ff
	ff		 mov	 DWORD PTR tv136[ebp], ecx
$LN43@RenderText:
  00175	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv136[ebp]
  0017b	89 55 a0	 mov	 DWORD PTR _s$[ebp], edx

; 2907 :             y += line_height;

  0017e	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  00183	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  00188	f3 0f 11 45 dc	 movss	 DWORD PTR _y$[ebp], xmm0

; 2908 :         }

  0018d	eb 92		 jmp	 SHORT $LN2@RenderText
$LN3@RenderText:

; 2909 : 
; 2910 :     // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
; 2911 :     // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
; 2912 :     if (text_end - s > 10000 && !word_wrap_enabled)

  0018f	8b 45 24	 mov	 eax, DWORD PTR _text_end$[ebp]
  00192	2b 45 a0	 sub	 eax, DWORD PTR _s$[ebp]
  00195	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  0019a	0f 8e 83 00 00
	00		 jle	 $LN13@RenderText
  001a0	0f b6 45 bb	 movzx	 eax, BYTE PTR _word_wrap_enabled$[ebp]
  001a4	85 c0		 test	 eax, eax
  001a6	75 7b		 jne	 SHORT $LN13@RenderText

; 2913 :     {
; 2914 :         const char* s_end = s;

  001a8	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  001ab	89 45 94	 mov	 DWORD PTR _s_end$14[ebp], eax

; 2915 :         float y_end = y;

  001ae	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  001b3	f3 0f 11 45 88	 movss	 DWORD PTR _y_end$13[ebp], xmm0
$LN4@RenderText:

; 2916 :         while (y_end < clip_rect.w && s_end < text_end)

  001b8	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  001bb	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001c0	0f 2f 45 88	 comiss	 xmm0, DWORD PTR _y_end$13[ebp]
  001c4	76 57		 jbe	 SHORT $LN5@RenderText
  001c6	8b 45 94	 mov	 eax, DWORD PTR _s_end$14[ebp]
  001c9	3b 45 24	 cmp	 eax, DWORD PTR _text_end$[ebp]
  001cc	73 4f		 jae	 SHORT $LN5@RenderText

; 2917 :         {
; 2918 :             s_end = (const char*)memchr(s_end, '\n', text_end - s_end);

  001ce	8b 45 24	 mov	 eax, DWORD PTR _text_end$[ebp]
  001d1	2b 45 94	 sub	 eax, DWORD PTR _s_end$14[ebp]
  001d4	50		 push	 eax
  001d5	6a 0a		 push	 10			; 0000000aH
  001d7	8b 4d 94	 mov	 ecx, DWORD PTR _s_end$14[ebp]
  001da	51		 push	 ecx
  001db	e8 00 00 00 00	 call	 _memchr
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e3	89 45 94	 mov	 DWORD PTR _s_end$14[ebp], eax

; 2919 :             s_end = s_end ? s_end + 1 : text_end;

  001e6	83 7d 94 00	 cmp	 DWORD PTR _s_end$14[ebp], 0
  001ea	74 0e		 je	 SHORT $LN44@RenderText
  001ec	8b 45 94	 mov	 eax, DWORD PTR _s_end$14[ebp]
  001ef	83 c0 01	 add	 eax, 1
  001f2	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
  001f8	eb 09		 jmp	 SHORT $LN45@RenderText
$LN44@RenderText:
  001fa	8b 4d 24	 mov	 ecx, DWORD PTR _text_end$[ebp]
  001fd	89 8d e8 fd ff
	ff		 mov	 DWORD PTR tv152[ebp], ecx
$LN45@RenderText:
  00203	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv152[ebp]
  00209	89 55 94	 mov	 DWORD PTR _s_end$14[ebp], edx

; 2920 :             y_end += line_height;

  0020c	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _y_end$13[ebp]
  00211	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  00216	f3 0f 11 45 88	 movss	 DWORD PTR _y_end$13[ebp], xmm0

; 2921 :         }

  0021b	eb 9b		 jmp	 SHORT $LN4@RenderText
$LN5@RenderText:

; 2922 :         text_end = s_end;

  0021d	8b 45 94	 mov	 eax, DWORD PTR _s_end$14[ebp]
  00220	89 45 24	 mov	 DWORD PTR _text_end$[ebp], eax
$LN13@RenderText:

; 2923 :     }
; 2924 :     if (s == text_end)

  00223	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00226	3b 45 24	 cmp	 eax, DWORD PTR _text_end$[ebp]
  00229	75 05		 jne	 SHORT $LN14@RenderText

; 2925 :         return;

  0022b	e9 99 08 00 00	 jmp	 $LN1@RenderText
$LN14@RenderText:

; 2926 : 
; 2927 :     // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
; 2928 :     const int vtx_count_max = (int)(text_end - s) * 4;

  00230	8b 45 24	 mov	 eax, DWORD PTR _text_end$[ebp]
  00233	2b 45 a0	 sub	 eax, DWORD PTR _s$[ebp]
  00236	c1 e0 02	 shl	 eax, 2
  00239	89 85 7c ff ff
	ff		 mov	 DWORD PTR _vtx_count_max$[ebp], eax

; 2929 :     const int idx_count_max = (int)(text_end - s) * 6;

  0023f	8b 45 24	 mov	 eax, DWORD PTR _text_end$[ebp]
  00242	2b 45 a0	 sub	 eax, DWORD PTR _s$[ebp]
  00245	6b c8 06	 imul	 ecx, eax, 6
  00248	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _idx_count_max$[ebp], ecx

; 2930 :     const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;

  0024e	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00251	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00254	03 8d 70 ff ff
	ff		 add	 ecx, DWORD PTR _idx_count_max$[ebp]
  0025a	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _idx_expected_size$[ebp], ecx

; 2931 :     draw_list->PrimReserve(idx_count_max, vtx_count_max);

  00260	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _vtx_count_max$[ebp]
  00266	50		 push	 eax
  00267	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _idx_count_max$[ebp]
  0026d	51		 push	 ecx
  0026e	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00271	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 2932 : 
; 2933 :     ImDrawVert* vtx_write = draw_list->_VtxWritePtr;

  00276	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00279	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0027c	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _vtx_write$[ebp], ecx

; 2934 :     ImDrawIdx* idx_write = draw_list->_IdxWritePtr;

  00282	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00285	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00288	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _idx_write$[ebp], ecx

; 2935 :     unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

  0028e	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00291	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00294	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _vtx_current_idx$[ebp], ecx
$LN49@RenderText:

; 2936 : 
; 2937 :     while (s < text_end)

  0029a	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  0029d	3b 45 24	 cmp	 eax, DWORD PTR _text_end$[ebp]
  002a0	0f 83 9a 07 00
	00		 jae	 $LN7@RenderText

; 2938 :     {
; 2939 :         if (word_wrap_enabled)

  002a6	0f b6 45 bb	 movzx	 eax, BYTE PTR _word_wrap_enabled$[ebp]
  002aa	85 c0		 test	 eax, eax
  002ac	0f 84 cd 00 00
	00		 je	 $LN18@RenderText

; 2940 :         {
; 2941 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 2942 :             if (!word_wrap_eol)

  002b2	83 7d ac 00	 cmp	 DWORD PTR _word_wrap_eol$[ebp], 0
  002b6	75 48		 jne	 SHORT $LN17@RenderText

; 2943 :             {
; 2944 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));

  002b8	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _x$[ebp]
  002bd	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _pos$[ebp]
  002c2	f3 0f 10 4d 28	 movss	 xmm1, DWORD PTR _wrap_width$[ebp]
  002c7	f3 0f 5c c8	 subss	 xmm1, xmm0
  002cb	51		 push	 ecx
  002cc	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  002d1	8b 45 24	 mov	 eax, DWORD PTR _text_end$[ebp]
  002d4	50		 push	 eax
  002d5	8b 4d a0	 mov	 ecx, DWORD PTR _s$[ebp]
  002d8	51		 push	 ecx
  002d9	51		 push	 ecx
  002da	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _scale$[ebp]
  002df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002e7	e8 00 00 00 00	 call	 ?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z ; ImFont::CalcWordWrapPositionA
  002ec	89 45 ac	 mov	 DWORD PTR _word_wrap_eol$[ebp], eax

; 2945 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

  002ef	8b 45 ac	 mov	 eax, DWORD PTR _word_wrap_eol$[ebp]
  002f2	3b 45 a0	 cmp	 eax, DWORD PTR _s$[ebp]
  002f5	75 09		 jne	 SHORT $LN17@RenderText

; 2946 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

  002f7	8b 45 ac	 mov	 eax, DWORD PTR _word_wrap_eol$[ebp]
  002fa	83 c0 01	 add	 eax, 1
  002fd	89 45 ac	 mov	 DWORD PTR _word_wrap_eol$[ebp], eax
$LN17@RenderText:

; 2947 :             }
; 2948 : 
; 2949 :             if (s >= word_wrap_eol)

  00300	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00303	3b 45 ac	 cmp	 eax, DWORD PTR _word_wrap_eol$[ebp]
  00306	72 77		 jb	 SHORT $LN18@RenderText

; 2950 :             {
; 2951 :                 x = pos.x;

  00308	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp]
  0030d	f3 0f 11 45 e8	 movss	 DWORD PTR _x$[ebp], xmm0

; 2952 :                 y += line_height;

  00312	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  00317	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  0031c	f3 0f 11 45 dc	 movss	 DWORD PTR _y$[ebp], xmm0

; 2953 :                 word_wrap_eol = NULL;

  00321	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _word_wrap_eol$[ebp], 0
$LN8@RenderText:

; 2954 : 
; 2955 :                 // Wrapping skips upcoming blanks
; 2956 :                 while (s < text_end)

  00328	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  0032b	3b 45 24	 cmp	 eax, DWORD PTR _text_end$[ebp]
  0032e	73 4a		 jae	 SHORT $LN9@RenderText

; 2957 :                 {
; 2958 :                     const char c = *s;

  00330	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00333	8a 08		 mov	 cl, BYTE PTR [eax]
  00335	88 8d 37 ff ff
	ff		 mov	 BYTE PTR _c$12[ebp], cl

; 2959 :                     if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

  0033b	0f b6 85 37 ff
	ff ff		 movzx	 eax, BYTE PTR _c$12[ebp]
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 ?ImCharIsBlankA@@YA_ND@Z ; ImCharIsBlankA
  00348	83 c4 04	 add	 esp, 4
  0034b	0f b6 c8	 movzx	 ecx, al
  0034e	85 c9		 test	 ecx, ecx
  00350	74 0b		 je	 SHORT $LN19@RenderText
  00352	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00355	83 c0 01	 add	 eax, 1
  00358	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax
  0035b	eb 1b		 jmp	 SHORT $LN22@RenderText
$LN19@RenderText:
  0035d	0f be 85 37 ff
	ff ff		 movsx	 eax, BYTE PTR _c$12[ebp]
  00364	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00367	75 0d		 jne	 SHORT $LN21@RenderText
  00369	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  0036c	83 c0 01	 add	 eax, 1
  0036f	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax
  00372	eb 06		 jmp	 SHORT $LN9@RenderText
  00374	eb 02		 jmp	 SHORT $LN22@RenderText
$LN21@RenderText:
  00376	eb 02		 jmp	 SHORT $LN9@RenderText
$LN22@RenderText:

; 2960 :                 }

  00378	eb ae		 jmp	 SHORT $LN8@RenderText
$LN9@RenderText:

; 2961 :                 continue;

  0037a	e9 1b ff ff ff	 jmp	 $LN49@RenderText
$LN18@RenderText:

; 2962 :             }
; 2963 :         }
; 2964 : 
; 2965 :         // Decode and advance source
; 2966 :         unsigned int c = (unsigned int)*s;

  0037f	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00382	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00385	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _c$11[ebp], ecx

; 2967 :         if (c < 0x80)

  0038b	81 bd 28 ff ff
	ff 80 00 00 00	 cmp	 DWORD PTR _c$11[ebp], 128 ; 00000080H
  00395	73 0b		 jae	 SHORT $LN23@RenderText

; 2968 :         {
; 2969 :             s += 1;

  00397	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  0039a	83 c0 01	 add	 eax, 1
  0039d	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 2970 :         }

  003a0	eb 2b		 jmp	 SHORT $LN25@RenderText
$LN23@RenderText:

; 2971 :         else
; 2972 :         {
; 2973 :             s += ImTextCharFromUtf8(&c, s, text_end);

  003a2	8b 45 24	 mov	 eax, DWORD PTR _text_end$[ebp]
  003a5	50		 push	 eax
  003a6	8b 4d a0	 mov	 ecx, DWORD PTR _s$[ebp]
  003a9	51		 push	 ecx
  003aa	8d 95 28 ff ff
	ff		 lea	 edx, DWORD PTR _c$11[ebp]
  003b0	52		 push	 edx
  003b1	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPAIPBD1@Z ; ImTextCharFromUtf8
  003b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b9	03 45 a0	 add	 eax, DWORD PTR _s$[ebp]
  003bc	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 2974 :             if (c == 0) // Malformed UTF-8?

  003bf	83 bd 28 ff ff
	ff 00		 cmp	 DWORD PTR _c$11[ebp], 0
  003c6	75 05		 jne	 SHORT $LN25@RenderText

; 2975 :                 break;

  003c8	e9 73 06 00 00	 jmp	 $LN7@RenderText
$LN25@RenderText:

; 2976 :         }
; 2977 : 
; 2978 :         if (c < 32)

  003cd	83 bd 28 ff ff
	ff 20		 cmp	 DWORD PTR _c$11[ebp], 32 ; 00000020H
  003d4	73 48		 jae	 SHORT $LN29@RenderText

; 2979 :         {
; 2980 :             if (c == '\n')

  003d6	83 bd 28 ff ff
	ff 0a		 cmp	 DWORD PTR _c$11[ebp], 10 ; 0000000aH
  003dd	75 31		 jne	 SHORT $LN27@RenderText

; 2981 :             {
; 2982 :                 x = pos.x;

  003df	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp]
  003e4	f3 0f 11 45 e8	 movss	 DWORD PTR _x$[ebp], xmm0

; 2983 :                 y += line_height;

  003e9	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  003ee	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  003f3	f3 0f 11 45 dc	 movss	 DWORD PTR _y$[ebp], xmm0

; 2984 :                 if (y > clip_rect.w)

  003f8	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  003fb	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _y$[ebp]
  00400	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00404	76 05		 jbe	 SHORT $LN28@RenderText

; 2985 :                     break; // break out of main loop

  00406	e9 35 06 00 00	 jmp	 $LN7@RenderText
$LN28@RenderText:

; 2986 :                 continue;

  0040b	e9 8a fe ff ff	 jmp	 $LN49@RenderText
$LN27@RenderText:

; 2987 :             }
; 2988 :             if (c == '\r')

  00410	83 bd 28 ff ff
	ff 0d		 cmp	 DWORD PTR _c$11[ebp], 13 ; 0000000dH
  00417	75 05		 jne	 SHORT $LN29@RenderText

; 2989 :                 continue;

  00419	e9 7c fe ff ff	 jmp	 $LN49@RenderText
$LN29@RenderText:

; 2990 :         }
; 2991 : 
; 2992 :         float char_width = 0.0f;

  0041e	0f 57 c0	 xorps	 xmm0, xmm0
  00421	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _char_width$10[ebp], xmm0

; 2993 :         if (const ImFontGlyph* glyph = FindGlyph((ImWchar)c))

  00429	0f b7 85 28 ff
	ff ff		 movzx	 eax, WORD PTR _c$11[ebp]
  00430	50		 push	 eax
  00431	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00434	e8 00 00 00 00	 call	 ?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyph
  00439	89 85 10 ff ff
	ff		 mov	 DWORD PTR _glyph$9[ebp], eax
  0043f	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR _glyph$9[ebp], 0
  00446	0f 84 dd 05 00
	00		 je	 $LN32@RenderText

; 2994 :         {
; 2995 :             char_width = glyph->AdvanceX * scale;

  0044c	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  00452	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00457	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  0045c	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _char_width$10[ebp], xmm0

; 2996 : 
; 2997 :             // Arbitrarily assume that both space and tabs are empty glyphs as an optimization
; 2998 :             if (c != ' ' && c != '\t')

  00464	83 bd 28 ff ff
	ff 20		 cmp	 DWORD PTR _c$11[ebp], 32 ; 00000020H
  0046b	0f 84 b8 05 00
	00		 je	 $LN32@RenderText
  00471	83 bd 28 ff ff
	ff 09		 cmp	 DWORD PTR _c$11[ebp], 9
  00478	0f 84 ab 05 00
	00		 je	 $LN32@RenderText

; 2999 :             {
; 3000 :                 // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
; 3001 :                 float x1 = x + glyph->X0 * scale;

  0047e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  00484	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00489	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  0048e	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _x$[ebp]
  00493	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _x1$8[ebp], xmm0

; 3002 :                 float x2 = x + glyph->X1 * scale;

  0049b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  004a1	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  004a6	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  004ab	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _x$[ebp]
  004b0	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR _x2$7[ebp], xmm0

; 3003 :                 float y1 = y + glyph->Y0 * scale;

  004b8	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  004be	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  004c3	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  004c8	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _y$[ebp]
  004cd	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _y1$6[ebp], xmm0

; 3004 :                 float y2 = y + glyph->Y1 * scale;

  004d5	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  004db	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  004e0	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  004e5	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _y$[ebp]
  004ea	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _y2$5[ebp], xmm0

; 3005 :                 if (x1 <= clip_rect.z && x2 >= clip_rect.x)

  004f2	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  004f5	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004fa	0f 2f 85 04 ff
	ff ff		 comiss	 xmm0, DWORD PTR _x1$8[ebp]
  00501	0f 82 22 05 00
	00		 jb	 $LN32@RenderText
  00507	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0050a	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$7[ebp]
  00512	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00515	0f 82 0e 05 00
	00		 jb	 $LN32@RenderText

; 3006 :                 {
; 3007 :                     // Render a character
; 3008 :                     float u1 = glyph->U0;

  0051b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  00521	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00526	f3 0f 11 85 d4
	fe ff ff	 movss	 DWORD PTR _u1$4[ebp], xmm0

; 3009 :                     float v1 = glyph->V0;

  0052e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  00534	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  00539	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR _v1$3[ebp], xmm0

; 3010 :                     float u2 = glyph->U1;

  00541	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  00547	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  0054c	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR _u2$2[ebp], xmm0

; 3011 :                     float v2 = glyph->V1;

  00554	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _glyph$9[ebp]
  0055a	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0055f	f3 0f 11 85 b0
	fe ff ff	 movss	 DWORD PTR _v2$1[ebp], xmm0

; 3012 : 
; 3013 :                     // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
; 3014 :                     if (cpu_fine_clip)

  00567	0f b6 45 2c	 movzx	 eax, BYTE PTR _cpu_fine_clip$[ebp]
  0056b	85 c0		 test	 eax, eax
  0056d	0f 84 e1 01 00
	00		 je	 $LN38@RenderText

; 3015 :                     {
; 3016 :                         if (x1 < clip_rect.x)

  00573	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  00576	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0057a	0f 2f 85 04 ff
	ff ff		 comiss	 xmm0, DWORD PTR _x1$8[ebp]
  00581	76 62		 jbe	 SHORT $LN34@RenderText

; 3017 :                         {
; 3018 :                             u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);

  00583	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  00586	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$7[ebp]
  0058e	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00592	f3 0f 10 8d f8
	fe ff ff	 movss	 xmm1, DWORD PTR _x2$7[ebp]
  0059a	f3 0f 5c 8d 04
	ff ff ff	 subss	 xmm1, DWORD PTR _x1$8[ebp]
  005a2	f3 0f 5e c1	 divss	 xmm0, xmm1
  005a6	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  005ae	f3 0f 5c c8	 subss	 xmm1, xmm0
  005b2	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR _u2$2[ebp]
  005ba	f3 0f 5c 85 d4
	fe ff ff	 subss	 xmm0, DWORD PTR _u1$4[ebp]
  005c2	f3 0f 59 c8	 mulss	 xmm1, xmm0
  005c6	f3 0f 58 8d d4
	fe ff ff	 addss	 xmm1, DWORD PTR _u1$4[ebp]
  005ce	f3 0f 11 8d d4
	fe ff ff	 movss	 DWORD PTR _u1$4[ebp], xmm1

; 3019 :                             x1 = clip_rect.x;

  005d6	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  005d9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  005dd	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _x1$8[ebp], xmm0
$LN34@RenderText:

; 3020 :                         }
; 3021 :                         if (y1 < clip_rect.y)

  005e5	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  005e8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  005ed	0f 2f 85 ec fe
	ff ff		 comiss	 xmm0, DWORD PTR _y1$6[ebp]
  005f4	76 64		 jbe	 SHORT $LN35@RenderText

; 3022 :                         {
; 3023 :                             v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);

  005f6	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  005f9	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$5[ebp]
  00601	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  00606	f3 0f 10 8d e0
	fe ff ff	 movss	 xmm1, DWORD PTR _y2$5[ebp]
  0060e	f3 0f 5c 8d ec
	fe ff ff	 subss	 xmm1, DWORD PTR _y1$6[ebp]
  00616	f3 0f 5e c1	 divss	 xmm0, xmm1
  0061a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00622	f3 0f 5c c8	 subss	 xmm1, xmm0
  00626	f3 0f 10 85 b0
	fe ff ff	 movss	 xmm0, DWORD PTR _v2$1[ebp]
  0062e	f3 0f 5c 85 c8
	fe ff ff	 subss	 xmm0, DWORD PTR _v1$3[ebp]
  00636	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0063a	f3 0f 58 8d c8
	fe ff ff	 addss	 xmm1, DWORD PTR _v1$3[ebp]
  00642	f3 0f 11 8d c8
	fe ff ff	 movss	 DWORD PTR _v1$3[ebp], xmm1

; 3024 :                             y1 = clip_rect.y;

  0064a	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0064d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00652	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _y1$6[ebp], xmm0
$LN35@RenderText:

; 3025 :                         }
; 3026 :                         if (x2 > clip_rect.z)

  0065a	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0065d	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$7[ebp]
  00665	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00669	76 58		 jbe	 SHORT $LN36@RenderText

; 3027 :                         {
; 3028 :                             u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);

  0066b	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0066e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00673	f3 0f 5c 85 04
	ff ff ff	 subss	 xmm0, DWORD PTR _x1$8[ebp]
  0067b	f3 0f 10 8d f8
	fe ff ff	 movss	 xmm1, DWORD PTR _x2$7[ebp]
  00683	f3 0f 5c 8d 04
	ff ff ff	 subss	 xmm1, DWORD PTR _x1$8[ebp]
  0068b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0068f	f3 0f 10 8d bc
	fe ff ff	 movss	 xmm1, DWORD PTR _u2$2[ebp]
  00697	f3 0f 5c 8d d4
	fe ff ff	 subss	 xmm1, DWORD PTR _u1$4[ebp]
  0069f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  006a3	f3 0f 58 85 d4
	fe ff ff	 addss	 xmm0, DWORD PTR _u1$4[ebp]
  006ab	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR _u2$2[ebp], xmm0

; 3029 :                             x2 = clip_rect.z;

  006b3	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  006b6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  006bb	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR _x2$7[ebp], xmm0
$LN36@RenderText:

; 3030 :                         }
; 3031 :                         if (y2 > clip_rect.w)

  006c3	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  006c6	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$5[ebp]
  006ce	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  006d2	76 58		 jbe	 SHORT $LN37@RenderText

; 3032 :                         {
; 3033 :                             v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);

  006d4	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  006d7	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  006dc	f3 0f 5c 85 ec
	fe ff ff	 subss	 xmm0, DWORD PTR _y1$6[ebp]
  006e4	f3 0f 10 8d e0
	fe ff ff	 movss	 xmm1, DWORD PTR _y2$5[ebp]
  006ec	f3 0f 5c 8d ec
	fe ff ff	 subss	 xmm1, DWORD PTR _y1$6[ebp]
  006f4	f3 0f 5e c1	 divss	 xmm0, xmm1
  006f8	f3 0f 10 8d b0
	fe ff ff	 movss	 xmm1, DWORD PTR _v2$1[ebp]
  00700	f3 0f 5c 8d c8
	fe ff ff	 subss	 xmm1, DWORD PTR _v1$3[ebp]
  00708	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0070c	f3 0f 58 85 c8
	fe ff ff	 addss	 xmm0, DWORD PTR _v1$3[ebp]
  00714	f3 0f 11 85 b0
	fe ff ff	 movss	 DWORD PTR _v2$1[ebp], xmm0

; 3034 :                             y2 = clip_rect.w;

  0071c	8b 45 1c	 mov	 eax, DWORD PTR _clip_rect$[ebp]
  0071f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00724	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _y2$5[ebp], xmm0
$LN37@RenderText:

; 3035 :                         }
; 3036 :                         if (y1 >= y2)

  0072c	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$6[ebp]
  00734	0f 2f 85 e0 fe
	ff ff		 comiss	 xmm0, DWORD PTR _y2$5[ebp]
  0073b	72 17		 jb	 SHORT $LN38@RenderText

; 3037 :                         {
; 3038 :                             x += char_width;

  0073d	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _x$[ebp]
  00742	f3 0f 58 85 1c
	ff ff ff	 addss	 xmm0, DWORD PTR _char_width$10[ebp]
  0074a	f3 0f 11 45 e8	 movss	 DWORD PTR _x$[ebp], xmm0

; 3039 :                             continue;

  0074f	e9 46 fb ff ff	 jmp	 $LN49@RenderText
$LN38@RenderText:

; 3040 :                         }
; 3041 :                     }
; 3042 : 
; 3043 :                     // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
; 3044 :                     {
; 3045 :                         idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);

  00754	b8 02 00 00 00	 mov	 eax, 2
  00759	6b c8 00	 imul	 ecx, eax, 0
  0075c	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _idx_write$[ebp]
  00762	66 8b 85 40 ff
	ff ff		 mov	 ax, WORD PTR _vtx_current_idx$[ebp]
  00769	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  0076d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _vtx_current_idx$[ebp]
  00773	83 c0 01	 add	 eax, 1
  00776	b9 02 00 00 00	 mov	 ecx, 2
  0077b	c1 e1 00	 shl	 ecx, 0
  0077e	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _idx_write$[ebp]
  00784	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00788	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _vtx_current_idx$[ebp]
  0078e	83 c0 02	 add	 eax, 2
  00791	b9 02 00 00 00	 mov	 ecx, 2
  00796	d1 e1		 shl	 ecx, 1
  00798	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _idx_write$[ebp]
  0079e	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 3046 :                         idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);

  007a2	b8 02 00 00 00	 mov	 eax, 2
  007a7	6b c8 03	 imul	 ecx, eax, 3
  007aa	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _idx_write$[ebp]
  007b0	66 8b 85 40 ff
	ff ff		 mov	 ax, WORD PTR _vtx_current_idx$[ebp]
  007b7	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  007bb	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _vtx_current_idx$[ebp]
  007c1	83 c0 02	 add	 eax, 2
  007c4	b9 02 00 00 00	 mov	 ecx, 2
  007c9	c1 e1 02	 shl	 ecx, 2
  007cc	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _idx_write$[ebp]
  007d2	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  007d6	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _vtx_current_idx$[ebp]
  007dc	83 c0 03	 add	 eax, 3
  007df	b9 02 00 00 00	 mov	 ecx, 2
  007e4	6b d1 05	 imul	 edx, ecx, 5
  007e7	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _idx_write$[ebp]
  007ed	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 3047 :                         vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;

  007f1	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  007f6	6b c8 00	 imul	 ecx, eax, 0
  007f9	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  007ff	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _x1$8[ebp]
  00807	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  0080c	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00811	6b c8 00	 imul	 ecx, eax, 0
  00814	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  0081a	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$6[ebp]
  00822	f3 0f 11 44 0a
	04		 movss	 DWORD PTR [edx+ecx+4], xmm0
  00828	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0082d	6b c8 00	 imul	 ecx, eax, 0
  00830	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  00836	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00839	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax
  0083d	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00842	6b c8 00	 imul	 ecx, eax, 0
  00845	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  0084b	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _u1$4[ebp]
  00853	f3 0f 11 44 0a
	08		 movss	 DWORD PTR [edx+ecx+8], xmm0
  00859	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0085e	6b c8 00	 imul	 ecx, eax, 0
  00861	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  00867	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR _v1$3[ebp]
  0086f	f3 0f 11 44 0a
	0c		 movss	 DWORD PTR [edx+ecx+12], xmm0

; 3048 :                         vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;

  00875	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0087a	c1 e0 00	 shl	 eax, 0
  0087d	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  00883	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$7[ebp]
  0088b	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  00890	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00895	c1 e0 00	 shl	 eax, 0
  00898	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  0089e	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _y1$6[ebp]
  008a6	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0
  008ac	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008b1	c1 e0 00	 shl	 eax, 0
  008b4	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  008ba	8b 55 18	 mov	 edx, DWORD PTR _col$[ebp]
  008bd	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx
  008c1	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008c6	c1 e0 00	 shl	 eax, 0
  008c9	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  008cf	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR _u2$2[ebp]
  008d7	f3 0f 11 44 01
	08		 movss	 DWORD PTR [ecx+eax+8], xmm0
  008dd	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008e2	c1 e0 00	 shl	 eax, 0
  008e5	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  008eb	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR _v1$3[ebp]
  008f3	f3 0f 11 44 01
	0c		 movss	 DWORD PTR [ecx+eax+12], xmm0

; 3049 :                         vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;

  008f9	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008fe	d1 e0		 shl	 eax, 1
  00900	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  00906	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _x2$7[ebp]
  0090e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  00913	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00918	d1 e0		 shl	 eax, 1
  0091a	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  00920	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$5[ebp]
  00928	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0
  0092e	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00933	d1 e0		 shl	 eax, 1
  00935	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  0093b	8b 55 18	 mov	 edx, DWORD PTR _col$[ebp]
  0093e	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx
  00942	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00947	d1 e0		 shl	 eax, 1
  00949	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  0094f	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR _u2$2[ebp]
  00957	f3 0f 11 44 01
	08		 movss	 DWORD PTR [ecx+eax+8], xmm0
  0095d	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00962	d1 e0		 shl	 eax, 1
  00964	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  0096a	f3 0f 10 85 b0
	fe ff ff	 movss	 xmm0, DWORD PTR _v2$1[ebp]
  00972	f3 0f 11 44 01
	0c		 movss	 DWORD PTR [ecx+eax+12], xmm0

; 3050 :                         vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;

  00978	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0097d	6b c8 03	 imul	 ecx, eax, 3
  00980	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  00986	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _x1$8[ebp]
  0098e	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  00993	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00998	6b c8 03	 imul	 ecx, eax, 3
  0099b	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  009a1	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _y2$5[ebp]
  009a9	f3 0f 11 44 0a
	04		 movss	 DWORD PTR [edx+ecx+4], xmm0
  009af	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  009b4	6b c8 03	 imul	 ecx, eax, 3
  009b7	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  009bd	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  009c0	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax
  009c4	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  009c9	6b c8 03	 imul	 ecx, eax, 3
  009cc	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  009d2	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _u1$4[ebp]
  009da	f3 0f 11 44 0a
	08		 movss	 DWORD PTR [edx+ecx+8], xmm0
  009e0	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  009e5	6b c8 03	 imul	 ecx, eax, 3
  009e8	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _vtx_write$[ebp]
  009ee	f3 0f 10 85 b0
	fe ff ff	 movss	 xmm0, DWORD PTR _v2$1[ebp]
  009f6	f3 0f 11 44 0a
	0c		 movss	 DWORD PTR [edx+ecx+12], xmm0

; 3051 :                         vtx_write += 4;

  009fc	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _vtx_write$[ebp]
  00a02	83 c0 50	 add	 eax, 80			; 00000050H
  00a05	89 85 58 ff ff
	ff		 mov	 DWORD PTR _vtx_write$[ebp], eax

; 3052 :                         vtx_current_idx += 4;

  00a0b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _vtx_current_idx$[ebp]
  00a11	83 c0 04	 add	 eax, 4
  00a14	89 85 40 ff ff
	ff		 mov	 DWORD PTR _vtx_current_idx$[ebp], eax

; 3053 :                         idx_write += 6;

  00a1a	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _idx_write$[ebp]
  00a20	83 c0 0c	 add	 eax, 12			; 0000000cH
  00a23	89 85 4c ff ff
	ff		 mov	 DWORD PTR _idx_write$[ebp], eax
$LN32@RenderText:

; 3054 :                     }
; 3055 :                 }
; 3056 :             }
; 3057 :         }
; 3058 : 
; 3059 :         x += char_width;

  00a29	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _x$[ebp]
  00a2e	f3 0f 58 85 1c
	ff ff ff	 addss	 xmm0, DWORD PTR _char_width$10[ebp]
  00a36	f3 0f 11 45 e8	 movss	 DWORD PTR _x$[ebp], xmm0

; 3060 :     }

  00a3b	e9 5a f8 ff ff	 jmp	 $LN49@RenderText
$LN7@RenderText:

; 3061 : 
; 3062 :     // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
; 3063 :     draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()

  00a40	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00a43	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  00a49	2b 48 20	 sub	 ecx, DWORD PTR [eax+32]
  00a4c	8b c1		 mov	 eax, ecx
  00a4e	99		 cdq
  00a4f	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00a54	f7 f9		 idiv	 ecx
  00a56	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  00a59	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 3064 :     draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);

  00a5c	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00a5f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _idx_write$[ebp]
  00a65	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  00a68	d1 f9		 sar	 ecx, 1
  00a6a	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  00a6d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 3065 :     draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);

  00a70	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00a73	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a75	83 e9 01	 sub	 ecx, 1
  00a78	51		 push	 ecx
  00a79	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00a7c	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  00a81	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv437[ebp], eax
  00a87	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  00a8a	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _idx_expected_size$[ebp]
  00a90	2b 42 0c	 sub	 eax, DWORD PTR [edx+12]
  00a93	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR tv437[ebp]
  00a99	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a9b	2b d0		 sub	 edx, eax
  00a9d	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR tv437[ebp]
  00aa3	89 10		 mov	 DWORD PTR [eax], edx

; 3066 :     draw_list->_VtxWritePtr = vtx_write;

  00aa5	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00aa8	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_write$[ebp]
  00aae	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 3067 :     draw_list->_IdxWritePtr = idx_write;

  00ab1	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00ab4	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _idx_write$[ebp]
  00aba	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 3068 :     draw_list->_VtxCurrentIdx = vtx_current_idx;

  00abd	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00ac0	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _vtx_current_idx$[ebp]
  00ac6	89 48 34	 mov	 DWORD PTR [eax+52], ecx
$LN1@RenderText:

; 3069 : }

  00ac9	52		 push	 edx
  00aca	8b cd		 mov	 ecx, ebp
  00acc	50		 push	 eax
  00acd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN52@RenderText
  00ad3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00ad8	58		 pop	 eax
  00ad9	5a		 pop	 edx
  00ada	5f		 pop	 edi
  00adb	5e		 pop	 esi
  00adc	5b		 pop	 ebx
  00add	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ae0	33 cd		 xor	 ecx, ebp
  00ae2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ae7	81 c4 18 02 00
	00		 add	 esp, 536		; 00000218H
  00aed	3b ec		 cmp	 ebp, esp
  00aef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00af4	8b e5		 mov	 esp, ebp
  00af6	5d		 pop	 ebp
  00af7	c2 28 00	 ret	 40			; 00000028H
  00afa	66 90		 npad	 2
$LN52@RenderText:
  00afc	01 00 00 00	 DD	 1
  00b00	00 00 00 00	 DD	 $LN51@RenderText
$LN51@RenderText:
  00b04	28 ff ff ff	 DD	 -216			; ffffff28H
  00b08	04 00 00 00	 DD	 4
  00b0c	00 00 00 00	 DD	 $LN50@RenderText
$LN50@RenderText:
  00b10	63		 DB	 99			; 00000063H
  00b11	00		 DB	 0
?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z ENDP ; ImFont::RenderText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z
_TEXT	SEGMENT
tv80 = -296						; size = 4
$T1 = -288						; size = 8
$T2 = -272						; size = 8
$T3 = -256						; size = 8
$T4 = -240						; size = 8
_scale$5 = -32						; size = 4
_glyph$6 = -20						; size = 4
_this$ = -8						; size = 4
_draw_list$ = 8						; size = 4
_size$ = 12						; size = 4
_pos$ = 16						; size = 8
_col$ = 24						; size = 4
_c$ = 28						; size = 2
?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z PROC ; ImFont::RenderChar, COMDAT
; _this$ = ecx

; 2869 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd d8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-296]
  00013	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2870 :     if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.

  0002d	0f b7 45 1c	 movzx	 eax, WORD PTR _c$[ebp]
  00031	83 f8 20	 cmp	 eax, 32			; 00000020H
  00034	74 1b		 je	 SHORT $LN3@RenderChar
  00036	0f b7 45 1c	 movzx	 eax, WORD PTR _c$[ebp]
  0003a	83 f8 09	 cmp	 eax, 9
  0003d	74 12		 je	 SHORT $LN3@RenderChar
  0003f	0f b7 45 1c	 movzx	 eax, WORD PTR _c$[ebp]
  00043	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00046	74 09		 je	 SHORT $LN3@RenderChar
  00048	0f b7 45 1c	 movzx	 eax, WORD PTR _c$[ebp]
  0004c	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0004f	75 05		 jne	 SHORT $LN2@RenderChar
$LN3@RenderChar:

; 2871 :         return;

  00051	e9 70 01 00 00	 jmp	 $LN1@RenderChar
$LN2@RenderChar:

; 2872 :     if (const ImFontGlyph* glyph = FindGlyph(c))

  00056	0f b7 45 1c	 movzx	 eax, WORD PTR _c$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z ; ImFont::FindGlyph
  00063	89 45 ec	 mov	 DWORD PTR _glyph$6[ebp], eax
  00066	83 7d ec 00	 cmp	 DWORD PTR _glyph$6[ebp], 0
  0006a	0f 84 56 01 00
	00		 je	 $LN4@RenderChar

; 2873 :     {
; 2874 :         float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;

  00070	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _size$[ebp]
  00075	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0007c	72 17		 jb	 SHORT $LN6@RenderChar
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _size$[ebp]
  00086	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  0008b	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR tv80[ebp], xmm0
  00093	eb 10		 jmp	 SHORT $LN7@RenderChar
$LN6@RenderChar:
  00095	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0009d	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR tv80[ebp], xmm0
$LN7@RenderChar:
  000a5	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR tv80[ebp]
  000ad	f3 0f 11 45 e0	 movss	 DWORD PTR _scale$5[ebp], xmm0

; 2875 :         pos.x = IM_FLOOR(pos.x + DisplayOffset.x);

  000b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _pos$[ebp]
  000ba	f3 0f 58 40 30	 addss	 xmm0, DWORD PTR [eax+48]
  000bf	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000c3	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000c7	f3 0f 11 45 10	 movss	 DWORD PTR _pos$[ebp], xmm0

; 2876 :         pos.y = IM_FLOOR(pos.y + DisplayOffset.y);

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _pos$[ebp+4]
  000d4	f3 0f 58 40 34	 addss	 xmm0, DWORD PTR [eax+52]
  000d9	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000dd	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000e1	f3 0f 11 45 14	 movss	 DWORD PTR _pos$[ebp+4], xmm0

; 2877 :         draw_list->PrimReserve(6, 4);

  000e6	6a 04		 push	 4
  000e8	6a 06		 push	 6
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  000ed	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 2878 :         draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

  000f2	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d ec	 mov	 ecx, DWORD PTR _glyph$6[ebp]
  000f9	51		 push	 ecx
  000fa	f3 0f 10 41 24	 movss	 xmm0, DWORD PTR [ecx+36]
  000ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00104	8b 55 ec	 mov	 edx, DWORD PTR _glyph$6[ebp]
  00107	51		 push	 ecx
  00108	f3 0f 10 42 20	 movss	 xmm0, DWORD PTR [edx+32]
  0010d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00112	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00118	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0011d	50		 push	 eax
  0011e	8b 45 ec	 mov	 eax, DWORD PTR _glyph$6[ebp]
  00121	51		 push	 ecx
  00122	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  00127	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012c	8b 4d ec	 mov	 ecx, DWORD PTR _glyph$6[ebp]
  0012f	51		 push	 ecx
  00130	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  00135	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00140	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00145	50		 push	 eax
  00146	8b 55 ec	 mov	 edx, DWORD PTR _glyph$6[ebp]
  00149	f3 0f 10 42 14	 movss	 xmm0, DWORD PTR [edx+20]
  0014e	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _scale$5[ebp]
  00153	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _pos$[ebp+4]
  00158	51		 push	 ecx
  00159	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015e	8b 45 ec	 mov	 eax, DWORD PTR _glyph$6[ebp]
  00161	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00166	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _scale$5[ebp]
  0016b	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _pos$[ebp]
  00170	51		 push	 ecx
  00171	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00176	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0017c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00181	50		 push	 eax
  00182	8b 4d ec	 mov	 ecx, DWORD PTR _glyph$6[ebp]
  00185	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [ecx+12]
  0018a	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _scale$5[ebp]
  0018f	f3 0f 58 45 14	 addss	 xmm0, DWORD PTR _pos$[ebp+4]
  00194	51		 push	 ecx
  00195	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019a	8b 55 ec	 mov	 edx, DWORD PTR _glyph$6[ebp]
  0019d	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  001a2	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _scale$5[ebp]
  001a7	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _pos$[ebp]
  001ac	51		 push	 ecx
  001ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b2	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  001b8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001bd	50		 push	 eax
  001be	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  001c1	e8 00 00 00 00	 call	 ?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z ; ImDrawList::PrimRectUV
$LN4@RenderChar:
$LN1@RenderChar:

; 2879 :     }
; 2880 : }

  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	81 c4 28 01 00
	00		 add	 esp, 296		; 00000128H
  001cf	3b ec		 cmp	 ebp, esp
  001d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d6	8b e5		 mov	 esp, ebp
  001d8	5d		 pop	 ebp
  001d9	c2 18 00	 ret	 24			; 00000018H
?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z ENDP ; ImFont::RenderChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z
_TEXT	SEGMENT
tv144 = -332						; size = 4
tv138 = -332						; size = 4
tv86 = -332						; size = 4
_char_width$1 = -132					; size = 4
_next_s$2 = -120					; size = 4
_c$3 = -108						; size = 4
_s$ = -96						; size = 4
_inside_word$ = -81					; size = 1
_prev_word_end$ = -72					; size = 4
_word_end$ = -60					; size = 4
_blank_width$ = -48					; size = 4
_word_width$ = -36					; size = 4
_line_width$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_scale$ = 8						; size = 4
_text$ = 12						; size = 4
_text_end$ = 16						; size = 4
_wrap_width$ = 20					; size = 4
?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z PROC	; ImFont::CalcWordWrapPositionA, COMDAT
; _this$ = ecx

; 2676 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00013	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2677 :     // Simple word-wrapping for English, not full-featured. Please submit failing cases!
; 2678 :     // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
; 2679 : 
; 2680 :     // For references, possible wrap point marked with ^
; 2681 :     //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
; 2682 :     //      ^    ^    ^   ^   ^__    ^    ^
; 2683 : 
; 2684 :     // List of hardcoded separators: .,;!?'"
; 2685 : 
; 2686 :     // Skip extra blanks after a line returns (that includes not counting them in width computation)
; 2687 :     // e.g. "Hello    world" --> "Hello" "World"
; 2688 : 
; 2689 :     // Cut words that cannot possibly fit within one line.
; 2690 :     // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
; 2691 : 
; 2692 :     float line_width = 0.0f;

  00037	0f 57 c0	 xorps	 xmm0, xmm0
  0003a	f3 0f 11 45 e8	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2693 :     float word_width = 0.0f;

  0003f	0f 57 c0	 xorps	 xmm0, xmm0
  00042	f3 0f 11 45 dc	 movss	 DWORD PTR _word_width$[ebp], xmm0

; 2694 :     float blank_width = 0.0f;

  00047	0f 57 c0	 xorps	 xmm0, xmm0
  0004a	f3 0f 11 45 d0	 movss	 DWORD PTR _blank_width$[ebp], xmm0

; 2695 :     wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

  0004f	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _wrap_width$[ebp]
  00054	f3 0f 5e 45 08	 divss	 xmm0, DWORD PTR _scale$[ebp]
  00059	f3 0f 11 45 14	 movss	 DWORD PTR _wrap_width$[ebp], xmm0

; 2696 : 
; 2697 :     const char* word_end = text;

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _text$[ebp]
  00061	89 45 c4	 mov	 DWORD PTR _word_end$[ebp], eax

; 2698 :     const char* prev_word_end = NULL;

  00064	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _prev_word_end$[ebp], 0

; 2699 :     bool inside_word = true;

  0006b	c6 45 af 01	 mov	 BYTE PTR _inside_word$[ebp], 1

; 2700 : 
; 2701 :     const char* s = text;

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _text$[ebp]
  00072	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax
$LN25@CalcWordWr:

; 2702 :     while (s < text_end)

  00075	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00078	3b 45 10	 cmp	 eax, DWORD PTR _text_end$[ebp]
  0007b	0f 83 fb 01 00
	00		 jae	 $LN3@CalcWordWr

; 2703 :     {
; 2704 :         unsigned int c = (unsigned int)*s;

  00081	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00084	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00087	89 4d 94	 mov	 DWORD PTR _c$3[ebp], ecx

; 2705 :         const char* next_s;
; 2706 :         if (c < 0x80)

  0008a	81 7d 94 80 00
	00 00		 cmp	 DWORD PTR _c$3[ebp], 128 ; 00000080H
  00091	73 0b		 jae	 SHORT $LN4@CalcWordWr

; 2707 :             next_s = s + 1;

  00093	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00096	83 c0 01	 add	 eax, 1
  00099	89 45 88	 mov	 DWORD PTR _next_s$2[ebp], eax
  0009c	eb 1a		 jmp	 SHORT $LN5@CalcWordWr
$LN4@CalcWordWr:

; 2708 :         else
; 2709 :             next_s = s + ImTextCharFromUtf8(&c, s, text_end);

  0009e	8b 45 10	 mov	 eax, DWORD PTR _text_end$[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d a0	 mov	 ecx, DWORD PTR _s$[ebp]
  000a5	51		 push	 ecx
  000a6	8d 55 94	 lea	 edx, DWORD PTR _c$3[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPAIPBD1@Z ; ImTextCharFromUtf8
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	03 45 a0	 add	 eax, DWORD PTR _s$[ebp]
  000b5	89 45 88	 mov	 DWORD PTR _next_s$2[ebp], eax
$LN5@CalcWordWr:

; 2710 :         if (c == 0)

  000b8	83 7d 94 00	 cmp	 DWORD PTR _c$3[ebp], 0
  000bc	75 05		 jne	 SHORT $LN6@CalcWordWr

; 2711 :             break;

  000be	e9 b9 01 00 00	 jmp	 $LN3@CalcWordWr
$LN6@CalcWordWr:

; 2712 : 
; 2713 :         if (c < 32)

  000c3	83 7d 94 20	 cmp	 DWORD PTR _c$3[ebp], 32	; 00000020H
  000c7	73 42		 jae	 SHORT $LN9@CalcWordWr

; 2714 :         {
; 2715 :             if (c == '\n')

  000c9	83 7d 94 0a	 cmp	 DWORD PTR _c$3[ebp], 10	; 0000000aH
  000cd	75 2b		 jne	 SHORT $LN8@CalcWordWr

; 2716 :             {
; 2717 :                 line_width = word_width = blank_width = 0.0f;

  000cf	0f 57 c0	 xorps	 xmm0, xmm0
  000d2	f3 0f 11 45 d0	 movss	 DWORD PTR _blank_width$[ebp], xmm0
  000d7	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _blank_width$[ebp]
  000dc	f3 0f 11 45 dc	 movss	 DWORD PTR _word_width$[ebp], xmm0
  000e1	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _word_width$[ebp]
  000e6	f3 0f 11 45 e8	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2718 :                 inside_word = true;

  000eb	c6 45 af 01	 mov	 BYTE PTR _inside_word$[ebp], 1

; 2719 :                 s = next_s;

  000ef	8b 45 88	 mov	 eax, DWORD PTR _next_s$2[ebp]
  000f2	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 2720 :                 continue;

  000f5	e9 7b ff ff ff	 jmp	 $LN25@CalcWordWr
$LN8@CalcWordWr:

; 2721 :             }
; 2722 :             if (c == '\r')

  000fa	83 7d 94 0d	 cmp	 DWORD PTR _c$3[ebp], 13	; 0000000dH
  000fe	75 0b		 jne	 SHORT $LN9@CalcWordWr

; 2723 :             {
; 2724 :                 s = next_s;

  00100	8b 45 88	 mov	 eax, DWORD PTR _next_s$2[ebp]
  00103	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 2725 :                 continue;

  00106	e9 6a ff ff ff	 jmp	 $LN25@CalcWordWr
$LN9@CalcWordWr:

; 2726 :             }
; 2727 :         }
; 2728 : 
; 2729 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);

  0010b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0010e	8b 4d 94	 mov	 ecx, DWORD PTR _c$3[ebp]
  00111	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00113	7d 18		 jge	 SHORT $LN18@CalcWordWr
  00115	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00118	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011b	8b 4d 94	 mov	 ecx, DWORD PTR _c$3[ebp]
  0011e	f3 0f 10 04 88	 movss	 xmm0, DWORD PTR [eax+ecx*4]
  00123	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR tv86[ebp], xmm0
  0012b	eb 10		 jmp	 SHORT $LN19@CalcWordWr
$LN18@CalcWordWr:
  0012d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00130	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  00135	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR tv86[ebp], xmm0
$LN19@CalcWordWr:
  0013d	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR tv86[ebp]
  00145	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _char_width$1[ebp], xmm0

; 2730 :         if (ImCharIsBlankW(c))

  0014d	8b 45 94	 mov	 eax, DWORD PTR _c$3[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ?ImCharIsBlankW@@YA_NI@Z ; ImCharIsBlankW
  00156	83 c4 04	 add	 esp, 4
  00159	0f b6 c8	 movzx	 ecx, al
  0015c	85 c9		 test	 ecx, ecx
  0015e	74 40		 je	 SHORT $LN10@CalcWordWr

; 2731 :         {
; 2732 :             if (inside_word)

  00160	0f b6 45 af	 movzx	 eax, BYTE PTR _inside_word$[ebp]
  00164	85 c0		 test	 eax, eax
  00166	74 1d		 je	 SHORT $LN12@CalcWordWr

; 2733 :             {
; 2734 :                 line_width += blank_width;

  00168	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  0016d	f3 0f 58 45 d0	 addss	 xmm0, DWORD PTR _blank_width$[ebp]
  00172	f3 0f 11 45 e8	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2735 :                 blank_width = 0.0f;

  00177	0f 57 c0	 xorps	 xmm0, xmm0
  0017a	f3 0f 11 45 d0	 movss	 DWORD PTR _blank_width$[ebp], xmm0

; 2736 :                 word_end = s;

  0017f	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]
  00182	89 45 c4	 mov	 DWORD PTR _word_end$[ebp], eax
$LN12@CalcWordWr:

; 2737 :             }
; 2738 :             blank_width += char_width;

  00185	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _blank_width$[ebp]
  0018a	f3 0f 58 85 7c
	ff ff ff	 addss	 xmm0, DWORD PTR _char_width$1[ebp]
  00192	f3 0f 11 45 d0	 movss	 DWORD PTR _blank_width$[ebp], xmm0

; 2739 :             inside_word = false;

  00197	c6 45 af 00	 mov	 BYTE PTR _inside_word$[ebp], 0

; 2740 :         }

  0019b	e9 91 00 00 00	 jmp	 $LN11@CalcWordWr
$LN10@CalcWordWr:

; 2741 :         else
; 2742 :         {
; 2743 :             word_width += char_width;

  001a0	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _word_width$[ebp]
  001a5	f3 0f 58 85 7c
	ff ff ff	 addss	 xmm0, DWORD PTR _char_width$1[ebp]
  001ad	f3 0f 11 45 dc	 movss	 DWORD PTR _word_width$[ebp], xmm0

; 2744 :             if (inside_word)

  001b2	0f b6 45 af	 movzx	 eax, BYTE PTR _inside_word$[ebp]
  001b6	85 c0		 test	 eax, eax
  001b8	74 08		 je	 SHORT $LN13@CalcWordWr

; 2745 :             {
; 2746 :                 word_end = next_s;

  001ba	8b 45 88	 mov	 eax, DWORD PTR _next_s$2[ebp]
  001bd	89 45 c4	 mov	 DWORD PTR _word_end$[ebp], eax

; 2747 :             }

  001c0	eb 2c		 jmp	 SHORT $LN14@CalcWordWr
$LN13@CalcWordWr:

; 2748 :             else
; 2749 :             {
; 2750 :                 prev_word_end = word_end;

  001c2	8b 45 c4	 mov	 eax, DWORD PTR _word_end$[ebp]
  001c5	89 45 b8	 mov	 DWORD PTR _prev_word_end$[ebp], eax

; 2751 :                 line_width += word_width + blank_width;

  001c8	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _word_width$[ebp]
  001cd	f3 0f 58 45 d0	 addss	 xmm0, DWORD PTR _blank_width$[ebp]
  001d2	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _line_width$[ebp]
  001d7	f3 0f 11 45 e8	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2752 :                 word_width = blank_width = 0.0f;

  001dc	0f 57 c0	 xorps	 xmm0, xmm0
  001df	f3 0f 11 45 d0	 movss	 DWORD PTR _blank_width$[ebp], xmm0
  001e4	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _blank_width$[ebp]
  001e9	f3 0f 11 45 dc	 movss	 DWORD PTR _word_width$[ebp], xmm0
$LN14@CalcWordWr:

; 2753 :             }
; 2754 : 
; 2755 :             // Allow wrapping after punctuation.
; 2756 :             inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');

  001ee	83 7d 94 2e	 cmp	 DWORD PTR _c$3[ebp], 46	; 0000002eH
  001f2	74 2a		 je	 SHORT $LN20@CalcWordWr
  001f4	83 7d 94 2c	 cmp	 DWORD PTR _c$3[ebp], 44	; 0000002cH
  001f8	74 24		 je	 SHORT $LN20@CalcWordWr
  001fa	83 7d 94 3b	 cmp	 DWORD PTR _c$3[ebp], 59	; 0000003bH
  001fe	74 1e		 je	 SHORT $LN20@CalcWordWr
  00200	83 7d 94 21	 cmp	 DWORD PTR _c$3[ebp], 33	; 00000021H
  00204	74 18		 je	 SHORT $LN20@CalcWordWr
  00206	83 7d 94 3f	 cmp	 DWORD PTR _c$3[ebp], 63	; 0000003fH
  0020a	74 12		 je	 SHORT $LN20@CalcWordWr
  0020c	83 7d 94 22	 cmp	 DWORD PTR _c$3[ebp], 34	; 00000022H
  00210	74 0c		 je	 SHORT $LN20@CalcWordWr
  00212	c7 85 b4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv138[ebp], 1
  0021c	eb 0a		 jmp	 SHORT $LN21@CalcWordWr
$LN20@CalcWordWr:
  0021e	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv138[ebp], 0
$LN21@CalcWordWr:
  00228	8a 85 b4 fe ff
	ff		 mov	 al, BYTE PTR tv138[ebp]
  0022e	88 45 af	 mov	 BYTE PTR _inside_word$[ebp], al
$LN11@CalcWordWr:

; 2757 :         }
; 2758 : 
; 2759 :         // We ignore blank width at the end of the line (they can be skipped)
; 2760 :         if (line_width + word_width > wrap_width)

  00231	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  00236	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _word_width$[ebp]
  0023b	0f 2f 45 14	 comiss	 xmm0, DWORD PTR _wrap_width$[ebp]
  0023f	76 30		 jbe	 SHORT $LN15@CalcWordWr

; 2761 :         {
; 2762 :             // Words that cannot possibly fit within an entire line will be cut anywhere.
; 2763 :             if (word_width < wrap_width)

  00241	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _wrap_width$[ebp]
  00246	0f 2f 45 dc	 comiss	 xmm0, DWORD PTR _word_width$[ebp]
  0024a	76 23		 jbe	 SHORT $LN16@CalcWordWr

; 2764 :                 s = prev_word_end ? prev_word_end : word_end;

  0024c	83 7d b8 00	 cmp	 DWORD PTR _prev_word_end$[ebp], 0
  00250	74 0b		 je	 SHORT $LN22@CalcWordWr
  00252	8b 45 b8	 mov	 eax, DWORD PTR _prev_word_end$[ebp]
  00255	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv144[ebp], eax
  0025b	eb 09		 jmp	 SHORT $LN23@CalcWordWr
$LN22@CalcWordWr:
  0025d	8b 4d c4	 mov	 ecx, DWORD PTR _word_end$[ebp]
  00260	89 8d b4 fe ff
	ff		 mov	 DWORD PTR tv144[ebp], ecx
$LN23@CalcWordWr:
  00266	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR tv144[ebp]
  0026c	89 55 a0	 mov	 DWORD PTR _s$[ebp], edx
$LN16@CalcWordWr:

; 2765 :             break;

  0026f	eb 0b		 jmp	 SHORT $LN3@CalcWordWr
$LN15@CalcWordWr:

; 2766 :         }
; 2767 : 
; 2768 :         s = next_s;

  00271	8b 45 88	 mov	 eax, DWORD PTR _next_s$2[ebp]
  00274	89 45 a0	 mov	 DWORD PTR _s$[ebp], eax

; 2769 :     }

  00277	e9 f9 fd ff ff	 jmp	 $LN25@CalcWordWr
$LN3@CalcWordWr:

; 2770 : 
; 2771 :     return s;

  0027c	8b 45 a0	 mov	 eax, DWORD PTR _s$[ebp]

; 2772 : }

  0027f	52		 push	 edx
  00280	8b cd		 mov	 ecx, ebp
  00282	50		 push	 eax
  00283	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@CalcWordWr
  00289	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0028e	58		 pop	 eax
  0028f	5a		 pop	 edx
  00290	5f		 pop	 edi
  00291	5e		 pop	 esi
  00292	5b		 pop	 ebx
  00293	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00296	33 cd		 xor	 ecx, ebp
  00298	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029d	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  002a3	3b ec		 cmp	 ebp, esp
  002a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002aa	8b e5		 mov	 esp, ebp
  002ac	5d		 pop	 ebp
  002ad	c2 10 00	 ret	 16			; 00000010H
$LN28@CalcWordWr:
  002b0	01 00 00 00	 DD	 1
  002b4	00 00 00 00	 DD	 $LN27@CalcWordWr
$LN27@CalcWordWr:
  002b8	94 ff ff ff	 DD	 -108			; ffffff94H
  002bc	04 00 00 00	 DD	 4
  002c0	00 00 00 00	 DD	 $LN26@CalcWordWr
$LN26@CalcWordWr:
  002c4	63		 DB	 99			; 00000063H
  002c5	00		 DB	 0
?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z ENDP	; ImFont::CalcWordWrapPositionA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z
_TEXT	SEGMENT
tv156 = -348						; size = 4
tv74 = -345						; size = 1
_char_width$1 = -148					; size = 4
_c$2 = -136						; size = 4
_prev_s$3 = -124					; size = 4
_c$4 = -109						; size = 1
_s$ = -100						; size = 4
_word_wrap_eol$ = -88					; size = 4
_word_wrap_enabled$ = -73				; size = 1
_line_width$ = -64					; size = 4
_text_size$ = -52					; size = 8
_scale$ = -36						; size = 4
_line_height$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_size$ = 12						; size = 4
_max_width$ = 16					; size = 4
_wrap_width$ = 20					; size = 4
_text_begin$ = 24					; size = 4
_text_end$ = 28						; size = 4
_remaining$ = 32					; size = 4
?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z PROC ; ImFont::CalcTextSizeA, COMDAT
; _this$ = ecx

; 2775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd a4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-348]
  00013	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2776 :     if (!text_end)

  00037	83 7d 1c 00	 cmp	 DWORD PTR _text_end$[ebp], 0
  0003b	75 12		 jne	 SHORT $LN6@CalcTextSi

; 2777 :         text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

  0003d	8b 45 18	 mov	 eax, DWORD PTR _text_begin$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strlen
  00046	83 c4 04	 add	 esp, 4
  00049	03 45 18	 add	 eax, DWORD PTR _text_begin$[ebp]
  0004c	89 45 1c	 mov	 DWORD PTR _text_end$[ebp], eax
$LN6@CalcTextSi:

; 2778 : 
; 2779 :     const float line_height = size;

  0004f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _size$[ebp]
  00054	f3 0f 11 45 e8	 movss	 DWORD PTR _line_height$[ebp], xmm0

; 2780 :     const float scale = size / FontSize;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _size$[ebp]
  00061	f3 0f 5e 40 10	 divss	 xmm0, DWORD PTR [eax+16]
  00066	f3 0f 11 45 dc	 movss	 DWORD PTR _scale$[ebp], xmm0

; 2781 : 
; 2782 :     ImVec2 text_size = ImVec2(0,0);

  0006b	51		 push	 ecx
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	51		 push	 ecx
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007d	8d 4d cc	 lea	 ecx, DWORD PTR _text_size$[ebp]
  00080	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 2783 :     float line_width = 0.0f;

  00085	0f 57 c0	 xorps	 xmm0, xmm0
  00088	f3 0f 11 45 c0	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2784 : 
; 2785 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

  0008d	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _wrap_width$[ebp]
  00092	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00099	76 09		 jbe	 SHORT $LN28@CalcTextSi
  0009b	c6 85 a7 fe ff
	ff 01		 mov	 BYTE PTR tv74[ebp], 1
  000a2	eb 07		 jmp	 SHORT $LN29@CalcTextSi
$LN28@CalcTextSi:
  000a4	c6 85 a7 fe ff
	ff 00		 mov	 BYTE PTR tv74[ebp], 0
$LN29@CalcTextSi:
  000ab	8a 85 a7 fe ff
	ff		 mov	 al, BYTE PTR tv74[ebp]
  000b1	88 45 b7	 mov	 BYTE PTR _word_wrap_enabled$[ebp], al

; 2786 :     const char* word_wrap_eol = NULL;

  000b4	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _word_wrap_eol$[ebp], 0

; 2787 : 
; 2788 :     const char* s = text_begin;

  000bb	8b 45 18	 mov	 eax, DWORD PTR _text_begin$[ebp]
  000be	89 45 9c	 mov	 DWORD PTR _s$[ebp], eax
$LN34@CalcTextSi:

; 2789 :     while (s < text_end)

  000c1	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  000c4	3b 45 1c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  000c7	0f 83 0e 02 00
	00		 jae	 $LN3@CalcTextSi

; 2790 :     {
; 2791 :         if (word_wrap_enabled)

  000cd	0f b6 45 b7	 movzx	 eax, BYTE PTR _word_wrap_enabled$[ebp]
  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 d2 00 00
	00		 je	 $LN10@CalcTextSi

; 2792 :         {
; 2793 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 2794 :             if (!word_wrap_eol)

  000d9	83 7d a8 00	 cmp	 DWORD PTR _word_wrap_eol$[ebp], 0
  000dd	75 3f		 jne	 SHORT $LN9@CalcTextSi

; 2795 :             {
; 2796 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

  000df	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _wrap_width$[ebp]
  000e4	f3 0f 5c 45 c0	 subss	 xmm0, DWORD PTR _line_width$[ebp]
  000e9	51		 push	 ecx
  000ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ef	8b 45 1c	 mov	 eax, DWORD PTR _text_end$[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 9c	 mov	 ecx, DWORD PTR _s$[ebp]
  000f6	51		 push	 ecx
  000f7	51		 push	 ecx
  000f8	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _scale$[ebp]
  000fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00102	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z ; ImFont::CalcWordWrapPositionA
  0010a	89 45 a8	 mov	 DWORD PTR _word_wrap_eol$[ebp], eax

; 2797 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

  0010d	8b 45 a8	 mov	 eax, DWORD PTR _word_wrap_eol$[ebp]
  00110	3b 45 9c	 cmp	 eax, DWORD PTR _s$[ebp]
  00113	75 09		 jne	 SHORT $LN9@CalcTextSi

; 2798 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

  00115	8b 45 a8	 mov	 eax, DWORD PTR _word_wrap_eol$[ebp]
  00118	83 c0 01	 add	 eax, 1
  0011b	89 45 a8	 mov	 DWORD PTR _word_wrap_eol$[ebp], eax
$LN9@CalcTextSi:

; 2799 :             }
; 2800 : 
; 2801 :             if (s >= word_wrap_eol)

  0011e	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  00121	3b 45 a8	 cmp	 eax, DWORD PTR _word_wrap_eol$[ebp]
  00124	0f 82 81 00 00
	00		 jb	 $LN10@CalcTextSi

; 2802 :             {
; 2803 :                 if (text_size.x < line_width)

  0012a	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  0012f	0f 2f 45 cc	 comiss	 xmm0, DWORD PTR _text_size$[ebp]
  00133	76 0a		 jbe	 SHORT $LN11@CalcTextSi

; 2804 :                     text_size.x = line_width;

  00135	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  0013a	f3 0f 11 45 cc	 movss	 DWORD PTR _text_size$[ebp], xmm0
$LN11@CalcTextSi:

; 2805 :                 text_size.y += line_height;

  0013f	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  00144	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  00149	f3 0f 11 45 d0	 movss	 DWORD PTR _text_size$[ebp+4], xmm0

; 2806 :                 line_width = 0.0f;

  0014e	0f 57 c0	 xorps	 xmm0, xmm0
  00151	f3 0f 11 45 c0	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2807 :                 word_wrap_eol = NULL;

  00156	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _word_wrap_eol$[ebp], 0
$LN4@CalcTextSi:

; 2808 : 
; 2809 :                 // Wrapping skips upcoming blanks
; 2810 :                 while (s < text_end)

  0015d	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  00160	3b 45 1c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  00163	73 41		 jae	 SHORT $LN5@CalcTextSi

; 2811 :                 {
; 2812 :                     const char c = *s;

  00165	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  00168	8a 08		 mov	 cl, BYTE PTR [eax]
  0016a	88 4d 93	 mov	 BYTE PTR _c$4[ebp], cl

; 2813 :                     if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

  0016d	0f b6 45 93	 movzx	 eax, BYTE PTR _c$4[ebp]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 ?ImCharIsBlankA@@YA_ND@Z ; ImCharIsBlankA
  00177	83 c4 04	 add	 esp, 4
  0017a	0f b6 c8	 movzx	 ecx, al
  0017d	85 c9		 test	 ecx, ecx
  0017f	74 0b		 je	 SHORT $LN12@CalcTextSi
  00181	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  00184	83 c0 01	 add	 eax, 1
  00187	89 45 9c	 mov	 DWORD PTR _s$[ebp], eax
  0018a	eb 18		 jmp	 SHORT $LN15@CalcTextSi
$LN12@CalcTextSi:
  0018c	0f be 45 93	 movsx	 eax, BYTE PTR _c$4[ebp]
  00190	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00193	75 0d		 jne	 SHORT $LN14@CalcTextSi
  00195	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  00198	83 c0 01	 add	 eax, 1
  0019b	89 45 9c	 mov	 DWORD PTR _s$[ebp], eax
  0019e	eb 06		 jmp	 SHORT $LN5@CalcTextSi
  001a0	eb 02		 jmp	 SHORT $LN15@CalcTextSi
$LN14@CalcTextSi:
  001a2	eb 02		 jmp	 SHORT $LN5@CalcTextSi
$LN15@CalcTextSi:

; 2814 :                 }

  001a4	eb b7		 jmp	 SHORT $LN4@CalcTextSi
$LN5@CalcTextSi:

; 2815 :                 continue;

  001a6	e9 16 ff ff ff	 jmp	 $LN34@CalcTextSi
$LN10@CalcTextSi:

; 2816 :             }
; 2817 :         }
; 2818 : 
; 2819 :         // Decode and advance source
; 2820 :         const char* prev_s = s;

  001ab	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  001ae	89 45 84	 mov	 DWORD PTR _prev_s$3[ebp], eax

; 2821 :         unsigned int c = (unsigned int)*s;

  001b1	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  001b4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001b7	89 8d 78 ff ff
	ff		 mov	 DWORD PTR _c$2[ebp], ecx

; 2822 :         if (c < 0x80)

  001bd	81 bd 78 ff ff
	ff 80 00 00 00	 cmp	 DWORD PTR _c$2[ebp], 128 ; 00000080H
  001c7	73 0b		 jae	 SHORT $LN16@CalcTextSi

; 2823 :         {
; 2824 :             s += 1;

  001c9	8b 45 9c	 mov	 eax, DWORD PTR _s$[ebp]
  001cc	83 c0 01	 add	 eax, 1
  001cf	89 45 9c	 mov	 DWORD PTR _s$[ebp], eax

; 2825 :         }

  001d2	eb 2b		 jmp	 SHORT $LN18@CalcTextSi
$LN16@CalcTextSi:

; 2826 :         else
; 2827 :         {
; 2828 :             s += ImTextCharFromUtf8(&c, s, text_end);

  001d4	8b 45 1c	 mov	 eax, DWORD PTR _text_end$[ebp]
  001d7	50		 push	 eax
  001d8	8b 4d 9c	 mov	 ecx, DWORD PTR _s$[ebp]
  001db	51		 push	 ecx
  001dc	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _c$2[ebp]
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPAIPBD1@Z ; ImTextCharFromUtf8
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001eb	03 45 9c	 add	 eax, DWORD PTR _s$[ebp]
  001ee	89 45 9c	 mov	 DWORD PTR _s$[ebp], eax

; 2829 :             if (c == 0) // Malformed UTF-8?

  001f1	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _c$2[ebp], 0
  001f8	75 05		 jne	 SHORT $LN18@CalcTextSi

; 2830 :                 break;

  001fa	e9 dc 00 00 00	 jmp	 $LN3@CalcTextSi
$LN18@CalcTextSi:

; 2831 :         }
; 2832 : 
; 2833 :         if (c < 32)

  001ff	83 bd 78 ff ff
	ff 20		 cmp	 DWORD PTR _c$2[ebp], 32	; 00000020H
  00206	73 54		 jae	 SHORT $LN21@CalcTextSi

; 2834 :         {
; 2835 :             if (c == '\n')

  00208	83 bd 78 ff ff
	ff 0a		 cmp	 DWORD PTR _c$2[ebp], 10	; 0000000aH
  0020f	75 3d		 jne	 SHORT $LN20@CalcTextSi

; 2836 :             {
; 2837 :                 text_size.x = ImMax(text_size.x, line_width);

  00211	51		 push	 ecx
  00212	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  00217	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021c	51		 push	 ecx
  0021d	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _text_size$[ebp]
  00222	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00227	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0022c	83 c4 08	 add	 esp, 8
  0022f	d9 5d cc	 fstp	 DWORD PTR _text_size$[ebp]

; 2838 :                 text_size.y += line_height;

  00232	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  00237	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  0023c	f3 0f 11 45 d0	 movss	 DWORD PTR _text_size$[ebp+4], xmm0

; 2839 :                 line_width = 0.0f;

  00241	0f 57 c0	 xorps	 xmm0, xmm0
  00244	f3 0f 11 45 c0	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2840 :                 continue;

  00249	e9 73 fe ff ff	 jmp	 $LN34@CalcTextSi
$LN20@CalcTextSi:

; 2841 :             }
; 2842 :             if (c == '\r')

  0024e	83 bd 78 ff ff
	ff 0d		 cmp	 DWORD PTR _c$2[ebp], 13	; 0000000dH
  00255	75 05		 jne	 SHORT $LN21@CalcTextSi

; 2843 :                 continue;

  00257	e9 65 fe ff ff	 jmp	 $LN34@CalcTextSi
$LN21@CalcTextSi:

; 2844 :         }
; 2845 : 
; 2846 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;

  0025c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0025f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _c$2[ebp]
  00265	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00267	7d 1b		 jge	 SHORT $LN30@CalcTextSi
  00269	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0026c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0026f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _c$2[ebp]
  00275	f3 0f 10 04 88	 movss	 xmm0, DWORD PTR [eax+ecx*4]
  0027a	f3 0f 11 85 a4
	fe ff ff	 movss	 DWORD PTR tv156[ebp], xmm0
  00282	eb 10		 jmp	 SHORT $LN31@CalcTextSi
$LN30@CalcTextSi:
  00284	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00287	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  0028c	f3 0f 11 85 a4
	fe ff ff	 movss	 DWORD PTR tv156[ebp], xmm0
$LN31@CalcTextSi:
  00294	f3 0f 10 85 a4
	fe ff ff	 movss	 xmm0, DWORD PTR tv156[ebp]
  0029c	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR _scale$[ebp]
  002a1	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _char_width$1[ebp], xmm0

; 2847 :         if (line_width + char_width >= max_width)

  002a9	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  002ae	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _char_width$1[ebp]
  002b6	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _max_width$[ebp]
  002ba	72 08		 jb	 SHORT $LN22@CalcTextSi

; 2848 :         {
; 2849 :             s = prev_s;

  002bc	8b 45 84	 mov	 eax, DWORD PTR _prev_s$3[ebp]
  002bf	89 45 9c	 mov	 DWORD PTR _s$[ebp], eax

; 2850 :             break;

  002c2	eb 17		 jmp	 SHORT $LN3@CalcTextSi
$LN22@CalcTextSi:

; 2851 :         }
; 2852 : 
; 2853 :         line_width += char_width;

  002c4	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  002c9	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR _char_width$1[ebp]
  002d1	f3 0f 11 45 c0	 movss	 DWORD PTR _line_width$[ebp], xmm0

; 2854 :     }

  002d6	e9 e6 fd ff ff	 jmp	 $LN34@CalcTextSi
$LN3@CalcTextSi:

; 2855 : 
; 2856 :     if (text_size.x < line_width)

  002db	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  002e0	0f 2f 45 cc	 comiss	 xmm0, DWORD PTR _text_size$[ebp]
  002e4	76 0a		 jbe	 SHORT $LN23@CalcTextSi

; 2857 :         text_size.x = line_width;

  002e6	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  002eb	f3 0f 11 45 cc	 movss	 DWORD PTR _text_size$[ebp], xmm0
$LN23@CalcTextSi:

; 2858 : 
; 2859 :     if (line_width > 0 || text_size.y == 0.0f)

  002f0	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _line_width$[ebp]
  002f5	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002fc	77 12		 ja	 SHORT $LN25@CalcTextSi
  002fe	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  00303	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0030a	9f		 lahf
  0030b	f6 c4 44	 test	 ah, 68			; 00000044H
  0030e	7a 0f		 jp	 SHORT $LN24@CalcTextSi
$LN25@CalcTextSi:

; 2860 :         text_size.y += line_height;

  00310	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _text_size$[ebp+4]
  00315	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _line_height$[ebp]
  0031a	f3 0f 11 45 d0	 movss	 DWORD PTR _text_size$[ebp+4], xmm0
$LN24@CalcTextSi:

; 2861 : 
; 2862 :     if (remaining)

  0031f	83 7d 20 00	 cmp	 DWORD PTR _remaining$[ebp], 0
  00323	74 08		 je	 SHORT $LN26@CalcTextSi

; 2863 :         *remaining = s;

  00325	8b 45 20	 mov	 eax, DWORD PTR _remaining$[ebp]
  00328	8b 4d 9c	 mov	 ecx, DWORD PTR _s$[ebp]
  0032b	89 08		 mov	 DWORD PTR [eax], ecx
$LN26@CalcTextSi:

; 2864 : 
; 2865 :     return text_size;

  0032d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00330	8b 4d cc	 mov	 ecx, DWORD PTR _text_size$[ebp]
  00333	89 08		 mov	 DWORD PTR [eax], ecx
  00335	8b 55 d0	 mov	 edx, DWORD PTR _text_size$[ebp+4]
  00338	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0033b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2866 : }

  0033e	52		 push	 edx
  0033f	8b cd		 mov	 ecx, ebp
  00341	50		 push	 eax
  00342	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN38@CalcTextSi
  00348	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0034d	58		 pop	 eax
  0034e	5a		 pop	 edx
  0034f	5f		 pop	 edi
  00350	5e		 pop	 esi
  00351	5b		 pop	 ebx
  00352	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00355	33 cd		 xor	 ecx, ebp
  00357	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035c	81 c4 5c 01 00
	00		 add	 esp, 348		; 0000015cH
  00362	3b ec		 cmp	 ebp, esp
  00364	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00369	8b e5		 mov	 esp, ebp
  0036b	5d		 pop	 ebp
  0036c	c2 1c 00	 ret	 28			; 0000001cH
  0036f	90		 npad	 1
$LN38@CalcTextSi:
  00370	02 00 00 00	 DD	 2
  00374	00 00 00 00	 DD	 $LN37@CalcTextSi
$LN37@CalcTextSi:
  00378	cc ff ff ff	 DD	 -52			; ffffffccH
  0037c	08 00 00 00	 DD	 8
  00380	00 00 00 00	 DD	 $LN35@CalcTextSi
  00384	78 ff ff ff	 DD	 -136			; ffffff78H
  00388	04 00 00 00	 DD	 4
  0038c	00 00 00 00	 DD	 $LN36@CalcTextSi
$LN36@CalcTextSi:
  00390	63		 DB	 99			; 00000063H
  00391	00		 DB	 0
$LN35@CalcTextSi:
  00392	74		 DB	 116			; 00000074H
  00393	65		 DB	 101			; 00000065H
  00394	78		 DB	 120			; 00000078H
  00395	74		 DB	 116			; 00000074H
  00396	5f		 DB	 95			; 0000005fH
  00397	73		 DB	 115			; 00000073H
  00398	69		 DB	 105			; 00000069H
  00399	7a		 DB	 122			; 0000007aH
  0039a	65		 DB	 101			; 00000065H
  0039b	00		 DB	 0
?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z ENDP ; ImFont::CalcTextSizeA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?IsLoaded@ImFont@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?IsLoaded@ImFont@@QBE_NXZ PROC				; ImFont::IsLoaded, COMDAT
; _this$ = ecx

; 2227 :     bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00034	74 0c		 je	 SHORT $LN3@IsLoaded
  00036	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  00040	eb 0a		 jmp	 SHORT $LN4@IsLoaded
$LN3@IsLoaded:
  00042	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsLoaded:
  0004c	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?IsLoaded@ImFont@@QBE_NXZ ENDP				; ImFont::IsLoaded
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?FindGlyphNoFallback@ImFont@@QBEPBUImFontGlyph@@G@Z
_TEXT	SEGMENT
_i$ = -20						; size = 2
_this$ = -8						; size = 4
_c$ = 8							; size = 2
?FindGlyphNoFallback@ImFont@@QBEPBUImFontGlyph@@G@Z PROC ; ImFont::FindGlyphNoFallback, COMDAT
; _this$ = ecx

; 2666 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2667 :     if (c >= IndexLookup.Size)

  0002d	0f b7 45 08	 movzx	 eax, WORD PTR _c$[ebp]
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00037	7c 04		 jl	 SHORT $LN2@FindGlyphN

; 2668 :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 2e		 jmp	 SHORT $LN1@FindGlyphN
$LN2@FindGlyphN:

; 2669 :     const ImWchar i = IndexLookup.Data[c];

  0003d	0f b7 45 08	 movzx	 eax, WORD PTR _c$[ebp]
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00047	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  0004b	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax

; 2670 :     if (i == (ImWchar)-1)

  0004f	0f b7 45 ec	 movzx	 eax, WORD PTR _i$[ebp]
  00053	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00058	75 04		 jne	 SHORT $LN3@FindGlyphN

; 2671 :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 0d		 jmp	 SHORT $LN1@FindGlyphN
$LN3@FindGlyphN:

; 2672 :     return &Glyphs.Data[i];

  0005e	0f b7 45 ec	 movzx	 eax, WORD PTR _i$[ebp]
  00062	6b c0 28	 imul	 eax, eax, 40
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	03 41 28	 add	 eax, DWORD PTR [ecx+40]
$LN1@FindGlyphN:

; 2673 : }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
?FindGlyphNoFallback@ImFont@@QBEPBUImFontGlyph@@G@Z ENDP ; ImFont::FindGlyphNoFallback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z
_TEXT	SEGMENT
_i$ = -20						; size = 2
_this$ = -8						; size = 4
_c$ = 8							; size = 2
?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z PROC		; ImFont::FindGlyph, COMDAT
; _this$ = ecx

; 2656 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2657 :     if (c >= IndexLookup.Size)

  0002d	0f b7 45 08	 movzx	 eax, WORD PTR _c$[ebp]
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00037	7c 08		 jl	 SHORT $LN2@FindGlyph

; 2658 :         return FallbackGlyph;

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0003f	eb 32		 jmp	 SHORT $LN1@FindGlyph
$LN2@FindGlyph:

; 2659 :     const ImWchar i = IndexLookup.Data[c];

  00041	0f b7 45 08	 movzx	 eax, WORD PTR _c$[ebp]
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004b	66 8b 04 42	 mov	 ax, WORD PTR [edx+eax*2]
  0004f	66 89 45 ec	 mov	 WORD PTR _i$[ebp], ax

; 2660 :     if (i == (ImWchar)-1)

  00053	0f b7 45 ec	 movzx	 eax, WORD PTR _i$[ebp]
  00057	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0005c	75 08		 jne	 SHORT $LN3@FindGlyph

; 2661 :         return FallbackGlyph;

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00064	eb 0d		 jmp	 SHORT $LN1@FindGlyph
$LN3@FindGlyph:

; 2662 :     return &Glyphs.Data[i];

  00066	0f b7 45 ec	 movzx	 eax, WORD PTR _i$[ebp]
  0006a	6b c0 28	 imul	 eax, eax, 40
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	03 41 28	 add	 eax, DWORD PTR [ecx+40]
$LN1@FindGlyph:

; 2663 : }

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?FindGlyph@ImFont@@QBEPBUImFontGlyph@@G@Z ENDP		; ImFont::FindGlyph
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ??1ImFont@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ImFont@@QAE@XZ PROC					; ImFont::~ImFont, COMDAT
; _this$ = ecx

; 2543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ImFont@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2544 :     ClearOutputData();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QAEXXZ ; ImFont::ClearOutputData

; 2545 : }

  00054	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 20	 add	 ecx, 32			; 00000020H
  0005a	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontGlyph@@@@QAE@XZ ; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	83 c1 14	 add	 ecx, 20			; 00000014H
  00065	e8 00 00 00 00	 call	 ??1?$ImVector@G@@QAE@XZ	; ImVector<unsigned short>::~ImVector<unsigned short>
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ??1?$ImVector@M@@QAE@XZ	; ImVector<float>::~ImVector<float>
  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007c	59		 pop	 ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
  00091	cc		 int	 3
  00092	cc		 int	 3
  00093	cc		 int	 3
  00094	cc		 int	 3
  00095	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImFont@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ImFont@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ImFont@@QAE@XZ ENDP					; ImFont::~ImFont
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ??0ImFont@@QAE@XZ
_TEXT	SEGMENT
$T2 = -228						; size = 8
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ImFont@@QAE@XZ PROC					; ImFont::ImFont, COMDAT
; _this$ = ecx

; 2526 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImFont@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00021	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??0?$ImVector@M@@QAE@XZ	; ImVector<float>::ImVector<float>
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 14	 add	 ecx, 20			; 00000014H
  00061	e8 00 00 00 00	 call	 ??0?$ImVector@G@@QAE@XZ	; ImVector<unsigned short>::ImVector<unsigned short>
  00066	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	83 c1 20	 add	 ecx, 32			; 00000020H
  00070	e8 00 00 00 00	 call	 ??0?$ImVector@UImFontGlyph@@@@QAE@XZ ; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
  00075	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 c1 30	 add	 ecx, 48			; 00000030H
  0007f	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2

; 2527 :     FontSize = 0.0f;

  00084	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00087	0f 57 c0	 xorps	 xmm0, xmm0
  0008a	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 2528 :     FallbackAdvanceX = 0.0f;

  0008f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00092	0f 57 c0	 xorps	 xmm0, xmm0
  00095	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 2529 :     FallbackChar = (ImWchar)'?';

  0009a	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	66 89 41 42	 mov	 WORD PTR [ecx+66], ax

; 2530 :     EllipsisChar = (ImWchar)-1;

  000a6	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	66 89 41 44	 mov	 WORD PTR [ecx+68], ax

; 2531 :     DisplayOffset = ImVec2(0.0f, 0.0f);

  000b2	51		 push	 ecx
  000b3	0f 57 c0	 xorps	 xmm0, xmm0
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	51		 push	 ecx
  000bc	0f 57 c0	 xorps	 xmm0, xmm0
  000bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c4	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000ca	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  000da	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 2532 :     FallbackGlyph = NULL;

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 2533 :     ContainerAtlas = NULL;

  000e7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 2534 :     ConfigData = NULL;

  000f1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 2535 :     ConfigDataCount = 0;

  000fb	33 c0		 xor	 eax, eax
  000fd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	66 89 41 40	 mov	 WORD PTR [ecx+64], ax

; 2536 :     DirtyLookupTables = false;

  00104	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00107	c6 40 58 00	 mov	 BYTE PTR [eax+88], 0

; 2537 :     Scale = 1.0f;

  0010b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0010e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00116	f3 0f 11 40 48	 movss	 DWORD PTR [eax+72], xmm0

; 2538 :     Ascent = Descent = 0.0f;

  0011b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	0f 57 c0	 xorps	 xmm0, xmm0
  00121	f3 0f 11 40 50	 movss	 DWORD PTR [eax+80], xmm0
  00126	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	0f 57 c0	 xorps	 xmm0, xmm0
  0012c	f3 0f 11 41 4c	 movss	 DWORD PTR [ecx+76], xmm0

; 2539 :     MetricsTotalSurface = 0;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00134	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [eax+84], 0

; 2540 : }

  0013b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00142	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00145	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00148	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014f	59		 pop	 ecx
  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00159	3b ec		 cmp	 ebp, esp
  0015b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImFont@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ImVector@M@@QAE@XZ	; ImVector<float>::~ImVector<float>
__unwindfunclet$??0ImFont@@QAE@XZ$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 14	 add	 ecx, 20			; 00000014H
  0000e	e9 00 00 00 00	 jmp	 ??1?$ImVector@G@@QAE@XZ	; ImVector<unsigned short>::~ImVector<unsigned short>
__unwindfunclet$??0ImFont@@QAE@XZ$2:
  00013	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 20	 add	 ecx, 32			; 00000020H
  00019	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontGlyph@@@@QAE@XZ ; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
__ehhandler$??0ImFont@@QAE@XZ:
  00023	90		 npad	 1
  00024	90		 npad	 1
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImFont@@QAE@XZ
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImFont@@QAE@XZ ENDP					; ImFont::ImFont
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontGlyph@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImFontGlyph@@@@QAEXH@Z PROC	; ImVector<ImFontGlyph>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 28	 imul	 eax, DWORD PTR _new_capacity$[ebp], 40
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImFontGlyph@@@@QAEXH@Z ENDP	; ImVector<ImFontGlyph>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontGlyph@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImFontGlyph@@@@QAEXH@Z PROC		; ImVector<ImFontGlyph>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImFontGlyph@@@@QBEHH@Z ; ImVector<ImFontGlyph>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImFontGlyph@@@@QAEXH@Z ; ImVector<ImFontGlyph>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImFontGlyph@@@@QAEXH@Z ENDP		; ImVector<ImFontGlyph>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontGlyph@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QBEHH@Z PROC	; ImVector<ImFontGlyph>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QBEHH@Z ENDP	; ImVector<ImFontGlyph>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@XZ PROC ; ImVector<ImFontGlyph>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	6b c1 28	 imul	 eax, ecx, 40
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?back@?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@XZ ENDP ; ImVector<ImFontGlyph>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontGlyph@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImFontGlyph@@@@QAEXXZ PROC		; ImVector<ImFontGlyph>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImFontGlyph@@@@QAEXXZ ENDP		; ImVector<ImFontGlyph>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@H@Z PROC ; ImVector<ImFontGlyph>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 28	 imul	 eax, DWORD PTR _i$[ebp], 40
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImFontGlyph@@@@QAEAAUImFontGlyph@@H@Z ENDP ; ImVector<ImFontGlyph>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontGlyph@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImFontGlyph@@@@QAE@XZ PROC		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImFontGlyph@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImFontGlyph@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImFontGlyph@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImFontGlyph@@@@QAE@XZ ENDP		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontGlyph@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImFontGlyph@@@@QAE@XZ PROC		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImFontGlyph@@@@QAE@XZ ENDP		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@M@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@M@@QAEXH@Z PROC			; ImVector<float>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 02	 shl	 eax, 2
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 02	 shl	 ecx, 2
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@M@@QAEXH@Z ENDP			; ImVector<float>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QAEXHABM@Z
_TEXT	SEGMENT
_n$1 = -20						; size = 4
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
_v$ = 12						; size = 4
?resize@?$ImVector@M@@QAEXHABM@Z PROC			; ImVector<float>::resize, COMDAT
; _this$ = ecx

; 1288 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN5@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@M@@QBEHH@Z ; ImVector<float>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@M@@QAEXH@Z ; ImVector<float>::reserve
$LN5@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00055	7e 38		 jle	 SHORT $LN6@resize
  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	89 4d ec	 mov	 DWORD PTR _n$1[ebp], ecx
  0005f	eb 09		 jmp	 SHORT $LN4@resize
$LN2@resize:
  00061	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 ec	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@resize:
  0006a	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  0006d	3b 45 08	 cmp	 eax, DWORD PTR _new_size$[ebp]
  00070	7d 1d		 jge	 SHORT $LN6@resize
  00072	6a 04		 push	 4
  00074	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  00081	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _memcpy
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	eb d2		 jmp	 SHORT $LN2@resize
$LN6@resize:
  0008f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
?resize@?$ImVector@M@@QAEXHABM@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@M@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@M@@QBEHH@Z PROC		; ImVector<float>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@M@@QBEHH@Z ENDP		; ImVector<float>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@M@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@M@@QAEXXZ PROC			; ImVector<float>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@M@@QAEXXZ ENDP			; ImVector<float>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QAEAAMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@M@@QAEAAMH@Z PROC				; ImVector<float>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@M@@QAEAAMH@Z ENDP				; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@M@@QAE@XZ PROC				; ImVector<float>::~ImVector<float>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@M@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@M@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@M@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@M@@QAE@XZ ENDP				; ImVector<float>::~ImVector<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@M@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@M@@QAE@XZ PROC				; ImVector<float>::ImVector<float>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@M@@QAE@XZ ENDP				; ImVector<float>::ImVector<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z PROC ; ImVector<ImFontConfig>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImFontConfig@@@@QBEHH@Z ; ImVector<ImFontConfig>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z ; ImVector<ImFontConfig>::reserve
$LN2@push_back:
  00054	6a 78		 push	 120			; 00000078H
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	6b 11 78	 imul	 edx, DWORD PTR [ecx], 120
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	83 c1 01	 add	 ecx, 1
  00077	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 0a		 mov	 DWORD PTR [edx], ecx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z ENDP ; ImVector<ImFontConfig>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z PROC	; ImVector<ImFontConfig>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 78	 imul	 eax, DWORD PTR _new_capacity$[ebp], 120
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 78	 imul	 ecx, DWORD PTR [eax], 120
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z ENDP	; ImVector<ImFontConfig>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontConfig@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImFontConfig@@@@QBEHH@Z PROC ; ImVector<ImFontConfig>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImFontConfig@@@@QBEHH@Z ENDP ; ImVector<ImFontConfig>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ PROC ; ImVector<ImFontConfig>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	6b c1 78	 imul	 eax, ecx, 120
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ ENDP ; ImVector<ImFontConfig>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontConfig@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImFontConfig@@@@QAEXXZ PROC		; ImVector<ImFontConfig>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImFontConfig@@@@QAEXXZ ENDP		; ImVector<ImFontConfig>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z PROC ; ImVector<ImFontConfig>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 78	 imul	 eax, DWORD PTR _i$[ebp], 120
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ENDP ; ImVector<ImFontConfig>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ PROC		; ImVector<ImFontConfig>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ ENDP		; ImVector<ImFontConfig>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontConfig@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImFontConfig@@@@QAE@XZ PROC		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImFontConfig@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImFontConfig@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImFontConfig@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImFontConfig@@@@QAE@XZ ENDP		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontConfig@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImFontConfig@@@@QAE@XZ PROC		; ImVector<ImFontConfig>::ImVector<ImFontConfig>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImFontConfig@@@@QAE@XZ ENDP		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QAEXABUImFontAtlasCustomRect@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QAEXABUImFontAtlasCustomRect@@@Z PROC ; ImVector<ImFontAtlasCustomRect>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QBEHH@Z ; ImVector<ImFontAtlasCustomRect>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QAEXH@Z ; ImVector<ImFontAtlasCustomRect>::reserve
$LN2@push_back:
  00054	6a 1c		 push	 28			; 0000001cH
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	6b 11 1c	 imul	 edx, DWORD PTR [ecx], 28
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	83 c1 01	 add	 ecx, 1
  00077	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 0a		 mov	 DWORD PTR [edx], ecx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QAEXABUImFontAtlasCustomRect@@@Z ENDP ; ImVector<ImFontAtlasCustomRect>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QAEXH@Z PROC ; ImVector<ImFontAtlasCustomRect>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 1c	 imul	 eax, DWORD PTR _new_capacity$[ebp], 28
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QAEXH@Z ENDP ; ImVector<ImFontAtlasCustomRect>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QBEHH@Z PROC ; ImVector<ImFontAtlasCustomRect>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QBEHH@Z ENDP ; ImVector<ImFontAtlasCustomRect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontAtlasCustomRect@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImFontAtlasCustomRect@@@@QAEXXZ PROC	; ImVector<ImFontAtlasCustomRect>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImFontAtlasCustomRect@@@@QAEXXZ ENDP	; ImVector<ImFontAtlasCustomRect>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z PROC ; ImVector<ImFontAtlasCustomRect>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 1c	 imul	 eax, DWORD PTR _i$[ebp], 28
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ENDP ; ImVector<ImFontAtlasCustomRect>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ PROC	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ ENDP	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ PROC	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ ENDP	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z PROC ; ImVector<ImFont *>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@PAUImFont@@@@QBEHH@Z ; ImVector<ImFont *>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z ; ImVector<ImFont *>::reserve
$LN2@push_back:
  00054	6a 04		 push	 4
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ENDP ; ImVector<ImFont *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z PROC		; ImVector<ImFont *>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 02	 shl	 eax, 2
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 02	 shl	 ecx, 2
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z ENDP		; ImVector<ImFont *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAUImFont@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAUImFont@@@@QBEHH@Z PROC	; ImVector<ImFont *>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@PAUImFont@@@@QBEHH@Z ENDP	; ImVector<ImFont *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ PROC	; ImVector<ImFont *>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00061	8d 44 88 fc	 lea	 eax, DWORD PTR [eax+ecx*4-4]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ ENDP	; ImVector<ImFont *>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAUImFont@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@PAUImFont@@@@QAEXXZ PROC		; ImVector<ImFont *>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@PAUImFont@@@@QAEXXZ ENDP		; ImVector<ImFont *>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z PROC	; ImVector<ImFont *>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ENDP	; ImVector<ImFont *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?size@?$ImVector@PAUImFont@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$ImVector@PAUImFont@@@@QBEHXZ PROC		; ImVector<ImFont *>::size, COMDAT
; _this$ = ecx

; 1269 :     inline int          size() const                        { return Size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?size@?$ImVector@PAUImFont@@@@QBEHXZ ENDP		; ImVector<ImFont *>::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PAUImFont@@@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@PAUImFont@@@@QBE_NXZ PROC		; ImVector<ImFont *>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@PAUImFont@@@@QBE_NXZ ENDP		; ImVector<ImFont *>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAUImFont@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAUImFont@@@@QAE@XZ PROC			; ImVector<ImFont *>::~ImVector<ImFont *>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@PAUImFont@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAUImFont@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@PAUImFont@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAUImFont@@@@QAE@XZ ENDP			; ImVector<ImFont *>::~ImVector<ImFont *>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAUImFont@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@PAUImFont@@@@QAE@XZ PROC			; ImVector<ImFont *>::ImVector<ImFont *>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@PAUImFont@@@@QAE@XZ ENDP			; ImVector<ImFont *>::ImVector<ImFont *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU2@1@Z
_TEXT	SEGMENT
$T1 = -360						; size = 8
$T2 = -344						; size = 8
$T3 = -328						; size = 8
$T4 = -312						; size = 8
$T5 = -296						; size = 8
$T6 = -280						; size = 8
$T7 = -264						; size = 8
_size$ = -56						; size = 8
_pos$ = -40						; size = 8
_r$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_cursor_type$ = 8					; size = 4
_out_offset$ = 12					; size = 4
_out_size$ = 16						; size = 4
_out_uv_border$ = 20					; size = 4
_out_uv_fill$ = 24					; size = 4
?GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU2@1@Z PROC ; ImFontAtlas::GetMouseCursorTexData, COMDAT
; _this$ = ecx

; 1803 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 94 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-364]
  00013	b9 5b 00 00 00	 mov	 ecx, 91			; 0000005bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1804 :     if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)

  00037	83 7d 08 ff	 cmp	 DWORD PTR _cursor_type$[ebp], -1
  0003b	7e 06		 jle	 SHORT $LN3@GetMouseCu
  0003d	83 7d 08 09	 cmp	 DWORD PTR _cursor_type$[ebp], 9
  00041	7c 07		 jl	 SHORT $LN2@GetMouseCu
$LN3@GetMouseCu:

; 1805 :         return false;

  00043	32 c0		 xor	 al, al
  00045	e9 35 02 00 00	 jmp	 $LN1@GetMouseCu
$LN2@GetMouseCu:

; 1806 :     if (Flags & ImFontAtlasFlags_NoMouseCursors)

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00050	83 e1 02	 and	 ecx, 2
  00053	74 07		 je	 SHORT $LN4@GetMouseCu

; 1807 :         return false;

  00055	32 c0		 xor	 al, al
  00057	e9 23 02 00 00	 jmp	 $LN1@GetMouseCu
$LN4@GetMouseCu:

; 1808 : 
; 1809 :     IM_ASSERT(CustomRectIds[0] != -1);

  0005c	b8 04 00 00 00	 mov	 eax, 4
  00061	6b c8 00	 imul	 ecx, eax, 0
  00064	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00067	83 7c 0a 58 ff	 cmp	 DWORD PTR [edx+ecx+88], -1
  0006c	75 25		 jne	 SHORT $LN6@GetMouseCu
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU3@1@Z@4JA
  00073	83 c0 06	 add	 eax, 6
  00076	8b f4		 mov	 esi, esp
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@OOJMDEAG@?$AAC?$AAu?$AAs?$AAt?$AAo?$AAm?$AAR?$AAe?$AAc?$AAt?$AAI?$AAd?$AAs?$AA?$FL?$AA0@
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@GetMouseCu:

; 1810 :     ImFontAtlasCustomRect& r = CustomRects[CustomRectIds[0]];

  00093	b8 04 00 00 00	 mov	 eax, 4
  00098	6b c8 00	 imul	 ecx, eax, 0
  0009b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	8b 44 0a 58	 mov	 eax, DWORD PTR [edx+ecx+88]
  000a2	50		 push	 eax
  000a3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	83 c1 40	 add	 ecx, 64			; 00000040H
  000a9	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontAtlasCustomRect@@@@QAEAAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
  000ae	89 45 e8	 mov	 DWORD PTR _r$[ebp], eax

; 1811 :     IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);

  000b1	8b 45 e8	 mov	 eax, DWORD PTR _r$[ebp]
  000b4	81 38 00 00 00
	80		 cmp	 DWORD PTR [eax], -2147483648 ; 80000000H
  000ba	74 26		 je	 SHORT $LN7@GetMouseCu
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU3@1@Z@4JA
  000c2	83 c1 08	 add	 ecx, 8
  000c5	8b f4		 mov	 esi, esp
  000c7	51		 push	 ecx
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@NGCKHELE@?$AAr?$AA?4?$AAI?$AAD?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN?$AAT?$AA_?$AAA?$AAT@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	3b f4		 cmp	 esi, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@GetMouseCu:

; 1812 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);

  000e2	8b 45 e8	 mov	 eax, DWORD PTR _r$[ebp]
  000e5	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  000e9	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000ed	51		 push	 ecx
  000ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f3	8b 55 e8	 mov	 edx, DWORD PTR _r$[ebp]
  000f6	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  000fa	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000fe	51		 push	 ecx
  000ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00104	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0010a	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0010f	50		 push	 eax
  00110	6b 4d 08 18	 imul	 ecx, DWORD PTR _cursor_type$[ebp], 24
  00114	ba 08 00 00 00	 mov	 edx, 8
  00119	6b c2 00	 imul	 eax, edx, 0
  0011c	8d 8c 01 00 00
	00 00		 lea	 ecx, DWORD PTR ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A[ecx+eax]
  00123	51		 push	 ecx
  00124	8d 55 d8	 lea	 edx, DWORD PTR _pos$[ebp]
  00127	52		 push	 edx
  00128	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1813 :     ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];

  00130	6b 45 08 18	 imul	 eax, DWORD PTR _cursor_type$[ebp], 24
  00134	b9 08 00 00 00	 mov	 ecx, 8
  00139	c1 e1 00	 shl	 ecx, 0
  0013c	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A[eax+ecx]
  00143	8b 84 08 04 00
	00 00		 mov	 eax, DWORD PTR ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A[eax+ecx+4]
  0014a	89 55 c8	 mov	 DWORD PTR _size$[ebp], edx
  0014d	89 45 cc	 mov	 DWORD PTR _size$[ebp+4], eax

; 1814 :     *out_size = size;

  00150	8b 45 10	 mov	 eax, DWORD PTR _out_size$[ebp]
  00153	8b 4d c8	 mov	 ecx, DWORD PTR _size$[ebp]
  00156	89 08		 mov	 DWORD PTR [eax], ecx
  00158	8b 55 cc	 mov	 edx, DWORD PTR _size$[ebp+4]
  0015b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1815 :     *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];

  0015e	6b 45 08 18	 imul	 eax, DWORD PTR _cursor_type$[ebp], 24
  00162	b9 08 00 00 00	 mov	 ecx, 8
  00167	d1 e1		 shl	 ecx, 1
  00169	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A[eax+ecx]
  00170	8b 84 08 04 00
	00 00		 mov	 eax, DWORD PTR ?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A[eax+ecx+4]
  00177	8b 4d 0c	 mov	 ecx, DWORD PTR _out_offset$[ebp]
  0017a	89 11		 mov	 DWORD PTR [ecx], edx
  0017c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1816 :     out_uv_border[0] = (pos) * TexUvScale;

  0017f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00182	83 c0 24	 add	 eax, 36			; 00000024H
  00185	50		 push	 eax
  00186	8d 4d d8	 lea	 ecx, DWORD PTR _pos$[ebp]
  00189	51		 push	 ecx
  0018a	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00190	52		 push	 edx
  00191	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@0@Z ; operator*
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH
  00199	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0019e	b8 08 00 00 00	 mov	 eax, 8
  001a3	6b c0 00	 imul	 eax, eax, 0
  001a6	8b 75 14	 mov	 esi, DWORD PTR _out_uv_border$[ebp]
  001a9	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  001ac	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 1817 :     out_uv_border[1] = (pos + size) * TexUvScale;

  001b0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001b3	83 c0 24	 add	 eax, 36			; 00000024H
  001b6	50		 push	 eax
  001b7	8d 4d c8	 lea	 ecx, DWORD PTR _size$[ebp]
  001ba	51		 push	 ecx
  001bb	8d 55 d8	 lea	 edx, DWORD PTR _pos$[ebp]
  001be	52		 push	 edx
  001bf	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ce	50		 push	 eax
  001cf	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001d5	51		 push	 ecx
  001d6	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@0@Z ; operator*
  001db	83 c4 0c	 add	 esp, 12			; 0000000cH
  001de	8b 10		 mov	 edx, DWORD PTR [eax]
  001e0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e3	b9 08 00 00 00	 mov	 ecx, 8
  001e8	c1 e1 00	 shl	 ecx, 0
  001eb	8b 75 14	 mov	 esi, DWORD PTR _out_uv_border$[ebp]
  001ee	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  001f1	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax

; 1818 :     pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;

  001f5	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _pos$[ebp]
  001fa	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@42da0000
  00202	f3 0f 11 45 d8	 movss	 DWORD PTR _pos$[ebp], xmm0

; 1819 :     out_uv_fill[0] = (pos) * TexUvScale;

  00207	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0020a	83 c0 24	 add	 eax, 36			; 00000024H
  0020d	50		 push	 eax
  0020e	8d 4d d8	 lea	 ecx, DWORD PTR _pos$[ebp]
  00211	51		 push	 ecx
  00212	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00218	52		 push	 edx
  00219	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@0@Z ; operator*
  0021e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00221	8b 08		 mov	 ecx, DWORD PTR [eax]
  00223	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00226	b8 08 00 00 00	 mov	 eax, 8
  0022b	6b c0 00	 imul	 eax, eax, 0
  0022e	8b 75 18	 mov	 esi, DWORD PTR _out_uv_fill$[ebp]
  00231	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00234	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 1820 :     out_uv_fill[1] = (pos + size) * TexUvScale;

  00238	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0023b	83 c0 24	 add	 eax, 36			; 00000024H
  0023e	50		 push	 eax
  0023f	8d 4d c8	 lea	 ecx, DWORD PTR _size$[ebp]
  00242	51		 push	 ecx
  00243	8d 55 d8	 lea	 edx, DWORD PTR _pos$[ebp]
  00246	52		 push	 edx
  00247	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH
  00256	50		 push	 eax
  00257	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0025d	51		 push	 ecx
  0025e	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@0@Z ; operator*
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH
  00266	8b 10		 mov	 edx, DWORD PTR [eax]
  00268	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0026b	b9 08 00 00 00	 mov	 ecx, 8
  00270	c1 e1 00	 shl	 ecx, 0
  00273	8b 75 18	 mov	 esi, DWORD PTR _out_uv_fill$[ebp]
  00276	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  00279	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax

; 1821 :     return true;

  0027d	b0 01		 mov	 al, 1
$LN1@GetMouseCu:

; 1822 : }

  0027f	52		 push	 edx
  00280	8b cd		 mov	 ecx, ebp
  00282	50		 push	 eax
  00283	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@GetMouseCu
  00289	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0028e	58		 pop	 eax
  0028f	5a		 pop	 edx
  00290	5f		 pop	 edi
  00291	5e		 pop	 esi
  00292	5b		 pop	 ebx
  00293	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00296	33 cd		 xor	 ecx, ebp
  00298	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029d	81 c4 6c 01 00
	00		 add	 esp, 364		; 0000016cH
  002a3	3b ec		 cmp	 ebp, esp
  002a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002aa	8b e5		 mov	 esp, ebp
  002ac	5d		 pop	 ebp
  002ad	c2 14 00	 ret	 20			; 00000014H
$LN11@GetMouseCu:
  002b0	02 00 00 00	 DD	 2
  002b4	00 00 00 00	 DD	 $LN10@GetMouseCu
$LN10@GetMouseCu:
  002b8	d8 ff ff ff	 DD	 -40			; ffffffd8H
  002bc	08 00 00 00	 DD	 8
  002c0	00 00 00 00	 DD	 $LN8@GetMouseCu
  002c4	c8 ff ff ff	 DD	 -56			; ffffffc8H
  002c8	08 00 00 00	 DD	 8
  002cc	00 00 00 00	 DD	 $LN9@GetMouseCu
$LN9@GetMouseCu:
  002d0	73		 DB	 115			; 00000073H
  002d1	69		 DB	 105			; 00000069H
  002d2	7a		 DB	 122			; 0000007aH
  002d3	65		 DB	 101			; 00000065H
  002d4	00		 DB	 0
$LN8@GetMouseCu:
  002d5	70		 DB	 112			; 00000070H
  002d6	6f		 DB	 111			; 0000006fH
  002d7	73		 DB	 115			; 00000073H
  002d8	00		 DB	 0
?GetMouseCursorTexData@ImFontAtlas@@QAE_NHPAUImVec2@@0QAU2@1@Z ENDP ; ImFontAtlas::GetMouseCursorTexData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z
_TEXT	SEGMENT
$T1 = -232						; size = 8
$T2 = -216						; size = 8
_this$ = -8						; size = 4
_rect$ = 8						; size = 4
_out_uv_min$ = 12					; size = 4
_out_uv_max$ = 16					; size = 4
?CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z PROC ; ImFontAtlas::CalcCustomRectUV, COMDAT
; _this$ = ecx

; 1795 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00013	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1796 :     IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00034	7e 09		 jle	 SHORT $LN3@CalcCustom
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0003d	7f 26		 jg	 SHORT $LN4@CalcCustom
$LN3@CalcCustom:
  0003f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z@4JA
  00045	83 c2 01	 add	 edx, 1
  00048	8b f4		 mov	 esi, esp
  0004a	52		 push	 edx
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@CalcCustom:

; 1797 :     IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed

  00065	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  00068	e8 00 00 00 00	 call	 ?IsPacked@ImFontAtlasCustomRect@@QBE_NXZ ; ImFontAtlasCustomRect::IsPacked
  0006d	0f b6 c0	 movzx	 eax, al
  00070	85 c0		 test	 eax, eax
  00072	75 26		 jne	 SHORT $LN5@CalcCustom
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z@4JA
  0007a	83 c1 02	 add	 ecx, 2
  0007d	8b f4		 mov	 esi, esp
  0007f	51		 push	 ecx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	3b f4		 cmp	 esi, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@CalcCustom:

; 1798 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

  0009a	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  0009d	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  000a1	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000a5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	f3 0f 59 42 28	 mulss	 xmm0, DWORD PTR [edx+40]
  000ad	51		 push	 ecx
  000ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b3	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  000b6	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  000ba	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000be	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	f3 0f 59 42 24	 mulss	 xmm0, DWORD PTR [edx+36]
  000c6	51		 push	 ecx
  000c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cc	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000d2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000dc	8b 45 0c	 mov	 eax, DWORD PTR _out_uv_min$[ebp]
  000df	89 08		 mov	 DWORD PTR [eax], ecx
  000e1	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1799 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

  000e4	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  000e7	0f b7 48 0a	 movzx	 ecx, WORD PTR [eax+10]
  000eb	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  000ee	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  000f2	03 c8		 add	 ecx, eax
  000f4	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	f3 0f 59 41 28	 mulss	 xmm0, DWORD PTR [ecx+40]
  00100	51		 push	 ecx
  00101	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00106	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  00109	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  00110	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  00114	03 c2		 add	 eax, edx
  00116	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0011a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	f3 0f 59 40 24	 mulss	 xmm0, DWORD PTR [eax+36]
  00122	51		 push	 ecx
  00123	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00128	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0012e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00133	8b 08		 mov	 ecx, DWORD PTR [eax]
  00135	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00138	8b 45 10	 mov	 eax, DWORD PTR _out_uv_max$[ebp]
  0013b	89 08		 mov	 DWORD PTR [eax], ecx
  0013d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1800 : }

  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx
  00143	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00149	3b ec		 cmp	 ebp, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c2 0c 00	 ret	 12			; 0000000cH
?CalcCustomRectUV@ImFontAtlas@@QBEXPBUImFontAtlasCustomRect@@PAUImVec2@@1@Z ENDP ; ImFontAtlas::CalcCustomRectUV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z
_TEXT	SEGMENT
_r$ = -48						; size = 28
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_font$ = 8						; size = 4
_id$ = 12						; size = 2
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_advance_x$ = 24					; size = 4
_offset$ = 28						; size = 4
?AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z PROC ; ImFontAtlas::AddCustomRectFontGlyph, COMDAT
; _this$ = ecx

; 1779 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00013	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1780 :     IM_ASSERT(font != NULL);

  00037	83 7d 08 00	 cmp	 DWORD PTR _font$[ebp], 0
  0003b	75 25		 jne	 SHORT $LN3@AddCustomR
  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z@4JA
  00042	83 c0 01	 add	 eax, 1
  00045	8b f4		 mov	 esi, esp
  00047	50		 push	 eax
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@PBFICKNN@?$AAf?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@AddCustomR:

; 1781 :     IM_ASSERT(width > 0 && width <= 0xFFFF);

  00062	83 7d 10 00	 cmp	 DWORD PTR _width$[ebp], 0
  00066	7e 09		 jle	 SHORT $LN4@AddCustomR
  00068	81 7d 10 ff ff
	00 00		 cmp	 DWORD PTR _width$[ebp], 65535 ; 0000ffffH
  0006f	7e 25		 jle	 SHORT $LN5@AddCustomR
$LN4@AddCustomR:
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z@4JA
  00076	83 c0 02	 add	 eax, 2
  00079	8b f4		 mov	 esi, esp
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	3b f4		 cmp	 esi, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@AddCustomR:

; 1782 :     IM_ASSERT(height > 0 && height <= 0xFFFF);

  00096	83 7d 14 00	 cmp	 DWORD PTR _height$[ebp], 0
  0009a	7e 09		 jle	 SHORT $LN6@AddCustomR
  0009c	81 7d 14 ff ff
	00 00		 cmp	 DWORD PTR _height$[ebp], 65535 ; 0000ffffH
  000a3	7e 25		 jle	 SHORT $LN7@AddCustomR
$LN6@AddCustomR:
  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z@4JA
  000aa	83 c0 03	 add	 eax, 3
  000ad	8b f4		 mov	 esi, esp
  000af	50		 push	 eax
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	3b f4		 cmp	 esi, esp
  000c5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@AddCustomR:

; 1783 :     ImFontAtlasCustomRect r;

  000ca	8d 4d d0	 lea	 ecx, DWORD PTR _r$[ebp]
  000cd	e8 00 00 00 00	 call	 ??0ImFontAtlasCustomRect@@QAE@XZ ; ImFontAtlasCustomRect::ImFontAtlasCustomRect

; 1784 :     r.ID = id;

  000d2	0f b7 45 0c	 movzx	 eax, WORD PTR _id$[ebp]
  000d6	89 45 d0	 mov	 DWORD PTR _r$[ebp], eax

; 1785 :     r.Width = (unsigned short)width;

  000d9	66 8b 45 10	 mov	 ax, WORD PTR _width$[ebp]
  000dd	66 89 45 d4	 mov	 WORD PTR _r$[ebp+4], ax

; 1786 :     r.Height = (unsigned short)height;

  000e1	66 8b 45 14	 mov	 ax, WORD PTR _height$[ebp]
  000e5	66 89 45 d6	 mov	 WORD PTR _r$[ebp+6], ax

; 1787 :     r.GlyphAdvanceX = advance_x;

  000e9	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _advance_x$[ebp]
  000ee	f3 0f 11 45 dc	 movss	 DWORD PTR _r$[ebp+12], xmm0

; 1788 :     r.GlyphOffset = offset;

  000f3	8b 45 1c	 mov	 eax, DWORD PTR _offset$[ebp]
  000f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	89 4d e0	 mov	 DWORD PTR _r$[ebp+16], ecx
  000fe	89 55 e4	 mov	 DWORD PTR _r$[ebp+20], edx

; 1789 :     r.Font = font;

  00101	8b 45 08	 mov	 eax, DWORD PTR _font$[ebp]
  00104	89 45 e8	 mov	 DWORD PTR _r$[ebp+24], eax

; 1790 :     CustomRects.push_back(r);

  00107	8d 45 d0	 lea	 eax, DWORD PTR _r$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	83 c1 40	 add	 ecx, 64			; 00000040H
  00111	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QAEXABUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back

; 1791 :     return CustomRects.Size - 1; // Return index

  00116	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00119	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  0011c	83 e8 01	 sub	 eax, 1

; 1792 : }

  0011f	52		 push	 edx
  00120	8b cd		 mov	 ecx, ebp
  00122	50		 push	 eax
  00123	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@AddCustomR
  00129	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0012e	58		 pop	 eax
  0012f	5a		 pop	 edx
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  00143	3b ec		 cmp	 ebp, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 18 00	 ret	 24			; 00000018H
$LN10@AddCustomR:
  00150	01 00 00 00	 DD	 1
  00154	00 00 00 00	 DD	 $LN9@AddCustomR
$LN9@AddCustomR:
  00158	d0 ff ff ff	 DD	 -48			; ffffffd0H
  0015c	1c 00 00 00	 DD	 28			; 0000001cH
  00160	00 00 00 00	 DD	 $LN8@AddCustomR
$LN8@AddCustomR:
  00164	72		 DB	 114			; 00000072H
  00165	00		 DB	 0
?AddCustomRectFontGlyph@ImFontAtlas@@QAEHPAUImFont@@GHHMABUImVec2@@@Z ENDP ; ImFontAtlas::AddCustomRectFontGlyph
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z
_TEXT	SEGMENT
_r$ = -48						; size = 28
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_id$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z PROC	; ImFontAtlas::AddCustomRectRegular, COMDAT
; _this$ = ecx

; 1765 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00013	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1766 :     // Breaking change on 2019/11/21 (1.74): ImFontAtlas::AddCustomRectRegular() now requires an ID >= 0x110000 (instead of >= 0x10000)
; 1767 :     IM_ASSERT(id >= 0x110000);

  00037	81 7d 08 00 00
	11 00		 cmp	 DWORD PTR _id$[ebp], 1114112 ; 00110000H
  0003e	73 25		 jae	 SHORT $LN3@AddCustomR
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z@4JA
  00045	83 c0 02	 add	 eax, 2
  00048	8b f4		 mov	 esi, esp
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@IFEPJNFF@?$AAi?$AAd?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AAx?$AA1?$AA1?$AA0?$AA0?$AA0?$AA0@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@AddCustomR:

; 1768 :     IM_ASSERT(width > 0 && width <= 0xFFFF);

  00065	83 7d 0c 00	 cmp	 DWORD PTR _width$[ebp], 0
  00069	7e 09		 jle	 SHORT $LN4@AddCustomR
  0006b	81 7d 0c ff ff
	00 00		 cmp	 DWORD PTR _width$[ebp], 65535 ; 0000ffffH
  00072	7e 25		 jle	 SHORT $LN5@AddCustomR
$LN4@AddCustomR:
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z@4JA
  00079	83 c0 03	 add	 eax, 3
  0007c	8b f4		 mov	 esi, esp
  0007e	50		 push	 eax
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00092	3b f4		 cmp	 esi, esp
  00094	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@AddCustomR:

; 1769 :     IM_ASSERT(height > 0 && height <= 0xFFFF);

  00099	83 7d 10 00	 cmp	 DWORD PTR _height$[ebp], 0
  0009d	7e 09		 jle	 SHORT $LN6@AddCustomR
  0009f	81 7d 10 ff ff
	00 00		 cmp	 DWORD PTR _height$[ebp], 65535 ; 0000ffffH
  000a6	7e 25		 jle	 SHORT $LN7@AddCustomR
$LN6@AddCustomR:
  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z@4JA
  000ad	83 c0 04	 add	 eax, 4
  000b0	8b f4		 mov	 esi, esp
  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	3b f4		 cmp	 esi, esp
  000c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@AddCustomR:

; 1770 :     ImFontAtlasCustomRect r;

  000cd	8d 4d d0	 lea	 ecx, DWORD PTR _r$[ebp]
  000d0	e8 00 00 00 00	 call	 ??0ImFontAtlasCustomRect@@QAE@XZ ; ImFontAtlasCustomRect::ImFontAtlasCustomRect

; 1771 :     r.ID = id;

  000d5	8b 45 08	 mov	 eax, DWORD PTR _id$[ebp]
  000d8	89 45 d0	 mov	 DWORD PTR _r$[ebp], eax

; 1772 :     r.Width = (unsigned short)width;

  000db	66 8b 45 0c	 mov	 ax, WORD PTR _width$[ebp]
  000df	66 89 45 d4	 mov	 WORD PTR _r$[ebp+4], ax

; 1773 :     r.Height = (unsigned short)height;

  000e3	66 8b 45 10	 mov	 ax, WORD PTR _height$[ebp]
  000e7	66 89 45 d6	 mov	 WORD PTR _r$[ebp+6], ax

; 1774 :     CustomRects.push_back(r);

  000eb	8d 45 d0	 lea	 eax, DWORD PTR _r$[ebp]
  000ee	50		 push	 eax
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	83 c1 40	 add	 ecx, 64			; 00000040H
  000f5	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QAEXABUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back

; 1775 :     return CustomRects.Size - 1; // Return index

  000fa	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  00100	83 e8 01	 sub	 eax, 1

; 1776 : }

  00103	52		 push	 edx
  00104	8b cd		 mov	 ecx, ebp
  00106	50		 push	 eax
  00107	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@AddCustomR
  0010d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00112	58		 pop	 eax
  00113	5a		 pop	 edx
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx
  00117	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011a	33 cd		 xor	 ecx, ebp
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  00127	3b ec		 cmp	 ebp, esp
  00129	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 0c 00	 ret	 12			; 0000000cH
$LN10@AddCustomR:
  00134	01 00 00 00	 DD	 1
  00138	00 00 00 00	 DD	 $LN9@AddCustomR
$LN9@AddCustomR:
  0013c	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00140	1c 00 00 00	 DD	 28			; 0000001cH
  00144	00 00 00 00	 DD	 $LN8@AddCustomR
$LN8@AddCustomR:
  00148	72		 DB	 114			; 00000072H
  00149	00		 DB	 0
?AddCustomRectRegular@ImFontAtlas@@QAEHIHH@Z ENDP	; ImFontAtlas::AddCustomRectRegular
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesVietnamese@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesVietnamese@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesVietnamese, COMDAT
; _this$ = ecx

; 2466 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2467 :     static const ImWchar ranges[] =
; 2468 :     {
; 2469 :         0x0020, 0x00FF, // Basic Latin
; 2470 :         0x0102, 0x0103,
; 2471 :         0x0110, 0x0111,
; 2472 :         0x0128, 0x0129,
; 2473 :         0x0168, 0x0169,
; 2474 :         0x01A0, 0x01A1,
; 2475 :         0x01AF, 0x01B0,
; 2476 :         0x1EA0, 0x1EF9,
; 2477 :         0,
; 2478 :     };
; 2479 :     return &ranges[0];

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c0 00	 imul	 eax, eax, 0
  00035	05 00 00 00 00	 add	 eax, OFFSET ?ranges@?1??GetGlyphRangesVietnamese@ImFontAtlas@@QAEPBGXZ@4QBGB

; 2480 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetGlyphRangesVietnamese@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesVietnamese
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ PROC		; ImFontAtlas::GetGlyphRangesThai, COMDAT
; _this$ = ecx

; 2454 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2455 :     static const ImWchar ranges[] =
; 2456 :     {
; 2457 :         0x0020, 0x00FF, // Basic Latin
; 2458 :         0x2010, 0x205E, // Punctuations
; 2459 :         0x0E00, 0x0E7F, // Thai
; 2460 :         0,
; 2461 :     };
; 2462 :     return &ranges[0];

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c0 00	 imul	 eax, eax, 0
  00035	05 00 00 00 00	 add	 eax, OFFSET ?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ@4QBGB

; 2463 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ ENDP		; ImFontAtlas::GetGlyphRangesThai
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesCyrillic, COMDAT
; _this$ = ecx

; 2441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2442 :     static const ImWchar ranges[] =
; 2443 :     {
; 2444 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2445 :         0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
; 2446 :         0x2DE0, 0x2DFF, // Cyrillic Extended-A
; 2447 :         0xA640, 0xA69F, // Cyrillic Extended-B
; 2448 :         0,
; 2449 :     };
; 2450 :     return &ranges[0];

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c0 00	 imul	 eax, eax, 0
  00035	05 00 00 00 00	 add	 eax, OFFSET ?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ@4QBGB

; 2451 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesCyrillic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ PROC ; ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon, COMDAT
; _this$ = ecx

; 2316 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2317 :     // Store 2500 regularly used characters for Simplified Chinese.
; 2318 :     // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
; 2319 :     // This table covers 97.97% of all characters used during the month in July, 1987.
; 2320 :     // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
; 2321 :     // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
; 2322 :     static const short accumulative_offsets_from_0x4E00[] =
; 2323 :     {
; 2324 :         0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
; 2325 :         1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
; 2326 :         2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
; 2327 :         1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
; 2328 :         3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
; 2329 :         1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
; 2330 :         1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
; 2331 :         2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
; 2332 :         27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
; 2333 :         3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
; 2334 :         1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
; 2335 :         176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
; 2336 :         5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
; 2337 :         1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
; 2338 :         6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
; 2339 :         2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
; 2340 :         2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
; 2341 :         2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
; 2342 :         3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
; 2343 :         3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
; 2344 :         3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
; 2345 :         1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
; 2346 :         140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
; 2347 :         5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
; 2348 :         2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
; 2349 :         4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
; 2350 :         2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
; 2351 :         4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
; 2352 :         3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
; 2353 :         3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
; 2354 :         2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
; 2355 :         5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
; 2356 :         3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
; 2357 :         1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
; 2358 :         4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
; 2359 :         4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
; 2360 :         26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
; 2361 :         3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
; 2362 :         2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
; 2363 :         10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
; 2364 :     };
; 2365 :     static ImWchar base_ranges[] = // not zero-terminated
; 2366 :     {
; 2367 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2368 :         0x2000, 0x206F, // General Punctuation
; 2369 :         0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
; 2370 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 2371 :         0xFF00, 0xFFEF  // Half-width characters
; 2372 :     };
; 2373 :     static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
; 2374 :     if (!full_ranges[0])

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c8 00	 imul	 ecx, eax, 0
  00035	0f b7 91 00 00
	00 00		 movzx	 edx, WORD PTR ?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4PAGA[ecx]
  0003c	85 d2		 test	 edx, edx
  0003e	75 30		 jne	 SHORT $LN2@GetGlyphRa

; 2375 :     {
; 2376 :         memcpy(full_ranges, base_ranges, sizeof(base_ranges));

  00040	6a 14		 push	 20			; 00000014H
  00042	68 00 00 00 00	 push	 OFFSET ?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4PAGA
  00047	68 00 00 00 00	 push	 OFFSET ?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4PAGA
  0004c	e8 00 00 00 00	 call	 _memcpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2377 :         UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));

  00054	68 14 00 00 00	 push	 OFFSET ?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4PAGA+20
  00059	68 c4 09 00 00	 push	 2500			; 000009c4H
  0005e	68 00 00 00 00	 push	 OFFSET ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4QBFB
  00063	68 00 4e 00 00	 push	 19968			; 00004e00H
  00068	e8 00 00 00 00	 call	 ?UnpackAccumulativeOffsetsIntoRanges@@YAXHPBFHPAG@Z ; UnpackAccumulativeOffsetsIntoRanges
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@GetGlyphRa:

; 2378 :     }
; 2379 :     return &full_ranges[0];

  00070	b8 02 00 00 00	 mov	 eax, 2
  00075	6b c0 00	 imul	 eax, eax, 0
  00078	05 00 00 00 00	 add	 eax, OFFSET ?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ@4PAGA

; 2380 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QAEPBGXZ ENDP ; ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesChineseFull@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesChineseFull@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesChineseFull, COMDAT
; _this$ = ecx

; 2287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2288 :     static const ImWchar ranges[] =
; 2289 :     {
; 2290 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2291 :         0x2000, 0x206F, // General Punctuation
; 2292 :         0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
; 2293 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 2294 :         0xFF00, 0xFFEF, // Half-width characters
; 2295 :         0x4e00, 0x9FAF, // CJK Ideograms
; 2296 :         0,
; 2297 :     };
; 2298 :     return &ranges[0];

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c0 00	 imul	 eax, eax, 0
  00035	05 00 00 00 00	 add	 eax, OFFSET ?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QAEPBGXZ@4QBGB

; 2299 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetGlyphRangesChineseFull@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesChineseFull
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesJapanese, COMDAT
; _this$ = ecx

; 2383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2384 :     // 1946 common ideograms code points for Japanese
; 2385 :     // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering
; 2386 :     // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.
; 2387 :     // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
; 2388 :     // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
; 2389 :     static const short accumulative_offsets_from_0x4E00[] =
; 2390 :     {
; 2391 :         0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,
; 2392 :         5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,
; 2393 :         2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,
; 2394 :         2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,
; 2395 :         20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,
; 2396 :         4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,
; 2397 :         3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,
; 2398 :         8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,
; 2399 :         3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,
; 2400 :         15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,
; 2401 :         1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,
; 2402 :         12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,
; 2403 :         22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,
; 2404 :         5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,
; 2405 :         1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,
; 2406 :         1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,
; 2407 :         11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,
; 2408 :         15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,
; 2409 :         5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,
; 2410 :         3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,
; 2411 :         18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,
; 2412 :         27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,
; 2413 :         1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,
; 2414 :         1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,
; 2415 :         10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,
; 2416 :         179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,
; 2417 :         3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,
; 2418 :         3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,
; 2419 :         3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,
; 2420 :         4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,
; 2421 :         1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,
; 2422 :         51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39,
; 2423 :     };
; 2424 :     static ImWchar base_ranges[] = // not zero-terminated
; 2425 :     {
; 2426 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2427 :         0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
; 2428 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 2429 :         0xFF00, 0xFFEF  // Half-width characters
; 2430 :     };
; 2431 :     static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };
; 2432 :     if (!full_ranges[0])

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c8 00	 imul	 ecx, eax, 0
  00035	0f b7 91 00 00
	00 00		 movzx	 edx, WORD PTR ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA[ecx]
  0003c	85 d2		 test	 edx, edx
  0003e	75 30		 jne	 SHORT $LN2@GetGlyphRa

; 2433 :     {
; 2434 :         memcpy(full_ranges, base_ranges, sizeof(base_ranges));

  00040	6a 10		 push	 16			; 00000010H
  00042	68 00 00 00 00	 push	 OFFSET ?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA
  00047	68 00 00 00 00	 push	 OFFSET ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA
  0004c	e8 00 00 00 00	 call	 _memcpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2435 :         UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));

  00054	68 10 00 00 00	 push	 OFFSET ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA+16
  00059	68 9a 07 00 00	 push	 1946			; 0000079aH
  0005e	68 00 00 00 00	 push	 OFFSET ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4QBFB
  00063	68 00 4e 00 00	 push	 19968			; 00004e00H
  00068	e8 00 00 00 00	 call	 ?UnpackAccumulativeOffsetsIntoRanges@@YAXHPBFHPAG@Z ; UnpackAccumulativeOffsetsIntoRanges
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@GetGlyphRa:

; 2436 :     }
; 2437 :     return &full_ranges[0];

  00070	b8 02 00 00 00	 mov	 eax, 2
  00075	6b c0 00	 imul	 eax, eax, 0
  00078	05 00 00 00 00	 add	 eax, OFFSET ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA

; 2438 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesJapanese
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesKorean, COMDAT
; _this$ = ecx

; 2275 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2276 :     static const ImWchar ranges[] =
; 2277 :     {
; 2278 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2279 :         0x3131, 0x3163, // Korean alphabets
; 2280 :         0xAC00, 0xD79D, // Korean characters
; 2281 :         0,
; 2282 :     };
; 2283 :     return &ranges[0];

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c0 00	 imul	 eax, eax, 0
  00035	05 00 00 00 00	 add	 eax, OFFSET ?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ@4QBGB

; 2284 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesKorean
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesDefault, COMDAT
; _this$ = ecx

; 2265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2266 :     static const ImWchar ranges[] =
; 2267 :     {
; 2268 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2269 :         0,
; 2270 :     };
; 2271 :     return &ranges[0];

  0002d	b8 02 00 00 00	 mov	 eax, 2
  00032	6b c0 00	 imul	 eax, eax, 0
  00035	05 00 00 00 00	 add	 eax, OFFSET ?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ@4QBGB

; 2272 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesDefault
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z
_TEXT	SEGMENT
_n$1 = -60						; size = 4
_dst$2 = -48						; size = 4
_src$3 = -36						; size = 4
_pixels$4 = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_out_pixels$ = 8					; size = 4
_out_width$ = 12					; size = 4
_out_height$ = 16					; size = 4
_out_bytes_per_pixel$ = 20				; size = 4
?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z PROC	; ImFontAtlas::GetTexDataAsRGBA32, COMDAT
; _this$ = ecx

; 1615 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00013	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1616 :     // Convert to RGBA32 format on demand
; 1617 :     // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
; 1618 :     if (!TexPixelsRGBA32)

  00037	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0003e	0f 85 a6 00 00
	00		 jne	 $LN5@GetTexData

; 1619 :     {
; 1620 :         unsigned char* pixels = NULL;

  00044	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pixels$4[ebp], 0

; 1621 :         GetTexDataAsAlpha8(&pixels, NULL, NULL);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	8d 45 e8	 lea	 eax, DWORD PTR _pixels$4[ebp]
  00054	50		 push	 eax
  00055	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8

; 1622 :         if (pixels)

  0005d	83 7d e8 00	 cmp	 DWORD PTR _pixels$4[ebp], 0
  00061	0f 84 83 00 00
	00		 je	 $LN5@GetTexData

; 1623 :         {
; 1624 :             TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);

  00067	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00070	0f af 51 20	 imul	 edx, DWORD PTR [ecx+32]
  00074	c1 e2 02	 shl	 edx, 2
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  0007d	83 c4 04	 add	 esp, 4
  00080	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1625 :             const unsigned char* src = pixels;

  00086	8b 45 e8	 mov	 eax, DWORD PTR _pixels$4[ebp]
  00089	89 45 dc	 mov	 DWORD PTR _src$3[ebp], eax

; 1626 :             unsigned int* dst = TexPixelsRGBA32;

  0008c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00092	89 4d d0	 mov	 DWORD PTR _dst$2[ebp], ecx

; 1627 :             for (int n = TexWidth * TexHeight; n > 0; n--)

  00095	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0009e	0f af 51 20	 imul	 edx, DWORD PTR [ecx+32]
  000a2	89 55 c4	 mov	 DWORD PTR _n$1[ebp], edx
  000a5	eb 09		 jmp	 SHORT $LN4@GetTexData
$LN2@GetTexData:
  000a7	8b 45 c4	 mov	 eax, DWORD PTR _n$1[ebp]
  000aa	83 e8 01	 sub	 eax, 1
  000ad	89 45 c4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@GetTexData:
  000b0	83 7d c4 00	 cmp	 DWORD PTR _n$1[ebp], 0
  000b4	7e 34		 jle	 SHORT $LN5@GetTexData

; 1628 :                 *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));

  000b6	8b 45 dc	 mov	 eax, DWORD PTR _src$3[ebp]
  000b9	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000bc	c1 e1 18	 shl	 ecx, 24			; 00000018H
  000bf	81 c9 00 00 ff
	00		 or	 ecx, 16711680		; 00ff0000H
  000c5	81 c9 00 ff 00
	00		 or	 ecx, 65280		; 0000ff00H
  000cb	81 c9 ff 00 00
	00		 or	 ecx, 255		; 000000ffH
  000d1	8b 55 d0	 mov	 edx, DWORD PTR _dst$2[ebp]
  000d4	89 0a		 mov	 DWORD PTR [edx], ecx
  000d6	8b 45 d0	 mov	 eax, DWORD PTR _dst$2[ebp]
  000d9	83 c0 04	 add	 eax, 4
  000dc	89 45 d0	 mov	 DWORD PTR _dst$2[ebp], eax
  000df	8b 4d dc	 mov	 ecx, DWORD PTR _src$3[ebp]
  000e2	83 c1 01	 add	 ecx, 1
  000e5	89 4d dc	 mov	 DWORD PTR _src$3[ebp], ecx
  000e8	eb bd		 jmp	 SHORT $LN2@GetTexData
$LN5@GetTexData:

; 1629 :         }
; 1630 :     }
; 1631 : 
; 1632 :     *out_pixels = (unsigned char*)TexPixelsRGBA32;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _out_pixels$[ebp]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000f3	89 10		 mov	 DWORD PTR [eax], edx

; 1633 :     if (out_width) *out_width = TexWidth;

  000f5	83 7d 0c 00	 cmp	 DWORD PTR _out_width$[ebp], 0
  000f9	74 0b		 je	 SHORT $LN7@GetTexData
  000fb	8b 45 0c	 mov	 eax, DWORD PTR _out_width$[ebp]
  000fe	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00104	89 10		 mov	 DWORD PTR [eax], edx
$LN7@GetTexData:

; 1634 :     if (out_height) *out_height = TexHeight;

  00106	83 7d 10 00	 cmp	 DWORD PTR _out_height$[ebp], 0
  0010a	74 0b		 je	 SHORT $LN8@GetTexData
  0010c	8b 45 10	 mov	 eax, DWORD PTR _out_height$[ebp]
  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00115	89 10		 mov	 DWORD PTR [eax], edx
$LN8@GetTexData:

; 1635 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;

  00117	83 7d 14 00	 cmp	 DWORD PTR _out_bytes_per_pixel$[ebp], 0
  0011b	74 09		 je	 SHORT $LN1@GetTexData
  0011d	8b 45 14	 mov	 eax, DWORD PTR _out_bytes_per_pixel$[ebp]
  00120	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], 4
$LN1@GetTexData:

; 1636 : }

  00126	52		 push	 edx
  00127	8b cd		 mov	 ecx, ebp
  00129	50		 push	 eax
  0012a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@GetTexData
  00130	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00135	58		 pop	 eax
  00136	5a		 pop	 edx
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013d	33 cd		 xor	 ecx, ebp
  0013f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00144	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  0014a	3b ec		 cmp	 ebp, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 10 00	 ret	 16			; 00000010H
  00157	90		 npad	 1
$LN13@GetTexData:
  00158	01 00 00 00	 DD	 1
  0015c	00 00 00 00	 DD	 $LN12@GetTexData
$LN12@GetTexData:
  00160	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00164	04 00 00 00	 DD	 4
  00168	00 00 00 00	 DD	 $LN11@GetTexData
$LN11@GetTexData:
  0016c	70		 DB	 112			; 00000070H
  0016d	69		 DB	 105			; 00000069H
  0016e	78		 DB	 120			; 00000078H
  0016f	65		 DB	 101			; 00000065H
  00170	6c		 DB	 108			; 0000006cH
  00171	73		 DB	 115			; 00000073H
  00172	00		 DB	 0
?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ENDP	; ImFontAtlas::GetTexDataAsRGBA32
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_out_pixels$ = 8					; size = 4
_out_width$ = 12					; size = 4
_out_height$ = 16					; size = 4
_out_bytes_per_pixel$ = 20				; size = 4
?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z PROC	; ImFontAtlas::GetTexDataAsAlpha8, COMDAT
; _this$ = ecx

; 1599 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1600 :     // Build atlas on demand
; 1601 :     if (TexPixelsAlpha8 == NULL)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00034	75 24		 jne	 SHORT $LN2@GetTexData

; 1602 :     {
; 1603 :         if (ConfigData.empty())

  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0003c	e8 00 00 00 00	 call	 ?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ ; ImVector<ImFontConfig>::empty
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	74 0a		 je	 SHORT $LN3@GetTexData

; 1604 :             AddFontDefault();

  00048	6a 00		 push	 0
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
$LN3@GetTexData:

; 1605 :         Build();

  00052	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?Build@ImFontAtlas@@QAE_NXZ ; ImFontAtlas::Build
$LN2@GetTexData:

; 1606 :     }
; 1607 : 
; 1608 :     *out_pixels = TexPixelsAlpha8;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _out_pixels$[ebp]
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00063	89 10		 mov	 DWORD PTR [eax], edx

; 1609 :     if (out_width) *out_width = TexWidth;

  00065	83 7d 0c 00	 cmp	 DWORD PTR _out_width$[ebp], 0
  00069	74 0b		 je	 SHORT $LN4@GetTexData
  0006b	8b 45 0c	 mov	 eax, DWORD PTR _out_width$[ebp]
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00074	89 10		 mov	 DWORD PTR [eax], edx
$LN4@GetTexData:

; 1610 :     if (out_height) *out_height = TexHeight;

  00076	83 7d 10 00	 cmp	 DWORD PTR _out_height$[ebp], 0
  0007a	74 0b		 je	 SHORT $LN5@GetTexData
  0007c	8b 45 10	 mov	 eax, DWORD PTR _out_height$[ebp]
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00085	89 10		 mov	 DWORD PTR [eax], edx
$LN5@GetTexData:

; 1611 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;

  00087	83 7d 14 00	 cmp	 DWORD PTR _out_bytes_per_pixel$[ebp], 0
  0008b	74 09		 je	 SHORT $LN1@GetTexData
  0008d	8b 45 14	 mov	 eax, DWORD PTR _out_bytes_per_pixel$[ebp]
  00090	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN1@GetTexData:

; 1612 : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0009f	3b ec		 cmp	 ebp, esp
  000a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 10 00	 ret	 16			; 00000010H
?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z ENDP	; ImFontAtlas::GetTexDataAsAlpha8
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?Build@ImFontAtlas@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Build@ImFontAtlas@@QAE_NXZ PROC			; ImFontAtlas::Build, COMDAT
; _this$ = ecx

; 1825 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1826 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00033	85 c9		 test	 ecx, ecx
  00035	75 09		 jne	 SHORT $LN3@Build
  00037	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  0003c	85 d2		 test	 edx, edx
  0003e	75 25		 jne	 SHORT $LN4@Build
$LN3@Build:
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??Build@ImFontAtlas@@QAE_NXZ@4JA
  00045	83 c0 01	 add	 eax, 1
  00048	8b f4		 mov	 esi, esp
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@Build:

; 1827 :     return ImFontAtlasBuildWithStbTruetype(this);

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?ImFontAtlasBuildWithStbTruetype@@YA_NPAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
  0006e	83 c4 04	 add	 esp, 4

; 1828 : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?Build@ImFontAtlas@@QAE_NXZ ENDP			; ImFontAtlas::Build
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?Clear@ImFontAtlas@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@ImFontAtlas@@QAEXXZ PROC				; ImFontAtlas::Clear, COMDAT
; _this$ = ecx

; 1592 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1593 :     ClearInputData();

  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?ClearInputData@ImFontAtlas@@QAEXXZ ; ImFontAtlas::ClearInputData

; 1594 :     ClearTexData();

  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?ClearTexData@ImFontAtlas@@QAEXXZ ; ImFontAtlas::ClearTexData

; 1595 :     ClearFonts();

  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?ClearFonts@ImFontAtlas@@QAEXXZ ; ImFontAtlas::ClearFonts

; 1596 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?Clear@ImFontAtlas@@QAEXXZ ENDP				; ImFontAtlas::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ClearFonts@ImFontAtlas@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?ClearFonts@ImFontAtlas@@QAEXXZ PROC			; ImFontAtlas::ClearFonts, COMDAT
; _this$ = ecx

; 1584 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1585 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00033	85 c9		 test	 ecx, ecx
  00035	75 09		 jne	 SHORT $LN6@ClearFonts
  00037	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  0003c	85 d2		 test	 edx, edx
  0003e	75 25		 jne	 SHORT $LN7@ClearFonts
$LN6@ClearFonts:
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ClearFonts@ImFontAtlas@@QAEXXZ@4JA
  00045	83 c0 01	 add	 eax, 1
  00048	8b f4		 mov	 esi, esp
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@ClearFonts:

; 1586 :     for (int i = 0; i < Fonts.Size; i++)

  00065	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0006c	eb 09		 jmp	 SHORT $LN4@ClearFonts
$LN2@ClearFonts:
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ClearFonts:
  00077	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  0007d	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  00080	7d 1c		 jge	 SHORT $LN3@ClearFonts

; 1587 :         IM_DELETE(Fonts[i]);

  00082	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00085	50		 push	 eax
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	83 c1 34	 add	 ecx, 52			; 00000034H
  0008c	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 ??$IM_DELETE@UImFont@@@@YAXPAUImFont@@@Z ; IM_DELETE<ImFont>
  00099	83 c4 04	 add	 esp, 4
  0009c	eb d0		 jmp	 SHORT $LN2@ClearFonts
$LN3@ClearFonts:

; 1588 :     Fonts.clear();

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	83 c1 34	 add	 ecx, 52			; 00000034H
  000a4	e8 00 00 00 00	 call	 ?clear@?$ImVector@PAUImFont@@@@QAEXXZ ; ImVector<ImFont *>::clear

; 1589 : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?ClearFonts@ImFontAtlas@@QAEXXZ ENDP			; ImFontAtlas::ClearFonts
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ClearTexData@ImFontAtlas@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ClearTexData@ImFontAtlas@@QAEXXZ PROC			; ImFontAtlas::ClearTexData, COMDAT
; _this$ = ecx

; 1573 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1574 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00033	85 c9		 test	 ecx, ecx
  00035	75 09		 jne	 SHORT $LN5@ClearTexDa
  00037	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  0003c	85 d2		 test	 edx, edx
  0003e	75 25		 jne	 SHORT $LN6@ClearTexDa
$LN5@ClearTexDa:
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ClearTexData@ImFontAtlas@@QAEXXZ@4JA
  00045	83 c0 01	 add	 eax, 1
  00048	8b f4		 mov	 esi, esp
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@ClearTexDa:

; 1575 :     if (TexPixelsAlpha8)

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0006c	74 0f		 je	 SHORT $LN2@ClearTexDa

; 1576 :         IM_FREE(TexPixelsAlpha8);

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007a	83 c4 04	 add	 esp, 4
$LN2@ClearTexDa:

; 1577 :     if (TexPixelsRGBA32)

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00080	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00084	74 0f		 je	 SHORT $LN3@ClearTexDa

; 1578 :         IM_FREE(TexPixelsRGBA32);

  00086	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00092	83 c4 04	 add	 esp, 4
$LN3@ClearTexDa:

; 1579 :     TexPixelsAlpha8 = NULL;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00098	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 1580 :     TexPixelsRGBA32 = NULL;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1581 : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?ClearTexData@ImFontAtlas@@QAEXXZ ENDP			; ImFontAtlas::ClearTexData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ClearInputData@ImFontAtlas@@QAEXXZ
_TEXT	SEGMENT
_n$1 = -44						; size = 4
_i$2 = -32						; size = 4
_i$3 = -20						; size = 4
_this$ = -8						; size = 4
?ClearInputData@ImFontAtlas@@QAEXXZ PROC		; ImFontAtlas::ClearInputData, COMDAT
; _this$ = ecx

; 1550 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1551 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00033	85 c9		 test	 ecx, ecx
  00035	75 09		 jne	 SHORT $LN14@ClearInput
  00037	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  0003c	85 d2		 test	 edx, edx
  0003e	75 25		 jne	 SHORT $LN15@ClearInput
$LN14@ClearInput:
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ClearInputData@ImFontAtlas@@QAEXXZ@4JA
  00045	83 c0 01	 add	 eax, 1
  00048	8b f4		 mov	 esi, esp
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN15@ClearInput:

; 1552 :     for (int i = 0; i < ConfigData.Size; i++)

  00065	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  0006c	eb 09		 jmp	 SHORT $LN4@ClearInput
$LN2@ClearInput:
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 ec	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@ClearInput:
  00077	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _i$3[ebp]
  0007d	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00080	7d 5c		 jge	 SHORT $LN3@ClearInput

; 1553 :         if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)

  00082	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00085	50		 push	 eax
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0008c	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  00091	83 38 00	 cmp	 DWORD PTR [eax], 0
  00094	74 46		 je	 SHORT $LN11@ClearInput
  00096	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00099	50		 push	 eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000a0	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  000a5	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 2f		 je	 SHORT $LN11@ClearInput

; 1554 :         {
; 1555 :             IM_FREE(ConfigData[i].FontData);

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000b7	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  000c4	83 c4 04	 add	 esp, 4

; 1556 :             ConfigData[i].FontData = NULL;

  000c7	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000d1	e8 00 00 00 00	 call	 ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
  000d6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN11@ClearInput:

; 1557 :         }

  000dc	eb 90		 jmp	 SHORT $LN2@ClearInput
$LN3@ClearInput:

; 1558 : 
; 1559 :     // When clearing this we lose access to the font name and other information used to build the font.
; 1560 :     for (int i = 0; i < Fonts.Size; i++)

  000de	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  000e5	eb 09		 jmp	 SHORT $LN7@ClearInput
$LN5@ClearInput:
  000e7	8b 45 e0	 mov	 eax, DWORD PTR _i$2[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 45 e0	 mov	 DWORD PTR _i$2[ebp], eax
$LN7@ClearInput:
  000f0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	8b 4d e0	 mov	 ecx, DWORD PTR _i$2[ebp]
  000f6	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  000f9	7d 73		 jge	 SHORT $LN6@ClearInput

; 1561 :         if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)

  000fb	8b 45 e0	 mov	 eax, DWORD PTR _i$2[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	83 c1 34	 add	 ecx, 52			; 00000034H
  00105	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  0010a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010f	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00112	3b 42 54	 cmp	 eax, DWORD PTR [edx+84]
  00115	72 52		 jb	 SHORT $LN12@ClearInput
  00117	8b 45 e0	 mov	 eax, DWORD PTR _i$2[ebp]
  0011a	50		 push	 eax
  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	83 c1 34	 add	 ecx, 52			; 00000034H
  00121	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  00126	8b 08		 mov	 ecx, DWORD PTR [eax]
  00128	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0012b	6b 42 4c 78	 imul	 eax, DWORD PTR [edx+76], 120
  0012f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00132	03 42 54	 add	 eax, DWORD PTR [edx+84]
  00135	39 41 3c	 cmp	 DWORD PTR [ecx+60], eax
  00138	73 2f		 jae	 SHORT $LN12@ClearInput

; 1562 :         {
; 1563 :             Fonts[i]->ConfigData = NULL;

  0013a	8b 45 e0	 mov	 eax, DWORD PTR _i$2[ebp]
  0013d	50		 push	 eax
  0013e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	83 c1 34	 add	 ecx, 52			; 00000034H
  00144	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 1564 :             Fonts[i]->ConfigDataCount = 0;

  00152	8b 45 e0	 mov	 eax, DWORD PTR _i$2[ebp]
  00155	50		 push	 eax
  00156	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00159	83 c1 34	 add	 ecx, 52			; 00000034H
  0015c	e8 00 00 00 00	 call	 ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ; ImVector<ImFont *>::operator[]
  00161	8b 08		 mov	 ecx, DWORD PTR [eax]
  00163	33 d2		 xor	 edx, edx
  00165	66 89 51 40	 mov	 WORD PTR [ecx+64], dx
$LN12@ClearInput:

; 1565 :         }

  00169	e9 79 ff ff ff	 jmp	 $LN5@ClearInput
$LN6@ClearInput:

; 1566 :     ConfigData.clear();

  0016e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00174	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImFontConfig@@@@QAEXXZ ; ImVector<ImFontConfig>::clear

; 1567 :     CustomRects.clear();

  00179	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	83 c1 40	 add	 ecx, 64			; 00000040H
  0017f	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImFontAtlasCustomRect@@@@QAEXXZ ; ImVector<ImFontAtlasCustomRect>::clear

; 1568 :     for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)

  00184	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0018b	eb 09		 jmp	 SHORT $LN10@ClearInput
$LN8@ClearInput:
  0018d	8b 45 d4	 mov	 eax, DWORD PTR _n$1[ebp]
  00190	83 c0 01	 add	 eax, 1
  00193	89 45 d4	 mov	 DWORD PTR _n$1[ebp], eax
$LN10@ClearInput:
  00196	83 7d d4 01	 cmp	 DWORD PTR _n$1[ebp], 1
  0019a	7d 10		 jge	 SHORT $LN1@ClearInput

; 1569 :         CustomRectIds[n] = -1;

  0019c	8b 45 d4	 mov	 eax, DWORD PTR _n$1[ebp]
  0019f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	c7 44 81 58 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax*4+88], -1
  001aa	eb e1		 jmp	 SHORT $LN8@ClearInput
$LN1@ClearInput:

; 1570 : }

  001ac	5f		 pop	 edi
  001ad	5e		 pop	 esi
  001ae	5b		 pop	 ebx
  001af	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  001b5	3b ec		 cmp	 ebp, esp
  001b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c3		 ret	 0
?ClearInputData@ImFontAtlas@@QAEXXZ ENDP		; ImFontAtlas::ClearInputData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z
_TEXT	SEGMENT
_font$ = -44						; size = 4
_compressed_ttf$ = -32					; size = 4
_compressed_ttf_size$ = -20				; size = 4
_this$ = -8						; size = 4
_compressed_ttf_data_base85$ = 8			; size = 4
_size_pixels$ = 12					; size = 4
_font_cfg$ = 16						; size = 4
_glyph_ranges$ = 20					; size = 4
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF, COMDAT
; _this$ = ecx

; 1755 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :     int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _compressed_ttf_data_base85$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _strlen
  00036	83 c4 04	 add	 esp, 4
  00039	83 c0 04	 add	 eax, 4
  0003c	99		 cdq
  0003d	b9 05 00 00 00	 mov	 ecx, 5
  00042	f7 f9		 idiv	 ecx
  00044	c1 e0 02	 shl	 eax, 2
  00047	89 45 ec	 mov	 DWORD PTR _compressed_ttf_size$[ebp], eax

; 1757 :     void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _compressed_ttf_size$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00053	83 c4 04	 add	 esp, 4
  00056	89 45 e0	 mov	 DWORD PTR _compressed_ttf$[ebp], eax

; 1758 :     Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);

  00059	8b 45 e0	 mov	 eax, DWORD PTR _compressed_ttf$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _compressed_ttf_data_base85$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?Decode85@@YAXPBEPAE@Z	; Decode85
  00066	83 c4 08	 add	 esp, 8

; 1759 :     ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);

  00069	8b 45 14	 mov	 eax, DWORD PTR _glyph_ranges$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _font_cfg$[ebp]
  00070	51		 push	 ecx
  00071	51		 push	 ecx
  00072	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _size_pixels$[ebp]
  00077	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007c	8b 55 ec	 mov	 edx, DWORD PTR _compressed_ttf_size$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 e0	 mov	 eax, DWORD PTR _compressed_ttf$[ebp]
  00083	50		 push	 eax
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
  0008c	89 45 d4	 mov	 DWORD PTR _font$[ebp], eax

; 1760 :     IM_FREE(compressed_ttf);

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _compressed_ttf$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00098	83 c4 04	 add	 esp, 4

; 1761 :     return font;

  0009b	8b 45 d4	 mov	 eax, DWORD PTR _font$[ebp]

; 1762 : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 10 00	 ret	 16			; 00000010H
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z
_TEXT	SEGMENT
tv75 = -632						; size = 4
$T1 = -624						; size = 120
$T2 = -496						; size = 120
$T3 = -368						; size = 4
_font_cfg$ = -164					; size = 120
_buf_decompressed_data$ = -36				; size = 4
_buf_decompressed_size$ = -24				; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_compressed_ttf_data$ = 8				; size = 4
_compressed_ttf_size$ = 12				; size = 4
_size_pixels$ = 16					; size = 4
_font_cfg_template$ = 20				; size = 4
_glyph_ranges$ = 24					; size = 4
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedTTF, COMDAT
; _this$ = ecx

; 1743 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 78 02 00
	00		 sub	 esp, 632		; 00000278H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 88 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-632]
  00013	b9 9e 00 00 00	 mov	 ecx, 158		; 0000009eH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1744 :     const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);

  00037	8b 45 08	 mov	 eax, DWORD PTR _compressed_ttf_data$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?stb_decompress_length@@YAIPBE@Z ; stb_decompress_length
  00040	83 c4 04	 add	 esp, 4
  00043	89 45 e8	 mov	 DWORD PTR _buf_decompressed_size$[ebp], eax

; 1745 :     unsigned char* buf_decompressed_data = (unsigned char *)IM_ALLOC(buf_decompressed_size);

  00046	8b 45 e8	 mov	 eax, DWORD PTR _buf_decompressed_size$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 dc	 mov	 DWORD PTR _buf_decompressed_data$[ebp], eax

; 1746 :     stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

  00055	8b 45 0c	 mov	 eax, DWORD PTR _compressed_ttf_size$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _compressed_ttf_data$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR _buf_decompressed_data$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?stb_decompress@@YAIPAEPBEI@Z ; stb_decompress
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1747 : 
; 1748 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00069	83 7d 14 00	 cmp	 DWORD PTR _font_cfg_template$[ebp], 0
  0006d	74 1e		 je	 SHORT $LN3@AddFontFro
  0006f	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00074	8b 75 14	 mov	 esi, DWORD PTR _font_cfg_template$[ebp]
  00077	8d bd 10 fe ff
	ff		 lea	 edi, DWORD PTR $T2[ebp]
  0007d	f3 a5		 rep movsd
  0007f	8d 85 10 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00085	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  0008b	eb 11		 jmp	 SHORT $LN4@AddFontFro
$LN3@AddFontFro:
  0008d	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00093	e8 00 00 00 00	 call	 ??0ImFontConfig@@QAE@XZ	; ImFontConfig::ImFontConfig
  00098	89 85 88 fd ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
$LN4@AddFontFro:
  0009e	8b 8d 88 fd ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  000a4	89 8d 90 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  000aa	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000af	8b b5 90 fe ff
	ff		 mov	 esi, DWORD PTR $T3[ebp]
  000b5	8d bd 5c ff ff
	ff		 lea	 edi, DWORD PTR _font_cfg$[ebp]
  000bb	f3 a5		 rep movsd

; 1749 :     IM_ASSERT(font_cfg.FontData == NULL);

  000bd	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _font_cfg$[ebp], 0
  000c4	74 25		 je	 SHORT $LN5@AddFontFro
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z@4JA
  000cb	83 c0 06	 add	 eax, 6
  000ce	8b f4		 mov	 esi, esp
  000d0	50		 push	 eax
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	3b f4		 cmp	 esi, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@AddFontFro:

; 1750 :     font_cfg.FontDataOwnedByAtlas = true;

  000eb	c6 85 64 ff ff
	ff 01		 mov	 BYTE PTR _font_cfg$[ebp+8], 1

; 1751 :     return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);

  000f2	8b 45 18	 mov	 eax, DWORD PTR _glyph_ranges$[ebp]
  000f5	50		 push	 eax
  000f6	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _font_cfg$[ebp]
  000fc	51		 push	 ecx
  000fd	51		 push	 ecx
  000fe	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _size_pixels$[ebp]
  00103	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00108	8b 55 e8	 mov	 edx, DWORD PTR _buf_decompressed_size$[ebp]
  0010b	52		 push	 edx
  0010c	8b 45 dc	 mov	 eax, DWORD PTR _buf_decompressed_data$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	e8 00 00 00 00	 call	 ?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryTTF

; 1752 : }

  00118	52		 push	 edx
  00119	8b cd		 mov	 ecx, ebp
  0011b	50		 push	 eax
  0011c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@AddFontFro
  00122	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00127	58		 pop	 eax
  00128	5a		 pop	 edx
  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
  0012b	5b		 pop	 ebx
  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	33 cd		 xor	 ecx, ebp
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	81 c4 78 02 00
	00		 add	 esp, 632		; 00000278H
  0013c	3b ec		 cmp	 ebp, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c2 14 00	 ret	 20			; 00000014H
  00149	0f 1f 00	 npad	 3
$LN8@AddFontFro:
  0014c	01 00 00 00	 DD	 1
  00150	00 00 00 00	 DD	 $LN7@AddFontFro
$LN7@AddFontFro:
  00154	5c ff ff ff	 DD	 -164			; ffffff5cH
  00158	78 00 00 00	 DD	 120			; 00000078H
  0015c	00 00 00 00	 DD	 $LN6@AddFontFro
$LN6@AddFontFro:
  00160	66		 DB	 102			; 00000066H
  00161	6f		 DB	 111			; 0000006fH
  00162	6e		 DB	 110			; 0000006eH
  00163	74		 DB	 116			; 00000074H
  00164	5f		 DB	 95			; 0000005fH
  00165	63		 DB	 99			; 00000063H
  00166	66		 DB	 102			; 00000066H
  00167	67		 DB	 103			; 00000067H
  00168	00		 DB	 0
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedTTF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z
_TEXT	SEGMENT
tv77 = -608						; size = 4
$T1 = -600						; size = 120
$T2 = -472						; size = 120
$T3 = -344						; size = 4
_font_cfg$ = -140					; size = 120
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_ttf_data$ = 8						; size = 4
_ttf_size$ = 12						; size = 4
_size_pixels$ = 16					; size = 4
_font_cfg_template$ = 20				; size = 4
_glyph_ranges$ = 24					; size = 4
?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromMemoryTTF, COMDAT
; _this$ = ecx

; 1730 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 02 00
	00		 sub	 esp, 608		; 00000260H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd a0 fd ff
	ff		 lea	 edi, DWORD PTR [ebp-608]
  00013	b9 98 00 00 00	 mov	 ecx, 152		; 00000098H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1731 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00037	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 09		 jne	 SHORT $LN4@AddFontFro
  00041	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  00046	85 d2		 test	 edx, edx
  00048	75 25		 jne	 SHORT $LN5@AddFontFro
$LN4@AddFontFro:
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z@4JA
  0004f	83 c0 01	 add	 eax, 1
  00052	8b f4		 mov	 esi, esp
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@AddFontFro:

; 1732 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  0006f	83 7d 14 00	 cmp	 DWORD PTR _font_cfg_template$[ebp], 0
  00073	74 1e		 je	 SHORT $LN6@AddFontFro
  00075	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  0007a	8b 75 14	 mov	 esi, DWORD PTR _font_cfg_template$[ebp]
  0007d	8d bd 28 fe ff
	ff		 lea	 edi, DWORD PTR $T2[ebp]
  00083	f3 a5		 rep movsd
  00085	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0008b	89 85 a0 fd ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  00091	eb 11		 jmp	 SHORT $LN7@AddFontFro
$LN6@AddFontFro:
  00093	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00099	e8 00 00 00 00	 call	 ??0ImFontConfig@@QAE@XZ	; ImFontConfig::ImFontConfig
  0009e	89 85 a0 fd ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
$LN7@AddFontFro:
  000a4	8b 8d a0 fd ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  000aa	89 8d a8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  000b0	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000b5	8b b5 a8 fe ff
	ff		 mov	 esi, DWORD PTR $T3[ebp]
  000bb	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR _font_cfg$[ebp]
  000c1	f3 a5		 rep movsd

; 1733 :     IM_ASSERT(font_cfg.FontData == NULL);

  000c3	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _font_cfg$[ebp], 0
  000ca	74 25		 je	 SHORT $LN8@AddFontFro
  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z@4JA
  000d1	83 c0 03	 add	 eax, 3
  000d4	8b f4		 mov	 esi, esp
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@AddFontFro:

; 1734 :     font_cfg.FontData = ttf_data;

  000f1	8b 45 08	 mov	 eax, DWORD PTR _ttf_data$[ebp]
  000f4	89 85 74 ff ff
	ff		 mov	 DWORD PTR _font_cfg$[ebp], eax

; 1735 :     font_cfg.FontDataSize = ttf_size;

  000fa	8b 45 0c	 mov	 eax, DWORD PTR _ttf_size$[ebp]
  000fd	89 85 78 ff ff
	ff		 mov	 DWORD PTR _font_cfg$[ebp+4], eax

; 1736 :     font_cfg.SizePixels = size_pixels;

  00103	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _size_pixels$[ebp]
  00108	f3 0f 11 45 84	 movss	 DWORD PTR _font_cfg$[ebp+16], xmm0

; 1737 :     if (glyph_ranges)

  0010d	83 7d 18 00	 cmp	 DWORD PTR _glyph_ranges$[ebp], 0
  00111	74 06		 je	 SHORT $LN2@AddFontFro

; 1738 :         font_cfg.GlyphRanges = glyph_ranges;

  00113	8b 45 18	 mov	 eax, DWORD PTR _glyph_ranges$[ebp]
  00116	89 45 a4	 mov	 DWORD PTR _font_cfg$[ebp+48], eax
$LN2@AddFontFro:

; 1739 :     return AddFont(&font_cfg);

  00119	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _font_cfg$[ebp]
  0011f	50		 push	 eax
  00120	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	e8 00 00 00 00	 call	 ?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFont

; 1740 : }

  00128	52		 push	 edx
  00129	8b cd		 mov	 ecx, ebp
  0012b	50		 push	 eax
  0012c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@AddFontFro
  00132	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00137	58		 pop	 eax
  00138	5a		 pop	 edx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013f	33 cd		 xor	 ecx, ebp
  00141	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00146	81 c4 60 02 00
	00		 add	 esp, 608		; 00000260H
  0014c	3b ec		 cmp	 ebp, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 14 00	 ret	 20			; 00000014H
  00159	0f 1f 00	 npad	 3
$LN11@AddFontFro:
  0015c	01 00 00 00	 DD	 1
  00160	00 00 00 00	 DD	 $LN10@AddFontFro
$LN10@AddFontFro:
  00164	74 ff ff ff	 DD	 -140			; ffffff74H
  00168	78 00 00 00	 DD	 120			; 00000078H
  0016c	00 00 00 00	 DD	 $LN9@AddFontFro
$LN9@AddFontFro:
  00170	66		 DB	 102			; 00000066H
  00171	6f		 DB	 111			; 0000006fH
  00172	6e		 DB	 110			; 0000006eH
  00173	74		 DB	 116			; 00000074H
  00174	5f		 DB	 95			; 0000005fH
  00175	63		 DB	 99			; 00000063H
  00176	66		 DB	 102			; 00000066H
  00177	67		 DB	 103			; 00000067H
  00178	00		 DB	 0
?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryTTF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z
_TEXT	SEGMENT
tv89 = -644						; size = 4
$T1 = -636						; size = 120
$T2 = -508						; size = 120
$T3 = -380						; size = 4
_p$4 = -176						; size = 4
_font_cfg$ = -164					; size = 120
_data$ = -36						; size = 4
_data_size$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_size_pixels$ = 12					; size = 4
_font_cfg_template$ = 16				; size = 4
_glyph_ranges$ = 20					; size = 4
?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromFileTTF, COMDAT
; _this$ = ecx

; 1708 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 7c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-644]
  00013	b9 a1 00 00 00	 mov	 ecx, 161		; 000000a1H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1709 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00037	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 09		 jne	 SHORT $LN8@AddFontFro
  00041	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  00046	85 d2		 test	 edx, edx
  00048	75 25		 jne	 SHORT $LN9@AddFontFro
$LN8@AddFontFro:
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z@4JA
  0004f	83 c0 01	 add	 eax, 1
  00052	8b f4		 mov	 esi, esp
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@AddFontFro:

; 1710 :     size_t data_size = 0;

  0006f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _data_size$[ebp], 0

; 1711 :     void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);

  00076	6a 00		 push	 0
  00078	8d 45 e8	 lea	 eax, DWORD PTR _data_size$[ebp]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 ?ImFileLoadToMemory@@YAPAXPBD0PAIH@Z ; ImFileLoadToMemory
  0008a	83 c4 10	 add	 esp, 16			; 00000010H
  0008d	89 45 dc	 mov	 DWORD PTR _data$[ebp], eax

; 1712 :     if (!data)

  00090	83 7d dc 00	 cmp	 DWORD PTR _data$[ebp], 0
  00094	75 31		 jne	 SHORT $LN5@AddFontFro

; 1713 :     {
; 1714 :         IM_ASSERT_USER_ERROR(0, "Could not load font file!");

  00096	33 c0		 xor	 eax, eax
  00098	75 26		 jne	 SHORT $LN10@AddFontFro
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z@4JA
  000a0	83 c1 06	 add	 ecx, 6
  000a3	8b f4		 mov	 esi, esp
  000a5	51		 push	 ecx
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@AddFontFro:

; 1715 :         return NULL;

  000c0	33 c0		 xor	 eax, eax
  000c2	e9 17 01 00 00	 jmp	 $LN1@AddFontFro
$LN5@AddFontFro:

; 1716 :     }
; 1717 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000c7	83 7d 10 00	 cmp	 DWORD PTR _font_cfg_template$[ebp], 0
  000cb	74 1e		 je	 SHORT $LN11@AddFontFro
  000cd	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000d2	8b 75 10	 mov	 esi, DWORD PTR _font_cfg_template$[ebp]
  000d5	8d bd 04 fe ff
	ff		 lea	 edi, DWORD PTR $T2[ebp]
  000db	f3 a5		 rep movsd
  000dd	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000e3	89 85 7c fd ff
	ff		 mov	 DWORD PTR tv89[ebp], eax
  000e9	eb 11		 jmp	 SHORT $LN12@AddFontFro
$LN11@AddFontFro:
  000eb	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000f1	e8 00 00 00 00	 call	 ??0ImFontConfig@@QAE@XZ	; ImFontConfig::ImFontConfig
  000f6	89 85 7c fd ff
	ff		 mov	 DWORD PTR tv89[ebp], eax
$LN12@AddFontFro:
  000fc	8b 8d 7c fd ff
	ff		 mov	 ecx, DWORD PTR tv89[ebp]
  00102	89 8d 84 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00108	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  0010d	8b b5 84 fe ff
	ff		 mov	 esi, DWORD PTR $T3[ebp]
  00113	8d bd 5c ff ff
	ff		 lea	 edi, DWORD PTR _font_cfg$[ebp]
  00119	f3 a5		 rep movsd

; 1718 :     if (font_cfg.Name[0] == '\0')

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	6b c8 00	 imul	 ecx, eax, 0
  00123	0f be 54 0d a6	 movsx	 edx, BYTE PTR _font_cfg$[ebp+ecx+74]
  00128	85 d2		 test	 edx, edx
  0012a	0f 85 88 00 00
	00		 jne	 $LN6@AddFontFro

; 1719 :     {
; 1720 :         // Store a short copy of filename into into the font name for convenience
; 1721 :         const char* p;
; 1722 :         for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}

  00130	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _strlen
  00139	83 c4 04	 add	 esp, 4
  0013c	03 45 08	 add	 eax, DWORD PTR _filename$[ebp]
  0013f	89 85 50 ff ff
	ff		 mov	 DWORD PTR _p$4[ebp], eax
  00145	eb 0f		 jmp	 SHORT $LN4@AddFontFro
$LN2@AddFontFro:
  00147	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _p$4[ebp]
  0014d	83 e8 01	 sub	 eax, 1
  00150	89 85 50 ff ff
	ff		 mov	 DWORD PTR _p$4[ebp], eax
$LN4@AddFontFro:
  00156	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _p$4[ebp]
  0015c	3b 45 08	 cmp	 eax, DWORD PTR _filename$[ebp]
  0015f	76 30		 jbe	 SHORT $LN3@AddFontFro
  00161	b8 01 00 00 00	 mov	 eax, 1
  00166	6b c8 ff	 imul	 ecx, eax, -1
  00169	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _p$4[ebp]
  0016f	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00173	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00176	74 19		 je	 SHORT $LN3@AddFontFro
  00178	b8 01 00 00 00	 mov	 eax, 1
  0017d	6b c8 ff	 imul	 ecx, eax, -1
  00180	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _p$4[ebp]
  00186	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0018a	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0018d	74 02		 je	 SHORT $LN3@AddFontFro
  0018f	eb b6		 jmp	 SHORT $LN2@AddFontFro
$LN3@AddFontFro:

; 1723 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);

  00191	f3 0f 5a 45 0c	 cvtss2sd xmm0, DWORD PTR _size_pixels$[ebp]
  00196	83 ec 08	 sub	 esp, 8
  00199	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0019e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _p$4[ebp]
  001a4	50		 push	 eax
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@
  001aa	6a 28		 push	 40			; 00000028H
  001ac	8d 4d a6	 lea	 ecx, DWORD PTR _font_cfg$[ebp+74]
  001af	51		 push	 ecx
  001b0	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  001b5	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@AddFontFro:

; 1724 :     }
; 1725 :     return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);

  001b8	8b 45 14	 mov	 eax, DWORD PTR _glyph_ranges$[ebp]
  001bb	50		 push	 eax
  001bc	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _font_cfg$[ebp]
  001c2	51		 push	 ecx
  001c3	51		 push	 ecx
  001c4	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _size_pixels$[ebp]
  001c9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ce	8b 55 e8	 mov	 edx, DWORD PTR _data_size$[ebp]
  001d1	52		 push	 edx
  001d2	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	e8 00 00 00 00	 call	 ?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
$LN1@AddFontFro:

; 1726 : }

  001de	52		 push	 edx
  001df	8b cd		 mov	 ecx, ebp
  001e1	50		 push	 eax
  001e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@AddFontFro
  001e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ed	58		 pop	 eax
  001ee	5a		 pop	 edx
  001ef	5f		 pop	 edi
  001f0	5e		 pop	 esi
  001f1	5b		 pop	 ebx
  001f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f5	33 cd		 xor	 ecx, ebp
  001f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fc	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  00202	3b ec		 cmp	 ebp, esp
  00204	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 10 00	 ret	 16			; 00000010H
  0020f	90		 npad	 1
$LN16@AddFontFro:
  00210	02 00 00 00	 DD	 2
  00214	00 00 00 00	 DD	 $LN15@AddFontFro
$LN15@AddFontFro:
  00218	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0021c	04 00 00 00	 DD	 4
  00220	00 00 00 00	 DD	 $LN13@AddFontFro
  00224	5c ff ff ff	 DD	 -164			; ffffff5cH
  00228	78 00 00 00	 DD	 120			; 00000078H
  0022c	00 00 00 00	 DD	 $LN14@AddFontFro
$LN14@AddFontFro:
  00230	66		 DB	 102			; 00000066H
  00231	6f		 DB	 111			; 0000006fH
  00232	6e		 DB	 110			; 0000006eH
  00233	74		 DB	 116			; 00000074H
  00234	5f		 DB	 95			; 0000005fH
  00235	63		 DB	 99			; 00000063H
  00236	66		 DB	 102			; 00000066H
  00237	67		 DB	 103			; 00000067H
  00238	00		 DB	 0
$LN13@AddFontFro:
  00239	64		 DB	 100			; 00000064H
  0023a	61		 DB	 97			; 00000061H
  0023b	74		 DB	 116			; 00000074H
  0023c	61		 DB	 97			; 00000061H
  0023d	5f		 DB	 95			; 0000005fH
  0023e	73		 DB	 115			; 00000073H
  0023f	69		 DB	 105			; 00000069H
  00240	7a		 DB	 122			; 0000007aH
  00241	65		 DB	 101			; 00000065H
  00242	00		 DB	 0
?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromFileTTF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
_TEXT	SEGMENT
tv85 = -644						; size = 4
tv68 = -644						; size = 4
$T1 = -636						; size = 120
$T2 = -508						; size = 120
$T3 = -380						; size = 4
_font$ = -176						; size = 4
_glyph_ranges$ = -164					; size = 4
_ttf_compressed_base85$ = -152				; size = 4
_font_cfg$ = -140					; size = 120
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_font_cfg_template$ = 8					; size = 4
?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFontDefault, COMDAT
; _this$ = ecx

; 1687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 7c fd ff
	ff		 lea	 edi, DWORD PTR [ebp-644]
  00013	b9 a1 00 00 00	 mov	 ecx, 161		; 000000a1H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1688 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00037	83 7d 08 00	 cmp	 DWORD PTR _font_cfg_template$[ebp], 0
  0003b	74 1e		 je	 SHORT $LN6@AddFontDef
  0003d	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00042	8b 75 08	 mov	 esi, DWORD PTR _font_cfg_template$[ebp]
  00045	8d bd 04 fe ff
	ff		 lea	 edi, DWORD PTR $T2[ebp]
  0004b	f3 a5		 rep movsd
  0004d	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00053	89 85 7c fd ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  00059	eb 11		 jmp	 SHORT $LN7@AddFontDef
$LN6@AddFontDef:
  0005b	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00061	e8 00 00 00 00	 call	 ??0ImFontConfig@@QAE@XZ	; ImFontConfig::ImFontConfig
  00066	89 85 7c fd ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN7@AddFontDef:
  0006c	8b 8d 7c fd ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  00072	89 8d 84 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00078	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  0007d	8b b5 84 fe ff
	ff		 mov	 esi, DWORD PTR $T3[ebp]
  00083	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR _font_cfg$[ebp]
  00089	f3 a5		 rep movsd

; 1689 :     if (!font_cfg_template)

  0008b	83 7d 08 00	 cmp	 DWORD PTR _font_cfg_template$[ebp], 0
  0008f	75 11		 jne	 SHORT $LN2@AddFontDef

; 1690 :     {
; 1691 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;

  00091	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _font_cfg$[ebp+24], 1
  00098	8b 45 8c	 mov	 eax, DWORD PTR _font_cfg$[ebp+24]
  0009b	89 45 88	 mov	 DWORD PTR _font_cfg$[ebp+20], eax

; 1692 :         font_cfg.PixelSnapH = true;

  0009e	c6 45 90 01	 mov	 BYTE PTR _font_cfg$[ebp+28], 1
$LN2@AddFontDef:

; 1693 :     }
; 1694 :     if (font_cfg.SizePixels <= 0.0f)

  000a2	0f 57 c0	 xorps	 xmm0, xmm0
  000a5	0f 2f 45 84	 comiss	 xmm0, DWORD PTR _font_cfg$[ebp+16]
  000a9	72 0d		 jb	 SHORT $LN3@AddFontDef

; 1695 :         font_cfg.SizePixels = 13.0f * 1.0f;

  000ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41500000
  000b3	f3 0f 11 45 84	 movss	 DWORD PTR _font_cfg$[ebp+16], xmm0
$LN3@AddFontDef:

; 1696 :     if (font_cfg.Name[0] == '\0')

  000b8	b8 01 00 00 00	 mov	 eax, 1
  000bd	6b c8 00	 imul	 ecx, eax, 0
  000c0	0f be 54 0d be	 movsx	 edx, BYTE PTR _font_cfg$[ebp+ecx+74]
  000c5	85 d2		 test	 edx, edx
  000c7	75 19		 jne	 SHORT $LN4@AddFontDef

; 1697 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

  000c9	f3 0f 2c 45 84	 cvttss2si eax, DWORD PTR _font_cfg$[ebp+16]
  000ce	50		 push	 eax
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
  000d4	6a 28		 push	 40			; 00000028H
  000d6	8d 4d be	 lea	 ecx, DWORD PTR _font_cfg$[ebp+74]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPADIPBDZZ ; ImFormatString
  000df	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@AddFontDef:

; 1698 :     font_cfg.EllipsisChar = (ImWchar)0x0085;

  000e2	b8 85 00 00 00	 mov	 eax, 133		; 00000085H
  000e7	66 89 45 bc	 mov	 WORD PTR _font_cfg$[ebp+72], ax

; 1699 : 
; 1700 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();

  000eb	e8 00 00 00 00	 call	 ?GetDefaultCompressedFontDataTTFBase85@@YAPBDXZ ; GetDefaultCompressedFontDataTTFBase85
  000f0	89 85 68 ff ff
	ff		 mov	 DWORD PTR _ttf_compressed_base85$[ebp], eax

; 1701 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  000f6	83 7d a4 00	 cmp	 DWORD PTR _font_cfg$[ebp+48], 0
  000fa	74 0b		 je	 SHORT $LN8@AddFontDef
  000fc	8b 45 a4	 mov	 eax, DWORD PTR _font_cfg$[ebp+48]
  000ff	89 85 7c fd ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  00105	eb 0e		 jmp	 SHORT $LN9@AddFontDef
$LN8@AddFontDef:
  00107	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	e8 00 00 00 00	 call	 ?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesDefault
  0010f	89 85 7c fd ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$LN9@AddFontDef:
  00115	8b 8d 7c fd ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  0011b	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _glyph_ranges$[ebp], ecx

; 1702 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  00121	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _glyph_ranges$[ebp]
  00127	50		 push	 eax
  00128	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _font_cfg$[ebp]
  0012e	51		 push	 ecx
  0012f	51		 push	 ecx
  00130	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _font_cfg$[ebp+16]
  00135	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013a	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _ttf_compressed_base85$[ebp]
  00140	52		 push	 edx
  00141	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
  00149	89 85 50 ff ff
	ff		 mov	 DWORD PTR _font$[ebp], eax

; 1703 :     font->DisplayOffset.y = 1.0f;

  0014f	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _font$[ebp]
  00155	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0015d	f3 0f 11 40 34	 movss	 DWORD PTR [eax+52], xmm0

; 1704 :     return font;

  00162	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _font$[ebp]

; 1705 : }

  00168	52		 push	 edx
  00169	8b cd		 mov	 ecx, ebp
  0016b	50		 push	 eax
  0016c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@AddFontDef
  00172	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00177	58		 pop	 eax
  00178	5a		 pop	 edx
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi
  0017b	5b		 pop	 ebx
  0017c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017f	33 cd		 xor	 ecx, ebp
  00181	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00186	81 c4 84 02 00
	00		 add	 esp, 644		; 00000284H
  0018c	3b ec		 cmp	 ebp, esp
  0018e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 04 00	 ret	 4
  00199	0f 1f 00	 npad	 3
$LN12@AddFontDef:
  0019c	01 00 00 00	 DD	 1
  001a0	00 00 00 00	 DD	 $LN11@AddFontDef
$LN11@AddFontDef:
  001a4	74 ff ff ff	 DD	 -140			; ffffff74H
  001a8	78 00 00 00	 DD	 120			; 00000078H
  001ac	00 00 00 00	 DD	 $LN10@AddFontDef
$LN10@AddFontDef:
  001b0	66		 DB	 102			; 00000066H
  001b1	6f		 DB	 111			; 0000006fH
  001b2	6e		 DB	 110			; 0000006eH
  001b3	74		 DB	 116			; 00000074H
  001b4	5f		 DB	 95			; 0000005fH
  001b5	63		 DB	 99			; 00000063H
  001b6	66		 DB	 102			; 00000066H
  001b7	67		 DB	 103			; 00000067H
  001b8	00		 DB	 0
?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFontDefault
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
_TEXT	SEGMENT
tv142 = -304						; size = 4
$T2 = -293						; size = 1
$T3 = -284						; size = 4
$T4 = -272						; size = 4
$T5 = -260						; size = 4
$T6 = -248						; size = 4
$T7 = -236						; size = 4
_new_font_cfg$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_font_cfg$ = 8						; size = 4
?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFont, COMDAT
; _this$ = ecx

; 1639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd d0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-304]
  00021	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1640 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00052	85 c9		 test	 ecx, ecx
  00054	75 09		 jne	 SHORT $LN8@AddFont
  00056	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  0005b	85 d2		 test	 edx, edx
  0005d	75 25		 jne	 SHORT $LN9@AddFont
$LN8@AddFont:
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z@4JA
  00064	83 c0 01	 add	 eax, 1
  00067	8b f4		 mov	 esi, esp
  00069	50		 push	 eax
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@AddFont:

; 1641 :     IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);

  00084	8b 45 08	 mov	 eax, DWORD PTR _font_cfg$[ebp]
  00087	83 38 00	 cmp	 DWORD PTR [eax], 0
  0008a	74 09		 je	 SHORT $LN10@AddFont
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _font_cfg$[ebp]
  0008f	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00093	7f 26		 jg	 SHORT $LN11@AddFont
$LN10@AddFont:
  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z@4JA
  0009b	83 c2 02	 add	 edx, 2
  0009e	8b f4		 mov	 esi, esp
  000a0	52		 push	 edx
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@AddFont:

; 1642 :     IM_ASSERT(font_cfg->SizePixels > 0.0f);

  000bb	8b 45 08	 mov	 eax, DWORD PTR _font_cfg$[ebp]
  000be	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  000c3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000ca	77 26		 ja	 SHORT $LN12@AddFont
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z@4JA
  000d2	83 c1 03	 add	 ecx, 3
  000d5	8b f4		 mov	 esi, esp
  000d7	51		 push	 ecx
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000eb	3b f4		 cmp	 esi, esp
  000ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@AddFont:

; 1643 : 
; 1644 :     // Create new font
; 1645 :     if (!font_cfg->MergeMode)

  000f2	8b 45 08	 mov	 eax, DWORD PTR _font_cfg$[ebp]
  000f5	0f b6 48 3c	 movzx	 ecx, BYTE PTR [eax+60]
  000f9	85 c9		 test	 ecx, ecx
  000fb	0f 85 9d 00 00
	00		 jne	 $LN2@AddFont

; 1646 :         Fonts.push_back(IM_NEW(ImFont));

  00101	6a 5c		 push	 92			; 0000005cH
  00103	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00108	83 c4 04	 add	 esp, 4
  0010b	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  00111	8d 85 db fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00117	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0011d	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  00123	51		 push	 ecx
  00124	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  0012a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0012d	50		 push	 eax
  0012e	6a 5c		 push	 92			; 0000005cH
  00130	e8 00 00 00 00	 call	 ??2@YAPAXIUImNewDummy@@PAX@Z ; operator new
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
  00138	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  0013e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00145	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR $T5[ebp], 0
  0014c	74 13		 je	 SHORT $LN13@AddFont
  0014e	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00154	e8 00 00 00 00	 call	 ??0ImFont@@QAE@XZ	; ImFont::ImFont
  00159	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv142[ebp], eax
  0015f	eb 0a		 jmp	 SHORT $LN14@AddFont
$LN13@AddFont:
  00161	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv142[ebp], 0
$LN14@AddFont:
  0016b	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv142[ebp]
  00171	89 8d 08 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  00177	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017e	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR $T6[ebp]
  00184	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], edx
  0018a	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00190	50		 push	 eax
  00191	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	83 c1 34	 add	 ecx, 52			; 00000034H
  00197	e8 00 00 00 00	 call	 ?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ; ImVector<ImFont *>::push_back
  0019c	eb 41		 jmp	 SHORT $LN16@AddFont
$LN2@AddFont:

; 1647 :     else
; 1648 :         IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

  0019e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	83 c1 34	 add	 ecx, 52			; 00000034H
  001a4	e8 00 00 00 00	 call	 ?empty@?$ImVector@PAUImFont@@@@QBE_NXZ ; ImVector<ImFont *>::empty
  001a9	0f b6 c0	 movzx	 eax, al
  001ac	85 c0		 test	 eax, eax
  001ae	75 09		 jne	 SHORT $LN15@AddFont
  001b0	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CI@EDBCHFCN@Cannot?5use?5MergeMode?5for?5the?5fi@
  001b5	85 c9		 test	 ecx, ecx
  001b7	75 26		 jne	 SHORT $LN16@AddFont
$LN15@AddFont:
  001b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z@4JA
  001bf	83 c2 09	 add	 edx, 9
  001c2	8b f4		 mov	 esi, esp
  001c4	52		 push	 edx
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d8	3b f4		 cmp	 esi, esp
  001da	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@AddFont:

; 1649 : 
; 1650 :     ConfigData.push_back(*font_cfg);

  001df	8b 45 08	 mov	 eax, DWORD PTR _font_cfg$[ebp]
  001e2	50		 push	 eax
  001e3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	83 c1 4c	 add	 ecx, 76			; 0000004cH
  001e9	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back

; 1651 :     ImFontConfig& new_font_cfg = ConfigData.back();

  001ee	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	83 c1 4c	 add	 ecx, 76			; 0000004cH
  001f4	e8 00 00 00 00	 call	 ?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ ; ImVector<ImFontConfig>::back
  001f9	89 45 e0	 mov	 DWORD PTR _new_font_cfg$[ebp], eax

; 1652 :     if (new_font_cfg.DstFont == NULL)

  001fc	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  001ff	83 78 74 00	 cmp	 DWORD PTR [eax+116], 0
  00203	75 13		 jne	 SHORT $LN4@AddFont

; 1653 :         new_font_cfg.DstFont = Fonts.back();

  00205	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	83 c1 34	 add	 ecx, 52			; 00000034H
  0020b	e8 00 00 00 00	 call	 ?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ ; ImVector<ImFont *>::back
  00210	8b 4d e0	 mov	 ecx, DWORD PTR _new_font_cfg$[ebp]
  00213	8b 10		 mov	 edx, DWORD PTR [eax]
  00215	89 51 74	 mov	 DWORD PTR [ecx+116], edx
$LN4@AddFont:

; 1654 :     if (!new_font_cfg.FontDataOwnedByAtlas)

  00218	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  0021b	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0021f	85 c9		 test	 ecx, ecx
  00221	75 36		 jne	 SHORT $LN5@AddFont

; 1655 :     {
; 1656 :         new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);

  00223	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  00226	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00229	51		 push	 ecx
  0022a	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  0022f	83 c4 04	 add	 esp, 4
  00232	8b 55 e0	 mov	 edx, DWORD PTR _new_font_cfg$[ebp]
  00235	89 02		 mov	 DWORD PTR [edx], eax

; 1657 :         new_font_cfg.FontDataOwnedByAtlas = true;

  00237	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  0023a	c6 40 08 01	 mov	 BYTE PTR [eax+8], 1

; 1658 :         memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);

  0023e	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  00241	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00244	51		 push	 ecx
  00245	8b 55 08	 mov	 edx, DWORD PTR _font_cfg$[ebp]
  00248	8b 02		 mov	 eax, DWORD PTR [edx]
  0024a	50		 push	 eax
  0024b	8b 4d e0	 mov	 ecx, DWORD PTR _new_font_cfg$[ebp]
  0024e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00250	52		 push	 edx
  00251	e8 00 00 00 00	 call	 _memcpy
  00256	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@AddFont:

; 1659 :     }
; 1660 : 
; 1661 :     if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)

  00259	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  0025c	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0025f	0f b7 51 44	 movzx	 edx, WORD PTR [ecx+68]
  00263	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00269	75 11		 jne	 SHORT $LN6@AddFont

; 1662 :         new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;

  0026b	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  0026e	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00271	8b 55 08	 mov	 edx, DWORD PTR _font_cfg$[ebp]
  00274	66 8b 42 48	 mov	 ax, WORD PTR [edx+72]
  00278	66 89 41 44	 mov	 WORD PTR [ecx+68], ax
$LN6@AddFont:

; 1663 : 
; 1664 :     // Invalidate texture
; 1665 :     ClearTexData();

  0027c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0027f	e8 00 00 00 00	 call	 ?ClearTexData@ImFontAtlas@@QAEXXZ ; ImFontAtlas::ClearTexData

; 1666 :     return new_font_cfg.DstFont;

  00284	8b 45 e0	 mov	 eax, DWORD PTR _new_font_cfg$[ebp]
  00287	8b 40 74	 mov	 eax, DWORD PTR [eax+116]

; 1667 : }

  0028a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0028d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00294	59		 pop	 ecx
  00295	5f		 pop	 edi
  00296	5e		 pop	 esi
  00297	5b		 pop	 ebx
  00298	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  0029e	3b ec		 cmp	 ebp, esp
  002a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z$0:
  00000	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00006	50		 push	 eax
  00007	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00010	50		 push	 eax
  00011	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXUImNewDummy@@0@Z ; operator delete
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	c3		 ret	 0
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a cc fe ff
	ff		 mov	 ecx, DWORD PTR [edx-308]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFont
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ??1ImFontAtlas@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ImFontAtlas@@QAE@XZ PROC				; ImFontAtlas::~ImFontAtlas, COMDAT
; _this$ = ecx

; 1544 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ImFontAtlas@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1545 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00052	85 c9		 test	 ecx, ecx
  00054	75 09		 jne	 SHORT $LN3@ImFontAtla
  00056	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
  0005b	85 d2		 test	 edx, edx
  0005d	75 25		 jne	 SHORT $LN4@ImFontAtla
$LN3@ImFontAtla:
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0???1ImFontAtlas@@QAE@XZ@4JA
  00064	83 c0 01	 add	 eax, 1
  00067	8b f4		 mov	 esi, esp
  00069	50		 push	 eax
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@ImFontAtla:

; 1546 :     Clear();

  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?Clear@ImFontAtlas@@QAEXXZ ; ImFontAtlas::Clear

; 1547 : }

  0008c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00092	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontConfig@@@@QAE@XZ ; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
  00097	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	83 c1 40	 add	 ecx, 64			; 00000040H
  0009d	e8 00 00 00 00	 call	 ??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ ; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
  000a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	83 c1 34	 add	 ecx, 52			; 00000034H
  000a8	e8 00 00 00 00	 call	 ??1?$ImVector@PAUImFont@@@@QAE@XZ ; ImVector<ImFont *>::~ImVector<ImFont *>
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b7	59		 pop	 ecx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c1	3b ec		 cmp	 ebp, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
  000cc	cc		 int	 3
  000cd	cc		 int	 3
  000ce	cc		 int	 3
  000cf	cc		 int	 3
  000d0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImFontAtlas@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ImFontAtlas@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ImFontAtlas@@QAE@XZ ENDP				; ImFontAtlas::~ImFontAtlas
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ??0ImFontAtlas@@QAE@XZ
_TEXT	SEGMENT
$T2 = -256						; size = 8
$T3 = -240						; size = 8
_n$4 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ImFontAtlas@@QAE@XZ PROC				; ImFontAtlas::ImFontAtlas, COMDAT
; _this$ = ecx

; 1527 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImFontAtlas@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd fc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-260]
  00021	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 24	 add	 ecx, 36			; 00000024H
  00052	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0005d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00062	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 34	 add	 ecx, 52			; 00000034H
  00068	e8 00 00 00 00	 call	 ??0?$ImVector@PAUImFont@@@@QAE@XZ ; ImVector<ImFont *>::ImVector<ImFont *>
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 40	 add	 ecx, 64			; 00000040H
  0007a	e8 00 00 00 00	 call	 ??0?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ ; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>
  0007f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00089	e8 00 00 00 00	 call	 ??0?$ImVector@UImFontConfig@@@@QAE@XZ ; ImVector<ImFontConfig>::ImVector<ImFontConfig>
  0008e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1528 :     Locked = false;

  00092	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00095	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1529 :     Flags = ImFontAtlasFlags_None;

  00098	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1530 :     TexID = (ImTextureID)NULL;

  000a2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1531 :     TexDesiredWidth = 0;

  000ac	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000af	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 1532 :     TexGlyphPadding = 1;

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 1533 : 
; 1534 :     TexPixelsAlpha8 = NULL;

  000c0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 1535 :     TexPixelsRGBA32 = NULL;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1536 :     TexWidth = TexHeight = 0;

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1537 :     TexUvScale = ImVec2(0.0f, 0.0f);

  000e8	51		 push	 ecx
  000e9	0f 57 c0	 xorps	 xmm0, xmm0
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	51		 push	 ecx
  000f2	0f 57 c0	 xorps	 xmm0, xmm0
  000f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fa	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00100	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00105	8b 08		 mov	 ecx, DWORD PTR [eax]
  00107	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	89 48 24	 mov	 DWORD PTR [eax+36], ecx
  00110	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 1538 :     TexUvWhitePixel = ImVec2(0.0f, 0.0f);

  00113	51		 push	 ecx
  00114	0f 57 c0	 xorps	 xmm0, xmm0
  00117	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011c	51		 push	 ecx
  0011d	0f 57 c0	 xorps	 xmm0, xmm0
  00120	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00125	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0012b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00135	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00138	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  0013b	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 1539 :     for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)

  0013e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _n$4[ebp], 0
  00145	eb 09		 jmp	 SHORT $LN4@ImFontAtla
$LN2@ImFontAtla:
  00147	8b 45 e0	 mov	 eax, DWORD PTR _n$4[ebp]
  0014a	83 c0 01	 add	 eax, 1
  0014d	89 45 e0	 mov	 DWORD PTR _n$4[ebp], eax
$LN4@ImFontAtla:
  00150	83 7d e0 01	 cmp	 DWORD PTR _n$4[ebp], 1
  00154	7d 10		 jge	 SHORT $LN3@ImFontAtla

; 1540 :         CustomRectIds[n] = -1;

  00156	8b 45 e0	 mov	 eax, DWORD PTR _n$4[ebp]
  00159	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	c7 44 81 58 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax*4+88], -1
  00164	eb e1		 jmp	 SHORT $LN2@ImFontAtla
$LN3@ImFontAtla:

; 1541 : }

  00166	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0016d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00170	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00173	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017a	59		 pop	 ecx
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  00184	3b ec		 cmp	 ebp, esp
  00186	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018b	8b e5		 mov	 esp, ebp
  0018d	5d		 pop	 ebp
  0018e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImFontAtlas@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 34	 add	 ecx, 52			; 00000034H
  00006	e9 00 00 00 00	 jmp	 ??1?$ImVector@PAUImFont@@@@QAE@XZ ; ImVector<ImFont *>::~ImVector<ImFont *>
__unwindfunclet$??0ImFontAtlas@@QAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 40	 add	 ecx, 64			; 00000040H
  00011	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontAtlasCustomRect@@@@QAE@XZ ; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
__unwindfunclet$??0ImFontAtlas@@QAE@XZ$2:
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001c	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontConfig@@@@QAE@XZ ; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$??0ImFontAtlas@@QAE@XZ:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a f8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-264]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImFontAtlas@@QAE@XZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImFontAtlas@@QAE@XZ ENDP				; ImFontAtlas::ImFontAtlas
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?IsPacked@ImFontAtlasCustomRect@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -208						; size = 4
_this$ = -8						; size = 4
?IsPacked@ImFontAtlasCustomRect@@QBE_NXZ PROC		; ImFontAtlasCustomRect::IsPacked, COMDAT
; _this$ = ecx

; 2080 :     bool IsPacked() const           { return X != 0xFFFF; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  00034	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0003a	74 0c		 je	 SHORT $LN3@IsPacked
  0003c	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00046	eb 0a		 jmp	 SHORT $LN4@IsPacked
$LN3@IsPacked:
  00048	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN4@IsPacked:
  00052	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv67[ebp]
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?IsPacked@ImFontAtlasCustomRect@@QBE_NXZ ENDP		; ImFontAtlasCustomRect::IsPacked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImFontAtlasCustomRect@@QAE@XZ
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
??0ImFontAtlasCustomRect@@QAE@XZ PROC			; ImFontAtlasCustomRect::ImFontAtlasCustomRect, COMDAT
; _this$ = ecx

; 2079 :     ImFontAtlasCustomRect()         { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 10	 add	 ecx, 16			; 00000010H
  00033	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00041	33 c0		 xor	 eax, eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  0004a	33 d2		 xor	 edx, edx
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  00053	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax
  0005f	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	66 89 50 08	 mov	 WORD PTR [eax+8], dx
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	0f 57 c0	 xorps	 xmm0, xmm0
  00071	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  00076	51		 push	 ecx
  00077	0f 57 c0	 xorps	 xmm0, xmm0
  0007a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007f	51		 push	 ecx
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00088	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0008e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00098	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0009e	89 50 14	 mov	 DWORD PTR [eax+20], edx
  000a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000b7	3b ec		 cmp	 ebp, esp
  000b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
??0ImFontAtlasCustomRect@@QAE@XZ ENDP			; ImFontAtlasCustomRect::ImFontAtlasCustomRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?BuildRanges@ImFontGlyphRangesBuilder@@QAEXPAU?$ImVector@G@@@Z
_TEXT	SEGMENT
$T1 = -258						; size = 2
$T2 = -246						; size = 2
$T3 = -234						; size = 2
_n$4 = -32						; size = 4
_max_codepoint$ = -20					; size = 4
_this$ = -8						; size = 4
_out_ranges$ = 8					; size = 4
?BuildRanges@ImFontGlyphRangesBuilder@@QAEXPAU?$ImVector@G@@@Z PROC ; ImFontGlyphRangesBuilder::BuildRanges, COMDAT
; _this$ = ecx

; 2508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00013	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2509 :     const int max_codepoint = IM_UNICODE_CODEPOINT_MAX;

  0002d	c7 45 ec ff ff
	00 00		 mov	 DWORD PTR _max_codepoint$[ebp], 65535 ; 0000ffffH

; 2510 :     for (int n = 0; n <= max_codepoint; n++)

  00034	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _n$4[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@BuildRange
$LN2@BuildRange:
  0003d	8b 45 e0	 mov	 eax, DWORD PTR _n$4[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 e0	 mov	 DWORD PTR _n$4[ebp], eax
$LN4@BuildRange:
  00046	81 7d e0 ff ff
	00 00		 cmp	 DWORD PTR _n$4[ebp], 65535 ; 0000ffffH
  0004d	7f 76		 jg	 SHORT $LN3@BuildRange

; 2511 :         if (GetBit(n))

  0004f	8b 45 e0	 mov	 eax, DWORD PTR _n$4[ebp]
  00052	50		 push	 eax
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?GetBit@ImFontGlyphRangesBuilder@@QBE_NH@Z ; ImFontGlyphRangesBuilder::GetBit
  0005b	0f b6 c8	 movzx	 ecx, al
  0005e	85 c9		 test	 ecx, ecx
  00060	74 5e		 je	 SHORT $LN7@BuildRange

; 2512 :         {
; 2513 :             out_ranges->push_back((ImWchar)n);

  00062	66 8b 45 e0	 mov	 ax, WORD PTR _n$4[ebp]
  00066	66 89 85 16 ff
	ff ff		 mov	 WORD PTR $T3[ebp], ax
  0006d	8d 8d 16 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00073	51		 push	 ecx
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _out_ranges$[ebp]
  00077	e8 00 00 00 00	 call	 ?push_back@?$ImVector@G@@QAEXABG@Z ; ImVector<unsigned short>::push_back
$LN5@BuildRange:

; 2514 :             while (n < max_codepoint && GetBit(n + 1))

  0007c	81 7d e0 ff ff
	00 00		 cmp	 DWORD PTR _n$4[ebp], 65535 ; 0000ffffH
  00083	7d 21		 jge	 SHORT $LN6@BuildRange
  00085	8b 45 e0	 mov	 eax, DWORD PTR _n$4[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	50		 push	 eax
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?GetBit@ImFontGlyphRangesBuilder@@QBE_NH@Z ; ImFontGlyphRangesBuilder::GetBit
  00094	0f b6 c8	 movzx	 ecx, al
  00097	85 c9		 test	 ecx, ecx
  00099	74 0b		 je	 SHORT $LN6@BuildRange

; 2515 :                 n++;

  0009b	8b 45 e0	 mov	 eax, DWORD PTR _n$4[ebp]
  0009e	83 c0 01	 add	 eax, 1
  000a1	89 45 e0	 mov	 DWORD PTR _n$4[ebp], eax
  000a4	eb d6		 jmp	 SHORT $LN5@BuildRange
$LN6@BuildRange:

; 2516 :             out_ranges->push_back((ImWchar)n);

  000a6	66 8b 45 e0	 mov	 ax, WORD PTR _n$4[ebp]
  000aa	66 89 85 0a ff
	ff ff		 mov	 WORD PTR $T2[ebp], ax
  000b1	8d 8d 0a ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b7	51		 push	 ecx
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _out_ranges$[ebp]
  000bb	e8 00 00 00 00	 call	 ?push_back@?$ImVector@G@@QAEXABG@Z ; ImVector<unsigned short>::push_back
$LN7@BuildRange:

; 2517 :         }

  000c0	e9 78 ff ff ff	 jmp	 $LN2@BuildRange
$LN3@BuildRange:

; 2518 :     out_ranges->push_back(0);

  000c5	33 c0		 xor	 eax, eax
  000c7	66 89 85 fe fe
	ff ff		 mov	 WORD PTR $T1[ebp], ax
  000ce	8d 8d fe fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000d4	51		 push	 ecx
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _out_ranges$[ebp]
  000d8	e8 00 00 00 00	 call	 ?push_back@?$ImVector@G@@QAEXABG@Z ; ImVector<unsigned short>::push_back

; 2519 : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?BuildRanges@ImFontGlyphRangesBuilder@@QAEXPAU?$ImVector@G@@@Z ENDP ; ImFontGlyphRangesBuilder::BuildRanges
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddRanges@ImFontGlyphRangesBuilder@@QAEXPBG@Z
_TEXT	SEGMENT
_c$1 = -20						; size = 2
_this$ = -8						; size = 4
_ranges$ = 8						; size = 4
?AddRanges@ImFontGlyphRangesBuilder@@QAEXPBG@Z PROC	; ImFontGlyphRangesBuilder::AddRanges, COMDAT
; _this$ = ecx

; 2501 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2502 :     for (; ranges[0]; ranges += 2)

  0002d	eb 09		 jmp	 SHORT $LN4@AddRanges
$LN2@AddRanges:
  0002f	8b 45 08	 mov	 eax, DWORD PTR _ranges$[ebp]
  00032	83 c0 04	 add	 eax, 4
  00035	89 45 08	 mov	 DWORD PTR _ranges$[ebp], eax
$LN4@AddRanges:
  00038	b8 02 00 00 00	 mov	 eax, 2
  0003d	6b c8 00	 imul	 ecx, eax, 0
  00040	8b 55 08	 mov	 edx, DWORD PTR _ranges$[ebp]
  00043	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00047	85 c0		 test	 eax, eax
  00049	74 49		 je	 SHORT $LN1@AddRanges

; 2503 :         for (ImWchar c = ranges[0]; c <= ranges[1]; c++)

  0004b	b8 02 00 00 00	 mov	 eax, 2
  00050	6b c8 00	 imul	 ecx, eax, 0
  00053	8b 55 08	 mov	 edx, DWORD PTR _ranges$[ebp]
  00056	66 8b 04 0a	 mov	 ax, WORD PTR [edx+ecx]
  0005a	66 89 45 ec	 mov	 WORD PTR _c$1[ebp], ax
  0005e	eb 0c		 jmp	 SHORT $LN7@AddRanges
$LN5@AddRanges:
  00060	66 8b 45 ec	 mov	 ax, WORD PTR _c$1[ebp]
  00064	66 83 c0 01	 add	 ax, 1
  00068	66 89 45 ec	 mov	 WORD PTR _c$1[ebp], ax
$LN7@AddRanges:
  0006c	0f b7 45 ec	 movzx	 eax, WORD PTR _c$1[ebp]
  00070	b9 02 00 00 00	 mov	 ecx, 2
  00075	c1 e1 00	 shl	 ecx, 0
  00078	8b 55 08	 mov	 edx, DWORD PTR _ranges$[ebp]
  0007b	0f b7 0c 0a	 movzx	 ecx, WORD PTR [edx+ecx]
  0007f	3b c1		 cmp	 eax, ecx
  00081	7f 0f		 jg	 SHORT $LN6@AddRanges

; 2504 :             AddChar(c);

  00083	0f b7 45 ec	 movzx	 eax, WORD PTR _c$1[ebp]
  00087	50		 push	 eax
  00088	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?AddChar@ImFontGlyphRangesBuilder@@QAEXG@Z ; ImFontGlyphRangesBuilder::AddChar
  00090	eb ce		 jmp	 SHORT $LN5@AddRanges
$LN6@AddRanges:
  00092	eb 9b		 jmp	 SHORT $LN2@AddRanges
$LN1@AddRanges:

; 2505 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009d	3b ec		 cmp	 ebp, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
?AddRanges@ImFontGlyphRangesBuilder@@QAEXPBG@Z ENDP	; ImFontGlyphRangesBuilder::AddRanges
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddText@ImFontGlyphRangesBuilder@@QAEXPBD0@Z
_TEXT	SEGMENT
tv68 = -240						; size = 4
tv65 = -236						; size = 4
_c_len$1 = -36						; size = 4
_c$2 = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_text_end$ = 12						; size = 4
?AddText@ImFontGlyphRangesBuilder@@QAEXPBD0@Z PROC	; ImFontGlyphRangesBuilder::AddText, COMDAT
; _this$ = ecx

; 2487 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@AddText:

; 2488 :     while (text_end ? (text < text_end) : *text)

  00037	83 7d 0c 00	 cmp	 DWORD PTR _text_end$[ebp], 0
  0003b	74 2c		 je	 SHORT $LN9@AddText
  0003d	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  00040	3b 45 0c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  00043	73 0c		 jae	 SHORT $LN7@AddText
  00045	c7 85 14 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  0004f	eb 0a		 jmp	 SHORT $LN8@AddText
$LN7@AddText:
  00051	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN8@AddText:
  0005b	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  00061	89 8d 10 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
  00067	eb 0c		 jmp	 SHORT $LN10@AddText
$LN9@AddText:
  00069	8b 55 08	 mov	 edx, DWORD PTR _text$[ebp]
  0006c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0006f	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
$LN10@AddText:
  00075	83 bd 10 ff ff
	ff 00		 cmp	 DWORD PTR tv68[ebp], 0
  0007c	74 4a		 je	 SHORT $LN1@AddText

; 2489 :     {
; 2490 :         unsigned int c = 0;

  0007e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _c$2[ebp], 0

; 2491 :         int c_len = ImTextCharFromUtf8(&c, text, text_end);

  00085	8b 45 0c	 mov	 eax, DWORD PTR _text_end$[ebp]
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _text$[ebp]
  0008c	51		 push	 ecx
  0008d	8d 55 e8	 lea	 edx, DWORD PTR _c$2[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPAIPBD1@Z ; ImTextCharFromUtf8
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	89 45 dc	 mov	 DWORD PTR _c_len$1[ebp], eax

; 2492 :         text += c_len;

  0009c	8b 45 08	 mov	 eax, DWORD PTR _text$[ebp]
  0009f	03 45 dc	 add	 eax, DWORD PTR _c_len$1[ebp]
  000a2	89 45 08	 mov	 DWORD PTR _text$[ebp], eax

; 2493 :         if (c_len == 0)

  000a5	83 7d dc 00	 cmp	 DWORD PTR _c_len$1[ebp], 0
  000a9	75 02		 jne	 SHORT $LN4@AddText

; 2494 :             break;

  000ab	eb 1b		 jmp	 SHORT $LN1@AddText
$LN4@AddText:

; 2495 :         if (c <= IM_UNICODE_CODEPOINT_MAX)

  000ad	81 7d e8 ff ff
	00 00		 cmp	 DWORD PTR _c$2[ebp], 65535 ; 0000ffffH
  000b4	77 0d		 ja	 SHORT $LN5@AddText

; 2496 :             AddChar((ImWchar)c);

  000b6	0f b7 45 e8	 movzx	 eax, WORD PTR _c$2[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?AddChar@ImFontGlyphRangesBuilder@@QAEXG@Z ; ImFontGlyphRangesBuilder::AddChar
$LN5@AddText:

; 2497 :     }

  000c3	e9 6f ff ff ff	 jmp	 $LN2@AddText
$LN1@AddText:

; 2498 : }

  000c8	52		 push	 edx
  000c9	8b cd		 mov	 ecx, ebp
  000cb	50		 push	 eax
  000cc	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@AddText
  000d2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d7	58		 pop	 eax
  000d8	5a		 pop	 edx
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000ec	3b ec		 cmp	 ebp, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 08 00	 ret	 8
  000f9	0f 1f 00	 npad	 3
$LN13@AddText:
  000fc	01 00 00 00	 DD	 1
  00100	00 00 00 00	 DD	 $LN12@AddText
$LN12@AddText:
  00104	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00108	04 00 00 00	 DD	 4
  0010c	00 00 00 00	 DD	 $LN11@AddText
$LN11@AddText:
  00110	63		 DB	 99			; 00000063H
  00111	00		 DB	 0
?AddText@ImFontGlyphRangesBuilder@@QAEXPBD0@Z ENDP	; ImFontGlyphRangesBuilder::AddText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?AddChar@ImFontGlyphRangesBuilder@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$ = 8							; size = 2
?AddChar@ImFontGlyphRangesBuilder@@QAEXG@Z PROC		; ImFontGlyphRangesBuilder::AddChar, COMDAT
; _this$ = ecx

; 2064 :     inline void     AddChar(ImWchar c)  { SetBit(c); }                          // Add character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	0f b7 45 08	 movzx	 eax, WORD PTR _c$[ebp]
  00031	50		 push	 eax
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?SetBit@ImFontGlyphRangesBuilder@@QAEXH@Z ; ImFontGlyphRangesBuilder::SetBit
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?AddChar@ImFontGlyphRangesBuilder@@QAEXG@Z ENDP		; ImFontGlyphRangesBuilder::AddChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?SetBit@ImFontGlyphRangesBuilder@@QAEXH@Z
_TEXT	SEGMENT
tv71 = -232						; size = 4
_mask$ = -32						; size = 4
_off$ = -20						; size = 4
_this$ = -8						; size = 4
_n$ = 8							; size = 4
?SetBit@ImFontGlyphRangesBuilder@@QAEXH@Z PROC		; ImFontGlyphRangesBuilder::SetBit, COMDAT
; _this$ = ecx

; 2063 :     inline void     SetBit(int n)       { int off = (n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }               // Set bit n in the array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00030	c1 f8 05	 sar	 eax, 5
  00033	89 45 ec	 mov	 DWORD PTR _off$[ebp], eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00039	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	d3 e0		 shl	 eax, cl
  00043	89 45 e0	 mov	 DWORD PTR _mask$[ebp], eax
  00046	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??A?$ImVector@I@@QAEAAIH@Z ; ImVector<unsigned int>::operator[]
  00052	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00058	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  0005e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00060	0b 55 e0	 or	 edx, DWORD PTR _mask$[ebp]
  00063	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv71[ebp]
  00069	89 10		 mov	 DWORD PTR [eax], edx
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
?SetBit@ImFontGlyphRangesBuilder@@QAEXH@Z ENDP		; ImFontGlyphRangesBuilder::SetBit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?GetBit@ImFontGlyphRangesBuilder@@QBE_NH@Z
_TEXT	SEGMENT
tv73 = -232						; size = 4
_mask$ = -32						; size = 4
_off$ = -20						; size = 4
_this$ = -8						; size = 4
_n$ = 8							; size = 4
?GetBit@ImFontGlyphRangesBuilder@@QBE_NH@Z PROC		; ImFontGlyphRangesBuilder::GetBit, COMDAT
; _this$ = ecx

; 2062 :     inline bool     GetBit(int n) const { int off = (n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }  // Get bit n in the array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00013	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00030	c1 f8 05	 sar	 eax, 5
  00033	89 45 ec	 mov	 DWORD PTR _off$[ebp], eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00039	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	d3 e0		 shl	 eax, cl
  00043	89 45 e0	 mov	 DWORD PTR _mask$[ebp], eax
  00046	8b 45 ec	 mov	 eax, DWORD PTR _off$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??A?$ImVector@I@@QBEABIH@Z ; ImVector<unsigned int>::operator[]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	23 4d e0	 and	 ecx, DWORD PTR _mask$[ebp]
  00057	74 0c		 je	 SHORT $LN3@GetBit
  00059	c7 85 18 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv73[ebp], 1
  00063	eb 0a		 jmp	 SHORT $LN4@GetBit
$LN3@GetBit:
  00065	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv73[ebp], 0
$LN4@GetBit:
  0006f	8a 85 18 ff ff
	ff		 mov	 al, BYTE PTR tv73[ebp]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?GetBit@ImFontGlyphRangesBuilder@@QBE_NH@Z ENDP		; ImFontGlyphRangesBuilder::GetBit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@I@@QBEABIH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@I@@QBEABIH@Z PROC				; ImVector<unsigned int>::operator[], COMDAT
; _this$ = ecx

; 1273 :     inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f9 04 00 00	 push	 1273			; 000004f9H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@I@@QBEABIH@Z ENDP				; ImVector<unsigned int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@I@@QAEAAIH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@I@@QAEAAIH@Z PROC				; ImVector<unsigned int>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@I@@QAEAAIH@Z ENDP				; ImVector<unsigned int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ??0ImFontConfig@@QAE@XZ
_TEXT	SEGMENT
$T1 = -232						; size = 8
$T2 = -216						; size = 8
_this$ = -8						; size = 4
??0ImFontConfig@@QAE@XZ PROC				; ImFontConfig::ImFontConfig, COMDAT
; _this$ = ecx

; 1451 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00013	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 20	 add	 ecx, 32			; 00000020H
  00033	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 28	 add	 ecx, 40			; 00000028H
  0003e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@XZ	; ImVec2::ImVec2

; 1452 :     FontData = NULL;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1453 :     FontDataSize = 0;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1454 :     FontDataOwnedByAtlas = true;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	c6 40 08 01	 mov	 BYTE PTR [eax+8], 1

; 1455 :     FontNo = 0;

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 1456 :     SizePixels = 0.0f;

  00067	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	0f 57 c0	 xorps	 xmm0, xmm0
  0006d	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 1457 :     OversampleH = 3; // FIXME: 2 may be a better default?

  00072	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c7 40 14 03 00
	00 00		 mov	 DWORD PTR [eax+20], 3

; 1458 :     OversampleV = 1;

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 1459 :     PixelSnapH = false;

  00086	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	c6 40 1c 00	 mov	 BYTE PTR [eax+28], 0

; 1460 :     GlyphExtraSpacing = ImVec2(0.0f, 0.0f);

  0008d	51		 push	 ecx
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00096	51		 push	 ecx
  00097	0f 57 c0	 xorps	 xmm0, xmm0
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000af	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  000b5	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 1461 :     GlyphOffset = ImVec2(0.0f, 0.0f);

  000b8	51		 push	 ecx
  000b9	0f 57 c0	 xorps	 xmm0, xmm0
  000bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c1	51		 push	 ecx
  000c2	0f 57 c0	 xorps	 xmm0, xmm0
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000d0	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  000e0	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 1462 :     GlyphRanges = NULL;

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1463 :     GlyphMinAdvanceX = 0.0f;

  000ed	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	0f 57 c0	 xorps	 xmm0, xmm0
  000f3	f3 0f 11 40 34	 movss	 DWORD PTR [eax+52], xmm0

; 1464 :     GlyphMaxAdvanceX = FLT_MAX;

  000f8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00103	f3 0f 11 40 38	 movss	 DWORD PTR [eax+56], xmm0

; 1465 :     MergeMode = false;

  00108	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	c6 40 3c 00	 mov	 BYTE PTR [eax+60], 0

; 1466 :     RasterizerFlags = 0x00;

  0010f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00112	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 1467 :     RasterizerMultiply = 1.0f;

  00119	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00124	f3 0f 11 40 44	 movss	 DWORD PTR [eax+68], xmm0

; 1468 :     EllipsisChar = (ImWchar)-1;

  00129	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	66 89 41 48	 mov	 WORD PTR [ecx+72], ax

; 1469 :     memset(Name, 0, sizeof(Name));

  00135	6a 28		 push	 40			; 00000028H
  00137	6a 00		 push	 0
  00139	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0013c	83 c0 4a	 add	 eax, 74			; 0000004aH
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _memset
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1470 :     DstFont = NULL;

  00148	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0

; 1471 : }

  00152	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx
  00158	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  0015e	3b ec		 cmp	 ebp, esp
  00160	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
??0ImFontConfig@@QAE@XZ ENDP				; ImFontConfig::ImFontConfig
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
$T1 = -272						; size = 16
_cmd$2 = -56						; size = 4
_cmd_i$3 = -44						; size = 4
_cmd_list$4 = -32					; size = 4
_i$5 = -20						; size = 4
_this$ = -8						; size = 4
_fb_scale$ = 8						; size = 4
?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z PROC	; ImDrawData::ScaleClipRects, COMDAT
; _this$ = ecx

; 1387 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00013	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1388 :     for (int i = 0; i < CmdListsCount; i++)

  0002d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@ScaleClipR
$LN2@ScaleClipR:
  00036	8b 45 ec	 mov	 eax, DWORD PTR _i$5[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 ec	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@ScaleClipR:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _i$5[ebp]
  00045	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00048	0f 8d c5 00 00
	00		 jge	 $LN3@ScaleClipR

; 1389 :     {
; 1390 :         ImDrawList* cmd_list = CmdLists[i];

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	8b 55 ec	 mov	 edx, DWORD PTR _i$5[ebp]
  00057	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0005a	89 45 e0	 mov	 DWORD PTR _cmd_list$4[ebp], eax

; 1391 :         for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

  0005d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _cmd_i$3[ebp], 0
  00064	eb 09		 jmp	 SHORT $LN7@ScaleClipR
$LN5@ScaleClipR:
  00066	8b 45 d4	 mov	 eax, DWORD PTR _cmd_i$3[ebp]
  00069	83 c0 01	 add	 eax, 1
  0006c	89 45 d4	 mov	 DWORD PTR _cmd_i$3[ebp], eax
$LN7@ScaleClipR:
  0006f	8b 45 e0	 mov	 eax, DWORD PTR _cmd_list$4[ebp]
  00072	8b 4d d4	 mov	 ecx, DWORD PTR _cmd_i$3[ebp]
  00075	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00077	0f 8d 91 00 00
	00		 jge	 $LN6@ScaleClipR

; 1392 :         {
; 1393 :             ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];

  0007d	8b 45 d4	 mov	 eax, DWORD PTR _cmd_i$3[ebp]
  00080	50		 push	 eax
  00081	8b 4d e0	 mov	 ecx, DWORD PTR _cmd_list$4[ebp]
  00084	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  00089	89 45 c8	 mov	 DWORD PTR _cmd$2[ebp], eax

; 1394 :             cmd->ClipRect = ImVec4(cmd->ClipRect.x * fb_scale.x, cmd->ClipRect.y * fb_scale.y, cmd->ClipRect.z * fb_scale.x, cmd->ClipRect.w * fb_scale.y);

  0008c	8b 45 c8	 mov	 eax, DWORD PTR _cmd$2[ebp]
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _fb_scale$[ebp]
  00092	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00097	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [ecx+4]
  0009c	51		 push	 ecx
  0009d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a2	8b 55 c8	 mov	 edx, DWORD PTR _cmd$2[ebp]
  000a5	8b 45 08	 mov	 eax, DWORD PTR _fb_scale$[ebp]
  000a8	f3 0f 10 42 0c	 movss	 xmm0, DWORD PTR [edx+12]
  000ad	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  000b1	51		 push	 ecx
  000b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b7	8b 4d c8	 mov	 ecx, DWORD PTR _cmd$2[ebp]
  000ba	8b 55 08	 mov	 edx, DWORD PTR _fb_scale$[ebp]
  000bd	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  000c2	f3 0f 59 42 04	 mulss	 xmm0, DWORD PTR [edx+4]
  000c7	51		 push	 ecx
  000c8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cd	8b 45 c8	 mov	 eax, DWORD PTR _cmd$2[ebp]
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _fb_scale$[ebp]
  000d3	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000d8	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  000dc	51		 push	 ecx
  000dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e2	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000e8	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  000ed	8b 55 c8	 mov	 edx, DWORD PTR _cmd$2[ebp]
  000f0	83 c2 04	 add	 edx, 4
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	89 0a		 mov	 DWORD PTR [edx], ecx
  000f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fa	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000fd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00100	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00103	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00106	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 1395 :         }

  00109	e9 58 ff ff ff	 jmp	 $LN5@ScaleClipR
$LN6@ScaleClipR:

; 1396 :     }

  0010e	e9 23 ff ff ff	 jmp	 $LN2@ScaleClipR
$LN3@ScaleClipR:

; 1397 : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  0011c	3b ec		 cmp	 ebp, esp
  0011e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 04 00	 ret	 4
?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z ENDP	; ImDrawData::ScaleClipRects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?DeIndexAllBuffers@ImDrawData@@QAEXXZ
_TEXT	SEGMENT
_j$2 = -80						; size = 4
_cmd_list$3 = -68					; size = 4
_i$4 = -56						; size = 4
_new_vtx_buffer$ = -44					; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?DeIndexAllBuffers@ImDrawData@@QAEXXZ PROC		; ImDrawData::DeIndexAllBuffers, COMDAT
; _this$ = ecx

; 1366 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DeIndexAllBuffers@ImDrawData@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00021	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1367 :     ImVector<ImDrawVert> new_vtx_buffer;

  0004f	8d 4d d4	 lea	 ecx, DWORD PTR _new_vtx_buffer$[ebp]
  00052	e8 00 00 00 00	 call	 ??0?$ImVector@UImDrawVert@@@@QAE@XZ ; ImVector<ImDrawVert>::ImVector<ImDrawVert>
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1368 :     TotalVtxCount = TotalIdxCount = 0;

  0005e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00068	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1369 :     for (int i = 0; i < CmdListsCount; i++)

  00072	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00079	eb 09		 jmp	 SHORT $LN4@DeIndexAll
$LN2@DeIndexAll:
  0007b	8b 45 c8	 mov	 eax, DWORD PTR _i$4[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 c8	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@DeIndexAll:
  00084	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 4d c8	 mov	 ecx, DWORD PTR _i$4[ebp]
  0008a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008d	0f 8d cc 00 00
	00		 jge	 $LN3@DeIndexAll

; 1370 :     {
; 1371 :         ImDrawList* cmd_list = CmdLists[i];

  00093	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00096	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00099	8b 55 c8	 mov	 edx, DWORD PTR _i$4[ebp]
  0009c	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0009f	89 45 bc	 mov	 DWORD PTR _cmd_list$3[ebp], eax

; 1372 :         if (cmd_list->IdxBuffer.empty())

  000a2	8b 4d bc	 mov	 ecx, DWORD PTR _cmd_list$3[ebp]
  000a5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000a8	e8 00 00 00 00	 call	 ?empty@?$ImVector@G@@QBE_NXZ ; ImVector<unsigned short>::empty
  000ad	0f b6 c0	 movzx	 eax, al
  000b0	85 c0		 test	 eax, eax
  000b2	74 02		 je	 SHORT $LN8@DeIndexAll

; 1373 :             continue;

  000b4	eb c5		 jmp	 SHORT $LN2@DeIndexAll
$LN8@DeIndexAll:

; 1374 :         new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);

  000b6	8b 45 bc	 mov	 eax, DWORD PTR _cmd_list$3[ebp]
  000b9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000bc	51		 push	 ecx
  000bd	8d 4d d4	 lea	 ecx, DWORD PTR _new_vtx_buffer$[ebp]
  000c0	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize

; 1375 :         for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)

  000c5	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _j$2[ebp], 0
  000cc	eb 09		 jmp	 SHORT $LN7@DeIndexAll
$LN5@DeIndexAll:
  000ce	8b 45 b0	 mov	 eax, DWORD PTR _j$2[ebp]
  000d1	83 c0 01	 add	 eax, 1
  000d4	89 45 b0	 mov	 DWORD PTR _j$2[ebp], eax
$LN7@DeIndexAll:
  000d7	8b 45 bc	 mov	 eax, DWORD PTR _cmd_list$3[ebp]
  000da	8b 4d b0	 mov	 ecx, DWORD PTR _j$2[ebp]
  000dd	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000e0	7d 4a		 jge	 SHORT $LN6@DeIndexAll

; 1376 :             new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];

  000e2	8b 45 b0	 mov	 eax, DWORD PTR _j$2[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d bc	 mov	 ecx, DWORD PTR _cmd_list$3[ebp]
  000e9	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000ec	e8 00 00 00 00	 call	 ??A?$ImVector@G@@QAEAAGH@Z ; ImVector<unsigned short>::operator[]
  000f1	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000f4	51		 push	 ecx
  000f5	8b 4d bc	 mov	 ecx, DWORD PTR _cmd_list$3[ebp]
  000f8	83 c1 18	 add	 ecx, 24			; 00000018H
  000fb	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
  00100	8b f0		 mov	 esi, eax
  00102	8b 55 b0	 mov	 edx, DWORD PTR _j$2[ebp]
  00105	52		 push	 edx
  00106	8d 4d d4	 lea	 ecx, DWORD PTR _new_vtx_buffer$[ebp]
  00109	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
  0010e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00110	89 08		 mov	 DWORD PTR [eax], ecx
  00112	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00115	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00118	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0011b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0011e	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00121	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00124	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00127	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0012a	eb a2		 jmp	 SHORT $LN5@DeIndexAll
$LN6@DeIndexAll:

; 1377 :         cmd_list->VtxBuffer.swap(new_vtx_buffer);

  0012c	8d 45 d4	 lea	 eax, DWORD PTR _new_vtx_buffer$[ebp]
  0012f	50		 push	 eax
  00130	8b 4d bc	 mov	 ecx, DWORD PTR _cmd_list$3[ebp]
  00133	83 c1 18	 add	 ecx, 24			; 00000018H
  00136	e8 00 00 00 00	 call	 ?swap@?$ImVector@UImDrawVert@@@@QAEXAAU1@@Z ; ImVector<ImDrawVert>::swap

; 1378 :         cmd_list->IdxBuffer.resize(0);

  0013b	6a 00		 push	 0
  0013d	8b 4d bc	 mov	 ecx, DWORD PTR _cmd_list$3[ebp]
  00140	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00143	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize

; 1379 :         TotalVtxCount += cmd_list->VtxBuffer.Size;

  00148	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0014e	8b 55 bc	 mov	 edx, DWORD PTR _cmd_list$3[ebp]
  00151	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00154	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00157	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1380 :     }

  0015a	e9 1c ff ff ff	 jmp	 $LN2@DeIndexAll
$LN3@DeIndexAll:

; 1381 : }

  0015f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00166	8d 4d d4	 lea	 ecx, DWORD PTR _new_vtx_buffer$[ebp]
  00169	e8 00 00 00 00	 call	 ??1?$ImVector@UImDrawVert@@@@QAE@XZ ; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
  0016e	52		 push	 edx
  0016f	8b cd		 mov	 ecx, ebp
  00171	50		 push	 eax
  00172	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@DeIndexAll
  00178	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0017d	58		 pop	 eax
  0017e	5a		 pop	 edx
  0017f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00182	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00189	59		 pop	 ecx
  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx
  0018d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00190	33 cd		 xor	 ecx, ebp
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  0019d	3b ec		 cmp	 ebp, esp
  0019f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN14@DeIndexAll:
  001a8	01 00 00 00	 DD	 1
  001ac	00 00 00 00	 DD	 $LN13@DeIndexAll
$LN13@DeIndexAll:
  001b0	d4 ff ff ff	 DD	 -44			; ffffffd4H
  001b4	0c 00 00 00	 DD	 12			; 0000000cH
  001b8	00 00 00 00	 DD	 $LN11@DeIndexAll
$LN11@DeIndexAll:
  001bc	6e		 DB	 110			; 0000006eH
  001bd	65		 DB	 101			; 00000065H
  001be	77		 DB	 119			; 00000077H
  001bf	5f		 DB	 95			; 0000005fH
  001c0	76		 DB	 118			; 00000076H
  001c1	74		 DB	 116			; 00000074H
  001c2	78		 DB	 120			; 00000078H
  001c3	5f		 DB	 95			; 0000005fH
  001c4	62		 DB	 98			; 00000062H
  001c5	75		 DB	 117			; 00000075H
  001c6	66		 DB	 102			; 00000066H
  001c7	66		 DB	 102			; 00000066H
  001c8	65		 DB	 101			; 00000065H
  001c9	72		 DB	 114			; 00000072H
  001ca	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeIndexAllBuffers@ImDrawData@@QAEXXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _new_vtx_buffer$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImDrawVert@@@@QAE@XZ ; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?DeIndexAllBuffers@ImDrawData@@QAEXXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a e8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-280]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DeIndexAllBuffers@ImDrawData@@QAEXXZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DeIndexAllBuffers@ImDrawData@@QAEXXZ ENDP		; ImDrawData::DeIndexAllBuffers
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?UpdateTextureID@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
tv148 = -256						; size = 4
tv95 = -256						; size = 4
tv82 = -256						; size = 4
tv75 = -256						; size = 4
$T1 = -248						; size = 4
_prev_cmd$ = -44					; size = 4
_curr_cmd$ = -32					; size = 4
_curr_texture_id$ = -20					; size = 4
_this$ = -8						; size = 4
?UpdateTextureID@ImDrawList@@QAEXXZ PROC		; ImDrawList::UpdateTextureID, COMDAT
; _this$ = ecx

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00013	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 455  :     // If current command is used with different settings we need to add a new command
; 456  :     const ImTextureID curr_texture_id = GetCurrentTextureId();

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00034	74 18		 je	 SHORT $LN8@UpdateText
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00042	8b 54 91 fc	 mov	 edx, DWORD PTR [ecx+edx*4-4]
  00046	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], edx
  0004c	eb 0a		 jmp	 SHORT $LN9@UpdateText
$LN8@UpdateText:
  0004e	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv75[ebp], 0
$LN9@UpdateText:
  00058	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]
  0005e	89 45 ec	 mov	 DWORD PTR _curr_texture_id$[ebp], eax

; 457  :     ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 38 00	 cmp	 DWORD PTR [eax], 0
  00067	74 10		 je	 SHORT $LN10@UpdateText
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  00071	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  00077	eb 0a		 jmp	 SHORT $LN11@UpdateText
$LN10@UpdateText:
  00079	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv82[ebp], 0
$LN11@UpdateText:
  00083	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv82[ebp]
  00089	89 4d e0	 mov	 DWORD PTR _curr_cmd$[ebp], ecx

; 458  :     if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)

  0008c	83 7d e0 00	 cmp	 DWORD PTR _curr_cmd$[ebp], 0
  00090	74 1c		 je	 SHORT $LN3@UpdateText
  00092	8b 45 e0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  00095	83 38 00	 cmp	 DWORD PTR [eax], 0
  00098	74 0b		 je	 SHORT $LN4@UpdateText
  0009a	8b 45 e0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  0009d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000a0	3b 4d ec	 cmp	 ecx, DWORD PTR _curr_texture_id$[ebp]
  000a3	75 09		 jne	 SHORT $LN3@UpdateText
$LN4@UpdateText:
  000a5	8b 45 e0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  000a8	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000ac	74 0d		 je	 SHORT $LN2@UpdateText
$LN3@UpdateText:

; 459  :     {
; 460  :         AddDrawCmd();

  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QAEXXZ ; ImDrawList::AddDrawCmd

; 461  :         return;

  000b6	e9 b8 00 00 00	 jmp	 $LN1@UpdateText
$LN2@UpdateText:

; 462  :     }
; 463  : 
; 464  :     // Try to merge with previous command if it matches, else use current command
; 465  :     ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000be	83 38 01	 cmp	 DWORD PTR [eax], 1
  000c1	7e 0e		 jle	 SHORT $LN12@UpdateText
  000c3	8b 4d e0	 mov	 ecx, DWORD PTR _curr_cmd$[ebp]
  000c6	83 e9 28	 sub	 ecx, 40			; 00000028H
  000c9	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  000cf	eb 0a		 jmp	 SHORT $LN13@UpdateText
$LN12@UpdateText:
  000d1	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv95[ebp], 0
$LN13@UpdateText:
  000db	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv95[ebp]
  000e1	89 55 d4	 mov	 DWORD PTR _prev_cmd$[ebp], edx

; 466  :     if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)

  000e4	8b 45 e0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  000e7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ea	75 7e		 jne	 SHORT $LN5@UpdateText
  000ec	83 7d d4 00	 cmp	 DWORD PTR _prev_cmd$[ebp], 0
  000f0	74 78		 je	 SHORT $LN5@UpdateText
  000f2	8b 45 d4	 mov	 eax, DWORD PTR _prev_cmd$[ebp]
  000f5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000f8	3b 4d ec	 cmp	 ecx, DWORD PTR _curr_texture_id$[ebp]
  000fb	75 6d		 jne	 SHORT $LN5@UpdateText
  000fd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00100	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00104	74 1a		 je	 SHORT $LN14@UpdateText
  00106	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0010c	83 ea 01	 sub	 edx, 1
  0010f	c1 e2 04	 shl	 edx, 4
  00112	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	03 50 48	 add	 edx, DWORD PTR [eax+72]
  00118	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv148[ebp], edx
  0011e	eb 0f		 jmp	 SHORT $LN15@UpdateText
$LN14@UpdateText:
  00120	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00126	83 c2 14	 add	 edx, 20			; 00000014H
  00129	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv148[ebp], edx
$LN15@UpdateText:
  0012f	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  00135	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0013b	6a 10		 push	 16			; 00000010H
  0013d	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00143	51		 push	 ecx
  00144	8b 55 d4	 mov	 edx, DWORD PTR _prev_cmd$[ebp]
  00147	83 c2 04	 add	 edx, 4
  0014a	52		 push	 edx
  0014b	e8 00 00 00 00	 call	 _memcmp
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH
  00153	85 c0		 test	 eax, eax
  00155	75 13		 jne	 SHORT $LN5@UpdateText
  00157	8b 45 d4	 mov	 eax, DWORD PTR _prev_cmd$[ebp]
  0015a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0015e	75 0a		 jne	 SHORT $LN5@UpdateText

; 467  :         CmdBuffer.pop_back();

  00160	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00163	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ ; ImVector<ImDrawCmd>::pop_back
  00168	eb 09		 jmp	 SHORT $LN1@UpdateText
$LN5@UpdateText:

; 468  :     else
; 469  :         curr_cmd->TextureId = curr_texture_id;

  0016a	8b 45 e0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  0016d	8b 4d ec	 mov	 ecx, DWORD PTR _curr_texture_id$[ebp]
  00170	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@UpdateText:

; 470  : }

  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx
  00176	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  0017c	3b ec		 cmp	 ebp, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
?UpdateTextureID@ImDrawList@@QAEXXZ ENDP		; ImDrawList::UpdateTextureID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?UpdateClipRect@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
tv161 = -272						; size = 4
tv139 = -272						; size = 4
tv90 = -272						; size = 4
tv77 = -272						; size = 4
$T1 = -264						; size = 4
_prev_cmd$ = -60					; size = 4
_curr_cmd$ = -48					; size = 4
_curr_clip_rect$ = -36					; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?UpdateClipRect@ImDrawList@@QAEXXZ PROC			; ImDrawList::UpdateClipRect, COMDAT
; _this$ = ecx

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00013	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 436  :     // If current command is used with different settings we need to add a new command
; 437  :     const ImVec4 curr_clip_rect = GetCurrentClipRect();

  00037	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  0003e	74 1a		 je	 SHORT $LN8@UpdateClip
  00040	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00046	83 ea 01	 sub	 edx, 1
  00049	c1 e2 04	 shl	 edx, 4
  0004c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	03 50 48	 add	 edx, DWORD PTR [eax+72]
  00052	89 95 f0 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], edx
  00058	eb 0f		 jmp	 SHORT $LN9@UpdateClip
$LN8@UpdateClip:
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00060	83 c2 14	 add	 edx, 20			; 00000014H
  00063	89 95 f0 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], edx
$LN9@UpdateClip:
  00069	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  0006f	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00075	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0007b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007d	89 55 dc	 mov	 DWORD PTR _curr_clip_rect$[ebp], edx
  00080	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00083	89 45 e0	 mov	 DWORD PTR _curr_clip_rect$[ebp+4], eax
  00086	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00089	89 55 e4	 mov	 DWORD PTR _curr_clip_rect$[ebp+8], edx
  0008c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0008f	89 45 e8	 mov	 DWORD PTR _curr_clip_rect$[ebp+12], eax

; 438  :     ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;

  00092	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 38 00	 cmp	 DWORD PTR [eax], 0
  00098	7e 19		 jle	 SHORT $LN10@UpdateClip
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009f	83 ea 01	 sub	 edx, 1
  000a2	6b c2 28	 imul	 eax, edx, 40
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  000ab	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  000b1	eb 0a		 jmp	 SHORT $LN11@UpdateClip
$LN10@UpdateClip:
  000b3	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
$LN11@UpdateClip:
  000bd	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  000c3	89 55 d0	 mov	 DWORD PTR _curr_cmd$[ebp], edx

; 439  :     if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)

  000c6	83 7d d0 00	 cmp	 DWORD PTR _curr_cmd$[ebp], 0
  000ca	74 2a		 je	 SHORT $LN3@UpdateClip
  000cc	8b 45 d0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  000cf	83 38 00	 cmp	 DWORD PTR [eax], 0
  000d2	74 19		 je	 SHORT $LN4@UpdateClip
  000d4	6a 10		 push	 16			; 00000010H
  000d6	8d 45 dc	 lea	 eax, DWORD PTR _curr_clip_rect$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d d0	 mov	 ecx, DWORD PTR _curr_cmd$[ebp]
  000dd	83 c1 04	 add	 ecx, 4
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 _memcmp
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	85 c0		 test	 eax, eax
  000eb	75 09		 jne	 SHORT $LN3@UpdateClip
$LN4@UpdateClip:
  000ed	8b 45 d0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  000f0	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000f4	74 0d		 je	 SHORT $LN2@UpdateClip
$LN3@UpdateClip:

; 440  :     {
; 441  :         AddDrawCmd();

  000f6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QAEXXZ ; ImDrawList::AddDrawCmd

; 442  :         return;

  000fe	e9 b9 00 00 00	 jmp	 $LN1@UpdateClip
$LN2@UpdateClip:

; 443  :     }
; 444  : 
; 445  :     // Try to merge with previous command if it matches, else use current command
; 446  :     ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;

  00103	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00106	83 38 01	 cmp	 DWORD PTR [eax], 1
  00109	7e 0e		 jle	 SHORT $LN12@UpdateClip
  0010b	8b 4d d0	 mov	 ecx, DWORD PTR _curr_cmd$[ebp]
  0010e	83 e9 28	 sub	 ecx, 40			; 00000028H
  00111	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv139[ebp], ecx
  00117	eb 0a		 jmp	 SHORT $LN13@UpdateClip
$LN12@UpdateClip:
  00119	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv139[ebp], 0
$LN13@UpdateClip:
  00123	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv139[ebp]
  00129	89 55 c4	 mov	 DWORD PTR _prev_cmd$[ebp], edx

; 447  :     if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)

  0012c	8b 45 d0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  0012f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00132	75 6b		 jne	 SHORT $LN5@UpdateClip
  00134	83 7d c4 00	 cmp	 DWORD PTR _prev_cmd$[ebp], 0
  00138	74 65		 je	 SHORT $LN5@UpdateClip
  0013a	6a 10		 push	 16			; 00000010H
  0013c	8d 45 dc	 lea	 eax, DWORD PTR _curr_clip_rect$[ebp]
  0013f	50		 push	 eax
  00140	8b 4d c4	 mov	 ecx, DWORD PTR _prev_cmd$[ebp]
  00143	83 c1 04	 add	 ecx, 4
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 _memcmp
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014f	85 c0		 test	 eax, eax
  00151	75 4c		 jne	 SHORT $LN5@UpdateClip
  00153	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00156	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0015a	74 18		 je	 SHORT $LN14@UpdateClip
  0015c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00162	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00165	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00168	8b 54 91 fc	 mov	 edx, DWORD PTR [ecx+edx*4-4]
  0016c	89 95 f0 fe ff
	ff		 mov	 DWORD PTR tv161[ebp], edx
  00172	eb 0a		 jmp	 SHORT $LN15@UpdateClip
$LN14@UpdateClip:
  00174	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
$LN15@UpdateClip:
  0017e	8b 45 c4	 mov	 eax, DWORD PTR _prev_cmd$[ebp]
  00181	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00184	3b 8d f0 fe ff
	ff		 cmp	 ecx, DWORD PTR tv161[ebp]
  0018a	75 13		 jne	 SHORT $LN5@UpdateClip
  0018c	8b 45 c4	 mov	 eax, DWORD PTR _prev_cmd$[ebp]
  0018f	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00193	75 0a		 jne	 SHORT $LN5@UpdateClip

; 448  :         CmdBuffer.pop_back();

  00195	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ ; ImVector<ImDrawCmd>::pop_back
  0019d	eb 1d		 jmp	 SHORT $LN1@UpdateClip
$LN5@UpdateClip:

; 449  :     else
; 450  :         curr_cmd->ClipRect = curr_clip_rect;

  0019f	8b 45 d0	 mov	 eax, DWORD PTR _curr_cmd$[ebp]
  001a2	83 c0 04	 add	 eax, 4
  001a5	8b 4d dc	 mov	 ecx, DWORD PTR _curr_clip_rect$[ebp]
  001a8	89 08		 mov	 DWORD PTR [eax], ecx
  001aa	8b 55 e0	 mov	 edx, DWORD PTR _curr_clip_rect$[ebp+4]
  001ad	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001b0	8b 4d e4	 mov	 ecx, DWORD PTR _curr_clip_rect$[ebp+8]
  001b3	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001b6	8b 55 e8	 mov	 edx, DWORD PTR _curr_clip_rect$[ebp+12]
  001b9	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN1@UpdateClip:

; 451  : }

  001bc	52		 push	 edx
  001bd	8b cd		 mov	 ecx, ebp
  001bf	50		 push	 eax
  001c0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@UpdateClip
  001c6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001cb	58		 pop	 eax
  001cc	5a		 pop	 edx
  001cd	5f		 pop	 edi
  001ce	5e		 pop	 esi
  001cf	5b		 pop	 ebx
  001d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d3	33 cd		 xor	 ecx, ebp
  001d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001da	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  001e0	3b ec		 cmp	 ebp, esp
  001e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
  001eb	90		 npad	 1
$LN18@UpdateClip:
  001ec	01 00 00 00	 DD	 1
  001f0	00 00 00 00	 DD	 $LN17@UpdateClip
$LN17@UpdateClip:
  001f4	dc ff ff ff	 DD	 -36			; ffffffdcH
  001f8	10 00 00 00	 DD	 16			; 00000010H
  001fc	00 00 00 00	 DD	 $LN16@UpdateClip
$LN16@UpdateClip:
  00200	63		 DB	 99			; 00000063H
  00201	75		 DB	 117			; 00000075H
  00202	72		 DB	 114			; 00000072H
  00203	72		 DB	 114			; 00000072H
  00204	5f		 DB	 95			; 0000005fH
  00205	63		 DB	 99			; 00000063H
  00206	6c		 DB	 108			; 0000006cH
  00207	69		 DB	 105			; 00000069H
  00208	70		 DB	 112			; 00000070H
  00209	5f		 DB	 95			; 0000005fH
  0020a	72		 DB	 114			; 00000072H
  0020b	65		 DB	 101			; 00000065H
  0020c	63		 DB	 99			; 00000063H
  0020d	74		 DB	 116			; 00000074H
  0020e	00		 DB	 0
?UpdateClipRect@ImDrawList@@QAEXXZ ENDP			; ImDrawList::UpdateClipRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PrimWriteIdx@ImDrawList@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_idx$ = 8						; size = 2
?PrimWriteIdx@ImDrawList@@QAEXG@Z PROC			; ImDrawList::PrimWriteIdx, COMDAT
; _this$ = ecx

; 1987 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00033	66 8b 55 08	 mov	 dx, WORD PTR _idx$[ebp]
  00037	66 89 11	 mov	 WORD PTR [ecx], dx
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00040	83 c1 02	 add	 ecx, 2
  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?PrimWriteIdx@ImDrawList@@QAEXG@Z ENDP			; ImDrawList::PrimWriteIdx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
_uv$ = 12						; size = 4
_col$ = 16						; size = 4
?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z PROC	; ImDrawList::PrimWriteVtx, COMDAT
; _this$ = ecx

; 1986 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0003b	89 08		 mov	 DWORD PTR [eax], ecx
  0003d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00040	8b 45 0c	 mov	 eax, DWORD PTR _uv$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0004e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00051	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005a	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  0005d	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00066	83 c1 14	 add	 ecx, 20			; 00000014H
  00069	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00075	83 c1 01	 add	 ecx, 1
  00078	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	89 4a 34	 mov	 DWORD PTR [edx+52], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 0c 00	 ret	 12			; 0000000cH
?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ENDP	; ImDrawList::PrimWriteVtx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z
_TEXT	SEGMENT
_idx$ = -20						; size = 2
_this$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_uv_a$ = 24						; size = 4
_uv_b$ = 28						; size = 4
_uv_c$ = 32						; size = 4
_uv_d$ = 36						; size = 4
_col$ = 40						; size = 4
?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z PROC	; ImDrawList::PrimQuadUV, COMDAT
; _this$ = ecx

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 589  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	66 8b 48 34	 mov	 cx, WORD PTR [eax+52]
  00034	66 89 4d ec	 mov	 WORD PTR _idx$[ebp], cx

; 590  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

  00038	b8 02 00 00 00	 mov	 eax, 2
  0003d	6b c8 00	 imul	 ecx, eax, 0
  00040	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00046	66 8b 55 ec	 mov	 dx, WORD PTR _idx$[ebp]
  0004a	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  0004e	0f b7 45 ec	 movzx	 eax, WORD PTR _idx$[ebp]
  00052	83 c0 01	 add	 eax, 1
  00055	b9 02 00 00 00	 mov	 ecx, 2
  0005a	c1 e1 00	 shl	 ecx, 0
  0005d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  00063	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  00067	0f b7 45 ec	 movzx	 eax, WORD PTR _idx$[ebp]
  0006b	83 c0 02	 add	 eax, 2
  0006e	b9 02 00 00 00	 mov	 ecx, 2
  00073	d1 e1		 shl	 ecx, 1
  00075	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00078	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  0007b	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 591  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

  0007f	b8 02 00 00 00	 mov	 eax, 2
  00084	6b c8 03	 imul	 ecx, eax, 3
  00087	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0008d	66 8b 55 ec	 mov	 dx, WORD PTR _idx$[ebp]
  00091	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00095	0f b7 45 ec	 movzx	 eax, WORD PTR _idx$[ebp]
  00099	83 c0 02	 add	 eax, 2
  0009c	b9 02 00 00 00	 mov	 ecx, 2
  000a1	c1 e1 02	 shl	 ecx, 2
  000a4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a7	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  000aa	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  000ae	0f b7 45 ec	 movzx	 eax, WORD PTR _idx$[ebp]
  000b2	83 c0 03	 add	 eax, 3
  000b5	b9 02 00 00 00	 mov	 ecx, 2
  000ba	6b d1 05	 imul	 edx, ecx, 5
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  000c3	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 592  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000cf	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  000d4	6b c0 00	 imul	 eax, eax, 0
  000d7	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  000da	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  000dd	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  000e0	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  000e4	8b 45 18	 mov	 eax, DWORD PTR _uv_a$[ebp]
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ec	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  000f1	6b c0 00	 imul	 eax, eax, 0
  000f4	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  000f7	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  000fa	89 4c 06 08	 mov	 DWORD PTR [esi+eax+8], ecx
  000fe	89 54 06 0c	 mov	 DWORD PTR [esi+eax+12], edx
  00102	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00107	6b c8 00	 imul	 ecx, eax, 0
  0010a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010d	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00110	8b 55 28	 mov	 edx, DWORD PTR _col$[ebp]
  00113	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 593  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;

  00117	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0011a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0011f	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00124	c1 e0 00	 shl	 eax, 0
  00127	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0012a	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0012d	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00130	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  00134	8b 45 1c	 mov	 eax, DWORD PTR _uv_b$[ebp]
  00137	8b 08		 mov	 ecx, DWORD PTR [eax]
  00139	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0013c	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00141	c1 e0 00	 shl	 eax, 0
  00144	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00147	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0014a	89 4c 06 08	 mov	 DWORD PTR [esi+eax+8], ecx
  0014e	89 54 06 0c	 mov	 DWORD PTR [esi+eax+12], edx
  00152	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00157	c1 e0 00	 shl	 eax, 0
  0015a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00160	8b 4d 28	 mov	 ecx, DWORD PTR _col$[ebp]
  00163	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 594  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

  00167	8b 45 10	 mov	 eax, DWORD PTR _c$[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0016f	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00174	d1 e0		 shl	 eax, 1
  00176	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00179	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0017c	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  0017f	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  00183	8b 45 20	 mov	 eax, DWORD PTR _uv_c$[ebp]
  00186	8b 08		 mov	 ecx, DWORD PTR [eax]
  00188	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0018b	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00190	d1 e0		 shl	 eax, 1
  00192	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00195	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  00198	89 4c 06 08	 mov	 DWORD PTR [esi+eax+8], ecx
  0019c	89 54 06 0c	 mov	 DWORD PTR [esi+eax+12], edx
  001a0	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001a5	d1 e0		 shl	 eax, 1
  001a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001aa	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001ad	8b 4d 28	 mov	 ecx, DWORD PTR _col$[ebp]
  001b0	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 595  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

  001b4	8b 45 14	 mov	 eax, DWORD PTR _d$[ebp]
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001c1	6b c0 03	 imul	 eax, eax, 3
  001c4	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  001c7	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  001ca	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  001cd	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  001d1	8b 45 24	 mov	 eax, DWORD PTR _uv_d$[ebp]
  001d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001d9	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001de	6b c0 03	 imul	 eax, eax, 3
  001e1	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  001e4	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  001e7	89 4c 06 08	 mov	 DWORD PTR [esi+eax+8], ecx
  001eb	89 54 06 0c	 mov	 DWORD PTR [esi+eax+12], edx
  001ef	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001f4	6b c8 03	 imul	 ecx, eax, 3
  001f7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001fa	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  001fd	8b 55 28	 mov	 edx, DWORD PTR _col$[ebp]
  00200	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 596  :     _VtxWritePtr += 4;

  00204	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00207	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0020a	83 c1 50	 add	 ecx, 80			; 00000050H
  0020d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00210	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 597  :     _VtxCurrentIdx += 4;

  00213	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00216	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00219	83 c1 04	 add	 ecx, 4
  0021c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0021f	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 598  :     _IdxWritePtr += 6;

  00222	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00225	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00228	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0022b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0022e	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 599  : }

  00231	5f		 pop	 edi
  00232	5e		 pop	 esi
  00233	5b		 pop	 ebx
  00234	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0023a	3b ec		 cmp	 ebp, esp
  0023c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00241	8b e5		 mov	 esp, ebp
  00243	5d		 pop	 ebp
  00244	c2 24 00	 ret	 36			; 00000024H
?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z ENDP	; ImDrawList::PrimQuadUV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z
_TEXT	SEGMENT
_idx$ = -88						; size = 2
_uv_d$ = -76						; size = 8
_uv_b$ = -60						; size = 8
_d$ = -44						; size = 8
_b$ = -28						; size = 8
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_c$ = 12						; size = 4
_uv_a$ = 16						; size = 4
_uv_c$ = 20						; size = 4
_col$ = 24						; size = 4
?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z PROC	; ImDrawList::PrimRectUV, COMDAT
; _this$ = ecx

; 573  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd e4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-284]
  00013	b9 47 00 00 00	 mov	 ecx, 71			; 00000047H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 574  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);

  00037	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0003a	51		 push	 ecx
  0003b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00040	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  00048	51		 push	 ecx
  00049	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8d 4d e4	 lea	 ecx, DWORD PTR _b$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0005d	51		 push	 ecx
  0005e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0006b	51		 push	 ecx
  0006c	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00070	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00075	8d 4d d4	 lea	 ecx, DWORD PTR _d$[ebp]
  00078	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0007d	8b 45 10	 mov	 eax, DWORD PTR _uv_a$[ebp]
  00080	51		 push	 ecx
  00081	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00086	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008b	8b 4d 14	 mov	 ecx, DWORD PTR _uv_c$[ebp]
  0008e	51		 push	 ecx
  0008f	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00093	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00098	8d 4d c4	 lea	 ecx, DWORD PTR _uv_b$[ebp]
  0009b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000a0	8b 45 14	 mov	 eax, DWORD PTR _uv_c$[ebp]
  000a3	51		 push	 ecx
  000a4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ae	8b 4d 10	 mov	 ecx, DWORD PTR _uv_a$[ebp]
  000b1	51		 push	 ecx
  000b2	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	8d 4d b4	 lea	 ecx, DWORD PTR _uv_d$[ebp]
  000be	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2

; 575  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	66 8b 48 34	 mov	 cx, WORD PTR [eax+52]
  000ca	66 89 4d a8	 mov	 WORD PTR _idx$[ebp], cx

; 576  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

  000ce	b8 02 00 00 00	 mov	 eax, 2
  000d3	6b c8 00	 imul	 ecx, eax, 0
  000d6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000d9	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000dc	66 8b 55 a8	 mov	 dx, WORD PTR _idx$[ebp]
  000e0	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  000e4	0f b7 45 a8	 movzx	 eax, WORD PTR _idx$[ebp]
  000e8	83 c0 01	 add	 eax, 1
  000eb	b9 02 00 00 00	 mov	 ecx, 2
  000f0	c1 e1 00	 shl	 ecx, 0
  000f3	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000f6	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  000f9	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  000fd	0f b7 45 a8	 movzx	 eax, WORD PTR _idx$[ebp]
  00101	83 c0 02	 add	 eax, 2
  00104	b9 02 00 00 00	 mov	 ecx, 2
  00109	d1 e1		 shl	 ecx, 1
  0010b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0010e	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  00111	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 577  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

  00115	b8 02 00 00 00	 mov	 eax, 2
  0011a	6b c8 03	 imul	 ecx, eax, 3
  0011d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00120	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00123	66 8b 55 a8	 mov	 dx, WORD PTR _idx$[ebp]
  00127	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  0012b	0f b7 45 a8	 movzx	 eax, WORD PTR _idx$[ebp]
  0012f	83 c0 02	 add	 eax, 2
  00132	b9 02 00 00 00	 mov	 ecx, 2
  00137	c1 e1 02	 shl	 ecx, 2
  0013a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0013d	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  00140	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  00144	0f b7 45 a8	 movzx	 eax, WORD PTR _idx$[ebp]
  00148	83 c0 03	 add	 eax, 3
  0014b	b9 02 00 00 00	 mov	 ecx, 2
  00150	6b d1 05	 imul	 edx, ecx, 5
  00153	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00159	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 578  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

  0015d	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00160	8b 08		 mov	 ecx, DWORD PTR [eax]
  00162	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00165	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0016a	6b c0 00	 imul	 eax, eax, 0
  0016d	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  00170	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  00173	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00176	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  0017a	8b 45 10	 mov	 eax, DWORD PTR _uv_a$[ebp]
  0017d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00182	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00187	6b c0 00	 imul	 eax, eax, 0
  0018a	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  0018d	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  00190	89 4c 06 08	 mov	 DWORD PTR [esi+eax+8], ecx
  00194	89 54 06 0c	 mov	 DWORD PTR [esi+eax+12], edx
  00198	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0019d	6b c8 00	 imul	 ecx, eax, 0
  001a0	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001a3	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  001a6	8b 55 18	 mov	 edx, DWORD PTR _col$[ebp]
  001a9	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 579  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;

  001ad	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001b2	c1 e0 00	 shl	 eax, 0
  001b5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001bb	8b 4d e4	 mov	 ecx, DWORD PTR _b$[ebp]
  001be	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
  001c1	8b 4d e8	 mov	 ecx, DWORD PTR _b$[ebp+4]
  001c4	89 4c 02 04	 mov	 DWORD PTR [edx+eax+4], ecx
  001c8	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001cd	c1 e0 00	 shl	 eax, 0
  001d0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001d6	8b 4d c4	 mov	 ecx, DWORD PTR _uv_b$[ebp]
  001d9	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  001dd	8b 4d c8	 mov	 ecx, DWORD PTR _uv_b$[ebp+4]
  001e0	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  001e4	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001e9	c1 e0 00	 shl	 eax, 0
  001ec	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001f2	8b 4d 18	 mov	 ecx, DWORD PTR _col$[ebp]
  001f5	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 580  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

  001f9	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  001fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fe	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00201	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00206	d1 e0		 shl	 eax, 1
  00208	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  0020b	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0020e	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00211	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  00215	8b 45 14	 mov	 eax, DWORD PTR _uv_c$[ebp]
  00218	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0021d	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00222	d1 e0		 shl	 eax, 1
  00224	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  00227	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0022a	89 4c 06 08	 mov	 DWORD PTR [esi+eax+8], ecx
  0022e	89 54 06 0c	 mov	 DWORD PTR [esi+eax+12], edx
  00232	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00237	d1 e0		 shl	 eax, 1
  00239	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0023f	8b 4d 18	 mov	 ecx, DWORD PTR _col$[ebp]
  00242	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 581  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

  00246	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0024b	6b c8 03	 imul	 ecx, eax, 3
  0024e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00251	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00254	8b 55 d4	 mov	 edx, DWORD PTR _d$[ebp]
  00257	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
  0025a	8b 55 d8	 mov	 edx, DWORD PTR _d$[ebp+4]
  0025d	89 54 08 04	 mov	 DWORD PTR [eax+ecx+4], edx
  00261	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00266	6b c8 03	 imul	 ecx, eax, 3
  00269	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0026c	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0026f	8b 55 b4	 mov	 edx, DWORD PTR _uv_d$[ebp]
  00272	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  00276	8b 55 b8	 mov	 edx, DWORD PTR _uv_d$[ebp+4]
  00279	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  0027d	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00282	6b c8 03	 imul	 ecx, eax, 3
  00285	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00288	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0028b	8b 55 18	 mov	 edx, DWORD PTR _col$[ebp]
  0028e	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 582  :     _VtxWritePtr += 4;

  00292	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00295	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00298	83 c1 50	 add	 ecx, 80			; 00000050H
  0029b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0029e	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 583  :     _VtxCurrentIdx += 4;

  002a1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002a4	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  002a7	83 c1 04	 add	 ecx, 4
  002aa	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002ad	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 584  :     _IdxWritePtr += 6;

  002b0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  002b3	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  002b6	83 c1 0c	 add	 ecx, 12			; 0000000cH
  002b9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  002bc	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 585  : }

  002bf	52		 push	 edx
  002c0	8b cd		 mov	 ecx, ebp
  002c2	50		 push	 eax
  002c3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@PrimRectUV
  002c9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002ce	58		 pop	 eax
  002cf	5a		 pop	 edx
  002d0	5f		 pop	 edi
  002d1	5e		 pop	 esi
  002d2	5b		 pop	 ebx
  002d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d6	33 cd		 xor	 ecx, ebp
  002d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002dd	81 c4 1c 01 00
	00		 add	 esp, 284		; 0000011cH
  002e3	3b ec		 cmp	 ebp, esp
  002e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ea	8b e5		 mov	 esp, ebp
  002ec	5d		 pop	 ebp
  002ed	c2 14 00	 ret	 20			; 00000014H
$LN8@PrimRectUV:
  002f0	04 00 00 00	 DD	 4
  002f4	00 00 00 00	 DD	 $LN7@PrimRectUV
$LN7@PrimRectUV:
  002f8	e4 ff ff ff	 DD	 -28			; ffffffe4H
  002fc	08 00 00 00	 DD	 8
  00300	00 00 00 00	 DD	 $LN3@PrimRectUV
  00304	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00308	08 00 00 00	 DD	 8
  0030c	00 00 00 00	 DD	 $LN4@PrimRectUV
  00310	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00314	08 00 00 00	 DD	 8
  00318	00 00 00 00	 DD	 $LN5@PrimRectUV
  0031c	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00320	08 00 00 00	 DD	 8
  00324	00 00 00 00	 DD	 $LN6@PrimRectUV
$LN6@PrimRectUV:
  00328	75		 DB	 117			; 00000075H
  00329	76		 DB	 118			; 00000076H
  0032a	5f		 DB	 95			; 0000005fH
  0032b	64		 DB	 100			; 00000064H
  0032c	00		 DB	 0
$LN5@PrimRectUV:
  0032d	75		 DB	 117			; 00000075H
  0032e	76		 DB	 118			; 00000076H
  0032f	5f		 DB	 95			; 0000005fH
  00330	62		 DB	 98			; 00000062H
  00331	00		 DB	 0
$LN4@PrimRectUV:
  00332	64		 DB	 100			; 00000064H
  00333	00		 DB	 0
$LN3@PrimRectUV:
  00334	62		 DB	 98			; 00000062H
  00335	00		 DB	 0
?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z ENDP	; ImDrawList::PrimRectUV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z
_TEXT	SEGMENT
_idx$ = -72						; size = 2
_uv$ = -60						; size = 8
_d$ = -44						; size = 8
_b$ = -28						; size = 8
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_c$ = 12						; size = 4
_col$ = 16						; size = 4
?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z PROC		; ImDrawList::PrimRect, COMDAT
; _this$ = ecx

; 558  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00013	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 559  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

  00037	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0003a	51		 push	 ecx
  0003b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00040	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _c$[ebp]
  00048	51		 push	 ecx
  00049	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8d 4d e4	 lea	 ecx, DWORD PTR _b$[ebp]
  00055	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0005d	51		 push	 ecx
  0005e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0006b	51		 push	 ecx
  0006c	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00070	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00075	8d 4d d4	 lea	 ecx, DWORD PTR _d$[ebp]
  00078	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0007d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00088	89 55 c4	 mov	 DWORD PTR _uv$[ebp], edx
  0008b	89 45 c8	 mov	 DWORD PTR _uv$[ebp+4], eax

; 560  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

  0008e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00091	66 8b 48 34	 mov	 cx, WORD PTR [eax+52]
  00095	66 89 4d b8	 mov	 WORD PTR _idx$[ebp], cx

; 561  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	6b c8 00	 imul	 ecx, eax, 0
  000a1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000a7	66 8b 55 b8	 mov	 dx, WORD PTR _idx$[ebp]
  000ab	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  000af	0f b7 45 b8	 movzx	 eax, WORD PTR _idx$[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	b9 02 00 00 00	 mov	 ecx, 2
  000bb	c1 e1 00	 shl	 ecx, 0
  000be	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  000c4	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  000c8	0f b7 45 b8	 movzx	 eax, WORD PTR _idx$[ebp]
  000cc	83 c0 02	 add	 eax, 2
  000cf	b9 02 00 00 00	 mov	 ecx, 2
  000d4	d1 e1		 shl	 ecx, 1
  000d6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000d9	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  000dc	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 562  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

  000e0	b8 02 00 00 00	 mov	 eax, 2
  000e5	6b c8 03	 imul	 ecx, eax, 3
  000e8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000ee	66 8b 55 b8	 mov	 dx, WORD PTR _idx$[ebp]
  000f2	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  000f6	0f b7 45 b8	 movzx	 eax, WORD PTR _idx$[ebp]
  000fa	83 c0 02	 add	 eax, 2
  000fd	b9 02 00 00 00	 mov	 ecx, 2
  00102	c1 e1 02	 shl	 ecx, 2
  00105	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00108	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  0010b	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  0010f	0f b7 45 b8	 movzx	 eax, WORD PTR _idx$[ebp]
  00113	83 c0 03	 add	 eax, 3
  00116	b9 02 00 00 00	 mov	 ecx, 2
  0011b	6b d1 05	 imul	 edx, ecx, 5
  0011e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00124	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 563  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

  00128	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0012b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00130	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00135	6b c0 00	 imul	 eax, eax, 0
  00138	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  0013b	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0013e	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00141	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  00145	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0014a	6b c8 00	 imul	 ecx, eax, 0
  0014d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00150	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00153	8b 55 c4	 mov	 edx, DWORD PTR _uv$[ebp]
  00156	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  0015a	8b 55 c8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  0015d	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  00161	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00166	6b c8 00	 imul	 ecx, eax, 0
  00169	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0016c	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0016f	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  00172	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 564  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

  00176	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0017b	c1 e0 00	 shl	 eax, 0
  0017e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00184	8b 4d e4	 mov	 ecx, DWORD PTR _b$[ebp]
  00187	89 0c 02	 mov	 DWORD PTR [edx+eax], ecx
  0018a	8b 4d e8	 mov	 ecx, DWORD PTR _b$[ebp+4]
  0018d	89 4c 02 04	 mov	 DWORD PTR [edx+eax+4], ecx
  00191	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00196	c1 e0 00	 shl	 eax, 0
  00199	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0019f	8b 4d c4	 mov	 ecx, DWORD PTR _uv$[ebp]
  001a2	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  001a6	8b 4d c8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  001a9	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  001ad	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001b2	c1 e0 00	 shl	 eax, 0
  001b5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001bb	8b 4d 10	 mov	 ecx, DWORD PTR _col$[ebp]
  001be	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 565  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

  001c2	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  001c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001ca	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001cf	d1 e0		 shl	 eax, 1
  001d1	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  001d4	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  001d7	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  001da	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx
  001de	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001e3	d1 e0		 shl	 eax, 1
  001e5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  001eb	8b 4d c4	 mov	 ecx, DWORD PTR _uv$[ebp]
  001ee	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  001f2	8b 4d c8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  001f5	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  001f9	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  001fe	d1 e0		 shl	 eax, 1
  00200	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00203	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00206	8b 4d 10	 mov	 ecx, DWORD PTR _col$[ebp]
  00209	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 566  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

  0020d	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00212	6b c8 03	 imul	 ecx, eax, 3
  00215	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00218	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0021b	8b 55 d4	 mov	 edx, DWORD PTR _d$[ebp]
  0021e	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
  00221	8b 55 d8	 mov	 edx, DWORD PTR _d$[ebp+4]
  00224	89 54 08 04	 mov	 DWORD PTR [eax+ecx+4], edx
  00228	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0022d	6b c8 03	 imul	 ecx, eax, 3
  00230	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00233	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00236	8b 55 c4	 mov	 edx, DWORD PTR _uv$[ebp]
  00239	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  0023d	8b 55 c8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  00240	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  00244	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00249	6b c8 03	 imul	 ecx, eax, 3
  0024c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0024f	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00252	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  00255	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 567  :     _VtxWritePtr += 4;

  00259	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0025c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0025f	83 c1 50	 add	 ecx, 80			; 00000050H
  00262	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00265	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 568  :     _VtxCurrentIdx += 4;

  00268	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0026e	83 c1 04	 add	 ecx, 4
  00271	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00274	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 569  :     _IdxWritePtr += 6;

  00277	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0027a	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0027d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00280	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00283	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 570  : }

  00286	52		 push	 edx
  00287	8b cd		 mov	 ecx, ebp
  00289	50		 push	 eax
  0028a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@PrimRect
  00290	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00295	58		 pop	 eax
  00296	5a		 pop	 edx
  00297	5f		 pop	 edi
  00298	5e		 pop	 esi
  00299	5b		 pop	 ebx
  0029a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029d	33 cd		 xor	 ecx, ebp
  0029f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a4	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  002aa	3b ec		 cmp	 ebp, esp
  002ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b1	8b e5		 mov	 esp, ebp
  002b3	5d		 pop	 ebp
  002b4	c2 0c 00	 ret	 12			; 0000000cH
  002b7	90		 npad	 1
$LN7@PrimRect:
  002b8	03 00 00 00	 DD	 3
  002bc	00 00 00 00	 DD	 $LN6@PrimRect
$LN6@PrimRect:
  002c0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  002c4	08 00 00 00	 DD	 8
  002c8	00 00 00 00	 DD	 $LN3@PrimRect
  002cc	d4 ff ff ff	 DD	 -44			; ffffffd4H
  002d0	08 00 00 00	 DD	 8
  002d4	00 00 00 00	 DD	 $LN4@PrimRect
  002d8	c4 ff ff ff	 DD	 -60			; ffffffc4H
  002dc	08 00 00 00	 DD	 8
  002e0	00 00 00 00	 DD	 $LN5@PrimRect
$LN5@PrimRect:
  002e4	75		 DB	 117			; 00000075H
  002e5	76		 DB	 118			; 00000076H
  002e6	00		 DB	 0
$LN4@PrimRect:
  002e7	64		 DB	 100			; 00000064H
  002e8	00		 DB	 0
$LN3@PrimRect:
  002e9	62		 DB	 98			; 00000062H
  002ea	00		 DB	 0
?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z ENDP		; ImDrawList::PrimRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PrimUnreserve@ImDrawList@@QAEXHH@Z
_TEXT	SEGMENT
_draw_cmd$ = -20					; size = 4
_this$ = -8						; size = 4
_idx_count$ = 8						; size = 4
_vtx_count$ = 12					; size = 4
?PrimUnreserve@ImDrawList@@QAEXHH@Z PROC		; ImDrawList::PrimUnreserve, COMDAT
; _this$ = ecx

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 548  :     IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
; 549  : 
; 550  :     ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size - 1];

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	83 e9 01	 sub	 ecx, 1
  00035	6b d1 28	 imul	 edx, ecx, 40
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0003e	89 55 ec	 mov	 DWORD PTR _draw_cmd$[ebp], edx

; 551  :     draw_cmd.ElemCount -= idx_count;

  00041	8b 45 ec	 mov	 eax, DWORD PTR _draw_cmd$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	2b 4d 08	 sub	 ecx, DWORD PTR _idx_count$[ebp]
  00049	8b 55 ec	 mov	 edx, DWORD PTR _draw_cmd$[ebp]
  0004c	89 0a		 mov	 DWORD PTR [edx], ecx

; 552  :     VtxBuffer.shrink(VtxBuffer.Size - vtx_count);

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00054	2b 4d 0c	 sub	 ecx, DWORD PTR _vtx_count$[ebp]
  00057	51		 push	 ecx
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 18	 add	 ecx, 24			; 00000018H
  0005e	e8 00 00 00 00	 call	 ?shrink@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::shrink

; 553  :     IdxBuffer.shrink(IdxBuffer.Size - idx_count);

  00063	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00069	2b 4d 08	 sub	 ecx, DWORD PTR _idx_count$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00073	e8 00 00 00 00	 call	 ?shrink@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::shrink

; 554  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
?PrimUnreserve@ImDrawList@@QAEXHH@Z ENDP		; ImDrawList::PrimUnreserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PrimReserve@ImDrawList@@QAEXHH@Z
_TEXT	SEGMENT
_idx_buffer_old_size$ = -44				; size = 4
_vtx_buffer_old_size$ = -32				; size = 4
_draw_cmd$ = -20					; size = 4
_this$ = -8						; size = 4
_idx_count$ = 8						; size = 4
_vtx_count$ = 12					; size = 4
?PrimReserve@ImDrawList@@QAEXHH@Z PROC			; ImDrawList::PrimReserve, COMDAT
; _this$ = ecx

; 523  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 524  :     // Large mesh support (when enabled)
; 525  :     IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
; 526  :     if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	74 3a		 je	 SHORT $LN2@PrimReserv
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0003c	03 4d 0c	 add	 ecx, DWORD PTR _vtx_count$[ebp]
  0003f	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  00045	72 29		 jb	 SHORT $LN2@PrimReserv
  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0004d	83 e1 04	 and	 ecx, 4
  00050	74 1e		 je	 SHORT $LN2@PrimReserv

; 527  :     {
; 528  :         _VtxCurrentOffset = VtxBuffer.Size;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005b	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 529  :         _VtxCurrentIdx = 0;

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 530  :         AddDrawCmd();

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QAEXXZ ; ImDrawList::AddDrawCmd
$LN2@PrimReserv:

; 531  :     }
; 532  : 
; 533  :     ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size - 1];

  00070	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	83 e9 01	 sub	 ecx, 1
  00078	6b d1 28	 imul	 edx, ecx, 40
  0007b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00081	89 55 ec	 mov	 DWORD PTR _draw_cmd$[ebp], edx

; 534  :     draw_cmd.ElemCount += idx_count;

  00084	8b 45 ec	 mov	 eax, DWORD PTR _draw_cmd$[ebp]
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	03 4d 08	 add	 ecx, DWORD PTR _idx_count$[ebp]
  0008c	8b 55 ec	 mov	 edx, DWORD PTR _draw_cmd$[ebp]
  0008f	89 0a		 mov	 DWORD PTR [edx], ecx

; 535  : 
; 536  :     int vtx_buffer_old_size = VtxBuffer.Size;

  00091	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00097	89 4d e0	 mov	 DWORD PTR _vtx_buffer_old_size$[ebp], ecx

; 537  :     VtxBuffer.resize(vtx_buffer_old_size + vtx_count);

  0009a	8b 45 e0	 mov	 eax, DWORD PTR _vtx_buffer_old_size$[ebp]
  0009d	03 45 0c	 add	 eax, DWORD PTR _vtx_count$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 18	 add	 ecx, 24			; 00000018H
  000a7	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize

; 538  :     _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

  000ac	6b 45 e0 14	 imul	 eax, DWORD PTR _vtx_buffer_old_size$[ebp], 20
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b9	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 539  : 
; 540  :     int idx_buffer_old_size = IdxBuffer.Size;

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000c2	89 4d d4	 mov	 DWORD PTR _idx_buffer_old_size$[ebp], ecx

; 541  :     IdxBuffer.resize(idx_buffer_old_size + idx_count);

  000c5	8b 45 d4	 mov	 eax, DWORD PTR _idx_buffer_old_size$[ebp]
  000c8	03 45 08	 add	 eax, DWORD PTR _idx_count$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000d2	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize

; 542  :     _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000dd	8b 55 d4	 mov	 edx, DWORD PTR _idx_buffer_old_size$[ebp]
  000e0	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  000e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 543  : }

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000f2	3b ec		 cmp	 ebp, esp
  000f4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 08 00	 ret	 8
?PrimReserve@ImDrawList@@QAEXHH@Z ENDP			; ImDrawList::PrimReserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ClearFreeMemory@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ClearFreeMemory@ImDrawList@@QAEXXZ PROC		; ImDrawList::ClearFreeMemory, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 380  :     CmdBuffer.clear();

  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ ; ImVector<ImDrawCmd>::clear

; 381  :     IdxBuffer.clear();

  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003b	e8 00 00 00 00	 call	 ?clear@?$ImVector@G@@QAEXXZ ; ImVector<unsigned short>::clear

; 382  :     VtxBuffer.clear();

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 18	 add	 ecx, 24			; 00000018H
  00046	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImDrawVert@@@@QAEXXZ ; ImVector<ImDrawVert>::clear

; 383  :     _VtxCurrentIdx = 0;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 384  :     _VtxWritePtr = NULL;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 385  :     _IdxWritePtr = NULL;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 386  :     _ClipRectStack.clear();

  00069	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	83 c1 40	 add	 ecx, 64			; 00000040H
  0006f	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImVec4@@@@QAEXXZ ; ImVector<ImVec4>::clear

; 387  :     _TextureIdStack.clear();

  00074	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0007a	e8 00 00 00 00	 call	 ?clear@?$ImVector@PAX@@QAEXXZ ; ImVector<void *>::clear

; 388  :     _Path.clear();

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	83 c1 58	 add	 ecx, 88			; 00000058H
  00085	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImVec2@@@@QAEXXZ ; ImVector<ImVec2>::clear

; 389  :     _Splitter.ClearFreeMemory();

  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	83 c1 64	 add	 ecx, 100		; 00000064H
  00090	e8 00 00 00 00	 call	 ?ClearFreeMemory@ImDrawListSplitter@@QAEXXZ ; ImDrawListSplitter::ClearFreeMemory

; 390  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0009e	3b ec		 cmp	 ebp, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?ClearFreeMemory@ImDrawList@@QAEXXZ ENDP		; ImDrawList::ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?Clear@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Clear@ImDrawList@@QAEXXZ PROC				; ImDrawList::Clear, COMDAT
; _this$ = ecx

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 364  :     CmdBuffer.resize(0);

  0002d	6a 00		 push	 0
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::resize

; 365  :     IdxBuffer.resize(0);

  00037	6a 00		 push	 0
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003f	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize

; 366  :     VtxBuffer.resize(0);

  00044	6a 00		 push	 0
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 18	 add	 ecx, 24			; 00000018H
  0004c	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize

; 367  :     Flags = _Data ? _Data->InitialFlags : ImDrawListFlags_None;

  00051	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00054	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00058	74 11		 je	 SHORT $LN3@Clear
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00060	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00063	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00069	eb 0a		 jmp	 SHORT $LN4@Clear
$LN3@Clear:
  0006b	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
$LN4@Clear:
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  0007e	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 368  :     _VtxCurrentOffset = 0;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 369  :     _VtxCurrentIdx = 0;

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 370  :     _VtxWritePtr = NULL;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00098	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 371  :     _IdxWritePtr = NULL;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 372  :     _ClipRectStack.resize(0);

  000a9	6a 00		 push	 0
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	83 c1 40	 add	 ecx, 64			; 00000040H
  000b1	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImVec4@@@@QAEXH@Z ; ImVector<ImVec4>::resize

; 373  :     _TextureIdStack.resize(0);

  000b6	6a 00		 push	 0
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000be	e8 00 00 00 00	 call	 ?resize@?$ImVector@PAX@@QAEXH@Z ; ImVector<void *>::resize

; 374  :     _Path.resize(0);

  000c3	6a 00		 push	 0
  000c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	83 c1 58	 add	 ecx, 88			; 00000058H
  000cb	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImVec2@@@@QAEXH@Z ; ImVector<ImVec2>::resize

; 375  :     _Splitter.Clear();

  000d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	83 c1 64	 add	 ecx, 100		; 00000064H
  000d6	e8 00 00 00 00	 call	 ?Clear@ImDrawListSplitter@@QAEXXZ ; ImDrawListSplitter::Clear

; 376  : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000e4	3b ec		 cmp	 ebp, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
?Clear@ImDrawList@@QAEXXZ ENDP				; ImDrawList::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?CloneOutput@ImDrawList@@QBEPAU1@XZ
_TEXT	SEGMENT
tv82 = -292						; size = 4
$T2 = -281						; size = 1
$T3 = -272						; size = 4
$T4 = -260						; size = 4
$T5 = -248						; size = 4
$T6 = -236						; size = 4
_dst$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?CloneOutput@ImDrawList@@QBEPAU1@XZ PROC		; ImDrawList::CloneOutput, COMDAT
; _this$ = ecx

; 393  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CloneOutput@ImDrawList@@QBEPAU1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd dc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-292]
  00021	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 394  :     ImDrawList* dst = IM_NEW(ImDrawList(_Data));

  0004c	6a 78		 push	 120			; 00000078H
  0004e	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00053	83 c4 04	 add	 esp, 4
  00056	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  0005c	8d 85 e7 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00062	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00068	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  0006e	51		 push	 ecx
  0006f	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00075	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00078	50		 push	 eax
  00079	6a 78		 push	 120			; 00000078H
  0007b	e8 00 00 00 00	 call	 ??2@YAPAXIUImNewDummy@@PAX@Z ; operator new
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00090	83 bd 08 ff ff
	ff 00		 cmp	 DWORD PTR $T5[ebp], 0
  00097	74 1a		 je	 SHORT $LN3@CloneOutpu
  00099	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0009f	52		 push	 edx
  000a0	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  000a6	e8 00 00 00 00	 call	 ??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z ; ImDrawList::ImDrawList
  000ab	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv82[ebp], eax
  000b1	eb 0a		 jmp	 SHORT $LN4@CloneOutpu
$LN3@CloneOutpu:
  000b3	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv82[ebp], 0
$LN4@CloneOutpu:
  000bd	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv82[ebp]
  000c3	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  000c9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d0	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  000d6	89 4d e0	 mov	 DWORD PTR _dst$[ebp], ecx

; 395  :     dst->CmdBuffer = CmdBuffer;

  000d9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d e0	 mov	 ecx, DWORD PTR _dst$[ebp]
  000e0	e8 00 00 00 00	 call	 ??4?$ImVector@UImDrawCmd@@@@QAEAAU0@ABU0@@Z ; ImVector<ImDrawCmd>::operator=

; 396  :     dst->IdxBuffer = IdxBuffer;

  000e5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	83 c0 0c	 add	 eax, 12			; 0000000cH
  000eb	50		 push	 eax
  000ec	8b 4d e0	 mov	 ecx, DWORD PTR _dst$[ebp]
  000ef	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000f2	e8 00 00 00 00	 call	 ??4?$ImVector@G@@QAEAAU0@ABU0@@Z ; ImVector<unsigned short>::operator=

; 397  :     dst->VtxBuffer = VtxBuffer;

  000f7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	83 c0 18	 add	 eax, 24			; 00000018H
  000fd	50		 push	 eax
  000fe	8b 4d e0	 mov	 ecx, DWORD PTR _dst$[ebp]
  00101	83 c1 18	 add	 ecx, 24			; 00000018H
  00104	e8 00 00 00 00	 call	 ??4?$ImVector@UImDrawVert@@@@QAEAAU0@ABU0@@Z ; ImVector<ImDrawVert>::operator=

; 398  :     dst->Flags = Flags;

  00109	8b 45 e0	 mov	 eax, DWORD PTR _dst$[ebp]
  0010c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00112	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 399  :     return dst;

  00115	8b 45 e0	 mov	 eax, DWORD PTR _dst$[ebp]

; 400  : }

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  0012c	3b ec		 cmp	 ebp, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CloneOutput@ImDrawList@@QBEPAU1@XZ$0:
  00000	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00006	50		 push	 eax
  00007	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00010	50		 push	 eax
  00011	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXUImNewDummy@@0@Z ; operator delete
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	c3		 ret	 0
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$?CloneOutput@ImDrawList@@QBEPAU1@XZ:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a d8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-296]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CloneOutput@ImDrawList@@QBEPAU1@XZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CloneOutput@ImDrawList@@QBEPAU1@XZ ENDP		; ImDrawList::CloneOutput
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddDrawCmd@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
tv91 = -272						; size = 4
tv78 = -272						; size = 4
$T1 = -264						; size = 4
_draw_cmd$ = -60					; size = 40
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?AddDrawCmd@ImDrawList@@QAEXXZ PROC			; ImDrawList::AddDrawCmd, COMDAT
; _this$ = ecx

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00013	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 408  :     ImDrawCmd draw_cmd;

  00037	8d 4d c4	 lea	 ecx, DWORD PTR _draw_cmd$[ebp]
  0003a	e8 00 00 00 00	 call	 ??0ImDrawCmd@@QAE@XZ	; ImDrawCmd::ImDrawCmd

; 409  :     draw_cmd.ClipRect = GetCurrentClipRect();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00046	74 1a		 je	 SHORT $LN3@AddDrawCmd
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0004e	83 ea 01	 sub	 edx, 1
  00051	c1 e2 04	 shl	 edx, 4
  00054	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00057	03 50 48	 add	 edx, DWORD PTR [eax+72]
  0005a	89 95 f0 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], edx
  00060	eb 0f		 jmp	 SHORT $LN4@AddDrawCmd
$LN3@AddDrawCmd:
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00068	83 c2 14	 add	 edx, 20			; 00000014H
  0006b	89 95 f0 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], edx
$LN4@AddDrawCmd:
  00071	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  00077	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0007d	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	89 55 c8	 mov	 DWORD PTR _draw_cmd$[ebp+4], edx
  00088	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0008b	89 45 cc	 mov	 DWORD PTR _draw_cmd$[ebp+8], eax
  0008e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00091	89 55 d0	 mov	 DWORD PTR _draw_cmd$[ebp+12], edx
  00094	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00097	89 45 d4	 mov	 DWORD PTR _draw_cmd$[ebp+16], eax

; 410  :     draw_cmd.TextureId = GetCurrentTextureId();

  0009a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000a1	74 18		 je	 SHORT $LN5@AddDrawCmd
  000a3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  000a9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000af	8b 54 91 fc	 mov	 edx, DWORD PTR [ecx+edx*4-4]
  000b3	89 95 f0 fe ff
	ff		 mov	 DWORD PTR tv91[ebp], edx
  000b9	eb 0a		 jmp	 SHORT $LN6@AddDrawCmd
$LN5@AddDrawCmd:
  000bb	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv91[ebp], 0
$LN6@AddDrawCmd:
  000c5	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv91[ebp]
  000cb	89 45 d8	 mov	 DWORD PTR _draw_cmd$[ebp+20], eax

; 411  :     draw_cmd.VtxOffset = _VtxCurrentOffset;

  000ce	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000d4	89 4d dc	 mov	 DWORD PTR _draw_cmd$[ebp+24], ecx

; 412  :     draw_cmd.IdxOffset = IdxBuffer.Size;

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000dd	89 4d e0	 mov	 DWORD PTR _draw_cmd$[ebp+28], ecx

; 413  : 
; 414  :     IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);

  000e0	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _draw_cmd$[ebp+12]
  000e5	0f 2f 45 c8	 comiss	 xmm0, DWORD PTR _draw_cmd$[ebp+4]
  000e9	72 0b		 jb	 SHORT $LN7@AddDrawCmd
  000eb	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _draw_cmd$[ebp+16]
  000f0	0f 2f 45 cc	 comiss	 xmm0, DWORD PTR _draw_cmd$[ebp+8]
  000f4	73 25		 jae	 SHORT $LN8@AddDrawCmd
$LN7@AddDrawCmd:
  000f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??AddDrawCmd@ImDrawList@@QAEXXZ@4JA
  000fb	83 c0 07	 add	 eax, 7
  000fe	8b f4		 mov	 esi, esp
  00100	50		 push	 eax
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
  00114	3b f4		 cmp	 esi, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@AddDrawCmd:

; 415  :     CmdBuffer.push_back(draw_cmd);

  0011b	8d 45 c4	 lea	 eax, DWORD PTR _draw_cmd$[ebp]
  0011e	50		 push	 eax
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back

; 416  : }

  00127	52		 push	 edx
  00128	8b cd		 mov	 ecx, ebp
  0012a	50		 push	 eax
  0012b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@AddDrawCmd
  00131	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00136	58		 pop	 eax
  00137	5a		 pop	 edx
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013e	33 cd		 xor	 ecx, ebp
  00140	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00145	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  0014b	3b ec		 cmp	 ebp, esp
  0014d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
  00156	66 90		 npad	 2
$LN11@AddDrawCmd:
  00158	01 00 00 00	 DD	 1
  0015c	00 00 00 00	 DD	 $LN10@AddDrawCmd
$LN10@AddDrawCmd:
  00160	c4 ff ff ff	 DD	 -60			; ffffffc4H
  00164	28 00 00 00	 DD	 40			; 00000028H
  00168	00 00 00 00	 DD	 $LN9@AddDrawCmd
$LN9@AddDrawCmd:
  0016c	64		 DB	 100			; 00000064H
  0016d	72		 DB	 114			; 00000072H
  0016e	61		 DB	 97			; 00000061H
  0016f	77		 DB	 119			; 00000077H
  00170	5f		 DB	 95			; 0000005fH
  00171	63		 DB	 99			; 00000063H
  00172	6d		 DB	 109			; 0000006dH
  00173	64		 DB	 100			; 00000064H
  00174	00		 DB	 0
?AddDrawCmd@ImDrawList@@QAEXXZ ENDP			; ImDrawList::AddDrawCmd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddCallback@ImDrawList@@QAEXP6AXPBU1@PBUImDrawCmd@@@ZPAX@Z
_TEXT	SEGMENT
tv70 = -220						; size = 4
_current_cmd$ = -20					; size = 4
_this$ = -8						; size = 4
_callback$ = 8						; size = 4
_callback_data$ = 12					; size = 4
?AddCallback@ImDrawList@@QAEXP6AXPBU1@PBUImDrawCmd@@@ZPAX@Z PROC ; ImDrawList::AddCallback, COMDAT
; _this$ = ecx

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 420  :     ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	74 10		 je	 SHORT $LN5@AddCallbac
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  0003d	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  00043	eb 0a		 jmp	 SHORT $LN6@AddCallbac
$LN5@AddCallbac:
  00045	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN6@AddCallbac:
  0004f	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  00055	89 4d ec	 mov	 DWORD PTR _current_cmd$[ebp], ecx

; 421  :     if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)

  00058	83 7d ec 00	 cmp	 DWORD PTR _current_cmd$[ebp], 0
  0005c	74 11		 je	 SHORT $LN3@AddCallbac
  0005e	8b 45 ec	 mov	 eax, DWORD PTR _current_cmd$[ebp]
  00061	83 38 00	 cmp	 DWORD PTR [eax], 0
  00064	75 09		 jne	 SHORT $LN3@AddCallbac
  00066	8b 45 ec	 mov	 eax, DWORD PTR _current_cmd$[ebp]
  00069	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0006d	74 13		 je	 SHORT $LN2@AddCallbac
$LN3@AddCallbac:

; 422  :     {
; 423  :         AddDrawCmd();

  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QAEXXZ ; ImDrawList::AddDrawCmd

; 424  :         current_cmd = &CmdBuffer.back();

  00077	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  0007f	89 45 ec	 mov	 DWORD PTR _current_cmd$[ebp], eax
$LN2@AddCallbac:

; 425  :     }
; 426  :     current_cmd->UserCallback = callback;

  00082	8b 45 ec	 mov	 eax, DWORD PTR _current_cmd$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _callback$[ebp]
  00088	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 427  :     current_cmd->UserCallbackData = callback_data;

  0008b	8b 45 ec	 mov	 eax, DWORD PTR _current_cmd$[ebp]
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR _callback_data$[ebp]
  00091	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 428  : 
; 429  :     AddDrawCmd(); // Force a new command after us (see comment below)

  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QAEXXZ ; ImDrawList::AddDrawCmd

; 430  : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?AddCallback@ImDrawList@@QAEXP6AXPBU1@PBUImDrawCmd@@@ZPAX@Z ENDP ; ImDrawList::AddCallback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z
_TEXT	SEGMENT
tv248 = -356						; size = 4
tv231 = -356						; size = 4
tv159 = -352						; size = 4
tv156 = -352						; size = 4
tv153 = -352						; size = 4
tv150 = -352						; size = 4
tv89 = -352						; size = 4
tv74 = -352						; size = 4
$T1 = -344						; size = 8
$T2 = -328						; size = 8
$T3 = -312						; size = 8
$T4 = -296						; size = 8
$T5 = -280						; size = 8
$T6 = -264						; size = 8
_rounding_bl$7 = -56					; size = 4
_rounding_br$8 = -44					; size = 4
_rounding_tr$9 = -32					; size = 4
_rounding_tl$10 = -20					; size = 4
_this$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_rounding$ = 16						; size = 4
_rounding_corners$ = 20					; size = 4
?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z PROC		; ImDrawList::PathRect, COMDAT
; _this$ = ecx

; 961  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 9c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-356]
  00013	b9 59 00 00 00	 mov	 ecx, 89			; 00000059H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 962  :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((rounding_corners & ImDrawCornerFlags_Top)  == ImDrawCornerFlags_Top)  || ((rounding_corners & ImDrawCornerFlags_Bot)   == ImDrawCornerFlags_Bot)   ? 0.5f : 1.0f ) - 1.0f);

  0002d	8b 45 14	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  00030	83 e0 03	 and	 eax, 3
  00033	83 f8 03	 cmp	 eax, 3
  00036	74 1d		 je	 SHORT $LN6@PathRect
  00038	8b 4d 14	 mov	 ecx, DWORD PTR _rounding_corners$[ebp]
  0003b	83 e1 0c	 and	 ecx, 12			; 0000000cH
  0003e	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  00041	74 12		 je	 SHORT $LN6@PathRect
  00043	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004b	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
  00053	eb 10		 jmp	 SHORT $LN7@PathRect
$LN6@PathRect:
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0005d	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv74[ebp], xmm0
$LN7@PathRect:
  00065	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00068	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0006b	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0006f	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00073	51		 push	 ecx
  00074	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00079	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  0007e	83 c4 04	 add	 esp, 4
  00081	d9 9d 9c fe ff
	ff		 fstp	 DWORD PTR tv231[ebp]
  00087	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR tv231[ebp]
  0008f	f3 0f 59 85 a0
	fe ff ff	 mulss	 xmm0, DWORD PTR tv74[ebp]
  00097	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0009f	51		 push	 ecx
  000a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a5	51		 push	 ecx
  000a6	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  000ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b0	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  000b5	83 c4 08	 add	 esp, 8
  000b8	d9 5d 10	 fstp	 DWORD PTR _rounding$[ebp]

; 963  :     rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f ) - 1.0f);

  000bb	8b 45 14	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  000be	83 e0 05	 and	 eax, 5
  000c1	83 f8 05	 cmp	 eax, 5
  000c4	74 1d		 je	 SHORT $LN8@PathRect
  000c6	8b 4d 14	 mov	 ecx, DWORD PTR _rounding_corners$[ebp]
  000c9	83 e1 0a	 and	 ecx, 10			; 0000000aH
  000cc	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000cf	74 12		 je	 SHORT $LN8@PathRect
  000d1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d9	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv89[ebp], xmm0
  000e1	eb 10		 jmp	 SHORT $LN9@PathRect
$LN8@PathRect:
  000e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000eb	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv89[ebp], xmm0
$LN9@PathRect:
  000f3	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  000f6	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000f9	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  000fe	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  00103	51		 push	 ecx
  00104	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00109	e8 00 00 00 00	 call	 ?ImFabs@@YAMM@Z		; ImFabs
  0010e	83 c4 04	 add	 esp, 4
  00111	d9 9d 9c fe ff
	ff		 fstp	 DWORD PTR tv248[ebp]
  00117	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR tv248[ebp]
  0011f	f3 0f 59 85 a0
	fe ff ff	 mulss	 xmm0, DWORD PTR tv89[ebp]
  00127	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0012f	51		 push	 ecx
  00130	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00135	51		 push	 ecx
  00136	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0013b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00140	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00145	83 c4 08	 add	 esp, 8
  00148	d9 5d 10	 fstp	 DWORD PTR _rounding$[ebp]

; 964  : 
; 965  :     if (rounding <= 0.0f || rounding_corners == 0)

  0014b	0f 57 c0	 xorps	 xmm0, xmm0
  0014e	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _rounding$[ebp]
  00152	73 06		 jae	 SHORT $LN4@PathRect
  00154	83 7d 14 00	 cmp	 DWORD PTR _rounding_corners$[ebp], 0
  00158	75 7b		 jne	 SHORT $LN2@PathRect
$LN4@PathRect:

; 966  :     {
; 967  :         PathLineTo(a);

  0015a	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0015d	50		 push	 eax
  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 968  :         PathLineTo(ImVec2(b.x, a.y));

  00166	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00169	51		 push	 ecx
  0016a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00177	51		 push	 ecx
  00178	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0017c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00181	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00187	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0018c	50		 push	 eax
  0018d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 969  :         PathLineTo(b);

  00195	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00198	50		 push	 eax
  00199	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 970  :         PathLineTo(ImVec2(a.x, b.y));

  001a1	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  001a4	51		 push	 ecx
  001a5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001af	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  001b2	51		 push	 ecx
  001b3	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  001b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bc	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  001c2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  001c7	50		 push	 eax
  001c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 971  :     }

  001d0	e9 dc 01 00 00	 jmp	 $LN3@PathRect
$LN2@PathRect:

; 972  :     else
; 973  :     {
; 974  :         const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;

  001d5	8b 45 14	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  001d8	83 e0 01	 and	 eax, 1
  001db	74 0f		 je	 SHORT $LN10@PathRect
  001dd	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  001e2	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv150[ebp], xmm0
  001ea	eb 0b		 jmp	 SHORT $LN11@PathRect
$LN10@PathRect:
  001ec	0f 57 c0	 xorps	 xmm0, xmm0
  001ef	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv150[ebp], xmm0
$LN11@PathRect:
  001f7	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR tv150[ebp]
  001ff	f3 0f 11 45 ec	 movss	 DWORD PTR _rounding_tl$10[ebp], xmm0

; 975  :         const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;

  00204	8b 45 14	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  00207	83 e0 02	 and	 eax, 2
  0020a	74 0f		 je	 SHORT $LN12@PathRect
  0020c	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00211	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv153[ebp], xmm0
  00219	eb 0b		 jmp	 SHORT $LN13@PathRect
$LN12@PathRect:
  0021b	0f 57 c0	 xorps	 xmm0, xmm0
  0021e	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv153[ebp], xmm0
$LN13@PathRect:
  00226	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR tv153[ebp]
  0022e	f3 0f 11 45 e0	 movss	 DWORD PTR _rounding_tr$9[ebp], xmm0

; 976  :         const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;

  00233	8b 45 14	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  00236	83 e0 08	 and	 eax, 8
  00239	74 0f		 je	 SHORT $LN14@PathRect
  0023b	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00240	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv156[ebp], xmm0
  00248	eb 0b		 jmp	 SHORT $LN15@PathRect
$LN14@PathRect:
  0024a	0f 57 c0	 xorps	 xmm0, xmm0
  0024d	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv156[ebp], xmm0
$LN15@PathRect:
  00255	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR tv156[ebp]
  0025d	f3 0f 11 45 d4	 movss	 DWORD PTR _rounding_br$8[ebp], xmm0

; 977  :         const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;

  00262	8b 45 14	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  00265	83 e0 04	 and	 eax, 4
  00268	74 0f		 je	 SHORT $LN16@PathRect
  0026a	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0026f	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
  00277	eb 0b		 jmp	 SHORT $LN17@PathRect
$LN16@PathRect:
  00279	0f 57 c0	 xorps	 xmm0, xmm0
  0027c	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR tv159[ebp], xmm0
$LN17@PathRect:
  00284	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR tv159[ebp]
  0028c	f3 0f 11 45 c8	 movss	 DWORD PTR _rounding_bl$7[ebp], xmm0

; 978  :         PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);

  00291	6a 09		 push	 9
  00293	6a 06		 push	 6
  00295	51		 push	 ecx
  00296	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _rounding_tl$10[ebp]
  0029b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a0	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  002a3	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002a8	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _rounding_tl$10[ebp]
  002ad	51		 push	 ecx
  002ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  002b6	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  002ba	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _rounding_tl$10[ebp]
  002bf	51		 push	 ecx
  002c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c5	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  002cb	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  002d0	50		 push	 eax
  002d1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d4	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 979  :         PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);

  002d9	6a 0c		 push	 12			; 0000000cH
  002db	6a 09		 push	 9
  002dd	51		 push	 ecx
  002de	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _rounding_tr$9[ebp]
  002e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e8	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  002eb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002f0	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _rounding_tr$9[ebp]
  002f5	51		 push	 ecx
  002f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002fb	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  002fe	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00302	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _rounding_tr$9[ebp]
  00307	51		 push	 ecx
  00308	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0030d	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00313	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00318	50		 push	 eax
  00319	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0031c	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 980  :         PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);

  00321	6a 03		 push	 3
  00323	6a 00		 push	 0
  00325	51		 push	 ecx
  00326	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _rounding_br$8[ebp]
  0032b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00330	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00333	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00338	f3 0f 5c 45 d4	 subss	 xmm0, DWORD PTR _rounding_br$8[ebp]
  0033d	51		 push	 ecx
  0033e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00343	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  00346	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0034a	f3 0f 5c 45 d4	 subss	 xmm0, DWORD PTR _rounding_br$8[ebp]
  0034f	51		 push	 ecx
  00350	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00355	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0035b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00360	50		 push	 eax
  00361	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00364	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 981  :         PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);

  00369	6a 06		 push	 6
  0036b	6a 03		 push	 3
  0036d	51		 push	 ecx
  0036e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _rounding_bl$7[ebp]
  00373	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00378	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0037b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00380	f3 0f 5c 45 c8	 subss	 xmm0, DWORD PTR _rounding_bl$7[ebp]
  00385	51		 push	 ecx
  00386	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038b	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0038e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00392	f3 0f 58 45 c8	 addss	 xmm0, DWORD PTR _rounding_bl$7[ebp]
  00397	51		 push	 ecx
  00398	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039d	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  003a3	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  003a8	50		 push	 eax
  003a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ac	e8 00 00 00 00	 call	 ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
$LN3@PathRect:

; 982  :     }
; 983  : }

  003b1	5f		 pop	 edi
  003b2	5e		 pop	 esi
  003b3	5b		 pop	 ebx
  003b4	81 c4 64 01 00
	00		 add	 esp, 356		; 00000164H
  003ba	3b ec		 cmp	 ebp, esp
  003bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c1	8b e5		 mov	 esp, ebp
  003c3	5d		 pop	 ebp
  003c4	c2 10 00	 ret	 16			; 00000010H
?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ENDP		; ImDrawList::PathRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z
_TEXT	SEGMENT
$T1 = -332						; size = 8
_w4$2 = -124						; size = 4
_w3$3 = -112						; size = 4
_w2$4 = -100						; size = 4
_w1$5 = -88						; size = 4
_u$6 = -76						; size = 4
_t$7 = -64						; size = 4
_i_step$8 = -52						; size = 4
_t_step$9 = -40						; size = 4
_p1$ = -28						; size = 8
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p2$ = 8						; size = 4
_p3$ = 12						; size = 4
_p4$ = 16						; size = 4
_num_segments$ = 20					; size = 4
?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z PROC ; ImDrawList::PathBezierCurveTo, COMDAT
; _this$ = ecx

; 937  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-336]
  00013	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 938  :     ImVec2 p1 = _Path.back();

  00037	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 58	 add	 ecx, 88			; 00000058H
  0003d	e8 00 00 00 00	 call	 ?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ ; ImVector<ImVec2>::back
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00047	89 4d e4	 mov	 DWORD PTR _p1$[ebp], ecx
  0004a	89 55 e8	 mov	 DWORD PTR _p1$[ebp+4], edx

; 939  :     if (num_segments == 0)

  0004d	83 7d 14 00	 cmp	 DWORD PTR _num_segments$[ebp], 0
  00051	0f 85 8e 00 00
	00		 jne	 $LN5@PathBezier

; 940  :     {
; 941  :         // Auto-tessellated
; 942  :         PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);

  00057	6a 00		 push	 0
  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0005f	51		 push	 ecx
  00060	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	8b 55 10	 mov	 edx, DWORD PTR _p4$[ebp]
  0006d	51		 push	 ecx
  0006e	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00073	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00078	8b 45 10	 mov	 eax, DWORD PTR _p4$[ebp]
  0007b	51		 push	 ecx
  0007c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00080	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00085	8b 4d 0c	 mov	 ecx, DWORD PTR _p3$[ebp]
  00088	51		 push	 ecx
  00089	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0008e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00093	8b 55 0c	 mov	 edx, DWORD PTR _p3$[ebp]
  00096	51		 push	 ecx
  00097	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0009b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a0	8b 45 08	 mov	 eax, DWORD PTR _p2$[ebp]
  000a3	51		 push	 ecx
  000a4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _p2$[ebp]
  000b1	51		 push	 ecx
  000b2	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	51		 push	 ecx
  000bc	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _p1$[ebp+4]
  000c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c6	51		 push	 ecx
  000c7	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _p1$[ebp]
  000cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d1	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	83 c2 58	 add	 edx, 88			; 00000058H
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 ?PathBezierToCasteljau@@YAXPAU?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau
  000dd	83 c4 2c	 add	 esp, 44			; 0000002cH

; 943  :     }

  000e0	e9 54 01 00 00	 jmp	 $LN3@PathBezier
$LN5@PathBezier:

; 944  :     else
; 945  :     {
; 946  :         float t_step = 1.0f / (float)num_segments;

  000e5	f3 0f 2a 45 14	 cvtsi2ss xmm0, DWORD PTR _num_segments$[ebp]
  000ea	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  000f2	f3 0f 5e c8	 divss	 xmm1, xmm0
  000f6	f3 0f 11 4d d8	 movss	 DWORD PTR _t_step$9[ebp], xmm1

; 947  :         for (int i_step = 1; i_step <= num_segments; i_step++)

  000fb	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _i_step$8[ebp], 1
  00102	eb 09		 jmp	 SHORT $LN4@PathBezier
$LN2@PathBezier:
  00104	8b 45 cc	 mov	 eax, DWORD PTR _i_step$8[ebp]
  00107	83 c0 01	 add	 eax, 1
  0010a	89 45 cc	 mov	 DWORD PTR _i_step$8[ebp], eax
$LN4@PathBezier:
  0010d	8b 45 cc	 mov	 eax, DWORD PTR _i_step$8[ebp]
  00110	3b 45 14	 cmp	 eax, DWORD PTR _num_segments$[ebp]
  00113	0f 8f 20 01 00
	00		 jg	 $LN3@PathBezier

; 948  :         {
; 949  :             float t = t_step * i_step;

  00119	f3 0f 2a 45 cc	 cvtsi2ss xmm0, DWORD PTR _i_step$8[ebp]
  0011e	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _t_step$9[ebp]
  00123	f3 0f 11 45 c0	 movss	 DWORD PTR _t$7[ebp], xmm0

; 950  :             float u = 1.0f - t;

  00128	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00130	f3 0f 5c 45 c0	 subss	 xmm0, DWORD PTR _t$7[ebp]
  00135	f3 0f 11 45 b4	 movss	 DWORD PTR _u$6[ebp], xmm0

; 951  :             float w1 = u*u*u;

  0013a	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _u$6[ebp]
  0013f	f3 0f 59 45 b4	 mulss	 xmm0, DWORD PTR _u$6[ebp]
  00144	f3 0f 59 45 b4	 mulss	 xmm0, DWORD PTR _u$6[ebp]
  00149	f3 0f 11 45 a8	 movss	 DWORD PTR _w1$5[ebp], xmm0

; 952  :             float w2 = 3*u*u*t;

  0014e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00156	f3 0f 59 45 b4	 mulss	 xmm0, DWORD PTR _u$6[ebp]
  0015b	f3 0f 59 45 b4	 mulss	 xmm0, DWORD PTR _u$6[ebp]
  00160	f3 0f 59 45 c0	 mulss	 xmm0, DWORD PTR _t$7[ebp]
  00165	f3 0f 11 45 9c	 movss	 DWORD PTR _w2$4[ebp], xmm0

; 953  :             float w3 = 3*u*t*t;

  0016a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00172	f3 0f 59 45 b4	 mulss	 xmm0, DWORD PTR _u$6[ebp]
  00177	f3 0f 59 45 c0	 mulss	 xmm0, DWORD PTR _t$7[ebp]
  0017c	f3 0f 59 45 c0	 mulss	 xmm0, DWORD PTR _t$7[ebp]
  00181	f3 0f 11 45 90	 movss	 DWORD PTR _w3$3[ebp], xmm0

; 954  :             float w4 = t*t*t;

  00186	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _t$7[ebp]
  0018b	f3 0f 59 45 c0	 mulss	 xmm0, DWORD PTR _t$7[ebp]
  00190	f3 0f 59 45 c0	 mulss	 xmm0, DWORD PTR _t$7[ebp]
  00195	f3 0f 11 45 84	 movss	 DWORD PTR _w4$2[ebp], xmm0

; 955  :             _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));

  0019a	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _w1$5[ebp]
  0019f	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _p1$[ebp+4]
  001a4	8b 45 08	 mov	 eax, DWORD PTR _p2$[ebp]
  001a7	f3 0f 10 4d 9c	 movss	 xmm1, DWORD PTR _w2$4[ebp]
  001ac	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  001b1	f3 0f 58 c1	 addss	 xmm0, xmm1
  001b5	8b 4d 0c	 mov	 ecx, DWORD PTR _p3$[ebp]
  001b8	f3 0f 10 4d 90	 movss	 xmm1, DWORD PTR _w3$3[ebp]
  001bd	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [ecx+4]
  001c2	f3 0f 58 c1	 addss	 xmm0, xmm1
  001c6	8b 55 10	 mov	 edx, DWORD PTR _p4$[ebp]
  001c9	f3 0f 10 4d 84	 movss	 xmm1, DWORD PTR _w4$2[ebp]
  001ce	f3 0f 59 4a 04	 mulss	 xmm1, DWORD PTR [edx+4]
  001d3	f3 0f 58 c1	 addss	 xmm0, xmm1
  001d7	51		 push	 ecx
  001d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001dd	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _w1$5[ebp]
  001e2	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _p1$[ebp]
  001e7	8b 45 08	 mov	 eax, DWORD PTR _p2$[ebp]
  001ea	f3 0f 10 4d 9c	 movss	 xmm1, DWORD PTR _w2$4[ebp]
  001ef	f3 0f 59 08	 mulss	 xmm1, DWORD PTR [eax]
  001f3	f3 0f 58 c1	 addss	 xmm0, xmm1
  001f7	8b 4d 0c	 mov	 ecx, DWORD PTR _p3$[ebp]
  001fa	f3 0f 10 4d 90	 movss	 xmm1, DWORD PTR _w3$3[ebp]
  001ff	f3 0f 59 09	 mulss	 xmm1, DWORD PTR [ecx]
  00203	f3 0f 58 c1	 addss	 xmm0, xmm1
  00207	8b 55 10	 mov	 edx, DWORD PTR _p4$[ebp]
  0020a	f3 0f 10 4d 84	 movss	 xmm1, DWORD PTR _w4$2[ebp]
  0020f	f3 0f 59 0a	 mulss	 xmm1, DWORD PTR [edx]
  00213	f3 0f 58 c1	 addss	 xmm0, xmm1
  00217	51		 push	 ecx
  00218	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021d	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00223	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00228	50		 push	 eax
  00229	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0022c	83 c1 58	 add	 ecx, 88			; 00000058H
  0022f	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 956  :         }

  00234	e9 cb fe ff ff	 jmp	 $LN2@PathBezier
$LN3@PathBezier:

; 957  :     }
; 958  : }

  00239	52		 push	 edx
  0023a	8b cd		 mov	 ecx, ebp
  0023c	50		 push	 eax
  0023d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@PathBezier
  00243	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00248	58		 pop	 eax
  00249	5a		 pop	 edx
  0024a	5f		 pop	 edi
  0024b	5e		 pop	 esi
  0024c	5b		 pop	 ebx
  0024d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00250	33 cd		 xor	 ecx, ebp
  00252	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00257	81 c4 50 01 00
	00		 add	 esp, 336		; 00000150H
  0025d	3b ec		 cmp	 ebp, esp
  0025f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c2 10 00	 ret	 16			; 00000010H
  0026a	66 90		 npad	 2
$LN10@PathBezier:
  0026c	01 00 00 00	 DD	 1
  00270	00 00 00 00	 DD	 $LN9@PathBezier
$LN9@PathBezier:
  00274	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00278	08 00 00 00	 DD	 8
  0027c	00 00 00 00	 DD	 $LN8@PathBezier
$LN8@PathBezier:
  00280	70		 DB	 112			; 00000070H
  00281	31		 DB	 49			; 00000031H
  00282	00		 DB	 0
?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z ENDP ; ImDrawList::PathBezierCurveTo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z
_TEXT	SEGMENT
$T1 = -240						; size = 8
_c$2 = -32						; size = 4
_a$3 = -20						; size = 4
_this$ = -8						; size = 4
_center$ = 8						; size = 4
_radius$ = 12						; size = 4
_a_min_of_12$ = 16					; size = 4
_a_max_of_12$ = 20					; size = 4
?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z PROC	; ImDrawList::PathArcToFast, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00013	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 879  :     if (radius == 0.0f || a_min_of_12 > a_max_of_12)

  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00032	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00039	9f		 lahf
  0003a	f6 c4 44	 test	 ah, 68			; 00000044H
  0003d	7b 08		 jnp	 SHORT $LN6@PathArcToF
  0003f	8b 45 10	 mov	 eax, DWORD PTR _a_min_of_12$[ebp]
  00042	3b 45 14	 cmp	 eax, DWORD PTR _a_max_of_12$[ebp]
  00045	7e 14		 jle	 SHORT $LN5@PathArcToF
$LN6@PathArcToF:

; 880  :     {
; 881  :         _Path.push_back(center);

  00047	8b 45 08	 mov	 eax, DWORD PTR _center$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 58	 add	 ecx, 88			; 00000058H
  00051	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 882  :         return;

  00056	e9 9a 00 00 00	 jmp	 $LN1@PathArcToF
$LN5@PathArcToF:

; 883  :     }
; 884  :     _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));

  0005b	8b 45 14	 mov	 eax, DWORD PTR _a_max_of_12$[ebp]
  0005e	2b 45 10	 sub	 eax, DWORD PTR _a_min_of_12$[ebp]
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00067	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  0006b	50		 push	 eax
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	83 c1 58	 add	 ecx, 88			; 00000058H
  00072	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ; ImVector<ImVec2>::reserve

; 885  :     for (int a = a_min_of_12; a <= a_max_of_12; a++)

  00077	8b 45 10	 mov	 eax, DWORD PTR _a_min_of_12$[ebp]
  0007a	89 45 ec	 mov	 DWORD PTR _a$3[ebp], eax
  0007d	eb 09		 jmp	 SHORT $LN4@PathArcToF
$LN2@PathArcToF:
  0007f	8b 45 ec	 mov	 eax, DWORD PTR _a$3[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 ec	 mov	 DWORD PTR _a$3[ebp], eax
$LN4@PathArcToF:
  00088	8b 45 ec	 mov	 eax, DWORD PTR _a$3[ebp]
  0008b	3b 45 14	 cmp	 eax, DWORD PTR _a_max_of_12$[ebp]
  0008e	7f 65		 jg	 SHORT $LN3@PathArcToF

; 886  :     {
; 887  :         const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];

  00090	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00096	8b 45 ec	 mov	 eax, DWORD PTR _a$3[ebp]
  00099	99		 cdq
  0009a	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  0009f	f7 fe		 idiv	 esi
  000a1	8d 54 d1 28	 lea	 edx, DWORD PTR [ecx+edx*8+40]
  000a5	89 55 e0	 mov	 DWORD PTR _c$2[ebp], edx

; 888  :         _Path.push_back(ImVec2(center.x + c.x * radius, center.y + c.y * radius));

  000a8	8b 45 e0	 mov	 eax, DWORD PTR _c$2[ebp]
  000ab	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000b0	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _radius$[ebp]
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _center$[ebp]
  000b8	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  000bd	51		 push	 ecx
  000be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c3	8b 55 e0	 mov	 edx, DWORD PTR _c$2[ebp]
  000c6	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  000ca	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _radius$[ebp]
  000cf	8b 45 08	 mov	 eax, DWORD PTR _center$[ebp]
  000d2	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  000d6	51		 push	 ecx
  000d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000dc	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000e2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000e7	50		 push	 eax
  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	83 c1 58	 add	 ecx, 88			; 00000058H
  000ee	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 889  :     }

  000f3	eb 8a		 jmp	 SHORT $LN2@PathArcToF
$LN3@PathArcToF:
$LN1@PathArcToF:

; 890  : }

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000fe	3b ec		 cmp	 ebp, esp
  00100	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 10 00	 ret	 16			; 00000010H
?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ENDP	; ImDrawList::PathArcToFast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z
_TEXT	SEGMENT
tv160 = -252						; size = 4
tv152 = -248						; size = 4
$T1 = -240						; size = 8
_a$2 = -32						; size = 4
_i$3 = -20						; size = 4
_this$ = -8						; size = 4
_center$ = 8						; size = 4
_radius$ = 12						; size = 4
_a_min$ = 16						; size = 4
_a_max$ = 20						; size = 4
_num_segments$ = 24					; size = 4
?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z PROC	; ImDrawList::PathArcTo, COMDAT
; _this$ = ecx

; 893  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00013	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 894  :     if (radius == 0.0f)

  0002d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00032	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00039	9f		 lahf
  0003a	f6 c4 44	 test	 ah, 68			; 00000044H
  0003d	7a 14		 jp	 SHORT $LN5@PathArcTo

; 895  :     {
; 896  :         _Path.push_back(center);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _center$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 58	 add	 ecx, 88			; 00000058H
  00049	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 897  :         return;

  0004e	e9 e0 00 00 00	 jmp	 $LN1@PathArcTo
$LN5@PathArcTo:

; 898  :     }
; 899  : 
; 900  :     // Note that we are adding a point at both a_min and a_max.
; 901  :     // If you are trying to draw a full closed circle you don't want the overlapping points!
; 902  :     _Path.reserve(_Path.Size + (num_segments + 1));

  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00059	8b 55 18	 mov	 edx, DWORD PTR _num_segments$[ebp]
  0005c	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00060	50		 push	 eax
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	83 c1 58	 add	 ecx, 88			; 00000058H
  00067	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ; ImVector<ImVec2>::reserve

; 903  :     for (int i = 0; i <= num_segments; i++)

  0006c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN4@PathArcTo
$LN2@PathArcTo:
  00075	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 ec	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@PathArcTo:
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00081	3b 45 18	 cmp	 eax, DWORD PTR _num_segments$[ebp]
  00084	0f 8f a9 00 00
	00		 jg	 $LN3@PathArcTo

; 904  :     {
; 905  :         const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);

  0008a	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _i$3[ebp]
  0008f	f3 0f 2a 4d 18	 cvtsi2ss xmm1, DWORD PTR _num_segments$[ebp]
  00094	f3 0f 5e c1	 divss	 xmm0, xmm1
  00098	f3 0f 10 4d 14	 movss	 xmm1, DWORD PTR _a_max$[ebp]
  0009d	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR _a_min$[ebp]
  000a2	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000a6	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR _a_min$[ebp]
  000ab	f3 0f 11 45 e0	 movss	 DWORD PTR _a$2[ebp], xmm0

; 906  :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

  000b0	51		 push	 ecx
  000b1	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _a$2[ebp]
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	e8 00 00 00 00	 call	 ?ImSin@@YAMM@Z		; ImSin
  000c0	83 c4 04	 add	 esp, 4
  000c3	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv152[ebp]
  000c9	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR tv152[ebp]
  000d1	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _radius$[ebp]
  000d6	8b 45 08	 mov	 eax, DWORD PTR _center$[ebp]
  000d9	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  000de	51		 push	 ecx
  000df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e4	51		 push	 ecx
  000e5	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _a$2[ebp]
  000ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ef	e8 00 00 00 00	 call	 ?ImCos@@YAMM@Z		; ImCos
  000f4	83 c4 04	 add	 esp, 4
  000f7	d9 9d 04 ff ff
	ff		 fstp	 DWORD PTR tv160[ebp]
  000fd	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR tv160[ebp]
  00105	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _radius$[ebp]
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _center$[ebp]
  0010d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00111	51		 push	 ecx
  00112	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00117	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0011d	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00122	50		 push	 eax
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	83 c1 58	 add	 ecx, 88			; 00000058H
  00129	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 907  :     }

  0012e	e9 42 ff ff ff	 jmp	 $LN2@PathArcTo
$LN3@PathArcTo:
$LN1@PathArcTo:

; 908  : }

  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  0013c	3b ec		 cmp	 ebp, esp
  0013e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c2 14 00	 ret	 20			; 00000014H
?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ENDP	; ImDrawList::PathArcTo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QAEXI_NM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_col$ = 8						; size = 4
_closed$ = 12						; size = 1
_thickness$ = 16					; size = 4
?PathStroke@ImDrawList@@QAEXI_NM@Z PROC			; ImDrawList::PathStroke, COMDAT
; _this$ = ecx

; 1959 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	51		 push	 ecx
  0002e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	0f b6 45 0c	 movzx	 eax, BYTE PTR _closed$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _col$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00047	50		 push	 eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0004e	52		 push	 edx
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM@Z ; ImDrawList::AddPolyline
  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 0c 00	 ret	 12			; 0000000cH
?PathStroke@ImDrawList@@QAEXI_NM@Z ENDP			; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PathFillConvex@ImDrawList@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_col$ = 8						; size = 4
?PathFillConvex@ImDrawList@@QAEXI@Z PROC		; ImDrawList::PathFillConvex, COMDAT
; _this$ = ecx

; 1958 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _col$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00037	52		 push	 edx
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0003e	51		 push	 ecx
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?PathFillConvex@ImDrawList@@QAEXI@Z ENDP		; ImDrawList::PathFillConvex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z PROC		; ImDrawList::PathLineTo, COMDAT
; _this$ = ecx

; 1956 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 58	 add	 ecx, 88			; 00000058H
  00037	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ENDP		; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddImageRounded@ImDrawList@@QAEXPAXABUImVec2@@111IMH@Z
_TEXT	SEGMENT
tv85 = -241						; size = 1
_vert_end_idx$ = -44					; size = 4
_vert_start_idx$ = -32					; size = 4
_push_texture_id$ = -17					; size = 1
_this$ = -8						; size = 4
_user_texture_id$ = 8					; size = 4
_p_min$ = 12						; size = 4
_p_max$ = 16						; size = 4
_uv_min$ = 20						; size = 4
_uv_max$ = 24						; size = 4
_col$ = 28						; size = 4
_rounding$ = 32						; size = 4
_rounding_corners$ = 36					; size = 4
?AddImageRounded@ImDrawList@@QAEXPAXABUImVec2@@111IMH@Z PROC ; ImDrawList::AddImageRounded, COMDAT
; _this$ = ecx

; 1208 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00013	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1209 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 1c	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 05		 jne	 SHORT $LN2@AddImageRo

; 1210 :         return;

  00037	e9 fa 00 00 00	 jmp	 $LN1@AddImageRo
$LN2@AddImageRo:

; 1211 : 
; 1212 :     if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)

  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	0f 2f 45 20	 comiss	 xmm0, DWORD PTR _rounding$[ebp]
  00043	73 08		 jae	 SHORT $LN4@AddImageRo
  00045	8b 45 24	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  00048	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004b	75 25		 jne	 SHORT $LN3@AddImageRo
$LN4@AddImageRo:

; 1213 :     {
; 1214 :         AddImage(user_texture_id, p_min, p_max, uv_min, uv_max, col);

  0004d	8b 45 1c	 mov	 eax, DWORD PTR _col$[ebp]
  00050	50		 push	 eax
  00051	8b 4d 18	 mov	 ecx, DWORD PTR _uv_max$[ebp]
  00054	51		 push	 ecx
  00055	8b 55 14	 mov	 edx, DWORD PTR _uv_min$[ebp]
  00058	52		 push	 edx
  00059	8b 45 10	 mov	 eax, DWORD PTR _p_max$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _p_min$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 08	 mov	 edx, DWORD PTR _user_texture_id$[ebp]
  00064	52		 push	 edx
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 1215 :         return;

  0006d	e9 c4 00 00 00	 jmp	 $LN1@AddImageRo
$LN3@AddImageRo:

; 1216 :     }
; 1217 : 
; 1218 :     const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();

  00072	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00078	e8 00 00 00 00	 call	 ?empty@?$ImVector@PAX@@QBE_NXZ ; ImVector<void *>::empty
  0007d	0f b6 c0	 movzx	 eax, al
  00080	85 c0		 test	 eax, eax
  00082	75 1b		 jne	 SHORT $LN8@AddImageRo
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0008a	e8 00 00 00 00	 call	 ?back@?$ImVector@PAX@@QAEAAPAXXZ ; ImVector<void *>::back
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _user_texture_id$[ebp]
  00092	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00094	75 09		 jne	 SHORT $LN8@AddImageRo
  00096	c6 85 0f ff ff
	ff 00		 mov	 BYTE PTR tv85[ebp], 0
  0009d	eb 07		 jmp	 SHORT $LN9@AddImageRo
$LN8@AddImageRo:
  0009f	c6 85 0f ff ff
	ff 01		 mov	 BYTE PTR tv85[ebp], 1
$LN9@AddImageRo:
  000a6	8a 95 0f ff ff
	ff		 mov	 dl, BYTE PTR tv85[ebp]
  000ac	88 55 ef	 mov	 BYTE PTR _push_texture_id$[ebp], dl

; 1219 :     if (push_texture_id)

  000af	0f b6 45 ef	 movzx	 eax, BYTE PTR _push_texture_id$[ebp]
  000b3	85 c0		 test	 eax, eax
  000b5	74 0c		 je	 SHORT $LN5@AddImageRo

; 1220 :         PushTextureID(user_texture_id);

  000b7	8b 45 08	 mov	 eax, DWORD PTR _user_texture_id$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QAEXPAX@Z ; ImDrawList::PushTextureID
$LN5@AddImageRo:

; 1221 : 
; 1222 :     int vert_start_idx = VtxBuffer.Size;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000c9	89 4d e0	 mov	 DWORD PTR _vert_start_idx$[ebp], ecx

; 1223 :     PathRect(p_min, p_max, rounding, rounding_corners);

  000cc	8b 45 24	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  000cf	50		 push	 eax
  000d0	51		 push	 ecx
  000d1	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  000d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000db	8b 4d 10	 mov	 ecx, DWORD PTR _p_max$[ebp]
  000de	51		 push	 ecx
  000df	8b 55 0c	 mov	 edx, DWORD PTR _p_min$[ebp]
  000e2	52		 push	 edx
  000e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	e8 00 00 00 00	 call	 ?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ; ImDrawList::PathRect

; 1224 :     PathFillConvex(col);

  000eb	8b 45 1c	 mov	 eax, DWORD PTR _col$[ebp]
  000ee	50		 push	 eax
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex

; 1225 :     int vert_end_idx = VtxBuffer.Size;

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000fd	89 4d d4	 mov	 DWORD PTR _vert_end_idx$[ebp], ecx

; 1226 :     ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true);

  00100	6a 01		 push	 1
  00102	8b 45 18	 mov	 eax, DWORD PTR _uv_max$[ebp]
  00105	50		 push	 eax
  00106	8b 4d 14	 mov	 ecx, DWORD PTR _uv_min$[ebp]
  00109	51		 push	 ecx
  0010a	8b 55 10	 mov	 edx, DWORD PTR _p_max$[ebp]
  0010d	52		 push	 edx
  0010e	8b 45 0c	 mov	 eax, DWORD PTR _p_min$[ebp]
  00111	50		 push	 eax
  00112	8b 4d d4	 mov	 ecx, DWORD PTR _vert_end_idx$[ebp]
  00115	51		 push	 ecx
  00116	8b 55 e0	 mov	 edx, DWORD PTR _vert_start_idx$[ebp]
  00119	52		 push	 edx
  0011a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?ShadeVertsLinearUV@ImGui@@YAXPAUImDrawList@@HHABUImVec2@@111_N@Z ; ImGui::ShadeVertsLinearUV
  00123	83 c4 20	 add	 esp, 32			; 00000020H

; 1227 : 
; 1228 :     if (push_texture_id)

  00126	0f b6 45 ef	 movzx	 eax, BYTE PTR _push_texture_id$[ebp]
  0012a	85 c0		 test	 eax, eax
  0012c	74 08		 je	 SHORT $LN6@AddImageRo

; 1229 :         PopTextureID();

  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QAEXXZ ; ImDrawList::PopTextureID
$LN6@AddImageRo:
$LN1@AddImageRo:

; 1230 : }

  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx
  00139	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  0013f	3b ec		 cmp	 ebp, esp
  00141	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 20 00	 ret	 32			; 00000020H
?AddImageRounded@ImDrawList@@QAEXPAXABUImVec2@@111IMH@Z ENDP ; ImDrawList::AddImageRounded
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddImageQuad@ImDrawList@@QAEXPAXABUImVec2@@1111111I@Z
_TEXT	SEGMENT
tv75 = -217						; size = 1
_push_texture_id$ = -17					; size = 1
_this$ = -8						; size = 4
_user_texture_id$ = 8					; size = 4
_p1$ = 12						; size = 4
_p2$ = 16						; size = 4
_p3$ = 20						; size = 4
_p4$ = 24						; size = 4
_uv1$ = 28						; size = 4
_uv2$ = 32						; size = 4
_uv3$ = 36						; size = 4
_uv4$ = 40						; size = 4
_col$ = 44						; size = 4
?AddImageQuad@ImDrawList@@QAEXPAXABUImVec2@@1111111I@Z PROC ; ImDrawList::AddImageQuad, COMDAT
; _this$ = ecx

; 1192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1193 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 2c	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 05		 jne	 SHORT $LN2@AddImageQu

; 1194 :         return;

  00037	e9 99 00 00 00	 jmp	 $LN1@AddImageQu
$LN2@AddImageQu:

; 1195 : 
; 1196 :     const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00042	e8 00 00 00 00	 call	 ?empty@?$ImVector@PAX@@QBE_NXZ ; ImVector<void *>::empty
  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	75 1b		 jne	 SHORT $LN6@AddImageQu
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00054	e8 00 00 00 00	 call	 ?back@?$ImVector@PAX@@QAEAAPAXXZ ; ImVector<void *>::back
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _user_texture_id$[ebp]
  0005c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005e	75 09		 jne	 SHORT $LN6@AddImageQu
  00060	c6 85 27 ff ff
	ff 00		 mov	 BYTE PTR tv75[ebp], 0
  00067	eb 07		 jmp	 SHORT $LN7@AddImageQu
$LN6@AddImageQu:
  00069	c6 85 27 ff ff
	ff 01		 mov	 BYTE PTR tv75[ebp], 1
$LN7@AddImageQu:
  00070	8a 95 27 ff ff
	ff		 mov	 dl, BYTE PTR tv75[ebp]
  00076	88 55 ef	 mov	 BYTE PTR _push_texture_id$[ebp], dl

; 1197 :     if (push_texture_id)

  00079	0f b6 45 ef	 movzx	 eax, BYTE PTR _push_texture_id$[ebp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 0c		 je	 SHORT $LN3@AddImageQu

; 1198 :         PushTextureID(user_texture_id);

  00081	8b 45 08	 mov	 eax, DWORD PTR _user_texture_id$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QAEXPAX@Z ; ImDrawList::PushTextureID
$LN3@AddImageQu:

; 1199 : 
; 1200 :     PrimReserve(6, 4);

  0008d	6a 04		 push	 4
  0008f	6a 06		 push	 6
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 1201 :     PrimQuadUV(p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);

  00099	8b 45 2c	 mov	 eax, DWORD PTR _col$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 28	 mov	 ecx, DWORD PTR _uv4$[ebp]
  000a0	51		 push	 ecx
  000a1	8b 55 24	 mov	 edx, DWORD PTR _uv3$[ebp]
  000a4	52		 push	 edx
  000a5	8b 45 20	 mov	 eax, DWORD PTR _uv2$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 1c	 mov	 ecx, DWORD PTR _uv1$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 18	 mov	 edx, DWORD PTR _p4$[ebp]
  000b0	52		 push	 edx
  000b1	8b 45 14	 mov	 eax, DWORD PTR _p3$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d 10	 mov	 ecx, DWORD PTR _p2$[ebp]
  000b8	51		 push	 ecx
  000b9	8b 55 0c	 mov	 edx, DWORD PTR _p1$[ebp]
  000bc	52		 push	 edx
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z ; ImDrawList::PrimQuadUV

; 1202 : 
; 1203 :     if (push_texture_id)

  000c5	0f b6 45 ef	 movzx	 eax, BYTE PTR _push_texture_id$[ebp]
  000c9	85 c0		 test	 eax, eax
  000cb	74 08		 je	 SHORT $LN1@AddImageQu

; 1204 :         PopTextureID();

  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QAEXXZ ; ImDrawList::PopTextureID
$LN1@AddImageQu:

; 1205 : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000de	3b ec		 cmp	 ebp, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 28 00	 ret	 40			; 00000028H
?AddImageQuad@ImDrawList@@QAEXPAXABUImVec2@@1111111I@Z ENDP ; ImDrawList::AddImageQuad
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z
_TEXT	SEGMENT
tv75 = -217						; size = 1
_push_texture_id$ = -17					; size = 1
_this$ = -8						; size = 4
_user_texture_id$ = 8					; size = 4
_p_min$ = 12						; size = 4
_p_max$ = 16						; size = 4
_uv_min$ = 20						; size = 4
_uv_max$ = 24						; size = 4
_col$ = 28						; size = 4
?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z PROC	; ImDrawList::AddImage, COMDAT
; _this$ = ecx

; 1176 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1177 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 1c	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 05		 jne	 SHORT $LN2@AddImage

; 1178 :         return;

  00037	e9 89 00 00 00	 jmp	 $LN1@AddImage
$LN2@AddImage:

; 1179 : 
; 1180 :     const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00042	e8 00 00 00 00	 call	 ?empty@?$ImVector@PAX@@QBE_NXZ ; ImVector<void *>::empty
  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	75 1b		 jne	 SHORT $LN6@AddImage
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00054	e8 00 00 00 00	 call	 ?back@?$ImVector@PAX@@QAEAAPAXXZ ; ImVector<void *>::back
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _user_texture_id$[ebp]
  0005c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005e	75 09		 jne	 SHORT $LN6@AddImage
  00060	c6 85 27 ff ff
	ff 00		 mov	 BYTE PTR tv75[ebp], 0
  00067	eb 07		 jmp	 SHORT $LN7@AddImage
$LN6@AddImage:
  00069	c6 85 27 ff ff
	ff 01		 mov	 BYTE PTR tv75[ebp], 1
$LN7@AddImage:
  00070	8a 95 27 ff ff
	ff		 mov	 dl, BYTE PTR tv75[ebp]
  00076	88 55 ef	 mov	 BYTE PTR _push_texture_id$[ebp], dl

; 1181 :     if (push_texture_id)

  00079	0f b6 45 ef	 movzx	 eax, BYTE PTR _push_texture_id$[ebp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 0c		 je	 SHORT $LN3@AddImage

; 1182 :         PushTextureID(user_texture_id);

  00081	8b 45 08	 mov	 eax, DWORD PTR _user_texture_id$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QAEXPAX@Z ; ImDrawList::PushTextureID
$LN3@AddImage:

; 1183 : 
; 1184 :     PrimReserve(6, 4);

  0008d	6a 04		 push	 4
  0008f	6a 06		 push	 6
  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 1185 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

  00099	8b 45 1c	 mov	 eax, DWORD PTR _col$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 18	 mov	 ecx, DWORD PTR _uv_max$[ebp]
  000a0	51		 push	 ecx
  000a1	8b 55 14	 mov	 edx, DWORD PTR _uv_min$[ebp]
  000a4	52		 push	 edx
  000a5	8b 45 10	 mov	 eax, DWORD PTR _p_max$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _p_min$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1186 : 
; 1187 :     if (push_texture_id)

  000b5	0f b6 45 ef	 movzx	 eax, BYTE PTR _push_texture_id$[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	74 08		 je	 SHORT $LN1@AddImage

; 1188 :         PopTextureID();

  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QAEXXZ ; ImDrawList::PopTextureID
$LN1@AddImage:

; 1189 : }

  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000ce	3b ec		 cmp	 ebp, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 18 00	 ret	 24			; 00000018H
?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ENDP	; ImDrawList::AddImage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pos0$ = 8						; size = 4
_cp0$ = 12						; size = 4
_cp1$ = 16						; size = 4
_pos1$ = 20						; size = 4
_col$ = 24						; size = 4
_thickness$ = 28					; size = 4
_num_segments$ = 32					; size = 4
?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z PROC ; ImDrawList::AddBezierCurve, COMDAT
; _this$ = ecx

; 1132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1133 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 02		 jne	 SHORT $LN2@AddBezierC

; 1134 :         return;

  00037	eb 3d		 jmp	 SHORT $LN1@AddBezierC
$LN2@AddBezierC:

; 1135 : 
; 1136 :     PathLineTo(pos0);

  00039	8b 45 08	 mov	 eax, DWORD PTR _pos0$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1137 :     PathBezierCurveTo(cp0, cp1, pos1, num_segments);

  00045	8b 45 20	 mov	 eax, DWORD PTR _num_segments$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 14	 mov	 ecx, DWORD PTR _pos1$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 55 10	 mov	 edx, DWORD PTR _cp1$[ebp]
  00050	52		 push	 edx
  00051	8b 45 0c	 mov	 eax, DWORD PTR _cp0$[ebp]
  00054	50		 push	 eax
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z ; ImDrawList::PathBezierCurveTo

; 1138 :     PathStroke(col, false, thickness);

  0005d	51		 push	 ecx
  0005e	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	6a 00		 push	 0
  0006a	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN1@AddBezierC:

; 1139 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 1c 00	 ret	 28			; 0000001cH
?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z ENDP ; ImDrawList::AddBezierCurve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI@Z
_TEXT	SEGMENT
tv139 = -580						; size = 4
tv475 = -576						; size = 4
tv376 = -576						; size = 4
__$AllocaPad$$ = -376					; size = 4
_i$1 = -364						; size = 4
_i$2 = -352						; size = 4
_vtx_count$3 = -340					; size = 4
_idx_count$4 = -328					; size = 4
_inv_lensq$5 = -316					; size = 4
_d2$6 = -304						; size = 4
_dm_y$7 = -292						; size = 4
_dm_x$8 = -280						; size = 4
_n1$9 = -268						; size = 4
_n0$10 = -256						; size = 4
_i1$11 = -244						; size = 4
_i0$12 = -232						; size = 4
_inv_len$13 = -220					; size = 4
_d2$14 = -208						; size = 4
_dy$15 = -196						; size = 4
_dx$16 = -184						; size = 4
_p1$17 = -172						; size = 4
_p0$18 = -160						; size = 4
_i1$19 = -148						; size = 4
_i0$20 = -136						; size = 4
_temp_normals$21 = -124					; size = 4
_i$22 = -112						; size = 4
_vtx_outer_idx$23 = -100				; size = 4
_vtx_inner_idx$24 = -88					; size = 4
_vtx_count$25 = -76					; size = 4
_idx_count$26 = -64					; size = 4
_col_trans$27 = -52					; size = 4
_AA_SIZE$28 = -40					; size = 4
_uv$ = -28						; size = 8
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_points$ = 8						; size = 4
_points_count$ = 12					; size = 4
_col$ = 16						; size = 4
?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI@Z PROC ; ImDrawList::AddConvexPolyFilled, COMDAT
; _this$ = ecx

; 797  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 02 00
	00		 sub	 esp, 580		; 00000244H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd bc fd ff
	ff		 lea	 edi, DWORD PTR [ebp-580]
  00013	b9 91 00 00 00	 mov	 ecx, 145		; 00000091H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __$AllocaPad$$[ebp], 0
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 798  :     if (points_count < 3)

  00041	83 7d 0c 03	 cmp	 DWORD PTR _points_count$[ebp], 3
  00045	7d 05		 jge	 SHORT $LN17@AddConvexP

; 799  :         return;

  00047	e9 80 07 00 00	 jmp	 $LN1@AddConvexP
$LN17@AddConvexP:

; 800  : 
; 801  :     const ImVec2 uv = _Data->TexUvWhitePixel;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00057	89 55 e4	 mov	 DWORD PTR _uv$[ebp], edx
  0005a	89 45 e8	 mov	 DWORD PTR _uv$[ebp+4], eax

; 802  : 
; 803  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00063	83 e1 02	 and	 ecx, 2
  00066	0f 84 fa 05 00
	00		 je	 $LN18@AddConvexP

; 804  :     {
; 805  :         // Anti-aliased Fill
; 806  :         const float AA_SIZE = 1.0f;

  0006c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00074	f3 0f 11 45 d8	 movss	 DWORD PTR _AA_SIZE$28[ebp], xmm0

; 807  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;

  00079	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  0007c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00081	89 45 cc	 mov	 DWORD PTR _col_trans$27[ebp], eax

; 808  :         const int idx_count = (points_count-2)*3 + points_count*6;

  00084	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00087	83 e8 02	 sub	 eax, 2
  0008a	6b c8 03	 imul	 ecx, eax, 3
  0008d	6b 55 0c 06	 imul	 edx, DWORD PTR _points_count$[ebp], 6
  00091	03 ca		 add	 ecx, edx
  00093	89 4d c0	 mov	 DWORD PTR _idx_count$26[ebp], ecx

; 809  :         const int vtx_count = (points_count*2);

  00096	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00099	d1 e0		 shl	 eax, 1
  0009b	89 45 b4	 mov	 DWORD PTR _vtx_count$25[ebp], eax

; 810  :         PrimReserve(idx_count, vtx_count);

  0009e	8b 45 b4	 mov	 eax, DWORD PTR _vtx_count$25[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d c0	 mov	 ecx, DWORD PTR _idx_count$26[ebp]
  000a5	51		 push	 ecx
  000a6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 811  : 
; 812  :         // Add indexes for fill
; 813  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

  000ae	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b4	89 4d a8	 mov	 DWORD PTR _vtx_inner_idx$24[ebp], ecx

; 814  :         unsigned int vtx_outer_idx = _VtxCurrentIdx+1;

  000b7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000bd	83 c1 01	 add	 ecx, 1
  000c0	89 4d 9c	 mov	 DWORD PTR _vtx_outer_idx$23[ebp], ecx

; 815  :         for (int i = 2; i < points_count; i++)

  000c3	c7 45 90 02 00
	00 00		 mov	 DWORD PTR _i$22[ebp], 2
  000ca	eb 09		 jmp	 SHORT $LN4@AddConvexP
$LN2@AddConvexP:
  000cc	8b 45 90	 mov	 eax, DWORD PTR _i$22[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 90	 mov	 DWORD PTR _i$22[ebp], eax
$LN4@AddConvexP:
  000d5	8b 45 90	 mov	 eax, DWORD PTR _i$22[ebp]
  000d8	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  000db	7d 5d		 jge	 SHORT $LN3@AddConvexP

; 816  :         {
; 817  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));

  000dd	b8 02 00 00 00	 mov	 eax, 2
  000e2	6b c8 00	 imul	 ecx, eax, 0
  000e5	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  000eb	66 8b 55 a8	 mov	 dx, WORD PTR _vtx_inner_idx$24[ebp]
  000ef	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  000f3	8b 45 90	 mov	 eax, DWORD PTR _i$22[ebp]
  000f6	8b 4d a8	 mov	 ecx, DWORD PTR _vtx_inner_idx$24[ebp]
  000f9	8d 54 41 fe	 lea	 edx, DWORD PTR [ecx+eax*2-2]
  000fd	b8 02 00 00 00	 mov	 eax, 2
  00102	c1 e0 00	 shl	 eax, 0
  00105	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0010b	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx
  0010f	8b 45 90	 mov	 eax, DWORD PTR _i$22[ebp]
  00112	8b 4d a8	 mov	 ecx, DWORD PTR _vtx_inner_idx$24[ebp]
  00115	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00118	b8 02 00 00 00	 mov	 eax, 2
  0011d	d1 e0		 shl	 eax, 1
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00125	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx

; 818  :             _IdxWritePtr += 3;

  00129	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0012f	83 c1 06	 add	 ecx, 6
  00132	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00135	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 819  :         }

  00138	eb 92		 jmp	 SHORT $LN2@AddConvexP
$LN3@AddConvexP:

; 820  : 
; 821  :         // Compute normals
; 822  :         ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630

  0013a	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  0013d	c1 e0 03	 shl	 eax, 3
  00140	83 c0 24	 add	 eax, 36			; 00000024H
  00143	89 85 c0 fd ff
	ff		 mov	 DWORD PTR tv376[ebp], eax
  00149	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR tv376[ebp]
  0014f	e8 00 00 00 00	 call	 __alloca_probe_16
  00154	89 a5 bc fd ff
	ff		 mov	 DWORD PTR tv139[ebp], esp
  0015a	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR __$AllocaPad$$[ebp]
  00160	51		 push	 ecx
  00161	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR tv376[ebp]
  00167	8b 8d bc fd ff
	ff		 mov	 ecx, DWORD PTR tv139[ebp]
  0016d	e8 00 00 00 00	 call	 @_RTC_AllocaHelper@12
  00172	83 85 bc fd ff
	ff 20		 add	 DWORD PTR tv139[ebp], 32 ; 00000020H
  00179	8b 95 bc fd ff
	ff		 mov	 edx, DWORD PTR tv139[ebp]
  0017f	89 55 84	 mov	 DWORD PTR _temp_normals$21[ebp], edx

; 823  :         for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)

  00182	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00185	83 e8 01	 sub	 eax, 1
  00188	89 85 78 ff ff
	ff		 mov	 DWORD PTR _i0$20[ebp], eax
  0018e	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i1$19[ebp], 0
  00198	eb 1b		 jmp	 SHORT $LN7@AddConvexP
$LN5@AddConvexP:
  0019a	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i1$19[ebp]
  001a0	89 85 78 ff ff
	ff		 mov	 DWORD PTR _i0$20[ebp], eax
  001a6	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _i1$19[ebp]
  001ac	83 c1 01	 add	 ecx, 1
  001af	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _i1$19[ebp], ecx
$LN7@AddConvexP:
  001b5	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i1$19[ebp]
  001bb	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  001be	0f 8d 38 01 00
	00		 jge	 $LN6@AddConvexP

; 824  :         {
; 825  :             const ImVec2& p0 = points[i0];

  001c4	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i0$20[ebp]
  001ca	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  001cd	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  001d0	89 95 60 ff ff
	ff		 mov	 DWORD PTR _p0$18[ebp], edx

; 826  :             const ImVec2& p1 = points[i1];

  001d6	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i1$19[ebp]
  001dc	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  001df	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  001e2	89 95 54 ff ff
	ff		 mov	 DWORD PTR _p1$17[ebp], edx

; 827  :             float dx = p1.x - p0.x;

  001e8	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _p1$17[ebp]
  001ee	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _p0$18[ebp]
  001f4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001f8	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  001fc	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _dx$16[ebp], xmm0

; 828  :             float dy = p1.y - p0.y;

  00204	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _p1$17[ebp]
  0020a	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _p0$18[ebp]
  00210	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00215	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0021a	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _dy$15[ebp], xmm0

; 829  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00222	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _dx$16[ebp]
  0022a	f3 0f 59 85 48
	ff ff ff	 mulss	 xmm0, DWORD PTR _dx$16[ebp]
  00232	f3 0f 10 8d 3c
	ff ff ff	 movss	 xmm1, DWORD PTR _dy$15[ebp]
  0023a	f3 0f 59 8d 3c
	ff ff ff	 mulss	 xmm1, DWORD PTR _dy$15[ebp]
  00242	f3 0f 58 c1	 addss	 xmm0, xmm1
  00246	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _d2$14[ebp], xmm0
  0024e	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _d2$14[ebp]
  00256	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0025d	76 64		 jbe	 SHORT $LN20@AddConvexP
  0025f	51		 push	 ecx
  00260	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _d2$14[ebp]
  00268	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026d	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  00272	83 c4 04	 add	 esp, 4
  00275	d9 9d c0 fd ff
	ff		 fstp	 DWORD PTR tv475[ebp]
  0027b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00283	f3 0f 5e 85 c0
	fd ff ff	 divss	 xmm0, DWORD PTR tv475[ebp]
  0028b	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _inv_len$13[ebp], xmm0
  00293	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _dx$16[ebp]
  0029b	f3 0f 59 85 24
	ff ff ff	 mulss	 xmm0, DWORD PTR _inv_len$13[ebp]
  002a3	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _dx$16[ebp], xmm0
  002ab	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _dy$15[ebp]
  002b3	f3 0f 59 85 24
	ff ff ff	 mulss	 xmm0, DWORD PTR _inv_len$13[ebp]
  002bb	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _dy$15[ebp], xmm0
$LN20@AddConvexP:

; 830  :             temp_normals[i0].x = dy;

  002c3	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i0$20[ebp]
  002c9	8b 4d 84	 mov	 ecx, DWORD PTR _temp_normals$21[ebp]
  002cc	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _dy$15[ebp]
  002d4	f3 0f 11 04 c1	 movss	 DWORD PTR [ecx+eax*8], xmm0

; 831  :             temp_normals[i0].y = -dx;

  002d9	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _dx$16[ebp]
  002e1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002e8	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i0$20[ebp]
  002ee	8b 4d 84	 mov	 ecx, DWORD PTR _temp_normals$21[ebp]
  002f1	f3 0f 11 44 c1
	04		 movss	 DWORD PTR [ecx+eax*8+4], xmm0

; 832  :         }

  002f7	e9 9e fe ff ff	 jmp	 $LN5@AddConvexP
$LN6@AddConvexP:

; 833  : 
; 834  :         for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)

  002fc	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  002ff	83 e8 01	 sub	 eax, 1
  00302	89 85 18 ff ff
	ff		 mov	 DWORD PTR _i0$12[ebp], eax
  00308	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i1$11[ebp], 0
  00312	eb 1b		 jmp	 SHORT $LN10@AddConvexP
$LN8@AddConvexP:
  00314	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  0031a	89 85 18 ff ff
	ff		 mov	 DWORD PTR _i0$12[ebp], eax
  00320	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _i1$11[ebp]
  00326	83 c1 01	 add	 ecx, 1
  00329	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _i1$11[ebp], ecx
$LN10@AddConvexP:
  0032f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  00335	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  00338	0f 8d 13 03 00
	00		 jge	 $LN9@AddConvexP

; 835  :         {
; 836  :             // Average normals
; 837  :             const ImVec2& n0 = temp_normals[i0];

  0033e	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i0$12[ebp]
  00344	8b 4d 84	 mov	 ecx, DWORD PTR _temp_normals$21[ebp]
  00347	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0034a	89 95 00 ff ff
	ff		 mov	 DWORD PTR _n0$10[ebp], edx

; 838  :             const ImVec2& n1 = temp_normals[i1];

  00350	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  00356	8b 4d 84	 mov	 ecx, DWORD PTR _temp_normals$21[ebp]
  00359	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0035c	89 95 f4 fe ff
	ff		 mov	 DWORD PTR _n1$9[ebp], edx

; 839  :             float dm_x = (n0.x + n1.x) * 0.5f;

  00362	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _n0$10[ebp]
  00368	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n1$9[ebp]
  0036e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00372	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00376	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0037e	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _dm_x$8[ebp], xmm0

; 840  :             float dm_y = (n0.y + n1.y) * 0.5f;

  00386	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _n0$10[ebp]
  0038c	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _n1$9[ebp]
  00392	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00397	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0039c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  003a4	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _dm_y$7[ebp], xmm0

; 841  :             IM_FIXNORMAL2F(dm_x, dm_y);

  003ac	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_x$8[ebp]
  003b4	f3 0f 59 85 e8
	fe ff ff	 mulss	 xmm0, DWORD PTR _dm_x$8[ebp]
  003bc	f3 0f 10 8d dc
	fe ff ff	 movss	 xmm1, DWORD PTR _dm_y$7[ebp]
  003c4	f3 0f 59 8d dc
	fe ff ff	 mulss	 xmm1, DWORD PTR _dm_y$7[ebp]
  003cc	f3 0f 58 c1	 addss	 xmm0, xmm1
  003d0	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _d2$6[ebp], xmm0
  003d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  003e0	0f 2f 85 d0 fe
	ff ff		 comiss	 xmm0, DWORD PTR _d2$6[ebp]
  003e7	76 10		 jbe	 SHORT $LN21@AddConvexP
  003e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  003f1	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _d2$6[ebp], xmm0
$LN21@AddConvexP:
  003f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00401	f3 0f 5e 85 d0
	fe ff ff	 divss	 xmm0, DWORD PTR _d2$6[ebp]
  00409	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _inv_lensq$5[ebp], xmm0
  00411	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_x$8[ebp]
  00419	f3 0f 59 85 c4
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_lensq$5[ebp]
  00421	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _dm_x$8[ebp], xmm0
  00429	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_y$7[ebp]
  00431	f3 0f 59 85 c4
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_lensq$5[ebp]
  00439	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _dm_y$7[ebp], xmm0

; 842  :             dm_x *= AA_SIZE * 0.5f;

  00441	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_x$8[ebp]
  00449	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00451	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _dm_x$8[ebp], xmm0

; 843  :             dm_y *= AA_SIZE * 0.5f;

  00459	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_y$7[ebp]
  00461	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00469	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _dm_y$7[ebp], xmm0

; 844  : 
; 845  :             // Add vertices
; 846  :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

  00471	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  00477	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  0047a	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  0047f	f3 0f 5c 85 e8
	fe ff ff	 subss	 xmm0, DWORD PTR _dm_x$8[ebp]
  00487	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  0048c	6b c2 00	 imul	 eax, edx, 0
  0048f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00492	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00495	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0
  0049a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  004a0	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  004a3	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  004a9	f3 0f 5c 85 dc
	fe ff ff	 subss	 xmm0, DWORD PTR _dm_y$7[ebp]
  004b1	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  004b6	6b c2 00	 imul	 eax, edx, 0
  004b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  004bc	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  004bf	f3 0f 11 44 02
	04		 movss	 DWORD PTR [edx+eax+4], xmm0
  004c5	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  004ca	6b c8 00	 imul	 ecx, eax, 0
  004cd	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  004d0	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  004d3	8b 55 e4	 mov	 edx, DWORD PTR _uv$[ebp]
  004d6	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  004da	8b 55 e8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  004dd	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  004e1	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  004e6	6b c8 00	 imul	 ecx, eax, 0
  004e9	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  004ec	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  004ef	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  004f2	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 847  :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer

  004f6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  004fc	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  004ff	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  00504	f3 0f 58 85 e8
	fe ff ff	 addss	 xmm0, DWORD PTR _dm_x$8[ebp]
  0050c	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00511	c1 e2 00	 shl	 edx, 0
  00514	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00517	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0051a	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  0051f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  00525	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00528	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  0052e	f3 0f 58 85 dc
	fe ff ff	 addss	 xmm0, DWORD PTR _dm_y$7[ebp]
  00536	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  0053b	c1 e2 00	 shl	 edx, 0
  0053e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00541	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00544	f3 0f 11 44 11
	04		 movss	 DWORD PTR [ecx+edx+4], xmm0
  0054a	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0054f	c1 e0 00	 shl	 eax, 0
  00552	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00555	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00558	8b 4d e4	 mov	 ecx, DWORD PTR _uv$[ebp]
  0055b	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  0055f	8b 4d e8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  00562	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  00566	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0056b	c1 e0 00	 shl	 eax, 0
  0056e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00571	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00574	8b 4d cc	 mov	 ecx, DWORD PTR _col_trans$27[ebp]
  00577	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 848  :             _VtxWritePtr += 2;

  0057b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0057e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00581	83 c1 28	 add	 ecx, 40			; 00000028H
  00584	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00587	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 849  : 
; 850  :             // Add indexes for fringes
; 851  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));

  0058a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  00590	8b 4d a8	 mov	 ecx, DWORD PTR _vtx_inner_idx$24[ebp]
  00593	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00596	b8 02 00 00 00	 mov	 eax, 2
  0059b	6b c8 00	 imul	 ecx, eax, 0
  0059e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  005a1	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  005a4	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  005a8	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i0$12[ebp]
  005ae	8b 4d a8	 mov	 ecx, DWORD PTR _vtx_inner_idx$24[ebp]
  005b1	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  005b4	b8 02 00 00 00	 mov	 eax, 2
  005b9	c1 e0 00	 shl	 eax, 0
  005bc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  005bf	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  005c2	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx
  005c6	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i0$12[ebp]
  005cc	8b 4d 9c	 mov	 ecx, DWORD PTR _vtx_outer_idx$23[ebp]
  005cf	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  005d2	b8 02 00 00 00	 mov	 eax, 2
  005d7	d1 e0		 shl	 eax, 1
  005d9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  005dc	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  005df	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx

; 852  :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));

  005e3	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i0$12[ebp]
  005e9	8b 4d 9c	 mov	 ecx, DWORD PTR _vtx_outer_idx$23[ebp]
  005ec	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  005ef	b8 02 00 00 00	 mov	 eax, 2
  005f4	6b c8 03	 imul	 ecx, eax, 3
  005f7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  005fa	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  005fd	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00601	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  00607	8b 4d 9c	 mov	 ecx, DWORD PTR _vtx_outer_idx$23[ebp]
  0060a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0060d	b8 02 00 00 00	 mov	 eax, 2
  00612	c1 e0 02	 shl	 eax, 2
  00615	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00618	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0061b	66 89 14 08	 mov	 WORD PTR [eax+ecx], dx
  0061f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _i1$11[ebp]
  00625	8b 4d a8	 mov	 ecx, DWORD PTR _vtx_inner_idx$24[ebp]
  00628	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0062b	b8 02 00 00 00	 mov	 eax, 2
  00630	6b c8 05	 imul	 ecx, eax, 5
  00633	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00636	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00639	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 853  :             _IdxWritePtr += 6;

  0063d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00640	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00643	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00646	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00649	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 854  :         }

  0064c	e9 c3 fc ff ff	 jmp	 $LN8@AddConvexP
$LN9@AddConvexP:

; 855  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  00651	0f b7 45 b4	 movzx	 eax, WORD PTR _vtx_count$25[ebp]
  00655	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00658	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  0065b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0065e	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 856  :     }

  00661	e9 66 01 00 00	 jmp	 $LN19@AddConvexP
$LN18@AddConvexP:

; 857  :     else
; 858  :     {
; 859  :         // Non Anti-aliased Fill
; 860  :         const int idx_count = (points_count-2)*3;

  00666	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00669	83 e8 02	 sub	 eax, 2
  0066c	6b c8 03	 imul	 ecx, eax, 3
  0066f	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _idx_count$4[ebp], ecx

; 861  :         const int vtx_count = points_count;

  00675	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00678	89 85 ac fe ff
	ff		 mov	 DWORD PTR _vtx_count$3[ebp], eax

; 862  :         PrimReserve(idx_count, vtx_count);

  0067e	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _vtx_count$3[ebp]
  00684	50		 push	 eax
  00685	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _idx_count$4[ebp]
  0068b	51		 push	 ecx
  0068c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0068f	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 863  :         for (int i = 0; i < vtx_count; i++)

  00694	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$2[ebp], 0
  0069e	eb 0f		 jmp	 SHORT $LN13@AddConvexP
$LN11@AddConvexP:
  006a0	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  006a6	83 c0 01	 add	 eax, 1
  006a9	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _i$2[ebp], eax
$LN13@AddConvexP:
  006af	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  006b5	3b 85 ac fe ff
	ff		 cmp	 eax, DWORD PTR _vtx_count$3[ebp]
  006bb	7d 6a		 jge	 SHORT $LN12@AddConvexP

; 864  :         {
; 865  :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

  006bd	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  006c3	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  006c6	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  006c9	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  006cd	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  006d2	6b c9 00	 imul	 ecx, ecx, 0
  006d5	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  006d8	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  006db	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  006de	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  006e2	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  006e7	6b c8 00	 imul	 ecx, eax, 0
  006ea	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  006ed	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  006f0	8b 55 e4	 mov	 edx, DWORD PTR _uv$[ebp]
  006f3	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  006f7	8b 55 e8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  006fa	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  006fe	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00703	6b c8 00	 imul	 ecx, eax, 0
  00706	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00709	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0070c	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  0070f	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 866  :             _VtxWritePtr++;

  00713	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00716	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00719	83 c1 14	 add	 ecx, 20			; 00000014H
  0071c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0071f	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 867  :         }

  00722	e9 79 ff ff ff	 jmp	 $LN11@AddConvexP
$LN12@AddConvexP:

; 868  :         for (int i = 2; i < points_count; i++)

  00727	c7 85 94 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _i$1[ebp], 2
  00731	eb 0f		 jmp	 SHORT $LN16@AddConvexP
$LN14@AddConvexP:
  00733	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00739	83 c0 01	 add	 eax, 1
  0073c	89 85 94 fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN16@AddConvexP:
  00742	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00748	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  0074b	7d 6c		 jge	 SHORT $LN15@AddConvexP

; 869  :         {
; 870  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);

  0074d	b8 02 00 00 00	 mov	 eax, 2
  00752	6b c8 00	 imul	 ecx, eax, 0
  00755	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00758	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0075b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0075e	66 8b 52 34	 mov	 dx, WORD PTR [edx+52]
  00762	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00766	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00769	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0076c	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _i$1[ebp]
  00772	8d 44 11 ff	 lea	 eax, DWORD PTR [ecx+edx-1]
  00776	b9 02 00 00 00	 mov	 ecx, 2
  0077b	c1 e1 00	 shl	 ecx, 0
  0077e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00781	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  00784	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  00788	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0078b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0078e	03 8d 94 fe ff
	ff		 add	 ecx, DWORD PTR _i$1[ebp]
  00794	ba 02 00 00 00	 mov	 edx, 2
  00799	d1 e2		 shl	 edx, 1
  0079b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0079e	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  007a1	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx

; 871  :             _IdxWritePtr += 3;

  007a5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  007a8	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  007ab	83 c1 06	 add	 ecx, 6
  007ae	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  007b1	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 872  :         }

  007b4	e9 7a ff ff ff	 jmp	 $LN14@AddConvexP
$LN15@AddConvexP:

; 873  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  007b9	0f b7 85 ac fe
	ff ff		 movzx	 eax, WORD PTR _vtx_count$3[ebp]
  007c0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  007c3	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  007c6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  007c9	89 42 34	 mov	 DWORD PTR [edx+52], eax
$LN19@AddConvexP:
$LN1@AddConvexP:

; 874  :     }
; 875  : }

  007cc	52		 push	 edx
  007cd	8b cd		 mov	 ecx, ebp
  007cf	50		 push	 eax
  007d0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@AddConvexP
  007d6	ff b5 88 fe ff
	ff		 push	 DWORD PTR __$AllocaPad$$[ebp]
  007dc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars2@12
  007e1	58		 pop	 eax
  007e2	5a		 pop	 edx
  007e3	8d a5 b0 fd ff
	ff		 lea	 esp, DWORD PTR [ebp-592]
  007e9	5f		 pop	 edi
  007ea	5e		 pop	 esi
  007eb	5b		 pop	 ebx
  007ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ef	33 cd		 xor	 ecx, ebp
  007f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f6	8b e5		 mov	 esp, ebp
  007f8	5d		 pop	 ebp
  007f9	c2 0c 00	 ret	 12			; 0000000cH
$LN26@AddConvexP:
  007fc	02 00 00 00	 DD	 2
  00800	00 00 00 00	 DD	 $LN25@AddConvexP
$LN25@AddConvexP:
  00804	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00808	08 00 00 00	 DD	 8
  0080c	00 00 00 00	 DD	 $LN23@AddConvexP
  00810	88 fe ff ff	 DD	 -376			; fffffe88H
  00814	04 00 00 00	 DD	 4
  00818	00 00 00 00	 DD	 $LN24@AddConvexP
$LN24@AddConvexP:
  0081c	5f		 DB	 95			; 0000005fH
  0081d	24		 DB	 36			; 00000024H
  0081e	41		 DB	 65			; 00000041H
  0081f	6c		 DB	 108			; 0000006cH
  00820	6c		 DB	 108			; 0000006cH
  00821	6f		 DB	 111			; 0000006fH
  00822	63		 DB	 99			; 00000063H
  00823	61		 DB	 97			; 00000061H
  00824	50		 DB	 80			; 00000050H
  00825	61		 DB	 97			; 00000061H
  00826	64		 DB	 100			; 00000064H
  00827	24		 DB	 36			; 00000024H
  00828	00		 DB	 0
$LN23@AddConvexP:
  00829	75		 DB	 117			; 00000075H
  0082a	76		 DB	 118			; 00000076H
  0082b	00		 DB	 0
?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI@Z ENDP ; ImDrawList::AddConvexPolyFilled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM@Z
_TEXT	SEGMENT
tv129 = -1604						; size = 4
tv1068 = -1600						; size = 4
tv1850 = -1596						; size = 4
tv1242 = -1596						; size = 4
tv914 = -1596						; size = 4
tv619 = -1596						; size = 4
tv614 = -1596						; size = 4
tv294 = -1596						; size = 4
tv289 = -1596						; size = 4
tv137 = -1596						; size = 4
tv93 = -1596						; size = 4
tv86 = -1596						; size = 4
tv81 = -1596						; size = 4
tv72 = -1593						; size = 1
$T1 = -1588						; size = 8
$T2 = -1572						; size = 8
$T3 = -1556						; size = 8
$T4 = -1540						; size = 8
$T5 = -1524						; size = 8
$T6 = -1508						; size = 8
$T7 = -1492						; size = 8
$T8 = -1476						; size = 8
$T9 = -1460						; size = 8
$T10 = -1444						; size = 8
$T11 = -1428						; size = 8
$T12 = -1412						; size = 8
$T13 = -1396						; size = 8
$T14 = -1380						; size = 8
$T15 = -1364						; size = 8
$T16 = -1348						; size = 8
$T17 = -1332						; size = 8
$T18 = -1316						; size = 8
$T19 = -1300						; size = 8
$T20 = -1284						; size = 8
$T21 = -1268						; size = 8
$T22 = -1252						; size = 8
$T23 = -1236						; size = 8
$T24 = -1220						; size = 8
__$AllocaPad$$ = -628					; size = 4
_inv_len$25 = -616					; size = 4
_d2$26 = -604						; size = 4
_dy$27 = -592						; size = 4
_dx$28 = -580						; size = 4
_p2$29 = -568						; size = 4
_p1$30 = -556						; size = 4
_i2$31 = -544						; size = 4
_i1$32 = -532						; size = 4
_vtx_count$33 = -520					; size = 4
_idx_count$34 = -508					; size = 4
_i$35 = -496						; size = 4
_out_vtx$36 = -484					; size = 4
_dm_in_y$37 = -472					; size = 4
_dm_in_x$38 = -460					; size = 4
_dm_out_y$39 = -448					; size = 4
_dm_out_x$40 = -436					; size = 4
_inv_lensq$41 = -424					; size = 4
_d2$42 = -412						; size = 4
_dm_y$43 = -400						; size = 4
_dm_x$44 = -388						; size = 4
_idx2$45 = -376						; size = 4
_i2$46 = -364						; size = 4
_i1$47 = -352						; size = 4
_idx1$48 = -340						; size = 4
_half_inner_thickness$49 = -328				; size = 4
_i$50 = -316						; size = 4
_out_vtx$51 = -304					; size = 4
_inv_lensq$52 = -292					; size = 4
_d2$53 = -280						; size = 4
_dm_y$54 = -268						; size = 4
_dm_x$55 = -256						; size = 4
_idx2$56 = -244						; size = 4
_i2$57 = -232						; size = 4
_i1$58 = -220						; size = 4
_idx1$59 = -208						; size = 4
_inv_len$60 = -196					; size = 4
_d2$61 = -184						; size = 4
_dy$62 = -172						; size = 4
_dx$63 = -160						; size = 4
_i2$64 = -148						; size = 4
_i1$65 = -136						; size = 4
_temp_points$66 = -124					; size = 4
_temp_normals$67 = -112					; size = 4
_vtx_count$68 = -100					; size = 4
_idx_count$69 = -88					; size = 4
_col_trans$70 = -76					; size = 4
_AA_SIZE$71 = -64					; size = 4
_thick_line$ = -49					; size = 1
_count$ = -40						; size = 4
_uv$ = -28						; size = 8
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_points$ = 8						; size = 4
_points_count$ = 12					; size = 4
_col$ = 16						; size = 4
_closed$ = 20						; size = 1
_thickness$ = 24					; size = 4
?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM@Z PROC	; ImDrawList::AddPolyline, COMDAT
; _this$ = ecx

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 06 00
	00		 sub	 esp, 1604		; 00000644H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd bc f9 ff
	ff		 lea	 edi, DWORD PTR [ebp-1604]
  00013	b9 91 01 00 00	 mov	 ecx, 401		; 00000191H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 85 8c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR __$AllocaPad$$[ebp], 0
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 610  :     if (points_count < 2)

  00041	83 7d 0c 02	 cmp	 DWORD PTR _points_count$[ebp], 2
  00045	7d 05		 jge	 SHORT $LN20@AddPolylin

; 611  :         return;

  00047	e9 5c 18 00 00	 jmp	 $LN1@AddPolylin
$LN20@AddPolylin:

; 612  : 
; 613  :     const ImVec2 uv = _Data->TexUvWhitePixel;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00057	89 55 e4	 mov	 DWORD PTR _uv$[ebp], edx
  0005a	89 45 e8	 mov	 DWORD PTR _uv$[ebp+4], eax

; 614  : 
; 615  :     int count = points_count;

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00060	89 45 d8	 mov	 DWORD PTR _count$[ebp], eax

; 616  :     if (!closed)

  00063	0f b6 45 14	 movzx	 eax, BYTE PTR _closed$[ebp]
  00067	85 c0		 test	 eax, eax
  00069	75 09		 jne	 SHORT $LN21@AddPolylin

; 617  :         count = points_count-1;

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  0006e	83 e8 01	 sub	 eax, 1
  00071	89 45 d8	 mov	 DWORD PTR _count$[ebp], eax
$LN21@AddPolylin:

; 618  : 
; 619  :     const bool thick_line = thickness > 1.0f;

  00074	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  00079	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00080	76 09		 jbe	 SHORT $LN34@AddPolylin
  00082	c6 85 c7 f9 ff
	ff 01		 mov	 BYTE PTR tv72[ebp], 1
  00089	eb 07		 jmp	 SHORT $LN35@AddPolylin
$LN34@AddPolylin:
  0008b	c6 85 c7 f9 ff
	ff 00		 mov	 BYTE PTR tv72[ebp], 0
$LN35@AddPolylin:
  00092	8a 85 c7 f9 ff
	ff		 mov	 al, BYTE PTR tv72[ebp]
  00098	88 45 cf	 mov	 BYTE PTR _thick_line$[ebp], al

; 620  :     if (Flags & ImDrawListFlags_AntiAliasedLines)

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000a1	83 e1 01	 and	 ecx, 1
  000a4	0f 84 7b 13 00
	00		 je	 $LN22@AddPolylin

; 621  :     {
; 622  :         // Anti-aliased stroke
; 623  :         const float AA_SIZE = 1.0f;

  000aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b2	f3 0f 11 45 c0	 movss	 DWORD PTR _AA_SIZE$71[ebp], xmm0

; 624  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;

  000b7	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  000ba	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000bf	89 45 b4	 mov	 DWORD PTR _col_trans$70[ebp], eax

; 625  : 
; 626  :         const int idx_count = thick_line ? count*18 : count*12;

  000c2	0f b6 45 cf	 movzx	 eax, BYTE PTR _thick_line$[ebp]
  000c6	85 c0		 test	 eax, eax
  000c8	74 0c		 je	 SHORT $LN36@AddPolylin
  000ca	6b 4d d8 12	 imul	 ecx, DWORD PTR _count$[ebp], 18
  000ce	89 8d c4 f9 ff
	ff		 mov	 DWORD PTR tv81[ebp], ecx
  000d4	eb 0a		 jmp	 SHORT $LN37@AddPolylin
$LN36@AddPolylin:
  000d6	6b 55 d8 0c	 imul	 edx, DWORD PTR _count$[ebp], 12
  000da	89 95 c4 f9 ff
	ff		 mov	 DWORD PTR tv81[ebp], edx
$LN37@AddPolylin:
  000e0	8b 85 c4 f9 ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  000e6	89 45 a8	 mov	 DWORD PTR _idx_count$69[ebp], eax

; 627  :         const int vtx_count = thick_line ? points_count*4 : points_count*3;

  000e9	0f b6 45 cf	 movzx	 eax, BYTE PTR _thick_line$[ebp]
  000ed	85 c0		 test	 eax, eax
  000ef	74 0e		 je	 SHORT $LN38@AddPolylin
  000f1	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  000f4	c1 e1 02	 shl	 ecx, 2
  000f7	89 8d c4 f9 ff
	ff		 mov	 DWORD PTR tv86[ebp], ecx
  000fd	eb 0a		 jmp	 SHORT $LN39@AddPolylin
$LN38@AddPolylin:
  000ff	6b 55 0c 03	 imul	 edx, DWORD PTR _points_count$[ebp], 3
  00103	89 95 c4 f9 ff
	ff		 mov	 DWORD PTR tv86[ebp], edx
$LN39@AddPolylin:
  00109	8b 85 c4 f9 ff
	ff		 mov	 eax, DWORD PTR tv86[ebp]
  0010f	89 45 9c	 mov	 DWORD PTR _vtx_count$68[ebp], eax

; 628  :         PrimReserve(idx_count, vtx_count);

  00112	8b 45 9c	 mov	 eax, DWORD PTR _vtx_count$68[ebp]
  00115	50		 push	 eax
  00116	8b 4d a8	 mov	 ecx, DWORD PTR _idx_count$69[ebp]
  00119	51		 push	 ecx
  0011a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 629  : 
; 630  :         // Temporary buffer
; 631  :         ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2)); //-V630

  00122	0f b6 45 cf	 movzx	 eax, BYTE PTR _thick_line$[ebp]
  00126	85 c0		 test	 eax, eax
  00128	74 0c		 je	 SHORT $LN40@AddPolylin
  0012a	c7 85 c4 f9 ff
	ff 05 00 00 00	 mov	 DWORD PTR tv93[ebp], 5
  00134	eb 0a		 jmp	 SHORT $LN41@AddPolylin
$LN40@AddPolylin:
  00136	c7 85 c4 f9 ff
	ff 03 00 00 00	 mov	 DWORD PTR tv93[ebp], 3
$LN41@AddPolylin:
  00140	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00143	0f af 8d c4 f9
	ff ff		 imul	 ecx, DWORD PTR tv93[ebp]
  0014a	c1 e1 03	 shl	 ecx, 3
  0014d	83 c1 24	 add	 ecx, 36			; 00000024H
  00150	89 8d c0 f9 ff
	ff		 mov	 DWORD PTR tv1068[ebp], ecx
  00156	8b 85 c0 f9 ff
	ff		 mov	 eax, DWORD PTR tv1068[ebp]
  0015c	e8 00 00 00 00	 call	 __alloca_probe_16
  00161	89 a5 bc f9 ff
	ff		 mov	 DWORD PTR tv129[ebp], esp
  00167	8d 95 8c fd ff
	ff		 lea	 edx, DWORD PTR __$AllocaPad$$[ebp]
  0016d	52		 push	 edx
  0016e	8b 95 c0 f9 ff
	ff		 mov	 edx, DWORD PTR tv1068[ebp]
  00174	8b 8d bc f9 ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  0017a	e8 00 00 00 00	 call	 @_RTC_AllocaHelper@12
  0017f	83 85 bc f9 ff
	ff 20		 add	 DWORD PTR tv129[ebp], 32 ; 00000020H
  00186	8b 85 bc f9 ff
	ff		 mov	 eax, DWORD PTR tv129[ebp]
  0018c	89 45 90	 mov	 DWORD PTR _temp_normals$67[ebp], eax

; 632  :         ImVec2* temp_points = temp_normals + points_count;

  0018f	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00192	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00195	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00198	89 55 84	 mov	 DWORD PTR _temp_points$66[ebp], edx

; 633  : 
; 634  :         for (int i1 = 0; i1 < count; i1++)

  0019b	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i1$65[ebp], 0
  001a5	eb 0f		 jmp	 SHORT $LN4@AddPolylin
$LN2@AddPolylin:
  001a7	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i1$65[ebp]
  001ad	83 c0 01	 add	 eax, 1
  001b0	89 85 78 ff ff
	ff		 mov	 DWORD PTR _i1$65[ebp], eax
$LN4@AddPolylin:
  001b6	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i1$65[ebp]
  001bc	3b 45 d8	 cmp	 eax, DWORD PTR _count$[ebp]
  001bf	0f 8d 59 01 00
	00		 jge	 $LN3@AddPolylin

; 635  :         {
; 636  :             const int i2 = (i1+1) == points_count ? 0 : i1+1;

  001c5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i1$65[ebp]
  001cb	83 c0 01	 add	 eax, 1
  001ce	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  001d1	75 0c		 jne	 SHORT $LN42@AddPolylin
  001d3	c7 85 c4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv137[ebp], 0
  001dd	eb 0f		 jmp	 SHORT $LN43@AddPolylin
$LN42@AddPolylin:
  001df	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _i1$65[ebp]
  001e5	83 c1 01	 add	 ecx, 1
  001e8	89 8d c4 f9 ff
	ff		 mov	 DWORD PTR tv137[ebp], ecx
$LN43@AddPolylin:
  001ee	8b 95 c4 f9 ff
	ff		 mov	 edx, DWORD PTR tv137[ebp]
  001f4	89 95 6c ff ff
	ff		 mov	 DWORD PTR _i2$64[ebp], edx

; 637  :             float dx = points[i2].x - points[i1].x;

  001fa	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i2$64[ebp]
  00200	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00203	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _i1$65[ebp]
  00209	8b 75 08	 mov	 esi, DWORD PTR _points$[ebp]
  0020c	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  00211	f3 0f 5c 04 d6	 subss	 xmm0, DWORD PTR [esi+edx*8]
  00216	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _dx$63[ebp], xmm0

; 638  :             float dy = points[i2].y - points[i1].y;

  0021e	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i2$64[ebp]
  00224	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00227	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _i1$65[ebp]
  0022d	8b 75 08	 mov	 esi, DWORD PTR _points$[ebp]
  00230	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00236	f3 0f 5c 44 d6
	04		 subss	 xmm0, DWORD PTR [esi+edx*8+4]
  0023c	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _dy$62[ebp], xmm0

; 639  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00244	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _dx$63[ebp]
  0024c	f3 0f 59 85 60
	ff ff ff	 mulss	 xmm0, DWORD PTR _dx$63[ebp]
  00254	f3 0f 10 8d 54
	ff ff ff	 movss	 xmm1, DWORD PTR _dy$62[ebp]
  0025c	f3 0f 59 8d 54
	ff ff ff	 mulss	 xmm1, DWORD PTR _dy$62[ebp]
  00264	f3 0f 58 c1	 addss	 xmm0, xmm1
  00268	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _d2$61[ebp], xmm0
  00270	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _d2$61[ebp]
  00278	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0027f	76 64		 jbe	 SHORT $LN24@AddPolylin
  00281	51		 push	 ecx
  00282	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _d2$61[ebp]
  0028a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028f	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  00294	83 c4 04	 add	 esp, 4
  00297	d9 9d c4 f9 ff
	ff		 fstp	 DWORD PTR tv1242[ebp]
  0029d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002a5	f3 0f 5e 85 c4
	f9 ff ff	 divss	 xmm0, DWORD PTR tv1242[ebp]
  002ad	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _inv_len$60[ebp], xmm0
  002b5	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _dx$63[ebp]
  002bd	f3 0f 59 85 3c
	ff ff ff	 mulss	 xmm0, DWORD PTR _inv_len$60[ebp]
  002c5	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _dx$63[ebp], xmm0
  002cd	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _dy$62[ebp]
  002d5	f3 0f 59 85 3c
	ff ff ff	 mulss	 xmm0, DWORD PTR _inv_len$60[ebp]
  002dd	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _dy$62[ebp], xmm0
$LN24@AddPolylin:

; 640  :             temp_normals[i1].x = dy;

  002e5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i1$65[ebp]
  002eb	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  002ee	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _dy$62[ebp]
  002f6	f3 0f 11 04 c1	 movss	 DWORD PTR [ecx+eax*8], xmm0

; 641  :             temp_normals[i1].y = -dx;

  002fb	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _dx$63[ebp]
  00303	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0030a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _i1$65[ebp]
  00310	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00313	f3 0f 11 44 c1
	04		 movss	 DWORD PTR [ecx+eax*8+4], xmm0

; 642  :         }

  00319	e9 89 fe ff ff	 jmp	 $LN2@AddPolylin
$LN3@AddPolylin:

; 643  :         if (!closed)

  0031e	0f b6 45 14	 movzx	 eax, BYTE PTR _closed$[ebp]
  00322	85 c0		 test	 eax, eax
  00324	75 1c		 jne	 SHORT $LN25@AddPolylin

; 644  :             temp_normals[points_count-1] = temp_normals[points_count-2];

  00326	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00329	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  0032c	8b 54 c1 f0	 mov	 edx, DWORD PTR [ecx+eax*8-16]
  00330	8b 44 c1 f4	 mov	 eax, DWORD PTR [ecx+eax*8-12]
  00334	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00337	8b 75 90	 mov	 esi, DWORD PTR _temp_normals$67[ebp]
  0033a	89 54 ce f8	 mov	 DWORD PTR [esi+ecx*8-8], edx
  0033e	89 44 ce fc	 mov	 DWORD PTR [esi+ecx*8-4], eax
$LN25@AddPolylin:

; 645  : 
; 646  :         if (!thick_line)

  00342	0f b6 45 cf	 movzx	 eax, BYTE PTR _thick_line$[ebp]
  00346	85 c0		 test	 eax, eax
  00348	0f 85 92 06 00
	00		 jne	 $LN26@AddPolylin

; 647  :         {
; 648  :             if (!closed)

  0034e	0f b6 45 14	 movzx	 eax, BYTE PTR _closed$[ebp]
  00352	85 c0		 test	 eax, eax
  00354	0f 85 6b 01 00
	00		 jne	 $LN28@AddPolylin

; 649  :             {
; 650  :                 temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;

  0035a	51		 push	 ecx
  0035b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00363	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00368	b8 08 00 00 00	 mov	 eax, 8
  0036d	6b c8 00	 imul	 ecx, eax, 0
  00370	03 4d 90	 add	 ecx, DWORD PTR _temp_normals$67[ebp]
  00373	51		 push	 ecx
  00374	8d 95 3c fb ff
	ff		 lea	 edx, DWORD PTR $T24[ebp]
  0037a	52		 push	 edx
  0037b	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00380	83 c4 0c	 add	 esp, 12			; 0000000cH
  00383	50		 push	 eax
  00384	b8 08 00 00 00	 mov	 eax, 8
  00389	6b c8 00	 imul	 ecx, eax, 0
  0038c	03 4d 08	 add	 ecx, DWORD PTR _points$[ebp]
  0038f	51		 push	 ecx
  00390	8d 95 2c fb ff
	ff		 lea	 edx, DWORD PTR $T23[ebp]
  00396	52		 push	 edx
  00397	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  0039c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0039f	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003a4	b8 08 00 00 00	 mov	 eax, 8
  003a9	6b c0 00	 imul	 eax, eax, 0
  003ac	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  003af	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  003b2	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 651  :                 temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;

  003b6	51		 push	 ecx
  003b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c4	b8 08 00 00 00	 mov	 eax, 8
  003c9	6b c8 00	 imul	 ecx, eax, 0
  003cc	03 4d 90	 add	 ecx, DWORD PTR _temp_normals$67[ebp]
  003cf	51		 push	 ecx
  003d0	8d 95 1c fb ff
	ff		 lea	 edx, DWORD PTR $T22[ebp]
  003d6	52		 push	 edx
  003d7	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  003dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  003df	50		 push	 eax
  003e0	b8 08 00 00 00	 mov	 eax, 8
  003e5	6b c8 00	 imul	 ecx, eax, 0
  003e8	03 4d 08	 add	 ecx, DWORD PTR _points$[ebp]
  003eb	51		 push	 ecx
  003ec	8d 95 0c fb ff
	ff		 lea	 edx, DWORD PTR $T21[ebp]
  003f2	52		 push	 edx
  003f3	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  003f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  003fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00400	b8 08 00 00 00	 mov	 eax, 8
  00405	c1 e0 00	 shl	 eax, 0
  00408	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  0040b	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  0040e	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 652  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;

  00412	51		 push	 ecx
  00413	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0041b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00420	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00423	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00426	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  0042a	52		 push	 edx
  0042b	8d 85 fc fa ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  00431	50		 push	 eax
  00432	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00437	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043a	50		 push	 eax
  0043b	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  0043e	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  00441	8d 44 ca f8	 lea	 eax, DWORD PTR [edx+ecx*8-8]
  00445	50		 push	 eax
  00446	8d 8d ec fa ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  0044c	51		 push	 ecx
  0044d	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00452	83 c4 0c	 add	 esp, 12			; 0000000cH
  00455	8b 10		 mov	 edx, DWORD PTR [eax]
  00457	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0045a	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  0045d	8d 4c 09 fe	 lea	 ecx, DWORD PTR [ecx+ecx-2]
  00461	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00464	89 14 ce	 mov	 DWORD PTR [esi+ecx*8], edx
  00467	89 44 ce 04	 mov	 DWORD PTR [esi+ecx*8+4], eax

; 653  :                 temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;

  0046b	51		 push	 ecx
  0046c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00474	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00479	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  0047c	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  0047f	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  00483	52		 push	 edx
  00484	8d 85 dc fa ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  0048a	50		 push	 eax
  0048b	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00490	83 c4 0c	 add	 esp, 12			; 0000000cH
  00493	50		 push	 eax
  00494	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00497	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  0049a	8d 44 ca f8	 lea	 eax, DWORD PTR [edx+ecx*8-8]
  0049e	50		 push	 eax
  0049f	8d 8d cc fa ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  004a5	51		 push	 ecx
  004a6	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  004ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ae	8b 10		 mov	 edx, DWORD PTR [eax]
  004b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004b3	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  004b6	8d 4c 09 fe	 lea	 ecx, DWORD PTR [ecx+ecx-2]
  004ba	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  004bd	89 54 ce 08	 mov	 DWORD PTR [esi+ecx*8+8], edx
  004c1	89 44 ce 0c	 mov	 DWORD PTR [esi+ecx*8+12], eax
$LN28@AddPolylin:

; 654  :             }
; 655  : 
; 656  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 657  :             unsigned int idx1 = _VtxCurrentIdx;

  004c5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  004c8	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  004cb	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _idx1$59[ebp], ecx

; 658  :             for (int i1 = 0; i1 < count; i1++)

  004d1	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i1$58[ebp], 0
  004db	eb 0f		 jmp	 SHORT $LN7@AddPolylin
$LN5@AddPolylin:
  004dd	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i1$58[ebp]
  004e3	83 c0 01	 add	 eax, 1
  004e6	89 85 24 ff ff
	ff		 mov	 DWORD PTR _i1$58[ebp], eax
$LN7@AddPolylin:
  004ec	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i1$58[ebp]
  004f2	3b 45 d8	 cmp	 eax, DWORD PTR _count$[ebp]
  004f5	0f 8d 9e 03 00
	00		 jge	 $LN6@AddPolylin

; 659  :             {
; 660  :                 const int i2 = (i1+1) == points_count ? 0 : i1+1;

  004fb	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i1$58[ebp]
  00501	83 c0 01	 add	 eax, 1
  00504	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  00507	75 0c		 jne	 SHORT $LN44@AddPolylin
  00509	c7 85 c4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv289[ebp], 0
  00513	eb 0f		 jmp	 SHORT $LN45@AddPolylin
$LN44@AddPolylin:
  00515	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _i1$58[ebp]
  0051b	83 c1 01	 add	 ecx, 1
  0051e	89 8d c4 f9 ff
	ff		 mov	 DWORD PTR tv289[ebp], ecx
$LN45@AddPolylin:
  00524	8b 95 c4 f9 ff
	ff		 mov	 edx, DWORD PTR tv289[ebp]
  0052a	89 95 18 ff ff
	ff		 mov	 DWORD PTR _i2$57[ebp], edx

; 661  :                 unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;

  00530	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i1$58[ebp]
  00536	83 c0 01	 add	 eax, 1
  00539	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  0053c	75 0e		 jne	 SHORT $LN46@AddPolylin
  0053e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00541	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00544	89 95 c4 f9 ff
	ff		 mov	 DWORD PTR tv294[ebp], edx
  0054a	eb 0f		 jmp	 SHORT $LN47@AddPolylin
$LN46@AddPolylin:
  0054c	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _idx1$59[ebp]
  00552	83 c0 03	 add	 eax, 3
  00555	89 85 c4 f9 ff
	ff		 mov	 DWORD PTR tv294[ebp], eax
$LN47@AddPolylin:
  0055b	8b 8d c4 f9 ff
	ff		 mov	 ecx, DWORD PTR tv294[ebp]
  00561	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _idx2$56[ebp], ecx

; 662  : 
; 663  :                 // Average normals
; 664  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;

  00567	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i1$58[ebp]
  0056d	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00570	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _i2$57[ebp]
  00576	8b 75 90	 mov	 esi, DWORD PTR _temp_normals$67[ebp]
  00579	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  0057e	f3 0f 58 04 d6	 addss	 xmm0, DWORD PTR [esi+edx*8]
  00583	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0058b	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _dm_x$55[ebp], xmm0

; 665  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

  00593	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i1$58[ebp]
  00599	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  0059c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR _i2$57[ebp]
  005a2	8b 75 90	 mov	 esi, DWORD PTR _temp_normals$67[ebp]
  005a5	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  005ab	f3 0f 58 44 d6
	04		 addss	 xmm0, DWORD PTR [esi+edx*8+4]
  005b1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  005b9	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _dm_y$54[ebp], xmm0

; 666  :                 IM_FIXNORMAL2F(dm_x, dm_y)

  005c1	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _dm_x$55[ebp]
  005c9	f3 0f 59 85 00
	ff ff ff	 mulss	 xmm0, DWORD PTR _dm_x$55[ebp]
  005d1	f3 0f 10 8d f4
	fe ff ff	 movss	 xmm1, DWORD PTR _dm_y$54[ebp]
  005d9	f3 0f 59 8d f4
	fe ff ff	 mulss	 xmm1, DWORD PTR _dm_y$54[ebp]
  005e1	f3 0f 58 c1	 addss	 xmm0, xmm1
  005e5	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _d2$53[ebp], xmm0
  005ed	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  005f5	0f 2f 85 e8 fe
	ff ff		 comiss	 xmm0, DWORD PTR _d2$53[ebp]
  005fc	76 10		 jbe	 SHORT $LN29@AddPolylin
  005fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00606	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _d2$53[ebp], xmm0
$LN29@AddPolylin:
  0060e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00616	f3 0f 5e 85 e8
	fe ff ff	 divss	 xmm0, DWORD PTR _d2$53[ebp]
  0061e	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _inv_lensq$52[ebp], xmm0
  00626	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _dm_x$55[ebp]
  0062e	f3 0f 59 85 dc
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_lensq$52[ebp]
  00636	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _dm_x$55[ebp], xmm0
  0063e	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_y$54[ebp]
  00646	f3 0f 59 85 dc
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_lensq$52[ebp]
  0064e	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _dm_y$54[ebp], xmm0

; 667  :                 dm_x *= AA_SIZE;

  00656	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _dm_x$55[ebp]
  0065e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  00666	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _dm_x$55[ebp], xmm0

; 668  :                 dm_y *= AA_SIZE;

  0066e	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_y$54[ebp]
  00676	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  0067e	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _dm_y$54[ebp], xmm0

; 669  : 
; 670  :                 // Add temporary vertexes
; 671  :                 ImVec2* out_vtx = &temp_points[i2*2];

  00686	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i2$57[ebp]
  0068c	d1 e0		 shl	 eax, 1
  0068e	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  00691	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00694	89 95 d0 fe ff
	ff		 mov	 DWORD PTR _out_vtx$51[ebp], edx

; 672  :                 out_vtx[0].x = points[i2].x + dm_x;

  0069a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i2$57[ebp]
  006a0	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  006a3	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  006a8	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _dm_x$55[ebp]
  006b0	ba 08 00 00 00	 mov	 edx, 8
  006b5	6b c2 00	 imul	 eax, edx, 0
  006b8	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _out_vtx$51[ebp]
  006be	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 673  :                 out_vtx[0].y = points[i2].y + dm_y;

  006c3	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i2$57[ebp]
  006c9	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  006cc	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  006d2	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _dm_y$54[ebp]
  006da	ba 08 00 00 00	 mov	 edx, 8
  006df	6b c2 00	 imul	 eax, edx, 0
  006e2	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _out_vtx$51[ebp]
  006e8	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 674  :                 out_vtx[1].x = points[i2].x - dm_x;

  006ee	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i2$57[ebp]
  006f4	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  006f7	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  006fc	f3 0f 5c 85 00
	ff ff ff	 subss	 xmm0, DWORD PTR _dm_x$55[ebp]
  00704	ba 08 00 00 00	 mov	 edx, 8
  00709	c1 e2 00	 shl	 edx, 0
  0070c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _out_vtx$51[ebp]
  00712	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 675  :                 out_vtx[1].y = points[i2].y - dm_y;

  00717	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _i2$57[ebp]
  0071d	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00720	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00726	f3 0f 5c 85 f4
	fe ff ff	 subss	 xmm0, DWORD PTR _dm_y$54[ebp]
  0072e	ba 08 00 00 00	 mov	 edx, 8
  00733	c1 e2 00	 shl	 edx, 0
  00736	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _out_vtx$51[ebp]
  0073c	f3 0f 11 44 10
	04		 movss	 DWORD PTR [eax+edx+4], xmm0

; 676  : 
; 677  :                 // Add indexes
; 678  :                 _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);

  00742	b8 02 00 00 00	 mov	 eax, 2
  00747	6b c8 00	 imul	 ecx, eax, 0
  0074a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0074d	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00750	66 8b 95 0c ff
	ff ff		 mov	 dx, WORD PTR _idx2$56[ebp]
  00757	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  0075b	b8 02 00 00 00	 mov	 eax, 2
  00760	c1 e0 00	 shl	 eax, 0
  00763	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00766	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00769	66 8b 8d 30 ff
	ff ff		 mov	 cx, WORD PTR _idx1$59[ebp]
  00770	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx
  00774	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _idx1$59[ebp]
  0077a	83 c0 02	 add	 eax, 2
  0077d	b9 02 00 00 00	 mov	 ecx, 2
  00782	d1 e1		 shl	 ecx, 1
  00784	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00787	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  0078a	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 679  :                 _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);

  0078e	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _idx1$59[ebp]
  00794	83 c0 02	 add	 eax, 2
  00797	b9 02 00 00 00	 mov	 ecx, 2
  0079c	6b d1 03	 imul	 edx, ecx, 3
  0079f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  007a2	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  007a5	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  007a9	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _idx2$56[ebp]
  007af	83 c0 02	 add	 eax, 2
  007b2	b9 02 00 00 00	 mov	 ecx, 2
  007b7	c1 e1 02	 shl	 ecx, 2
  007ba	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  007bd	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  007c0	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  007c4	b8 02 00 00 00	 mov	 eax, 2
  007c9	6b c8 05	 imul	 ecx, eax, 5
  007cc	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  007cf	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  007d2	66 8b 95 0c ff
	ff ff		 mov	 dx, WORD PTR _idx2$56[ebp]
  007d9	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 680  :                 _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);

  007dd	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _idx2$56[ebp]
  007e3	83 c0 01	 add	 eax, 1
  007e6	b9 02 00 00 00	 mov	 ecx, 2
  007eb	6b d1 06	 imul	 edx, ecx, 6
  007ee	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  007f1	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  007f4	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  007f8	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _idx1$59[ebp]
  007fe	83 c0 01	 add	 eax, 1
  00801	b9 02 00 00 00	 mov	 ecx, 2
  00806	6b d1 07	 imul	 edx, ecx, 7
  00809	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0080c	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0080f	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  00813	b8 02 00 00 00	 mov	 eax, 2
  00818	c1 e0 03	 shl	 eax, 3
  0081b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0081e	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00821	66 8b 8d 30 ff
	ff ff		 mov	 cx, WORD PTR _idx1$59[ebp]
  00828	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 681  :                 _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);

  0082c	b8 02 00 00 00	 mov	 eax, 2
  00831	6b c8 09	 imul	 ecx, eax, 9
  00834	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00837	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0083a	66 8b 95 30 ff
	ff ff		 mov	 dx, WORD PTR _idx1$59[ebp]
  00841	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  00845	b8 02 00 00 00	 mov	 eax, 2
  0084a	6b c8 0a	 imul	 ecx, eax, 10
  0084d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00850	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00853	66 8b 95 0c ff
	ff ff		 mov	 dx, WORD PTR _idx2$56[ebp]
  0085a	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  0085e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _idx2$56[ebp]
  00864	83 c0 01	 add	 eax, 1
  00867	b9 02 00 00 00	 mov	 ecx, 2
  0086c	6b d1 0b	 imul	 edx, ecx, 11
  0086f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00872	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00875	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 682  :                 _IdxWritePtr += 12;

  00879	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0087c	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0087f	83 c1 18	 add	 ecx, 24			; 00000018H
  00882	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00885	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 683  : 
; 684  :                 idx1 = idx2;

  00888	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _idx2$56[ebp]
  0088e	89 85 30 ff ff
	ff		 mov	 DWORD PTR _idx1$59[ebp], eax

; 685  :             }

  00894	e9 44 fc ff ff	 jmp	 $LN5@AddPolylin
$LN6@AddPolylin:

; 686  : 
; 687  :             // Add vertexes
; 688  :             for (int i = 0; i < points_count; i++)

  00899	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$50[ebp], 0
  008a3	eb 0f		 jmp	 SHORT $LN10@AddPolylin
$LN8@AddPolylin:
  008a5	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _i$50[ebp]
  008ab	83 c0 01	 add	 eax, 1
  008ae	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _i$50[ebp], eax
$LN10@AddPolylin:
  008b4	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _i$50[ebp]
  008ba	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  008bd	0f 8d 18 01 00
	00		 jge	 $LN9@AddPolylin

; 689  :             {
; 690  :                 _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

  008c3	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _i$50[ebp]
  008c9	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  008cc	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  008cf	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  008d3	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  008d8	6b c9 00	 imul	 ecx, ecx, 0
  008db	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  008de	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  008e1	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  008e4	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  008e8	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  008ed	6b c8 00	 imul	 ecx, eax, 0
  008f0	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  008f3	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  008f6	8b 55 e4	 mov	 edx, DWORD PTR _uv$[ebp]
  008f9	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  008fd	8b 55 e8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  00900	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  00904	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00909	6b c8 00	 imul	 ecx, eax, 0
  0090c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0090f	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00912	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  00915	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 691  :                 _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;

  00919	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _i$50[ebp]
  0091f	d1 e0		 shl	 eax, 1
  00921	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  00924	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  00927	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  0092b	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00930	c1 e1 00	 shl	 ecx, 0
  00933	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  00936	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  00939	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  0093c	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  00940	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00945	c1 e0 00	 shl	 eax, 0
  00948	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0094b	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0094e	8b 4d e4	 mov	 ecx, DWORD PTR _uv$[ebp]
  00951	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  00955	8b 4d e8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  00958	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  0095c	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00961	c1 e0 00	 shl	 eax, 0
  00964	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00967	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0096a	8b 4d b4	 mov	 ecx, DWORD PTR _col_trans$70[ebp]
  0096d	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 692  :                 _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;

  00971	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _i$50[ebp]
  00977	d1 e0		 shl	 eax, 1
  00979	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  0097c	8b 54 c1 08	 mov	 edx, DWORD PTR [ecx+eax*8+8]
  00980	8b 44 c1 0c	 mov	 eax, DWORD PTR [ecx+eax*8+12]
  00984	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00989	d1 e1		 shl	 ecx, 1
  0098b	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  0098e	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  00991	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  00994	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  00998	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0099d	d1 e0		 shl	 eax, 1
  0099f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  009a2	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  009a5	8b 4d e4	 mov	 ecx, DWORD PTR _uv$[ebp]
  009a8	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  009ac	8b 4d e8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  009af	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  009b3	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  009b8	d1 e0		 shl	 eax, 1
  009ba	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  009bd	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  009c0	8b 4d b4	 mov	 ecx, DWORD PTR _col_trans$70[ebp]
  009c3	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 693  :                 _VtxWritePtr += 3;

  009c7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  009ca	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  009cd	83 c1 3c	 add	 ecx, 60			; 0000003cH
  009d0	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  009d3	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 694  :             }

  009d6	e9 ca fe ff ff	 jmp	 $LN8@AddPolylin
$LN9@AddPolylin:

; 695  :         }

  009db	e9 30 0a 00 00	 jmp	 $LN15@AddPolylin
$LN26@AddPolylin:

; 696  :         else
; 697  :         {
; 698  :             const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

  009e0	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  009e5	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  009ed	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  009f5	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR _half_inner_thickness$49[ebp], xmm0

; 699  :             if (!closed)

  009fd	0f b6 45 14	 movzx	 eax, BYTE PTR _closed$[ebp]
  00a01	85 c0		 test	 eax, eax
  00a03	0f 85 02 03 00
	00		 jne	 $LN30@AddPolylin

; 700  :             {
; 701  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

  00a09	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00a11	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00a19	51		 push	 ecx
  00a1a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a1f	b8 08 00 00 00	 mov	 eax, 8
  00a24	6b c8 00	 imul	 ecx, eax, 0
  00a27	03 4d 90	 add	 ecx, DWORD PTR _temp_normals$67[ebp]
  00a2a	51		 push	 ecx
  00a2b	8d 95 bc fa ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  00a31	52		 push	 edx
  00a32	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00a37	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a3a	50		 push	 eax
  00a3b	b8 08 00 00 00	 mov	 eax, 8
  00a40	6b c8 00	 imul	 ecx, eax, 0
  00a43	03 4d 08	 add	 ecx, DWORD PTR _points$[ebp]
  00a46	51		 push	 ecx
  00a47	8d 95 ac fa ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00a4d	52		 push	 edx
  00a4e	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00a53	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a56	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a58	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00a5b	b8 08 00 00 00	 mov	 eax, 8
  00a60	6b c0 00	 imul	 eax, eax, 0
  00a63	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00a66	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00a69	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 702  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

  00a6d	51		 push	 ecx
  00a6e	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00a76	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a7b	b8 08 00 00 00	 mov	 eax, 8
  00a80	6b c8 00	 imul	 ecx, eax, 0
  00a83	03 4d 90	 add	 ecx, DWORD PTR _temp_normals$67[ebp]
  00a86	51		 push	 ecx
  00a87	8d 95 9c fa ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  00a8d	52		 push	 edx
  00a8e	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00a93	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a96	50		 push	 eax
  00a97	b8 08 00 00 00	 mov	 eax, 8
  00a9c	6b c8 00	 imul	 ecx, eax, 0
  00a9f	03 4d 08	 add	 ecx, DWORD PTR _points$[ebp]
  00aa2	51		 push	 ecx
  00aa3	8d 95 8c fa ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  00aa9	52		 push	 edx
  00aaa	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00aaf	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ab2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ab4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00ab7	b8 08 00 00 00	 mov	 eax, 8
  00abc	c1 e0 00	 shl	 eax, 0
  00abf	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00ac2	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00ac5	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 703  :                 temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);

  00ac9	51		 push	 ecx
  00aca	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00ad2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ad7	b8 08 00 00 00	 mov	 eax, 8
  00adc	6b c8 00	 imul	 ecx, eax, 0
  00adf	03 4d 90	 add	 ecx, DWORD PTR _temp_normals$67[ebp]
  00ae2	51		 push	 ecx
  00ae3	8d 95 7c fa ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00ae9	52		 push	 edx
  00aea	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00aef	83 c4 0c	 add	 esp, 12			; 0000000cH
  00af2	50		 push	 eax
  00af3	b8 08 00 00 00	 mov	 eax, 8
  00af8	6b c8 00	 imul	 ecx, eax, 0
  00afb	03 4d 08	 add	 ecx, DWORD PTR _points$[ebp]
  00afe	51		 push	 ecx
  00aff	8d 95 6c fa ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  00b05	52		 push	 edx
  00b06	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00b0b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b0e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b10	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00b13	b8 08 00 00 00	 mov	 eax, 8
  00b18	d1 e0		 shl	 eax, 1
  00b1a	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00b1d	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00b20	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 704  :                 temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);

  00b24	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00b2c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00b34	51		 push	 ecx
  00b35	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b3a	b8 08 00 00 00	 mov	 eax, 8
  00b3f	6b c8 00	 imul	 ecx, eax, 0
  00b42	03 4d 90	 add	 ecx, DWORD PTR _temp_normals$67[ebp]
  00b45	51		 push	 ecx
  00b46	8d 95 5c fa ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  00b4c	52		 push	 edx
  00b4d	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00b52	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b55	50		 push	 eax
  00b56	b8 08 00 00 00	 mov	 eax, 8
  00b5b	6b c8 00	 imul	 ecx, eax, 0
  00b5e	03 4d 08	 add	 ecx, DWORD PTR _points$[ebp]
  00b61	51		 push	 ecx
  00b62	8d 95 4c fa ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  00b68	52		 push	 edx
  00b69	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00b6e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b71	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b73	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00b76	b8 08 00 00 00	 mov	 eax, 8
  00b7b	6b c0 03	 imul	 eax, eax, 3
  00b7e	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00b81	89 0c 06	 mov	 DWORD PTR [esi+eax], ecx
  00b84	89 54 06 04	 mov	 DWORD PTR [esi+eax+4], edx

; 705  :                 temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

  00b88	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00b90	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00b98	51		 push	 ecx
  00b99	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b9e	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00ba1	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00ba4	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  00ba8	52		 push	 edx
  00ba9	8d 85 3c fa ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00baf	50		 push	 eax
  00bb0	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00bb5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bb8	50		 push	 eax
  00bb9	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00bbc	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  00bbf	8d 44 ca f8	 lea	 eax, DWORD PTR [edx+ecx*8-8]
  00bc3	50		 push	 eax
  00bc4	8d 8d 2c fa ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00bca	51		 push	 ecx
  00bcb	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00bd0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bd3	8b 10		 mov	 edx, DWORD PTR [eax]
  00bd5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00bd8	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00bdb	8d 0c 8d fc ff
	ff ff		 lea	 ecx, DWORD PTR [ecx*4-4]
  00be2	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00be5	89 14 ce	 mov	 DWORD PTR [esi+ecx*8], edx
  00be8	89 44 ce 04	 mov	 DWORD PTR [esi+ecx*8+4], eax

; 706  :                 temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);

  00bec	51		 push	 ecx
  00bed	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00bf5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bfa	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00bfd	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00c00	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  00c04	52		 push	 edx
  00c05	8d 85 1c fa ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00c0b	50		 push	 eax
  00c0c	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00c11	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c14	50		 push	 eax
  00c15	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00c18	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  00c1b	8d 44 ca f8	 lea	 eax, DWORD PTR [edx+ecx*8-8]
  00c1f	50		 push	 eax
  00c20	8d 8d 0c fa ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00c26	51		 push	 ecx
  00c27	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00c2c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c2f	8b 10		 mov	 edx, DWORD PTR [eax]
  00c31	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c34	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00c37	8d 0c 8d fc ff
	ff ff		 lea	 ecx, DWORD PTR [ecx*4-4]
  00c3e	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00c41	89 54 ce 08	 mov	 DWORD PTR [esi+ecx*8+8], edx
  00c45	89 44 ce 0c	 mov	 DWORD PTR [esi+ecx*8+12], eax

; 707  :                 temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);

  00c49	51		 push	 ecx
  00c4a	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00c52	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c57	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00c5a	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00c5d	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  00c61	52		 push	 edx
  00c62	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00c68	50		 push	 eax
  00c69	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00c6e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c71	50		 push	 eax
  00c72	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00c75	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  00c78	8d 44 ca f8	 lea	 eax, DWORD PTR [edx+ecx*8-8]
  00c7c	50		 push	 eax
  00c7d	8d 8d ec f9 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00c83	51		 push	 ecx
  00c84	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00c89	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c8c	8b 10		 mov	 edx, DWORD PTR [eax]
  00c8e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c91	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00c94	8d 0c 8d fc ff
	ff ff		 lea	 ecx, DWORD PTR [ecx*4-4]
  00c9b	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00c9e	89 54 ce 10	 mov	 DWORD PTR [esi+ecx*8+16], edx
  00ca2	89 44 ce 14	 mov	 DWORD PTR [esi+ecx*8+20], eax

; 708  :                 temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

  00ca6	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00cae	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00cb6	51		 push	 ecx
  00cb7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cbc	8b 45 0c	 mov	 eax, DWORD PTR _points_count$[ebp]
  00cbf	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00cc2	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  00cc6	52		 push	 edx
  00cc7	8d 85 dc f9 ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00ccd	50		 push	 eax
  00cce	e8 00 00 00 00	 call	 ??D@YA?AUImVec2@@ABU0@M@Z ; operator*
  00cd3	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cd6	50		 push	 eax
  00cd7	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00cda	8b 55 08	 mov	 edx, DWORD PTR _points$[ebp]
  00cdd	8d 44 ca f8	 lea	 eax, DWORD PTR [edx+ecx*8-8]
  00ce1	50		 push	 eax
  00ce2	8d 8d cc f9 ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00ce8	51		 push	 ecx
  00ce9	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00cee	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cf1	8b 10		 mov	 edx, DWORD PTR [eax]
  00cf3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00cf6	8b 4d 0c	 mov	 ecx, DWORD PTR _points_count$[ebp]
  00cf9	8d 0c 8d fc ff
	ff ff		 lea	 ecx, DWORD PTR [ecx*4-4]
  00d00	8b 75 84	 mov	 esi, DWORD PTR _temp_points$66[ebp]
  00d03	89 54 ce 18	 mov	 DWORD PTR [esi+ecx*8+24], edx
  00d07	89 44 ce 1c	 mov	 DWORD PTR [esi+ecx*8+28], eax
$LN30@AddPolylin:

; 709  :             }
; 710  : 
; 711  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 712  :             unsigned int idx1 = _VtxCurrentIdx;

  00d0b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00d0e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00d11	89 8d ac fe ff
	ff		 mov	 DWORD PTR _idx1$48[ebp], ecx

; 713  :             for (int i1 = 0; i1 < count; i1++)

  00d17	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i1$47[ebp], 0
  00d21	eb 0f		 jmp	 SHORT $LN13@AddPolylin
$LN11@AddPolylin:
  00d23	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i1$47[ebp]
  00d29	83 c0 01	 add	 eax, 1
  00d2c	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _i1$47[ebp], eax
$LN13@AddPolylin:
  00d32	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i1$47[ebp]
  00d38	3b 45 d8	 cmp	 eax, DWORD PTR _count$[ebp]
  00d3b	0f 8d 2d 05 00
	00		 jge	 $LN12@AddPolylin

; 714  :             {
; 715  :                 const int i2 = (i1+1) == points_count ? 0 : i1+1;

  00d41	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i1$47[ebp]
  00d47	83 c0 01	 add	 eax, 1
  00d4a	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  00d4d	75 0c		 jne	 SHORT $LN48@AddPolylin
  00d4f	c7 85 c4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv614[ebp], 0
  00d59	eb 0f		 jmp	 SHORT $LN49@AddPolylin
$LN48@AddPolylin:
  00d5b	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _i1$47[ebp]
  00d61	83 c1 01	 add	 ecx, 1
  00d64	89 8d c4 f9 ff
	ff		 mov	 DWORD PTR tv614[ebp], ecx
$LN49@AddPolylin:
  00d6a	8b 95 c4 f9 ff
	ff		 mov	 edx, DWORD PTR tv614[ebp]
  00d70	89 95 94 fe ff
	ff		 mov	 DWORD PTR _i2$46[ebp], edx

; 716  :                 unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;

  00d76	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i1$47[ebp]
  00d7c	83 c0 01	 add	 eax, 1
  00d7f	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  00d82	75 0e		 jne	 SHORT $LN50@AddPolylin
  00d84	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00d87	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00d8a	89 95 c4 f9 ff
	ff		 mov	 DWORD PTR tv619[ebp], edx
  00d90	eb 0f		 jmp	 SHORT $LN51@AddPolylin
$LN50@AddPolylin:
  00d92	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  00d98	83 c0 04	 add	 eax, 4
  00d9b	89 85 c4 f9 ff
	ff		 mov	 DWORD PTR tv619[ebp], eax
$LN51@AddPolylin:
  00da1	8b 8d c4 f9 ff
	ff		 mov	 ecx, DWORD PTR tv619[ebp]
  00da7	89 8d 88 fe ff
	ff		 mov	 DWORD PTR _idx2$45[ebp], ecx

; 717  : 
; 718  :                 // Average normals
; 719  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;

  00dad	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i1$47[ebp]
  00db3	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00db6	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _i2$46[ebp]
  00dbc	8b 75 90	 mov	 esi, DWORD PTR _temp_normals$67[ebp]
  00dbf	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  00dc4	f3 0f 58 04 d6	 addss	 xmm0, DWORD PTR [esi+edx*8]
  00dc9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00dd1	f3 0f 11 85 7c
	fe ff ff	 movss	 DWORD PTR _dm_x$44[ebp], xmm0

; 720  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

  00dd9	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _i1$47[ebp]
  00ddf	8b 4d 90	 mov	 ecx, DWORD PTR _temp_normals$67[ebp]
  00de2	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _i2$46[ebp]
  00de8	8b 75 90	 mov	 esi, DWORD PTR _temp_normals$67[ebp]
  00deb	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00df1	f3 0f 58 44 d6
	04		 addss	 xmm0, DWORD PTR [esi+edx*8+4]
  00df7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00dff	f3 0f 11 85 70
	fe ff ff	 movss	 DWORD PTR _dm_y$43[ebp], xmm0

; 721  :                 IM_FIXNORMAL2F(dm_x, dm_y);

  00e07	f3 0f 10 85 7c
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_x$44[ebp]
  00e0f	f3 0f 59 85 7c
	fe ff ff	 mulss	 xmm0, DWORD PTR _dm_x$44[ebp]
  00e17	f3 0f 10 8d 70
	fe ff ff	 movss	 xmm1, DWORD PTR _dm_y$43[ebp]
  00e1f	f3 0f 59 8d 70
	fe ff ff	 mulss	 xmm1, DWORD PTR _dm_y$43[ebp]
  00e27	f3 0f 58 c1	 addss	 xmm0, xmm1
  00e2b	f3 0f 11 85 64
	fe ff ff	 movss	 DWORD PTR _d2$42[ebp], xmm0
  00e33	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00e3b	0f 2f 85 64 fe
	ff ff		 comiss	 xmm0, DWORD PTR _d2$42[ebp]
  00e42	76 10		 jbe	 SHORT $LN31@AddPolylin
  00e44	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00e4c	f3 0f 11 85 64
	fe ff ff	 movss	 DWORD PTR _d2$42[ebp], xmm0
$LN31@AddPolylin:
  00e54	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e5c	f3 0f 5e 85 64
	fe ff ff	 divss	 xmm0, DWORD PTR _d2$42[ebp]
  00e64	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR _inv_lensq$41[ebp], xmm0
  00e6c	f3 0f 10 85 7c
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_x$44[ebp]
  00e74	f3 0f 59 85 58
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_lensq$41[ebp]
  00e7c	f3 0f 11 85 7c
	fe ff ff	 movss	 DWORD PTR _dm_x$44[ebp], xmm0
  00e84	f3 0f 10 85 70
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_y$43[ebp]
  00e8c	f3 0f 59 85 58
	fe ff ff	 mulss	 xmm0, DWORD PTR _inv_lensq$41[ebp]
  00e94	f3 0f 11 85 70
	fe ff ff	 movss	 DWORD PTR _dm_y$43[ebp], xmm0

; 722  :                 float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);

  00e9c	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00ea4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00eac	f3 0f 59 85 7c
	fe ff ff	 mulss	 xmm0, DWORD PTR _dm_x$44[ebp]
  00eb4	f3 0f 11 85 4c
	fe ff ff	 movss	 DWORD PTR _dm_out_x$40[ebp], xmm0

; 723  :                 float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);

  00ebc	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00ec4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00ecc	f3 0f 59 85 70
	fe ff ff	 mulss	 xmm0, DWORD PTR _dm_y$43[ebp]
  00ed4	f3 0f 11 85 40
	fe ff ff	 movss	 DWORD PTR _dm_out_y$39[ebp], xmm0

; 724  :                 float dm_in_x = dm_x * half_inner_thickness;

  00edc	f3 0f 10 85 7c
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_x$44[ebp]
  00ee4	f3 0f 59 85 b8
	fe ff ff	 mulss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00eec	f3 0f 11 85 34
	fe ff ff	 movss	 DWORD PTR _dm_in_x$38[ebp], xmm0

; 725  :                 float dm_in_y = dm_y * half_inner_thickness;

  00ef4	f3 0f 10 85 70
	fe ff ff	 movss	 xmm0, DWORD PTR _dm_y$43[ebp]
  00efc	f3 0f 59 85 b8
	fe ff ff	 mulss	 xmm0, DWORD PTR _half_inner_thickness$49[ebp]
  00f04	f3 0f 11 85 28
	fe ff ff	 movss	 DWORD PTR _dm_in_y$37[ebp], xmm0

; 726  : 
; 727  :                 // Add temporary vertexes
; 728  :                 ImVec2* out_vtx = &temp_points[i2*4];

  00f0c	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  00f12	c1 e0 02	 shl	 eax, 2
  00f15	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  00f18	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00f1b	89 95 1c fe ff
	ff		 mov	 DWORD PTR _out_vtx$36[ebp], edx

; 729  :                 out_vtx[0].x = points[i2].x + dm_out_x;

  00f21	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  00f27	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00f2a	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  00f2f	f3 0f 58 85 4c
	fe ff ff	 addss	 xmm0, DWORD PTR _dm_out_x$40[ebp]
  00f37	ba 08 00 00 00	 mov	 edx, 8
  00f3c	6b c2 00	 imul	 eax, edx, 0
  00f3f	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _out_vtx$36[ebp]
  00f45	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 730  :                 out_vtx[0].y = points[i2].y + dm_out_y;

  00f4a	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  00f50	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00f53	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00f59	f3 0f 58 85 40
	fe ff ff	 addss	 xmm0, DWORD PTR _dm_out_y$39[ebp]
  00f61	ba 08 00 00 00	 mov	 edx, 8
  00f66	6b c2 00	 imul	 eax, edx, 0
  00f69	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _out_vtx$36[ebp]
  00f6f	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 731  :                 out_vtx[1].x = points[i2].x + dm_in_x;

  00f75	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  00f7b	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00f7e	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  00f83	f3 0f 58 85 34
	fe ff ff	 addss	 xmm0, DWORD PTR _dm_in_x$38[ebp]
  00f8b	ba 08 00 00 00	 mov	 edx, 8
  00f90	c1 e2 00	 shl	 edx, 0
  00f93	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _out_vtx$36[ebp]
  00f99	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 732  :                 out_vtx[1].y = points[i2].y + dm_in_y;

  00f9e	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  00fa4	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00fa7	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  00fad	f3 0f 58 85 28
	fe ff ff	 addss	 xmm0, DWORD PTR _dm_in_y$37[ebp]
  00fb5	ba 08 00 00 00	 mov	 edx, 8
  00fba	c1 e2 00	 shl	 edx, 0
  00fbd	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _out_vtx$36[ebp]
  00fc3	f3 0f 11 44 10
	04		 movss	 DWORD PTR [eax+edx+4], xmm0

; 733  :                 out_vtx[2].x = points[i2].x - dm_in_x;

  00fc9	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  00fcf	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00fd2	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  00fd7	f3 0f 5c 85 34
	fe ff ff	 subss	 xmm0, DWORD PTR _dm_in_x$38[ebp]
  00fdf	ba 08 00 00 00	 mov	 edx, 8
  00fe4	d1 e2		 shl	 edx, 1
  00fe6	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _out_vtx$36[ebp]
  00fec	f3 0f 11 04 10	 movss	 DWORD PTR [eax+edx], xmm0

; 734  :                 out_vtx[2].y = points[i2].y - dm_in_y;

  00ff1	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  00ff7	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  00ffa	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  01000	f3 0f 5c 85 28
	fe ff ff	 subss	 xmm0, DWORD PTR _dm_in_y$37[ebp]
  01008	ba 08 00 00 00	 mov	 edx, 8
  0100d	d1 e2		 shl	 edx, 1
  0100f	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _out_vtx$36[ebp]
  01015	f3 0f 11 44 10
	04		 movss	 DWORD PTR [eax+edx+4], xmm0

; 735  :                 out_vtx[3].x = points[i2].x - dm_out_x;

  0101b	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  01021	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  01024	f3 0f 10 04 c1	 movss	 xmm0, DWORD PTR [ecx+eax*8]
  01029	f3 0f 5c 85 4c
	fe ff ff	 subss	 xmm0, DWORD PTR _dm_out_x$40[ebp]
  01031	ba 08 00 00 00	 mov	 edx, 8
  01036	6b c2 03	 imul	 eax, edx, 3
  01039	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _out_vtx$36[ebp]
  0103f	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 736  :                 out_vtx[3].y = points[i2].y - dm_out_y;

  01044	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _i2$46[ebp]
  0104a	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  0104d	f3 0f 10 44 c1
	04		 movss	 xmm0, DWORD PTR [ecx+eax*8+4]
  01053	f3 0f 5c 85 40
	fe ff ff	 subss	 xmm0, DWORD PTR _dm_out_y$39[ebp]
  0105b	ba 08 00 00 00	 mov	 edx, 8
  01060	6b c2 03	 imul	 eax, edx, 3
  01063	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR _out_vtx$36[ebp]
  01069	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 737  : 
; 738  :                 // Add indexes
; 739  :                 _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);

  0106f	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  01075	83 c0 01	 add	 eax, 1
  01078	b9 02 00 00 00	 mov	 ecx, 2
  0107d	6b d1 00	 imul	 edx, ecx, 0
  01080	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01083	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  01086	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  0108a	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  01090	83 c0 01	 add	 eax, 1
  01093	b9 02 00 00 00	 mov	 ecx, 2
  01098	c1 e1 00	 shl	 ecx, 0
  0109b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0109e	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  010a1	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  010a5	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  010ab	83 c0 02	 add	 eax, 2
  010ae	b9 02 00 00 00	 mov	 ecx, 2
  010b3	d1 e1		 shl	 ecx, 1
  010b5	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  010b8	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  010bb	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax

; 740  :                 _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);

  010bf	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  010c5	83 c0 02	 add	 eax, 2
  010c8	b9 02 00 00 00	 mov	 ecx, 2
  010cd	6b d1 03	 imul	 edx, ecx, 3
  010d0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  010d3	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  010d6	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  010da	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  010e0	83 c0 02	 add	 eax, 2
  010e3	b9 02 00 00 00	 mov	 ecx, 2
  010e8	c1 e1 02	 shl	 ecx, 2
  010eb	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  010ee	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  010f1	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  010f5	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  010fb	83 c0 01	 add	 eax, 1
  010fe	b9 02 00 00 00	 mov	 ecx, 2
  01103	6b d1 05	 imul	 edx, ecx, 5
  01106	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01109	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0110c	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 741  :                 _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);

  01110	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  01116	83 c0 01	 add	 eax, 1
  01119	b9 02 00 00 00	 mov	 ecx, 2
  0111e	6b d1 06	 imul	 edx, ecx, 6
  01121	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01124	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  01127	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  0112b	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  01131	83 c0 01	 add	 eax, 1
  01134	b9 02 00 00 00	 mov	 ecx, 2
  01139	6b d1 07	 imul	 edx, ecx, 7
  0113c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0113f	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  01142	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  01146	b8 02 00 00 00	 mov	 eax, 2
  0114b	c1 e0 03	 shl	 eax, 3
  0114e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01151	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  01154	66 8b 8d ac fe
	ff ff		 mov	 cx, WORD PTR _idx1$48[ebp]
  0115b	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 742  :                 _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);

  0115f	b8 02 00 00 00	 mov	 eax, 2
  01164	6b c8 09	 imul	 ecx, eax, 9
  01167	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0116a	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0116d	66 8b 95 ac fe
	ff ff		 mov	 dx, WORD PTR _idx1$48[ebp]
  01174	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  01178	b8 02 00 00 00	 mov	 eax, 2
  0117d	6b c8 0a	 imul	 ecx, eax, 10
  01180	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01183	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  01186	66 8b 95 88 fe
	ff ff		 mov	 dx, WORD PTR _idx2$45[ebp]
  0118d	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  01191	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  01197	83 c0 01	 add	 eax, 1
  0119a	b9 02 00 00 00	 mov	 ecx, 2
  0119f	6b d1 0b	 imul	 edx, ecx, 11
  011a2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  011a5	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  011a8	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 743  :                 _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);

  011ac	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  011b2	83 c0 02	 add	 eax, 2
  011b5	b9 02 00 00 00	 mov	 ecx, 2
  011ba	6b d1 0c	 imul	 edx, ecx, 12
  011bd	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  011c0	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  011c3	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  011c7	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  011cd	83 c0 02	 add	 eax, 2
  011d0	b9 02 00 00 00	 mov	 ecx, 2
  011d5	6b d1 0d	 imul	 edx, ecx, 13
  011d8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  011db	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  011de	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  011e2	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  011e8	83 c0 03	 add	 eax, 3
  011eb	b9 02 00 00 00	 mov	 ecx, 2
  011f0	6b d1 0e	 imul	 edx, ecx, 14
  011f3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  011f6	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  011f9	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 744  :                 _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);

  011fd	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _idx1$48[ebp]
  01203	83 c0 03	 add	 eax, 3
  01206	b9 02 00 00 00	 mov	 ecx, 2
  0120b	6b d1 0f	 imul	 edx, ecx, 15
  0120e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01211	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  01214	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
  01218	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  0121e	83 c0 03	 add	 eax, 3
  01221	b9 02 00 00 00	 mov	 ecx, 2
  01226	c1 e1 04	 shl	 ecx, 4
  01229	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0122c	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  0122f	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
  01233	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  01239	83 c0 02	 add	 eax, 2
  0123c	b9 02 00 00 00	 mov	 ecx, 2
  01241	6b d1 11	 imul	 edx, ecx, 17
  01244	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01247	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0124a	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 745  :                 _IdxWritePtr += 18;

  0124e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01251	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  01254	83 c1 24	 add	 ecx, 36			; 00000024H
  01257	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0125a	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 746  : 
; 747  :                 idx1 = idx2;

  0125d	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _idx2$45[ebp]
  01263	89 85 ac fe ff
	ff		 mov	 DWORD PTR _idx1$48[ebp], eax

; 748  :             }

  01269	e9 b5 fa ff ff	 jmp	 $LN11@AddPolylin
$LN12@AddPolylin:

; 749  : 
; 750  :             // Add vertexes
; 751  :             for (int i = 0; i < points_count; i++)

  0126e	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$35[ebp], 0
  01278	eb 0f		 jmp	 SHORT $LN16@AddPolylin
$LN14@AddPolylin:
  0127a	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  01280	83 c0 01	 add	 eax, 1
  01283	89 85 10 fe ff
	ff		 mov	 DWORD PTR _i$35[ebp], eax
$LN16@AddPolylin:
  01289	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  0128f	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  01292	0f 8d 78 01 00
	00		 jge	 $LN15@AddPolylin

; 752  :             {
; 753  :                 _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;

  01298	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  0129e	c1 e0 02	 shl	 eax, 2
  012a1	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  012a4	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  012a7	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  012ab	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  012b0	6b c9 00	 imul	 ecx, ecx, 0
  012b3	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  012b6	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  012b9	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  012bc	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  012c0	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  012c5	6b c8 00	 imul	 ecx, eax, 0
  012c8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  012cb	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  012ce	8b 55 e4	 mov	 edx, DWORD PTR _uv$[ebp]
  012d1	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  012d5	8b 55 e8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  012d8	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  012dc	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  012e1	6b c8 00	 imul	 ecx, eax, 0
  012e4	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  012e7	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  012ea	8b 55 b4	 mov	 edx, DWORD PTR _col_trans$70[ebp]
  012ed	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 754  :                 _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

  012f1	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  012f7	c1 e0 02	 shl	 eax, 2
  012fa	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  012fd	8b 54 c1 08	 mov	 edx, DWORD PTR [ecx+eax*8+8]
  01301	8b 44 c1 0c	 mov	 eax, DWORD PTR [ecx+eax*8+12]
  01305	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0130a	c1 e1 00	 shl	 ecx, 0
  0130d	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  01310	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  01313	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  01316	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  0131a	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0131f	c1 e0 00	 shl	 eax, 0
  01322	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01325	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  01328	8b 4d e4	 mov	 ecx, DWORD PTR _uv$[ebp]
  0132b	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  0132f	8b 4d e8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  01332	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  01336	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0133b	c1 e0 00	 shl	 eax, 0
  0133e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01341	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  01344	8b 4d 10	 mov	 ecx, DWORD PTR _col$[ebp]
  01347	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 755  :                 _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

  0134b	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  01351	c1 e0 02	 shl	 eax, 2
  01354	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  01357	8b 54 c1 10	 mov	 edx, DWORD PTR [ecx+eax*8+16]
  0135b	8b 44 c1 14	 mov	 eax, DWORD PTR [ecx+eax*8+20]
  0135f	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  01364	d1 e1		 shl	 ecx, 1
  01366	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  01369	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0136c	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  0136f	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  01373	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  01378	d1 e0		 shl	 eax, 1
  0137a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0137d	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  01380	8b 4d e4	 mov	 ecx, DWORD PTR _uv$[ebp]
  01383	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  01387	8b 4d e8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  0138a	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  0138e	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  01393	d1 e0		 shl	 eax, 1
  01395	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01398	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0139b	8b 4d 10	 mov	 ecx, DWORD PTR _col$[ebp]
  0139e	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 756  :                 _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;

  013a2	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _i$35[ebp]
  013a8	c1 e0 02	 shl	 eax, 2
  013ab	8b 4d 84	 mov	 ecx, DWORD PTR _temp_points$66[ebp]
  013ae	8b 54 c1 18	 mov	 edx, DWORD PTR [ecx+eax*8+24]
  013b2	8b 44 c1 1c	 mov	 eax, DWORD PTR [ecx+eax*8+28]
  013b6	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  013bb	6b c9 03	 imul	 ecx, ecx, 3
  013be	8b 75 f4	 mov	 esi, DWORD PTR _this$[ebp]
  013c1	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  013c4	89 14 0e	 mov	 DWORD PTR [esi+ecx], edx
  013c7	89 44 0e 04	 mov	 DWORD PTR [esi+ecx+4], eax
  013cb	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  013d0	6b c8 03	 imul	 ecx, eax, 3
  013d3	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  013d6	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  013d9	8b 55 e4	 mov	 edx, DWORD PTR _uv$[ebp]
  013dc	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  013e0	8b 55 e8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  013e3	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  013e7	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  013ec	6b c8 03	 imul	 ecx, eax, 3
  013ef	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  013f2	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  013f5	8b 55 b4	 mov	 edx, DWORD PTR _col_trans$70[ebp]
  013f8	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 757  :                 _VtxWritePtr += 4;

  013fc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  013ff	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01402	83 c1 50	 add	 ecx, 80			; 00000050H
  01405	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01408	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 758  :             }

  0140b	e9 6a fe ff ff	 jmp	 $LN14@AddPolylin
$LN15@AddPolylin:

; 759  :         }
; 760  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  01410	0f b7 45 9c	 movzx	 eax, WORD PTR _vtx_count$68[ebp]
  01414	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01417	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  0141a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0141d	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 761  :     }

  01420	e9 83 04 00 00	 jmp	 $LN18@AddPolylin
$LN22@AddPolylin:

; 762  :     else
; 763  :     {
; 764  :         // Non Anti-aliased Stroke
; 765  :         const int idx_count = count*6;

  01425	6b 45 d8 06	 imul	 eax, DWORD PTR _count$[ebp], 6
  01429	89 85 04 fe ff
	ff		 mov	 DWORD PTR _idx_count$34[ebp], eax

; 766  :         const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges

  0142f	8b 45 d8	 mov	 eax, DWORD PTR _count$[ebp]
  01432	c1 e0 02	 shl	 eax, 2
  01435	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _vtx_count$33[ebp], eax

; 767  :         PrimReserve(idx_count, vtx_count);

  0143b	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _vtx_count$33[ebp]
  01441	50		 push	 eax
  01442	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _idx_count$34[ebp]
  01448	51		 push	 ecx
  01449	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0144c	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 768  : 
; 769  :         for (int i1 = 0; i1 < count; i1++)

  01451	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i1$32[ebp], 0
  0145b	eb 0f		 jmp	 SHORT $LN19@AddPolylin
$LN17@AddPolylin:
  0145d	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _i1$32[ebp]
  01463	83 c0 01	 add	 eax, 1
  01466	89 85 ec fd ff
	ff		 mov	 DWORD PTR _i1$32[ebp], eax
$LN19@AddPolylin:
  0146c	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _i1$32[ebp]
  01472	3b 45 d8	 cmp	 eax, DWORD PTR _count$[ebp]
  01475	0f 8d 2d 04 00
	00		 jge	 $LN18@AddPolylin

; 770  :         {
; 771  :             const int i2 = (i1+1) == points_count ? 0 : i1+1;

  0147b	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _i1$32[ebp]
  01481	83 c0 01	 add	 eax, 1
  01484	3b 45 0c	 cmp	 eax, DWORD PTR _points_count$[ebp]
  01487	75 0c		 jne	 SHORT $LN52@AddPolylin
  01489	c7 85 c4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv914[ebp], 0
  01493	eb 0f		 jmp	 SHORT $LN53@AddPolylin
$LN52@AddPolylin:
  01495	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _i1$32[ebp]
  0149b	83 c1 01	 add	 ecx, 1
  0149e	89 8d c4 f9 ff
	ff		 mov	 DWORD PTR tv914[ebp], ecx
$LN53@AddPolylin:
  014a4	8b 95 c4 f9 ff
	ff		 mov	 edx, DWORD PTR tv914[ebp]
  014aa	89 95 e0 fd ff
	ff		 mov	 DWORD PTR _i2$31[ebp], edx

; 772  :             const ImVec2& p1 = points[i1];

  014b0	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _i1$32[ebp]
  014b6	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  014b9	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  014bc	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _p1$30[ebp], edx

; 773  :             const ImVec2& p2 = points[i2];

  014c2	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _i2$31[ebp]
  014c8	8b 4d 08	 mov	 ecx, DWORD PTR _points$[ebp]
  014cb	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  014ce	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _p2$29[ebp], edx

; 774  : 
; 775  :             float dx = p2.x - p1.x;

  014d4	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _p2$29[ebp]
  014da	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _p1$30[ebp]
  014e0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  014e4	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  014e8	f3 0f 11 85 bc
	fd ff ff	 movss	 DWORD PTR _dx$28[ebp], xmm0

; 776  :             float dy = p2.y - p1.y;

  014f0	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _p2$29[ebp]
  014f6	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _p1$30[ebp]
  014fc	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01501	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  01506	f3 0f 11 85 b0
	fd ff ff	 movss	 DWORD PTR _dy$27[ebp], xmm0

; 777  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  0150e	f3 0f 10 85 bc
	fd ff ff	 movss	 xmm0, DWORD PTR _dx$28[ebp]
  01516	f3 0f 59 85 bc
	fd ff ff	 mulss	 xmm0, DWORD PTR _dx$28[ebp]
  0151e	f3 0f 10 8d b0
	fd ff ff	 movss	 xmm1, DWORD PTR _dy$27[ebp]
  01526	f3 0f 59 8d b0
	fd ff ff	 mulss	 xmm1, DWORD PTR _dy$27[ebp]
  0152e	f3 0f 58 c1	 addss	 xmm0, xmm1
  01532	f3 0f 11 85 a4
	fd ff ff	 movss	 DWORD PTR _d2$26[ebp], xmm0
  0153a	f3 0f 10 85 a4
	fd ff ff	 movss	 xmm0, DWORD PTR _d2$26[ebp]
  01542	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  01549	76 64		 jbe	 SHORT $LN32@AddPolylin
  0154b	51		 push	 ecx
  0154c	f3 0f 10 85 a4
	fd ff ff	 movss	 xmm0, DWORD PTR _d2$26[ebp]
  01554	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01559	e8 00 00 00 00	 call	 ?ImSqrt@@YAMM@Z		; ImSqrt
  0155e	83 c4 04	 add	 esp, 4
  01561	d9 9d c4 f9 ff
	ff		 fstp	 DWORD PTR tv1850[ebp]
  01567	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0156f	f3 0f 5e 85 c4
	f9 ff ff	 divss	 xmm0, DWORD PTR tv1850[ebp]
  01577	f3 0f 11 85 98
	fd ff ff	 movss	 DWORD PTR _inv_len$25[ebp], xmm0
  0157f	f3 0f 10 85 bc
	fd ff ff	 movss	 xmm0, DWORD PTR _dx$28[ebp]
  01587	f3 0f 59 85 98
	fd ff ff	 mulss	 xmm0, DWORD PTR _inv_len$25[ebp]
  0158f	f3 0f 11 85 bc
	fd ff ff	 movss	 DWORD PTR _dx$28[ebp], xmm0
  01597	f3 0f 10 85 b0
	fd ff ff	 movss	 xmm0, DWORD PTR _dy$27[ebp]
  0159f	f3 0f 59 85 98
	fd ff ff	 mulss	 xmm0, DWORD PTR _inv_len$25[ebp]
  015a7	f3 0f 11 85 b0
	fd ff ff	 movss	 DWORD PTR _dy$27[ebp], xmm0
$LN32@AddPolylin:

; 778  :             dx *= (thickness * 0.5f);

  015af	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  015b4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  015bc	f3 0f 59 85 bc
	fd ff ff	 mulss	 xmm0, DWORD PTR _dx$28[ebp]
  015c4	f3 0f 11 85 bc
	fd ff ff	 movss	 DWORD PTR _dx$28[ebp], xmm0

; 779  :             dy *= (thickness * 0.5f);

  015cc	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  015d1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  015d9	f3 0f 59 85 b0
	fd ff ff	 mulss	 xmm0, DWORD PTR _dy$27[ebp]
  015e1	f3 0f 11 85 b0
	fd ff ff	 movss	 DWORD PTR _dy$27[ebp], xmm0

; 780  : 
; 781  :             _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

  015e9	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _p1$30[ebp]
  015ef	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  015f3	f3 0f 58 85 b0
	fd ff ff	 addss	 xmm0, DWORD PTR _dy$27[ebp]
  015fb	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  01600	6b d1 00	 imul	 edx, ecx, 0
  01603	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01606	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01609	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  0160e	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _p1$30[ebp]
  01614	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01619	f3 0f 5c 85 bc
	fd ff ff	 subss	 xmm0, DWORD PTR _dx$28[ebp]
  01621	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  01626	6b d1 00	 imul	 edx, ecx, 0
  01629	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0162c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0162f	f3 0f 11 44 11
	04		 movss	 DWORD PTR [ecx+edx+4], xmm0
  01635	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0163a	6b c8 00	 imul	 ecx, eax, 0
  0163d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01640	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01643	8b 55 e4	 mov	 edx, DWORD PTR _uv$[ebp]
  01646	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  0164a	8b 55 e8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  0164d	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  01651	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  01656	6b c8 00	 imul	 ecx, eax, 0
  01659	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0165c	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0165f	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  01662	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 782  :             _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

  01666	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _p2$29[ebp]
  0166c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01670	f3 0f 58 85 b0
	fd ff ff	 addss	 xmm0, DWORD PTR _dy$27[ebp]
  01678	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0167d	c1 e1 00	 shl	 ecx, 0
  01680	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01683	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01686	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0168b	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _p2$29[ebp]
  01691	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01696	f3 0f 5c 85 bc
	fd ff ff	 subss	 xmm0, DWORD PTR _dx$28[ebp]
  0169e	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  016a3	c1 e1 00	 shl	 ecx, 0
  016a6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  016a9	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  016ac	f3 0f 11 44 08
	04		 movss	 DWORD PTR [eax+ecx+4], xmm0
  016b2	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  016b7	c1 e0 00	 shl	 eax, 0
  016ba	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  016bd	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  016c0	8b 4d e4	 mov	 ecx, DWORD PTR _uv$[ebp]
  016c3	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  016c7	8b 4d e8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  016ca	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  016ce	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  016d3	c1 e0 00	 shl	 eax, 0
  016d6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  016d9	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  016dc	8b 4d 10	 mov	 ecx, DWORD PTR _col$[ebp]
  016df	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 783  :             _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

  016e3	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _p2$29[ebp]
  016e9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  016ed	f3 0f 5c 85 b0
	fd ff ff	 subss	 xmm0, DWORD PTR _dy$27[ebp]
  016f5	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  016fa	d1 e1		 shl	 ecx, 1
  016fc	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  016ff	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01702	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  01707	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _p2$29[ebp]
  0170d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01712	f3 0f 58 85 bc
	fd ff ff	 addss	 xmm0, DWORD PTR _dx$28[ebp]
  0171a	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0171f	d1 e1		 shl	 ecx, 1
  01721	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01724	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01727	f3 0f 11 44 08
	04		 movss	 DWORD PTR [eax+ecx+4], xmm0
  0172d	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  01732	d1 e0		 shl	 eax, 1
  01734	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01737	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0173a	8b 4d e4	 mov	 ecx, DWORD PTR _uv$[ebp]
  0173d	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  01741	8b 4d e8	 mov	 ecx, DWORD PTR _uv$[ebp+4]
  01744	89 4c 02 0c	 mov	 DWORD PTR [edx+eax+12], ecx
  01748	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0174d	d1 e0		 shl	 eax, 1
  0174f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  01752	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  01755	8b 4d 10	 mov	 ecx, DWORD PTR _col$[ebp]
  01758	89 4c 02 10	 mov	 DWORD PTR [edx+eax+16], ecx

; 784  :             _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

  0175c	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _p1$30[ebp]
  01762	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01766	f3 0f 5c 85 b0
	fd ff ff	 subss	 xmm0, DWORD PTR _dy$27[ebp]
  0176e	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  01773	6b d1 03	 imul	 edx, ecx, 3
  01776	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01779	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0177c	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  01781	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _p1$30[ebp]
  01787	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0178c	f3 0f 58 85 bc
	fd ff ff	 addss	 xmm0, DWORD PTR _dx$28[ebp]
  01794	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  01799	6b d1 03	 imul	 edx, ecx, 3
  0179c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0179f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  017a2	f3 0f 11 44 11
	04		 movss	 DWORD PTR [ecx+edx+4], xmm0
  017a8	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  017ad	6b c8 03	 imul	 ecx, eax, 3
  017b0	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  017b3	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  017b6	8b 55 e4	 mov	 edx, DWORD PTR _uv$[ebp]
  017b9	89 54 08 08	 mov	 DWORD PTR [eax+ecx+8], edx
  017bd	8b 55 e8	 mov	 edx, DWORD PTR _uv$[ebp+4]
  017c0	89 54 08 0c	 mov	 DWORD PTR [eax+ecx+12], edx
  017c4	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  017c9	6b c8 03	 imul	 ecx, eax, 3
  017cc	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  017cf	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  017d2	8b 55 10	 mov	 edx, DWORD PTR _col$[ebp]
  017d5	89 54 08 10	 mov	 DWORD PTR [eax+ecx+16], edx

; 785  :             _VtxWritePtr += 4;

  017d9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  017dc	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  017df	83 c1 50	 add	 ecx, 80			; 00000050H
  017e2	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  017e5	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 786  : 
; 787  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);

  017e8	b8 02 00 00 00	 mov	 eax, 2
  017ed	6b c8 00	 imul	 ecx, eax, 0
  017f0	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  017f3	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  017f6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  017f9	66 8b 52 34	 mov	 dx, WORD PTR [edx+52]
  017fd	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  01801	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01804	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01807	83 c1 01	 add	 ecx, 1
  0180a	ba 02 00 00 00	 mov	 edx, 2
  0180f	c1 e2 00	 shl	 edx, 0
  01812	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01815	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  01818	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  0181c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0181f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01822	83 c1 02	 add	 ecx, 2
  01825	ba 02 00 00 00	 mov	 edx, 2
  0182a	d1 e2		 shl	 edx, 1
  0182c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0182f	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  01832	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx

; 788  :             _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);

  01836	b8 02 00 00 00	 mov	 eax, 2
  0183b	6b c8 03	 imul	 ecx, eax, 3
  0183e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01841	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  01844	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01847	66 8b 52 34	 mov	 dx, WORD PTR [edx+52]
  0184b	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx
  0184f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01852	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01855	83 c1 02	 add	 ecx, 2
  01858	ba 02 00 00 00	 mov	 edx, 2
  0185d	c1 e2 02	 shl	 edx, 2
  01860	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01863	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  01866	66 89 0c 02	 mov	 WORD PTR [edx+eax], cx
  0186a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0186d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01870	83 c1 03	 add	 ecx, 3
  01873	ba 02 00 00 00	 mov	 edx, 2
  01878	6b c2 05	 imul	 eax, edx, 5
  0187b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0187e	8b 52 3c	 mov	 edx, DWORD PTR [edx+60]
  01881	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 789  :             _IdxWritePtr += 6;

  01885	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01888	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0188b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0188e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  01891	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 790  :             _VtxCurrentIdx += 4;

  01894	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  01897	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0189a	83 c1 04	 add	 ecx, 4
  0189d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  018a0	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 791  :         }

  018a3	e9 b5 fb ff ff	 jmp	 $LN17@AddPolylin
$LN18@AddPolylin:
$LN1@AddPolylin:

; 792  :     }
; 793  : }

  018a8	52		 push	 edx
  018a9	8b cd		 mov	 ecx, ebp
  018ab	50		 push	 eax
  018ac	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN57@AddPolylin
  018b2	ff b5 8c fd ff
	ff		 push	 DWORD PTR __$AllocaPad$$[ebp]
  018b8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars2@12
  018bd	58		 pop	 eax
  018be	5a		 pop	 edx
  018bf	8d a5 b0 f9 ff
	ff		 lea	 esp, DWORD PTR [ebp-1616]
  018c5	5f		 pop	 edi
  018c6	5e		 pop	 esi
  018c7	5b		 pop	 ebx
  018c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018cb	33 cd		 xor	 ecx, ebp
  018cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018d2	8b e5		 mov	 esp, ebp
  018d4	5d		 pop	 ebp
  018d5	c2 14 00	 ret	 20			; 00000014H
$LN57@AddPolylin:
  018d8	02 00 00 00	 DD	 2
  018dc	00 00 00 00	 DD	 $LN56@AddPolylin
$LN56@AddPolylin:
  018e0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  018e4	08 00 00 00	 DD	 8
  018e8	00 00 00 00	 DD	 $LN54@AddPolylin
  018ec	8c fd ff ff	 DD	 -628			; fffffd8cH
  018f0	04 00 00 00	 DD	 4
  018f4	00 00 00 00	 DD	 $LN55@AddPolylin
$LN55@AddPolylin:
  018f8	5f		 DB	 95			; 0000005fH
  018f9	24		 DB	 36			; 00000024H
  018fa	41		 DB	 65			; 00000041H
  018fb	6c		 DB	 108			; 0000006cH
  018fc	6c		 DB	 108			; 0000006cH
  018fd	6f		 DB	 111			; 0000006fH
  018fe	63		 DB	 99			; 00000063H
  018ff	61		 DB	 97			; 00000061H
  01900	50		 DB	 80			; 00000050H
  01901	61		 DB	 97			; 00000061H
  01902	64		 DB	 100			; 00000064H
  01903	24		 DB	 36			; 00000024H
  01904	00		 DB	 0
$LN54@AddPolylin:
  01905	75		 DB	 117			; 00000075H
  01906	76		 DB	 118			; 00000076H
  01907	00		 DB	 0
?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM@Z ENDP	; ImDrawList::AddPolyline
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z
_TEXT	SEGMENT
tv143 = -233						; size = 1
_clip_rect$ = -36					; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_font$ = 8						; size = 4
_font_size$ = 12					; size = 4
_pos$ = 16						; size = 4
_col$ = 20						; size = 4
_text_begin$ = 24					; size = 4
_text_end$ = 28						; size = 4
_wrap_width$ = 32					; size = 4
_cpu_fine_clip_rect$ = 36				; size = 4
?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z PROC ; ImDrawList::AddText, COMDAT
; _this$ = ecx

; 1142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00013	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1143 :     if ((col & IM_COL32_A_MASK) == 0)

  00037	8b 45 14	 mov	 eax, DWORD PTR _col$[ebp]
  0003a	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0003f	75 05		 jne	 SHORT $LN2@AddText

; 1144 :         return;

  00041	e9 ac 01 00 00	 jmp	 $LN1@AddText
$LN2@AddText:

; 1145 : 
; 1146 :     if (text_end == NULL)

  00046	83 7d 1c 00	 cmp	 DWORD PTR _text_end$[ebp], 0
  0004a	75 12		 jne	 SHORT $LN3@AddText

; 1147 :         text_end = text_begin + strlen(text_begin);

  0004c	8b 45 18	 mov	 eax, DWORD PTR _text_begin$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _strlen
  00055	83 c4 04	 add	 esp, 4
  00058	03 45 18	 add	 eax, DWORD PTR _text_begin$[ebp]
  0005b	89 45 1c	 mov	 DWORD PTR _text_end$[ebp], eax
$LN3@AddText:

; 1148 :     if (text_begin == text_end)

  0005e	8b 45 18	 mov	 eax, DWORD PTR _text_begin$[ebp]
  00061	3b 45 1c	 cmp	 eax, DWORD PTR _text_end$[ebp]
  00064	75 05		 jne	 SHORT $LN4@AddText

; 1149 :         return;

  00066	e9 87 01 00 00	 jmp	 $LN1@AddText
$LN4@AddText:

; 1150 : 
; 1151 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1152 :     if (font == NULL)

  0006b	83 7d 08 00	 cmp	 DWORD PTR _font$[ebp], 0
  0006f	75 0c		 jne	 SHORT $LN5@AddText

; 1153 :         font = _Data->Font;

  00071	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00077	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007a	89 55 08	 mov	 DWORD PTR _font$[ebp], edx
$LN5@AddText:

; 1154 :     if (font_size == 0.0f)

  0007d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _font_size$[ebp]
  00082	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00089	9f		 lahf
  0008a	f6 c4 44	 test	 ah, 68			; 00000044H
  0008d	7a 10		 jp	 SHORT $LN6@AddText

; 1155 :         font_size = _Data->FontSize;

  0008f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00095	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [ecx+12]
  0009a	f3 0f 11 45 0c	 movss	 DWORD PTR _font_size$[ebp], xmm0
$LN6@AddText:

; 1156 : 
; 1157 :     IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

  0009f	8b 45 08	 mov	 eax, DWORD PTR _font$[ebp]
  000a2	8b 70 38	 mov	 esi, DWORD PTR [eax+56]
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000ab	e8 00 00 00 00	 call	 ?back@?$ImVector@PAX@@QAEAAPAXXZ ; ImVector<void *>::back
  000b0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000b5	74 26		 je	 SHORT $LN9@AddText
  000b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z@4JA
  000bd	83 c2 0f	 add	 edx, 15			; 0000000fH
  000c0	8b f4		 mov	 esi, esp
  000c2	52		 push	 edx
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_1GM@DGBHKFGF@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	3b f4		 cmp	 esi, esp
  000d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@AddText:

; 1158 : 
; 1159 :     ImVec4 clip_rect = _ClipRectStack.back();

  000dd	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	83 c1 40	 add	 ecx, 64			; 00000040H
  000e3	e8 00 00 00 00	 call	 ?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ ; ImVector<ImVec4>::back
  000e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ea	89 4d dc	 mov	 DWORD PTR _clip_rect$[ebp], ecx
  000ed	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f0	89 55 e0	 mov	 DWORD PTR _clip_rect$[ebp+4], edx
  000f3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000f6	89 4d e4	 mov	 DWORD PTR _clip_rect$[ebp+8], ecx
  000f9	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000fc	89 55 e8	 mov	 DWORD PTR _clip_rect$[ebp+12], edx

; 1160 :     if (cpu_fine_clip_rect)

  000ff	83 7d 24 00	 cmp	 DWORD PTR _cpu_fine_clip_rect$[ebp], 0
  00103	0f 84 8f 00 00
	00		 je	 $LN7@AddText

; 1161 :     {
; 1162 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);

  00109	8b 45 24	 mov	 eax, DWORD PTR _cpu_fine_clip_rect$[ebp]
  0010c	51		 push	 ecx
  0010d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00111	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00116	51		 push	 ecx
  00117	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _clip_rect$[ebp]
  0011c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00121	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  00126	83 c4 08	 add	 esp, 8
  00129	d9 5d dc	 fstp	 DWORD PTR _clip_rect$[ebp]

; 1163 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);

  0012c	8b 45 24	 mov	 eax, DWORD PTR _cpu_fine_clip_rect$[ebp]
  0012f	51		 push	 ecx
  00130	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00135	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013a	51		 push	 ecx
  0013b	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _clip_rect$[ebp+4]
  00140	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00145	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0014a	83 c4 08	 add	 esp, 8
  0014d	d9 5d e0	 fstp	 DWORD PTR _clip_rect$[ebp+4]

; 1164 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);

  00150	8b 45 24	 mov	 eax, DWORD PTR _cpu_fine_clip_rect$[ebp]
  00153	51		 push	 ecx
  00154	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00159	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015e	51		 push	 ecx
  0015f	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _clip_rect$[ebp+8]
  00164	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00169	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  0016e	83 c4 08	 add	 esp, 8
  00171	d9 5d e4	 fstp	 DWORD PTR _clip_rect$[ebp+8]

; 1165 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);

  00174	8b 45 24	 mov	 eax, DWORD PTR _cpu_fine_clip_rect$[ebp]
  00177	51		 push	 ecx
  00178	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0017d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00182	51		 push	 ecx
  00183	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _clip_rect$[ebp+12]
  00188	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018d	e8 00 00 00 00	 call	 ??$ImMin@M@@YAMMM@Z	; ImMin<float>
  00192	83 c4 08	 add	 esp, 8
  00195	d9 5d e8	 fstp	 DWORD PTR _clip_rect$[ebp+12]
$LN7@AddText:

; 1166 :     }
; 1167 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

  00198	83 7d 24 00	 cmp	 DWORD PTR _cpu_fine_clip_rect$[ebp], 0
  0019c	74 09		 je	 SHORT $LN10@AddText
  0019e	c6 85 17 ff ff
	ff 01		 mov	 BYTE PTR tv143[ebp], 1
  001a5	eb 07		 jmp	 SHORT $LN11@AddText
$LN10@AddText:
  001a7	c6 85 17 ff ff
	ff 00		 mov	 BYTE PTR tv143[ebp], 0
$LN11@AddText:
  001ae	0f b6 85 17 ff
	ff ff		 movzx	 eax, BYTE PTR tv143[ebp]
  001b5	50		 push	 eax
  001b6	51		 push	 ecx
  001b7	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _wrap_width$[ebp]
  001bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c1	8b 4d 1c	 mov	 ecx, DWORD PTR _text_end$[ebp]
  001c4	51		 push	 ecx
  001c5	8b 55 18	 mov	 edx, DWORD PTR _text_begin$[ebp]
  001c8	52		 push	 edx
  001c9	8d 45 dc	 lea	 eax, DWORD PTR _clip_rect$[ebp]
  001cc	50		 push	 eax
  001cd	8b 4d 14	 mov	 ecx, DWORD PTR _col$[ebp]
  001d0	51		 push	 ecx
  001d1	8b 55 10	 mov	 edx, DWORD PTR _pos$[ebp]
  001d4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001d7	50		 push	 eax
  001d8	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001da	51		 push	 ecx
  001db	51		 push	 ecx
  001dc	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _font_size$[ebp]
  001e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e6	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001e9	52		 push	 edx
  001ea	8b 4d 08	 mov	 ecx, DWORD PTR _font$[ebp]
  001ed	e8 00 00 00 00	 call	 ?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z ; ImFont::RenderText
$LN1@AddText:

; 1168 : }

  001f2	52		 push	 edx
  001f3	8b cd		 mov	 ecx, ebp
  001f5	50		 push	 eax
  001f6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@AddText
  001fc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00201	58		 pop	 eax
  00202	5a		 pop	 edx
  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5b		 pop	 ebx
  00206	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00209	33 cd		 xor	 ecx, ebp
  0020b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00210	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  00216	3b ec		 cmp	 ebp, esp
  00218	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021d	8b e5		 mov	 esp, ebp
  0021f	5d		 pop	 ebp
  00220	c2 20 00	 ret	 32			; 00000020H
  00223	90		 npad	 1
$LN14@AddText:
  00224	01 00 00 00	 DD	 1
  00228	00 00 00 00	 DD	 $LN13@AddText
$LN13@AddText:
  0022c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00230	10 00 00 00	 DD	 16			; 00000010H
  00234	00 00 00 00	 DD	 $LN12@AddText
$LN12@AddText:
  00238	63		 DB	 99			; 00000063H
  00239	6c		 DB	 108			; 0000006cH
  0023a	69		 DB	 105			; 00000069H
  0023b	70		 DB	 112			; 00000070H
  0023c	5f		 DB	 95			; 0000005fH
  0023d	72		 DB	 114			; 00000072H
  0023e	65		 DB	 101			; 00000065H
  0023f	63		 DB	 99			; 00000063H
  00240	74		 DB	 116			; 00000074H
  00241	00		 DB	 0
?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ENDP ; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddText@ImDrawList@@QAEXABUImVec2@@IPBD1@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pos$ = 8						; size = 4
_col$ = 12						; size = 4
_text_begin$ = 16					; size = 4
_text_end$ = 20						; size = 4
?AddText@ImDrawList@@QAEXABUImVec2@@IPBD1@Z PROC	; ImDrawList::AddText, COMDAT
; _this$ = ecx

; 1171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1172 :     AddText(NULL, 0.0f, pos, col, text_begin, text_end);

  0002d	6a 00		 push	 0
  0002f	51		 push	 ecx
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	8b 45 14	 mov	 eax, DWORD PTR _text_end$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _text_begin$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 0c	 mov	 edx, DWORD PTR _col$[ebp]
  00043	52		 push	 edx
  00044	8b 45 08	 mov	 eax, DWORD PTR _pos$[ebp]
  00047	50		 push	 eax
  00048	51		 push	 ecx
  00049	0f 57 c0	 xorps	 xmm0, xmm0
  0004c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00051	6a 00		 push	 0
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText

; 1173 : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 10 00	 ret	 16			; 00000010H
?AddText@ImDrawList@@QAEXABUImVec2@@IPBD1@Z ENDP	; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddNgonFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z
_TEXT	SEGMENT
_a_max$ = -20						; size = 4
_this$ = -8						; size = 4
_center$ = 8						; size = 4
_radius$ = 12						; size = 4
_col$ = 16						; size = 4
_num_segments$ = 20					; size = 4
?AddNgonFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z PROC	; ImDrawList::AddNgonFilled, COMDAT
; _this$ = ecx

; 1121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1122 :     if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	74 06		 je	 SHORT $LN3@AddNgonFil
  00037	83 7d 14 02	 cmp	 DWORD PTR _num_segments$[ebp], 2
  0003b	7f 02		 jg	 SHORT $LN2@AddNgonFil
$LN3@AddNgonFil:

; 1123 :         return;

  0003d	eb 61		 jmp	 SHORT $LN1@AddNgonFil
$LN2@AddNgonFil:

; 1124 : 
; 1125 :     // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1126 :     const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;

  0003f	f3 0f 2a 45 14	 cvtsi2ss xmm0, DWORD PTR _num_segments$[ebp]
  00044	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40c90fdb
  00054	f3 0f 2a 4d 14	 cvtsi2ss xmm1, DWORD PTR _num_segments$[ebp]
  00059	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005d	f3 0f 11 45 ec	 movss	 DWORD PTR _a_max$[ebp], xmm0

; 1127 :     PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);

  00062	8b 45 14	 mov	 eax, DWORD PTR _num_segments$[ebp]
  00065	83 e8 01	 sub	 eax, 1
  00068	50		 push	 eax
  00069	51		 push	 ecx
  0006a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _a_max$[ebp]
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	51		 push	 ecx
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007d	51		 push	 ecx
  0007e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _center$[ebp]
  0008b	51		 push	 ecx
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 1128 :     PathFillConvex(col);

  00094	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex
$LN1@AddNgonFil:

; 1129 : }

  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 10 00	 ret	 16			; 00000010H
?AddNgonFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ENDP	; ImDrawList::AddNgonFilled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddNgon@ImDrawList@@QAEXABUImVec2@@MIHM@Z
_TEXT	SEGMENT
_a_max$ = -20						; size = 4
_this$ = -8						; size = 4
_center$ = 8						; size = 4
_radius$ = 12						; size = 4
_col$ = 16						; size = 4
_num_segments$ = 20					; size = 4
_thickness$ = 24					; size = 4
?AddNgon@ImDrawList@@QAEXABUImVec2@@MIHM@Z PROC		; ImDrawList::AddNgon, COMDAT
; _this$ = ecx

; 1109 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1110 :     if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	74 06		 je	 SHORT $LN3@AddNgon
  00037	83 7d 14 02	 cmp	 DWORD PTR _num_segments$[ebp], 2
  0003b	7f 02		 jg	 SHORT $LN2@AddNgon
$LN3@AddNgon:

; 1111 :         return;

  0003d	eb 76		 jmp	 SHORT $LN1@AddNgon
$LN2@AddNgon:

; 1112 : 
; 1113 :     // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1114 :     const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;

  0003f	f3 0f 2a 45 14	 cvtsi2ss xmm0, DWORD PTR _num_segments$[ebp]
  00044	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40c90fdb
  00054	f3 0f 2a 4d 14	 cvtsi2ss xmm1, DWORD PTR _num_segments$[ebp]
  00059	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005d	f3 0f 11 45 ec	 movss	 DWORD PTR _a_max$[ebp], xmm0

; 1115 :     PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);

  00062	8b 45 14	 mov	 eax, DWORD PTR _num_segments$[ebp]
  00065	83 e8 01	 sub	 eax, 1
  00068	50		 push	 eax
  00069	51		 push	 ecx
  0006a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _a_max$[ebp]
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	51		 push	 ecx
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00082	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  0008a	51		 push	 ecx
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _center$[ebp]
  00093	51		 push	 ecx
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 1116 :     PathStroke(col, true, thickness);

  0009c	51		 push	 ecx
  0009d	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  000a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a7	6a 01		 push	 1
  000a9	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN1@AddNgon:

; 1117 : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 14 00	 ret	 20			; 00000014H
?AddNgon@ImDrawList@@QAEXABUImVec2@@MIHM@Z ENDP		; ImDrawList::AddNgon
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z
_TEXT	SEGMENT
_a_max$ = -20						; size = 4
_this$ = -8						; size = 4
_center$ = 8						; size = 4
_radius$ = 12						; size = 4
_col$ = 16						; size = 4
_num_segments$ = 20					; size = 4
?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z PROC	; ImDrawList::AddCircleFilled, COMDAT
; _this$ = ecx

; 1097 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1098 :     if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	74 06		 je	 SHORT $LN3@AddCircleF
  00037	83 7d 14 02	 cmp	 DWORD PTR _num_segments$[ebp], 2
  0003b	7f 02		 jg	 SHORT $LN2@AddCircleF
$LN3@AddCircleF:

; 1099 :         return;

  0003d	eb 61		 jmp	 SHORT $LN1@AddCircleF
$LN2@AddCircleF:

; 1100 : 
; 1101 :     // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1102 :     const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;

  0003f	f3 0f 2a 45 14	 cvtsi2ss xmm0, DWORD PTR _num_segments$[ebp]
  00044	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40c90fdb
  00054	f3 0f 2a 4d 14	 cvtsi2ss xmm1, DWORD PTR _num_segments$[ebp]
  00059	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005d	f3 0f 11 45 ec	 movss	 DWORD PTR _a_max$[ebp], xmm0

; 1103 :     PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);

  00062	8b 45 14	 mov	 eax, DWORD PTR _num_segments$[ebp]
  00065	83 e8 01	 sub	 eax, 1
  00068	50		 push	 eax
  00069	51		 push	 ecx
  0006a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _a_max$[ebp]
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	51		 push	 ecx
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007d	51		 push	 ecx
  0007e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _center$[ebp]
  0008b	51		 push	 ecx
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 1104 :     PathFillConvex(col);

  00094	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex
$LN1@AddCircleF:

; 1105 : }

  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 10 00	 ret	 16			; 00000010H
?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ENDP	; ImDrawList::AddCircleFilled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z
_TEXT	SEGMENT
_a_max$ = -20						; size = 4
_this$ = -8						; size = 4
_center$ = 8						; size = 4
_radius$ = 12						; size = 4
_col$ = 16						; size = 4
_num_segments$ = 20					; size = 4
_thickness$ = 24					; size = 4
?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z PROC	; ImDrawList::AddCircle, COMDAT
; _this$ = ecx

; 1086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1087 :     if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	74 06		 je	 SHORT $LN3@AddCircle
  00037	83 7d 14 02	 cmp	 DWORD PTR _num_segments$[ebp], 2
  0003b	7f 02		 jg	 SHORT $LN2@AddCircle
$LN3@AddCircle:

; 1088 :         return;

  0003d	eb 76		 jmp	 SHORT $LN1@AddCircle
$LN2@AddCircle:

; 1089 : 
; 1090 :     // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1091 :     const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;

  0003f	f3 0f 2a 45 14	 cvtsi2ss xmm0, DWORD PTR _num_segments$[ebp]
  00044	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40c90fdb
  00054	f3 0f 2a 4d 14	 cvtsi2ss xmm1, DWORD PTR _num_segments$[ebp]
  00059	f3 0f 5e c1	 divss	 xmm0, xmm1
  0005d	f3 0f 11 45 ec	 movss	 DWORD PTR _a_max$[ebp], xmm0

; 1092 :     PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);

  00062	8b 45 14	 mov	 eax, DWORD PTR _num_segments$[ebp]
  00065	83 e8 01	 sub	 eax, 1
  00068	50		 push	 eax
  00069	51		 push	 ecx
  0006a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _a_max$[ebp]
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	51		 push	 ecx
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00082	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  0008a	51		 push	 ecx
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _center$[ebp]
  00093	51		 push	 ecx
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo

; 1093 :     PathStroke(col, true, thickness);

  0009c	51		 push	 ecx
  0009d	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  000a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a7	6a 01		 push	 1
  000a9	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN1@AddCircle:

; 1094 : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 14 00	 ret	 20			; 00000014H
?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ENDP	; ImDrawList::AddCircle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_p3$ = 16						; size = 4
_col$ = 20						; size = 4
?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z PROC ; ImDrawList::AddTriangleFilled, COMDAT
; _this$ = ecx

; 1075 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1076 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 14	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 02		 jne	 SHORT $LN2@AddTriangl

; 1077 :         return;

  00037	eb 30		 jmp	 SHORT $LN1@AddTriangl
$LN2@AddTriangl:

; 1078 : 
; 1079 :     PathLineTo(p1);

  00039	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1080 :     PathLineTo(p2);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _p2$[ebp]
  00048	50		 push	 eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1081 :     PathLineTo(p3);

  00051	8b 45 10	 mov	 eax, DWORD PTR _p3$[ebp]
  00054	50		 push	 eax
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1082 :     PathFillConvex(col);

  0005d	8b 45 14	 mov	 eax, DWORD PTR _col$[ebp]
  00060	50		 push	 eax
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex
$LN1@AddTriangl:

; 1083 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 10 00	 ret	 16			; 00000010H
?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ENDP ; ImDrawList::AddTriangleFilled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_p3$ = 16						; size = 4
_col$ = 20						; size = 4
_thickness$ = 24					; size = 4
?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z PROC	; ImDrawList::AddTriangle, COMDAT
; _this$ = ecx

; 1064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1065 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 14	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 02		 jne	 SHORT $LN2@AddTriangl

; 1066 :         return;

  00037	eb 3d		 jmp	 SHORT $LN1@AddTriangl
$LN2@AddTriangl:

; 1067 : 
; 1068 :     PathLineTo(p1);

  00039	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1069 :     PathLineTo(p2);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _p2$[ebp]
  00048	50		 push	 eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1070 :     PathLineTo(p3);

  00051	8b 45 10	 mov	 eax, DWORD PTR _p3$[ebp]
  00054	50		 push	 eax
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1071 :     PathStroke(col, true, thickness);

  0005d	51		 push	 ecx
  0005e	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	6a 01		 push	 1
  0006a	8b 45 14	 mov	 eax, DWORD PTR _col$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN1@AddTriangl:

; 1072 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 14 00	 ret	 20			; 00000014H
?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z ENDP	; ImDrawList::AddTriangle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddQuadFilled@ImDrawList@@QAEXABUImVec2@@000I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_p3$ = 16						; size = 4
_p4$ = 20						; size = 4
_col$ = 24						; size = 4
?AddQuadFilled@ImDrawList@@QAEXABUImVec2@@000I@Z PROC	; ImDrawList::AddQuadFilled, COMDAT
; _this$ = ecx

; 1052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1053 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 02		 jne	 SHORT $LN2@AddQuadFil

; 1054 :         return;

  00037	eb 3c		 jmp	 SHORT $LN1@AddQuadFil
$LN2@AddQuadFil:

; 1055 : 
; 1056 :     PathLineTo(p1);

  00039	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1057 :     PathLineTo(p2);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _p2$[ebp]
  00048	50		 push	 eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1058 :     PathLineTo(p3);

  00051	8b 45 10	 mov	 eax, DWORD PTR _p3$[ebp]
  00054	50		 push	 eax
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1059 :     PathLineTo(p4);

  0005d	8b 45 14	 mov	 eax, DWORD PTR _p4$[ebp]
  00060	50		 push	 eax
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1060 :     PathFillConvex(col);

  00069	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex
$LN1@AddQuadFil:

; 1061 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 14 00	 ret	 20			; 00000014H
?AddQuadFilled@ImDrawList@@QAEXABUImVec2@@000I@Z ENDP	; ImDrawList::AddQuadFilled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddQuad@ImDrawList@@QAEXABUImVec2@@000IM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_p3$ = 16						; size = 4
_p4$ = 20						; size = 4
_col$ = 24						; size = 4
_thickness$ = 28					; size = 4
?AddQuad@ImDrawList@@QAEXABUImVec2@@000IM@Z PROC	; ImDrawList::AddQuad, COMDAT
; _this$ = ecx

; 1040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1041 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 02		 jne	 SHORT $LN2@AddQuad

; 1042 :         return;

  00037	eb 49		 jmp	 SHORT $LN1@AddQuad
$LN2@AddQuad:

; 1043 : 
; 1044 :     PathLineTo(p1);

  00039	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1045 :     PathLineTo(p2);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _p2$[ebp]
  00048	50		 push	 eax
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1046 :     PathLineTo(p3);

  00051	8b 45 10	 mov	 eax, DWORD PTR _p3$[ebp]
  00054	50		 push	 eax
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1047 :     PathLineTo(p4);

  0005d	8b 45 14	 mov	 eax, DWORD PTR _p4$[ebp]
  00060	50		 push	 eax
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 1048 :     PathStroke(col, true, thickness);

  00069	51		 push	 ecx
  0006a	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	6a 01		 push	 1
  00076	8b 45 18	 mov	 eax, DWORD PTR _col$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN1@AddQuad:

; 1049 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 18 00	 ret	 24			; 00000018H
?AddQuad@ImDrawList@@QAEXABUImVec2@@000IM@Z ENDP	; ImDrawList::AddQuad
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z
_TEXT	SEGMENT
$T1 = -252						; size = 8
$T2 = -236						; size = 8
_uv$ = -28						; size = 8
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_p_min$ = 8						; size = 4
_p_max$ = 12						; size = 4
_col_upr_left$ = 16					; size = 4
_col_upr_right$ = 20					; size = 4
_col_bot_right$ = 24					; size = 4
_col_bot_left$ = 28					; size = 4
?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z PROC ; ImDrawList::AddRectFilledMultiColor, COMDAT
; _this$ = ecx

; 1025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00013	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1026 :     if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)

  00037	8b 45 10	 mov	 eax, DWORD PTR _col_upr_left$[ebp]
  0003a	0b 45 14	 or	 eax, DWORD PTR _col_upr_right$[ebp]
  0003d	0b 45 18	 or	 eax, DWORD PTR _col_bot_right$[ebp]
  00040	0b 45 1c	 or	 eax, DWORD PTR _col_bot_left$[ebp]
  00043	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00048	75 05		 jne	 SHORT $LN2@AddRectFil

; 1027 :         return;

  0004a	e9 1b 01 00 00	 jmp	 $LN1@AddRectFil
$LN2@AddRectFil:

; 1028 : 
; 1029 :     const ImVec2 uv = _Data->TexUvWhitePixel;

  0004f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005a	89 55 e4	 mov	 DWORD PTR _uv$[ebp], edx
  0005d	89 45 e8	 mov	 DWORD PTR _uv$[ebp+4], eax

; 1030 :     PrimReserve(6, 4);

  00060	6a 04		 push	 4
  00062	6a 06		 push	 6
  00064	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 1031 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));

  0006c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  00073	51		 push	 ecx
  00074	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?PrimWriteIdx@ImDrawList@@QAEXG@Z ; ImDrawList::PrimWriteIdx
  0007c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00082	83 c1 01	 add	 ecx, 1
  00085	51		 push	 ecx
  00086	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?PrimWriteIdx@ImDrawList@@QAEXG@Z ; ImDrawList::PrimWriteIdx
  0008e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00094	83 c1 02	 add	 ecx, 2
  00097	51		 push	 ecx
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?PrimWriteIdx@ImDrawList@@QAEXG@Z ; ImDrawList::PrimWriteIdx

; 1032 :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  000a7	51		 push	 ecx
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	e8 00 00 00 00	 call	 ?PrimWriteIdx@ImDrawList@@QAEXG@Z ; ImDrawList::PrimWriteIdx
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b6	83 c1 02	 add	 ecx, 2
  000b9	51		 push	 ecx
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?PrimWriteIdx@ImDrawList@@QAEXG@Z ; ImDrawList::PrimWriteIdx
  000c2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000c8	83 c1 03	 add	 ecx, 3
  000cb	51		 push	 ecx
  000cc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	e8 00 00 00 00	 call	 ?PrimWriteIdx@ImDrawList@@QAEXG@Z ; ImDrawList::PrimWriteIdx

; 1033 :     PrimWriteVtx(p_min, uv, col_upr_left);

  000d4	8b 45 10	 mov	 eax, DWORD PTR _col_upr_left$[ebp]
  000d7	50		 push	 eax
  000d8	8d 4d e4	 lea	 ecx, DWORD PTR _uv$[ebp]
  000db	51		 push	 ecx
  000dc	8b 55 08	 mov	 edx, DWORD PTR _p_min$[ebp]
  000df	52		 push	 edx
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx

; 1034 :     PrimWriteVtx(ImVec2(p_max.x, p_min.y), uv, col_upr_right);

  000e8	8b 45 14	 mov	 eax, DWORD PTR _col_upr_right$[ebp]
  000eb	50		 push	 eax
  000ec	8d 4d e4	 lea	 ecx, DWORD PTR _uv$[ebp]
  000ef	51		 push	 ecx
  000f0	8b 55 08	 mov	 edx, DWORD PTR _p_min$[ebp]
  000f3	51		 push	 ecx
  000f4	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  000f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fe	8b 45 0c	 mov	 eax, DWORD PTR _p_max$[ebp]
  00101	51		 push	 ecx
  00102	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00106	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010b	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00111	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00116	50		 push	 eax
  00117	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	e8 00 00 00 00	 call	 ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx

; 1035 :     PrimWriteVtx(p_max, uv, col_bot_right);

  0011f	8b 45 18	 mov	 eax, DWORD PTR _col_bot_right$[ebp]
  00122	50		 push	 eax
  00123	8d 4d e4	 lea	 ecx, DWORD PTR _uv$[ebp]
  00126	51		 push	 ecx
  00127	8b 55 0c	 mov	 edx, DWORD PTR _p_max$[ebp]
  0012a	52		 push	 edx
  0012b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx

; 1036 :     PrimWriteVtx(ImVec2(p_min.x, p_max.y), uv, col_bot_left);

  00133	8b 45 1c	 mov	 eax, DWORD PTR _col_bot_left$[ebp]
  00136	50		 push	 eax
  00137	8d 4d e4	 lea	 ecx, DWORD PTR _uv$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 55 0c	 mov	 edx, DWORD PTR _p_max$[ebp]
  0013e	51		 push	 ecx
  0013f	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  00144	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00149	8b 45 08	 mov	 eax, DWORD PTR _p_min$[ebp]
  0014c	51		 push	 ecx
  0014d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00151	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00156	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0015c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00161	50		 push	 eax
  00162	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00165	e8 00 00 00 00	 call	 ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimWriteVtx
$LN1@AddRectFil:

; 1037 : }

  0016a	52		 push	 edx
  0016b	8b cd		 mov	 ecx, ebp
  0016d	50		 push	 eax
  0016e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@AddRectFil
  00174	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00179	58		 pop	 eax
  0017a	5a		 pop	 edx
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00181	33 cd		 xor	 ecx, ebp
  00183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00188	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  0018e	3b ec		 cmp	 ebp, esp
  00190	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c2 18 00	 ret	 24			; 00000018H
  0019b	90		 npad	 1
$LN6@AddRectFil:
  0019c	01 00 00 00	 DD	 1
  001a0	00 00 00 00	 DD	 $LN5@AddRectFil
$LN5@AddRectFil:
  001a4	e4 ff ff ff	 DD	 -28			; ffffffe4H
  001a8	08 00 00 00	 DD	 8
  001ac	00 00 00 00	 DD	 $LN4@AddRectFil
$LN4@AddRectFil:
  001b0	75		 DB	 117			; 00000075H
  001b1	76		 DB	 118			; 00000076H
  001b2	00		 DB	 0
?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ENDP ; ImDrawList::AddRectFilledMultiColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_p_min$ = 8						; size = 4
_p_max$ = 12						; size = 4
_col$ = 16						; size = 4
_rounding$ = 20						; size = 4
_rounding_corners$ = 24					; size = 4
?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z PROC	; ImDrawList::AddRectFilled, COMDAT
; _this$ = ecx

; 1008 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1009 :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 02		 jne	 SHORT $LN2@AddRectFil

; 1010 :         return;

  00037	eb 5b		 jmp	 SHORT $LN1@AddRectFil
$LN2@AddRectFil:

; 1011 :     if (rounding > 0.0f)

  00039	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  0003e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00045	76 2d		 jbe	 SHORT $LN3@AddRectFil

; 1012 :     {
; 1013 :         PathRect(p_min, p_max, rounding, rounding_corners);

  00047	8b 45 18	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  0004a	50		 push	 eax
  0004b	51		 push	 ecx
  0004c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 08	 mov	 edx, DWORD PTR _p_min$[ebp]
  0005d	52		 push	 edx
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ; ImDrawList::PathRect

; 1014 :         PathFillConvex(col);

  00066	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?PathFillConvex@ImDrawList@@QAEXI@Z ; ImDrawList::PathFillConvex

; 1015 :     }

  00072	eb 20		 jmp	 SHORT $LN4@AddRectFil
$LN3@AddRectFil:

; 1016 :     else
; 1017 :     {
; 1018 :         PrimReserve(6, 4);

  00074	6a 04		 push	 4
  00076	6a 06		 push	 6
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QAEXHH@Z ; ImDrawList::PrimReserve

; 1019 :         PrimRect(p_min, p_max, col);

  00080	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  00087	51		 push	 ecx
  00088	8b 55 08	 mov	 edx, DWORD PTR _p_min$[ebp]
  0008b	52		 push	 edx
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimRect
$LN4@AddRectFil:
$LN1@AddRectFil:

; 1020 :     }
; 1021 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0009d	3b ec		 cmp	 ebp, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 14 00	 ret	 20			; 00000014H
?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ENDP	; ImDrawList::AddRectFilled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z
_TEXT	SEGMENT
$T1 = -328						; size = 8
$T2 = -312						; size = 8
$T3 = -296						; size = 8
$T4 = -280						; size = 8
$T5 = -264						; size = 8
$T6 = -248						; size = 8
$T7 = -232						; size = 8
$T8 = -216						; size = 8
_this$ = -8						; size = 4
_p_min$ = 8						; size = 4
_p_max$ = 12						; size = 4
_col$ = 16						; size = 4
_rounding$ = 20						; size = 4
_rounding_corners$ = 24					; size = 4
_thickness$ = 28					; size = 4
?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z PROC	; ImDrawList::AddRect, COMDAT
; _this$ = ecx

; 997  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd b4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-332]
  00013	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 998  :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 05		 jne	 SHORT $LN2@AddRect

; 999  :         return;

  00037	e9 4b 01 00 00	 jmp	 $LN1@AddRect
$LN2@AddRect:

; 1000 :     if (Flags & ImDrawListFlags_AntiAliasedLines)

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00042	83 e1 01	 and	 ecx, 1
  00045	0f 84 94 00 00
	00		 je	 $LN3@AddRect

; 1001 :         PathRect(p_min + ImVec2(0.50f,0.50f), p_max - ImVec2(0.50f,0.50f), rounding, rounding_corners);

  0004b	8b 45 18	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  0004e	50		 push	 eax
  0004f	51		 push	 ecx
  00050	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  00055	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005a	51		 push	 ecx
  0005b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00063	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00068	51		 push	 ecx
  00069	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00071	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00076	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0007c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00081	50		 push	 eax
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  00085	51		 push	 ecx
  00086	8d 95 18 ff ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	50		 push	 eax
  00096	51		 push	 ecx
  00097	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0009f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a4	51		 push	 ecx
  000a5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b2	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000b8	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000bd	50		 push	 eax
  000be	8b 45 08	 mov	 eax, DWORD PTR _p_min$[ebp]
  000c1	50		 push	 eax
  000c2	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	50		 push	 eax
  000d2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ; ImDrawList::PathRect
  000da	e9 8f 00 00 00	 jmp	 $LN4@AddRect
$LN3@AddRect:

; 1002 :     else
; 1003 :         PathRect(p_min + ImVec2(0.50f,0.50f), p_max - ImVec2(0.49f,0.49f), rounding, rounding_corners); // Better looking lower-right corner and rounded non-AA shapes.

  000df	8b 45 18	 mov	 eax, DWORD PTR _rounding_corners$[ebp]
  000e2	50		 push	 eax
  000e3	51		 push	 ecx
  000e4	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _rounding$[ebp]
  000e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ee	51		 push	 ecx
  000ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  000f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fc	51		 push	 ecx
  000fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  00105	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010a	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00110	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00115	50		 push	 eax
  00116	8b 4d 0c	 mov	 ecx, DWORD PTR _p_max$[ebp]
  00119	51		 push	 ecx
  0011a	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 ??G@YA?AUImVec2@@ABU0@0@Z ; operator-
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH
  00129	50		 push	 eax
  0012a	51		 push	 ecx
  0012b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00133	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00138	51		 push	 ecx
  00139	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00141	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00146	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0014c	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00151	50		 push	 eax
  00152	8b 45 08	 mov	 eax, DWORD PTR _p_min$[ebp]
  00155	50		 push	 eax
  00156	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH
  00165	50		 push	 eax
  00166	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00169	e8 00 00 00 00	 call	 ?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ; ImDrawList::PathRect
$LN4@AddRect:

; 1004 :     PathStroke(col, true, thickness);

  0016e	51		 push	 ecx
  0016f	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	6a 01		 push	 1
  0017b	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  0017e	50		 push	 eax
  0017f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN1@AddRect:

; 1005 : }

  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
  0018a	81 c4 4c 01 00
	00		 add	 esp, 332		; 0000014cH
  00190	3b ec		 cmp	 ebp, esp
  00192	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c2 18 00	 ret	 24			; 00000018H
?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ENDP	; ImDrawList::AddRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z
_TEXT	SEGMENT
$T1 = -264						; size = 8
$T2 = -248						; size = 8
$T3 = -232						; size = 8
$T4 = -216						; size = 8
_this$ = -8						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_col$ = 16						; size = 4
_thickness$ = 20					; size = 4
?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z PROC		; ImDrawList::AddLine, COMDAT
; _this$ = ecx

; 986  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00013	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 987  :     if ((col & IM_COL32_A_MASK) == 0)

  0002d	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  00030	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00035	75 05		 jne	 SHORT $LN2@AddLine

; 988  :         return;

  00037	e9 a1 00 00 00	 jmp	 $LN1@AddLine
$LN2@AddLine:

; 989  :     PathLineTo(p1 + ImVec2(0.5f, 0.5f));

  0003c	51		 push	 ecx
  0003d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	51		 push	 ecx
  0004b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00053	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00058	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0005e	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00063	50		 push	 eax
  00064	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  00067	50		 push	 eax
  00068	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 990  :     PathLineTo(p2 + ImVec2(0.5f, 0.5f));

  00080	51		 push	 ecx
  00081	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00089	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008e	51		 push	 ecx
  0008f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00097	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009c	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a2	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  000a7	50		 push	 eax
  000a8	8b 45 0c	 mov	 eax, DWORD PTR _p2$[ebp]
  000ab	50		 push	 eax
  000ac	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ??H@YA?AUImVec2@@ABU0@0@Z ; operator+
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	50		 push	 eax
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ; ImDrawList::PathLineTo

; 991  :     PathStroke(col, false, thickness);

  000c4	51		 push	 ecx
  000c5	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _thickness$[ebp]
  000ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cf	6a 00		 push	 0
  000d1	8b 45 10	 mov	 eax, DWORD PTR _col$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?PathStroke@ImDrawList@@QAEXI_NM@Z ; ImDrawList::PathStroke
$LN1@AddLine:

; 992  : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  000e6	3b ec		 cmp	 ebp, esp
  000e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 10 00	 ret	 16			; 00000010H
?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ENDP		; ImDrawList::AddLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PopTextureID@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PopTextureID@ImDrawList@@QAEXXZ PROC			; ImDrawList::PopTextureID, COMDAT
; _this$ = ecx

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 514  :     IM_ASSERT(_TextureIdStack.Size > 0);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00034	7f 26		 jg	 SHORT $LN3@PopTexture
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??PopTextureID@ImDrawList@@QAEXXZ@4JA
  0003c	83 c1 01	 add	 ecx, 1
  0003f	8b f4		 mov	 esi, esp
  00041	51		 push	 ecx
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@CKLENJON@?$AA_?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AAI?$AAd?$AAS?$AAt?$AAa?$AAc?$AAk@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@PopTexture:

; 515  :     _TextureIdStack.pop_back();

  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00062	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@PAX@@QAEXXZ ; ImVector<void *>::pop_back

; 516  :     UpdateTextureID();

  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?UpdateTextureID@ImDrawList@@QAEXXZ ; ImDrawList::UpdateTextureID

; 517  : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?PopTextureID@ImDrawList@@QAEXXZ ENDP			; ImDrawList::PopTextureID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PushTextureID@ImDrawList@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_texture_id$ = 8					; size = 4
?PushTextureID@ImDrawList@@QAEXPAX@Z PROC		; ImDrawList::PushTextureID, COMDAT
; _this$ = ecx

; 507  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 508  :     _TextureIdStack.push_back(texture_id);

  0002d	8d 45 08	 lea	 eax, DWORD PTR _texture_id$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00037	e8 00 00 00 00	 call	 ?push_back@?$ImVector@PAX@@QAEXABQAX@Z ; ImVector<void *>::push_back

; 509  :     UpdateTextureID();

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?UpdateTextureID@ImDrawList@@QAEXXZ ; ImDrawList::UpdateTextureID

; 510  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?PushTextureID@ImDrawList@@QAEXPAX@Z ENDP		; ImDrawList::PushTextureID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PopClipRect@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PopClipRect@ImDrawList@@QAEXXZ PROC			; ImDrawList::PopClipRect, COMDAT
; _this$ = ecx

; 500  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 501  :     IM_ASSERT(_ClipRectStack.Size > 0);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00034	7f 26		 jg	 SHORT $LN3@PopClipRec
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??PopClipRect@ImDrawList@@QAEXXZ@4JA
  0003c	83 c1 01	 add	 ecx, 1
  0003f	8b f4		 mov	 esi, esp
  00041	51		 push	 ecx
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@MJAOFGMF@?$AA_?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe?$AAc?$AAt?$AAS?$AAt?$AAa?$AAc?$AAk?$AA?4@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@PopClipRec:

; 502  :     _ClipRectStack.pop_back();

  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 40	 add	 ecx, 64			; 00000040H
  00062	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImVec4@@@@QAEXXZ ; ImVector<ImVec4>::pop_back

; 503  :     UpdateClipRect();

  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?UpdateClipRect@ImDrawList@@QAEXXZ ; ImDrawList::UpdateClipRect

; 504  : }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?PopClipRect@ImDrawList@@QAEXXZ ENDP			; ImDrawList::PopClipRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PushClipRectFullScreen@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
$T1 = -232						; size = 8
$T2 = -216						; size = 8
_this$ = -8						; size = 4
?PushClipRectFullScreen@ImDrawList@@QAEXXZ PROC		; ImDrawList::PushClipRectFullScreen, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 00 00
	00		 sub	 esp, 236		; 000000ecH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-236]
  00013	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 496  :     PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));

  0002d	6a 00		 push	 0
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00035	51		 push	 ecx
  00036	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [ecx+32]
  0003b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00040	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00046	51		 push	 ecx
  00047	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  0004c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00051	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00057	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  0005c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005f	51		 push	 ecx
  00060	8b 10		 mov	 edx, DWORD PTR [eax]
  00062	52		 push	 edx
  00063	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00069	51		 push	 ecx
  0006a	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00077	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0007a	51		 push	 ecx
  0007b	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00080	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00085	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0008b	e8 00 00 00 00	 call	 ??0ImVec2@@QAE@MM@Z	; ImVec2::ImVec2
  00090	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00093	51		 push	 ecx
  00094	8b 10		 mov	 edx, DWORD PTR [eax]
  00096	52		 push	 edx
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z ; ImDrawList::PushClipRect

; 497  : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?PushClipRectFullScreen@ImDrawList@@QAEXXZ ENDP		; ImDrawList::PushClipRectFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z
_TEXT	SEGMENT
_current$1 = -60					; size = 16
_cr$ = -36						; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_cr_min$ = 8						; size = 8
_cr_max$ = 16						; size = 8
_intersect_with_current_clip_rect$ = 24			; size = 1
?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z PROC	; ImDrawList::PushClipRect, COMDAT
; _this$ = ecx

; 477  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00013	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 478  :     ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);

  00037	51		 push	 ecx
  00038	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _cr_max$[ebp+4]
  0003d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00042	51		 push	 ecx
  00043	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _cr_max$[ebp]
  00048	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004d	51		 push	 ecx
  0004e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _cr_min$[ebp+4]
  00053	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00058	51		 push	 ecx
  00059	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _cr_min$[ebp]
  0005e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00063	8d 4d dc	 lea	 ecx, DWORD PTR _cr$[ebp]
  00066	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4

; 479  :     if (intersect_with_current_clip_rect && _ClipRectStack.Size)

  0006b	0f b6 45 18	 movzx	 eax, BYTE PTR _intersect_with_current_clip_rect$[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 88 00 00
	00		 je	 $LN6@PushClipRe
  00077	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  0007e	74 7f		 je	 SHORT $LN6@PushClipRe

; 480  :     {
; 481  :         ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];

  00080	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00086	83 e9 01	 sub	 ecx, 1
  00089	c1 e1 04	 shl	 ecx, 4
  0008c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00092	03 c1		 add	 eax, ecx
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	89 4d c4	 mov	 DWORD PTR _current$1[ebp], ecx
  00099	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009c	89 55 c8	 mov	 DWORD PTR _current$1[ebp+4], edx
  0009f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a2	89 4d cc	 mov	 DWORD PTR _current$1[ebp+8], ecx
  000a5	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000a8	89 55 d0	 mov	 DWORD PTR _current$1[ebp+12], edx

; 482  :         if (cr.x < current.x) cr.x = current.x;

  000ab	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _current$1[ebp]
  000b0	0f 2f 45 dc	 comiss	 xmm0, DWORD PTR _cr$[ebp]
  000b4	76 0a		 jbe	 SHORT $LN3@PushClipRe
  000b6	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _current$1[ebp]
  000bb	f3 0f 11 45 dc	 movss	 DWORD PTR _cr$[ebp], xmm0
$LN3@PushClipRe:

; 483  :         if (cr.y < current.y) cr.y = current.y;

  000c0	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _current$1[ebp+4]
  000c5	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR _cr$[ebp+4]
  000c9	76 0a		 jbe	 SHORT $LN4@PushClipRe
  000cb	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _current$1[ebp+4]
  000d0	f3 0f 11 45 e0	 movss	 DWORD PTR _cr$[ebp+4], xmm0
$LN4@PushClipRe:

; 484  :         if (cr.z > current.z) cr.z = current.z;

  000d5	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _cr$[ebp+8]
  000da	0f 2f 45 cc	 comiss	 xmm0, DWORD PTR _current$1[ebp+8]
  000de	76 0a		 jbe	 SHORT $LN5@PushClipRe
  000e0	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _current$1[ebp+8]
  000e5	f3 0f 11 45 e4	 movss	 DWORD PTR _cr$[ebp+8], xmm0
$LN5@PushClipRe:

; 485  :         if (cr.w > current.w) cr.w = current.w;

  000ea	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _cr$[ebp+12]
  000ef	0f 2f 45 d0	 comiss	 xmm0, DWORD PTR _current$1[ebp+12]
  000f3	76 0a		 jbe	 SHORT $LN6@PushClipRe
  000f5	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _current$1[ebp+12]
  000fa	f3 0f 11 45 e8	 movss	 DWORD PTR _cr$[ebp+12], xmm0
$LN6@PushClipRe:

; 486  :     }
; 487  :     cr.z = ImMax(cr.x, cr.z);

  000ff	51		 push	 ecx
  00100	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _cr$[ebp+8]
  00105	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010a	51		 push	 ecx
  0010b	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _cr$[ebp]
  00110	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00115	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0011a	83 c4 08	 add	 esp, 8
  0011d	d9 5d e4	 fstp	 DWORD PTR _cr$[ebp+8]

; 488  :     cr.w = ImMax(cr.y, cr.w);

  00120	51		 push	 ecx
  00121	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _cr$[ebp+12]
  00126	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012b	51		 push	 ecx
  0012c	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _cr$[ebp+4]
  00131	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00136	e8 00 00 00 00	 call	 ??$ImMax@M@@YAMMM@Z	; ImMax<float>
  0013b	83 c4 08	 add	 esp, 8
  0013e	d9 5d e8	 fstp	 DWORD PTR _cr$[ebp+12]

; 489  : 
; 490  :     _ClipRectStack.push_back(cr);

  00141	8d 45 dc	 lea	 eax, DWORD PTR _cr$[ebp]
  00144	50		 push	 eax
  00145	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	83 c1 40	 add	 ecx, 64			; 00000040H
  0014b	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z ; ImVector<ImVec4>::push_back

; 491  :     UpdateClipRect();

  00150	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	e8 00 00 00 00	 call	 ?UpdateClipRect@ImDrawList@@QAEXXZ ; ImDrawList::UpdateClipRect

; 492  : }

  00158	52		 push	 edx
  00159	8b cd		 mov	 ecx, ebp
  0015b	50		 push	 eax
  0015c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@PushClipRe
  00162	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00167	58		 pop	 eax
  00168	5a		 pop	 edx
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016f	33 cd		 xor	 ecx, ebp
  00171	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00176	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  0017c	3b ec		 cmp	 ebp, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 14 00	 ret	 20			; 00000014H
  00189	0f 1f 00	 npad	 3
$LN11@PushClipRe:
  0018c	02 00 00 00	 DD	 2
  00190	00 00 00 00	 DD	 $LN10@PushClipRe
$LN10@PushClipRe:
  00194	dc ff ff ff	 DD	 -36			; ffffffdcH
  00198	10 00 00 00	 DD	 16			; 00000010H
  0019c	00 00 00 00	 DD	 $LN8@PushClipRe
  001a0	c4 ff ff ff	 DD	 -60			; ffffffc4H
  001a4	10 00 00 00	 DD	 16			; 00000010H
  001a8	00 00 00 00	 DD	 $LN9@PushClipRe
$LN9@PushClipRe:
  001ac	63		 DB	 99			; 00000063H
  001ad	75		 DB	 117			; 00000075H
  001ae	72		 DB	 114			; 00000072H
  001af	72		 DB	 114			; 00000072H
  001b0	65		 DB	 101			; 00000065H
  001b1	6e		 DB	 110			; 0000006eH
  001b2	74		 DB	 116			; 00000074H
  001b3	00		 DB	 0
$LN8@PushClipRe:
  001b4	63		 DB	 99			; 00000063H
  001b5	72		 DB	 114			; 00000072H
  001b6	00		 DB	 0
?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z ENDP	; ImDrawList::PushClipRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_shared_data$ = 8					; size = 4
??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z PROC	; ImDrawList::ImDrawList, COMDAT
; _this$ = ecx

; 1916 :     ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??0?$ImVector@UImDrawCmd@@@@QAE@XZ ; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00061	e8 00 00 00 00	 call	 ??0?$ImVector@G@@QAE@XZ	; ImVector<unsigned short>::ImVector<unsigned short>
  00066	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	83 c1 18	 add	 ecx, 24			; 00000018H
  00070	e8 00 00 00 00	 call	 ??0?$ImVector@UImDrawVert@@@@QAE@XZ ; ImVector<ImDrawVert>::ImVector<ImDrawVert>
  00075	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 c1 40	 add	 ecx, 64			; 00000040H
  0007f	e8 00 00 00 00	 call	 ??0?$ImVector@UImVec4@@@@QAE@XZ ; ImVector<ImVec4>::ImVector<ImVec4>
  00084	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00088	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0008e	e8 00 00 00 00	 call	 ??0?$ImVector@PAX@@QAE@XZ ; ImVector<void *>::ImVector<void *>
  00093	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00097	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	83 c1 58	 add	 ecx, 88			; 00000058H
  0009d	e8 00 00 00 00	 call	 ??0?$ImVector@UImVec2@@@@QAE@XZ ; ImVector<ImVec2>::ImVector<ImVec2>
  000a2	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	83 c1 64	 add	 ecx, 100		; 00000064H
  000ac	e8 00 00 00 00	 call	 ??0ImDrawListSplitter@@QAE@XZ ; ImDrawListSplitter::ImDrawListSplitter
  000b1	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  000b5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _shared_data$[ebp]
  000bb	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  000be	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  000c8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?Clear@ImDrawList@@QAEXXZ ; ImDrawList::Clear
  000d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e4	59		 pop	 ecx
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000ee	3b ec		 cmp	 ebp, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImDrawCmd@@@@QAE@XZ ; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$ImVector@G@@QAE@XZ	; ImVector<unsigned short>::~ImVector<unsigned short>
__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$2:
  00013	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 18	 add	 ecx, 24			; 00000018H
  00019	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImDrawVert@@@@QAE@XZ ; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$3:
  0001e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 40	 add	 ecx, 64			; 00000040H
  00024	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImVec4@@@@QAE@XZ ; ImVector<ImVec4>::~ImVector<ImVec4>
__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$4:
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$ImVector@PAX@@QAE@XZ ; ImVector<void *>::~ImVector<void *>
__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$5:
  00034	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 58	 add	 ecx, 88			; 00000058H
  0003a	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImVec2@@@@QAE@XZ ; ImVector<ImVec2>::~ImVector<ImVec2>
__unwindfunclet$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z$6:
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 64	 add	 ecx, 100		; 00000064H
  00045	e9 00 00 00 00	 jmp	 ??1ImDrawListSplitter@@QAE@XZ ; ImDrawListSplitter::~ImDrawListSplitter
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0005e	33 c8		 xor	 ecx, eax
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z
  0006a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImDrawList@@QAE@PBUImDrawListSharedData@@@Z ENDP	; ImDrawList::ImDrawList
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z PROC	; ImVector<ImVec2>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z ; ImVector<ImVec2>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ; ImVector<ImVec2>::reserve
$LN2@push_back:
  00054	6a 08		 push	 8
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 d1	 lea	 edx, DWORD PTR [ecx+edx*8]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ENDP	; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 03	 shl	 eax, 3
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 03	 shl	 ecx, 3
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z ; ImVector<ImVec2>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ; ImVector<ImVec2>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImVec2@@@@QBEHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ PROC	; ImVector<ImVec2>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00061	8d 44 c8 f8	 lea	 eax, DWORD PTR [eax+ecx*8-8]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ ENDP	; ImVector<ImVec2>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec2@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImVec2@@@@QAEXXZ PROC		; ImVector<ImVec2>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImVec2@@@@QAEXXZ ENDP		; ImVector<ImVec2>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec2@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImVec2@@@@QAE@XZ PROC			; ImVector<ImVec2>::~ImVector<ImVec2>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImVec2@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImVec2@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImVec2@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImVec2@@@@QAE@XZ ENDP			; ImVector<ImVec2>::~ImVector<ImVec2>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec2@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImVec2@@@@QAE@XZ PROC			; ImVector<ImVec2>::ImVector<ImVec2>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImVec2@@@@QAE@XZ ENDP			; ImVector<ImVec2>::ImVector<ImVec2>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PAX@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?pop_back@?$ImVector@PAX@@QAEXXZ PROC			; ImVector<void *>::pop_back, COMDAT
; _this$ = ecx

; 1294 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@pop_back
  00035	8b f4		 mov	 esi, esp
  00037	68 0e 05 00 00	 push	 1294			; 0000050eH
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@pop_back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	89 0a		 mov	 DWORD PTR [edx], ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?pop_back@?$ImVector@PAX@@QAEXXZ ENDP			; ImVector<void *>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAX@@QAEXABQAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@PAX@@QAEXABQAX@Z PROC		; ImVector<void *>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@PAX@@QBEHH@Z ; ImVector<void *>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@PAX@@QAEXH@Z ; ImVector<void *>::reserve
$LN2@push_back:
  00054	6a 04		 push	 4
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@PAX@@QAEXABQAX@Z ENDP		; ImVector<void *>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAX@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAX@@QAEXH@Z PROC			; ImVector<void *>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 02	 shl	 eax, 2
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 02	 shl	 ecx, 2
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@PAX@@QAEXH@Z ENDP			; ImVector<void *>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PAX@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@PAX@@QAEXH@Z PROC			; ImVector<void *>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@PAX@@QBEHH@Z ; ImVector<void *>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@PAX@@QAEXH@Z ; ImVector<void *>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@PAX@@QAEXH@Z ENDP			; ImVector<void *>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAX@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAX@@QBEHH@Z PROC		; ImVector<void *>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@PAX@@QBEHH@Z ENDP		; ImVector<void *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@PAX@@QAEAAPAXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@PAX@@QAEAAPAXXZ PROC			; ImVector<void *>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00061	8d 44 88 fc	 lea	 eax, DWORD PTR [eax+ecx*4-4]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?back@?$ImVector@PAX@@QAEAAPAXXZ ENDP			; ImVector<void *>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAX@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@PAX@@QAEXXZ PROC			; ImVector<void *>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@PAX@@QAEXXZ ENDP			; ImVector<void *>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PAX@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@PAX@@QBE_NXZ PROC			; ImVector<void *>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@PAX@@QBE_NXZ ENDP			; ImVector<void *>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAX@@QAE@XZ PROC				; ImVector<void *>::~ImVector<void *>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@PAX@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAX@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@PAX@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAX@@QAE@XZ ENDP				; ImVector<void *>::~ImVector<void *>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@PAX@@QAE@XZ PROC				; ImVector<void *>::ImVector<void *>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@PAX@@QAE@XZ ENDP				; ImVector<void *>::ImVector<void *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImVec4@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?pop_back@?$ImVector@UImVec4@@@@QAEXXZ PROC		; ImVector<ImVec4>::pop_back, COMDAT
; _this$ = ecx

; 1294 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@pop_back
  00035	8b f4		 mov	 esi, esp
  00037	68 0e 05 00 00	 push	 1294			; 0000050eH
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@pop_back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	89 0a		 mov	 DWORD PTR [edx], ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?pop_back@?$ImVector@UImVec4@@@@QAEXXZ ENDP		; ImVector<ImVec4>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z PROC	; ImVector<ImVec4>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImVec4@@@@QBEHH@Z ; ImVector<ImVec4>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec4@@@@QAEXH@Z ; ImVector<ImVec4>::reserve
$LN2@push_back:
  00054	6a 10		 push	 16			; 00000010H
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	c1 e2 04	 shl	 edx, 4
  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z ENDP	; ImVector<ImVec4>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec4@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImVec4@@@@QAEXH@Z PROC		; ImVector<ImVec4>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 58		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	c1 e0 04	 shl	 eax, 4
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 2b		 je	 SHORT $LN3@reserve
  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	c1 e1 04	 shl	 ecx, 4
  0005d	51		 push	 ecx
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00064	50		 push	 eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007d	83 c4 04	 add	 esp, 4
$LN3@reserve:
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?reserve@?$ImVector@UImVec4@@@@QAEXH@Z ENDP		; ImVector<ImVec4>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec4@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImVec4@@@@QAEXH@Z PROC		; ImVector<ImVec4>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImVec4@@@@QBEHH@Z ; ImVector<ImVec4>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec4@@@@QAEXH@Z ; ImVector<ImVec4>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImVec4@@@@QAEXH@Z ENDP		; ImVector<ImVec4>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec4@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImVec4@@@@QBEHH@Z PROC	; ImVector<ImVec4>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImVec4@@@@QBEHH@Z ENDP	; ImVector<ImVec4>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ PROC	; ImVector<ImVec4>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 e8 01	 sub	 eax, 1
  0005e	c1 e0 04	 shl	 eax, 4
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ ENDP	; ImVector<ImVec4>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec4@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImVec4@@@@QAEXXZ PROC		; ImVector<ImVec4>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImVec4@@@@QAEXXZ ENDP		; ImVector<ImVec4>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec4@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImVec4@@@@QAE@XZ PROC			; ImVector<ImVec4>::~ImVector<ImVec4>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImVec4@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImVec4@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImVec4@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImVec4@@@@QAE@XZ ENDP			; ImVector<ImVec4>::~ImVector<ImVec4>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec4@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImVec4@@@@QAE@XZ PROC			; ImVector<ImVec4>::ImVector<ImVec4>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImVec4@@@@QAE@XZ ENDP			; ImVector<ImVec4>::ImVector<ImVec4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z PROC		; ImVector<ImDrawVert>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 14	 imul	 eax, DWORD PTR _new_capacity$[ebp], 20
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 14	 imul	 ecx, DWORD PTR [eax], 20
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z ENDP		; ImVector<ImDrawVert>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?shrink@?$ImVector@UImDrawVert@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?shrink@?$ImVector@UImDrawVert@@@@QAEXH@Z PROC		; ImVector<ImDrawVert>::shrink, COMDAT
; _this$ = ecx

; 1289 :     inline void         shrink(int new_size)                { IM_ASSERT(new_size <= Size); Size = new_size; } // Resize a vector to a smaller size, guaranteed not to cause a reallocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7e 21		 jle	 SHORT $LN3@shrink
  00037	8b f4		 mov	 esi, esp
  00039	68 09 05 00 00	 push	 1289			; 00000509H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@shrink:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  0005e	89 08		 mov	 DWORD PTR [eax], ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?shrink@?$ImVector@UImDrawVert@@@@QAEXH@Z ENDP		; ImVector<ImDrawVert>::shrink
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z PROC		; ImVector<ImDrawVert>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImDrawVert@@@@QBEHH@Z ; ImVector<ImDrawVert>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ENDP		; ImVector<ImDrawVert>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawVert@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImDrawVert@@@@QBEHH@Z PROC	; ImVector<ImDrawVert>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImDrawVert@@@@QBEHH@Z ENDP	; ImVector<ImDrawVert>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?swap@?$ImVector@UImDrawVert@@@@QAEXAAU1@@Z
_TEXT	SEGMENT
_rhs_data$ = -44					; size = 4
_rhs_cap$ = -32						; size = 4
_rhs_size$ = -20					; size = 4
_this$ = -8						; size = 4
_rhs$ = 8						; size = 4
?swap@?$ImVector@UImDrawVert@@@@QAEXAAU1@@Z PROC	; ImVector<ImDrawVert>::swap, COMDAT
; _this$ = ecx

; 1284 :     inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00013	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 08	 mov	 eax, DWORD PTR _rhs$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 4d ec	 mov	 DWORD PTR _rhs_size$[ebp], ecx
  00035	8b 45 08	 mov	 eax, DWORD PTR _rhs$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _rhs_size$[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx
  00047	8b 45 08	 mov	 eax, DWORD PTR _rhs$[ebp]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	89 4d e0	 mov	 DWORD PTR _rhs_cap$[ebp], ecx
  00050	8b 45 08	 mov	 eax, DWORD PTR _rhs$[ebp]
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00059	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d e0	 mov	 ecx, DWORD PTR _rhs_cap$[ebp]
  00062	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00065	8b 45 08	 mov	 eax, DWORD PTR _rhs$[ebp]
  00068	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006b	89 4d d4	 mov	 DWORD PTR _rhs_data$[ebp], ecx
  0006e	8b 45 08	 mov	 eax, DWORD PTR _rhs$[ebp]
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00077	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 4d d4	 mov	 ecx, DWORD PTR _rhs_data$[ebp]
  00080	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
?swap@?$ImVector@UImDrawVert@@@@QAEXAAU1@@Z ENDP	; ImVector<ImDrawVert>::swap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawVert@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImDrawVert@@@@QAEXXZ PROC		; ImVector<ImDrawVert>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImDrawVert@@@@QAEXXZ ENDP		; ImVector<ImDrawVert>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z PROC	; ImVector<ImDrawVert>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 14	 imul	 eax, DWORD PTR _i$[ebp], 20
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ENDP	; ImVector<ImDrawVert>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawVert@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawVert@@@@QAE@XZ PROC		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImDrawVert@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawVert@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawVert@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawVert@@@@QAE@XZ ENDP		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??4?$ImVector@UImDrawVert@@@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_src$ = 8						; size = 4
??4?$ImVector@UImDrawVert@@@@QAEAAU0@ABU0@@Z PROC	; ImVector<ImDrawVert>::operator=, COMDAT
; _this$ = ecx

; 1265 :     inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImDrawVert@@@@QAEXXZ ; ImVector<ImDrawVert>::clear
  00035	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	51		 push	 ecx
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	6b 08 14	 imul	 ecx, DWORD PTR [eax], 20
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0004d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00050	50		 push	 eax
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _memcpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
??4?$ImVector@UImDrawVert@@@@QAEAAU0@ABU0@@Z ENDP	; ImVector<ImDrawVert>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawVert@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImDrawVert@@@@QAE@XZ PROC		; ImVector<ImDrawVert>::ImVector<ImDrawVert>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImDrawVert@@@@QAE@XZ ENDP		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_draw_list$ = 8						; size = 4
_idx$ = 12						; size = 4
?SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z PROC ; ImDrawListSplitter::SetCurrentChannel, COMDAT
; _this$ = ecx

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1348 :     IM_ASSERT(idx >= 0 && idx < _Count);

  0002d	83 7d 0c 00	 cmp	 DWORD PTR _idx$[ebp], 0
  00031	7c 0b		 jl	 SHORT $LN4@SetCurrent
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _idx$[ebp]
  00039	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0003c	7c 26		 jl	 SHORT $LN5@SetCurrent
$LN4@SetCurrent:
  0003e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA
  00044	83 c2 01	 add	 edx, 1
  00047	8b f4		 mov	 esi, esp
  00049	52		 push	 edx
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@SetCurrent:

; 1349 :     if (_Current == idx)

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	3b 4d 0c	 cmp	 ecx, DWORD PTR _idx$[ebp]
  0006c	75 05		 jne	 SHORT $LN2@SetCurrent

; 1350 :         return;

  0006e	e9 97 00 00 00	 jmp	 $LN1@SetCurrent
$LN2@SetCurrent:

; 1351 :     // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
; 1352 :     memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));

  00073	6a 0c		 push	 12			; 0000000cH
  00075	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00078	50		 push	 eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	6b 11 18	 imul	 edx, DWORD PTR [ecx], 24
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00082	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00085	03 ca		 add	 ecx, edx
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1353 :     memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));

  00090	6a 0c		 push	 12			; 0000000cH
  00092	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00095	83 c0 0c	 add	 eax, 12			; 0000000cH
  00098	50		 push	 eax
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	6b 11 18	 imul	 edx, DWORD PTR [ecx], 24
  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000a5	8d 54 11 0c	 lea	 edx, DWORD PTR [ecx+edx+12]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1354 :     _Current = idx;

  000b2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 4d 0c	 mov	 ecx, DWORD PTR _idx$[ebp]
  000b8	89 08		 mov	 DWORD PTR [eax], ecx

; 1355 :     memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));

  000ba	6a 0c		 push	 12			; 0000000cH
  000bc	6b 45 0c 18	 imul	 eax, DWORD PTR _idx$[ebp], 24
  000c0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000c6	03 d0		 add	 edx, eax
  000c8	52		 push	 edx
  000c9	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _memcpy
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1356 :     memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));

  000d5	6a 0c		 push	 12			; 0000000cH
  000d7	6b 45 0c 18	 imul	 eax, DWORD PTR _idx$[ebp], 24
  000db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000e1	8d 44 02 0c	 lea	 eax, DWORD PTR [edx+eax+12]
  000e5	50		 push	 eax
  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  000e9	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 _memcpy
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1357 :     draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;

  000f5	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  000f8	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000fb	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  000fe	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00101	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00104	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  00107	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx
$LN1@SetCurrent:

; 1358 : }

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00113	3b ec		 cmp	 ebp, esp
  00115	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 08 00	 ret	 8
?SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z ENDP ; ImDrawListSplitter::SetCurrentChannel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?Merge@ImDrawListSplitter@@QAEXPAUImDrawList@@@Z
_TEXT	SEGMENT
tv92 = -364						; size = 4
tv87 = -364						; size = 4
_sz$1 = -164						; size = 4
_sz$2 = -152						; size = 4
_ch$3 = -140						; size = 4
_i$4 = -128						; size = 4
_idx_write$ = -116					; size = 4
_cmd_write$ = -104					; size = 4
_cmd_n$5 = -92						; size = 4
_ch$6 = -80						; size = 4
_i$7 = -68						; size = 4
_idx_offset$ = -56					; size = 4
_last_cmd$ = -44					; size = 4
_new_idx_buffer_count$ = -32				; size = 4
_new_cmd_buffer_count$ = -20				; size = 4
_this$ = -8						; size = 4
_draw_list$ = 8						; size = 4
?Merge@ImDrawListSplitter@@QAEXPAUImDrawList@@@Z PROC	; ImDrawListSplitter::Merge, COMDAT
; _this$ = ecx

; 1292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 94 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-364]
  00013	b9 5b 00 00 00	 mov	 ecx, 91			; 0000005bH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1293 :     // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
; 1294 :     if (_Count <= 1)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00034	7f 05		 jg	 SHORT $LN11@Merge

; 1295 :         return;

  00036	e9 f9 02 00 00	 jmp	 $LN1@Merge
$LN11@Merge:

; 1296 : 
; 1297 :     SetCurrentChannel(draw_list, 0);

  0003b	6a 00		 push	 0
  0003d	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00040	50		 push	 eax
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 1298 :     if (draw_list->CmdBuffer.Size != 0 && draw_list->CmdBuffer.back().ElemCount == 0)

  00049	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  0004c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004f	74 15		 je	 SHORT $LN12@Merge
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00054	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  00059	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005c	75 08		 jne	 SHORT $LN12@Merge

; 1299 :         draw_list->CmdBuffer.pop_back();

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00061	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ ; ImVector<ImDrawCmd>::pop_back
$LN12@Merge:

; 1300 : 
; 1301 :     // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
; 1302 :     int new_cmd_buffer_count = 0;

  00066	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _new_cmd_buffer_count$[ebp], 0

; 1303 :     int new_idx_buffer_count = 0;

  0006d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _new_idx_buffer_count$[ebp], 0

; 1304 :     ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00077	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0007b	7e 18		 jle	 SHORT $LN19@Merge
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00080	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00083	7e 10		 jle	 SHORT $LN19@Merge
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00088	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  0008d	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
  00093	eb 0a		 jmp	 SHORT $LN20@Merge
$LN19@Merge:
  00095	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv87[ebp], 0
$LN20@Merge:
  0009f	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR tv87[ebp]
  000a5	89 55 d4	 mov	 DWORD PTR _last_cmd$[ebp], edx

; 1305 :     int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;

  000a8	83 7d d4 00	 cmp	 DWORD PTR _last_cmd$[ebp], 0
  000ac	74 13		 je	 SHORT $LN21@Merge
  000ae	8b 45 d4	 mov	 eax, DWORD PTR _last_cmd$[ebp]
  000b1	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000b4	8b 55 d4	 mov	 edx, DWORD PTR _last_cmd$[ebp]
  000b7	03 0a		 add	 ecx, DWORD PTR [edx]
  000b9	89 8d 94 fe ff
	ff		 mov	 DWORD PTR tv92[ebp], ecx
  000bf	eb 0a		 jmp	 SHORT $LN22@Merge
$LN21@Merge:
  000c1	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
$LN22@Merge:
  000cb	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv92[ebp]
  000d1	89 45 c8	 mov	 DWORD PTR _idx_offset$[ebp], eax

; 1306 :     for (int i = 1; i < _Count; i++)

  000d4	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _i$7[ebp], 1
  000db	eb 09		 jmp	 SHORT $LN4@Merge
$LN2@Merge:
  000dd	8b 45 bc	 mov	 eax, DWORD PTR _i$7[ebp]
  000e0	83 c0 01	 add	 eax, 1
  000e3	89 45 bc	 mov	 DWORD PTR _i$7[ebp], eax
$LN4@Merge:
  000e6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d bc	 mov	 ecx, DWORD PTR _i$7[ebp]
  000ec	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000ef	0f 8d 03 01 00
	00		 jge	 $LN3@Merge

; 1307 :     {
; 1308 :         ImDrawChannel& ch = _Channels[i];

  000f5	8b 45 bc	 mov	 eax, DWORD PTR _i$7[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	83 c1 08	 add	 ecx, 8
  000ff	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00104	89 45 b0	 mov	 DWORD PTR _ch$6[ebp], eax

; 1309 :         if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0)

  00107	8b 45 b0	 mov	 eax, DWORD PTR _ch$6[ebp]
  0010a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0010d	7e 15		 jle	 SHORT $LN13@Merge
  0010f	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  00112	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  00117	83 38 00	 cmp	 DWORD PTR [eax], 0
  0011a	75 08		 jne	 SHORT $LN13@Merge

; 1310 :             ch._CmdBuffer.pop_back();

  0011c	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  0011f	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ ; ImVector<ImDrawCmd>::pop_back
$LN13@Merge:

; 1311 :         if (ch._CmdBuffer.Size > 0 && last_cmd != NULL && CanMergeDrawCommands(last_cmd, &ch._CmdBuffer[0]))

  00124	8b 45 b0	 mov	 eax, DWORD PTR _ch$6[ebp]
  00127	83 38 00	 cmp	 DWORD PTR [eax], 0
  0012a	7e 5b		 jle	 SHORT $LN14@Merge
  0012c	83 7d d4 00	 cmp	 DWORD PTR _last_cmd$[ebp], 0
  00130	74 55		 je	 SHORT $LN14@Merge
  00132	6a 00		 push	 0
  00134	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  00137	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  0013c	50		 push	 eax
  0013d	8b 45 d4	 mov	 eax, DWORD PTR _last_cmd$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 ?CanMergeDrawCommands@@YA_NPAUImDrawCmd@@0@Z ; CanMergeDrawCommands
  00146	83 c4 08	 add	 esp, 8
  00149	0f b6 c8	 movzx	 ecx, al
  0014c	85 c9		 test	 ecx, ecx
  0014e	74 37		 je	 SHORT $LN14@Merge

; 1312 :         {
; 1313 :             // Merge previous channel last draw command with current channel first draw command if matching.
; 1314 :             last_cmd->ElemCount += ch._CmdBuffer[0].ElemCount;

  00150	6a 00		 push	 0
  00152	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  00155	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  0015a	8b 4d d4	 mov	 ecx, DWORD PTR _last_cmd$[ebp]
  0015d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015f	03 10		 add	 edx, DWORD PTR [eax]
  00161	8b 45 d4	 mov	 eax, DWORD PTR _last_cmd$[ebp]
  00164	89 10		 mov	 DWORD PTR [eax], edx

; 1315 :             idx_offset += ch._CmdBuffer[0].ElemCount;

  00166	6a 00		 push	 0
  00168	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  0016b	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
  00170	8b 4d c8	 mov	 ecx, DWORD PTR _idx_offset$[ebp]
  00173	03 08		 add	 ecx, DWORD PTR [eax]
  00175	89 4d c8	 mov	 DWORD PTR _idx_offset$[ebp], ecx

; 1316 :             ch._CmdBuffer.erase(ch._CmdBuffer.Data);

  00178	8b 45 b0	 mov	 eax, DWORD PTR _ch$6[ebp]
  0017b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017e	51		 push	 ecx
  0017f	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  00182	e8 00 00 00 00	 call	 ?erase@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@PBU2@@Z ; ImVector<ImDrawCmd>::erase
$LN14@Merge:

; 1317 :         }
; 1318 :         if (ch._CmdBuffer.Size > 0)

  00187	8b 45 b0	 mov	 eax, DWORD PTR _ch$6[ebp]
  0018a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0018d	7e 0b		 jle	 SHORT $LN15@Merge

; 1319 :             last_cmd = &ch._CmdBuffer.back();

  0018f	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  00192	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  00197	89 45 d4	 mov	 DWORD PTR _last_cmd$[ebp], eax
$LN15@Merge:

; 1320 :         new_cmd_buffer_count += ch._CmdBuffer.Size;

  0019a	8b 45 b0	 mov	 eax, DWORD PTR _ch$6[ebp]
  0019d	8b 4d ec	 mov	 ecx, DWORD PTR _new_cmd_buffer_count$[ebp]
  001a0	03 08		 add	 ecx, DWORD PTR [eax]
  001a2	89 4d ec	 mov	 DWORD PTR _new_cmd_buffer_count$[ebp], ecx

; 1321 :         new_idx_buffer_count += ch._IdxBuffer.Size;

  001a5	8b 45 b0	 mov	 eax, DWORD PTR _ch$6[ebp]
  001a8	8b 4d e0	 mov	 ecx, DWORD PTR _new_idx_buffer_count$[ebp]
  001ab	03 48 0c	 add	 ecx, DWORD PTR [eax+12]
  001ae	89 4d e0	 mov	 DWORD PTR _new_idx_buffer_count$[ebp], ecx

; 1322 :         for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)

  001b1	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _cmd_n$5[ebp], 0
  001b8	eb 09		 jmp	 SHORT $LN7@Merge
$LN5@Merge:
  001ba	8b 45 a4	 mov	 eax, DWORD PTR _cmd_n$5[ebp]
  001bd	83 c0 01	 add	 eax, 1
  001c0	89 45 a4	 mov	 DWORD PTR _cmd_n$5[ebp], eax
$LN7@Merge:
  001c3	8b 45 b0	 mov	 eax, DWORD PTR _ch$6[ebp]
  001c6	8b 4d a4	 mov	 ecx, DWORD PTR _cmd_n$5[ebp]
  001c9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001cb	7d 26		 jge	 SHORT $LN6@Merge

; 1323 :         {
; 1324 :             ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;

  001cd	6b 45 a4 28	 imul	 eax, DWORD PTR _cmd_n$5[ebp], 40
  001d1	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  001d4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001d7	8b 4d c8	 mov	 ecx, DWORD PTR _idx_offset$[ebp]
  001da	89 4c 02 1c	 mov	 DWORD PTR [edx+eax+28], ecx

; 1325 :             idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;

  001de	6b 45 a4 28	 imul	 eax, DWORD PTR _cmd_n$5[ebp], 40
  001e2	8b 4d b0	 mov	 ecx, DWORD PTR _ch$6[ebp]
  001e5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001e8	8b 4d c8	 mov	 ecx, DWORD PTR _idx_offset$[ebp]
  001eb	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  001ee	89 4d c8	 mov	 DWORD PTR _idx_offset$[ebp], ecx

; 1326 :         }

  001f1	eb c7		 jmp	 SHORT $LN5@Merge
$LN6@Merge:

; 1327 :     }

  001f3	e9 e5 fe ff ff	 jmp	 $LN2@Merge
$LN3@Merge:

; 1328 :     draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);

  001f8	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  001fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fd	03 4d ec	 add	 ecx, DWORD PTR _new_cmd_buffer_count$[ebp]
  00200	51		 push	 ecx
  00201	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00204	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::resize

; 1329 :     draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

  00209	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  0020c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0020f	03 4d e0	 add	 ecx, DWORD PTR _new_idx_buffer_count$[ebp]
  00212	51		 push	 ecx
  00213	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00216	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00219	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize

; 1330 : 
; 1331 :     // Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
; 1332 :     ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;

  0021e	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00221	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  00224	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  00227	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0022a	03 c1		 add	 eax, ecx
  0022c	6b 4d ec 28	 imul	 ecx, DWORD PTR _new_cmd_buffer_count$[ebp], 40
  00230	2b c1		 sub	 eax, ecx
  00232	89 45 98	 mov	 DWORD PTR _cmd_write$[ebp], eax

; 1333 :     ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;

  00235	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00238	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0023b	8b 55 08	 mov	 edx, DWORD PTR _draw_list$[ebp]
  0023e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00241	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00244	8b 55 e0	 mov	 edx, DWORD PTR _new_idx_buffer_count$[ebp]
  00247	d1 e2		 shl	 edx, 1
  00249	2b ca		 sub	 ecx, edx
  0024b	89 4d 8c	 mov	 DWORD PTR _idx_write$[ebp], ecx

; 1334 :     for (int i = 1; i < _Count; i++)

  0024e	c7 45 80 01 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 1
  00255	eb 09		 jmp	 SHORT $LN10@Merge
$LN8@Merge:
  00257	8b 45 80	 mov	 eax, DWORD PTR _i$4[ebp]
  0025a	83 c0 01	 add	 eax, 1
  0025d	89 45 80	 mov	 DWORD PTR _i$4[ebp], eax
$LN10@Merge:
  00260	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00263	8b 4d 80	 mov	 ecx, DWORD PTR _i$4[ebp]
  00266	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00269	0f 8d a2 00 00
	00		 jge	 $LN9@Merge

; 1335 :     {
; 1336 :         ImDrawChannel& ch = _Channels[i];

  0026f	8b 45 80	 mov	 eax, DWORD PTR _i$4[ebp]
  00272	50		 push	 eax
  00273	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00276	83 c1 08	 add	 ecx, 8
  00279	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  0027e	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ch$3[ebp], eax

; 1337 :         if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }

  00284	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ch$3[ebp]
  0028a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028c	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _sz$2[ebp], ecx
  00292	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _sz$2[ebp], 0
  00299	74 2b		 je	 SHORT $LN16@Merge
  0029b	6b 85 68 ff ff
	ff 28		 imul	 eax, DWORD PTR _sz$2[ebp], 40
  002a2	50		 push	 eax
  002a3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ch$3[ebp]
  002a9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002ac	52		 push	 edx
  002ad	8b 45 98	 mov	 eax, DWORD PTR _cmd_write$[ebp]
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _memcpy
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b9	6b 85 68 ff ff
	ff 28		 imul	 eax, DWORD PTR _sz$2[ebp], 40
  002c0	03 45 98	 add	 eax, DWORD PTR _cmd_write$[ebp]
  002c3	89 45 98	 mov	 DWORD PTR _cmd_write$[ebp], eax
$LN16@Merge:

; 1338 :         if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }

  002c6	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _ch$3[ebp]
  002cc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002cf	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _sz$1[ebp], ecx
  002d5	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _sz$1[ebp], 0
  002dc	74 2e		 je	 SHORT $LN17@Merge
  002de	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _sz$1[ebp]
  002e4	d1 e0		 shl	 eax, 1
  002e6	50		 push	 eax
  002e7	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _ch$3[ebp]
  002ed	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  002f0	52		 push	 edx
  002f1	8b 45 8c	 mov	 eax, DWORD PTR _idx_write$[ebp]
  002f4	50		 push	 eax
  002f5	e8 00 00 00 00	 call	 _memcpy
  002fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  002fd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _sz$1[ebp]
  00303	8b 4d 8c	 mov	 ecx, DWORD PTR _idx_write$[ebp]
  00306	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00309	89 55 8c	 mov	 DWORD PTR _idx_write$[ebp], edx
$LN17@Merge:

; 1339 :     }

  0030c	e9 46 ff ff ff	 jmp	 $LN8@Merge
$LN9@Merge:

; 1340 :     draw_list->_IdxWritePtr = idx_write;

  00311	8b 45 08	 mov	 eax, DWORD PTR _draw_list$[ebp]
  00314	8b 4d 8c	 mov	 ecx, DWORD PTR _idx_write$[ebp]
  00317	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 1341 :     draw_list->UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.

  0031a	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  0031d	e8 00 00 00 00	 call	 ?UpdateClipRect@ImDrawList@@QAEXXZ ; ImDrawList::UpdateClipRect

; 1342 :     draw_list->UpdateTextureID();

  00322	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00325	e8 00 00 00 00	 call	 ?UpdateTextureID@ImDrawList@@QAEXXZ ; ImDrawList::UpdateTextureID

; 1343 :     _Count = 1;

  0032a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0032d	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
$LN1@Merge:

; 1344 : }

  00334	5f		 pop	 edi
  00335	5e		 pop	 esi
  00336	5b		 pop	 ebx
  00337	81 c4 6c 01 00
	00		 add	 esp, 364		; 0000016cH
  0033d	3b ec		 cmp	 ebp, esp
  0033f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00344	8b e5		 mov	 esp, ebp
  00346	5d		 pop	 ebp
  00347	c2 04 00	 ret	 4
?Merge@ImDrawListSplitter@@QAEXPAUImDrawList@@@Z ENDP	; ImDrawListSplitter::Merge
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z
_TEXT	SEGMENT
tv138 = -356						; size = 4
$T2 = -345						; size = 1
$T3 = -336						; size = 4
$T4 = -324						; size = 4
$T5 = -312						; size = 4
$T6 = -300						; size = 4
_draw_cmd$7 = -96					; size = 40
_i$8 = -48						; size = 4
_old_channels_count$ = -36				; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_draw_list$ = 8						; size = 4
_channels_count$ = 12					; size = 4
?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z PROC	; ImDrawListSplitter::Split, COMDAT
; _this$ = ecx

; 1254 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 9c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-356]
  00021	b9 56 00 00 00	 mov	 ecx, 86			; 00000056H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1255 :     IM_ASSERT(_Current == 0 && _Count <= 1);

  0004f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 38 00	 cmp	 DWORD PTR [eax], 0
  00055	75 09		 jne	 SHORT $LN10@Split
  00057	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  0005e	7e 26		 jle	 SHORT $LN11@Split
$LN10@Split:
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z@4JA
  00066	83 c2 01	 add	 edx, 1
  00069	8b f4		 mov	 esi, esp
  0006b	52		 push	 edx
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_1LA@MPFJCAF@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@EHEALEDG@?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	3b f4		 cmp	 esi, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@Split:

; 1256 :     int old_channels_count = _Channels.Size;

  00086	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008c	89 4d dc	 mov	 DWORD PTR _old_channels_count$[ebp], ecx

; 1257 :     if (old_channels_count < channels_count)

  0008f	8b 45 dc	 mov	 eax, DWORD PTR _old_channels_count$[ebp]
  00092	3b 45 0c	 cmp	 eax, DWORD PTR _channels_count$[ebp]
  00095	7d 0f		 jge	 SHORT $LN5@Split

; 1258 :         _Channels.resize(channels_count);

  00097	8b 45 0c	 mov	 eax, DWORD PTR _channels_count$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	83 c1 08	 add	 ecx, 8
  000a1	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z ; ImVector<ImDrawChannel>::resize
$LN5@Split:

; 1259 :     _Count = channels_count;

  000a6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR _channels_count$[ebp]
  000ac	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1260 : 
; 1261 :     // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
; 1262 :     // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
; 1263 :     // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
; 1264 :     memset(&_Channels[0], 0, sizeof(ImDrawChannel));

  000af	6a 18		 push	 24			; 00000018H
  000b1	6a 00		 push	 0
  000b3	6a 00		 push	 0
  000b5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	83 c1 08	 add	 ecx, 8
  000bb	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _memset
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1265 :     for (int i = 1; i < channels_count; i++)

  000c9	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 1
  000d0	eb 09		 jmp	 SHORT $LN4@Split
$LN2@Split:
  000d2	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 d0	 mov	 DWORD PTR _i$8[ebp], eax
$LN4@Split:
  000db	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  000de	3b 45 0c	 cmp	 eax, DWORD PTR _channels_count$[ebp]
  000e1	0f 8d 49 01 00
	00		 jge	 $LN1@Split

; 1266 :     {
; 1267 :         if (i >= old_channels_count)

  000e7	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  000ea	3b 45 dc	 cmp	 eax, DWORD PTR _old_channels_count$[ebp]
  000ed	0f 8c 9d 00 00
	00		 jl	 $LN6@Split

; 1268 :         {
; 1269 :             IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();

  000f3	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  000f6	50		 push	 eax
  000f7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	83 c1 08	 add	 ecx, 8
  000fd	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00102	89 85 bc fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  00108	8d 8d a7 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0010e	89 8d b0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00114	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  0011a	52		 push	 edx
  0011b	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00121	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00124	51		 push	 ecx
  00125	6a 18		 push	 24			; 00000018H
  00127	e8 00 00 00 00	 call	 ??2@YAPAXIUImNewDummy@@PAX@Z ; operator new
  0012c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012f	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  00135	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0013c	83 bd c8 fe ff
	ff 00		 cmp	 DWORD PTR $T5[ebp], 0
  00143	74 2c		 je	 SHORT $LN12@Split
  00145	33 d2		 xor	 edx, edx
  00147	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  0014d	89 10		 mov	 DWORD PTR [eax], edx
  0014f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00152	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00155	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00158	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0015b	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0015e	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00164	e8 00 00 00 00	 call	 ??0ImDrawChannel@@QAE@XZ
  00169	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
  0016f	eb 0a		 jmp	 SHORT $LN13@Split
$LN12@Split:
  00171	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv138[ebp], 0
$LN13@Split:
  0017b	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv138[ebp]
  00181	89 8d d4 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  00187	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 1270 :         }

  0018e	eb 33		 jmp	 SHORT $LN7@Split
$LN6@Split:

; 1271 :         else
; 1272 :         {
; 1273 :             _Channels[i]._CmdBuffer.resize(0);

  00190	6a 00		 push	 0
  00192	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  00195	50		 push	 eax
  00196	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	83 c1 08	 add	 ecx, 8
  0019c	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  001a1	8b c8		 mov	 ecx, eax
  001a3	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::resize

; 1274 :             _Channels[i]._IdxBuffer.resize(0);

  001a8	6a 00		 push	 0
  001aa	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  001ad	50		 push	 eax
  001ae	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	83 c1 08	 add	 ecx, 8
  001b4	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  001b9	83 c0 0c	 add	 eax, 12			; 0000000cH
  001bc	8b c8		 mov	 ecx, eax
  001be	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize
$LN7@Split:

; 1275 :         }
; 1276 :         if (_Channels[i]._CmdBuffer.Size == 0)

  001c3	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  001c6	50		 push	 eax
  001c7	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	83 c1 08	 add	 ecx, 8
  001cd	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  001d2	83 38 00	 cmp	 DWORD PTR [eax], 0
  001d5	75 54		 jne	 SHORT $LN8@Split

; 1277 :         {
; 1278 :             ImDrawCmd draw_cmd;

  001d7	8d 4d a0	 lea	 ecx, DWORD PTR _draw_cmd$7[ebp]
  001da	e8 00 00 00 00	 call	 ??0ImDrawCmd@@QAE@XZ	; ImDrawCmd::ImDrawCmd

; 1279 :             draw_cmd.ClipRect = draw_list->_ClipRectStack.back();

  001df	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  001e2	83 c1 40	 add	 ecx, 64			; 00000040H
  001e5	e8 00 00 00 00	 call	 ?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ ; ImVector<ImVec4>::back
  001ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ec	89 4d a4	 mov	 DWORD PTR _draw_cmd$7[ebp+4], ecx
  001ef	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001f2	89 55 a8	 mov	 DWORD PTR _draw_cmd$7[ebp+8], edx
  001f5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f8	89 4d ac	 mov	 DWORD PTR _draw_cmd$7[ebp+12], ecx
  001fb	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  001fe	89 55 b0	 mov	 DWORD PTR _draw_cmd$7[ebp+16], edx

; 1280 :             draw_cmd.TextureId = draw_list->_TextureIdStack.back();

  00201	8b 4d 08	 mov	 ecx, DWORD PTR _draw_list$[ebp]
  00204	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00207	e8 00 00 00 00	 call	 ?back@?$ImVector@PAX@@QAEAAPAXXZ ; ImVector<void *>::back
  0020c	8b 00		 mov	 eax, DWORD PTR [eax]
  0020e	89 45 b4	 mov	 DWORD PTR _draw_cmd$7[ebp+20], eax

; 1281 :             _Channels[i]._CmdBuffer.push_back(draw_cmd);

  00211	8d 45 a0	 lea	 eax, DWORD PTR _draw_cmd$7[ebp]
  00214	50		 push	 eax
  00215	8b 4d d0	 mov	 ecx, DWORD PTR _i$8[ebp]
  00218	51		 push	 ecx
  00219	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021c	83 c1 08	 add	 ecx, 8
  0021f	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00224	8b c8		 mov	 ecx, eax
  00226	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back
$LN8@Split:

; 1282 :         }
; 1283 :     }

  0022b	e9 a2 fe ff ff	 jmp	 $LN2@Split
$LN1@Split:

; 1284 : }

  00230	52		 push	 edx
  00231	8b cd		 mov	 ecx, ebp
  00233	50		 push	 eax
  00234	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN18@Split
  0023a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0023f	58		 pop	 eax
  00240	5a		 pop	 edx
  00241	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00244	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0024b	59		 pop	 ecx
  0024c	5f		 pop	 edi
  0024d	5e		 pop	 esi
  0024e	5b		 pop	 ebx
  0024f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00252	33 cd		 xor	 ecx, ebp
  00254	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00259	81 c4 64 01 00
	00		 add	 esp, 356		; 00000164H
  0025f	3b ec		 cmp	 ebp, esp
  00261	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00266	8b e5		 mov	 esp, ebp
  00268	5d		 pop	 ebp
  00269	c2 08 00	 ret	 8
$LN18@Split:
  0026c	01 00 00 00	 DD	 1
  00270	00 00 00 00	 DD	 $LN17@Split
$LN17@Split:
  00274	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00278	28 00 00 00	 DD	 40			; 00000028H
  0027c	00 00 00 00	 DD	 $LN15@Split
$LN15@Split:
  00280	64		 DB	 100			; 00000064H
  00281	72		 DB	 114			; 00000072H
  00282	61		 DB	 97			; 00000061H
  00283	77		 DB	 119			; 00000077H
  00284	5f		 DB	 95			; 0000005fH
  00285	63		 DB	 99			; 00000063H
  00286	6d		 DB	 109			; 0000006dH
  00287	64		 DB	 100			; 00000064H
  00288	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z$0:
  00000	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00006	50		 push	 eax
  00007	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0000d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00010	50		 push	 eax
  00011	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXUImNewDummy@@0@Z ; operator delete
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	c3		 ret	 0
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a 98 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-360]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003f	33 c8		 xor	 ecx, eax
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z
  0004b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Split@ImDrawListSplitter@@QAEXPAUImDrawList@@H@Z ENDP	; ImDrawListSplitter::Split
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?ClearFreeMemory@ImDrawListSplitter@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?ClearFreeMemory@ImDrawListSplitter@@QAEXXZ PROC	; ImDrawListSplitter::ClearFreeMemory, COMDAT
; _this$ = ecx

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1241 :     for (int i = 0; i < _Channels.Size; i++)

  0002d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@ClearFreeM
$LN2@ClearFreeM:
  00036	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ClearFreeM:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00045	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00048	7d 57		 jge	 SHORT $LN3@ClearFreeM

; 1242 :     {
; 1243 :         if (i == _Current)

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00050	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00052	75 1c		 jne	 SHORT $LN5@ClearFreeM

; 1244 :             memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again

  00054	6a 18		 push	 24			; 00000018H
  00056	6a 00		 push	 0
  00058	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 08	 add	 ecx, 8
  00062	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _memset
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@ClearFreeM:

; 1245 :         _Channels[i]._CmdBuffer.clear();

  00070	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00073	50		 push	 eax
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 08	 add	 ecx, 8
  0007a	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  0007f	8b c8		 mov	 ecx, eax
  00081	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ ; ImVector<ImDrawCmd>::clear

; 1246 :         _Channels[i]._IdxBuffer.clear();

  00086	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00089	50		 push	 eax
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	83 c1 08	 add	 ecx, 8
  00090	e8 00 00 00 00	 call	 ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
  00095	83 c0 0c	 add	 eax, 12			; 0000000cH
  00098	8b c8		 mov	 ecx, eax
  0009a	e8 00 00 00 00	 call	 ?clear@?$ImVector@G@@QAEXXZ ; ImVector<unsigned short>::clear

; 1247 :     }

  0009f	eb 95		 jmp	 SHORT $LN2@ClearFreeM
$LN3@ClearFreeM:

; 1248 :     _Current = 0;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1249 :     _Count = 1;

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 1250 :     _Channels.clear();

  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	83 c1 08	 add	 ecx, 8
  000ba	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ ; ImVector<ImDrawChannel>::clear

; 1251 : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c8	3b ec		 cmp	 ebp, esp
  000ca	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
?ClearFreeMemory@ImDrawListSplitter@@QAEXXZ ENDP	; ImDrawListSplitter::ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?Clear@ImDrawListSplitter@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@ImDrawListSplitter@@QAEXXZ PROC			; ImDrawListSplitter::Clear, COMDAT
; _this$ = ecx

; 1858 :     inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?Clear@ImDrawListSplitter@@QAEXXZ ENDP			; ImDrawListSplitter::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1ImDrawListSplitter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ImDrawListSplitter@@QAE@XZ PROC			; ImDrawListSplitter::~ImDrawListSplitter, COMDAT
; _this$ = ecx

; 1857 :     inline ~ImDrawListSplitter() { ClearFreeMemory(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ImDrawListSplitter@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?ClearFreeMemory@ImDrawListSplitter@@QAEXXZ ; ImDrawListSplitter::ClearFreeMemory
  00054	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	83 c1 08	 add	 ecx, 8
  0005a	e8 00 00 00 00	 call	 ??1?$ImVector@UImDrawChannel@@@@QAE@XZ ; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImDrawListSplitter@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ImDrawListSplitter@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ImDrawListSplitter@@QAE@XZ ENDP			; ImDrawListSplitter::~ImDrawListSplitter
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImDrawListSplitter@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ImDrawListSplitter@@QAE@XZ PROC			; ImDrawListSplitter::ImDrawListSplitter, COMDAT
; _this$ = ecx

; 1856 :     inline ImDrawListSplitter()  { Clear(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImDrawListSplitter@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 08	 add	 ecx, 8
  00052	e8 00 00 00 00	 call	 ??0?$ImVector@UImDrawChannel@@@@QAE@XZ ; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?Clear@ImDrawListSplitter@@QAEXXZ ; ImDrawListSplitter::Clear
  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImDrawListSplitter@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImDrawChannel@@@@QAE@XZ ; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0ImDrawListSplitter@@QAE@XZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImDrawListSplitter@@QAE@XZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImDrawListSplitter@@QAE@XZ ENDP			; ImDrawListSplitter::ImDrawListSplitter
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z PROC	; ImVector<ImDrawChannel>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 18	 imul	 eax, DWORD PTR _new_capacity$[ebp], 24
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 18	 imul	 ecx, DWORD PTR [eax], 24
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z ENDP	; ImVector<ImDrawChannel>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z PROC	; ImVector<ImDrawChannel>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImDrawChannel@@@@QBEHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z ; ImVector<ImDrawChannel>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z ENDP	; ImVector<ImDrawChannel>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawChannel@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QBEHH@Z PROC ; ImVector<ImDrawChannel>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QBEHH@Z ENDP ; ImVector<ImDrawChannel>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ PROC		; ImVector<ImDrawChannel>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ ENDP		; ImVector<ImDrawChannel>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z PROC ; ImVector<ImDrawChannel>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ENDP ; ImVector<ImDrawChannel>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawChannel@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawChannel@@@@QAE@XZ PROC		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImDrawChannel@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawChannel@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawChannel@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawChannel@@@@QAE@XZ ENDP		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawChannel@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImDrawChannel@@@@QAE@XZ PROC		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImDrawChannel@@@@QAE@XZ ENDP		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0ImDrawChannel@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ImDrawChannel@@QAE@XZ PROC				; ImDrawChannel::ImDrawChannel, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ImDrawChannel@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$ImVector@UImDrawCmd@@@@QAE@XZ ; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00057	e8 00 00 00 00	 call	 ??0?$ImVector@G@@QAE@XZ	; ImVector<unsigned short>::ImVector<unsigned short>
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImDrawChannel@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImDrawCmd@@@@QAE@XZ ; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0ImDrawChannel@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ImDrawChannel@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ImDrawChannel@@QAE@XZ ENDP				; ImDrawChannel::ImDrawChannel
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?erase@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@PBU2@@Z
_TEXT	SEGMENT
_off$ = -20						; size = 4
_this$ = -8						; size = 4
_it$ = 8						; size = 4
?erase@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@PBU2@@Z PROC ; ImVector<ImDrawCmd>::erase, COMDAT
; _this$ = ecx

; 1296 :     inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _it$[ebp]
  00033	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00036	72 11		 jb	 SHORT $LN3@erase
  00038	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	6b 02 28	 imul	 eax, DWORD PTR [edx], 40
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00044	39 45 08	 cmp	 DWORD PTR _it$[ebp], eax
  00047	72 21		 jb	 SHORT $LN4@erase
$LN3@erase:
  00049	8b f4		 mov	 esi, esp
  0004b	68 10 05 00 00	 push	 1296			; 00000510H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@JJGEFOJO@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@erase:
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _it$[ebp]
  00070	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  00073	8b c1		 mov	 eax, ecx
  00075	99		 cdq
  00076	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0007b	f7 f9		 idiv	 ecx
  0007d	89 45 ec	 mov	 DWORD PTR _off$[ebp], eax
  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	2b 4d ec	 sub	 ecx, DWORD PTR _off$[ebp]
  00088	83 e9 01	 sub	 ecx, 1
  0008b	6b d1 28	 imul	 edx, ecx, 40
  0008e	52		 push	 edx
  0008f	6b 45 ec 28	 imul	 eax, DWORD PTR _off$[ebp], 40
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00099	8d 44 02 28	 lea	 eax, DWORD PTR [edx+eax+40]
  0009d	50		 push	 eax
  0009e	6b 4d ec 28	 imul	 ecx, DWORD PTR _off$[ebp], 40
  000a2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _memmove
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b6	83 e9 01	 sub	 ecx, 1
  000b9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000bc	89 0a		 mov	 DWORD PTR [edx], ecx
  000be	6b 45 ec 28	 imul	 eax, DWORD PTR _off$[ebp], 40
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000d1	3b ec		 cmp	 ebp, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 04 00	 ret	 4
?erase@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@PBU2@@Z ENDP ; ImVector<ImDrawCmd>::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ PROC		; ImVector<ImDrawCmd>::pop_back, COMDAT
; _this$ = ecx

; 1294 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@pop_back
  00035	8b f4		 mov	 esi, esp
  00037	68 0e 05 00 00	 push	 1294			; 0000050eH
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@pop_back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00061	89 0a		 mov	 DWORD PTR [edx], ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ ENDP		; ImVector<ImDrawCmd>::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z PROC ; ImVector<ImDrawCmd>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImDrawCmd@@@@QBEHH@Z ; ImVector<ImDrawCmd>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::reserve
$LN2@push_back:
  00054	6a 28		 push	 40			; 00000028H
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	6b 11 28	 imul	 edx, DWORD PTR [ecx], 40
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	83 c1 01	 add	 ecx, 1
  00077	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 0a		 mov	 DWORD PTR [edx], ecx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ENDP ; ImVector<ImDrawCmd>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z PROC		; ImVector<ImDrawCmd>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 54		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	6b 45 08 28	 imul	 eax, DWORD PTR _new_capacity$[ebp], 40
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00051	74 29		 je	 SHORT $LN3@reserve
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00079	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z ENDP		; ImVector<ImDrawCmd>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z PROC		; ImVector<ImDrawCmd>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@UImDrawCmd@@@@QBEHH@Z ; ImVector<ImDrawCmd>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ENDP		; ImVector<ImDrawCmd>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawCmd@@@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImDrawCmd@@@@QBEHH@Z PROC	; ImVector<ImDrawCmd>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@UImDrawCmd@@@@QBEHH@Z ENDP	; ImVector<ImDrawCmd>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ PROC	; ImVector<ImDrawCmd>::back, COMDAT
; _this$ = ecx

; 1282 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	7f 21		 jg	 SHORT $LN3@back
  00035	8b f4		 mov	 esi, esp
  00037	68 02 05 00 00	 push	 1282			; 00000502H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@back:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	6b c1 28	 imul	 eax, ecx, 40
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ENDP	; ImVector<ImDrawCmd>::back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ PROC		; ImVector<ImDrawCmd>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ ENDP		; ImVector<ImDrawCmd>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	6b 45 08 28	 imul	 eax, DWORD PTR _i$[ebp], 40
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawCmd@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawCmd@@@@QAE@XZ PROC			; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@UImDrawCmd@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawCmd@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawCmd@@@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawCmd@@@@QAE@XZ ENDP			; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??4?$ImVector@UImDrawCmd@@@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_src$ = 8						; size = 4
??4?$ImVector@UImDrawCmd@@@@QAEAAU0@ABU0@@Z PROC	; ImVector<ImDrawCmd>::operator=, COMDAT
; _this$ = ecx

; 1265 :     inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ ; ImVector<ImDrawCmd>::clear
  00035	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	51		 push	 ecx
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::resize
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0004d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00050	50		 push	 eax
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 _memcpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
??4?$ImVector@UImDrawCmd@@@@QAEAAU0@ABU0@@Z ENDP	; ImVector<ImDrawCmd>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawCmd@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@UImDrawCmd@@@@QAE@XZ PROC			; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@UImDrawCmd@@@@QAE@XZ ENDP			; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImDrawCmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImDrawCmd@@QAE@XZ PROC				; ImDrawCmd::ImDrawCmd, COMDAT
; _this$ = ecx

; 1815 :     ImDrawCmd() { ElemCount = 0; TextureId = (ImTextureID)NULL; VtxOffset = IdxOffset = 0;  UserCallback = NULL; UserCallbackData = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 04	 add	 ecx, 4
  00033	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@XZ	; ImVec4::ImVec4
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
  00073	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
??0ImDrawCmd@@QAE@XZ ENDP				; ImDrawCmd::ImDrawCmd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@G@@QAEXABG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
?push_back@?$ImVector@G@@QAEXABG@Z PROC			; ImVector<unsigned short>::push_back, COMDAT
; _this$ = ecx

; 1293 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00038	75 1a		 jne	 SHORT $LN2@push_back
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	83 c1 01	 add	 ecx, 1
  00042	51		 push	 ecx
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@G@@QBEHH@Z ; ImVector<unsigned short>::_grow_capacity
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::reserve
$LN2@push_back:
  00054	6a 02		 push	 2
  00056	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00065	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 _memcpy
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	83 c1 01	 add	 ecx, 1
  00079	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 0a		 mov	 DWORD PTR [edx], ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?push_back@?$ImVector@G@@QAEXABG@Z ENDP			; ImVector<unsigned short>::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_new_data$ = -20					; size = 4
_this$ = -8						; size = 4
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT
; _this$ = ecx

; 1290 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7f 02		 jg	 SHORT $LN2@reserve
  00038	eb 56		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0003a	8b 45 08	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  0003d	d1 e0		 shl	 eax, 1
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPAXI@Z ; ImGui::MemAlloc
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 ec	 mov	 DWORD PTR _new_data$[ebp], eax
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00052	74 2a		 je	 SHORT $LN3@reserve
  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	d1 e1		 shl	 ecx, 1
  0005b	51		 push	 ecx
  0005c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00062	50		 push	 eax
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  0007b	83 c4 04	 add	 esp, 4
$LN3@reserve:
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _new_data$[ebp]
  00084	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00087	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0008d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@reserve:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
?reserve@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?shrink@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?shrink@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::shrink, COMDAT
; _this$ = ecx

; 1289 :     inline void         shrink(int new_size)                { IM_ASSERT(new_size <= Size); Size = new_size; } // Resize a vector to a smaller size, guaranteed not to cause a reallocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7e 21		 jle	 SHORT $LN3@shrink
  00037	8b f4		 mov	 esi, esp
  00039	68 09 05 00 00	 push	 1289			; 00000509H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@shrink:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  0005e	89 08		 mov	 DWORD PTR [eax], ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
?shrink@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::shrink
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QAEXHABG@Z
_TEXT	SEGMENT
_n$1 = -20						; size = 4
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
_v$ = 12						; size = 4
?resize@?$ImVector@G@@QAEXHABG@Z PROC			; ImVector<unsigned short>::resize, COMDAT
; _this$ = ecx

; 1288 :     inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN5@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@G@@QBEHH@Z ; ImVector<unsigned short>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::reserve
$LN5@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00055	7e 38		 jle	 SHORT $LN6@resize
  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	89 4d ec	 mov	 DWORD PTR _n$1[ebp], ecx
  0005f	eb 09		 jmp	 SHORT $LN4@resize
$LN2@resize:
  00061	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 ec	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@resize:
  0006a	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  0006d	3b 45 08	 cmp	 eax, DWORD PTR _new_size$[ebp]
  00070	7d 1d		 jge	 SHORT $LN6@resize
  00072	6a 02		 push	 2
  00074	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _n$1[ebp]
  00081	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00084	51		 push	 ecx
  00085	e8 00 00 00 00	 call	 _memcpy
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	eb d2		 jmp	 SHORT $LN2@resize
$LN6@resize:
  0008f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
?resize@?$ImVector@G@@QAEXHABG@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT
; _this$ = ecx

; 1287 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00033	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00036	7e 15		 jle	 SHORT $LN2@resize
  00038	8b 45 08	 mov	 eax, DWORD PTR _new_size$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@G@@QBEHH@Z ; ImVector<unsigned short>::_grow_capacity
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::reserve
$LN2@resize:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _new_size$[ebp]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?resize@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QBEHH@Z
_TEXT	SEGMENT
tv72 = -220						; size = 4
tv70 = -220						; size = 4
_new_capacity$ = -20					; size = 4
_this$ = -8						; size = 4
_sz$ = 8						; size = 4
?_grow_capacity@?$ImVector@G@@QBEHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT
; _this$ = ecx

; 1286 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	74 19		 je	 SHORT $LN3@grow_capac
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00047	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  0004f	c7 85 24 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR tv70[ebp], 8
$LN4@grow_capac:
  00059	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv70[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _new_capacity$[ebp], eax
  00062	8b 45 ec	 mov	 eax, DWORD PTR _new_capacity$[ebp]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _sz$[ebp]
  00068	7e 0b		 jle	 SHORT $LN5@grow_capac
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _new_capacity$[ebp]
  0006d	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00073	eb 09		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00075	8b 55 08	 mov	 edx, DWORD PTR _sz$[ebp]
  00078	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN6@grow_capac:
  0007e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv72[ebp]
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_grow_capacity@?$ImVector@G@@QBEHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@G@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?clear@?$ImVector@G@@QAEXXZ PROC			; ImVector<unsigned short>::clear, COMDAT
; _this$ = ecx

; 1275 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00034	74 2c		 je	 SHORT $LN1@clear
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00055	83 c4 04	 add	 esp, 4
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN1@clear:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?clear@?$ImVector@G@@QAEXXZ ENDP			; ImVector<unsigned short>::clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$ImVector@G@@QAEAAGH@Z PROC				; ImVector<unsigned short>::operator[], COMDAT
; _this$ = ecx

; 1272 :     inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _i$[ebp]
  00033	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00035	7c 21		 jl	 SHORT $LN3@operator
  00037	8b f4		 mov	 esi, esp
  00039	68 f8 04 00 00	 push	 1272			; 000004f8H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@LHOPDKO@?$AAD?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AAm?$AAi?$AAe?$AAr?$AAe@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@DCMHDKFO@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@operator:
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00061	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??A?$ImVector@G@@QAEAAGH@Z ENDP				; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@G@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?empty@?$ImVector@G@@QBE_NXZ PROC			; ImVector<unsigned short>::empty, COMDAT
; _this$ = ecx

; 1268 :     inline bool         empty() const                       { return Size == 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00013	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 0c		 jne	 SHORT $LN3@empty
  00035	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003f	eb 0a		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00041	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  0004b	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?empty@?$ImVector@G@@QBE_NXZ ENDP			; ImVector<unsigned short>::empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??1?$ImVector@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ImVector@G@@QAE@XZ PROC				; ImVector<unsigned short>::~ImVector<unsigned short>, COMDAT
; _this$ = ecx

; 1266 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$ImVector@G@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00021	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00053	74 0f		 je	 SHORT $LN3@ImVector
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPAX@Z ; ImGui::MemFree
  00061	83 c4 04	 add	 esp, 4
$LN3@ImVector:
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@G@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$ImVector@G@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@G@@QAE@XZ ENDP				; ImVector<unsigned short>::~ImVector<unsigned short>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??4?$ImVector@G@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_src$ = 8						; size = 4
??4?$ImVector@G@@QAEAAU0@ABU0@@Z PROC			; ImVector<unsigned short>::operator=, COMDAT
; _this$ = ecx

; 1265 :     inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?clear@?$ImVector@G@@QAEXXZ ; ImVector<unsigned short>::clear
  00035	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	51		 push	 ecx
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QAEXH@Z ; ImVector<unsigned short>::resize
  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	d1 e1		 shl	 ecx, 1
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0004e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00051	50		 push	 eax
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 _memcpy
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??4?$ImVector@G@@QAEAAU0@ABU0@@Z ENDP			; ImVector<unsigned short>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0?$ImVector@G@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$ImVector@G@@QAE@XZ PROC				; ImVector<unsigned short>::ImVector<unsigned short>, COMDAT
; _this$ = ecx

; 1263 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??0?$ImVector@G@@QAE@XZ ENDP				; ImVector<unsigned short>::ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??3@YAXPAXUImNewDummy@@0@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 4
??3@YAXPAXUImNewDummy@@0@Z PROC				; operator delete, COMDAT

; 1232 : inline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symmetrical new()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??3@YAXPAXUImNewDummy@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00020	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??3@YAXPAXUImNewDummy@@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??3@YAXPAXUImNewDummy@@0@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??3@YAXPAXUImNewDummy@@0@Z ENDP				; operator delete
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??2@YAPAXIUImNewDummy@@PAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
_ptr$ = 16						; size = 4
??2@YAPAXIUImNewDummy@@PAX@Z PROC			; operator new, COMDAT

; 1231 : inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 10	 mov	 eax, DWORD PTR _ptr$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??2@YAPAXIUImNewDummy@@PAX@Z ENDP			; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?StyleColorsLight@ImGui@@YAXPAUImGuiStyle@@@Z
_TEXT	SEGMENT
tv66 = -1708						; size = 4
$T1 = -1700						; size = 16
$T2 = -1676						; size = 16
$T3 = -1652						; size = 16
$T4 = -1628						; size = 16
$T5 = -1604						; size = 16
$T6 = -1580						; size = 16
$T7 = -1556						; size = 16
$T8 = -1532						; size = 16
$T9 = -1508						; size = 16
$T10 = -1484						; size = 16
$T11 = -1460						; size = 16
$T12 = -1436						; size = 16
$T13 = -1412						; size = 16
$T14 = -1388						; size = 16
$T15 = -1364						; size = 16
$T16 = -1340						; size = 16
$T17 = -1316						; size = 16
$T18 = -1292						; size = 16
$T19 = -1268						; size = 16
$T20 = -1244						; size = 16
$T21 = -1220						; size = 16
$T22 = -1196						; size = 16
$T23 = -1172						; size = 16
$T24 = -1148						; size = 16
$T25 = -1124						; size = 16
$T26 = -1100						; size = 16
$T27 = -1076						; size = 16
$T28 = -1052						; size = 16
$T29 = -1028						; size = 16
$T30 = -1004						; size = 16
$T31 = -980						; size = 16
$T32 = -956						; size = 16
$T33 = -932						; size = 16
$T34 = -908						; size = 16
$T35 = -884						; size = 16
$T36 = -860						; size = 16
$T37 = -836						; size = 16
$T38 = -812						; size = 16
$T39 = -788						; size = 16
$T40 = -764						; size = 16
$T41 = -740						; size = 16
$T42 = -716						; size = 16
$T43 = -692						; size = 16
$T44 = -668						; size = 16
$T45 = -644						; size = 16
$T46 = -620						; size = 16
_colors$ = -20						; size = 4
_style$ = -8						; size = 4
_dst$ = 8						; size = 4
?StyleColorsLight@ImGui@@YAXPAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsLight, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 06 00
	00		 sub	 esp, 1708		; 000006acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 54 f9 ff
	ff		 lea	 edi, DWORD PTR [ebp-1708]
  00012	b9 ab 01 00 00	 mov	 ecx, 427		; 000001abH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

  00028	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  0002c	74 0b		 je	 SHORT $LN3@StyleColor
  0002e	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00031	89 85 54 f9 ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00037	eb 0b		 jmp	 SHORT $LN4@StyleColor
$LN3@StyleColor:
  00039	e8 00 00 00 00	 call	 ?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ ; ImGui::GetStyle
  0003e	89 85 54 f9 ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
$LN4@StyleColor:
  00044	8b 8d 54 f9 ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0004a	89 4d f8	 mov	 DWORD PTR _style$[ebp], ecx

; 290  :     ImVec4* colors = style->Colors;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _style$[ebp]
  00050	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  00055	89 45 ec	 mov	 DWORD PTR _colors$[ebp], eax

; 291  : 
; 292  :     colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);

  00058	51		 push	 ecx
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	51		 push	 ecx
  00067	0f 57 c0	 xorps	 xmm0, xmm0
  0006a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006f	51		 push	 ecx
  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00078	51		 push	 ecx
  00079	0f 57 c0	 xorps	 xmm0, xmm0
  0007c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00081	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  00087	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0008c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00091	6b d1 00	 imul	 edx, ecx, 0
  00094	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00097	8b 08		 mov	 ecx, DWORD PTR [eax]
  00099	89 0a		 mov	 DWORD PTR [edx], ecx
  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000a1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000a7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000aa	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 293  :     colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);

  000ad	51		 push	 ecx
  000ae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	51		 push	 ecx
  000bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c9	51		 push	 ecx
  000ca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d7	51		 push	 ecx
  000d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e5	8d 8d 7c fd ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  000eb	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  000f0	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000f5	c1 e1 00	 shl	 ecx, 0
  000f8	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  000fb	8b 10		 mov	 edx, DWORD PTR [eax]
  000fd	89 11		 mov	 DWORD PTR [ecx], edx
  000ff	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00102	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00105	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00108	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0010b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0010e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 294  :     colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);

  00111	51		 push	 ecx
  00112	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0011a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011f	51		 push	 ecx
  00120	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f70a3d7
  00128	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012d	51		 push	 ecx
  0012e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f70a3d7
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	51		 push	 ecx
  0013c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f70a3d7
  00144	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00149	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  0014f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00154	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00159	d1 e1		 shl	 ecx, 1
  0015b	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0015e	8b 10		 mov	 edx, DWORD PTR [eax]
  00160	89 11		 mov	 DWORD PTR [ecx], edx
  00162	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00165	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00168	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0016b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0016e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00171	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 295  :     colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  00174	51		 push	 ecx
  00175	0f 57 c0	 xorps	 xmm0, xmm0
  00178	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017d	51		 push	 ecx
  0017e	0f 57 c0	 xorps	 xmm0, xmm0
  00181	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00186	51		 push	 ecx
  00187	0f 57 c0	 xorps	 xmm0, xmm0
  0018a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018f	51		 push	 ecx
  00190	0f 57 c0	 xorps	 xmm0, xmm0
  00193	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00198	8d 8d 4c fd ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  0019e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  001a3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001a8	6b d1 03	 imul	 edx, ecx, 3
  001ab	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  001ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b0	89 0a		 mov	 DWORD PTR [edx], ecx
  001b2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001bb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  001be	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001c1	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 296  :     colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);

  001c4	51		 push	 ecx
  001c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  001cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d2	51		 push	 ecx
  001d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e0	51		 push	 ecx
  001e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	51		 push	 ecx
  001ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fc	8d 8d 34 fd ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  00202	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00207	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0020c	c1 e1 02	 shl	 ecx, 2
  0020f	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00212	8b 10		 mov	 edx, DWORD PTR [eax]
  00214	89 11		 mov	 DWORD PTR [ecx], edx
  00216	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00219	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0021c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0021f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00222	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00225	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 297  :     colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);

  00228	51		 push	 ecx
  00229	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e99999a
  00231	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00236	51		 push	 ecx
  00237	0f 57 c0	 xorps	 xmm0, xmm0
  0023a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023f	51		 push	 ecx
  00240	0f 57 c0	 xorps	 xmm0, xmm0
  00243	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00248	51		 push	 ecx
  00249	0f 57 c0	 xorps	 xmm0, xmm0
  0024c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00251	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  00257	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0025c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00261	6b d1 05	 imul	 edx, ecx, 5
  00264	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00267	8b 08		 mov	 ecx, DWORD PTR [eax]
  00269	89 0a		 mov	 DWORD PTR [edx], ecx
  0026b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00271	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00274	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00277	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0027a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 298  :     colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  0027d	51		 push	 ecx
  0027e	0f 57 c0	 xorps	 xmm0, xmm0
  00281	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00286	51		 push	 ecx
  00287	0f 57 c0	 xorps	 xmm0, xmm0
  0028a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028f	51		 push	 ecx
  00290	0f 57 c0	 xorps	 xmm0, xmm0
  00293	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00298	51		 push	 ecx
  00299	0f 57 c0	 xorps	 xmm0, xmm0
  0029c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a1	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T40[ebp]
  002a7	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  002ac	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002b1	6b d1 06	 imul	 edx, ecx, 6
  002b4	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  002b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b9	89 0a		 mov	 DWORD PTR [edx], ecx
  002bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002be	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002c1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002c4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  002c7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002ca	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 299  :     colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

  002cd	51		 push	 ecx
  002ce	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002db	51		 push	 ecx
  002dc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e9	51		 push	 ecx
  002ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f7	51		 push	 ecx
  002f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00300	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00305	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  0030b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00310	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00315	6b d1 07	 imul	 edx, ecx, 7
  00318	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0031b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031d	89 0a		 mov	 DWORD PTR [edx], ecx
  0031f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00322	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00325	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00328	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0032b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0032e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 300  :     colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

  00331	51		 push	 ecx
  00332	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  0033a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0033f	51		 push	 ecx
  00340	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00348	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034d	51		 push	 ecx
  0034e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00356	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035b	51		 push	 ecx
  0035c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00364	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00369	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  0036f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00374	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00379	c1 e1 03	 shl	 ecx, 3
  0037c	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0037f	8b 10		 mov	 edx, DWORD PTR [eax]
  00381	89 11		 mov	 DWORD PTR [ecx], edx
  00383	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00386	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00389	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0038c	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0038f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00392	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 301  :     colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

  00395	51		 push	 ecx
  00396	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f2b851f
  0039e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a3	51		 push	 ecx
  003a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  003ac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b1	51		 push	 ecx
  003b2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  003ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003bf	51		 push	 ecx
  003c0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  003c8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cd	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR $T37[ebp]
  003d3	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  003d8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003dd	6b d1 09	 imul	 edx, ecx, 9
  003e0	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  003e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e5	89 0a		 mov	 DWORD PTR [edx], ecx
  003e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003ea	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  003ed	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003f0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  003f3	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  003f6	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 302  :     colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);

  003f9	51		 push	 ecx
  003fa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00402	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00407	51		 push	 ecx
  00408	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f75c28f
  00410	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00415	51		 push	 ecx
  00416	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f75c28f
  0041e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00423	51		 push	 ecx
  00424	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f75c28f
  0042c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00431	8d 8d a4 fc ff
	ff		 lea	 ecx, DWORD PTR $T36[ebp]
  00437	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0043c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00441	6b d1 0a	 imul	 edx, ecx, 10
  00444	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00447	8b 08		 mov	 ecx, DWORD PTR [eax]
  00449	89 0a		 mov	 DWORD PTR [edx], ecx
  0044b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0044e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00451	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00454	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00457	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0045a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 303  :     colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);

  0045d	51		 push	 ecx
  0045e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00466	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0046b	51		 push	 ecx
  0046c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f51eb85
  00474	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00479	51		 push	 ecx
  0047a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f51eb85
  00482	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00487	51		 push	 ecx
  00488	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f51eb85
  00490	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00495	8d 8d 8c fc ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  0049b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  004a0	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004a5	6b d1 0b	 imul	 edx, ecx, 11
  004a8	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  004ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ad	89 0a		 mov	 DWORD PTR [edx], ecx
  004af	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004b2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  004b5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004b8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  004bb	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  004be	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 304  :     colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);

  004c1	51		 push	 ecx
  004c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f028f5c
  004ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004cf	51		 push	 ecx
  004d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004dd	51		 push	 ecx
  004de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004eb	51		 push	 ecx
  004ec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004f9	8d 8d 74 fc ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  004ff	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00504	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00509	6b d1 0c	 imul	 edx, ecx, 12
  0050c	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0050f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00511	89 0a		 mov	 DWORD PTR [edx], ecx
  00513	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00516	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00519	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0051c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0051f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00522	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 305  :     colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);

  00525	51		 push	 ecx
  00526	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0052e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00533	51		 push	 ecx
  00534	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f5c28f6
  0053c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00541	51		 push	 ecx
  00542	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f5c28f6
  0054a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0054f	51		 push	 ecx
  00550	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f5c28f6
  00558	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055d	8d 8d 5c fc ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00563	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00568	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0056d	6b d1 0d	 imul	 edx, ecx, 13
  00570	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00573	8b 08		 mov	 ecx, DWORD PTR [eax]
  00575	89 0a		 mov	 DWORD PTR [edx], ecx
  00577	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0057a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0057d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00580	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00583	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00586	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 306  :     colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);

  00589	51		 push	 ecx
  0058a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f07ae14
  00592	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00597	51		 push	 ecx
  00598	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  005a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a5	51		 push	 ecx
  005a6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  005ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b3	51		 push	 ecx
  005b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  005bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c1	8d 8d 44 fc ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  005c7	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  005cc	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  005d1	6b d1 0e	 imul	 edx, ecx, 14
  005d4	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  005d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  005d9	89 0a		 mov	 DWORD PTR [edx], ecx
  005db	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005de	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  005e1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005e4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  005e7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  005ea	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 307  :     colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);

  005ed	51		 push	 ecx
  005ee	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  005f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005fb	51		 push	 ecx
  005fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f30a3d7
  00604	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00609	51		 push	 ecx
  0060a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f30a3d7
  00612	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00617	51		 push	 ecx
  00618	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f30a3d7
  00620	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00625	8d 8d 2c fc ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  0062b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00630	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00635	6b d1 0f	 imul	 edx, ecx, 15
  00638	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0063b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0063d	89 0a		 mov	 DWORD PTR [edx], ecx
  0063f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00642	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00645	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00648	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0064b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0064e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 308  :     colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);

  00651	51		 push	 ecx
  00652	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  0065a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0065f	51		 push	 ecx
  00660	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  00668	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0066d	51		 push	 ecx
  0066e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  00676	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0067b	51		 push	 ecx
  0067c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  00684	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00689	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  0068f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00694	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00699	c1 e1 04	 shl	 ecx, 4
  0069c	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0069f	8b 10		 mov	 edx, DWORD PTR [eax]
  006a1	89 11		 mov	 DWORD PTR [ecx], edx
  006a3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  006a6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  006a9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  006ac	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  006af	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  006b2	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 309  :     colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);

  006b5	51		 push	 ecx
  006b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006c3	51		 push	 ecx
  006c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  006cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006d1	51		 push	 ecx
  006d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  006da	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006df	51		 push	 ecx
  006e0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3efae148
  006e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ed	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  006f3	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  006f8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  006fd	6b d1 11	 imul	 edx, ecx, 17
  00700	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00703	8b 08		 mov	 ecx, DWORD PTR [eax]
  00705	89 0a		 mov	 DWORD PTR [edx], ecx
  00707	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0070a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0070d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00710	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00713	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00716	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 310  :     colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  00719	51		 push	 ecx
  0071a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00722	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00727	51		 push	 ecx
  00728	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00730	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00735	51		 push	 ecx
  00736	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  0073e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00743	51		 push	 ecx
  00744	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  0074c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00751	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00757	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0075c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00761	6b d1 12	 imul	 edx, ecx, 18
  00764	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00767	8b 08		 mov	 ecx, DWORD PTR [eax]
  00769	89 0a		 mov	 DWORD PTR [edx], ecx
  0076b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0076e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00771	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00774	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00777	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0077a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 311  :     colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);

  0077d	51		 push	 ecx
  0077e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f47ae14
  00786	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0078b	51		 push	 ecx
  0078c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00794	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00799	51		 push	 ecx
  0079a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  007a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007a7	51		 push	 ecx
  007a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  007b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007b5	8d 8d cc fb ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  007bb	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  007c0	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  007c5	6b d1 13	 imul	 edx, ecx, 19
  007c8	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  007cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  007cd	89 0a		 mov	 DWORD PTR [edx], ecx
  007cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  007d2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  007d5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  007d8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  007db	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  007de	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 312  :     colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);

  007e1	51		 push	 ecx
  007e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  007ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007ef	51		 push	 ecx
  007f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  007f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007fd	51		 push	 ecx
  007fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00806	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0080b	51		 push	 ecx
  0080c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eeb851f
  00814	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00819	8d 8d b4 fb ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0081f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00824	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00829	6b d1 14	 imul	 edx, ecx, 20
  0082c	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0082f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00831	89 0a		 mov	 DWORD PTR [edx], ecx
  00833	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00836	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00839	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0083c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0083f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00842	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 313  :     colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

  00845	51		 push	 ecx
  00846	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  0084e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00853	51		 push	 ecx
  00854	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  0085c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00861	51		 push	 ecx
  00862	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  0086a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0086f	51		 push	 ecx
  00870	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00878	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0087d	8d 8d 9c fb ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00883	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00888	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0088d	6b d1 15	 imul	 edx, ecx, 21
  00890	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00893	8b 08		 mov	 ecx, DWORD PTR [eax]
  00895	89 0a		 mov	 DWORD PTR [edx], ecx
  00897	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0089a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0089d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  008a0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  008a3	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  008a6	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 314  :     colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  008a9	51		 push	 ecx
  008aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008b7	51		 push	 ecx
  008b8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  008c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c5	51		 push	 ecx
  008c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  008ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d3	51		 push	 ecx
  008d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  008dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008e1	8d 8d 84 fb ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  008e7	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  008ec	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  008f1	6b d1 16	 imul	 edx, ecx, 22
  008f4	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  008f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  008f9	89 0a		 mov	 DWORD PTR [edx], ecx
  008fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  008fe	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00901	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00904	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00907	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0090a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 315  :     colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);

  0090d	51		 push	 ecx
  0090e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00916	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0091b	51		 push	 ecx
  0091c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00924	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00929	51		 push	 ecx
  0092a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f07ae14
  00932	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00937	51		 push	 ecx
  00938	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d75c28f
  00940	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00945	8d 8d 6c fb ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  0094b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00950	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00955	6b d1 17	 imul	 edx, ecx, 23
  00958	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0095b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0095d	89 0a		 mov	 DWORD PTR [edx], ecx
  0095f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00962	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00965	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00968	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0096b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0096e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 316  :     colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);

  00971	51		 push	 ecx
  00972	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e9eb852
  0097a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0097f	51		 push	 ecx
  00980	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00988	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0098d	51		 push	 ecx
  0098e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00996	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0099b	51		 push	 ecx
  0099c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  009a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009a9	8d 8d 54 fb ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  009af	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  009b4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  009b9	6b d1 18	 imul	 edx, ecx, 24
  009bc	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  009bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  009c1	89 0a		 mov	 DWORD PTR [edx], ecx
  009c3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009c6	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  009c9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  009cc	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  009cf	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  009d2	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 317  :     colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);

  009d5	51		 push	 ecx
  009d6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  009de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009e3	51		 push	 ecx
  009e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  009ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009f1	51		 push	 ecx
  009f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  009fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009ff	51		 push	 ecx
  00a00	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00a08	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a0d	8d 8d 3c fb ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00a13	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00a18	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00a1d	6b d1 19	 imul	 edx, ecx, 25
  00a20	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00a23	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a25	89 0a		 mov	 DWORD PTR [edx], ecx
  00a27	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a2a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00a2d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a30	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00a33	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00a36	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 318  :     colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  00a39	51		 push	 ecx
  00a3a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a42	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a47	51		 push	 ecx
  00a48	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00a50	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a55	51		 push	 ecx
  00a56	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00a5e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a63	51		 push	 ecx
  00a64	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00a6c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a71	8d 8d 24 fb ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00a77	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00a7c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00a81	6b d1 1a	 imul	 edx, ecx, 26
  00a84	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00a87	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a89	89 0a		 mov	 DWORD PTR [edx], ecx
  00a8b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a8e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00a91	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a94	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00a97	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00a9a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 319  :     colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 0.62f);

  00a9d	51		 push	 ecx
  00a9e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f1eb852
  00aa6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aab	51		 push	 ecx
  00aac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  00ab4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ab9	51		 push	 ecx
  00aba	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  00ac2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ac7	51		 push	 ecx
  00ac8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  00ad0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ad5	8d 8d 0c fb ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00adb	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00ae0	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00ae5	6b d1 1b	 imul	 edx, ecx, 27
  00ae8	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00aeb	8b 08		 mov	 ecx, DWORD PTR [eax]
  00aed	89 0a		 mov	 DWORD PTR [edx], ecx
  00aef	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00af2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00af5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00af8	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00afb	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00afe	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 320  :     colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);

  00b01	51		 push	 ecx
  00b02	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f47ae14
  00b0a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b0f	51		 push	 ecx
  00b10	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00b18	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b1d	51		 push	 ecx
  00b1e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ee147ae
  00b26	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b2b	51		 push	 ecx
  00b2c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e0f5c29
  00b34	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b39	8d 8d f4 fa ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00b3f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00b44	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00b49	6b d1 1c	 imul	 edx, ecx, 28
  00b4c	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00b4f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b51	89 0a		 mov	 DWORD PTR [edx], ecx
  00b53	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b56	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b59	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b5c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b5f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b62	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 321  :     colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);

  00b65	51		 push	 ecx
  00b66	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b6e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b73	51		 push	 ecx
  00b74	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00b7c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b81	51		 push	 ecx
  00b82	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ee147ae
  00b8a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b8f	51		 push	 ecx
  00b90	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e0f5c29
  00b98	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b9d	8d 8d dc fa ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00ba3	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00ba8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00bad	6b d1 1d	 imul	 edx, ecx, 29
  00bb0	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00bb3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bb5	89 0a		 mov	 DWORD PTR [edx], ecx
  00bb7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bba	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00bbd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00bc0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00bc3	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00bc6	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 322  :     colors[ImGuiCol_ResizeGrip]             = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);

  00bc9	51		 push	 ecx
  00bca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0f5c29
  00bd2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bd7	51		 push	 ecx
  00bd8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00be0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00be5	51		 push	 ecx
  00be6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00bee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bf3	51		 push	 ecx
  00bf4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00bfc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c01	8d 8d c4 fa ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00c07	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00c0c	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00c11	6b d1 1e	 imul	 edx, ecx, 30
  00c14	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00c17	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c19	89 0a		 mov	 DWORD PTR [edx], ecx
  00c1b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c1e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c21	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c24	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c27	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c2a	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 323  :     colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

  00c2d	51		 push	 ecx
  00c2e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f2b851f
  00c36	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c3b	51		 push	 ecx
  00c3c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00c44	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c49	51		 push	 ecx
  00c4a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00c52	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c57	51		 push	 ecx
  00c58	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00c60	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c65	8d 8d ac fa ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00c6b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00c70	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00c75	6b d1 1f	 imul	 edx, ecx, 31
  00c78	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00c7b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c7d	89 0a		 mov	 DWORD PTR [edx], ecx
  00c7f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c82	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c85	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c88	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c8b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c8e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 324  :     colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

  00c91	51		 push	 ecx
  00c92	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f733333
  00c9a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c9f	51		 push	 ecx
  00ca0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00ca8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cad	51		 push	 ecx
  00cae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00cb6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cbb	51		 push	 ecx
  00cbc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00cc4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cc9	8d 8d 94 fa ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00ccf	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00cd4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00cd9	c1 e1 05	 shl	 ecx, 5
  00cdc	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00cdf	8b 10		 mov	 edx, DWORD PTR [eax]
  00ce1	89 11		 mov	 DWORD PTR [ecx], edx
  00ce3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00ce6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00ce9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00cec	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00cef	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00cf2	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 325  :     colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);

  00cf5	51		 push	 ecx
  00cf6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00cfe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d03	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d08	6b c8 0b	 imul	 ecx, eax, 11
  00d0b	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d0e	51		 push	 ecx
  00d0f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d14	6b c2 18	 imul	 eax, edx, 24
  00d17	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00d1a	50		 push	 eax
  00d1b	8d 8d 7c fa ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00d21	51		 push	 ecx
  00d22	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00d27	83 c4 10	 add	 esp, 16			; 00000010H
  00d2a	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d2f	6b ca 21	 imul	 ecx, edx, 33
  00d32	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d35	8b 10		 mov	 edx, DWORD PTR [eax]
  00d37	89 11		 mov	 DWORD PTR [ecx], edx
  00d39	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00d3c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00d3f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00d42	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00d45	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00d48	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 326  :     colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];

  00d4b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d50	6b c8 19	 imul	 ecx, eax, 25
  00d53	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d56	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d5b	6b c2 22	 imul	 eax, edx, 34
  00d5e	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00d61	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d63	89 10		 mov	 DWORD PTR [eax], edx
  00d65	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00d68	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00d6b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00d6e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00d71	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00d74	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 327  :     colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

  00d77	51		 push	 ecx
  00d78	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00d80	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d85	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d8a	6b c8 0b	 imul	 ecx, eax, 11
  00d8d	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d90	51		 push	 ecx
  00d91	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d96	6b c2 1a	 imul	 eax, edx, 26
  00d99	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00d9c	50		 push	 eax
  00d9d	8d 8d 64 fa ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00da3	51		 push	 ecx
  00da4	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00da9	83 c4 10	 add	 esp, 16			; 00000010H
  00dac	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00db1	6b ca 23	 imul	 ecx, edx, 35
  00db4	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00db7	8b 10		 mov	 edx, DWORD PTR [eax]
  00db9	89 11		 mov	 DWORD PTR [ecx], edx
  00dbb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00dbe	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00dc1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00dc4	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00dc7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00dca	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 328  :     colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);

  00dcd	51		 push	 ecx
  00dce	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00dd6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ddb	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00de0	6b c8 0a	 imul	 ecx, eax, 10
  00de3	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00de6	51		 push	 ecx
  00de7	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00dec	6b c2 21	 imul	 eax, edx, 33
  00def	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00df2	50		 push	 eax
  00df3	8d 8d 4c fa ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00df9	51		 push	 ecx
  00dfa	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00dff	83 c4 10	 add	 esp, 16			; 00000010H
  00e02	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e07	6b ca 24	 imul	 ecx, edx, 36
  00e0a	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e0d	8b 10		 mov	 edx, DWORD PTR [eax]
  00e0f	89 11		 mov	 DWORD PTR [ecx], edx
  00e11	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e14	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00e17	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00e1a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00e1d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00e20	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 329  :     colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);

  00e23	51		 push	 ecx
  00e24	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00e2c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e31	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00e36	6b c8 0a	 imul	 ecx, eax, 10
  00e39	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e3c	51		 push	 ecx
  00e3d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e42	6b c2 23	 imul	 eax, edx, 35
  00e45	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00e48	50		 push	 eax
  00e49	8d 8d 34 fa ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00e4f	51		 push	 ecx
  00e50	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00e55	83 c4 10	 add	 esp, 16			; 00000010H
  00e58	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e5d	6b ca 25	 imul	 ecx, edx, 37
  00e60	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e63	8b 10		 mov	 edx, DWORD PTR [eax]
  00e65	89 11		 mov	 DWORD PTR [ecx], edx
  00e67	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e6a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00e6d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00e70	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00e73	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00e76	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 330  :     colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);

  00e79	51		 push	 ecx
  00e7a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e82	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e87	51		 push	 ecx
  00e88	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  00e90	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e95	51		 push	 ecx
  00e96	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  00e9e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ea3	51		 push	 ecx
  00ea4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  00eac	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00eb1	8d 8d 1c fa ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00eb7	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00ebc	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00ec1	6b d1 26	 imul	 edx, ecx, 38
  00ec4	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00ec7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ec9	89 0a		 mov	 DWORD PTR [edx], ecx
  00ecb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ece	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ed1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ed4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00ed7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00eda	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 331  :     colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);

  00edd	51		 push	 ecx
  00ede	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ee6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00eeb	51		 push	 ecx
  00eec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  00ef4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ef9	51		 push	 ecx
  00efa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3edc28f6
  00f02	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f07	51		 push	 ecx
  00f08	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00f10	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f15	8d 8d 04 fa ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00f1b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00f20	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00f25	6b d1 27	 imul	 edx, ecx, 39
  00f28	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00f2b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f2d	89 0a		 mov	 DWORD PTR [edx], ecx
  00f2f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f32	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00f35	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f38	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00f3b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00f3e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 332  :     colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

  00f41	51		 push	 ecx
  00f42	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00f4a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f4f	51		 push	 ecx
  00f50	0f 57 c0	 xorps	 xmm0, xmm0
  00f53	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f58	51		 push	 ecx
  00f59	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00f61	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f66	51		 push	 ecx
  00f67	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00f6f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f74	8d 8d ec f9 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00f7a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00f7f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00f84	6b d1 28	 imul	 edx, ecx, 40
  00f87	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00f8a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f8c	89 0a		 mov	 DWORD PTR [edx], ecx
  00f8e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f91	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00f94	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f97	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00f9a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00f9d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 333  :     colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);

  00fa0	51		 push	 ecx
  00fa1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00fa9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fae	51		 push	 ecx
  00faf	0f 57 c0	 xorps	 xmm0, xmm0
  00fb2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fb7	51		 push	 ecx
  00fb8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ee66666
  00fc0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fc5	51		 push	 ecx
  00fc6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00fce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fd3	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00fd9	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00fde	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00fe3	6b d1 29	 imul	 edx, ecx, 41
  00fe6	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00fe9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00feb	89 0a		 mov	 DWORD PTR [edx], ecx
  00fed	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ff0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ff3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ff6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00ff9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00ffc	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 334  :     colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);

  00fff	51		 push	 ecx
  01000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  01008	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0100d	51		 push	 ecx
  0100e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  01016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0101b	51		 push	 ecx
  0101c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  01024	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01029	51		 push	 ecx
  0102a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  01032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01037	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0103d	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01042	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  01047	6b d1 2a	 imul	 edx, ecx, 42
  0104a	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0104d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0104f	89 0a		 mov	 DWORD PTR [edx], ecx
  01051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01054	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01057	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0105a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0105d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01060	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 335  :     colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

  01063	51		 push	 ecx
  01064	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f733333
  0106c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01071	51		 push	 ecx
  01072	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  0107a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0107f	51		 push	 ecx
  01080	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  01088	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0108d	51		 push	 ecx
  0108e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  01096	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0109b	8d 8d a4 f9 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  010a1	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  010a6	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  010ab	6b d1 2b	 imul	 edx, ecx, 43
  010ae	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  010b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  010b3	89 0a		 mov	 DWORD PTR [edx], ecx
  010b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  010b8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  010bb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  010be	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  010c1	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  010c4	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 336  :     colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];

  010c7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  010cc	6b c8 19	 imul	 ecx, eax, 25
  010cf	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  010d2	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  010d7	6b c2 2c	 imul	 eax, edx, 44
  010da	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  010dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  010df	89 10		 mov	 DWORD PTR [eax], edx
  010e1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  010e4	89 50 04	 mov	 DWORD PTR [eax+4], edx
  010e7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  010ea	89 50 08	 mov	 DWORD PTR [eax+8], edx
  010ed	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  010f0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 337  :     colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);

  010f3	51		 push	 ecx
  010f4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  010fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01101	51		 push	 ecx
  01102	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  0110a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0110f	51		 push	 ecx
  01110	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  01118	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0111d	51		 push	 ecx
  0111e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  01126	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0112b	8d 8d 8c f9 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  01131	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01136	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0113b	6b d1 2d	 imul	 edx, ecx, 45
  0113e	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  01141	8b 08		 mov	 ecx, DWORD PTR [eax]
  01143	89 0a		 mov	 DWORD PTR [edx], ecx
  01145	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01148	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0114b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0114e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01151	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01154	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 338  :     colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);

  01157	51		 push	 ecx
  01158	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  01160	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01165	51		 push	 ecx
  01166	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0116e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01173	51		 push	 ecx
  01174	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0117c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01181	51		 push	 ecx
  01182	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0118a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0118f	8d 8d 74 f9 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  01195	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0119a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0119f	6b d1 2e	 imul	 edx, ecx, 46
  011a2	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  011a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  011a7	89 0a		 mov	 DWORD PTR [edx], ecx
  011a9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  011ac	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  011af	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  011b2	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  011b5	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  011b8	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 339  :     colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);

  011bb	51		 push	 ecx
  011bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  011c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011c9	51		 push	 ecx
  011ca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  011d2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011d7	51		 push	 ecx
  011d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  011e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011e5	51		 push	 ecx
  011e6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  011ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011f3	8d 8d 5c f9 ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  011f9	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  011fe	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  01203	6b d1 2f	 imul	 edx, ecx, 47
  01206	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  01209	8b 08		 mov	 ecx, DWORD PTR [eax]
  0120b	89 0a		 mov	 DWORD PTR [edx], ecx
  0120d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01210	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01213	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01216	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01219	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0121c	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 340  : }

  0121f	5f		 pop	 edi
  01220	5e		 pop	 esi
  01221	5b		 pop	 ebx
  01222	81 c4 ac 06 00
	00		 add	 esp, 1708		; 000006acH
  01228	3b ec		 cmp	 ebp, esp
  0122a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0122f	8b e5		 mov	 esp, ebp
  01231	5d		 pop	 ebp
  01232	c3		 ret	 0
?StyleColorsLight@ImGui@@YAXPAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsLight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?StyleColorsClassic@ImGui@@YAXPAUImGuiStyle@@@Z
_TEXT	SEGMENT
tv66 = -1708						; size = 4
$T1 = -1700						; size = 16
$T2 = -1676						; size = 16
$T3 = -1652						; size = 16
$T4 = -1628						; size = 16
$T5 = -1604						; size = 16
$T6 = -1580						; size = 16
$T7 = -1556						; size = 16
$T8 = -1532						; size = 16
$T9 = -1508						; size = 16
$T10 = -1484						; size = 16
$T11 = -1460						; size = 16
$T12 = -1436						; size = 16
$T13 = -1412						; size = 16
$T14 = -1388						; size = 16
$T15 = -1364						; size = 16
$T16 = -1340						; size = 16
$T17 = -1316						; size = 16
$T18 = -1292						; size = 16
$T19 = -1268						; size = 16
$T20 = -1244						; size = 16
$T21 = -1220						; size = 16
$T22 = -1196						; size = 16
$T23 = -1172						; size = 16
$T24 = -1148						; size = 16
$T25 = -1124						; size = 16
$T26 = -1100						; size = 16
$T27 = -1076						; size = 16
$T28 = -1052						; size = 16
$T29 = -1028						; size = 16
$T30 = -1004						; size = 16
$T31 = -980						; size = 16
$T32 = -956						; size = 16
$T33 = -932						; size = 16
$T34 = -908						; size = 16
$T35 = -884						; size = 16
$T36 = -860						; size = 16
$T37 = -836						; size = 16
$T38 = -812						; size = 16
$T39 = -788						; size = 16
$T40 = -764						; size = 16
$T41 = -740						; size = 16
$T42 = -716						; size = 16
$T43 = -692						; size = 16
$T44 = -668						; size = 16
$T45 = -644						; size = 16
$T46 = -620						; size = 16
_colors$ = -20						; size = 4
_style$ = -8						; size = 4
_dst$ = 8						; size = 4
?StyleColorsClassic@ImGui@@YAXPAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsClassic, COMDAT

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 06 00
	00		 sub	 esp, 1708		; 000006acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 54 f9 ff
	ff		 lea	 edi, DWORD PTR [ebp-1708]
  00012	b9 ab 01 00 00	 mov	 ecx, 427		; 000001abH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 233  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

  00028	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  0002c	74 0b		 je	 SHORT $LN3@StyleColor
  0002e	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00031	89 85 54 f9 ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00037	eb 0b		 jmp	 SHORT $LN4@StyleColor
$LN3@StyleColor:
  00039	e8 00 00 00 00	 call	 ?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ ; ImGui::GetStyle
  0003e	89 85 54 f9 ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
$LN4@StyleColor:
  00044	8b 8d 54 f9 ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0004a	89 4d f8	 mov	 DWORD PTR _style$[ebp], ecx

; 234  :     ImVec4* colors = style->Colors;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _style$[ebp]
  00050	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  00055	89 45 ec	 mov	 DWORD PTR _colors$[ebp], eax

; 235  : 
; 236  :     colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);

  00058	51		 push	 ecx
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	51		 push	 ecx
  00067	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	51		 push	 ecx
  00075	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  0007d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00082	51		 push	 ecx
  00083	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  00096	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0009b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000a0	6b d1 00	 imul	 edx, ecx, 0
  000a3	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	89 0a		 mov	 DWORD PTR [edx], ecx
  000aa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ad	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000b0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000b6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000b9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 237  :     colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);

  000bc	51		 push	 ecx
  000bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	51		 push	 ecx
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d8	51		 push	 ecx
  000d9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e6	51		 push	 ecx
  000e7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  000ef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f4	8d 8d 7c fd ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  000fa	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  000ff	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00104	c1 e1 00	 shl	 ecx, 0
  00107	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0010a	8b 10		 mov	 edx, DWORD PTR [eax]
  0010c	89 11		 mov	 DWORD PTR [ecx], edx
  0010e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00111	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00114	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00117	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0011a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0011d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 238  :     colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);

  00120	51		 push	 ecx
  00121	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00129	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012e	51		 push	 ecx
  0012f	0f 57 c0	 xorps	 xmm0, xmm0
  00132	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00137	51		 push	 ecx
  00138	0f 57 c0	 xorps	 xmm0, xmm0
  0013b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00140	51		 push	 ecx
  00141	0f 57 c0	 xorps	 xmm0, xmm0
  00144	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00149	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  0014f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00154	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00159	d1 e1		 shl	 ecx, 1
  0015b	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0015e	8b 10		 mov	 edx, DWORD PTR [eax]
  00160	89 11		 mov	 DWORD PTR [ecx], edx
  00162	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00165	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00168	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0016b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0016e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00171	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 239  :     colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  00174	51		 push	 ecx
  00175	0f 57 c0	 xorps	 xmm0, xmm0
  00178	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017d	51		 push	 ecx
  0017e	0f 57 c0	 xorps	 xmm0, xmm0
  00181	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00186	51		 push	 ecx
  00187	0f 57 c0	 xorps	 xmm0, xmm0
  0018a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018f	51		 push	 ecx
  00190	0f 57 c0	 xorps	 xmm0, xmm0
  00193	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00198	8d 8d 4c fd ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  0019e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  001a3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001a8	6b d1 03	 imul	 edx, ecx, 3
  001ab	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  001ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b0	89 0a		 mov	 DWORD PTR [edx], ecx
  001b2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001bb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  001be	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001c1	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 240  :     colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);

  001c4	51		 push	 ecx
  001c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f6b851f
  001cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d2	51		 push	 ecx
  001d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e0f5c29
  001db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e0	51		 push	 ecx
  001e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3de147ae
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	51		 push	 ecx
  001ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3de147ae
  001f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fc	8d 8d 34 fd ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  00202	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00207	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0020c	c1 e1 02	 shl	 ecx, 2
  0020f	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00212	8b 10		 mov	 edx, DWORD PTR [eax]
  00214	89 11		 mov	 DWORD PTR [ecx], edx
  00216	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00219	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0021c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0021f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00222	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00225	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 241  :     colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);

  00228	51		 push	 ecx
  00229	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00231	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00236	51		 push	 ecx
  00237	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0023f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00244	51		 push	 ecx
  00245	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0024d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00252	51		 push	 ecx
  00253	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0025b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00260	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  00266	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0026b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00270	6b d1 05	 imul	 edx, ecx, 5
  00273	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00276	8b 08		 mov	 ecx, DWORD PTR [eax]
  00278	89 0a		 mov	 DWORD PTR [edx], ecx
  0027a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0027d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00280	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00283	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00286	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00289	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 242  :     colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  0028c	51		 push	 ecx
  0028d	0f 57 c0	 xorps	 xmm0, xmm0
  00290	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00295	51		 push	 ecx
  00296	0f 57 c0	 xorps	 xmm0, xmm0
  00299	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029e	51		 push	 ecx
  0029f	0f 57 c0	 xorps	 xmm0, xmm0
  002a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a7	51		 push	 ecx
  002a8	0f 57 c0	 xorps	 xmm0, xmm0
  002ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b0	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T40[ebp]
  002b6	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  002bb	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002c0	6b d1 06	 imul	 edx, ecx, 6
  002c3	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  002c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c8	89 0a		 mov	 DWORD PTR [edx], ecx
  002ca	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002cd	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002d0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002d3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  002d6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002d9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 243  :     colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);

  002dc	51		 push	 ecx
  002dd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  002e5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ea	51		 push	 ecx
  002eb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3edc28f6
  002f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f8	51		 push	 ecx
  002f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3edc28f6
  00301	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00306	51		 push	 ecx
  00307	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3edc28f6
  0030f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00314	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  0031a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0031f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00324	6b d1 07	 imul	 edx, ecx, 7
  00327	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0032a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032c	89 0a		 mov	 DWORD PTR [edx], ecx
  0032e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00331	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00334	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00337	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0033a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0033d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 244  :     colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);

  00340	51		 push	 ecx
  00341	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00349	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034e	51		 push	 ecx
  0034f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f30a3d7
  00357	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035c	51		 push	 ecx
  0035d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ef0a3d7
  00365	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036a	51		 push	 ecx
  0036b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ef0a3d7
  00373	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00378	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  0037e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00383	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00388	c1 e1 03	 shl	 ecx, 3
  0038b	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0038e	8b 10		 mov	 edx, DWORD PTR [eax]
  00390	89 11		 mov	 DWORD PTR [ecx], edx
  00392	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00395	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00398	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0039b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0039e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  003a1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 245  :     colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);

  003a4	51		 push	 ecx
  003a5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f30a3d7
  003ad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b2	51		 push	 ecx
  003b3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f23d70a
  003bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c0	51		 push	 ecx
  003c1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ed1eb85
  003c9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ce	51		 push	 ecx
  003cf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ed70a3d
  003d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003dc	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR $T37[ebp]
  003e2	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  003e7	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003ec	6b d1 09	 imul	 edx, ecx, 9
  003ef	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  003f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f4	89 0a		 mov	 DWORD PTR [edx], ecx
  003f6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  003fc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003ff	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00402	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00405	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 246  :     colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);

  00408	51		 push	 ecx
  00409	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f547ae1
  00411	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00416	51		 push	 ecx
  00417	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  0041f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00424	51		 push	 ecx
  00425	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e8a3d71
  0042d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00432	51		 push	 ecx
  00433	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e8a3d71
  0043b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00440	8d 8d a4 fc ff
	ff		 lea	 ecx, DWORD PTR $T36[ebp]
  00446	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0044b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00450	6b d1 0a	 imul	 edx, ecx, 10
  00453	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00456	8b 08		 mov	 ecx, DWORD PTR [eax]
  00458	89 0a		 mov	 DWORD PTR [edx], ecx
  0045a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0045d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00460	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00463	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00466	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00469	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 247  :     colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);

  0046c	51		 push	 ecx
  0046d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f5eb852
  00475	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0047a	51		 push	 ecx
  0047b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f2147ae
  00483	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00488	51		 push	 ecx
  00489	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ea3d70a
  00491	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00496	51		 push	 ecx
  00497	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ea3d70a
  0049f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a4	8d 8d 8c fc ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  004aa	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  004af	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004b4	6b d1 0b	 imul	 edx, ecx, 11
  004b7	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  004ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  004bc	89 0a		 mov	 DWORD PTR [edx], ecx
  004be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004c1	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  004c4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004c7	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  004ca	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  004cd	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 248  :     colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);

  004d0	51		 push	 ecx
  004d1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  004d9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004de	51		 push	 ecx
  004df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  004e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ec	51		 push	 ecx
  004ed	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  004f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004fa	51		 push	 ecx
  004fb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00503	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00508	8d 8d 74 fc ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  0050e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00513	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00518	6b d1 0c	 imul	 edx, ecx, 12
  0051b	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0051e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00520	89 0a		 mov	 DWORD PTR [edx], ecx
  00522	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00525	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00528	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0052b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0052e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00531	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 249  :     colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);

  00534	51		 push	 ecx
  00535	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  0053d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00542	51		 push	 ecx
  00543	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0ccccd
  0054b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00550	51		 push	 ecx
  00551	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00559	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055e	51		 push	 ecx
  0055f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00567	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0056c	8d 8d 5c fc ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00572	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00577	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0057c	6b d1 0d	 imul	 edx, ecx, 13
  0057f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00582	8b 08		 mov	 ecx, DWORD PTR [eax]
  00584	89 0a		 mov	 DWORD PTR [edx], ecx
  00586	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00589	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0058c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0058f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00592	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00595	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 250  :     colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);

  00598	51		 push	 ecx
  00599	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  005a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a6	51		 push	 ecx
  005a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e99999a
  005af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b4	51		 push	 ecx
  005b5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  005bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c2	51		 push	 ecx
  005c3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  005cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005d0	8d 8d 44 fc ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  005d6	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  005db	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  005e0	6b d1 0e	 imul	 edx, ecx, 14
  005e3	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  005e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  005e8	89 0a		 mov	 DWORD PTR [edx], ecx
  005ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005ed	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  005f0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005f3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  005f6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  005f9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 251  :     colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);

  005fc	51		 push	 ecx
  005fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e99999a
  00605	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0060a	51		 push	 ecx
  0060b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00613	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00618	51		 push	 ecx
  00619	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00621	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00626	51		 push	 ecx
  00627	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  0062f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00634	8d 8d 2c fc ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  0063a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0063f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00644	6b d1 0f	 imul	 edx, ecx, 15
  00647	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0064a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0064c	89 0a		 mov	 DWORD PTR [edx], ecx
  0064e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00651	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00654	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00657	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0065a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0065d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 252  :     colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);

  00660	51		 push	 ecx
  00661	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00669	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0066e	51		 push	 ecx
  0066f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00677	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0067c	51		 push	 ecx
  0067d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00685	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0068a	51		 push	 ecx
  0068b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00693	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00698	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  0069e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  006a3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  006a8	c1 e1 04	 shl	 ecx, 4
  006ab	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  006ae	8b 10		 mov	 edx, DWORD PTR [eax]
  006b0	89 11		 mov	 DWORD PTR [ecx], edx
  006b2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  006b5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  006b8	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  006bb	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  006be	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  006c1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 253  :     colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);

  006c4	51		 push	 ecx
  006c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  006cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006d2	51		 push	 ecx
  006d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  006db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006e0	51		 push	 ecx
  006e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  006e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ee	51		 push	 ecx
  006ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ed1eb85
  006f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006fc	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00702	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00707	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0070c	6b d1 11	 imul	 edx, ecx, 17
  0070f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00712	8b 08		 mov	 ecx, DWORD PTR [eax]
  00714	89 0a		 mov	 DWORD PTR [edx], ecx
  00716	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00719	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0071c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0071f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00722	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00725	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 254  :     colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);

  00728	51		 push	 ecx
  00729	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00731	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00736	51		 push	 ecx
  00737	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  0073f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00744	51		 push	 ecx
  00745	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  0074d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00752	51		 push	 ecx
  00753	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  0075b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00760	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00766	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0076b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00770	6b d1 12	 imul	 edx, ecx, 18
  00773	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00776	8b 08		 mov	 ecx, DWORD PTR [eax]
  00778	89 0a		 mov	 DWORD PTR [edx], ecx
  0077a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0077d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00780	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00783	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00786	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00789	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 255  :     colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);

  0078c	51		 push	 ecx
  0078d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e99999a
  00795	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0079a	51		 push	 ecx
  0079b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007a8	51		 push	 ecx
  007a9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007b6	51		 push	 ecx
  007b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007c4	8d 8d cc fb ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  007ca	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  007cf	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  007d4	6b d1 13	 imul	 edx, ecx, 19
  007d7	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  007da	8b 08		 mov	 ecx, DWORD PTR [eax]
  007dc	89 0a		 mov	 DWORD PTR [edx], ecx
  007de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  007e1	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  007e4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  007e7	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  007ea	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  007ed	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 256  :     colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);

  007f0	51		 push	 ecx
  007f1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  007f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007fe	51		 push	 ecx
  007ff	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00807	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0080c	51		 push	 ecx
  0080d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ec7ae14
  00815	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0081a	51		 push	 ecx
  0081b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ed1eb85
  00823	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00828	8d 8d b4 fb ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0082e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00833	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00838	6b d1 14	 imul	 edx, ecx, 20
  0083b	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0083e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00840	89 0a		 mov	 DWORD PTR [edx], ecx
  00842	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00845	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00848	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0084b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0084e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00851	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 257  :     colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);

  00854	51		 push	 ecx
  00855	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f1eb852
  0085d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00862	51		 push	 ecx
  00863	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f1c28f6
  0086b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00870	51		 push	 ecx
  00871	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00879	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0087e	51		 push	 ecx
  0087f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  00887	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0088c	8d 8d 9c fb ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00892	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00897	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0089c	6b d1 15	 imul	 edx, ecx, 21
  0089f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  008a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  008a4	89 0a		 mov	 DWORD PTR [edx], ecx
  008a6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  008a9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  008ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  008af	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  008b2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  008b5	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 258  :     colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);

  008b8	51		 push	 ecx
  008b9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4a3d71
  008c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c6	51		 push	 ecx
  008c7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f35c28f
  008cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d4	51		 push	 ecx
  008d5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ef5c28f
  008dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008e2	51		 push	 ecx
  008e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  008eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008f0	8d 8d 84 fb ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  008f6	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  008fb	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00900	6b d1 16	 imul	 edx, ecx, 22
  00903	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00906	8b 08		 mov	 ecx, DWORD PTR [eax]
  00908	89 0a		 mov	 DWORD PTR [edx], ecx
  0090a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0090d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00910	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00913	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00916	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00919	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 259  :     colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);

  0091c	51		 push	 ecx
  0091d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00925	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0092a	51		 push	 ecx
  0092b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00933	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00938	51		 push	 ecx
  00939	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  00941	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00946	51		 push	 ecx
  00947	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eeb851f
  0094f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00954	8d 8d 6c fb ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  0095a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0095f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00964	6b d1 17	 imul	 edx, ecx, 23
  00967	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0096a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0096c	89 0a		 mov	 DWORD PTR [edx], ecx
  0096e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00971	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00974	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00977	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0097a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0097d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 260  :     colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);

  00980	51		 push	 ecx
  00981	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ee66666
  00989	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0098e	51		 push	 ecx
  0098f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00997	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0099c	51		 push	 ecx
  0099d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  009a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009aa	51		 push	 ecx
  009ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  009b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009b8	8d 8d 54 fb ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  009be	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  009c3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  009c8	6b d1 18	 imul	 edx, ecx, 24
  009cb	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  009ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d0	89 0a		 mov	 DWORD PTR [edx], ecx
  009d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009d5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  009d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  009db	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  009de	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  009e1	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 261  :     colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);

  009e4	51		 push	 ecx
  009e5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  009ed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009f2	51		 push	 ecx
  009f3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  009fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a00	51		 push	 ecx
  00a01	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ee66666
  00a09	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a0e	51		 push	 ecx
  00a0f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ee66666
  00a17	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a1c	8d 8d 3c fb ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00a22	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00a27	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00a2c	6b d1 19	 imul	 edx, ecx, 25
  00a2f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00a32	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a34	89 0a		 mov	 DWORD PTR [edx], ecx
  00a36	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a39	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00a3c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a3f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00a42	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00a45	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 262  :     colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);

  00a48	51		 push	 ecx
  00a49	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00a51	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a56	51		 push	 ecx
  00a57	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f5eb852
  00a5f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a64	51		 push	 ecx
  00a65	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f07ae14
  00a6d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a72	51		 push	 ecx
  00a73	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f07ae14
  00a7b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a80	8d 8d 24 fb ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00a86	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00a8b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00a90	6b d1 1a	 imul	 edx, ecx, 26
  00a93	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00a96	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a98	89 0a		 mov	 DWORD PTR [edx], ecx
  00a9a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a9d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00aa0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00aa3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00aa6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00aa9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 263  :     colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 0.60f);

  00aac	51		 push	 ecx
  00aad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00ab5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00aba	51		 push	 ecx
  00abb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00ac3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ac8	51		 push	 ecx
  00ac9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00ad1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ad6	51		 push	 ecx
  00ad7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00adf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ae4	8d 8d 0c fb ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00aea	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00aef	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00af4	6b d1 1b	 imul	 edx, ecx, 27
  00af7	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00afa	8b 08		 mov	 ecx, DWORD PTR [eax]
  00afc	89 0a		 mov	 DWORD PTR [edx], ecx
  00afe	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b01	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b04	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b07	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b0a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b0d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 264  :     colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);

  00b10	51		 push	 ecx
  00b11	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b19	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b1e	51		 push	 ecx
  00b1f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00b27	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b2c	51		 push	 ecx
  00b2d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00b35	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b3a	51		 push	 ecx
  00b3b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00b43	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b48	8d 8d f4 fa ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00b4e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00b53	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00b58	6b d1 1c	 imul	 edx, ecx, 28
  00b5b	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00b5e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b60	89 0a		 mov	 DWORD PTR [edx], ecx
  00b62	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b65	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b68	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b6b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b6e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b71	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 265  :     colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);

  00b74	51		 push	 ecx
  00b75	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b7d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b82	51		 push	 ecx
  00b83	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00b8b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b90	51		 push	 ecx
  00b91	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00b99	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b9e	51		 push	 ecx
  00b9f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00ba7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bac	8d 8d dc fa ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00bb2	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00bb7	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00bbc	6b d1 1d	 imul	 edx, ecx, 29
  00bbf	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00bc2	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bc4	89 0a		 mov	 DWORD PTR [edx], ecx
  00bc6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bc9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00bcc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00bcf	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00bd2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00bd5	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 266  :     colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);

  00bd8	51		 push	 ecx
  00bd9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e23d70a
  00be1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00be6	51		 push	 ecx
  00be7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00bef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bf4	51		 push	 ecx
  00bf5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00bfd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c02	51		 push	 ecx
  00c03	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c0b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c10	8d 8d c4 fa ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00c16	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00c1b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00c20	6b d1 1e	 imul	 edx, ecx, 30
  00c23	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00c26	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c28	89 0a		 mov	 DWORD PTR [edx], ecx
  00c2a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c2d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c30	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c33	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c36	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c39	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 267  :     colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);

  00c3c	51		 push	 ecx
  00c3d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00c45	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c4a	51		 push	 ecx
  00c4b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c53	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c58	51		 push	 ecx
  00c59	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f51eb85
  00c61	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c66	51		 push	 ecx
  00c67	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f47ae14
  00c6f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c74	8d 8d ac fa ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00c7a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00c7f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00c84	6b d1 1f	 imul	 edx, ecx, 31
  00c87	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00c8a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c8c	89 0a		 mov	 DWORD PTR [edx], ecx
  00c8e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c91	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c94	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c97	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c9a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c9d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 268  :     colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);

  00ca0	51		 push	 ecx
  00ca1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00ca9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cae	51		 push	 ecx
  00caf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00cb7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cbc	51		 push	 ecx
  00cbd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f51eb85
  00cc5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cca	51		 push	 ecx
  00ccb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f47ae14
  00cd3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cd8	8d 8d 94 fa ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00cde	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00ce3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00ce8	c1 e1 05	 shl	 ecx, 5
  00ceb	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00cee	8b 10		 mov	 edx, DWORD PTR [eax]
  00cf0	89 11		 mov	 DWORD PTR [ecx], edx
  00cf2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00cf5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00cf8	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00cfb	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00cfe	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00d01	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 269  :     colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);

  00d04	51		 push	 ecx
  00d05	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00d0d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d12	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d17	6b c8 0b	 imul	 ecx, eax, 11
  00d1a	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d1d	51		 push	 ecx
  00d1e	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d23	6b c2 18	 imul	 eax, edx, 24
  00d26	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00d29	50		 push	 eax
  00d2a	8d 8d 7c fa ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00d30	51		 push	 ecx
  00d31	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00d36	83 c4 10	 add	 esp, 16			; 00000010H
  00d39	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d3e	6b ca 21	 imul	 ecx, edx, 33
  00d41	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d44	8b 10		 mov	 edx, DWORD PTR [eax]
  00d46	89 11		 mov	 DWORD PTR [ecx], edx
  00d48	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00d4b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00d4e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00d51	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00d54	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00d57	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 270  :     colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];

  00d5a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d5f	6b c8 19	 imul	 ecx, eax, 25
  00d62	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d65	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d6a	6b c2 22	 imul	 eax, edx, 34
  00d6d	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00d70	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d72	89 10		 mov	 DWORD PTR [eax], edx
  00d74	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00d77	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00d7a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00d7d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00d80	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00d83	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 271  :     colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

  00d86	51		 push	 ecx
  00d87	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00d8f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d94	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d99	6b c8 0b	 imul	 ecx, eax, 11
  00d9c	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d9f	51		 push	 ecx
  00da0	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00da5	6b c2 1a	 imul	 eax, edx, 26
  00da8	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00dab	50		 push	 eax
  00dac	8d 8d 64 fa ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00db2	51		 push	 ecx
  00db3	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00db8	83 c4 10	 add	 esp, 16			; 00000010H
  00dbb	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00dc0	6b ca 23	 imul	 ecx, edx, 35
  00dc3	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00dc6	8b 10		 mov	 edx, DWORD PTR [eax]
  00dc8	89 11		 mov	 DWORD PTR [ecx], edx
  00dca	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00dcd	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00dd0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00dd3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00dd6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00dd9	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 272  :     colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);

  00ddc	51		 push	 ecx
  00ddd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00de5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00dea	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00def	6b c8 0a	 imul	 ecx, eax, 10
  00df2	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00df5	51		 push	 ecx
  00df6	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00dfb	6b c2 21	 imul	 eax, edx, 33
  00dfe	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00e01	50		 push	 eax
  00e02	8d 8d 4c fa ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00e08	51		 push	 ecx
  00e09	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00e0e	83 c4 10	 add	 esp, 16			; 00000010H
  00e11	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e16	6b ca 24	 imul	 ecx, edx, 36
  00e19	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e1c	8b 10		 mov	 edx, DWORD PTR [eax]
  00e1e	89 11		 mov	 DWORD PTR [ecx], edx
  00e20	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e23	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00e26	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00e29	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00e2c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00e2f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 273  :     colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);

  00e32	51		 push	 ecx
  00e33	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00e3b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e40	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00e45	6b c8 0a	 imul	 ecx, eax, 10
  00e48	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e4b	51		 push	 ecx
  00e4c	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e51	6b c2 23	 imul	 eax, edx, 35
  00e54	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00e57	50		 push	 eax
  00e58	8d 8d 34 fa ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00e5e	51		 push	 ecx
  00e5f	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00e64	83 c4 10	 add	 esp, 16			; 00000010H
  00e67	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e6c	6b ca 25	 imul	 ecx, edx, 37
  00e6f	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e72	8b 10		 mov	 edx, DWORD PTR [eax]
  00e74	89 11		 mov	 DWORD PTR [ecx], edx
  00e76	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e79	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00e7c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00e7f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00e82	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00e85	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 274  :     colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

  00e88	51		 push	 ecx
  00e89	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e91	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e96	51		 push	 ecx
  00e97	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e9f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ea4	51		 push	 ecx
  00ea5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ead	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00eb2	51		 push	 ecx
  00eb3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ebb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ec0	8d 8d 1c fa ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00ec6	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00ecb	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00ed0	6b d1 26	 imul	 edx, ecx, 38
  00ed3	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00ed6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ed8	89 0a		 mov	 DWORD PTR [edx], ecx
  00eda	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00edd	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ee0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00ee3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00ee6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00ee9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 275  :     colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

  00eec	51		 push	 ecx
  00eed	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ef5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00efa	51		 push	 ecx
  00efb	0f 57 c0	 xorps	 xmm0, xmm0
  00efe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f03	51		 push	 ecx
  00f04	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00f0c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f11	51		 push	 ecx
  00f12	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00f1a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f1f	8d 8d 04 fa ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00f25	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00f2a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00f2f	6b d1 27	 imul	 edx, ecx, 39
  00f32	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00f35	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f37	89 0a		 mov	 DWORD PTR [edx], ecx
  00f39	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f3c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00f3f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f42	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00f45	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00f48	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 276  :     colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

  00f4b	51		 push	 ecx
  00f4c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00f54	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f59	51		 push	 ecx
  00f5a	0f 57 c0	 xorps	 xmm0, xmm0
  00f5d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f62	51		 push	 ecx
  00f63	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00f6b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f70	51		 push	 ecx
  00f71	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00f79	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f7e	8d 8d ec f9 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00f84	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00f89	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00f8e	6b d1 28	 imul	 edx, ecx, 40
  00f91	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00f94	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f96	89 0a		 mov	 DWORD PTR [edx], ecx
  00f98	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f9b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00f9e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00fa1	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00fa4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00fa7	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 277  :     colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);

  00faa	51		 push	 ecx
  00fab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00fb3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fb8	51		 push	 ecx
  00fb9	0f 57 c0	 xorps	 xmm0, xmm0
  00fbc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fc1	51		 push	 ecx
  00fc2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00fca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fcf	51		 push	 ecx
  00fd0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00fd8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fdd	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00fe3	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00fe8	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00fed	6b d1 29	 imul	 edx, ecx, 41
  00ff0	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00ff3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ff5	89 0a		 mov	 DWORD PTR [edx], ecx
  00ff7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ffa	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ffd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01000	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01003	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01006	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 278  :     colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);

  01009	51		 push	 ecx
  0100a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  01012	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01017	51		 push	 ecx
  01018	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01020	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01025	51		 push	 ecx
  01026	0f 57 c0	 xorps	 xmm0, xmm0
  01029	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0102e	51		 push	 ecx
  0102f	0f 57 c0	 xorps	 xmm0, xmm0
  01032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01037	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0103d	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01042	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  01047	6b d1 2a	 imul	 edx, ecx, 42
  0104a	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0104d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0104f	89 0a		 mov	 DWORD PTR [edx], ecx
  01051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01054	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01057	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0105a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0105d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01060	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 279  :     colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);

  01063	51		 push	 ecx
  01064	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  0106c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01071	51		 push	 ecx
  01072	0f 57 c0	 xorps	 xmm0, xmm0
  01075	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0107a	51		 push	 ecx
  0107b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01088	51		 push	 ecx
  01089	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01091	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01096	8d 8d a4 f9 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0109c	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  010a1	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  010a6	6b d1 2b	 imul	 edx, ecx, 43
  010a9	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  010ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  010ae	89 0a		 mov	 DWORD PTR [edx], ecx
  010b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  010b3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  010b6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  010b9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  010bc	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  010bf	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 280  :     colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];

  010c2	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  010c7	6b c8 19	 imul	 ecx, eax, 25
  010ca	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  010cd	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  010d2	6b c2 2c	 imul	 eax, edx, 44
  010d5	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  010d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  010da	89 10		 mov	 DWORD PTR [eax], edx
  010dc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  010df	89 50 04	 mov	 DWORD PTR [eax+4], edx
  010e2	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  010e5	89 50 08	 mov	 DWORD PTR [eax+8], edx
  010e8	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  010eb	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 281  :     colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);

  010ee	51		 push	 ecx
  010ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  010f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010fc	51		 push	 ecx
  010fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01105	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0110a	51		 push	 ecx
  0110b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01118	51		 push	 ecx
  01119	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01121	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01126	8d 8d 8c f9 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0112c	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01131	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  01136	6b d1 2d	 imul	 edx, ecx, 45
  01139	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0113c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0113e	89 0a		 mov	 DWORD PTR [edx], ecx
  01140	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01143	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01146	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01149	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0114c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0114f	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 282  :     colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);

  01152	51		 push	 ecx
  01153	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0115b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01160	51		 push	 ecx
  01161	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  01169	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0116e	51		 push	 ecx
  0116f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  01177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0117c	51		 push	 ecx
  0117d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  01185	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0118a	8d 8d 74 f9 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  01190	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01195	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0119a	6b d1 2e	 imul	 edx, ecx, 46
  0119d	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  011a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  011a2	89 0a		 mov	 DWORD PTR [edx], ecx
  011a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  011a7	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  011aa	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  011ad	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  011b0	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  011b3	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 283  :     colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);

  011b6	51		 push	 ecx
  011b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  011bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011c4	51		 push	 ecx
  011c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  011cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011d2	51		 push	 ecx
  011d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  011db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011e0	51		 push	 ecx
  011e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  011e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011ee	8d 8d 5c f9 ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  011f4	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  011f9	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  011fe	6b d1 2f	 imul	 edx, ecx, 47
  01201	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  01204	8b 08		 mov	 ecx, DWORD PTR [eax]
  01206	89 0a		 mov	 DWORD PTR [edx], ecx
  01208	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0120b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0120e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01211	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01214	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01217	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 284  : }

  0121a	5f		 pop	 edi
  0121b	5e		 pop	 esi
  0121c	5b		 pop	 ebx
  0121d	81 c4 ac 06 00
	00		 add	 esp, 1708		; 000006acH
  01223	3b ec		 cmp	 ebp, esp
  01225	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0122a	8b e5		 mov	 esp, ebp
  0122c	5d		 pop	 ebp
  0122d	c3		 ret	 0
?StyleColorsClassic@ImGui@@YAXPAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsClassic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui_draw.cpp
;	COMDAT ?StyleColorsDark@ImGui@@YAXPAUImGuiStyle@@@Z
_TEXT	SEGMENT
tv66 = -1708						; size = 4
$T1 = -1700						; size = 16
$T2 = -1676						; size = 16
$T3 = -1652						; size = 16
$T4 = -1628						; size = 16
$T5 = -1604						; size = 16
$T6 = -1580						; size = 16
$T7 = -1556						; size = 16
$T8 = -1532						; size = 16
$T9 = -1508						; size = 16
$T10 = -1484						; size = 16
$T11 = -1460						; size = 16
$T12 = -1436						; size = 16
$T13 = -1412						; size = 16
$T14 = -1388						; size = 16
$T15 = -1364						; size = 16
$T16 = -1340						; size = 16
$T17 = -1316						; size = 16
$T18 = -1292						; size = 16
$T19 = -1268						; size = 16
$T20 = -1244						; size = 16
$T21 = -1220						; size = 16
$T22 = -1196						; size = 16
$T23 = -1172						; size = 16
$T24 = -1148						; size = 16
$T25 = -1124						; size = 16
$T26 = -1100						; size = 16
$T27 = -1076						; size = 16
$T28 = -1052						; size = 16
$T29 = -1028						; size = 16
$T30 = -1004						; size = 16
$T31 = -980						; size = 16
$T32 = -956						; size = 16
$T33 = -932						; size = 16
$T34 = -908						; size = 16
$T35 = -884						; size = 16
$T36 = -860						; size = 16
$T37 = -836						; size = 16
$T38 = -812						; size = 16
$T39 = -788						; size = 16
$T40 = -764						; size = 16
$T41 = -740						; size = 16
$T42 = -716						; size = 16
$T43 = -692						; size = 16
$T44 = -668						; size = 16
$T45 = -644						; size = 16
$T46 = -620						; size = 16
_colors$ = -20						; size = 4
_style$ = -8						; size = 4
_dst$ = 8						; size = 4
?StyleColorsDark@ImGui@@YAXPAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsDark, COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 06 00
	00		 sub	 esp, 1708		; 000006acH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 54 f9 ff
	ff		 lea	 edi, DWORD PTR [ebp-1708]
  00012	b9 ab 01 00 00	 mov	 ecx, 427		; 000001abH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C693DA93_imgui_draw@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 178  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

  00028	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  0002c	74 0b		 je	 SHORT $LN3@StyleColor
  0002e	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00031	89 85 54 f9 ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00037	eb 0b		 jmp	 SHORT $LN4@StyleColor
$LN3@StyleColor:
  00039	e8 00 00 00 00	 call	 ?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ ; ImGui::GetStyle
  0003e	89 85 54 f9 ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
$LN4@StyleColor:
  00044	8b 8d 54 f9 ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  0004a	89 4d f8	 mov	 DWORD PTR _style$[ebp], ecx

; 179  :     ImVec4* colors = style->Colors;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _style$[ebp]
  00050	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  00055	89 45 ec	 mov	 DWORD PTR _colors$[ebp], eax

; 180  : 
; 181  :     colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

  00058	51		 push	 ecx
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	51		 push	 ecx
  00067	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	51		 push	 ecx
  00075	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0007d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00082	51		 push	 ecx
  00083	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	8d 8d 94 fd ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  00096	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0009b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  000a0	6b d1 00	 imul	 edx, ecx, 0
  000a3	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	89 0a		 mov	 DWORD PTR [edx], ecx
  000aa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ad	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000b0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000b6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000b9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 182  :     colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);

  000bc	51		 push	 ecx
  000bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	51		 push	 ecx
  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d8	51		 push	 ecx
  000d9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e6	51		 push	 ecx
  000e7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000ef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f4	8d 8d 7c fd ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  000fa	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  000ff	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00104	c1 e1 00	 shl	 ecx, 0
  00107	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0010a	8b 10		 mov	 edx, DWORD PTR [eax]
  0010c	89 11		 mov	 DWORD PTR [ecx], edx
  0010e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00111	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00114	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00117	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0011a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0011d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 183  :     colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);

  00120	51		 push	 ecx
  00121	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f70a3d7
  00129	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012e	51		 push	 ecx
  0012f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d75c28f
  00137	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013c	51		 push	 ecx
  0013d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d75c28f
  00145	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014a	51		 push	 ecx
  0014b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d75c28f
  00153	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00158	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  0015e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00163	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00168	d1 e1		 shl	 ecx, 1
  0016a	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0016d	8b 10		 mov	 edx, DWORD PTR [eax]
  0016f	89 11		 mov	 DWORD PTR [ecx], edx
  00171	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00174	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0017d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00180	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 184  :     colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  00183	51		 push	 ecx
  00184	0f 57 c0	 xorps	 xmm0, xmm0
  00187	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018c	51		 push	 ecx
  0018d	0f 57 c0	 xorps	 xmm0, xmm0
  00190	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00195	51		 push	 ecx
  00196	0f 57 c0	 xorps	 xmm0, xmm0
  00199	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019e	51		 push	 ecx
  0019f	0f 57 c0	 xorps	 xmm0, xmm0
  001a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a7	8d 8d 4c fd ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  001ad	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  001b2	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  001b7	6b d1 03	 imul	 edx, ecx, 3
  001ba	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  001bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bf	89 0a		 mov	 DWORD PTR [edx], ecx
  001c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001c7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001ca	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  001cd	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001d0	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 185  :     colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);

  001d3	51		 push	 ecx
  001d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f70a3d7
  001dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e1	51		 push	 ecx
  001e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3da3d70a
  001ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ef	51		 push	 ecx
  001f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3da3d70a
  001f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fd	51		 push	 ecx
  001fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3da3d70a
  00206	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020b	8d 8d 34 fd ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  00211	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00216	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0021b	c1 e1 02	 shl	 ecx, 2
  0021e	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00221	8b 10		 mov	 edx, DWORD PTR [eax]
  00223	89 11		 mov	 DWORD PTR [ecx], edx
  00225	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00228	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0022b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0022e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00231	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00234	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 186  :     colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);

  00237	51		 push	 ecx
  00238	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00240	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00245	51		 push	 ecx
  00246	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0024e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00253	51		 push	 ecx
  00254	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3edc28f6
  0025c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00261	51		 push	 ecx
  00262	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3edc28f6
  0026a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026f	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  00275	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0027a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0027f	6b d1 05	 imul	 edx, ecx, 5
  00282	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00285	8b 08		 mov	 ecx, DWORD PTR [eax]
  00287	89 0a		 mov	 DWORD PTR [edx], ecx
  00289	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0028c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0028f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00292	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00295	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00298	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 187  :     colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  0029b	51		 push	 ecx
  0029c	0f 57 c0	 xorps	 xmm0, xmm0
  0029f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a4	51		 push	 ecx
  002a5	0f 57 c0	 xorps	 xmm0, xmm0
  002a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ad	51		 push	 ecx
  002ae	0f 57 c0	 xorps	 xmm0, xmm0
  002b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b6	51		 push	 ecx
  002b7	0f 57 c0	 xorps	 xmm0, xmm0
  002ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002bf	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR $T40[ebp]
  002c5	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  002ca	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  002cf	6b d1 06	 imul	 edx, ecx, 6
  002d2	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  002d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d7	89 0a		 mov	 DWORD PTR [edx], ecx
  002d9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002dc	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002df	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002e2	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  002e5	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002e8	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 188  :     colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);

  002eb	51		 push	 ecx
  002ec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f0a3d71
  002f4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002f9	51		 push	 ecx
  002fa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ef5c28f
  00302	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00307	51		 push	 ecx
  00308	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e947ae1
  00310	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00315	51		 push	 ecx
  00316	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e23d70a
  0031e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00323	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  00329	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0032e	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00333	6b d1 07	 imul	 edx, ecx, 7
  00336	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00339	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033b	89 0a		 mov	 DWORD PTR [edx], ecx
  0033d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00340	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00343	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00346	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00349	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0034c	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 189  :     colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

  0034f	51		 push	 ecx
  00350	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00358	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035d	51		 push	 ecx
  0035e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00366	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036b	51		 push	 ecx
  0036c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00374	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00379	51		 push	 ecx
  0037a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00382	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00387	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  0038d	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00392	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00397	c1 e1 03	 shl	 ecx, 3
  0039a	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  0039d	8b 10		 mov	 edx, DWORD PTR [eax]
  0039f	89 11		 mov	 DWORD PTR [ecx], edx
  003a1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003a4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  003a7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  003aa	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  003ad	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  003b0	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 190  :     colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

  003b3	51		 push	 ecx
  003b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f2b851f
  003bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c1	51		 push	 ecx
  003c2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  003ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cf	51		 push	 ecx
  003d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  003d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003dd	51		 push	 ecx
  003de	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  003e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003eb	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR $T37[ebp]
  003f1	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  003f6	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  003fb	6b d1 09	 imul	 edx, ecx, 9
  003fe	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00401	8b 08		 mov	 ecx, DWORD PTR [eax]
  00403	89 0a		 mov	 DWORD PTR [edx], ecx
  00405	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00408	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0040b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0040e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00411	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00414	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 191  :     colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);

  00417	51		 push	 ecx
  00418	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00420	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00425	51		 push	 ecx
  00426	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d23d70a
  0042e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00433	51		 push	 ecx
  00434	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d23d70a
  0043c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00441	51		 push	 ecx
  00442	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d23d70a
  0044a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0044f	8d 8d a4 fc ff
	ff		 lea	 ecx, DWORD PTR $T36[ebp]
  00455	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0045a	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0045f	6b d1 0a	 imul	 edx, ecx, 10
  00462	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00465	8b 08		 mov	 ecx, DWORD PTR [eax]
  00467	89 0a		 mov	 DWORD PTR [edx], ecx
  00469	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0046c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0046f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00472	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00475	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00478	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 192  :     colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);

  0047b	51		 push	 ecx
  0047c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00484	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00489	51		 push	 ecx
  0048a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ef5c28f
  00492	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00497	51		 push	 ecx
  00498	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e947ae1
  004a0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004a5	51		 push	 ecx
  004a6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e23d70a
  004ae	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004b3	8d 8d 8c fc ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  004b9	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  004be	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  004c3	6b d1 0b	 imul	 edx, ecx, 11
  004c6	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  004c9	8b 08		 mov	 ecx, DWORD PTR [eax]
  004cb	89 0a		 mov	 DWORD PTR [edx], ecx
  004cd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004d0	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  004d3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  004d6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  004d9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  004dc	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 193  :     colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);

  004df	51		 push	 ecx
  004e0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f028f5c
  004e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ed	51		 push	 ecx
  004ee	0f 57 c0	 xorps	 xmm0, xmm0
  004f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004f6	51		 push	 ecx
  004f7	0f 57 c0	 xorps	 xmm0, xmm0
  004fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ff	51		 push	 ecx
  00500	0f 57 c0	 xorps	 xmm0, xmm0
  00503	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00508	8d 8d 74 fc ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  0050e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00513	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00518	6b d1 0c	 imul	 edx, ecx, 12
  0051b	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0051e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00520	89 0a		 mov	 DWORD PTR [edx], ecx
  00522	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00525	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00528	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0052b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0052e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00531	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 194  :     colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);

  00534	51		 push	 ecx
  00535	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0053d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00542	51		 push	 ecx
  00543	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e0f5c29
  0054b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00550	51		 push	 ecx
  00551	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e0f5c29
  00559	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055e	51		 push	 ecx
  0055f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e0f5c29
  00567	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0056c	8d 8d 5c fc ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00572	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00577	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0057c	6b d1 0d	 imul	 edx, ecx, 13
  0057f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00582	8b 08		 mov	 ecx, DWORD PTR [eax]
  00584	89 0a		 mov	 DWORD PTR [edx], ecx
  00586	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00589	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0058c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0058f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00592	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00595	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 195  :     colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);

  00598	51		 push	 ecx
  00599	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f07ae14
  005a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005a6	51		 push	 ecx
  005a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ca3d70a
  005af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005b4	51		 push	 ecx
  005b5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ca3d70a
  005bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c2	51		 push	 ecx
  005c3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ca3d70a
  005cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005d0	8d 8d 44 fc ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  005d6	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  005db	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  005e0	6b d1 0e	 imul	 edx, ecx, 14
  005e3	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  005e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  005e8	89 0a		 mov	 DWORD PTR [edx], ecx
  005ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005ed	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  005f0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  005f3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  005f6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  005f9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 196  :     colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);

  005fc	51		 push	 ecx
  005fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00605	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0060a	51		 push	 ecx
  0060b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e9eb852
  00613	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00618	51		 push	 ecx
  00619	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e9eb852
  00621	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00626	51		 push	 ecx
  00627	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e9eb852
  0062f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00634	8d 8d 2c fc ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  0063a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0063f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00644	6b d1 0f	 imul	 edx, ecx, 15
  00647	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0064a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0064c	89 0a		 mov	 DWORD PTR [edx], ecx
  0064e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00651	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00654	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00657	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0065a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0065d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 197  :     colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);

  00660	51		 push	 ecx
  00661	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00669	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0066e	51		 push	 ecx
  0066f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ed1eb85
  00677	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0067c	51		 push	 ecx
  0067d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ed1eb85
  00685	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0068a	51		 push	 ecx
  0068b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ed1eb85
  00693	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00698	8d 8d 14 fc ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  0069e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  006a3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  006a8	c1 e1 04	 shl	 ecx, 4
  006ab	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  006ae	8b 10		 mov	 edx, DWORD PTR [eax]
  006b0	89 11		 mov	 DWORD PTR [ecx], edx
  006b2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  006b5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  006b8	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  006bb	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  006be	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  006c1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 198  :     colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);

  006c4	51		 push	 ecx
  006c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006d2	51		 push	 ecx
  006d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f028f5c
  006db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006e0	51		 push	 ecx
  006e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f028f5c
  006e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ee	51		 push	 ecx
  006ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f028f5c
  006f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006fc	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00702	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00707	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0070c	6b d1 11	 imul	 edx, ecx, 17
  0070f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00712	8b 08		 mov	 ecx, DWORD PTR [eax]
  00714	89 0a		 mov	 DWORD PTR [edx], ecx
  00716	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00719	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0071c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0071f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00722	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00725	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 199  :     colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  00728	51		 push	 ecx
  00729	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00731	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00736	51		 push	 ecx
  00737	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  0073f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00744	51		 push	 ecx
  00745	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  0074d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00752	51		 push	 ecx
  00753	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  0075b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00760	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00766	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0076b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00770	6b d1 12	 imul	 edx, ecx, 18
  00773	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00776	8b 08		 mov	 ecx, DWORD PTR [eax]
  00778	89 0a		 mov	 DWORD PTR [edx], ecx
  0077a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0077d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00780	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00783	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00786	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00789	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 200  :     colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);

  0078c	51		 push	 ecx
  0078d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00795	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0079a	51		 push	 ecx
  0079b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f6147ae
  007a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007a8	51		 push	 ecx
  007a9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f051eb8
  007b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007b6	51		 push	 ecx
  007b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e75c28f
  007bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007c4	8d 8d cc fb ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  007ca	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  007cf	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  007d4	6b d1 13	 imul	 edx, ecx, 19
  007d7	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  007da	8b 08		 mov	 ecx, DWORD PTR [eax]
  007dc	89 0a		 mov	 DWORD PTR [edx], ecx
  007de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  007e1	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  007e4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  007e7	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  007ea	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  007ed	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 201  :     colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  007f0	51		 push	 ecx
  007f1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  007f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007fe	51		 push	 ecx
  007ff	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00807	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0080c	51		 push	 ecx
  0080d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00815	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0081a	51		 push	 ecx
  0081b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00823	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00828	8d 8d b4 fb ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0082e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00833	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00838	6b d1 14	 imul	 edx, ecx, 20
  0083b	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0083e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00840	89 0a		 mov	 DWORD PTR [edx], ecx
  00842	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00845	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00848	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0084b	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0084e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00851	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 202  :     colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

  00854	51		 push	 ecx
  00855	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  0085d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00862	51		 push	 ecx
  00863	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  0086b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00870	51		 push	 ecx
  00871	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00879	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0087e	51		 push	 ecx
  0087f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00887	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0088c	8d 8d 9c fb ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00892	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00897	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0089c	6b d1 15	 imul	 edx, ecx, 21
  0089f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  008a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  008a4	89 0a		 mov	 DWORD PTR [edx], ecx
  008a6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  008a9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  008ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  008af	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  008b2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  008b5	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 203  :     colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  008b8	51		 push	 ecx
  008b9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008c6	51		 push	 ecx
  008c7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  008cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008d4	51		 push	 ecx
  008d5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  008dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008e2	51		 push	 ecx
  008e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  008eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008f0	8d 8d 84 fb ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  008f6	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  008fb	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00900	6b d1 16	 imul	 edx, ecx, 22
  00903	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00906	8b 08		 mov	 ecx, DWORD PTR [eax]
  00908	89 0a		 mov	 DWORD PTR [edx], ecx
  0090a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0090d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00910	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00913	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00916	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00919	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 204  :     colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);

  0091c	51		 push	 ecx
  0091d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00925	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0092a	51		 push	 ecx
  0092b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00933	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00938	51		 push	 ecx
  00939	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f07ae14
  00941	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00946	51		 push	 ecx
  00947	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d75c28f
  0094f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00954	8d 8d 6c fb ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  0095a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  0095f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00964	6b d1 17	 imul	 edx, ecx, 23
  00967	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0096a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0096c	89 0a		 mov	 DWORD PTR [edx], ecx
  0096e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00971	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00974	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00977	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0097a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0097d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 205  :     colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);

  00980	51		 push	 ecx
  00981	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e9eb852
  00989	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0098e	51		 push	 ecx
  0098f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00997	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0099c	51		 push	 ecx
  0099d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  009a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009aa	51		 push	 ecx
  009ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  009b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009b8	8d 8d 54 fb ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  009be	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  009c3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  009c8	6b d1 18	 imul	 edx, ecx, 24
  009cb	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  009ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d0	89 0a		 mov	 DWORD PTR [edx], ecx
  009d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  009d5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  009d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  009db	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  009de	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  009e1	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 206  :     colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);

  009e4	51		 push	 ecx
  009e5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  009ed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009f2	51		 push	 ecx
  009f3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  009fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a00	51		 push	 ecx
  00a01	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00a09	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a0e	51		 push	 ecx
  00a0f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00a17	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a1c	8d 8d 3c fb ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00a22	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00a27	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00a2c	6b d1 19	 imul	 edx, ecx, 25
  00a2f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00a32	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a34	89 0a		 mov	 DWORD PTR [edx], ecx
  00a36	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a39	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00a3c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a3f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00a42	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00a45	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 207  :     colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  00a48	51		 push	 ecx
  00a49	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a51	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a56	51		 push	 ecx
  00a57	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00a5f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a64	51		 push	 ecx
  00a65	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00a6d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a72	51		 push	 ecx
  00a73	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00a7b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a80	8d 8d 24 fb ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00a86	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00a8b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00a90	6b d1 1a	 imul	 edx, ecx, 26
  00a93	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00a96	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a98	89 0a		 mov	 DWORD PTR [edx], ecx
  00a9a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00a9d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00aa0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00aa3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00aa6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00aa9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 208  :     colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];

  00aac	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00ab1	6b c8 05	 imul	 ecx, eax, 5
  00ab4	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00ab7	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00abc	6b c2 1b	 imul	 eax, edx, 27
  00abf	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00ac2	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ac4	89 10		 mov	 DWORD PTR [eax], edx
  00ac6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00ac9	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00acc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00acf	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00ad2	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00ad5	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 209  :     colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);

  00ad8	51		 push	 ecx
  00ad9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f47ae14
  00ae1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ae6	51		 push	 ecx
  00ae7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f400000
  00aef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00af4	51		 push	 ecx
  00af5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00afd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b02	51		 push	 ecx
  00b03	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00b0b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b10	8d 8d 0c fb ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00b16	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00b1b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00b20	6b d1 1c	 imul	 edx, ecx, 28
  00b23	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00b26	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b28	89 0a		 mov	 DWORD PTR [edx], ecx
  00b2a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b2d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b30	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b33	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b36	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b39	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 210  :     colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);

  00b3c	51		 push	 ecx
  00b3d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b45	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b4a	51		 push	 ecx
  00b4b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f400000
  00b53	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b58	51		 push	 ecx
  00b59	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00b61	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b66	51		 push	 ecx
  00b67	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00b6f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b74	8d 8d f4 fa ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00b7a	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00b7f	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00b84	6b d1 1d	 imul	 edx, ecx, 29
  00b87	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00b8a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b8c	89 0a		 mov	 DWORD PTR [edx], ecx
  00b8e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b91	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00b94	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00b97	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00b9a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00b9d	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 211  :     colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);

  00ba0	51		 push	 ecx
  00ba1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  00ba9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bae	51		 push	 ecx
  00baf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00bb7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bbc	51		 push	 ecx
  00bbd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00bc5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bca	51		 push	 ecx
  00bcb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00bd3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00bd8	8d 8d dc fa ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00bde	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00be3	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00be8	6b d1 1e	 imul	 edx, ecx, 30
  00beb	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00bee	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bf0	89 0a		 mov	 DWORD PTR [edx], ecx
  00bf2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bf5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00bf8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00bfb	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00bfe	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c01	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 212  :     colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

  00c04	51		 push	 ecx
  00c05	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f2b851f
  00c0d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c12	51		 push	 ecx
  00c13	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00c1b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c20	51		 push	 ecx
  00c21	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00c29	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c2e	51		 push	 ecx
  00c2f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00c37	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c3c	8d 8d c4 fa ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00c42	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00c47	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00c4c	6b d1 1f	 imul	 edx, ecx, 31
  00c4f	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00c52	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c54	89 0a		 mov	 DWORD PTR [edx], ecx
  00c56	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c59	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00c5c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c5f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00c62	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00c65	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 213  :     colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

  00c68	51		 push	 ecx
  00c69	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f733333
  00c71	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c76	51		 push	 ecx
  00c77	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00c7f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c84	51		 push	 ecx
  00c85	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00c8d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c92	51		 push	 ecx
  00c93	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  00c9b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ca0	8d 8d ac fa ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00ca6	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00cab	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00cb0	c1 e1 05	 shl	 ecx, 5
  00cb3	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00cb6	8b 10		 mov	 edx, DWORD PTR [eax]
  00cb8	89 11		 mov	 DWORD PTR [ecx], edx
  00cba	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00cbd	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00cc0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00cc3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00cc6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00cc9	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 214  :     colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);

  00ccc	51		 push	 ecx
  00ccd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00cd5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00cda	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00cdf	6b c8 0b	 imul	 ecx, eax, 11
  00ce2	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00ce5	51		 push	 ecx
  00ce6	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00ceb	6b c2 18	 imul	 eax, edx, 24
  00cee	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00cf1	50		 push	 eax
  00cf2	8d 8d 94 fa ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00cf8	51		 push	 ecx
  00cf9	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00cfe	83 c4 10	 add	 esp, 16			; 00000010H
  00d01	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d06	6b ca 21	 imul	 ecx, edx, 33
  00d09	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d0c	8b 10		 mov	 edx, DWORD PTR [eax]
  00d0e	89 11		 mov	 DWORD PTR [ecx], edx
  00d10	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00d13	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00d16	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00d19	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00d1c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00d1f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 215  :     colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];

  00d22	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d27	6b c8 19	 imul	 ecx, eax, 25
  00d2a	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d2d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d32	6b c2 22	 imul	 eax, edx, 34
  00d35	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00d38	8b 11		 mov	 edx, DWORD PTR [ecx]
  00d3a	89 10		 mov	 DWORD PTR [eax], edx
  00d3c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00d3f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00d42	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00d45	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00d48	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00d4b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 216  :     colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

  00d4e	51		 push	 ecx
  00d4f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00d57	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00d5c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00d61	6b c8 0b	 imul	 ecx, eax, 11
  00d64	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d67	51		 push	 ecx
  00d68	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d6d	6b c2 1a	 imul	 eax, edx, 26
  00d70	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00d73	50		 push	 eax
  00d74	8d 8d 7c fa ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00d7a	51		 push	 ecx
  00d7b	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00d80	83 c4 10	 add	 esp, 16			; 00000010H
  00d83	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00d88	6b ca 23	 imul	 ecx, edx, 35
  00d8b	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00d8e	8b 10		 mov	 edx, DWORD PTR [eax]
  00d90	89 11		 mov	 DWORD PTR [ecx], edx
  00d92	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00d95	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00d98	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00d9b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00d9e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00da1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 217  :     colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);

  00da4	51		 push	 ecx
  00da5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00dad	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00db2	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00db7	6b c8 0a	 imul	 ecx, eax, 10
  00dba	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00dbd	51		 push	 ecx
  00dbe	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00dc3	6b c2 21	 imul	 eax, edx, 33
  00dc6	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00dc9	50		 push	 eax
  00dca	8d 8d 64 fa ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00dd0	51		 push	 ecx
  00dd1	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00dd6	83 c4 10	 add	 esp, 16			; 00000010H
  00dd9	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00dde	6b ca 24	 imul	 ecx, edx, 36
  00de1	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00de4	8b 10		 mov	 edx, DWORD PTR [eax]
  00de6	89 11		 mov	 DWORD PTR [ecx], edx
  00de8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00deb	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00dee	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00df1	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00df4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00df7	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 218  :     colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);

  00dfa	51		 push	 ecx
  00dfb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00e03	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e08	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00e0d	6b c8 0a	 imul	 ecx, eax, 10
  00e10	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e13	51		 push	 ecx
  00e14	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e19	6b c2 23	 imul	 eax, edx, 35
  00e1c	03 45 ec	 add	 eax, DWORD PTR _colors$[ebp]
  00e1f	50		 push	 eax
  00e20	8d 8d 4c fa ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00e26	51		 push	 ecx
  00e27	e8 00 00 00 00	 call	 ?ImLerp@@YA?AUImVec4@@ABU1@0M@Z ; ImLerp
  00e2c	83 c4 10	 add	 esp, 16			; 00000010H
  00e2f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00e34	6b ca 25	 imul	 ecx, edx, 37
  00e37	03 4d ec	 add	 ecx, DWORD PTR _colors$[ebp]
  00e3a	8b 10		 mov	 edx, DWORD PTR [eax]
  00e3c	89 11		 mov	 DWORD PTR [ecx], edx
  00e3e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00e41	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00e44	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00e47	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00e4a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00e4d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 219  :     colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);

  00e50	51		 push	 ecx
  00e51	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e59	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e5e	51		 push	 ecx
  00e5f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f1c28f6
  00e67	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e6c	51		 push	 ecx
  00e6d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f1c28f6
  00e75	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e7a	51		 push	 ecx
  00e7b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f1c28f6
  00e83	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e88	8d 8d 34 fa ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00e8e	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00e93	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00e98	6b d1 26	 imul	 edx, ecx, 38
  00e9b	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00e9e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ea0	89 0a		 mov	 DWORD PTR [edx], ecx
  00ea2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ea5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00ea8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00eab	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00eae	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00eb1	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 220  :     colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);

  00eb4	51		 push	 ecx
  00eb5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ebd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ec2	51		 push	 ecx
  00ec3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  00ecb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ed0	51		 push	 ecx
  00ed1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3edc28f6
  00ed9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ede	51		 push	 ecx
  00edf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ee7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00eec	8d 8d 1c fa ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00ef2	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00ef7	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00efc	6b d1 27	 imul	 edx, ecx, 39
  00eff	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00f02	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f04	89 0a		 mov	 DWORD PTR [edx], ecx
  00f06	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f09	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00f0c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f0f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00f12	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00f15	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 221  :     colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

  00f18	51		 push	 ecx
  00f19	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00f21	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f26	51		 push	 ecx
  00f27	0f 57 c0	 xorps	 xmm0, xmm0
  00f2a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f2f	51		 push	 ecx
  00f30	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  00f38	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f3d	51		 push	 ecx
  00f3e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  00f46	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f4b	8d 8d 04 fa ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00f51	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00f56	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00f5b	6b d1 28	 imul	 edx, ecx, 40
  00f5e	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00f61	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f63	89 0a		 mov	 DWORD PTR [edx], ecx
  00f65	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f68	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00f6b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f6e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00f71	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00f74	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 222  :     colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);

  00f77	51		 push	 ecx
  00f78	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00f80	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f85	51		 push	 ecx
  00f86	0f 57 c0	 xorps	 xmm0, xmm0
  00f89	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f8e	51		 push	 ecx
  00f8f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f19999a
  00f97	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00f9c	51		 push	 ecx
  00f9d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00fa5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00faa	8d 8d ec f9 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00fb0	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  00fb5	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00fba	6b d1 29	 imul	 edx, ecx, 41
  00fbd	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  00fc0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fc2	89 0a		 mov	 DWORD PTR [edx], ecx
  00fc4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00fc7	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00fca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00fcd	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00fd0	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00fd3	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 223  :     colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);

  00fd6	51		 push	 ecx
  00fd7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  00fdf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00fe4	51		 push	 ecx
  00fe5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  00fed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00ff2	51		 push	 ecx
  00ff3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  00ffb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01000	51		 push	 ecx
  01001	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  01009	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0100e	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  01014	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01019	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0101e	6b d1 2a	 imul	 edx, ecx, 42
  01021	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  01024	8b 08		 mov	 ecx, DWORD PTR [eax]
  01026	89 0a		 mov	 DWORD PTR [edx], ecx
  01028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0102b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0102e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01031	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01034	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01037	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 224  :     colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);

  0103a	51		 push	 ecx
  0103b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f666666
  01043	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01048	51		 push	 ecx
  01049	0f 57 c0	 xorps	 xmm0, xmm0
  0104c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01051	51		 push	 ecx
  01052	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0105a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0105f	51		 push	 ecx
  01060	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01068	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0106d	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  01073	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01078	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0107d	6b d1 2b	 imul	 edx, ecx, 43
  01080	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  01083	8b 08		 mov	 ecx, DWORD PTR [eax]
  01085	89 0a		 mov	 DWORD PTR [edx], ecx
  01087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0108a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0108d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01090	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01093	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01096	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 225  :     colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  01099	51		 push	 ecx
  0109a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  010a2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010a7	51		 push	 ecx
  010a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f7ae148
  010b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010b5	51		 push	 ecx
  010b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f170a3d
  010be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010c3	51		 push	 ecx
  010c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e851eb8
  010cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  010d1	8d 8d a4 f9 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  010d7	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  010dc	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  010e1	6b d1 2c	 imul	 edx, ecx, 44
  010e4	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  010e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  010e9	89 0a		 mov	 DWORD PTR [edx], ecx
  010eb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  010ee	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  010f1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  010f4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  010f7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  010fa	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 226  :     colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);

  010fd	51		 push	 ecx
  010fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f333333
  01106	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0110b	51		 push	 ecx
  0110c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01114	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01119	51		 push	 ecx
  0111a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01122	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01127	51		 push	 ecx
  01128	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01130	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01135	8d 8d 8c f9 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0113b	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01140	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  01145	6b d1 2d	 imul	 edx, ecx, 45
  01148	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  0114b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0114d	89 0a		 mov	 DWORD PTR [edx], ecx
  0114f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01152	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01155	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01158	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0115b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0115e	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 227  :     colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);

  01161	51		 push	 ecx
  01162	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0116a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0116f	51		 push	 ecx
  01170	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  01178	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0117d	51		 push	 ecx
  0117e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  01186	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0118b	51		 push	 ecx
  0118c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  01194	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01199	8d 8d 74 f9 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0119f	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  011a4	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  011a9	6b d1 2e	 imul	 edx, ecx, 46
  011ac	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  011af	8b 08		 mov	 ecx, DWORD PTR [eax]
  011b1	89 0a		 mov	 DWORD PTR [edx], ecx
  011b3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  011b6	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  011b9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  011bc	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  011bf	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  011c2	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 228  :     colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);

  011c5	51		 push	 ecx
  011c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3eb33333
  011ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011d3	51		 push	 ecx
  011d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  011dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011e1	51		 push	 ecx
  011e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  011ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011ef	51		 push	 ecx
  011f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  011f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011fd	8d 8d 5c f9 ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  01203	e8 00 00 00 00	 call	 ??0ImVec4@@QAE@MMMM@Z	; ImVec4::ImVec4
  01208	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0120d	6b d1 2f	 imul	 edx, ecx, 47
  01210	03 55 ec	 add	 edx, DWORD PTR _colors$[ebp]
  01213	8b 08		 mov	 ecx, DWORD PTR [eax]
  01215	89 0a		 mov	 DWORD PTR [edx], ecx
  01217	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0121a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0121d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01220	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01223	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01226	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 229  : }

  01229	5f		 pop	 edi
  0122a	5e		 pop	 esi
  0122b	5b		 pop	 ebx
  0122c	81 c4 ac 06 00
	00		 add	 esp, 1708		; 000006acH
  01232	3b ec		 cmp	 ebp, esp
  01234	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01239	8b e5		 mov	 esp, ebp
  0123b	5d		 pop	 ebp
  0123c	c3		 ret	 0
?StyleColorsDark@ImGui@@YAXPAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsDark
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0ImVec4@@QAE@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 200  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __x$[ebp]
  00035	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __y$[ebp]
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR __z$[ebp]
  0004e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR __w$[ebp]
  0005b	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 10 00	 ret	 16			; 00000010H
??0ImVec4@@QAE@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImVec4@@QAE@XZ PROC					; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 199  :     ImVec4()  { x = y = z = w = 0.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00043	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00046	0f 57 c0	 xorps	 xmm0, xmm0
  00049	f3 0f 11 42 04	 movss	 DWORD PTR [edx+4], xmm0
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??0ImVec4@@QAE@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 187  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __x$[ebp]
  00035	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR __y$[ebp]
  00041	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Programmieren\csgoHack\ProjektWolf\ImGui DirectX 9 Kiero Hook 2\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ImVec2@@QAE@XZ PROC					; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 186  :     ImVec2()  { x = y = 0.0f; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __42049807_imgui@h
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??0ImVec2@@QAE@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv67 = -200						; size = 4
tv66 = -196						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
$LN2@vector:
  0001e	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00021	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0002a	83 e9 01	 sub	 ecx, 1
  0002d	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00030	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv66[ebp], 0
  00037	76 0c		 jbe	 SHORT $LN5@vector
  00039	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv67[ebp], 1
  00043	eb 0a		 jmp	 SHORT $LN6@vector
$LN5@vector:
  00045	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
$LN6@vector:
  0004f	83 bd 38 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  00056	74 1a		 je	 SHORT $LN1@vector
  00058	8b f4		 mov	 esi, esp
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0005d	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  0006a	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  0006d	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00070	eb ac		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
